from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_imagebuilder.CfnContainerRecipe.ComponentConfigurationProperty
class CfnContainerRecipe_ComponentConfigurationPropertyDef(BaseStruct):
    component_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the component.\n')
    parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnContainerRecipe_ComponentParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A group of parameter settings that Image Builder uses to configure the component for a specific recipe.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-containerrecipe-componentconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    component_configuration_property = imagebuilder.CfnContainerRecipe.ComponentConfigurationProperty(\n        component_arn="componentArn",\n        parameters=[imagebuilder.CfnContainerRecipe.ComponentParameterProperty(\n            name="name",\n            value=["value"]\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['component_arn', 'parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnContainerRecipe.ComponentConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnContainerRecipe.ComponentParameterProperty
class CfnContainerRecipe_ComponentParameterPropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the component parameter to set.\n')
    value: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Sets the value for the named component parameter.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-containerrecipe-componentparameter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    component_parameter_property = imagebuilder.CfnContainerRecipe.ComponentParameterProperty(\n        name="name",\n        value=["value"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnContainerRecipe.ComponentParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnContainerRecipe.EbsInstanceBlockDeviceSpecificationProperty
class CfnContainerRecipe_EbsInstanceBlockDeviceSpecificationPropertyDef(BaseStruct):
    delete_on_termination: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Use to configure delete on termination of the associated device.\n')
    encrypted: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Use to configure device encryption.\n')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='Use to configure device IOPS.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='Use to configure the KMS key to use when encrypting the device.\n')
    snapshot_id: typing.Optional[str] = pydantic.Field(None, description='The snapshot that defines the device contents.\n')
    throughput: typing.Union[int, float, None] = pydantic.Field(None, description='*For GP3 volumes only* â€“ The throughput in MiB/s that the volume supports.\n')
    volume_size: typing.Union[int, float, None] = pydantic.Field(None, description="Use to override the device's volume size.\n")
    volume_type: typing.Optional[str] = pydantic.Field(None, description='Use to override the device\'s volume type.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-containerrecipe-ebsinstanceblockdevicespecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    ebs_instance_block_device_specification_property = imagebuilder.CfnContainerRecipe.EbsInstanceBlockDeviceSpecificationProperty(\n        delete_on_termination=False,\n        encrypted=False,\n        iops=123,\n        kms_key_id="kmsKeyId",\n        snapshot_id="snapshotId",\n        throughput=123,\n        volume_size=123,\n        volume_type="volumeType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['delete_on_termination', 'encrypted', 'iops', 'kms_key_id', 'snapshot_id', 'throughput', 'volume_size', 'volume_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnContainerRecipe.EbsInstanceBlockDeviceSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnContainerRecipe.InstanceBlockDeviceMappingProperty
class CfnContainerRecipe_InstanceBlockDeviceMappingPropertyDef(BaseStruct):
    device_name: typing.Optional[str] = pydantic.Field(None, description='The device to which these mappings apply.\n')
    ebs: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnContainerRecipe_EbsInstanceBlockDeviceSpecificationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Use to manage Amazon EBS-specific configuration for this mapping.\n')
    no_device: typing.Optional[str] = pydantic.Field(None, description='Use to remove a mapping from the base image.\n')
    virtual_name: typing.Optional[str] = pydantic.Field(None, description='Use to manage instance ephemeral devices.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-containerrecipe-instanceblockdevicemapping.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    instance_block_device_mapping_property = imagebuilder.CfnContainerRecipe.InstanceBlockDeviceMappingProperty(\n        device_name="deviceName",\n        ebs=imagebuilder.CfnContainerRecipe.EbsInstanceBlockDeviceSpecificationProperty(\n            delete_on_termination=False,\n            encrypted=False,\n            iops=123,\n            kms_key_id="kmsKeyId",\n            snapshot_id="snapshotId",\n            throughput=123,\n            volume_size=123,\n            volume_type="volumeType"\n        ),\n        no_device="noDevice",\n        virtual_name="virtualName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['device_name', 'ebs', 'no_device', 'virtual_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnContainerRecipe.InstanceBlockDeviceMappingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnContainerRecipe.InstanceConfigurationProperty
class CfnContainerRecipe_InstanceConfigurationPropertyDef(BaseStruct):
    block_device_mappings: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnContainerRecipe_InstanceBlockDeviceMappingPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Defines the block devices to attach for building an instance from this Image Builder AMI.\n')
    image: typing.Optional[str] = pydantic.Field(None, description='The AMI ID to use as the base image for a container build and test instance. If not specified, Image Builder will use the appropriate ECS-optimized AMI as a base image.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-containerrecipe-instanceconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    instance_configuration_property = imagebuilder.CfnContainerRecipe.InstanceConfigurationProperty(\n        block_device_mappings=[imagebuilder.CfnContainerRecipe.InstanceBlockDeviceMappingProperty(\n            device_name="deviceName",\n            ebs=imagebuilder.CfnContainerRecipe.EbsInstanceBlockDeviceSpecificationProperty(\n                delete_on_termination=False,\n                encrypted=False,\n                iops=123,\n                kms_key_id="kmsKeyId",\n                snapshot_id="snapshotId",\n                throughput=123,\n                volume_size=123,\n                volume_type="volumeType"\n            ),\n            no_device="noDevice",\n            virtual_name="virtualName"\n        )],\n        image="image"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['block_device_mappings', 'image']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnContainerRecipe.InstanceConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnContainerRecipe.TargetContainerRepositoryProperty
class CfnContainerRecipe_TargetContainerRepositoryPropertyDef(BaseStruct):
    repository_name: typing.Optional[str] = pydantic.Field(None, description='The name of the container repository where the output container image is stored. This name is prefixed by the repository location.\n')
    service: typing.Optional[str] = pydantic.Field(None, description='Specifies the service in which this image was registered.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-containerrecipe-targetcontainerrepository.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    target_container_repository_property = imagebuilder.CfnContainerRecipe.TargetContainerRepositoryProperty(\n        repository_name="repositoryName",\n        service="service"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['repository_name', 'service']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnContainerRecipe.TargetContainerRepositoryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnDistributionConfiguration.AmiDistributionConfigurationProperty
class CfnDistributionConfiguration_AmiDistributionConfigurationPropertyDef(BaseStruct):
    ami_tags: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='The tags to apply to AMIs distributed to this Region.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the AMI distribution configuration. Minimum and maximum length are in characters.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The KMS key identifier used to encrypt the distributed image.\n')
    launch_permission_configuration: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnDistributionConfiguration_LaunchPermissionConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Launch permissions can be used to configure which AWS account s can use the AMI to launch instances.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the output AMI.\n')
    target_account_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The ID of an account to which you want to distribute an image.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-distributionconfiguration-amidistributionconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    ami_distribution_configuration_property = imagebuilder.CfnDistributionConfiguration.AmiDistributionConfigurationProperty(\n        ami_tags={\n            "ami_tags_key": "amiTags"\n        },\n        description="description",\n        kms_key_id="kmsKeyId",\n        launch_permission_configuration=imagebuilder.CfnDistributionConfiguration.LaunchPermissionConfigurationProperty(\n            organizational_unit_arns=["organizationalUnitArns"],\n            organization_arns=["organizationArns"],\n            user_groups=["userGroups"],\n            user_ids=["userIds"]\n        ),\n        name="name",\n        target_account_ids=["targetAccountIds"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ami_tags', 'description', 'kms_key_id', 'launch_permission_configuration', 'name', 'target_account_ids']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnDistributionConfiguration.AmiDistributionConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnDistributionConfiguration.ContainerDistributionConfigurationProperty
class CfnDistributionConfiguration_ContainerDistributionConfigurationPropertyDef(BaseStruct):
    container_tags: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Tags that are attached to the container distribution configuration.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the container distribution configuration.\n')
    target_repository: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnDistributionConfiguration_TargetContainerRepositoryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The destination repository for the container distribution configuration.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-distributionconfiguration-containerdistributionconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    container_distribution_configuration_property = imagebuilder.CfnDistributionConfiguration.ContainerDistributionConfigurationProperty(\n        container_tags=["containerTags"],\n        description="description",\n        target_repository=imagebuilder.CfnDistributionConfiguration.TargetContainerRepositoryProperty(\n            repository_name="repositoryName",\n            service="service"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['container_tags', 'description', 'target_repository']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnDistributionConfiguration.ContainerDistributionConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnDistributionConfiguration.DistributionProperty
class CfnDistributionConfiguration_DistributionPropertyDef(BaseStruct):
    region: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The target Region for the Distribution Configuration. For example, ``eu-west-1`` .\n')
    ami_distribution_configuration: typing.Any = pydantic.Field(None, description='The specific AMI settings, such as launch permissions and AMI tags. For details, see example schema below.\n')
    container_distribution_configuration: typing.Any = pydantic.Field(None, description='Container distribution settings for encryption, licensing, and sharing in a specific Region. For details, see example schema below.\n')
    fast_launch_configurations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnDistributionConfiguration_FastLaunchConfigurationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The Windows faster-launching configurations to use for AMI distribution.\n')
    launch_template_configurations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnDistributionConfiguration_LaunchTemplateConfigurationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A group of launchTemplateConfiguration settings that apply to image distribution for specified accounts.\n')
    license_configuration_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The License Manager Configuration to associate with the AMI in the specified Region. For more information, see the `LicenseConfiguration API <https://docs.aws.amazon.com/license-manager/latest/APIReference/API_LicenseConfiguration.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-distributionconfiguration-distribution.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    # ami_distribution_configuration: Any\n    # container_distribution_configuration: Any\n\n    distribution_property = imagebuilder.CfnDistributionConfiguration.DistributionProperty(\n        region="region",\n\n        # the properties below are optional\n        ami_distribution_configuration=ami_distribution_configuration,\n        container_distribution_configuration=container_distribution_configuration,\n        fast_launch_configurations=[imagebuilder.CfnDistributionConfiguration.FastLaunchConfigurationProperty(\n            account_id="accountId",\n            enabled=False,\n            launch_template=imagebuilder.CfnDistributionConfiguration.FastLaunchLaunchTemplateSpecificationProperty(\n                launch_template_id="launchTemplateId",\n                launch_template_name="launchTemplateName",\n                launch_template_version="launchTemplateVersion"\n            ),\n            max_parallel_launches=123,\n            snapshot_configuration=imagebuilder.CfnDistributionConfiguration.FastLaunchSnapshotConfigurationProperty(\n                target_resource_count=123\n            )\n        )],\n        launch_template_configurations=[imagebuilder.CfnDistributionConfiguration.LaunchTemplateConfigurationProperty(\n            account_id="accountId",\n            launch_template_id="launchTemplateId",\n            set_default_version=False\n        )],\n        license_configuration_arns=["licenseConfigurationArns"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['region', 'ami_distribution_configuration', 'container_distribution_configuration', 'fast_launch_configurations', 'launch_template_configurations', 'license_configuration_arns']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnDistributionConfiguration.DistributionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnDistributionConfiguration.FastLaunchConfigurationProperty
class CfnDistributionConfiguration_FastLaunchConfigurationPropertyDef(BaseStruct):
    account_id: typing.Optional[str] = pydantic.Field(None, description='The owner account ID for the fast-launch enabled Windows AMI.\n')
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='A Boolean that represents the current state of faster launching for the Windows AMI. Set to ``true`` to start using Windows faster launching, or ``false`` to stop using it.\n')
    launch_template: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnDistributionConfiguration_FastLaunchLaunchTemplateSpecificationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The launch template that the fast-launch enabled Windows AMI uses when it launches Windows instances to create pre-provisioned snapshots.\n')
    max_parallel_launches: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of parallel instances that are launched for creating resources.\n')
    snapshot_configuration: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnDistributionConfiguration_FastLaunchSnapshotConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configuration settings for managing the number of snapshots that are created from pre-provisioned instances for the Windows AMI when faster launching is enabled.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-distributionconfiguration-fastlaunchconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    fast_launch_configuration_property = imagebuilder.CfnDistributionConfiguration.FastLaunchConfigurationProperty(\n        account_id="accountId",\n        enabled=False,\n        launch_template=imagebuilder.CfnDistributionConfiguration.FastLaunchLaunchTemplateSpecificationProperty(\n            launch_template_id="launchTemplateId",\n            launch_template_name="launchTemplateName",\n            launch_template_version="launchTemplateVersion"\n        ),\n        max_parallel_launches=123,\n        snapshot_configuration=imagebuilder.CfnDistributionConfiguration.FastLaunchSnapshotConfigurationProperty(\n            target_resource_count=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account_id', 'enabled', 'launch_template', 'max_parallel_launches', 'snapshot_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnDistributionConfiguration.FastLaunchConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnDistributionConfiguration.FastLaunchLaunchTemplateSpecificationProperty
class CfnDistributionConfiguration_FastLaunchLaunchTemplateSpecificationPropertyDef(BaseStruct):
    launch_template_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the launch template to use for faster launching for a Windows AMI.\n')
    launch_template_name: typing.Optional[str] = pydantic.Field(None, description='The name of the launch template to use for faster launching for a Windows AMI.\n')
    launch_template_version: typing.Optional[str] = pydantic.Field(None, description='The version of the launch template to use for faster launching for a Windows AMI.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-distributionconfiguration-fastlaunchlaunchtemplatespecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    fast_launch_launch_template_specification_property = imagebuilder.CfnDistributionConfiguration.FastLaunchLaunchTemplateSpecificationProperty(\n        launch_template_id="launchTemplateId",\n        launch_template_name="launchTemplateName",\n        launch_template_version="launchTemplateVersion"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['launch_template_id', 'launch_template_name', 'launch_template_version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnDistributionConfiguration.FastLaunchLaunchTemplateSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnDistributionConfiguration.FastLaunchSnapshotConfigurationProperty
class CfnDistributionConfiguration_FastLaunchSnapshotConfigurationPropertyDef(BaseStruct):
    target_resource_count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of pre-provisioned snapshots to keep on hand for a fast-launch enabled Windows AMI.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-distributionconfiguration-fastlaunchsnapshotconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    fast_launch_snapshot_configuration_property = imagebuilder.CfnDistributionConfiguration.FastLaunchSnapshotConfigurationProperty(\n        target_resource_count=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['target_resource_count']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnDistributionConfiguration.FastLaunchSnapshotConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnDistributionConfiguration.LaunchPermissionConfigurationProperty
class CfnDistributionConfiguration_LaunchPermissionConfigurationPropertyDef(BaseStruct):
    organizational_unit_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The ARN for an AWS Organizations organizational unit (OU) that you want to share your AMI with. For more information about key concepts for AWS Organizations , see `AWS Organizations terminology and concepts <https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html>`_ .\n')
    organization_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The ARN for an AWS Organization that you want to share your AMI with. For more information, see `What is AWS Organizations ? <https://docs.aws.amazon.com/organizations/latest/userguide/orgs_introduction.html>`_ .\n')
    user_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The name of the group.\n')
    user_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The AWS account ID.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-distributionconfiguration-launchpermissionconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    launch_permission_configuration_property = imagebuilder.CfnDistributionConfiguration.LaunchPermissionConfigurationProperty(\n        organizational_unit_arns=["organizationalUnitArns"],\n        organization_arns=["organizationArns"],\n        user_groups=["userGroups"],\n        user_ids=["userIds"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['organizational_unit_arns', 'organization_arns', 'user_groups', 'user_ids']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnDistributionConfiguration.LaunchPermissionConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnDistributionConfiguration.LaunchTemplateConfigurationProperty
class CfnDistributionConfiguration_LaunchTemplateConfigurationPropertyDef(BaseStruct):
    account_id: typing.Optional[str] = pydantic.Field(None, description='The account ID that this configuration applies to.\n')
    launch_template_id: typing.Optional[str] = pydantic.Field(None, description='Identifies the Amazon EC2 launch template to use.\n')
    set_default_version: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Set the specified Amazon EC2 launch template as the default launch template for the specified account.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-distributionconfiguration-launchtemplateconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    launch_template_configuration_property = imagebuilder.CfnDistributionConfiguration.LaunchTemplateConfigurationProperty(\n        account_id="accountId",\n        launch_template_id="launchTemplateId",\n        set_default_version=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account_id', 'launch_template_id', 'set_default_version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnDistributionConfiguration.LaunchTemplateConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnDistributionConfiguration.TargetContainerRepositoryProperty
class CfnDistributionConfiguration_TargetContainerRepositoryPropertyDef(BaseStruct):
    repository_name: typing.Optional[str] = pydantic.Field(None, description='The name of the container repository where the output container image is stored. This name is prefixed by the repository location.\n')
    service: typing.Optional[str] = pydantic.Field(None, description='Specifies the service in which this image was registered.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-distributionconfiguration-targetcontainerrepository.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    target_container_repository_property = imagebuilder.CfnDistributionConfiguration.TargetContainerRepositoryProperty(\n        repository_name="repositoryName",\n        service="service"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['repository_name', 'service']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnDistributionConfiguration.TargetContainerRepositoryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnImage.EcrConfigurationProperty
class CfnImage_EcrConfigurationPropertyDef(BaseStruct):
    container_tags: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Tags for Image Builder to apply to the output container image that &INS; scans. Tags can help you identify and manage your scanned images.\n')
    repository_name: typing.Optional[str] = pydantic.Field(None, description='The name of the container repository that Amazon Inspector scans to identify findings for your container images. The name includes the path for the repository location. If you donâ€™t provide this information, Image Builder creates a repository in your account named ``image-builder-image-scanning-repository`` for vulnerability scans of your output container images.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-image-ecrconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    ecr_configuration_property = imagebuilder.CfnImage.EcrConfigurationProperty(\n        container_tags=["containerTags"],\n        repository_name="repositoryName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['container_tags', 'repository_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImage.EcrConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnImage.ImageScanningConfigurationProperty
class CfnImage_ImageScanningConfigurationPropertyDef(BaseStruct):
    ecr_configuration: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImage_EcrConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains Amazon ECR settings for vulnerability scans.\n')
    image_scanning_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='A setting that indicates whether Image Builder keeps a snapshot of the vulnerability scans that Amazon Inspector runs against the build instance when you create a new image.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-image-imagescanningconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    image_scanning_configuration_property = imagebuilder.CfnImage.ImageScanningConfigurationProperty(\n        ecr_configuration=imagebuilder.CfnImage.EcrConfigurationProperty(\n            container_tags=["containerTags"],\n            repository_name="repositoryName"\n        ),\n        image_scanning_enabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ecr_configuration', 'image_scanning_enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImage.ImageScanningConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnImage.ImageTestsConfigurationProperty
class CfnImage_ImageTestsConfigurationPropertyDef(BaseStruct):
    image_tests_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Determines if tests should run after building the image. Image Builder defaults to enable tests to run following the image build, before image distribution.\n')
    timeout_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum time in minutes that tests are permitted to run. .. epigraph:: The timeoutMinutes attribute is not currently active. This value is ignored.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-image-imagetestsconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    image_tests_configuration_property = imagebuilder.CfnImage.ImageTestsConfigurationProperty(\n        image_tests_enabled=False,\n        timeout_minutes=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['image_tests_enabled', 'timeout_minutes']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImage.ImageTestsConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnImage.WorkflowConfigurationProperty
class CfnImage_WorkflowConfigurationPropertyDef(BaseStruct):
    on_failure: typing.Optional[str] = pydantic.Field(None, description='The action to take if the workflow fails.\n')
    parallel_group: typing.Optional[str] = pydantic.Field(None, description='Test workflows are defined within named runtime groups called parallel groups. The parallel group is the named group that contains this test workflow. Test workflows within a parallel group can run at the same time. Image Builder starts up to five test workflows in the group at the same time, and starts additional workflows as others complete, until all workflows in the group have completed. This field only applies for test workflows.\n')
    parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImage_WorkflowParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Contains parameter values for each of the parameters that the workflow document defined for the workflow resource.\n')
    workflow_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the workflow resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-image-workflowconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    workflow_configuration_property = imagebuilder.CfnImage.WorkflowConfigurationProperty(\n        on_failure="onFailure",\n        parallel_group="parallelGroup",\n        parameters=[imagebuilder.CfnImage.WorkflowParameterProperty(\n            name="name",\n            value=["value"]\n        )],\n        workflow_arn="workflowArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['on_failure', 'parallel_group', 'parameters', 'workflow_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImage.WorkflowConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnImage.WorkflowParameterProperty
class CfnImage_WorkflowParameterPropertyDef(BaseStruct):
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the workflow parameter to set.\n')
    value: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Sets the value for the named workflow parameter.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-image-workflowparameter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    workflow_parameter_property = imagebuilder.CfnImage.WorkflowParameterProperty(\n        name="name",\n        value=["value"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImage.WorkflowParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnImagePipeline.EcrConfigurationProperty
class CfnImagePipeline_EcrConfigurationPropertyDef(BaseStruct):
    container_tags: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Tags for Image Builder to apply to the output container image that &INS; scans. Tags can help you identify and manage your scanned images.\n')
    repository_name: typing.Optional[str] = pydantic.Field(None, description='The name of the container repository that Amazon Inspector scans to identify findings for your container images. The name includes the path for the repository location. If you donâ€™t provide this information, Image Builder creates a repository in your account named ``image-builder-image-scanning-repository`` for vulnerability scans of your output container images.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-imagepipeline-ecrconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    ecr_configuration_property = imagebuilder.CfnImagePipeline.EcrConfigurationProperty(\n        container_tags=["containerTags"],\n        repository_name="repositoryName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['container_tags', 'repository_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImagePipeline.EcrConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnImagePipeline.ImageScanningConfigurationProperty
class CfnImagePipeline_ImageScanningConfigurationPropertyDef(BaseStruct):
    ecr_configuration: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImagePipeline_EcrConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains Amazon ECR settings for vulnerability scans.\n')
    image_scanning_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='A setting that indicates whether Image Builder keeps a snapshot of the vulnerability scans that Amazon Inspector runs against the build instance when you create a new image.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-imagepipeline-imagescanningconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    image_scanning_configuration_property = imagebuilder.CfnImagePipeline.ImageScanningConfigurationProperty(\n        ecr_configuration=imagebuilder.CfnImagePipeline.EcrConfigurationProperty(\n            container_tags=["containerTags"],\n            repository_name="repositoryName"\n        ),\n        image_scanning_enabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ecr_configuration', 'image_scanning_enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImagePipeline.ImageScanningConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnImagePipeline.ImageTestsConfigurationProperty
class CfnImagePipeline_ImageTestsConfigurationPropertyDef(BaseStruct):
    image_tests_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Defines if tests should be executed when building this image. For example, ``true`` or ``false`` .\n')
    timeout_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum time in minutes that tests are permitted to run. .. epigraph:: The timeoutMinutes attribute is not currently active. This value is ignored.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-imagepipeline-imagetestsconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    image_tests_configuration_property = imagebuilder.CfnImagePipeline.ImageTestsConfigurationProperty(\n        image_tests_enabled=False,\n        timeout_minutes=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['image_tests_enabled', 'timeout_minutes']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImagePipeline.ImageTestsConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnImagePipeline.ScheduleProperty
class CfnImagePipeline_SchedulePropertyDef(BaseStruct):
    pipeline_execution_start_condition: typing.Optional[str] = pydantic.Field(None, description='The condition configures when the pipeline should trigger a new image build. When the ``pipelineExecutionStartCondition`` is set to ``EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE`` , and you use semantic version filters on the base image or components in your image recipe, Image Builder will build a new image only when there are new versions of the image or components in your recipe that match the semantic version filter. When it is set to ``EXPRESSION_MATCH_ONLY`` , it will build a new image every time the CRON expression matches the current time. For semantic version syntax, see `CreateComponent <https://docs.aws.amazon.com/imagebuilder/latest/APIReference/API_CreateComponent.html>`_ in the *Image Builder API Reference* .\n')
    schedule_expression: typing.Optional[str] = pydantic.Field(None, description='The cron expression determines how often EC2 Image Builder evaluates your ``pipelineExecutionStartCondition`` . For information on how to format a cron expression in Image Builder, see `Use cron expressions in EC2 Image Builder <https://docs.aws.amazon.com/imagebuilder/latest/userguide/image-builder-cron.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-imagepipeline-schedule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    schedule_property = imagebuilder.CfnImagePipeline.ScheduleProperty(\n        pipeline_execution_start_condition="pipelineExecutionStartCondition",\n        schedule_expression="scheduleExpression"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['pipeline_execution_start_condition', 'schedule_expression']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImagePipeline.ScheduleProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnImagePipeline.WorkflowConfigurationProperty
class CfnImagePipeline_WorkflowConfigurationPropertyDef(BaseStruct):
    on_failure: typing.Optional[str] = pydantic.Field(None, description='The action to take if the workflow fails.\n')
    parallel_group: typing.Optional[str] = pydantic.Field(None, description='Test workflows are defined within named runtime groups called parallel groups. The parallel group is the named group that contains this test workflow. Test workflows within a parallel group can run at the same time. Image Builder starts up to five test workflows in the group at the same time, and starts additional workflows as others complete, until all workflows in the group have completed. This field only applies for test workflows.\n')
    parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImagePipeline_WorkflowParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Contains parameter values for each of the parameters that the workflow document defined for the workflow resource.\n')
    workflow_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the workflow resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-imagepipeline-workflowconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    workflow_configuration_property = imagebuilder.CfnImagePipeline.WorkflowConfigurationProperty(\n        on_failure="onFailure",\n        parallel_group="parallelGroup",\n        parameters=[imagebuilder.CfnImagePipeline.WorkflowParameterProperty(\n            name="name",\n            value=["value"]\n        )],\n        workflow_arn="workflowArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['on_failure', 'parallel_group', 'parameters', 'workflow_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImagePipeline.WorkflowConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnImagePipeline.WorkflowParameterProperty
class CfnImagePipeline_WorkflowParameterPropertyDef(BaseStruct):
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the workflow parameter to set.\n')
    value: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Sets the value for the named workflow parameter.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-imagepipeline-workflowparameter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    workflow_parameter_property = imagebuilder.CfnImagePipeline.WorkflowParameterProperty(\n        name="name",\n        value=["value"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImagePipeline.WorkflowParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnImageRecipe.AdditionalInstanceConfigurationProperty
class CfnImageRecipe_AdditionalInstanceConfigurationPropertyDef(BaseStruct):
    systems_manager_agent: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImageRecipe_SystemsManagerAgentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains settings for the Systems Manager agent on your build instance.\n')
    user_data_override: typing.Optional[str] = pydantic.Field(None, description='Use this property to provide commands or a command script to run when you launch your build instance. The userDataOverride property replaces any commands that Image Builder might have added to ensure that Systems Manager is installed on your Linux build instance. If you override the user data, make sure that you add commands to install Systems Manager, if it is not pre-installed on your base image. .. epigraph:: The user data is always base 64 encoded. For example, the following commands are encoded as ``IyEvYmluL2Jhc2gKbWtkaXIgLXAgL3Zhci9iYi8KdG91Y2ggL3Zhci$`` : *#!/bin/bash* mkdir -p /var/bb/ touch /var\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-imagerecipe-additionalinstanceconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    additional_instance_configuration_property = imagebuilder.CfnImageRecipe.AdditionalInstanceConfigurationProperty(\n        systems_manager_agent=imagebuilder.CfnImageRecipe.SystemsManagerAgentProperty(\n            uninstall_after_build=False\n        ),\n        user_data_override="userDataOverride"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['systems_manager_agent', 'user_data_override']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImageRecipe.AdditionalInstanceConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnImageRecipe.ComponentConfigurationProperty
class CfnImageRecipe_ComponentConfigurationPropertyDef(BaseStruct):
    component_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the component.\n')
    parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImageRecipe_ComponentParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A group of parameter settings that Image Builder uses to configure the component for a specific recipe.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-imagerecipe-componentconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    component_configuration_property = imagebuilder.CfnImageRecipe.ComponentConfigurationProperty(\n        component_arn="componentArn",\n        parameters=[imagebuilder.CfnImageRecipe.ComponentParameterProperty(\n            name="name",\n            value=["value"]\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['component_arn', 'parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImageRecipe.ComponentConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnImageRecipe.ComponentParameterProperty
class CfnImageRecipe_ComponentParameterPropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the component parameter to set.\n')
    value: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Sets the value for the named component parameter.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-imagerecipe-componentparameter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    component_parameter_property = imagebuilder.CfnImageRecipe.ComponentParameterProperty(\n        name="name",\n        value=["value"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImageRecipe.ComponentParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnImageRecipe.EbsInstanceBlockDeviceSpecificationProperty
class CfnImageRecipe_EbsInstanceBlockDeviceSpecificationPropertyDef(BaseStruct):
    delete_on_termination: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Configures delete on termination of the associated device.\n')
    encrypted: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Use to configure device encryption.\n')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='Use to configure device IOPS.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='Use to configure the KMS key to use when encrypting the device.\n')
    snapshot_id: typing.Optional[str] = pydantic.Field(None, description='The snapshot that defines the device contents.\n')
    throughput: typing.Union[int, float, None] = pydantic.Field(None, description='*For GP3 volumes only* â€“ The throughput in MiB/s that the volume supports.\n')
    volume_size: typing.Union[int, float, None] = pydantic.Field(None, description='Overrides the volume size of the device.\n')
    volume_type: typing.Optional[str] = pydantic.Field(None, description='Overrides the volume type of the device.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-imagerecipe-ebsinstanceblockdevicespecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    ebs_instance_block_device_specification_property = imagebuilder.CfnImageRecipe.EbsInstanceBlockDeviceSpecificationProperty(\n        delete_on_termination=False,\n        encrypted=False,\n        iops=123,\n        kms_key_id="kmsKeyId",\n        snapshot_id="snapshotId",\n        throughput=123,\n        volume_size=123,\n        volume_type="volumeType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['delete_on_termination', 'encrypted', 'iops', 'kms_key_id', 'snapshot_id', 'throughput', 'volume_size', 'volume_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImageRecipe.EbsInstanceBlockDeviceSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnImageRecipe.InstanceBlockDeviceMappingProperty
class CfnImageRecipe_InstanceBlockDeviceMappingPropertyDef(BaseStruct):
    device_name: typing.Optional[str] = pydantic.Field(None, description='The device to which these mappings apply.\n')
    ebs: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImageRecipe_EbsInstanceBlockDeviceSpecificationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Use to manage Amazon EBS-specific configuration for this mapping.\n')
    no_device: typing.Optional[str] = pydantic.Field(None, description='Enter an empty string to remove a mapping from the parent image. The following is an example of an empty string value in the ``NoDevice`` field. ``NoDevice:""``\n')
    virtual_name: typing.Optional[str] = pydantic.Field(None, description='Manages the instance ephemeral devices.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-imagerecipe-instanceblockdevicemapping.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    instance_block_device_mapping_property = imagebuilder.CfnImageRecipe.InstanceBlockDeviceMappingProperty(\n        device_name="deviceName",\n        ebs=imagebuilder.CfnImageRecipe.EbsInstanceBlockDeviceSpecificationProperty(\n            delete_on_termination=False,\n            encrypted=False,\n            iops=123,\n            kms_key_id="kmsKeyId",\n            snapshot_id="snapshotId",\n            throughput=123,\n            volume_size=123,\n            volume_type="volumeType"\n        ),\n        no_device="noDevice",\n        virtual_name="virtualName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['device_name', 'ebs', 'no_device', 'virtual_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImageRecipe.InstanceBlockDeviceMappingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnImageRecipe.SystemsManagerAgentProperty
class CfnImageRecipe_SystemsManagerAgentPropertyDef(BaseStruct):
    uninstall_after_build: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="Controls whether the Systems Manager agent is removed from your final build image, prior to creating the new AMI. If this is set to true, then the agent is removed from the final image. If it's set to false, then the agent is left in, so that it is included in the new AMI. The default value is false.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-imagerecipe-systemsmanageragent.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    systems_manager_agent_property = imagebuilder.CfnImageRecipe.SystemsManagerAgentProperty(\n        uninstall_after_build=False\n    )\n")
    _init_params: typing.ClassVar[list[str]] = ['uninstall_after_build']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImageRecipe.SystemsManagerAgentProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnInfrastructureConfiguration.InstanceMetadataOptionsProperty
class CfnInfrastructureConfiguration_InstanceMetadataOptionsPropertyDef(BaseStruct):
    http_put_response_hop_limit: typing.Union[int, float, None] = pydantic.Field(None, description='Limit the number of hops that an instance metadata request can traverse to reach its destination. The default is one hop. However, if HTTP tokens are required, container image builds need a minimum of two hops.\n')
    http_tokens: typing.Optional[str] = pydantic.Field(None, description='Indicates whether a signed token header is required for instance metadata retrieval requests. The values affect the response as follows: - *required* â€“ When you retrieve the IAM role credentials, version 2.0 credentials are returned in all cases. - *optional* â€“ You can include a signed token header in your request to retrieve instance metadata, or you can leave it out. If you include it, version 2.0 credentials are returned for the IAM role. Otherwise, version 1.0 credentials are returned. The default setting is *optional* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-infrastructureconfiguration-instancemetadataoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    instance_metadata_options_property = imagebuilder.CfnInfrastructureConfiguration.InstanceMetadataOptionsProperty(\n        http_put_response_hop_limit=123,\n        http_tokens="httpTokens"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['http_put_response_hop_limit', 'http_tokens']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnInfrastructureConfiguration.InstanceMetadataOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnInfrastructureConfiguration.LoggingProperty
class CfnInfrastructureConfiguration_LoggingPropertyDef(BaseStruct):
    s3_logs: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnInfrastructureConfiguration_S3LogsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The Amazon S3 logging configuration.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-infrastructureconfiguration-logging.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    logging_property = imagebuilder.CfnInfrastructureConfiguration.LoggingProperty(\n        s3_logs=imagebuilder.CfnInfrastructureConfiguration.S3LogsProperty(\n            s3_bucket_name="s3BucketName",\n            s3_key_prefix="s3KeyPrefix"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['s3_logs']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnInfrastructureConfiguration.LoggingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnInfrastructureConfiguration.S3LogsProperty
class CfnInfrastructureConfiguration_S3LogsPropertyDef(BaseStruct):
    s3_bucket_name: typing.Optional[str] = pydantic.Field(None, description='The S3 bucket in which to store the logs.\n')
    s3_key_prefix: typing.Optional[str] = pydantic.Field(None, description='The Amazon S3 path to the bucket where the logs are stored.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-infrastructureconfiguration-s3logs.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    s3_logs_property = imagebuilder.CfnInfrastructureConfiguration.S3LogsProperty(\n        s3_bucket_name="s3BucketName",\n        s3_key_prefix="s3KeyPrefix"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['s3_bucket_name', 's3_key_prefix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnInfrastructureConfiguration.S3LogsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnLifecyclePolicy.ActionProperty
class CfnLifecyclePolicy_ActionPropertyDef(BaseStruct):
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the lifecycle action to take.\n')
    include_resources: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnLifecyclePolicy_IncludeResourcesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies the resources that the lifecycle policy applies to.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-lifecyclepolicy-action.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    action_property = imagebuilder.CfnLifecyclePolicy.ActionProperty(\n        type="type",\n\n        # the properties below are optional\n        include_resources=imagebuilder.CfnLifecyclePolicy.IncludeResourcesProperty(\n            amis=False,\n            containers=False,\n            snapshots=False\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'include_resources']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnLifecyclePolicy.ActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnLifecyclePolicy.AmiExclusionRulesProperty
class CfnLifecyclePolicy_AmiExclusionRulesPropertyDef(BaseStruct):
    is_public: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Configures whether public AMIs are excluded from the lifecycle action.\n')
    last_launched: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnLifecyclePolicy_LastLaunchedPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies configuration details for Image Builder to exclude the most recent resources from lifecycle actions.\n')
    regions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Configures AWS Region s that are excluded from the lifecycle action.\n')
    shared_accounts: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Specifies AWS account s whose resources are excluded from the lifecycle action.\n')
    tag_map: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='Lists tags that should be excluded from lifecycle actions for the AMIs that have them.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-lifecyclepolicy-amiexclusionrules.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    ami_exclusion_rules_property = imagebuilder.CfnLifecyclePolicy.AmiExclusionRulesProperty(\n        is_public=False,\n        last_launched=imagebuilder.CfnLifecyclePolicy.LastLaunchedProperty(\n            unit="unit",\n            value=123\n        ),\n        regions=["regions"],\n        shared_accounts=["sharedAccounts"],\n        tag_map={\n            "tag_map_key": "tagMap"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['is_public', 'last_launched', 'regions', 'shared_accounts', 'tag_map']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnLifecyclePolicy.AmiExclusionRulesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnLifecyclePolicy.ExclusionRulesProperty
class CfnLifecyclePolicy_ExclusionRulesPropertyDef(BaseStruct):
    amis: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnLifecyclePolicy_AmiExclusionRulesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Lists configuration values that apply to AMIs that Image Builder should exclude from the lifecycle action.\n')
    tag_map: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='Contains a list of tags that Image Builder uses to skip lifecycle actions for Image Builder image resources that have them.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-lifecyclepolicy-exclusionrules.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    exclusion_rules_property = imagebuilder.CfnLifecyclePolicy.ExclusionRulesProperty(\n        amis=imagebuilder.CfnLifecyclePolicy.AmiExclusionRulesProperty(\n            is_public=False,\n            last_launched=imagebuilder.CfnLifecyclePolicy.LastLaunchedProperty(\n                unit="unit",\n                value=123\n            ),\n            regions=["regions"],\n            shared_accounts=["sharedAccounts"],\n            tag_map={\n                "tag_map_key": "tagMap"\n            }\n        ),\n        tag_map={\n            "tag_map_key": "tagMap"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['amis', 'tag_map']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnLifecyclePolicy.ExclusionRulesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnLifecyclePolicy.FilterProperty
class CfnLifecyclePolicy_FilterPropertyDef(BaseStruct):
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Filter resources based on either ``age`` or ``count`` .\n')
    value: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The number of units for the time period or for the count. For example, a value of ``6`` might refer to six months or six AMIs. .. epigraph:: For count-based filters, this value represents the minimum number of resources to keep on hand. If you have fewer resources than this number, the resource is excluded from lifecycle actions.\n')
    retain_at_least: typing.Union[int, float, None] = pydantic.Field(None, description='For age-based filters, this is the number of resources to keep on hand after the lifecycle ``DELETE`` action is applied. Impacted resources are only deleted if you have more than this number of resources. If you have fewer resources than this number, the impacted resource is not deleted.\n')
    unit: typing.Optional[str] = pydantic.Field(None, description='Defines the unit of time that the lifecycle policy uses to determine impacted resources. This is required for age-based rules.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-lifecyclepolicy-filter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    filter_property = imagebuilder.CfnLifecyclePolicy.FilterProperty(\n        type="type",\n        value=123,\n\n        # the properties below are optional\n        retain_at_least=123,\n        unit="unit"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'value', 'retain_at_least', 'unit']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnLifecyclePolicy.FilterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnLifecyclePolicy.IncludeResourcesProperty
class CfnLifecyclePolicy_IncludeResourcesPropertyDef(BaseStruct):
    amis: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether the lifecycle action should apply to distributed AMIs.\n')
    containers: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether the lifecycle action should apply to distributed containers.\n')
    snapshots: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether the lifecycle action should apply to snapshots associated with distributed AMIs.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-lifecyclepolicy-includeresources.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    include_resources_property = imagebuilder.CfnLifecyclePolicy.IncludeResourcesProperty(\n        amis=False,\n        containers=False,\n        snapshots=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['amis', 'containers', 'snapshots']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnLifecyclePolicy.IncludeResourcesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnLifecyclePolicy.LastLaunchedProperty
class CfnLifecyclePolicy_LastLaunchedPropertyDef(BaseStruct):
    unit: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Defines the unit of time that the lifecycle policy uses to calculate elapsed time since the last instance launched from the AMI. For example: days, weeks, months, or years.\n')
    value: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The integer number of units for the time period. For example ``6`` (months).\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-lifecyclepolicy-lastlaunched.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    last_launched_property = imagebuilder.CfnLifecyclePolicy.LastLaunchedProperty(\n        unit="unit",\n        value=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['unit', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnLifecyclePolicy.LastLaunchedProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnLifecyclePolicy.PolicyDetailProperty
class CfnLifecyclePolicy_PolicyDetailPropertyDef(BaseStruct):
    action: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_imagebuilder.CfnLifecyclePolicy_ActionPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Configuration details for the policy action.\n')
    filter: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_imagebuilder.CfnLifecyclePolicy_FilterPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the resources that the lifecycle policy applies to.\n')
    exclusion_rules: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnLifecyclePolicy_ExclusionRulesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional rules to specify resources that should be exempt from policy actions.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-lifecyclepolicy-policydetail.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    policy_detail_property = imagebuilder.CfnLifecyclePolicy.PolicyDetailProperty(\n        action=imagebuilder.CfnLifecyclePolicy.ActionProperty(\n            type="type",\n\n            # the properties below are optional\n            include_resources=imagebuilder.CfnLifecyclePolicy.IncludeResourcesProperty(\n                amis=False,\n                containers=False,\n                snapshots=False\n            )\n        ),\n        filter=imagebuilder.CfnLifecyclePolicy.FilterProperty(\n            type="type",\n            value=123,\n\n            # the properties below are optional\n            retain_at_least=123,\n            unit="unit"\n        ),\n\n        # the properties below are optional\n        exclusion_rules=imagebuilder.CfnLifecyclePolicy.ExclusionRulesProperty(\n            amis=imagebuilder.CfnLifecyclePolicy.AmiExclusionRulesProperty(\n                is_public=False,\n                last_launched=imagebuilder.CfnLifecyclePolicy.LastLaunchedProperty(\n                    unit="unit",\n                    value=123\n                ),\n                regions=["regions"],\n                shared_accounts=["sharedAccounts"],\n                tag_map={\n                    "tag_map_key": "tagMap"\n                }\n            ),\n            tag_map={\n                "tag_map_key": "tagMap"\n            }\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action', 'filter', 'exclusion_rules']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnLifecyclePolicy.PolicyDetailProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnLifecyclePolicy.RecipeSelectionProperty
class CfnLifecyclePolicy_RecipeSelectionPropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of an Image Builder recipe that the lifecycle policy uses for resource selection.\n')
    semantic_version: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The version of the Image Builder recipe specified by the ``name`` field.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-lifecyclepolicy-recipeselection.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    recipe_selection_property = imagebuilder.CfnLifecyclePolicy.RecipeSelectionProperty(\n        name="name",\n        semantic_version="semanticVersion"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'semantic_version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnLifecyclePolicy.RecipeSelectionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnLifecyclePolicy.ResourceSelectionProperty
class CfnLifecyclePolicy_ResourceSelectionPropertyDef(BaseStruct):
    recipes: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnLifecyclePolicy_RecipeSelectionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of recipes that are used as selection criteria for the output images that the lifecycle policy applies to.\n')
    tag_map: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='A list of tags that are used as selection criteria for the Image Builder image resources that the lifecycle policy applies to.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-imagebuilder-lifecyclepolicy-resourceselection.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    resource_selection_property = imagebuilder.CfnLifecyclePolicy.ResourceSelectionProperty(\n        recipes=[imagebuilder.CfnLifecyclePolicy.RecipeSelectionProperty(\n            name="name",\n            semantic_version="semanticVersion"\n        )],\n        tag_map={\n            "tag_map_key": "tagMap"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['recipes', 'tag_map']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnLifecyclePolicy.ResourceSelectionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnComponent
class CfnComponentDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the component.\n')
    platform: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The operating system platform of the component.\n')
    version: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The component version. For example, ``1.0.0`` .\n')
    change_description: typing.Optional[str] = pydantic.Field(None, description='The change description of the component. Describes what change has been made in this version, or what makes this version different from other versions of the component.\n')
    data: typing.Optional[str] = pydantic.Field(None, description='Component ``data`` contains inline YAML document content for the component. Alternatively, you can specify the ``uri`` of a YAML document file stored in Amazon S3. However, you cannot specify both properties.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Describes the contents of the component.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the KMS key that is used to encrypt this component.\n')
    supported_os_versions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The operating system (OS) version supported by the component. If the OS information is available, a prefix match is performed against the base image OS version during image recipe creation.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The tags that apply to the component.\n')
    uri: typing.Optional[str] = pydantic.Field(None, description='The ``uri`` of a YAML component document file. This must be an S3 URL ( ``s3://bucket/key`` ), and the requester must have permission to access the S3 bucket it points to. If you use Amazon S3, you can specify component content up to your service quota. Alternatively, you can specify the YAML document inline, using the component ``data`` property. You cannot specify both properties.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'platform', 'version', 'change_description', 'data', 'description', 'kms_key_id', 'supported_os_versions', 'tags', 'uri']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnComponent'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_imagebuilder.CfnComponentDefConfig] = pydantic.Field(None)


class CfnComponentDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_imagebuilder.CfnComponentDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_imagebuilder.CfnComponentDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_imagebuilder.CfnComponentDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_imagebuilder.CfnComponentDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_imagebuilder.CfnComponentDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_imagebuilder.CfnComponentDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_imagebuilder.CfnComponentDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_imagebuilder.CfnComponentDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_imagebuilder.CfnComponentDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_imagebuilder.CfnComponentDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_imagebuilder.CfnComponentDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_imagebuilder.CfnComponentDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_imagebuilder.CfnComponentDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_encrypted_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnComponentDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnComponentDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnComponentDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnComponentDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnComponentDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnComponentDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnComponentDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnComponentDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnComponentDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnComponentDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnComponentDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnComponentDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnComponentDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnComponentDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_imagebuilder.CfnContainerRecipe
class CfnContainerRecipeDef(BaseCfnResource):
    components: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnContainerRecipe_ComponentConfigurationPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Build and test components that are included in the container recipe. Recipes require a minimum of one build component, and can have a maximum of 20 build and test components in any combination.\n')
    container_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the type of container, such as Docker.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the container recipe.\n')
    parent_image: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The base image for the container recipe.\n')
    target_repository: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_imagebuilder.CfnContainerRecipe_TargetContainerRepositoryPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The destination repository for the container image.\n')
    version: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The semantic version of the container recipe. .. epigraph:: The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. *Assignment:* For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. *Patterns:* You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01. *Filtering:* With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the container recipe.\n')
    dockerfile_template_data: typing.Optional[str] = pydantic.Field(None, description='Dockerfiles are text documents that are used to build Docker containers, and ensure that they contain all of the elements required by the application running inside. The template data consists of contextual variables where Image Builder places build information or scripts, based on your container image recipe.\n')
    dockerfile_template_uri: typing.Optional[str] = pydantic.Field(None, description='The S3 URI for the Dockerfile that will be used to build your container image.\n')
    image_os_version_override: typing.Optional[str] = pydantic.Field(None, description='Specifies the operating system version for the base image.\n')
    instance_configuration: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnContainerRecipe_InstanceConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A group of options that can be used to configure an instance for building and testing container images.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='Identifies which KMS key is used to encrypt the container image for distribution to the target Region.\n')
    platform_override: typing.Optional[str] = pydantic.Field(None, description='Specifies the operating system platform when you use a custom base image.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Tags that are attached to the container recipe.\n')
    working_directory: typing.Optional[str] = pydantic.Field(None, description='The working directory for use during build and test workflows.')
    _init_params: typing.ClassVar[list[str]] = ['components', 'container_type', 'name', 'parent_image', 'target_repository', 'version', 'description', 'dockerfile_template_data', 'dockerfile_template_uri', 'image_os_version_override', 'instance_configuration', 'kms_key_id', 'platform_override', 'tags', 'working_directory']
    _method_names: typing.ClassVar[list[str]] = ['ComponentConfigurationProperty', 'ComponentParameterProperty', 'EbsInstanceBlockDeviceSpecificationProperty', 'InstanceBlockDeviceMappingProperty', 'InstanceConfigurationProperty', 'TargetContainerRepositoryProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnContainerRecipe'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_imagebuilder.CfnContainerRecipeDefConfig] = pydantic.Field(None)


class CfnContainerRecipeDefConfig(pydantic.BaseModel):
    ComponentConfigurationProperty: typing.Optional[list[models.aws_imagebuilder.CfnContainerRecipeDefComponentconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ComponentParameterProperty: typing.Optional[list[models.aws_imagebuilder.CfnContainerRecipeDefComponentparameterpropertyParams]] = pydantic.Field(None, description='')
    EbsInstanceBlockDeviceSpecificationProperty: typing.Optional[list[models.aws_imagebuilder.CfnContainerRecipeDefEbsinstanceblockdevicespecificationpropertyParams]] = pydantic.Field(None, description='')
    InstanceBlockDeviceMappingProperty: typing.Optional[list[models.aws_imagebuilder.CfnContainerRecipeDefInstanceblockdevicemappingpropertyParams]] = pydantic.Field(None, description='')
    InstanceConfigurationProperty: typing.Optional[list[models.aws_imagebuilder.CfnContainerRecipeDefInstanceconfigurationpropertyParams]] = pydantic.Field(None, description='')
    TargetContainerRepositoryProperty: typing.Optional[list[models.aws_imagebuilder.CfnContainerRecipeDefTargetcontainerrepositorypropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_imagebuilder.CfnContainerRecipeDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_imagebuilder.CfnContainerRecipeDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_imagebuilder.CfnContainerRecipeDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_imagebuilder.CfnContainerRecipeDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_imagebuilder.CfnContainerRecipeDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_imagebuilder.CfnContainerRecipeDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_imagebuilder.CfnContainerRecipeDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_imagebuilder.CfnContainerRecipeDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_imagebuilder.CfnContainerRecipeDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_imagebuilder.CfnContainerRecipeDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_imagebuilder.CfnContainerRecipeDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_imagebuilder.CfnContainerRecipeDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_imagebuilder.CfnContainerRecipeDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnContainerRecipeDefComponentconfigurationpropertyParams(pydantic.BaseModel):
    component_arn: typing.Optional[str] = pydantic.Field(None, description='')
    parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnContainerRecipe_ComponentParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnContainerRecipeDefComponentparameterpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    value: typing.Sequence[str] = pydantic.Field(..., description='')
    ...

class CfnContainerRecipeDefEbsinstanceblockdevicespecificationpropertyParams(pydantic.BaseModel):
    delete_on_termination: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    encrypted: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='')
    snapshot_id: typing.Optional[str] = pydantic.Field(None, description='')
    throughput: typing.Union[int, float, None] = pydantic.Field(None, description='')
    volume_size: typing.Union[int, float, None] = pydantic.Field(None, description='')
    volume_type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnContainerRecipeDefInstanceblockdevicemappingpropertyParams(pydantic.BaseModel):
    device_name: typing.Optional[str] = pydantic.Field(None, description='')
    ebs: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnContainerRecipe_EbsInstanceBlockDeviceSpecificationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    no_device: typing.Optional[str] = pydantic.Field(None, description='')
    virtual_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnContainerRecipeDefInstanceconfigurationpropertyParams(pydantic.BaseModel):
    block_device_mappings: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnContainerRecipe_InstanceBlockDeviceMappingPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    image: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnContainerRecipeDefTargetcontainerrepositorypropertyParams(pydantic.BaseModel):
    repository_name: typing.Optional[str] = pydantic.Field(None, description='')
    service: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnContainerRecipeDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnContainerRecipeDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnContainerRecipeDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnContainerRecipeDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnContainerRecipeDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnContainerRecipeDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnContainerRecipeDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnContainerRecipeDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnContainerRecipeDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnContainerRecipeDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnContainerRecipeDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnContainerRecipeDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnContainerRecipeDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnContainerRecipeDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_imagebuilder.CfnDistributionConfiguration
class CfnDistributionConfigurationDef(BaseCfnResource):
    distributions: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnDistributionConfiguration_DistributionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The distributions of this distribution configuration formatted as an array of Distribution objects.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of this distribution configuration.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of this distribution configuration.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The tags of this distribution configuration.')
    _init_params: typing.ClassVar[list[str]] = ['distributions', 'name', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['AmiDistributionConfigurationProperty', 'ContainerDistributionConfigurationProperty', 'DistributionProperty', 'FastLaunchConfigurationProperty', 'FastLaunchLaunchTemplateSpecificationProperty', 'FastLaunchSnapshotConfigurationProperty', 'LaunchPermissionConfigurationProperty', 'LaunchTemplateConfigurationProperty', 'TargetContainerRepositoryProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnDistributionConfiguration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_imagebuilder.CfnDistributionConfigurationDefConfig] = pydantic.Field(None)


class CfnDistributionConfigurationDefConfig(pydantic.BaseModel):
    AmiDistributionConfigurationProperty: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefAmidistributionconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ContainerDistributionConfigurationProperty: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefContainerdistributionconfigurationpropertyParams]] = pydantic.Field(None, description='')
    DistributionProperty: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefDistributionpropertyParams]] = pydantic.Field(None, description='')
    FastLaunchConfigurationProperty: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefFastlaunchconfigurationpropertyParams]] = pydantic.Field(None, description='')
    FastLaunchLaunchTemplateSpecificationProperty: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefFastlaunchlaunchtemplatespecificationpropertyParams]] = pydantic.Field(None, description='')
    FastLaunchSnapshotConfigurationProperty: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefFastlaunchsnapshotconfigurationpropertyParams]] = pydantic.Field(None, description='')
    LaunchPermissionConfigurationProperty: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefLaunchpermissionconfigurationpropertyParams]] = pydantic.Field(None, description='')
    LaunchTemplateConfigurationProperty: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefLaunchtemplateconfigurationpropertyParams]] = pydantic.Field(None, description='')
    TargetContainerRepositoryProperty: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefTargetcontainerrepositorypropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_imagebuilder.CfnDistributionConfigurationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDistributionConfigurationDefAmidistributionconfigurationpropertyParams(pydantic.BaseModel):
    ami_tags: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='')
    launch_permission_configuration: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnDistributionConfiguration_LaunchPermissionConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    target_account_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnDistributionConfigurationDefContainerdistributionconfigurationpropertyParams(pydantic.BaseModel):
    container_tags: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    target_repository: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnDistributionConfiguration_TargetContainerRepositoryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnDistributionConfigurationDefDistributionpropertyParams(pydantic.BaseModel):
    region: str = pydantic.Field(..., description='')
    ami_distribution_configuration: typing.Any = pydantic.Field(None, description='')
    container_distribution_configuration: typing.Any = pydantic.Field(None, description='')
    fast_launch_configurations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnDistributionConfiguration_FastLaunchConfigurationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    launch_template_configurations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnDistributionConfiguration_LaunchTemplateConfigurationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    license_configuration_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnDistributionConfigurationDefFastlaunchconfigurationpropertyParams(pydantic.BaseModel):
    account_id: typing.Optional[str] = pydantic.Field(None, description='')
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    launch_template: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnDistributionConfiguration_FastLaunchLaunchTemplateSpecificationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    max_parallel_launches: typing.Union[int, float, None] = pydantic.Field(None, description='')
    snapshot_configuration: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnDistributionConfiguration_FastLaunchSnapshotConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnDistributionConfigurationDefFastlaunchlaunchtemplatespecificationpropertyParams(pydantic.BaseModel):
    launch_template_id: typing.Optional[str] = pydantic.Field(None, description='')
    launch_template_name: typing.Optional[str] = pydantic.Field(None, description='')
    launch_template_version: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDistributionConfigurationDefFastlaunchsnapshotconfigurationpropertyParams(pydantic.BaseModel):
    target_resource_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnDistributionConfigurationDefLaunchpermissionconfigurationpropertyParams(pydantic.BaseModel):
    organizational_unit_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    organization_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    user_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    user_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnDistributionConfigurationDefLaunchtemplateconfigurationpropertyParams(pydantic.BaseModel):
    account_id: typing.Optional[str] = pydantic.Field(None, description='')
    launch_template_id: typing.Optional[str] = pydantic.Field(None, description='')
    set_default_version: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnDistributionConfigurationDefTargetcontainerrepositorypropertyParams(pydantic.BaseModel):
    repository_name: typing.Optional[str] = pydantic.Field(None, description='')
    service: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDistributionConfigurationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDistributionConfigurationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDistributionConfigurationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDistributionConfigurationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDistributionConfigurationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDistributionConfigurationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDistributionConfigurationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDistributionConfigurationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDistributionConfigurationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDistributionConfigurationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDistributionConfigurationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDistributionConfigurationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDistributionConfigurationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDistributionConfigurationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_imagebuilder.CfnImage
class CfnImageDef(BaseCfnResource):
    infrastructure_configuration_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the infrastructure configuration that defines the environment in which your image will be built and tested.\n')
    container_recipe_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the container recipe that defines how images are configured and tested.\n')
    distribution_configuration_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the distribution configuration that defines and configures the outputs of your pipeline.\n')
    enhanced_image_metadata_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.\n')
    execution_role: typing.Optional[str] = pydantic.Field(None, description='The name or Amazon Resource Name (ARN) for the IAM role you create that grants Image Builder access to perform workflow actions.\n')
    image_recipe_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the image recipe that defines how images are configured, tested, and assessed.\n')
    image_scanning_configuration: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImage_ImageScanningConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains settings for vulnerability scans.\n')
    image_tests_configuration: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImage_ImageTestsConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The image tests configuration of the image.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The tags of the image.\n')
    workflows: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImage_WorkflowConfigurationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Contains an array of workflow configuration objects.')
    _init_params: typing.ClassVar[list[str]] = ['infrastructure_configuration_arn', 'container_recipe_arn', 'distribution_configuration_arn', 'enhanced_image_metadata_enabled', 'execution_role', 'image_recipe_arn', 'image_scanning_configuration', 'image_tests_configuration', 'tags', 'workflows']
    _method_names: typing.ClassVar[list[str]] = ['EcrConfigurationProperty', 'ImageScanningConfigurationProperty', 'ImageTestsConfigurationProperty', 'WorkflowConfigurationProperty', 'WorkflowParameterProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImage'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_imagebuilder.CfnImageDefConfig] = pydantic.Field(None)


class CfnImageDefConfig(pydantic.BaseModel):
    EcrConfigurationProperty: typing.Optional[list[models.aws_imagebuilder.CfnImageDefEcrconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ImageScanningConfigurationProperty: typing.Optional[list[models.aws_imagebuilder.CfnImageDefImagescanningconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ImageTestsConfigurationProperty: typing.Optional[list[models.aws_imagebuilder.CfnImageDefImagetestsconfigurationpropertyParams]] = pydantic.Field(None, description='')
    WorkflowConfigurationProperty: typing.Optional[list[models.aws_imagebuilder.CfnImageDefWorkflowconfigurationpropertyParams]] = pydantic.Field(None, description='')
    WorkflowParameterProperty: typing.Optional[list[models.aws_imagebuilder.CfnImageDefWorkflowparameterpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_imagebuilder.CfnImageDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_imagebuilder.CfnImageDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_imagebuilder.CfnImageDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_imagebuilder.CfnImageDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_imagebuilder.CfnImageDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_imagebuilder.CfnImageDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_imagebuilder.CfnImageDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_imagebuilder.CfnImageDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_imagebuilder.CfnImageDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_imagebuilder.CfnImageDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_imagebuilder.CfnImageDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_imagebuilder.CfnImageDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_imagebuilder.CfnImageDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnImageDefEcrconfigurationpropertyParams(pydantic.BaseModel):
    container_tags: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    repository_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnImageDefImagescanningconfigurationpropertyParams(pydantic.BaseModel):
    ecr_configuration: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImage_EcrConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    image_scanning_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnImageDefImagetestsconfigurationpropertyParams(pydantic.BaseModel):
    image_tests_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    timeout_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnImageDefWorkflowconfigurationpropertyParams(pydantic.BaseModel):
    on_failure: typing.Optional[str] = pydantic.Field(None, description='')
    parallel_group: typing.Optional[str] = pydantic.Field(None, description='')
    parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImage_WorkflowParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    workflow_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnImageDefWorkflowparameterpropertyParams(pydantic.BaseModel):
    name: typing.Optional[str] = pydantic.Field(None, description='')
    value: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnImageDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnImageDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnImageDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnImageDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnImageDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnImageDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnImageDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnImageDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnImageDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnImageDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnImageDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnImageDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnImageDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnImageDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_imagebuilder.CfnImagePipeline
class CfnImagePipelineDef(BaseCfnResource):
    infrastructure_configuration_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the infrastructure configuration associated with this image pipeline.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the image pipeline.\n')
    container_recipe_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the container recipe that is used for this pipeline.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of this image pipeline.\n')
    distribution_configuration_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the distribution configuration associated with this image pipeline.\n')
    enhanced_image_metadata_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.\n')
    execution_role: typing.Optional[str] = pydantic.Field(None, description='The name or Amazon Resource Name (ARN) for the IAM role you create that grants Image Builder access to perform workflow actions.\n')
    image_recipe_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the image recipe associated with this image pipeline.\n')
    image_scanning_configuration: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImagePipeline_ImageScanningConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains settings for vulnerability scans.\n')
    image_tests_configuration: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImagePipeline_ImageTestsConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration of the image tests that run after image creation to ensure the quality of the image that was created.\n')
    schedule: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImagePipeline_SchedulePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The schedule of the image pipeline. A schedule configures how often and when a pipeline automatically creates a new image.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='The status of the image pipeline.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The tags of this image pipeline.\n')
    workflows: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImagePipeline_WorkflowConfigurationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Contains the workflows that run for the image pipeline.')
    _init_params: typing.ClassVar[list[str]] = ['infrastructure_configuration_arn', 'name', 'container_recipe_arn', 'description', 'distribution_configuration_arn', 'enhanced_image_metadata_enabled', 'execution_role', 'image_recipe_arn', 'image_scanning_configuration', 'image_tests_configuration', 'schedule', 'status', 'tags', 'workflows']
    _method_names: typing.ClassVar[list[str]] = ['EcrConfigurationProperty', 'ImageScanningConfigurationProperty', 'ImageTestsConfigurationProperty', 'ScheduleProperty', 'WorkflowConfigurationProperty', 'WorkflowParameterProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImagePipeline'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_imagebuilder.CfnImagePipelineDefConfig] = pydantic.Field(None)


class CfnImagePipelineDefConfig(pydantic.BaseModel):
    EcrConfigurationProperty: typing.Optional[list[models.aws_imagebuilder.CfnImagePipelineDefEcrconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ImageScanningConfigurationProperty: typing.Optional[list[models.aws_imagebuilder.CfnImagePipelineDefImagescanningconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ImageTestsConfigurationProperty: typing.Optional[list[models.aws_imagebuilder.CfnImagePipelineDefImagetestsconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ScheduleProperty: typing.Optional[list[models.aws_imagebuilder.CfnImagePipelineDefSchedulepropertyParams]] = pydantic.Field(None, description='')
    WorkflowConfigurationProperty: typing.Optional[list[models.aws_imagebuilder.CfnImagePipelineDefWorkflowconfigurationpropertyParams]] = pydantic.Field(None, description='')
    WorkflowParameterProperty: typing.Optional[list[models.aws_imagebuilder.CfnImagePipelineDefWorkflowparameterpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_imagebuilder.CfnImagePipelineDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_imagebuilder.CfnImagePipelineDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_imagebuilder.CfnImagePipelineDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_imagebuilder.CfnImagePipelineDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_imagebuilder.CfnImagePipelineDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_imagebuilder.CfnImagePipelineDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_imagebuilder.CfnImagePipelineDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_imagebuilder.CfnImagePipelineDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_imagebuilder.CfnImagePipelineDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_imagebuilder.CfnImagePipelineDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_imagebuilder.CfnImagePipelineDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_imagebuilder.CfnImagePipelineDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_imagebuilder.CfnImagePipelineDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnImagePipelineDefEcrconfigurationpropertyParams(pydantic.BaseModel):
    container_tags: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    repository_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnImagePipelineDefImagescanningconfigurationpropertyParams(pydantic.BaseModel):
    ecr_configuration: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImagePipeline_EcrConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    image_scanning_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnImagePipelineDefImagetestsconfigurationpropertyParams(pydantic.BaseModel):
    image_tests_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    timeout_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnImagePipelineDefSchedulepropertyParams(pydantic.BaseModel):
    pipeline_execution_start_condition: typing.Optional[str] = pydantic.Field(None, description='')
    schedule_expression: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnImagePipelineDefWorkflowconfigurationpropertyParams(pydantic.BaseModel):
    on_failure: typing.Optional[str] = pydantic.Field(None, description='')
    parallel_group: typing.Optional[str] = pydantic.Field(None, description='')
    parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImagePipeline_WorkflowParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    workflow_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnImagePipelineDefWorkflowparameterpropertyParams(pydantic.BaseModel):
    name: typing.Optional[str] = pydantic.Field(None, description='')
    value: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnImagePipelineDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnImagePipelineDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnImagePipelineDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnImagePipelineDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnImagePipelineDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnImagePipelineDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnImagePipelineDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnImagePipelineDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnImagePipelineDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnImagePipelineDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnImagePipelineDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnImagePipelineDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnImagePipelineDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnImagePipelineDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_imagebuilder.CfnImageRecipe
class CfnImageRecipeDef(BaseCfnResource):
    components: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImageRecipe_ComponentConfigurationPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The components of the image recipe. Components are orchestration documents that define a sequence of steps for downloading, installing, configuring, and testing software packages. They also define validation and security hardening steps. A component is defined using a YAML document format.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the image recipe.\n')
    parent_image: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The parent image of the image recipe. The string must be either an Image ARN or an AMI ID.\n')
    version: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The semantic version of the image recipe.\n')
    additional_instance_configuration: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImageRecipe_AdditionalInstanceConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Before you create a new AMI, Image Builder launches temporary Amazon EC2 instances to build and test your image configuration. Instance configuration adds a layer of control over those instances. You can define settings and add scripts to run when an instance is launched from your AMI.\n')
    block_device_mappings: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImageRecipe_InstanceBlockDeviceMappingPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The block device mappings to apply when creating images from this recipe.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the image recipe.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The tags of the image recipe.\n')
    working_directory: typing.Optional[str] = pydantic.Field(None, description='The working directory to be used during build and test workflows.')
    _init_params: typing.ClassVar[list[str]] = ['components', 'name', 'parent_image', 'version', 'additional_instance_configuration', 'block_device_mappings', 'description', 'tags', 'working_directory']
    _method_names: typing.ClassVar[list[str]] = ['AdditionalInstanceConfigurationProperty', 'ComponentConfigurationProperty', 'ComponentParameterProperty', 'EbsInstanceBlockDeviceSpecificationProperty', 'InstanceBlockDeviceMappingProperty', 'SystemsManagerAgentProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImageRecipe'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_imagebuilder.CfnImageRecipeDefConfig] = pydantic.Field(None)


class CfnImageRecipeDefConfig(pydantic.BaseModel):
    AdditionalInstanceConfigurationProperty: typing.Optional[list[models.aws_imagebuilder.CfnImageRecipeDefAdditionalinstanceconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ComponentConfigurationProperty: typing.Optional[list[models.aws_imagebuilder.CfnImageRecipeDefComponentconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ComponentParameterProperty: typing.Optional[list[models.aws_imagebuilder.CfnImageRecipeDefComponentparameterpropertyParams]] = pydantic.Field(None, description='')
    EbsInstanceBlockDeviceSpecificationProperty: typing.Optional[list[models.aws_imagebuilder.CfnImageRecipeDefEbsinstanceblockdevicespecificationpropertyParams]] = pydantic.Field(None, description='')
    InstanceBlockDeviceMappingProperty: typing.Optional[list[models.aws_imagebuilder.CfnImageRecipeDefInstanceblockdevicemappingpropertyParams]] = pydantic.Field(None, description='')
    SystemsManagerAgentProperty: typing.Optional[list[models.aws_imagebuilder.CfnImageRecipeDefSystemsmanageragentpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_imagebuilder.CfnImageRecipeDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_imagebuilder.CfnImageRecipeDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_imagebuilder.CfnImageRecipeDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_imagebuilder.CfnImageRecipeDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_imagebuilder.CfnImageRecipeDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_imagebuilder.CfnImageRecipeDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_imagebuilder.CfnImageRecipeDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_imagebuilder.CfnImageRecipeDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_imagebuilder.CfnImageRecipeDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_imagebuilder.CfnImageRecipeDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_imagebuilder.CfnImageRecipeDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_imagebuilder.CfnImageRecipeDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_imagebuilder.CfnImageRecipeDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnImageRecipeDefAdditionalinstanceconfigurationpropertyParams(pydantic.BaseModel):
    systems_manager_agent: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImageRecipe_SystemsManagerAgentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    user_data_override: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnImageRecipeDefComponentconfigurationpropertyParams(pydantic.BaseModel):
    component_arn: typing.Optional[str] = pydantic.Field(None, description='')
    parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImageRecipe_ComponentParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnImageRecipeDefComponentparameterpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    value: typing.Sequence[str] = pydantic.Field(..., description='')
    ...

class CfnImageRecipeDefEbsinstanceblockdevicespecificationpropertyParams(pydantic.BaseModel):
    delete_on_termination: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    encrypted: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='')
    snapshot_id: typing.Optional[str] = pydantic.Field(None, description='')
    throughput: typing.Union[int, float, None] = pydantic.Field(None, description='')
    volume_size: typing.Union[int, float, None] = pydantic.Field(None, description='')
    volume_type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnImageRecipeDefInstanceblockdevicemappingpropertyParams(pydantic.BaseModel):
    device_name: typing.Optional[str] = pydantic.Field(None, description='')
    ebs: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImageRecipe_EbsInstanceBlockDeviceSpecificationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    no_device: typing.Optional[str] = pydantic.Field(None, description='')
    virtual_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnImageRecipeDefSystemsmanageragentpropertyParams(pydantic.BaseModel):
    uninstall_after_build: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnImageRecipeDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnImageRecipeDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnImageRecipeDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnImageRecipeDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnImageRecipeDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnImageRecipeDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnImageRecipeDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnImageRecipeDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnImageRecipeDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnImageRecipeDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnImageRecipeDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnImageRecipeDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnImageRecipeDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnImageRecipeDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_imagebuilder.CfnInfrastructureConfiguration
class CfnInfrastructureConfigurationDef(BaseCfnResource):
    instance_profile_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The instance profile of the infrastructure configuration.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the infrastructure configuration.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the infrastructure configuration.\n')
    instance_metadata_options: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnInfrastructureConfiguration_InstanceMetadataOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The instance metadata option settings for the infrastructure configuration.\n')
    instance_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The instance types of the infrastructure configuration.\n')
    key_pair: typing.Optional[str] = pydantic.Field(None, description='The Amazon EC2 key pair of the infrastructure configuration.\n')
    logging: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnInfrastructureConfiguration_LoggingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The logging configuration defines where Image Builder uploads your logs.\n')
    resource_tags: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='The tags attached to the resource created by Image Builder.\n')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The security group IDs of the infrastructure configuration.\n')
    sns_topic_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the SNS topic for the infrastructure configuration.\n')
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='The subnet ID of the infrastructure configuration.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The tags of the infrastructure configuration.\n')
    terminate_instance_on_failure: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='The terminate instance on failure configuration of the infrastructure configuration.')
    _init_params: typing.ClassVar[list[str]] = ['instance_profile_name', 'name', 'description', 'instance_metadata_options', 'instance_types', 'key_pair', 'logging', 'resource_tags', 'security_group_ids', 'sns_topic_arn', 'subnet_id', 'tags', 'terminate_instance_on_failure']
    _method_names: typing.ClassVar[list[str]] = ['InstanceMetadataOptionsProperty', 'LoggingProperty', 'S3LogsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnInfrastructureConfiguration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_imagebuilder.CfnInfrastructureConfigurationDefConfig] = pydantic.Field(None)


class CfnInfrastructureConfigurationDefConfig(pydantic.BaseModel):
    InstanceMetadataOptionsProperty: typing.Optional[list[models.aws_imagebuilder.CfnInfrastructureConfigurationDefInstancemetadataoptionspropertyParams]] = pydantic.Field(None, description='')
    LoggingProperty: typing.Optional[list[models.aws_imagebuilder.CfnInfrastructureConfigurationDefLoggingpropertyParams]] = pydantic.Field(None, description='')
    S3LogsProperty: typing.Optional[list[models.aws_imagebuilder.CfnInfrastructureConfigurationDefS3LogspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_imagebuilder.CfnInfrastructureConfigurationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_imagebuilder.CfnInfrastructureConfigurationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_imagebuilder.CfnInfrastructureConfigurationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_imagebuilder.CfnInfrastructureConfigurationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_imagebuilder.CfnInfrastructureConfigurationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_imagebuilder.CfnInfrastructureConfigurationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_imagebuilder.CfnInfrastructureConfigurationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_imagebuilder.CfnInfrastructureConfigurationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_imagebuilder.CfnInfrastructureConfigurationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_imagebuilder.CfnInfrastructureConfigurationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_imagebuilder.CfnInfrastructureConfigurationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_imagebuilder.CfnInfrastructureConfigurationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_imagebuilder.CfnInfrastructureConfigurationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnInfrastructureConfigurationDefInstancemetadataoptionspropertyParams(pydantic.BaseModel):
    http_put_response_hop_limit: typing.Union[int, float, None] = pydantic.Field(None, description='')
    http_tokens: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnInfrastructureConfigurationDefLoggingpropertyParams(pydantic.BaseModel):
    s3_logs: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnInfrastructureConfiguration_S3LogsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnInfrastructureConfigurationDefS3LogspropertyParams(pydantic.BaseModel):
    s3_bucket_name: typing.Optional[str] = pydantic.Field(None, description='')
    s3_key_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnInfrastructureConfigurationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnInfrastructureConfigurationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnInfrastructureConfigurationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnInfrastructureConfigurationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnInfrastructureConfigurationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnInfrastructureConfigurationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnInfrastructureConfigurationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnInfrastructureConfigurationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnInfrastructureConfigurationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnInfrastructureConfigurationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnInfrastructureConfigurationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnInfrastructureConfigurationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnInfrastructureConfigurationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnInfrastructureConfigurationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_imagebuilder.CfnLifecyclePolicy
class CfnLifecyclePolicyDef(BaseCfnResource):
    execution_role: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name or Amazon Resource Name (ARN) for the IAM role you create that grants Image Builder access to run lifecycle actions.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the lifecycle policy to create.\n')
    policy_details: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnLifecyclePolicy_PolicyDetailPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Configuration details for the lifecycle policy rules.\n')
    resource_selection: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_imagebuilder.CfnLifecyclePolicy_ResourceSelectionPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Selection criteria for the resources that the lifecycle policy applies to.\n')
    resource_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of Image Builder resource that the lifecycle policy applies to.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Optional description for the lifecycle policy.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='Indicates whether the lifecycle policy resource is enabled.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Tags to apply to the lifecycle policy resource.')
    _init_params: typing.ClassVar[list[str]] = ['execution_role', 'name', 'policy_details', 'resource_selection', 'resource_type', 'description', 'status', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['ActionProperty', 'AmiExclusionRulesProperty', 'ExclusionRulesProperty', 'FilterProperty', 'IncludeResourcesProperty', 'LastLaunchedProperty', 'PolicyDetailProperty', 'RecipeSelectionProperty', 'ResourceSelectionProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnLifecyclePolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_imagebuilder.CfnLifecyclePolicyDefConfig] = pydantic.Field(None)


class CfnLifecyclePolicyDefConfig(pydantic.BaseModel):
    ActionProperty: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefActionpropertyParams]] = pydantic.Field(None, description='')
    AmiExclusionRulesProperty: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefAmiexclusionrulespropertyParams]] = pydantic.Field(None, description='')
    ExclusionRulesProperty: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefExclusionrulespropertyParams]] = pydantic.Field(None, description='')
    FilterProperty: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefFilterpropertyParams]] = pydantic.Field(None, description='')
    IncludeResourcesProperty: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefIncluderesourcespropertyParams]] = pydantic.Field(None, description='')
    LastLaunchedProperty: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefLastlaunchedpropertyParams]] = pydantic.Field(None, description='')
    PolicyDetailProperty: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefPolicydetailpropertyParams]] = pydantic.Field(None, description='')
    RecipeSelectionProperty: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefRecipeselectionpropertyParams]] = pydantic.Field(None, description='')
    ResourceSelectionProperty: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefResourceselectionpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_imagebuilder.CfnLifecyclePolicyDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnLifecyclePolicyDefActionpropertyParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='')
    include_resources: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnLifecyclePolicy_IncludeResourcesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnLifecyclePolicyDefAmiexclusionrulespropertyParams(pydantic.BaseModel):
    is_public: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    last_launched: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnLifecyclePolicy_LastLaunchedPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    regions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    shared_accounts: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    tag_map: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    ...

class CfnLifecyclePolicyDefExclusionrulespropertyParams(pydantic.BaseModel):
    amis: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnLifecyclePolicy_AmiExclusionRulesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    tag_map: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    ...

class CfnLifecyclePolicyDefFilterpropertyParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='')
    value: typing.Union[int, float] = pydantic.Field(..., description='')
    retain_at_least: typing.Union[int, float, None] = pydantic.Field(None, description='')
    unit: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLifecyclePolicyDefIncluderesourcespropertyParams(pydantic.BaseModel):
    amis: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    containers: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    snapshots: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnLifecyclePolicyDefLastlaunchedpropertyParams(pydantic.BaseModel):
    unit: str = pydantic.Field(..., description='')
    value: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnLifecyclePolicyDefPolicydetailpropertyParams(pydantic.BaseModel):
    action: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnLifecyclePolicy_ActionPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    filter: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnLifecyclePolicy_FilterPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    exclusion_rules: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnLifecyclePolicy_ExclusionRulesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnLifecyclePolicyDefRecipeselectionpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    semantic_version: str = pydantic.Field(..., description='')
    ...

class CfnLifecyclePolicyDefResourceselectionpropertyParams(pydantic.BaseModel):
    recipes: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnLifecyclePolicy_RecipeSelectionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    tag_map: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    ...

class CfnLifecyclePolicyDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnLifecyclePolicyDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLifecyclePolicyDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnLifecyclePolicyDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLifecyclePolicyDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnLifecyclePolicyDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnLifecyclePolicyDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnLifecyclePolicyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnLifecyclePolicyDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnLifecyclePolicyDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLifecyclePolicyDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnLifecyclePolicyDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnLifecyclePolicyDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLifecyclePolicyDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_imagebuilder.CfnWorkflow
class CfnWorkflowDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the workflow to create.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The phase in the image build process for which the workflow resource is responsible.\n')
    version: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The semantic version of this workflow resource. The semantic version syntax adheres to the following rules. .. epigraph:: The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. *Assignment:* For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. *Patterns:* You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.\n')
    change_description: typing.Optional[str] = pydantic.Field(None, description='Describes what change has been made in this version of the workflow, or what makes this version different from other versions of the workflow.\n')
    data: typing.Optional[str] = pydantic.Field(None, description='Contains the UTF-8 encoded YAML document content for the workflow. Alternatively, you can specify the ``uri`` of a YAML document file stored in Amazon S3. However, you cannot specify both properties.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Describes the workflow.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the KMS key that is used to encrypt this workflow resource.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Tags that apply to the workflow resource.\n')
    uri: typing.Optional[str] = pydantic.Field(None, description='The ``uri`` of a YAML component document file. This must be an S3 URL ( ``s3://bucket/key`` ), and the requester must have permission to access the S3 bucket it points to. If you use Amazon S3, you can specify component content up to your service quota. Alternatively, you can specify the YAML document inline, using the component ``data`` property. You cannot specify both properties.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'type', 'version', 'change_description', 'data', 'description', 'kms_key_id', 'tags', 'uri']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnWorkflow'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_imagebuilder.CfnWorkflowDefConfig] = pydantic.Field(None)


class CfnWorkflowDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_imagebuilder.CfnWorkflowDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_imagebuilder.CfnWorkflowDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_imagebuilder.CfnWorkflowDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_imagebuilder.CfnWorkflowDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_imagebuilder.CfnWorkflowDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_imagebuilder.CfnWorkflowDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_imagebuilder.CfnWorkflowDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_imagebuilder.CfnWorkflowDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_imagebuilder.CfnWorkflowDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_imagebuilder.CfnWorkflowDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_imagebuilder.CfnWorkflowDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_imagebuilder.CfnWorkflowDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_imagebuilder.CfnWorkflowDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnWorkflowDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnWorkflowDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnWorkflowDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnWorkflowDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnWorkflowDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnWorkflowDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnWorkflowDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnWorkflowDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnWorkflowDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnWorkflowDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnWorkflowDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnWorkflowDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnWorkflowDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnWorkflowDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_imagebuilder.CfnComponentProps
class CfnComponentPropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the component.\n')
    platform: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The operating system platform of the component.\n')
    version: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The component version. For example, ``1.0.0`` .\n')
    change_description: typing.Optional[str] = pydantic.Field(None, description='The change description of the component. Describes what change has been made in this version, or what makes this version different from other versions of the component.\n')
    data: typing.Optional[str] = pydantic.Field(None, description='Component ``data`` contains inline YAML document content for the component. Alternatively, you can specify the ``uri`` of a YAML document file stored in Amazon S3. However, you cannot specify both properties.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Describes the contents of the component.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the KMS key that is used to encrypt this component.\n')
    supported_os_versions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The operating system (OS) version supported by the component. If the OS information is available, a prefix match is performed against the base image OS version during image recipe creation.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The tags that apply to the component.\n')
    uri: typing.Optional[str] = pydantic.Field(None, description='The ``uri`` of a YAML component document file. This must be an S3 URL ( ``s3://bucket/key`` ), and the requester must have permission to access the S3 bucket it points to. If you use Amazon S3, you can specify component content up to your service quota. Alternatively, you can specify the YAML document inline, using the component ``data`` property. You cannot specify both properties.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-imagebuilder-component.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    cfn_component_props = imagebuilder.CfnComponentProps(\n        name="name",\n        platform="platform",\n        version="version",\n\n        # the properties below are optional\n        change_description="changeDescription",\n        data="data",\n        description="description",\n        kms_key_id="kmsKeyId",\n        supported_os_versions=["supportedOsVersions"],\n        tags={\n            "tags_key": "tags"\n        },\n        uri="uri"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'platform', 'version', 'change_description', 'data', 'description', 'kms_key_id', 'supported_os_versions', 'tags', 'uri']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnComponentProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnContainerRecipeProps
class CfnContainerRecipePropsDef(BaseCfnProperty):
    components: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnContainerRecipe_ComponentConfigurationPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Build and test components that are included in the container recipe. Recipes require a minimum of one build component, and can have a maximum of 20 build and test components in any combination.\n')
    container_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the type of container, such as Docker.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the container recipe.\n')
    parent_image: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The base image for the container recipe.\n')
    target_repository: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_imagebuilder.CfnContainerRecipe_TargetContainerRepositoryPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The destination repository for the container image.\n')
    version: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The semantic version of the container recipe. .. epigraph:: The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. *Assignment:* For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. *Patterns:* You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01. *Filtering:* With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the container recipe.\n')
    dockerfile_template_data: typing.Optional[str] = pydantic.Field(None, description='Dockerfiles are text documents that are used to build Docker containers, and ensure that they contain all of the elements required by the application running inside. The template data consists of contextual variables where Image Builder places build information or scripts, based on your container image recipe.\n')
    dockerfile_template_uri: typing.Optional[str] = pydantic.Field(None, description='The S3 URI for the Dockerfile that will be used to build your container image.\n')
    image_os_version_override: typing.Optional[str] = pydantic.Field(None, description='Specifies the operating system version for the base image.\n')
    instance_configuration: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnContainerRecipe_InstanceConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A group of options that can be used to configure an instance for building and testing container images.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='Identifies which KMS key is used to encrypt the container image for distribution to the target Region.\n')
    platform_override: typing.Optional[str] = pydantic.Field(None, description='Specifies the operating system platform when you use a custom base image.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Tags that are attached to the container recipe.\n')
    working_directory: typing.Optional[str] = pydantic.Field(None, description='The working directory for use during build and test workflows.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-imagebuilder-containerrecipe.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    cfn_container_recipe_props = imagebuilder.CfnContainerRecipeProps(\n        components=[imagebuilder.CfnContainerRecipe.ComponentConfigurationProperty(\n            component_arn="componentArn",\n            parameters=[imagebuilder.CfnContainerRecipe.ComponentParameterProperty(\n                name="name",\n                value=["value"]\n            )]\n        )],\n        container_type="containerType",\n        name="name",\n        parent_image="parentImage",\n        target_repository=imagebuilder.CfnContainerRecipe.TargetContainerRepositoryProperty(\n            repository_name="repositoryName",\n            service="service"\n        ),\n        version="version",\n\n        # the properties below are optional\n        description="description",\n        dockerfile_template_data="dockerfileTemplateData",\n        dockerfile_template_uri="dockerfileTemplateUri",\n        image_os_version_override="imageOsVersionOverride",\n        instance_configuration=imagebuilder.CfnContainerRecipe.InstanceConfigurationProperty(\n            block_device_mappings=[imagebuilder.CfnContainerRecipe.InstanceBlockDeviceMappingProperty(\n                device_name="deviceName",\n                ebs=imagebuilder.CfnContainerRecipe.EbsInstanceBlockDeviceSpecificationProperty(\n                    delete_on_termination=False,\n                    encrypted=False,\n                    iops=123,\n                    kms_key_id="kmsKeyId",\n                    snapshot_id="snapshotId",\n                    throughput=123,\n                    volume_size=123,\n                    volume_type="volumeType"\n                ),\n                no_device="noDevice",\n                virtual_name="virtualName"\n            )],\n            image="image"\n        ),\n        kms_key_id="kmsKeyId",\n        platform_override="platformOverride",\n        tags={\n            "tags_key": "tags"\n        },\n        working_directory="workingDirectory"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['components', 'container_type', 'name', 'parent_image', 'target_repository', 'version', 'description', 'dockerfile_template_data', 'dockerfile_template_uri', 'image_os_version_override', 'instance_configuration', 'kms_key_id', 'platform_override', 'tags', 'working_directory']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnContainerRecipeProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnDistributionConfigurationProps
class CfnDistributionConfigurationPropsDef(BaseCfnProperty):
    distributions: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnDistributionConfiguration_DistributionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The distributions of this distribution configuration formatted as an array of Distribution objects.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of this distribution configuration.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of this distribution configuration.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The tags of this distribution configuration.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-imagebuilder-distributionconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    # ami_distribution_configuration: Any\n    # container_distribution_configuration: Any\n\n    cfn_distribution_configuration_props = imagebuilder.CfnDistributionConfigurationProps(\n        distributions=[imagebuilder.CfnDistributionConfiguration.DistributionProperty(\n            region="region",\n\n            # the properties below are optional\n            ami_distribution_configuration=ami_distribution_configuration,\n            container_distribution_configuration=container_distribution_configuration,\n            fast_launch_configurations=[imagebuilder.CfnDistributionConfiguration.FastLaunchConfigurationProperty(\n                account_id="accountId",\n                enabled=False,\n                launch_template=imagebuilder.CfnDistributionConfiguration.FastLaunchLaunchTemplateSpecificationProperty(\n                    launch_template_id="launchTemplateId",\n                    launch_template_name="launchTemplateName",\n                    launch_template_version="launchTemplateVersion"\n                ),\n                max_parallel_launches=123,\n                snapshot_configuration=imagebuilder.CfnDistributionConfiguration.FastLaunchSnapshotConfigurationProperty(\n                    target_resource_count=123\n                )\n            )],\n            launch_template_configurations=[imagebuilder.CfnDistributionConfiguration.LaunchTemplateConfigurationProperty(\n                account_id="accountId",\n                launch_template_id="launchTemplateId",\n                set_default_version=False\n            )],\n            license_configuration_arns=["licenseConfigurationArns"]\n        )],\n        name="name",\n\n        # the properties below are optional\n        description="description",\n        tags={\n            "tags_key": "tags"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['distributions', 'name', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnDistributionConfigurationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnImagePipelineProps
class CfnImagePipelinePropsDef(BaseCfnProperty):
    infrastructure_configuration_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the infrastructure configuration associated with this image pipeline.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the image pipeline.\n')
    container_recipe_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the container recipe that is used for this pipeline.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of this image pipeline.\n')
    distribution_configuration_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the distribution configuration associated with this image pipeline.\n')
    enhanced_image_metadata_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.\n')
    execution_role: typing.Optional[str] = pydantic.Field(None, description='The name or Amazon Resource Name (ARN) for the IAM role you create that grants Image Builder access to perform workflow actions.\n')
    image_recipe_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the image recipe associated with this image pipeline.\n')
    image_scanning_configuration: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImagePipeline_ImageScanningConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains settings for vulnerability scans.\n')
    image_tests_configuration: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImagePipeline_ImageTestsConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration of the image tests that run after image creation to ensure the quality of the image that was created.\n')
    schedule: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImagePipeline_SchedulePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The schedule of the image pipeline. A schedule configures how often and when a pipeline automatically creates a new image.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='The status of the image pipeline.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The tags of this image pipeline.\n')
    workflows: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImagePipeline_WorkflowConfigurationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Contains the workflows that run for the image pipeline.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-imagebuilder-imagepipeline.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    cfn_image_pipeline_props = imagebuilder.CfnImagePipelineProps(\n        infrastructure_configuration_arn="infrastructureConfigurationArn",\n        name="name",\n\n        # the properties below are optional\n        container_recipe_arn="containerRecipeArn",\n        description="description",\n        distribution_configuration_arn="distributionConfigurationArn",\n        enhanced_image_metadata_enabled=False,\n        execution_role="executionRole",\n        image_recipe_arn="imageRecipeArn",\n        image_scanning_configuration=imagebuilder.CfnImagePipeline.ImageScanningConfigurationProperty(\n            ecr_configuration=imagebuilder.CfnImagePipeline.EcrConfigurationProperty(\n                container_tags=["containerTags"],\n                repository_name="repositoryName"\n            ),\n            image_scanning_enabled=False\n        ),\n        image_tests_configuration=imagebuilder.CfnImagePipeline.ImageTestsConfigurationProperty(\n            image_tests_enabled=False,\n            timeout_minutes=123\n        ),\n        schedule=imagebuilder.CfnImagePipeline.ScheduleProperty(\n            pipeline_execution_start_condition="pipelineExecutionStartCondition",\n            schedule_expression="scheduleExpression"\n        ),\n        status="status",\n        tags={\n            "tags_key": "tags"\n        },\n        workflows=[imagebuilder.CfnImagePipeline.WorkflowConfigurationProperty(\n            on_failure="onFailure",\n            parallel_group="parallelGroup",\n            parameters=[imagebuilder.CfnImagePipeline.WorkflowParameterProperty(\n                name="name",\n                value=["value"]\n            )],\n            workflow_arn="workflowArn"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['infrastructure_configuration_arn', 'name', 'container_recipe_arn', 'description', 'distribution_configuration_arn', 'enhanced_image_metadata_enabled', 'execution_role', 'image_recipe_arn', 'image_scanning_configuration', 'image_tests_configuration', 'schedule', 'status', 'tags', 'workflows']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImagePipelineProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnImageProps
class CfnImagePropsDef(BaseCfnProperty):
    infrastructure_configuration_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the infrastructure configuration that defines the environment in which your image will be built and tested.\n')
    container_recipe_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the container recipe that defines how images are configured and tested.\n')
    distribution_configuration_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the distribution configuration that defines and configures the outputs of your pipeline.\n')
    enhanced_image_metadata_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.\n')
    execution_role: typing.Optional[str] = pydantic.Field(None, description='The name or Amazon Resource Name (ARN) for the IAM role you create that grants Image Builder access to perform workflow actions.\n')
    image_recipe_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the image recipe that defines how images are configured, tested, and assessed.\n')
    image_scanning_configuration: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImage_ImageScanningConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains settings for vulnerability scans.\n')
    image_tests_configuration: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImage_ImageTestsConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The image tests configuration of the image.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The tags of the image.\n')
    workflows: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImage_WorkflowConfigurationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Contains an array of workflow configuration objects.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-imagebuilder-image.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    cfn_image_props = imagebuilder.CfnImageProps(\n        infrastructure_configuration_arn="infrastructureConfigurationArn",\n\n        # the properties below are optional\n        container_recipe_arn="containerRecipeArn",\n        distribution_configuration_arn="distributionConfigurationArn",\n        enhanced_image_metadata_enabled=False,\n        execution_role="executionRole",\n        image_recipe_arn="imageRecipeArn",\n        image_scanning_configuration=imagebuilder.CfnImage.ImageScanningConfigurationProperty(\n            ecr_configuration=imagebuilder.CfnImage.EcrConfigurationProperty(\n                container_tags=["containerTags"],\n                repository_name="repositoryName"\n            ),\n            image_scanning_enabled=False\n        ),\n        image_tests_configuration=imagebuilder.CfnImage.ImageTestsConfigurationProperty(\n            image_tests_enabled=False,\n            timeout_minutes=123\n        ),\n        tags={\n            "tags_key": "tags"\n        },\n        workflows=[imagebuilder.CfnImage.WorkflowConfigurationProperty(\n            on_failure="onFailure",\n            parallel_group="parallelGroup",\n            parameters=[imagebuilder.CfnImage.WorkflowParameterProperty(\n                name="name",\n                value=["value"]\n            )],\n            workflow_arn="workflowArn"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['infrastructure_configuration_arn', 'container_recipe_arn', 'distribution_configuration_arn', 'enhanced_image_metadata_enabled', 'execution_role', 'image_recipe_arn', 'image_scanning_configuration', 'image_tests_configuration', 'tags', 'workflows']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImageProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnImageRecipeProps
class CfnImageRecipePropsDef(BaseCfnProperty):
    components: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImageRecipe_ComponentConfigurationPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The components of the image recipe. Components are orchestration documents that define a sequence of steps for downloading, installing, configuring, and testing software packages. They also define validation and security hardening steps. A component is defined using a YAML document format.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the image recipe.\n')
    parent_image: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The parent image of the image recipe. The string must be either an Image ARN or an AMI ID.\n')
    version: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The semantic version of the image recipe.\n')
    additional_instance_configuration: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImageRecipe_AdditionalInstanceConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Before you create a new AMI, Image Builder launches temporary Amazon EC2 instances to build and test your image configuration. Instance configuration adds a layer of control over those instances. You can define settings and add scripts to run when an instance is launched from your AMI.\n')
    block_device_mappings: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnImageRecipe_InstanceBlockDeviceMappingPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The block device mappings to apply when creating images from this recipe.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the image recipe.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The tags of the image recipe.\n')
    working_directory: typing.Optional[str] = pydantic.Field(None, description='The working directory to be used during build and test workflows.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-imagebuilder-imagerecipe.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    cfn_image_recipe_props = imagebuilder.CfnImageRecipeProps(\n        components=[imagebuilder.CfnImageRecipe.ComponentConfigurationProperty(\n            component_arn="componentArn",\n            parameters=[imagebuilder.CfnImageRecipe.ComponentParameterProperty(\n                name="name",\n                value=["value"]\n            )]\n        )],\n        name="name",\n        parent_image="parentImage",\n        version="version",\n\n        # the properties below are optional\n        additional_instance_configuration=imagebuilder.CfnImageRecipe.AdditionalInstanceConfigurationProperty(\n            systems_manager_agent=imagebuilder.CfnImageRecipe.SystemsManagerAgentProperty(\n                uninstall_after_build=False\n            ),\n            user_data_override="userDataOverride"\n        ),\n        block_device_mappings=[imagebuilder.CfnImageRecipe.InstanceBlockDeviceMappingProperty(\n            device_name="deviceName",\n            ebs=imagebuilder.CfnImageRecipe.EbsInstanceBlockDeviceSpecificationProperty(\n                delete_on_termination=False,\n                encrypted=False,\n                iops=123,\n                kms_key_id="kmsKeyId",\n                snapshot_id="snapshotId",\n                throughput=123,\n                volume_size=123,\n                volume_type="volumeType"\n            ),\n            no_device="noDevice",\n            virtual_name="virtualName"\n        )],\n        description="description",\n        tags={\n            "tags_key": "tags"\n        },\n        working_directory="workingDirectory"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['components', 'name', 'parent_image', 'version', 'additional_instance_configuration', 'block_device_mappings', 'description', 'tags', 'working_directory']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnImageRecipeProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnInfrastructureConfigurationProps
class CfnInfrastructureConfigurationPropsDef(BaseCfnProperty):
    instance_profile_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The instance profile of the infrastructure configuration.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the infrastructure configuration.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the infrastructure configuration.\n')
    instance_metadata_options: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnInfrastructureConfiguration_InstanceMetadataOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The instance metadata option settings for the infrastructure configuration.\n')
    instance_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The instance types of the infrastructure configuration.\n')
    key_pair: typing.Optional[str] = pydantic.Field(None, description='The Amazon EC2 key pair of the infrastructure configuration.\n')
    logging: typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnInfrastructureConfiguration_LoggingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The logging configuration defines where Image Builder uploads your logs.\n')
    resource_tags: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='The tags attached to the resource created by Image Builder.\n')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The security group IDs of the infrastructure configuration.\n')
    sns_topic_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the SNS topic for the infrastructure configuration.\n')
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='The subnet ID of the infrastructure configuration.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The tags of the infrastructure configuration.\n')
    terminate_instance_on_failure: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='The terminate instance on failure configuration of the infrastructure configuration.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-imagebuilder-infrastructureconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    cfn_infrastructure_configuration_props = imagebuilder.CfnInfrastructureConfigurationProps(\n        instance_profile_name="instanceProfileName",\n        name="name",\n\n        # the properties below are optional\n        description="description",\n        instance_metadata_options=imagebuilder.CfnInfrastructureConfiguration.InstanceMetadataOptionsProperty(\n            http_put_response_hop_limit=123,\n            http_tokens="httpTokens"\n        ),\n        instance_types=["instanceTypes"],\n        key_pair="keyPair",\n        logging=imagebuilder.CfnInfrastructureConfiguration.LoggingProperty(\n            s3_logs=imagebuilder.CfnInfrastructureConfiguration.S3LogsProperty(\n                s3_bucket_name="s3BucketName",\n                s3_key_prefix="s3KeyPrefix"\n            )\n        ),\n        resource_tags={\n            "resource_tags_key": "resourceTags"\n        },\n        security_group_ids=["securityGroupIds"],\n        sns_topic_arn="snsTopicArn",\n        subnet_id="subnetId",\n        tags={\n            "tags_key": "tags"\n        },\n        terminate_instance_on_failure=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_profile_name', 'name', 'description', 'instance_metadata_options', 'instance_types', 'key_pair', 'logging', 'resource_tags', 'security_group_ids', 'sns_topic_arn', 'subnet_id', 'tags', 'terminate_instance_on_failure']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnInfrastructureConfigurationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnLifecyclePolicyProps
class CfnLifecyclePolicyPropsDef(BaseCfnProperty):
    execution_role: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name or Amazon Resource Name (ARN) for the IAM role you create that grants Image Builder access to run lifecycle actions.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the lifecycle policy to create.\n')
    policy_details: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_imagebuilder.CfnLifecyclePolicy_PolicyDetailPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Configuration details for the lifecycle policy rules.\n')
    resource_selection: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_imagebuilder.CfnLifecyclePolicy_ResourceSelectionPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Selection criteria for the resources that the lifecycle policy applies to.\n')
    resource_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of Image Builder resource that the lifecycle policy applies to.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Optional description for the lifecycle policy.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='Indicates whether the lifecycle policy resource is enabled.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Tags to apply to the lifecycle policy resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-imagebuilder-lifecyclepolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    cfn_lifecycle_policy_props = imagebuilder.CfnLifecyclePolicyProps(\n        execution_role="executionRole",\n        name="name",\n        policy_details=[imagebuilder.CfnLifecyclePolicy.PolicyDetailProperty(\n            action=imagebuilder.CfnLifecyclePolicy.ActionProperty(\n                type="type",\n\n                # the properties below are optional\n                include_resources=imagebuilder.CfnLifecyclePolicy.IncludeResourcesProperty(\n                    amis=False,\n                    containers=False,\n                    snapshots=False\n                )\n            ),\n            filter=imagebuilder.CfnLifecyclePolicy.FilterProperty(\n                type="type",\n                value=123,\n\n                # the properties below are optional\n                retain_at_least=123,\n                unit="unit"\n            ),\n\n            # the properties below are optional\n            exclusion_rules=imagebuilder.CfnLifecyclePolicy.ExclusionRulesProperty(\n                amis=imagebuilder.CfnLifecyclePolicy.AmiExclusionRulesProperty(\n                    is_public=False,\n                    last_launched=imagebuilder.CfnLifecyclePolicy.LastLaunchedProperty(\n                        unit="unit",\n                        value=123\n                    ),\n                    regions=["regions"],\n                    shared_accounts=["sharedAccounts"],\n                    tag_map={\n                        "tag_map_key": "tagMap"\n                    }\n                ),\n                tag_map={\n                    "tag_map_key": "tagMap"\n                }\n            )\n        )],\n        resource_selection=imagebuilder.CfnLifecyclePolicy.ResourceSelectionProperty(\n            recipes=[imagebuilder.CfnLifecyclePolicy.RecipeSelectionProperty(\n                name="name",\n                semantic_version="semanticVersion"\n            )],\n            tag_map={\n                "tag_map_key": "tagMap"\n            }\n        ),\n        resource_type="resourceType",\n\n        # the properties below are optional\n        description="description",\n        status="status",\n        tags={\n            "tags_key": "tags"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['execution_role', 'name', 'policy_details', 'resource_selection', 'resource_type', 'description', 'status', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnLifecyclePolicyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_imagebuilder.CfnWorkflowProps
class CfnWorkflowPropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the workflow to create.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The phase in the image build process for which the workflow resource is responsible.\n')
    version: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The semantic version of this workflow resource. The semantic version syntax adheres to the following rules. .. epigraph:: The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. *Assignment:* For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. *Patterns:* You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.\n')
    change_description: typing.Optional[str] = pydantic.Field(None, description='Describes what change has been made in this version of the workflow, or what makes this version different from other versions of the workflow.\n')
    data: typing.Optional[str] = pydantic.Field(None, description='Contains the UTF-8 encoded YAML document content for the workflow. Alternatively, you can specify the ``uri`` of a YAML document file stored in Amazon S3. However, you cannot specify both properties.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Describes the workflow.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the KMS key that is used to encrypt this workflow resource.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Tags that apply to the workflow resource.\n')
    uri: typing.Optional[str] = pydantic.Field(None, description='The ``uri`` of a YAML component document file. This must be an S3 URL ( ``s3://bucket/key`` ), and the requester must have permission to access the S3 bucket it points to. If you use Amazon S3, you can specify component content up to your service quota. Alternatively, you can specify the YAML document inline, using the component ``data`` property. You cannot specify both properties.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-imagebuilder-workflow.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_imagebuilder as imagebuilder\n\n    cfn_workflow_props = imagebuilder.CfnWorkflowProps(\n        name="name",\n        type="type",\n        version="version",\n\n        # the properties below are optional\n        change_description="changeDescription",\n        data="data",\n        description="description",\n        kms_key_id="kmsKeyId",\n        tags={\n            "tags_key": "tags"\n        },\n        uri="uri"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'type', 'version', 'change_description', 'data', 'description', 'kms_key_id', 'tags', 'uri']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_imagebuilder.CfnWorkflowProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    CfnContainerRecipe_ComponentConfigurationProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnContainerRecipe_ComponentConfigurationPropertyDef]] = pydantic.Field(None)
    CfnContainerRecipe_ComponentParameterProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnContainerRecipe_ComponentParameterPropertyDef]] = pydantic.Field(None)
    CfnContainerRecipe_EbsInstanceBlockDeviceSpecificationProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnContainerRecipe_EbsInstanceBlockDeviceSpecificationPropertyDef]] = pydantic.Field(None)
    CfnContainerRecipe_InstanceBlockDeviceMappingProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnContainerRecipe_InstanceBlockDeviceMappingPropertyDef]] = pydantic.Field(None)
    CfnContainerRecipe_InstanceConfigurationProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnContainerRecipe_InstanceConfigurationPropertyDef]] = pydantic.Field(None)
    CfnContainerRecipe_TargetContainerRepositoryProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnContainerRecipe_TargetContainerRepositoryPropertyDef]] = pydantic.Field(None)
    CfnDistributionConfiguration_AmiDistributionConfigurationProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnDistributionConfiguration_AmiDistributionConfigurationPropertyDef]] = pydantic.Field(None)
    CfnDistributionConfiguration_ContainerDistributionConfigurationProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnDistributionConfiguration_ContainerDistributionConfigurationPropertyDef]] = pydantic.Field(None)
    CfnDistributionConfiguration_DistributionProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnDistributionConfiguration_DistributionPropertyDef]] = pydantic.Field(None)
    CfnDistributionConfiguration_FastLaunchConfigurationProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnDistributionConfiguration_FastLaunchConfigurationPropertyDef]] = pydantic.Field(None)
    CfnDistributionConfiguration_FastLaunchLaunchTemplateSpecificationProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnDistributionConfiguration_FastLaunchLaunchTemplateSpecificationPropertyDef]] = pydantic.Field(None)
    CfnDistributionConfiguration_FastLaunchSnapshotConfigurationProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnDistributionConfiguration_FastLaunchSnapshotConfigurationPropertyDef]] = pydantic.Field(None)
    CfnDistributionConfiguration_LaunchPermissionConfigurationProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnDistributionConfiguration_LaunchPermissionConfigurationPropertyDef]] = pydantic.Field(None)
    CfnDistributionConfiguration_LaunchTemplateConfigurationProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnDistributionConfiguration_LaunchTemplateConfigurationPropertyDef]] = pydantic.Field(None)
    CfnDistributionConfiguration_TargetContainerRepositoryProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnDistributionConfiguration_TargetContainerRepositoryPropertyDef]] = pydantic.Field(None)
    CfnImage_EcrConfigurationProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnImage_EcrConfigurationPropertyDef]] = pydantic.Field(None)
    CfnImage_ImageScanningConfigurationProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnImage_ImageScanningConfigurationPropertyDef]] = pydantic.Field(None)
    CfnImage_ImageTestsConfigurationProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnImage_ImageTestsConfigurationPropertyDef]] = pydantic.Field(None)
    CfnImage_WorkflowConfigurationProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnImage_WorkflowConfigurationPropertyDef]] = pydantic.Field(None)
    CfnImage_WorkflowParameterProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnImage_WorkflowParameterPropertyDef]] = pydantic.Field(None)
    CfnImagePipeline_EcrConfigurationProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnImagePipeline_EcrConfigurationPropertyDef]] = pydantic.Field(None)
    CfnImagePipeline_ImageScanningConfigurationProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnImagePipeline_ImageScanningConfigurationPropertyDef]] = pydantic.Field(None)
    CfnImagePipeline_ImageTestsConfigurationProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnImagePipeline_ImageTestsConfigurationPropertyDef]] = pydantic.Field(None)
    CfnImagePipeline_ScheduleProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnImagePipeline_SchedulePropertyDef]] = pydantic.Field(None)
    CfnImagePipeline_WorkflowConfigurationProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnImagePipeline_WorkflowConfigurationPropertyDef]] = pydantic.Field(None)
    CfnImagePipeline_WorkflowParameterProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnImagePipeline_WorkflowParameterPropertyDef]] = pydantic.Field(None)
    CfnImageRecipe_AdditionalInstanceConfigurationProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnImageRecipe_AdditionalInstanceConfigurationPropertyDef]] = pydantic.Field(None)
    CfnImageRecipe_ComponentConfigurationProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnImageRecipe_ComponentConfigurationPropertyDef]] = pydantic.Field(None)
    CfnImageRecipe_ComponentParameterProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnImageRecipe_ComponentParameterPropertyDef]] = pydantic.Field(None)
    CfnImageRecipe_EbsInstanceBlockDeviceSpecificationProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnImageRecipe_EbsInstanceBlockDeviceSpecificationPropertyDef]] = pydantic.Field(None)
    CfnImageRecipe_InstanceBlockDeviceMappingProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnImageRecipe_InstanceBlockDeviceMappingPropertyDef]] = pydantic.Field(None)
    CfnImageRecipe_SystemsManagerAgentProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnImageRecipe_SystemsManagerAgentPropertyDef]] = pydantic.Field(None)
    CfnInfrastructureConfiguration_InstanceMetadataOptionsProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnInfrastructureConfiguration_InstanceMetadataOptionsPropertyDef]] = pydantic.Field(None)
    CfnInfrastructureConfiguration_LoggingProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnInfrastructureConfiguration_LoggingPropertyDef]] = pydantic.Field(None)
    CfnInfrastructureConfiguration_S3LogsProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnInfrastructureConfiguration_S3LogsPropertyDef]] = pydantic.Field(None)
    CfnLifecyclePolicy_ActionProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnLifecyclePolicy_ActionPropertyDef]] = pydantic.Field(None)
    CfnLifecyclePolicy_AmiExclusionRulesProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnLifecyclePolicy_AmiExclusionRulesPropertyDef]] = pydantic.Field(None)
    CfnLifecyclePolicy_ExclusionRulesProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnLifecyclePolicy_ExclusionRulesPropertyDef]] = pydantic.Field(None)
    CfnLifecyclePolicy_FilterProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnLifecyclePolicy_FilterPropertyDef]] = pydantic.Field(None)
    CfnLifecyclePolicy_IncludeResourcesProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnLifecyclePolicy_IncludeResourcesPropertyDef]] = pydantic.Field(None)
    CfnLifecyclePolicy_LastLaunchedProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnLifecyclePolicy_LastLaunchedPropertyDef]] = pydantic.Field(None)
    CfnLifecyclePolicy_PolicyDetailProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnLifecyclePolicy_PolicyDetailPropertyDef]] = pydantic.Field(None)
    CfnLifecyclePolicy_RecipeSelectionProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnLifecyclePolicy_RecipeSelectionPropertyDef]] = pydantic.Field(None)
    CfnLifecyclePolicy_ResourceSelectionProperty: typing.Optional[dict[str, models.aws_imagebuilder.CfnLifecyclePolicy_ResourceSelectionPropertyDef]] = pydantic.Field(None)
    CfnComponent: typing.Optional[dict[str, models.aws_imagebuilder.CfnComponentDef]] = pydantic.Field(None)
    CfnContainerRecipe: typing.Optional[dict[str, models.aws_imagebuilder.CfnContainerRecipeDef]] = pydantic.Field(None)
    CfnDistributionConfiguration: typing.Optional[dict[str, models.aws_imagebuilder.CfnDistributionConfigurationDef]] = pydantic.Field(None)
    CfnImage: typing.Optional[dict[str, models.aws_imagebuilder.CfnImageDef]] = pydantic.Field(None)
    CfnImagePipeline: typing.Optional[dict[str, models.aws_imagebuilder.CfnImagePipelineDef]] = pydantic.Field(None)
    CfnImageRecipe: typing.Optional[dict[str, models.aws_imagebuilder.CfnImageRecipeDef]] = pydantic.Field(None)
    CfnInfrastructureConfiguration: typing.Optional[dict[str, models.aws_imagebuilder.CfnInfrastructureConfigurationDef]] = pydantic.Field(None)
    CfnLifecyclePolicy: typing.Optional[dict[str, models.aws_imagebuilder.CfnLifecyclePolicyDef]] = pydantic.Field(None)
    CfnWorkflow: typing.Optional[dict[str, models.aws_imagebuilder.CfnWorkflowDef]] = pydantic.Field(None)
    CfnComponentProps: typing.Optional[dict[str, models.aws_imagebuilder.CfnComponentPropsDef]] = pydantic.Field(None)
    CfnContainerRecipeProps: typing.Optional[dict[str, models.aws_imagebuilder.CfnContainerRecipePropsDef]] = pydantic.Field(None)
    CfnDistributionConfigurationProps: typing.Optional[dict[str, models.aws_imagebuilder.CfnDistributionConfigurationPropsDef]] = pydantic.Field(None)
    CfnImagePipelineProps: typing.Optional[dict[str, models.aws_imagebuilder.CfnImagePipelinePropsDef]] = pydantic.Field(None)
    CfnImageProps: typing.Optional[dict[str, models.aws_imagebuilder.CfnImagePropsDef]] = pydantic.Field(None)
    CfnImageRecipeProps: typing.Optional[dict[str, models.aws_imagebuilder.CfnImageRecipePropsDef]] = pydantic.Field(None)
    CfnInfrastructureConfigurationProps: typing.Optional[dict[str, models.aws_imagebuilder.CfnInfrastructureConfigurationPropsDef]] = pydantic.Field(None)
    CfnLifecyclePolicyProps: typing.Optional[dict[str, models.aws_imagebuilder.CfnLifecyclePolicyPropsDef]] = pydantic.Field(None)
    CfnWorkflowProps: typing.Optional[dict[str, models.aws_imagebuilder.CfnWorkflowPropsDef]] = pydantic.Field(None)
    ...

import models
