from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams

#  autogenerated from aws_cdk.aws_certificatemanager.CertificateValidation
class CertificateValidationDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_dns', 'from_dns_multi_zone', 'from_email']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_certificatemanager.CertificateValidation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CertificateValidationDefConfig] = pydantic.Field(None)


class CertificateValidationDefConfig(pydantic.BaseModel):
    from_dns: typing.Optional[list[CertificateValidationDefFromDnsParams]] = pydantic.Field(None, description='Validate the certificate with DNS.\nIMPORTANT: If ``hostedZone`` is not specified, DNS records must be added\nmanually and the stack will not complete creating until the records are\nadded.')
    from_dns_multi_zone: typing.Optional[list[CertificateValidationDefFromDnsMultiZoneParams]] = pydantic.Field(None, description='Validate the certificate with automatically created DNS records in multiple Amazon Route 53 hosted zones.')
    from_email: typing.Optional[list[CertificateValidationDefFromEmailParams]] = pydantic.Field(None, description='Validate the certificate with Email.\nIMPORTANT: if you are creating a certificate as part of your stack, the stack\nwill not complete creating until you read and follow the instructions in the\nemail that you will receive.\n\nACM will send validation emails to the following addresses:\n\nadmin@domain.com\nadministrator@domain.com\nhostmaster@domain.com\npostmaster@domain.com\nwebmaster@domain.com\n\nFor every domain that you register.')

class CertificateValidationDefFromDnsParams(pydantic.BaseModel):
    hosted_zone: typing.Optional[typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef]] = pydantic.Field(None, description='the hosted zone where DNS records must be created.')
    return_config: typing.Optional[list[models.aws_certificatemanager.CertificateValidationDefConfig]] = pydantic.Field(None)
    ...

class CertificateValidationDefFromDnsMultiZoneParams(pydantic.BaseModel):
    hosted_zones: typing.Mapping[str, typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef]] = pydantic.Field(..., description='a map of hosted zones where DNS records must be created for the domains in the certificate.')
    return_config: typing.Optional[list[models.aws_certificatemanager.CertificateValidationDefConfig]] = pydantic.Field(None)
    ...

class CertificateValidationDefFromEmailParams(pydantic.BaseModel):
    validation_domains: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='a map of validation domains to use for domains in the certificate.')
    return_config: typing.Optional[list[models.aws_certificatemanager.CertificateValidationDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_certificatemanager.Certificate
class CertificateDef(BaseConstruct):
    domain_name: str = pydantic.Field(..., description='Fully-qualified domain name to request a certificate for. May contain wildcards, such as ``*.domain.com``.\n')
    certificate_name: typing.Optional[str] = pydantic.Field(None, description="The Certifcate name. Since the Certifcate resource doesn't support providing a physical name, the value provided here will be recorded in the ``Name`` tag Default: the full, absolute path of this construct\n")
    subject_alternative_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Alternative domain names on your certificate. Use this to register alternative domain names that represent the same site. Default: - No additional FQDNs will be included as alternative domain names.\n')
    transparency_logging_enabled: typing.Optional[bool] = pydantic.Field(None, description='Enable or disable transparency logging for this certificate. Once a certificate has been logged, it cannot be removed from the log. Opting out at that point will have no effect. If you opt out of logging when you request a certificate and then choose later to opt back in, your certificate will not be logged until it is renewed. If you want the certificate to be logged immediately, we recommend that you issue a new one. Default: true\n')
    validation: typing.Optional[models.aws_certificatemanager.CertificateValidationDef] = pydantic.Field(None, description='How to validate this certificate. Default: CertificateValidation.fromEmail()')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'certificate_name', 'subject_alternative_names', 'transparency_logging_enabled', 'validation']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'metric_days_to_expiry']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_certificate_arn']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_certificatemanager.Certificate'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_certificate_arn']
    ...


    from_certificate_arn: typing.Optional[CertificateDefFromCertificateArnParams] = pydantic.Field(None, description='Import a certificate.')
    resource_config: typing.Optional[CertificateDefConfig] = pydantic.Field(None)


class CertificateDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    metric_days_to_expiry: typing.Optional[list[CertificateDefMetricDaysToExpiryParams]] = pydantic.Field(None, description='Return the DaysToExpiry metric for this AWS Certificate Manager Certificate. By default, this is the minimum value over 1 day.\nThis metric is no longer emitted once the certificate has effectively\nexpired, so alarms configured on this metric should probably treat missing\ndata as "breaching".')

class CertificateDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class CertificateDefFromCertificateArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    certificate_arn: str = pydantic.Field(..., description='-')
    ...

class CertificateDefMetricDaysToExpiryParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_certificatemanager.DnsValidatedCertificate
class DnsValidatedCertificateDef(BaseConstruct):
    hosted_zone: typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef] = pydantic.Field(..., description='Route 53 Hosted Zone used to perform DNS validation of the request. The zone must be authoritative for the domain name specified in the Certificate Request.\n')
    cleanup_route53_records: typing.Optional[bool] = pydantic.Field(None, description='When set to true, when the DnsValidatedCertificate is deleted, the associated Route53 validation records are removed. CAUTION: If multiple certificates share the same domains (and same validation records), this can cause the other certificates to fail renewal and/or not validate. Not recommended for production use. Default: false\n')
    custom_resource_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='Role to use for the custom resource that creates the validated certificate. Default: - A new role will be created\n')
    region: typing.Optional[str] = pydantic.Field(None, description='AWS region that will host the certificate. This is needed especially for certificates used for CloudFront distributions, which require the region to be us-east-1. Default: the region the stack is deployed in.\n')
    route53_endpoint: typing.Optional[str] = pydantic.Field(None, description='An endpoint of Route53 service, which is not necessary as AWS SDK could figure out the right endpoints for most regions, but for some regions such as those in aws-cn partition, the default endpoint is not working now, hence the right endpoint need to be specified through this prop. Route53 is not been officially launched in China, it is only available for AWS internal accounts now. To make DnsValidatedCertificate work for internal accounts now, a special endpoint needs to be provided. Default: - The AWS SDK will determine the Route53 endpoint to use based on region\n')
    domain_name: str = pydantic.Field(..., description='Fully-qualified domain name to request a certificate for. May contain wildcards, such as ``*.domain.com``.\n')
    certificate_name: typing.Optional[str] = pydantic.Field(None, description="The Certifcate name. Since the Certifcate resource doesn't support providing a physical name, the value provided here will be recorded in the ``Name`` tag Default: the full, absolute path of this construct\n")
    subject_alternative_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Alternative domain names on your certificate. Use this to register alternative domain names that represent the same site. Default: - No additional FQDNs will be included as alternative domain names.\n')
    transparency_logging_enabled: typing.Optional[bool] = pydantic.Field(None, description='Enable or disable transparency logging for this certificate. Once a certificate has been logged, it cannot be removed from the log. Opting out at that point will have no effect. If you opt out of logging when you request a certificate and then choose later to opt back in, your certificate will not be logged until it is renewed. If you want the certificate to be logged immediately, we recommend that you issue a new one. Default: true\n')
    validation: typing.Optional[models.aws_certificatemanager.CertificateValidationDef] = pydantic.Field(None, description='How to validate this certificate. Default: CertificateValidation.fromEmail()\n\n:stability: deprecated\n')
    _init_params: typing.ClassVar[list[str]] = ['hosted_zone', 'cleanup_route53_records', 'custom_resource_role', 'region', 'route53_endpoint', 'domain_name', 'certificate_name', 'subject_alternative_names', 'transparency_logging_enabled', 'validation']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'metric_days_to_expiry']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_certificatemanager.DnsValidatedCertificate'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[DnsValidatedCertificateDefConfig] = pydantic.Field(None)


class DnsValidatedCertificateDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    metric_days_to_expiry: typing.Optional[list[DnsValidatedCertificateDefMetricDaysToExpiryParams]] = pydantic.Field(None, description='(deprecated) Return the DaysToExpiry metric for this AWS Certificate Manager Certificate. By default, this is the minimum value over 1 day.\nThis metric is no longer emitted once the certificate has effectively\nexpired, so alarms configured on this metric should probably treat missing\ndata as "breaching".')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class DnsValidatedCertificateDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-\n\n:stability: deprecated\n')
    ...

class DnsValidatedCertificateDefMetricDaysToExpiryParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:stability: deprecated\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_certificatemanager.PrivateCertificate
class PrivateCertificateDef(BaseConstruct):
    certificate_authority: models.UnsupportedResource = pydantic.Field(..., description='Private certificate authority (CA) that will be used to issue the certificate.\n')
    domain_name: str = pydantic.Field(..., description='Fully-qualified domain name to request a private certificate for. May contain wildcards, such as ``*.domain.com``.\n')
    subject_alternative_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Alternative domain names on your private certificate. Use this to register alternative domain names that represent the same site. Default: - No additional FQDNs will be included as alternative domain names.')
    _init_params: typing.ClassVar[list[str]] = ['certificate_authority', 'domain_name', 'subject_alternative_names']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'metric_days_to_expiry']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_certificate_arn']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_certificatemanager.PrivateCertificate'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_certificate_arn']
    ...


    from_certificate_arn: typing.Optional[PrivateCertificateDefFromCertificateArnParams] = pydantic.Field(None, description='Import a certificate.')
    resource_config: typing.Optional[PrivateCertificateDefConfig] = pydantic.Field(None)


class PrivateCertificateDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    metric_days_to_expiry: typing.Optional[list[PrivateCertificateDefMetricDaysToExpiryParams]] = pydantic.Field(None, description='Return the DaysToExpiry metric for this AWS Certificate Manager Certificate. By default, this is the minimum value over 1 day.\nThis metric is no longer emitted once the certificate has effectively\nexpired, so alarms configured on this metric should probably treat missing\ndata as "breaching".')

class PrivateCertificateDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class PrivateCertificateDefFromCertificateArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    certificate_arn: str = pydantic.Field(..., description='-')
    ...

class PrivateCertificateDefMetricDaysToExpiryParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_certificatemanager.CertificateProps
class CertificatePropsDef(BaseStruct):
    domain_name: str = pydantic.Field(..., description='Fully-qualified domain name to request a certificate for. May contain wildcards, such as ``*.domain.com``.\n')
    certificate_name: typing.Optional[str] = pydantic.Field(None, description="The Certifcate name. Since the Certifcate resource doesn't support providing a physical name, the value provided here will be recorded in the ``Name`` tag Default: the full, absolute path of this construct\n")
    subject_alternative_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Alternative domain names on your certificate. Use this to register alternative domain names that represent the same site. Default: - No additional FQDNs will be included as alternative domain names.\n')
    transparency_logging_enabled: typing.Optional[bool] = pydantic.Field(None, description='Enable or disable transparency logging for this certificate. Once a certificate has been logged, it cannot be removed from the log. Opting out at that point will have no effect. If you opt out of logging when you request a certificate and then choose later to opt back in, your certificate will not be logged until it is renewed. If you want the certificate to be logged immediately, we recommend that you issue a new one. Default: true\n')
    validation: typing.Optional[models.aws_certificatemanager.CertificateValidationDef] = pydantic.Field(None, description='How to validate this certificate. Default: CertificateValidation.fromEmail()\n\n:exampleMetadata: infused\n\nExample::\n\n    example_com = route53.HostedZone(self, "ExampleCom",\n        zone_name="example.com"\n    )\n    example_net = route53.HostedZone(self, "ExampleNet",\n        zone_name="example.net"\n    )\n\n    cert = acm.Certificate(self, "Certificate",\n        domain_name="test.example.com",\n        subject_alternative_names=["cool.example.com", "test.example.net"],\n        validation=acm.CertificateValidation.from_dns_multi_zone({\n            "test.example.com": example_com,\n            "cool.example.com": example_com,\n            "test.example.net": example_net\n        })\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'certificate_name', 'subject_alternative_names', 'transparency_logging_enabled', 'validation']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_certificatemanager.CertificateProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_certificatemanager.CertificationValidationProps
class CertificationValidationPropsDef(BaseStruct):
    hosted_zone: typing.Optional[typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef]] = pydantic.Field(None, description='Hosted zone to use for DNS validation. Default: - use email validation\n')
    hosted_zones: typing.Optional[typing.Mapping[str, typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef]]] = pydantic.Field(None, description='A map of hosted zones to use for DNS validation. Default: - use ``hostedZone``\n')
    method: typing.Optional[aws_cdk.aws_certificatemanager.ValidationMethod] = pydantic.Field(None, description='Validation method. Default: ValidationMethod.EMAIL\n')
    validation_domains: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Validation domains to use for email validation. Default: - Apex domain\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_certificatemanager as certificatemanager\n    from aws_cdk import aws_route53 as route53\n\n    # hosted_zone: route53.HostedZone\n\n    certification_validation_props = certificatemanager.CertificationValidationProps(\n        hosted_zone=hosted_zone,\n        hosted_zones={\n            "hosted_zones_key": hosted_zone\n        },\n        method=certificatemanager.ValidationMethod.EMAIL,\n        validation_domains={\n            "validation_domains_key": "validationDomains"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['hosted_zone', 'hosted_zones', 'method', 'validation_domains']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_certificatemanager.CertificationValidationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_certificatemanager.CfnAccount.ExpiryEventsConfigurationProperty
class CfnAccount_ExpiryEventsConfigurationPropertyDef(BaseStruct):
    days_before_expiry: typing.Union[int, float, None] = pydantic.Field(None, description='This option specifies the number of days prior to certificate expiration when ACM starts generating ``EventBridge`` events. ACM sends one event per day per certificate until the certificate expires. By default, accounts receive events starting 45 days before certificate expiration.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-certificatemanager-account-expiryeventsconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_certificatemanager as certificatemanager\n\n    expiry_events_configuration_property = certificatemanager.CfnAccount.ExpiryEventsConfigurationProperty(\n        days_before_expiry=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['days_before_expiry']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_certificatemanager.CfnAccount.ExpiryEventsConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_certificatemanager.CfnCertificate.DomainValidationOptionProperty
class CfnCertificate_DomainValidationOptionPropertyDef(BaseStruct):
    domain_name: str = pydantic.Field(..., description='A fully qualified domain name (FQDN) in the certificate request.\n')
    hosted_zone_id: typing.Optional[str] = pydantic.Field(None, description='The ``HostedZoneId`` option, which is available if you are using Route 53 as your domain registrar, causes ACM to add your CNAME to the domain record. Your list of ``DomainValidationOptions`` must contain one and only one of the domain-validation options, and the ``HostedZoneId`` can be used only when ``DNS`` is specified as your validation method. Use the Route 53 ``ListHostedZones`` API to discover IDs for available hosted zones. This option is required for publicly trusted certificates. .. epigraph:: The ``ListHostedZones`` API returns IDs in the format "/hostedzone/Z111111QQQQQQQ", but CloudFormation requires the IDs to be in the format "Z111111QQQQQQQ". When you change your ``DomainValidationOptions`` , a new resource is created.\n')
    validation_domain: typing.Optional[str] = pydantic.Field(None, description='The domain name to which you want ACM to send validation emails. This domain name is the suffix of the email addresses that you want ACM to use. This must be the same as the ``DomainName`` value or a superdomain of the ``DomainName`` value. For example, if you request a certificate for ``testing.example.com`` , you can specify ``example.com`` as this value. In that case, ACM sends domain validation emails to the following five addresses: - admin@example.com - administrator@example.com - hostmaster@example.com - postmaster@example.com - webmaster@example.com\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-certificatemanager-certificate-domainvalidationoption.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_certificatemanager as certificatemanager\n\n    domain_validation_option_property = certificatemanager.CfnCertificate.DomainValidationOptionProperty(\n        domain_name="domainName",\n\n        # the properties below are optional\n        hosted_zone_id="hostedZoneId",\n        validation_domain="validationDomain"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'hosted_zone_id', 'validation_domain']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_certificatemanager.CfnCertificate.DomainValidationOptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_certificatemanager.DnsValidatedCertificateProps
class DnsValidatedCertificatePropsDef(BaseStruct):
    domain_name: str = pydantic.Field(..., description='Fully-qualified domain name to request a certificate for. May contain wildcards, such as ``*.domain.com``.\n')
    certificate_name: typing.Optional[str] = pydantic.Field(None, description="The Certifcate name. Since the Certifcate resource doesn't support providing a physical name, the value provided here will be recorded in the ``Name`` tag Default: the full, absolute path of this construct\n")
    subject_alternative_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Alternative domain names on your certificate. Use this to register alternative domain names that represent the same site. Default: - No additional FQDNs will be included as alternative domain names.\n')
    transparency_logging_enabled: typing.Optional[bool] = pydantic.Field(None, description='Enable or disable transparency logging for this certificate. Once a certificate has been logged, it cannot be removed from the log. Opting out at that point will have no effect. If you opt out of logging when you request a certificate and then choose later to opt back in, your certificate will not be logged until it is renewed. If you want the certificate to be logged immediately, we recommend that you issue a new one. Default: true\n')
    validation: typing.Optional[models.aws_certificatemanager.CertificateValidationDef] = pydantic.Field(None, description='How to validate this certificate. Default: CertificateValidation.fromEmail()\n')
    hosted_zone: typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef] = pydantic.Field(..., description='Route 53 Hosted Zone used to perform DNS validation of the request. The zone must be authoritative for the domain name specified in the Certificate Request.\n')
    cleanup_route53_records: typing.Optional[bool] = pydantic.Field(None, description='When set to true, when the DnsValidatedCertificate is deleted, the associated Route53 validation records are removed. CAUTION: If multiple certificates share the same domains (and same validation records), this can cause the other certificates to fail renewal and/or not validate. Not recommended for production use. Default: false\n')
    custom_resource_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='Role to use for the custom resource that creates the validated certificate. Default: - A new role will be created\n')
    region: typing.Optional[str] = pydantic.Field(None, description='AWS region that will host the certificate. This is needed especially for certificates used for CloudFront distributions, which require the region to be us-east-1. Default: the region the stack is deployed in.\n')
    route53_endpoint: typing.Optional[str] = pydantic.Field(None, description='An endpoint of Route53 service, which is not necessary as AWS SDK could figure out the right endpoints for most regions, but for some regions such as those in aws-cn partition, the default endpoint is not working now, hence the right endpoint need to be specified through this prop. Route53 is not been officially launched in China, it is only available for AWS internal accounts now. To make DnsValidatedCertificate work for internal accounts now, a special endpoint needs to be provided. Default: - The AWS SDK will determine the Route53 endpoint to use based on region\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_certificatemanager as certificatemanager\n    from aws_cdk import aws_iam as iam\n    from aws_cdk import aws_route53 as route53\n\n    # certificate_validation: certificatemanager.CertificateValidation\n    # hosted_zone: route53.HostedZone\n    # role: iam.Role\n\n    dns_validated_certificate_props = certificatemanager.DnsValidatedCertificateProps(\n        domain_name="domainName",\n        hosted_zone=hosted_zone,\n\n        # the properties below are optional\n        certificate_name="certificateName",\n        cleanup_route53_records=False,\n        custom_resource_role=role,\n        region="region",\n        route53_endpoint="route53Endpoint",\n        subject_alternative_names=["subjectAlternativeNames"],\n        transparency_logging_enabled=False,\n        validation=certificate_validation\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'certificate_name', 'subject_alternative_names', 'transparency_logging_enabled', 'validation', 'hosted_zone', 'cleanup_route53_records', 'custom_resource_role', 'region', 'route53_endpoint']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_certificatemanager.DnsValidatedCertificateProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[DnsValidatedCertificatePropsDefConfig] = pydantic.Field(None)


class DnsValidatedCertificatePropsDefConfig(pydantic.BaseModel):
    hosted_zone_config: typing.Optional[models._interface_methods.AwsRoute53IHostedZoneDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_certificatemanager.PrivateCertificateProps
class PrivateCertificatePropsDef(BaseStruct):
    certificate_authority: models.UnsupportedResource = pydantic.Field(..., description='Private certificate authority (CA) that will be used to issue the certificate.\n')
    domain_name: str = pydantic.Field(..., description='Fully-qualified domain name to request a private certificate for. May contain wildcards, such as ``*.domain.com``.\n')
    subject_alternative_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Alternative domain names on your private certificate. Use this to register alternative domain names that represent the same site. Default: - No additional FQDNs will be included as alternative domain names.\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_acmpca as acmpca\n\n\n    acm.PrivateCertificate(self, "PrivateCertificate",\n        domain_name="test.example.com",\n        subject_alternative_names=["cool.example.com", "test.example.net"],  # optional\n        certificate_authority=acmpca.CertificateAuthority.from_certificate_authority_arn(self, "CA", "arn:aws:acm-pca:us-east-1:123456789012:certificate-authority/023077d8-2bfa-4eb0-8f22-05c96deade77")\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate_authority', 'domain_name', 'subject_alternative_names']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_certificatemanager.PrivateCertificateProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[PrivateCertificatePropsDefConfig] = pydantic.Field(None)


class PrivateCertificatePropsDefConfig(pydantic.BaseModel):
    certificate_authority_config: typing.Optional[models._interface_methods.AwsAcmpcaICertificateAuthorityDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_certificatemanager.ValidationMethod
# skipping emum

#  autogenerated from aws_cdk.aws_certificatemanager.ICertificate
#  skipping Interface

#  autogenerated from aws_cdk.aws_certificatemanager.CfnAccount
class CfnAccountDef(BaseCfnResource):
    expiry_events_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_certificatemanager.CfnAccount_ExpiryEventsConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Object containing expiration events options associated with an AWS account . For more information, see `ExpiryEventsConfiguration <https://docs.aws.amazon.com/acm/latest/APIReference/API_ExpiryEventsConfiguration.html>`_ in the API reference.')
    _init_params: typing.ClassVar[list[str]] = ['expiry_events_configuration']
    _method_names: typing.ClassVar[list[str]] = ['ExpiryEventsConfigurationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_certificatemanager.CfnAccount'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnAccountDefConfig] = pydantic.Field(None)


class CfnAccountDefConfig(pydantic.BaseModel):
    ExpiryEventsConfigurationProperty: typing.Optional[list[CfnAccountDefExpiryeventsconfigurationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnAccountDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnAccountDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnAccountDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnAccountDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnAccountDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnAccountDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnAccountDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnAccountDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnAccountDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnAccountDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnAccountDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnAccountDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnAccountDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnAccountDefExpiryeventsconfigurationpropertyParams(pydantic.BaseModel):
    days_before_expiry: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnAccountDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAccountDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAccountDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAccountDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAccountDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAccountDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAccountDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAccountDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAccountDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAccountDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAccountDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnAccountDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAccountDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAccountDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_certificatemanager.CfnCertificate
class CfnCertificateDef(BaseCfnResource):
    domain_name: str = pydantic.Field(..., description='The fully qualified domain name (FQDN), such as www.example.com, with which you want to secure an ACM certificate. Use an asterisk (*) to create a wildcard certificate that protects several sites in the same domain. For example, ``*.example.com`` protects ``www.example.com`` , ``site.example.com`` , and ``images.example.com.``.\n')
    certificate_authority_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the private certificate authority (CA) that will be used to issue the certificate. If you do not provide an ARN and you are trying to request a private certificate, ACM will attempt to issue a public certificate. For more information about private CAs, see the `AWS Private Certificate Authority <https://docs.aws.amazon.com/privateca/latest/userguide/PcaWelcome.html>`_ user guide. The ARN must have the following form: ``arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012``\n')
    certificate_transparency_logging_preference: typing.Optional[str] = pydantic.Field(None, description='You can opt out of certificate transparency logging by specifying the ``DISABLED`` option. Opt in by specifying ``ENABLED`` . If you do not specify a certificate transparency logging preference on a new CloudFormation template, or if you remove the logging preference from an existing template, this is the same as explicitly enabling the preference. Changing the certificate transparency logging preference will update the existing resource by calling ``UpdateCertificateOptions`` on the certificate. This action will not create a new resource.\n')
    domain_validation_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_certificatemanager.CfnCertificate_DomainValidationOptionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Domain information that domain name registrars use to verify your identity. .. epigraph:: In order for a AWS::CertificateManager::Certificate to be provisioned and validated in CloudFormation automatically, the ``DomainName`` property needs to be identical to one of the ``DomainName`` property supplied in DomainValidationOptions, if the ValidationMethod is **DNS**. Failing to keep them like-for-like will result in failure to create the domain validation records in Route53.\n')
    subject_alternative_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Additional FQDNs to be included in the Subject Alternative Name extension of the ACM certificate. For example, you can add www.example.net to a certificate for which the ``DomainName`` field is www.example.com if users can reach your site by using either name.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Key-value pairs that can identify the certificate.\n')
    validation_method: typing.Optional[str] = pydantic.Field(None, description='The method you want to use to validate that you own or control the domain associated with a public certificate. You can `validate with DNS <https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-validate-dns.html>`_ or `validate with email <https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-validate-email.html>`_ . We recommend that you use DNS validation. If not specified, this property defaults to email validation.')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'certificate_authority_arn', 'certificate_transparency_logging_preference', 'domain_validation_options', 'subject_alternative_names', 'tags', 'validation_method']
    _method_names: typing.ClassVar[list[str]] = ['DomainValidationOptionProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_certificatemanager.CfnCertificate'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnCertificateDefConfig] = pydantic.Field(None)


class CfnCertificateDefConfig(pydantic.BaseModel):
    DomainValidationOptionProperty: typing.Optional[list[CfnCertificateDefDomainvalidationoptionpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnCertificateDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnCertificateDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnCertificateDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnCertificateDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnCertificateDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnCertificateDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnCertificateDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnCertificateDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnCertificateDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnCertificateDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnCertificateDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnCertificateDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnCertificateDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnCertificateDefDomainvalidationoptionpropertyParams(pydantic.BaseModel):
    domain_name: str = pydantic.Field(..., description='')
    hosted_zone_id: typing.Optional[str] = pydantic.Field(None, description='')
    validation_domain: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnCertificateDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnCertificateDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCertificateDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnCertificateDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCertificateDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnCertificateDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnCertificateDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnCertificateDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnCertificateDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnCertificateDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCertificateDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnCertificateDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnCertificateDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCertificateDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_certificatemanager.CfnAccountProps
class CfnAccountPropsDef(BaseCfnProperty):
    expiry_events_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_certificatemanager.CfnAccount_ExpiryEventsConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Object containing expiration events options associated with an AWS account . For more information, see `ExpiryEventsConfiguration <https://docs.aws.amazon.com/acm/latest/APIReference/API_ExpiryEventsConfiguration.html>`_ in the API reference.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-certificatemanager-account.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_certificatemanager as certificatemanager\n\n    cfn_account_props = certificatemanager.CfnAccountProps(\n        expiry_events_configuration=certificatemanager.CfnAccount.ExpiryEventsConfigurationProperty(\n            days_before_expiry=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['expiry_events_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_certificatemanager.CfnAccountProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_certificatemanager.CfnCertificateProps
class CfnCertificatePropsDef(BaseCfnProperty):
    domain_name: str = pydantic.Field(..., description='The fully qualified domain name (FQDN), such as www.example.com, with which you want to secure an ACM certificate. Use an asterisk (*) to create a wildcard certificate that protects several sites in the same domain. For example, ``*.example.com`` protects ``www.example.com`` , ``site.example.com`` , and ``images.example.com.``.\n')
    certificate_authority_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the private certificate authority (CA) that will be used to issue the certificate. If you do not provide an ARN and you are trying to request a private certificate, ACM will attempt to issue a public certificate. For more information about private CAs, see the `AWS Private Certificate Authority <https://docs.aws.amazon.com/privateca/latest/userguide/PcaWelcome.html>`_ user guide. The ARN must have the following form: ``arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012``\n')
    certificate_transparency_logging_preference: typing.Optional[str] = pydantic.Field(None, description='You can opt out of certificate transparency logging by specifying the ``DISABLED`` option. Opt in by specifying ``ENABLED`` . If you do not specify a certificate transparency logging preference on a new CloudFormation template, or if you remove the logging preference from an existing template, this is the same as explicitly enabling the preference. Changing the certificate transparency logging preference will update the existing resource by calling ``UpdateCertificateOptions`` on the certificate. This action will not create a new resource.\n')
    domain_validation_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_certificatemanager.CfnCertificate_DomainValidationOptionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Domain information that domain name registrars use to verify your identity. .. epigraph:: In order for a AWS::CertificateManager::Certificate to be provisioned and validated in CloudFormation automatically, the ``DomainName`` property needs to be identical to one of the ``DomainName`` property supplied in DomainValidationOptions, if the ValidationMethod is **DNS**. Failing to keep them like-for-like will result in failure to create the domain validation records in Route53.\n')
    subject_alternative_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Additional FQDNs to be included in the Subject Alternative Name extension of the ACM certificate. For example, you can add www.example.net to a certificate for which the ``DomainName`` field is www.example.com if users can reach your site by using either name.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Key-value pairs that can identify the certificate.\n')
    validation_method: typing.Optional[str] = pydantic.Field(None, description='The method you want to use to validate that you own or control the domain associated with a public certificate. You can `validate with DNS <https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-validate-dns.html>`_ or `validate with email <https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-validate-email.html>`_ . We recommend that you use DNS validation. If not specified, this property defaults to email validation.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-certificatemanager-certificate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_certificatemanager as certificatemanager\n\n    cfn_certificate_props = certificatemanager.CfnCertificateProps(\n        domain_name="domainName",\n\n        # the properties below are optional\n        certificate_authority_arn="certificateAuthorityArn",\n        certificate_transparency_logging_preference="certificateTransparencyLoggingPreference",\n        domain_validation_options=[certificatemanager.CfnCertificate.DomainValidationOptionProperty(\n            domain_name="domainName",\n\n            # the properties below are optional\n            hosted_zone_id="hostedZoneId",\n            validation_domain="validationDomain"\n        )],\n        subject_alternative_names=["subjectAlternativeNames"],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        validation_method="validationMethod"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'certificate_authority_arn', 'certificate_transparency_logging_preference', 'domain_validation_options', 'subject_alternative_names', 'tags', 'validation_method']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_certificatemanager.CfnCertificateProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    CertificateValidation: typing.Optional[dict[str, CertificateValidationDef]] = pydantic.Field(None)
    Certificate: typing.Optional[dict[str, CertificateDef]] = pydantic.Field(None)
    DnsValidatedCertificate: typing.Optional[dict[str, DnsValidatedCertificateDef]] = pydantic.Field(None)
    PrivateCertificate: typing.Optional[dict[str, PrivateCertificateDef]] = pydantic.Field(None)
    CertificateProps: typing.Optional[dict[str, CertificatePropsDef]] = pydantic.Field(None)
    CertificationValidationProps: typing.Optional[dict[str, CertificationValidationPropsDef]] = pydantic.Field(None)
    CfnAccount_ExpiryEventsConfigurationProperty: typing.Optional[dict[str, CfnAccount_ExpiryEventsConfigurationPropertyDef]] = pydantic.Field(None)
    CfnCertificate_DomainValidationOptionProperty: typing.Optional[dict[str, CfnCertificate_DomainValidationOptionPropertyDef]] = pydantic.Field(None)
    DnsValidatedCertificateProps: typing.Optional[dict[str, DnsValidatedCertificatePropsDef]] = pydantic.Field(None)
    PrivateCertificateProps: typing.Optional[dict[str, PrivateCertificatePropsDef]] = pydantic.Field(None)
    CfnAccount: typing.Optional[dict[str, CfnAccountDef]] = pydantic.Field(None)
    CfnCertificate: typing.Optional[dict[str, CfnCertificateDef]] = pydantic.Field(None)
    CfnAccountProps: typing.Optional[dict[str, CfnAccountPropsDef]] = pydantic.Field(None)
    CfnCertificateProps: typing.Optional[dict[str, CfnCertificatePropsDef]] = pydantic.Field(None)
    ...
