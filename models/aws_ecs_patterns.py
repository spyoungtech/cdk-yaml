from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedServiceBase
class ApplicationLoadBalancedServiceBaseDef(BaseClass):
    capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs.CapacityProviderStrategyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of Capacity Provider strategies used to place a service. Default: - undefined\n')
    certificate: typing.Optional[typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef]] = pydantic.Field(None, description="Certificate Manager certificate to associate with the load balancer. Setting this option will set the load balancer protocol to HTTPS. Default: - No certificate associated with the load balancer, if using the HTTP protocol. For HTTPS, a DNS-validated certificate will be created for the load balancer's specified domain name if a domain name and domain zone are specified.\n")
    circuit_breaker: typing.Union[models.aws_ecs.DeploymentCircuitBreakerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly enabled. Default: - disabled\n')
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    deployment_controller: typing.Union[models.aws_ecs.DeploymentControllerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies which deployment controller to use for the service. For more information, see `Amazon ECS Deployment Types <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html>`_ Default: - Rolling update (ECS)\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. The minimum value is 1 Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='The domain name for the service, e.g. "api.example.com.". Default: - No domain name.\n')
    domain_zone: typing.Optional[typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef]] = pydantic.Field(None, description='The Route53 hosted zone for the domain, e.g. "example.com.". Default: - No Route53 hosted domain zone.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    idle_timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The load balancer idle timeout, in seconds. Can be between 1 and 4000 seconds Default: - CloudFormation sets idle timeout to 60 seconds\n')
    listener_port: typing.Union[int, float, None] = pydantic.Field(None, description='Listener port of the application load balancer that will serve traffic to the service. Default: - The default listener port is determined from the protocol (port 80 for HTTP, port 443 for HTTPS). A domain name and zone must be also be specified if using HTTPS.\n')
    load_balancer: typing.Optional[typing.Union[models.aws_elasticloadbalancingv2.ApplicationLoadBalancerDef]] = pydantic.Field(None, description='The application load balancer that will serve traffic to the service. The VPC attribute of a load balancer must be specified for it to be used to create a new service with this pattern. [disable-awslint:ref-via-interface] Default: - a new load balancer will be created.\n')
    load_balancer_name: typing.Optional[str] = pydantic.Field(None, description='Name of the load balancer. Default: - Automatically generated name.\n')
    max_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The maximum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that can run in a service during a deployment. Default: - 100 if daemon, otherwise 200\n")
    min_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The minimum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that must continue to run and remain healthy during a deployment. Default: - 0 if daemon, otherwise 50\n")
    open_listener: typing.Optional[bool] = pydantic.Field(None, description="Determines whether or not the Security Group for the Load Balancer's Listener will be open to all traffic by default. Default: true -- The security group allows ingress from all IP addresses.\n")
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    protocol: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.ApplicationProtocol] = pydantic.Field(None, description='The protocol for connections from clients to the load balancer. The load balancer port is determined from the protocol (port 80 for HTTP, port 443 for HTTPS). If HTTPS, either a certificate or domain name and domain zone must also be specified. Default: HTTP. If a certificate is specified, the protocol will be set by default to HTTPS.\n')
    protocol_version: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.ApplicationProtocolVersion] = pydantic.Field(None, description='The protocol version to use. Default: ApplicationProtocolVersion.HTTP1\n')
    public_load_balancer: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the Load Balancer will be internet-facing. Default: true\n')
    record_type: typing.Optional[aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedServiceRecordType] = pydantic.Field(None, description='Specifies whether the Route53 record should be a CNAME, an A record using the Alias feature or no record at all. This is useful if you need to work with DNS systems that do not support alias records. Default: ApplicationLoadBalancedServiceRecordType.ALIAS\n')
    redirect_http: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether the load balancer should redirect traffic on port 80 to port 443 to support HTTP->HTTPS redirects This is only valid if the protocol of the ALB is HTTPS. Default: false\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    ssl_policy: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.SslPolicy] = pydantic.Field(None, description='The security policy that defines which ciphers and protocols are supported by the ALB Listener. Default: - The recommended elastic load balancing security policy\n')
    target_protocol: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.ApplicationProtocol] = pydantic.Field(None, description='The protocol for connections from the load balancer to the ECS tasks. The default target port is determined from the protocol (port 80 for HTTP, port 443 for HTTPS). Default: HTTP.\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.ApplicationLoadBalancedTaskImageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. TaskDefinition or TaskImageOptions must be specified, but not both. Default: none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.')
    _init_params: typing.ClassVar[list[str]] = ['capacity_provider_strategies', 'certificate', 'circuit_breaker', 'cloud_map_options', 'cluster', 'deployment_controller', 'desired_count', 'domain_name', 'domain_zone', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'idle_timeout', 'listener_port', 'load_balancer', 'load_balancer_name', 'max_healthy_percent', 'min_healthy_percent', 'open_listener', 'propagate_tags', 'protocol', 'protocol_version', 'public_load_balancer', 'record_type', 'redirect_http', 'service_name', 'ssl_policy', 'target_protocol', 'task_image_options', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedServiceBase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.ApplicationLoadBalancedServiceBaseDefConfig] = pydantic.Field(None)


class ApplicationLoadBalancedServiceBaseDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEcsIClusterDefConfig] = pydantic.Field(None)
    listener_config: typing.Optional[models.aws_elasticloadbalancingv2.ApplicationListenerDefConfig] = pydantic.Field(None)
    load_balancer_config: typing.Optional[models.aws_elasticloadbalancingv2.ApplicationLoadBalancerDefConfig] = pydantic.Field(None)
    target_group_config: typing.Optional[models.aws_elasticloadbalancingv2.ApplicationTargetGroupDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.ApplicationMultipleTargetGroupsServiceBase
class ApplicationMultipleTargetGroupsServiceBaseDef(BaseClass):
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    load_balancers: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.ApplicationLoadBalancerPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The application load balancer that will serve traffic to the service. Default: - a new load balancer with a listener will be created.\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    target_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.ApplicationTargetPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Properties to specify ALB target groups. Default: - default portMapping registered as target group and attached to the first defined listener\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.ApplicationLoadBalancedTaskImagePropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. Only one of TaskDefinition or TaskImageOptions must be specified. Default: none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.')
    _init_params: typing.ClassVar[list[str]] = ['cloud_map_options', 'cluster', 'desired_count', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'load_balancers', 'propagate_tags', 'service_name', 'target_groups', 'task_image_options', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ApplicationMultipleTargetGroupsServiceBase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.ApplicationMultipleTargetGroupsServiceBaseDefConfig] = pydantic.Field(None)


class ApplicationMultipleTargetGroupsServiceBaseDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEcsIClusterDefConfig] = pydantic.Field(None)
    listener_config: typing.Optional[models.aws_elasticloadbalancingv2.ApplicationListenerDefConfig] = pydantic.Field(None)
    load_balancer_config: typing.Optional[models.aws_elasticloadbalancingv2.ApplicationLoadBalancerDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.NetworkLoadBalancedServiceBase
class NetworkLoadBalancedServiceBaseDef(BaseClass):
    capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs.CapacityProviderStrategyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of Capacity Provider strategies used to place a service. Default: - undefined\n')
    circuit_breaker: typing.Union[models.aws_ecs.DeploymentCircuitBreakerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly enabled. Default: - disabled\n')
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    deployment_controller: typing.Union[models.aws_ecs.DeploymentControllerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies which deployment controller to use for the service. For more information, see `Amazon ECS Deployment Types <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html>`_ Default: - Rolling update (ECS)\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. The minimum value is 1 Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='The domain name for the service, e.g. "api.example.com.". Default: - No domain name.\n')
    domain_zone: typing.Optional[typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef]] = pydantic.Field(None, description='The Route53 hosted zone for the domain, e.g. "example.com.". Default: - No Route53 hosted domain zone.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    listener_port: typing.Union[int, float, None] = pydantic.Field(None, description='Listener port of the network load balancer that will serve traffic to the service. Default: 80\n')
    load_balancer: typing.Optional[typing.Union[models.aws_elasticloadbalancingv2.NetworkLoadBalancerDef]] = pydantic.Field(None, description='The network load balancer that will serve traffic to the service. If the load balancer has been imported, the vpc attribute must be specified in the call to fromNetworkLoadBalancerAttributes(). [disable-awslint:ref-via-interface] Default: - a new load balancer will be created.\n')
    max_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The maximum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that can run in a service during a deployment. Default: - 100 if daemon, otherwise 200\n")
    min_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The minimum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that must continue to run and remain healthy during a deployment. Default: - 0 if daemon, otherwise 50\n")
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    public_load_balancer: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the Load Balancer will be internet-facing. Default: true\n')
    record_type: typing.Optional[aws_cdk.aws_ecs_patterns.NetworkLoadBalancedServiceRecordType] = pydantic.Field(None, description='Specifies whether the Route53 record should be a CNAME, an A record using the Alias feature or no record at all. This is useful if you need to work with DNS systems that do not support alias records. Default: NetworkLoadBalancedServiceRecordType.ALIAS\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.NetworkLoadBalancedTaskImageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. One of taskImageOptions or taskDefinition must be specified. Default: - none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.')
    _init_params: typing.ClassVar[list[str]] = ['capacity_provider_strategies', 'circuit_breaker', 'cloud_map_options', 'cluster', 'deployment_controller', 'desired_count', 'domain_name', 'domain_zone', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'listener_port', 'load_balancer', 'max_healthy_percent', 'min_healthy_percent', 'propagate_tags', 'public_load_balancer', 'record_type', 'service_name', 'task_image_options', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.NetworkLoadBalancedServiceBase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.NetworkLoadBalancedServiceBaseDefConfig] = pydantic.Field(None)


class NetworkLoadBalancedServiceBaseDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEcsIClusterDefConfig] = pydantic.Field(None)
    listener_config: typing.Optional[models.aws_elasticloadbalancingv2.NetworkListenerDefConfig] = pydantic.Field(None)
    load_balancer_config: typing.Optional[models.aws_elasticloadbalancingv2.NetworkLoadBalancerDefConfig] = pydantic.Field(None)
    target_group_config: typing.Optional[models.aws_elasticloadbalancingv2.NetworkTargetGroupDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.NetworkMultipleTargetGroupsServiceBase
class NetworkMultipleTargetGroupsServiceBaseDef(BaseClass):
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. The minimum value is 1 Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    load_balancers: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.NetworkLoadBalancerPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The network load balancer that will serve traffic to the service. Default: - a new load balancer with a listener will be created.\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='Name of the service. Default: - CloudFormation-generated name.\n')
    target_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.NetworkTargetPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Properties to specify NLB target groups. Default: - default portMapping registered as target group and attached to the first defined listener\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.NetworkLoadBalancedTaskImagePropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. Only one of TaskDefinition or TaskImageOptions must be specified. Default: - none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.')
    _init_params: typing.ClassVar[list[str]] = ['cloud_map_options', 'cluster', 'desired_count', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'load_balancers', 'propagate_tags', 'service_name', 'target_groups', 'task_image_options', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.NetworkMultipleTargetGroupsServiceBase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.NetworkMultipleTargetGroupsServiceBaseDefConfig] = pydantic.Field(None)


class NetworkMultipleTargetGroupsServiceBaseDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEcsIClusterDefConfig] = pydantic.Field(None)
    listener_config: typing.Optional[models.aws_elasticloadbalancingv2.NetworkListenerDefConfig] = pydantic.Field(None)
    load_balancer_config: typing.Optional[models.aws_elasticloadbalancingv2.NetworkLoadBalancerDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.QueueProcessingServiceBase
class QueueProcessingServiceBaseDef(BaseClass):
    image: typing.Union[models.aws_ecs.ContainerImageDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The image used to start a container.\n')
    capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs.CapacityProviderStrategyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of Capacity Provider strategies used to place a service. Default: - undefined\n')
    circuit_breaker: typing.Union[models.aws_ecs.DeploymentCircuitBreakerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly enabled. Default: - disabled\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    command: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The command that is passed to the container. If you provide a shell command as a single string, you have to quote command-line arguments. Default: - CMD value built into container image.\n')
    deployment_controller: typing.Union[models.aws_ecs.DeploymentControllerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies which deployment controller to use for the service. For more information, see `Amazon ECS Deployment Types <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html>`_ Default: - Rolling update (ECS)\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    enable_logging: typing.Optional[bool] = pydantic.Field(None, description='Flag to indicate whether to enable logging. Default: true\n')
    environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description="The environment variables to pass to the container. The variable ``QUEUE_NAME`` with value ``queue.queueName`` will always be passed. Default: 'QUEUE_NAME: queue.queueName'\n")
    family: typing.Optional[str] = pydantic.Field(None, description='The name of a family that the task definition is registered to. A family groups multiple versions of a task definition. Default: - Automatically generated name.\n')
    log_driver: typing.Optional[models.aws_ecs.LogDriverDef] = pydantic.Field(None, description='The log driver to use. Default: - AwsLogDriver if enableLogging is true\n')
    max_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The maximum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that can run in a service during a deployment. Default: - default from underlying service.\n")
    max_receive_count: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of times that a message can be received by consumers. When this value is exceeded for a message the message will be automatically sent to the Dead Letter Queue. If the queue construct is specified, maxReceiveCount should be omitted. Default: 3\n')
    max_scaling_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Maximum capacity to scale to. Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is (desiredTaskCount * 2); if true, the default is 2.\n')
    min_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The minimum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that must continue to run and remain healthy during a deployment. Default: - default from underlying service.\n")
    min_scaling_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Minimum capacity to scale to. Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is the desiredTaskCount; if true, the default is 1.\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    queue: typing.Optional[typing.Union[models.aws_sqs.QueueBaseDef, models.aws_sqs.QueueDef]] = pydantic.Field(None, description="A queue for which to process items from. If specified and this is a FIFO queue, the queue name must end in the string '.fifo'. See `CreateQueue <https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_CreateQueue.html>`_ Default: 'SQSQueue with CloudFormation-generated name'\n")
    retention_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The number of seconds that Dead Letter Queue retains a message. If the queue construct is specified, retentionPeriod should be omitted. Default: Duration.days(14)\n')
    scaling_steps: typing.Optional[typing.Sequence[typing.Union[models.aws_applicationautoscaling.ScalingIntervalDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="The intervals for scaling based on the SQS queue's ApproximateNumberOfMessagesVisible metric. Maps a range of metric values to a particular scaling behavior. See `Simple and Step Scaling Policies for Amazon EC2 Auto Scaling <https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-simple-step.html>`_ Default: [{ upper: 0, change: -1 },{ lower: 100, change: +1 },{ lower: 500, change: +5 }]\n")
    secrets: typing.Optional[typing.Mapping[str, models.aws_ecs.SecretDef]] = pydantic.Field(None, description='The secret to expose to the container as an environment variable. Default: - No secret environment variables.\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    visibility_timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Timeout of processing a single message. After dequeuing, the processor has this much time to handle the message and delete it from the queue before it becomes visible again for dequeueing by another processor. Values must be between 0 and (12 hours). If the queue construct is specified, visibilityTimeout should be omitted. Default: Duration.seconds(30)\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.')
    _init_params: typing.ClassVar[list[str]] = ['image', 'capacity_provider_strategies', 'circuit_breaker', 'cluster', 'command', 'deployment_controller', 'enable_ecs_managed_tags', 'enable_execute_command', 'enable_logging', 'environment', 'family', 'log_driver', 'max_healthy_percent', 'max_receive_count', 'max_scaling_capacity', 'min_healthy_percent', 'min_scaling_capacity', 'propagate_tags', 'queue', 'retention_period', 'scaling_steps', 'secrets', 'service_name', 'visibility_timeout', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.QueueProcessingServiceBase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.QueueProcessingServiceBaseDefConfig] = pydantic.Field(None)


class QueueProcessingServiceBaseDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEcsIClusterDefConfig] = pydantic.Field(None)
    sqs_queue_config: typing.Optional[models._interface_methods.AwsSqsIQueueDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.ScheduledTaskBase
class ScheduledTaskBaseDef(BaseClass):
    schedule: typing.Union[models.aws_applicationautoscaling.ScheduleDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The schedule or rate (frequency) that determines when CloudWatch Events runs the rule. For more information, see `Schedule Expression Syntax for Rules <https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html>`_ in the Amazon CloudWatch User Guide.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    desired_task_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. Default: 1\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the rule is enabled. Default: true\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Default: - Tags will not be propagated\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: - AWS CloudFormation generates a unique physical ID and uses that ID for the rule name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_.\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='Existing security groups to use for your service. Default: - a new security group will be created.\n')
    subnet_selection: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description="In what subnets to place the task's ENIs. (Only applicable in case the TaskDefinition is configured for AwsVpc networking) Default: Private subnets\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.aws_events_targets.TagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The metadata that you apply to the task to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. Default: - No tags are applied to the task\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.')
    _init_params: typing.ClassVar[list[str]] = ['schedule', 'cluster', 'desired_task_count', 'enabled', 'propagate_tags', 'rule_name', 'security_groups', 'subnet_selection', 'tags', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ScheduledTaskBase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.ScheduledTaskBaseDefConfig] = pydantic.Field(None)


class ScheduledTaskBaseDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEcsIClusterDefConfig] = pydantic.Field(None)
    event_rule_config: typing.Optional[models.aws_events.RuleDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedEc2Service
class ApplicationLoadBalancedEc2ServiceDef(BaseConstruct):
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments This default is set in the underlying FargateTaskDefinition construct. Default: none\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The hard limit (in MiB) of memory to present to the container. If your container attempts to exceed the allocated memory, the container is terminated. At least one of memoryLimitMiB and memoryReservationMiB is required. Default: - No memory limit.\n')
    memory_reservation_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The soft limit (in MiB) of memory to reserve for the container. When system memory is under contention, Docker attempts to keep the container memory within the limit. If the container requires more memory, it can consume up to the value specified by the Memory property or all of the available memory on the container instance—whichever comes first. At least one of memoryLimitMiB and memoryReservationMiB is required. Default: - No memory reserved.\n')
    placement_constraints: typing.Optional[typing.Sequence[models.aws_ecs.PlacementConstraintDef]] = pydantic.Field(None, description='The placement constraints to use for tasks in the service. For more information, see `Amazon ECS Task Placement Constraints <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-constraints.html>`_. Default: - No constraints.\n')
    placement_strategies: typing.Optional[typing.Sequence[models.aws_ecs.PlacementStrategyDef]] = pydantic.Field(None, description='The placement strategies to use for tasks in the service. For more information, see `Amazon ECS Task Placement Strategies <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-strategies.html>`_. Default: - No strategies.\n')
    task_definition: typing.Optional[models.aws_ecs.Ec2TaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. TaskDefinition or TaskImageOptions must be specified, but not both.. [disable-awslint:ref-via-interface] Default: - none\n')
    capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs.CapacityProviderStrategyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of Capacity Provider strategies used to place a service. Default: - undefined\n')
    certificate: typing.Optional[typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef]] = pydantic.Field(None, description="Certificate Manager certificate to associate with the load balancer. Setting this option will set the load balancer protocol to HTTPS. Default: - No certificate associated with the load balancer, if using the HTTP protocol. For HTTPS, a DNS-validated certificate will be created for the load balancer's specified domain name if a domain name and domain zone are specified.\n")
    circuit_breaker: typing.Union[models.aws_ecs.DeploymentCircuitBreakerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly enabled. Default: - disabled\n')
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    deployment_controller: typing.Union[models.aws_ecs.DeploymentControllerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies which deployment controller to use for the service. For more information, see `Amazon ECS Deployment Types <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html>`_ Default: - Rolling update (ECS)\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. The minimum value is 1 Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='The domain name for the service, e.g. "api.example.com.". Default: - No domain name.\n')
    domain_zone: typing.Optional[typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef]] = pydantic.Field(None, description='The Route53 hosted zone for the domain, e.g. "example.com.". Default: - No Route53 hosted domain zone.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    idle_timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The load balancer idle timeout, in seconds. Can be between 1 and 4000 seconds Default: - CloudFormation sets idle timeout to 60 seconds\n')
    listener_port: typing.Union[int, float, None] = pydantic.Field(None, description='Listener port of the application load balancer that will serve traffic to the service. Default: - The default listener port is determined from the protocol (port 80 for HTTP, port 443 for HTTPS). A domain name and zone must be also be specified if using HTTPS.\n')
    load_balancer: typing.Optional[typing.Union[models.aws_elasticloadbalancingv2.ApplicationLoadBalancerDef]] = pydantic.Field(None, description='The application load balancer that will serve traffic to the service. The VPC attribute of a load balancer must be specified for it to be used to create a new service with this pattern. [disable-awslint:ref-via-interface] Default: - a new load balancer will be created.\n')
    load_balancer_name: typing.Optional[str] = pydantic.Field(None, description='Name of the load balancer. Default: - Automatically generated name.\n')
    max_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The maximum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that can run in a service during a deployment. Default: - 100 if daemon, otherwise 200\n")
    min_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The minimum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that must continue to run and remain healthy during a deployment. Default: - 0 if daemon, otherwise 50\n")
    open_listener: typing.Optional[bool] = pydantic.Field(None, description="Determines whether or not the Security Group for the Load Balancer's Listener will be open to all traffic by default. Default: true -- The security group allows ingress from all IP addresses.\n")
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    protocol: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.ApplicationProtocol] = pydantic.Field(None, description='The protocol for connections from clients to the load balancer. The load balancer port is determined from the protocol (port 80 for HTTP, port 443 for HTTPS). If HTTPS, either a certificate or domain name and domain zone must also be specified. Default: HTTP. If a certificate is specified, the protocol will be set by default to HTTPS.\n')
    protocol_version: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.ApplicationProtocolVersion] = pydantic.Field(None, description='The protocol version to use. Default: ApplicationProtocolVersion.HTTP1\n')
    public_load_balancer: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the Load Balancer will be internet-facing. Default: true\n')
    record_type: typing.Optional[aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedServiceRecordType] = pydantic.Field(None, description='Specifies whether the Route53 record should be a CNAME, an A record using the Alias feature or no record at all. This is useful if you need to work with DNS systems that do not support alias records. Default: ApplicationLoadBalancedServiceRecordType.ALIAS\n')
    redirect_http: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether the load balancer should redirect traffic on port 80 to port 443 to support HTTP->HTTPS redirects This is only valid if the protocol of the ALB is HTTPS. Default: false\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    ssl_policy: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.SslPolicy] = pydantic.Field(None, description='The security policy that defines which ciphers and protocols are supported by the ALB Listener. Default: - The recommended elastic load balancing security policy\n')
    target_protocol: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.ApplicationProtocol] = pydantic.Field(None, description='The protocol for connections from the load balancer to the ECS tasks. The default target port is determined from the protocol (port 80 for HTTP, port 443 for HTTPS). Default: HTTP.\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.ApplicationLoadBalancedTaskImageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. TaskDefinition or TaskImageOptions must be specified, but not both. Default: none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.')
    _init_params: typing.ClassVar[list[str]] = ['cpu', 'memory_limit_mib', 'memory_reservation_mib', 'placement_constraints', 'placement_strategies', 'task_definition', 'capacity_provider_strategies', 'certificate', 'circuit_breaker', 'cloud_map_options', 'cluster', 'deployment_controller', 'desired_count', 'domain_name', 'domain_zone', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'idle_timeout', 'listener_port', 'load_balancer', 'load_balancer_name', 'max_healthy_percent', 'min_healthy_percent', 'open_listener', 'propagate_tags', 'protocol', 'protocol_version', 'public_load_balancer', 'record_type', 'redirect_http', 'service_name', 'ssl_policy', 'target_protocol', 'task_image_options', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedEc2Service'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.ApplicationLoadBalancedEc2ServiceDefConfig] = pydantic.Field(None)


class ApplicationLoadBalancedEc2ServiceDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEcsIClusterDefConfig] = pydantic.Field(None)
    listener_config: typing.Optional[models.aws_elasticloadbalancingv2.ApplicationListenerDefConfig] = pydantic.Field(None)
    load_balancer_config: typing.Optional[models.aws_elasticloadbalancingv2.ApplicationLoadBalancerDefConfig] = pydantic.Field(None)
    service_config: typing.Optional[models.aws_ecs.Ec2ServiceDefConfig] = pydantic.Field(None)
    target_group_config: typing.Optional[models.aws_elasticloadbalancingv2.ApplicationTargetGroupDefConfig] = pydantic.Field(None)
    task_definition_config: typing.Optional[models.aws_ecs.Ec2TaskDefinitionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedFargateService
class ApplicationLoadBalancedFargateServiceDef(BaseConstruct):
    assign_public_ip: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the service will be assigned a public IP address. Default: false\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='The security groups to associate with the service. If you do not specify a security group, a new security group is created. Default: - A new security group is created.\n')
    task_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The subnets to associate with the service. Default: - Public subnets if ``assignPublicIp`` is set, otherwise the first available one of Private, Isolated, Public, in that order.\n')
    capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs.CapacityProviderStrategyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of Capacity Provider strategies used to place a service. Default: - undefined\n')
    certificate: typing.Optional[typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef]] = pydantic.Field(None, description="Certificate Manager certificate to associate with the load balancer. Setting this option will set the load balancer protocol to HTTPS. Default: - No certificate associated with the load balancer, if using the HTTP protocol. For HTTPS, a DNS-validated certificate will be created for the load balancer's specified domain name if a domain name and domain zone are specified.\n")
    circuit_breaker: typing.Union[models.aws_ecs.DeploymentCircuitBreakerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly enabled. Default: - disabled\n')
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    deployment_controller: typing.Union[models.aws_ecs.DeploymentControllerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies which deployment controller to use for the service. For more information, see `Amazon ECS Deployment Types <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html>`_ Default: - Rolling update (ECS)\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. The minimum value is 1 Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='The domain name for the service, e.g. "api.example.com.". Default: - No domain name.\n')
    domain_zone: typing.Optional[typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef]] = pydantic.Field(None, description='The Route53 hosted zone for the domain, e.g. "example.com.". Default: - No Route53 hosted domain zone.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    idle_timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The load balancer idle timeout, in seconds. Can be between 1 and 4000 seconds Default: - CloudFormation sets idle timeout to 60 seconds\n')
    listener_port: typing.Union[int, float, None] = pydantic.Field(None, description='Listener port of the application load balancer that will serve traffic to the service. Default: - The default listener port is determined from the protocol (port 80 for HTTP, port 443 for HTTPS). A domain name and zone must be also be specified if using HTTPS.\n')
    load_balancer: typing.Optional[typing.Union[models.aws_elasticloadbalancingv2.ApplicationLoadBalancerDef]] = pydantic.Field(None, description='The application load balancer that will serve traffic to the service. The VPC attribute of a load balancer must be specified for it to be used to create a new service with this pattern. [disable-awslint:ref-via-interface] Default: - a new load balancer will be created.\n')
    load_balancer_name: typing.Optional[str] = pydantic.Field(None, description='Name of the load balancer. Default: - Automatically generated name.\n')
    max_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The maximum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that can run in a service during a deployment. Default: - 100 if daemon, otherwise 200\n")
    min_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The minimum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that must continue to run and remain healthy during a deployment. Default: - 0 if daemon, otherwise 50\n")
    open_listener: typing.Optional[bool] = pydantic.Field(None, description="Determines whether or not the Security Group for the Load Balancer's Listener will be open to all traffic by default. Default: true -- The security group allows ingress from all IP addresses.\n")
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    protocol: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.ApplicationProtocol] = pydantic.Field(None, description='The protocol for connections from clients to the load balancer. The load balancer port is determined from the protocol (port 80 for HTTP, port 443 for HTTPS). If HTTPS, either a certificate or domain name and domain zone must also be specified. Default: HTTP. If a certificate is specified, the protocol will be set by default to HTTPS.\n')
    protocol_version: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.ApplicationProtocolVersion] = pydantic.Field(None, description='The protocol version to use. Default: ApplicationProtocolVersion.HTTP1\n')
    public_load_balancer: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the Load Balancer will be internet-facing. Default: true\n')
    record_type: typing.Optional[aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedServiceRecordType] = pydantic.Field(None, description='Specifies whether the Route53 record should be a CNAME, an A record using the Alias feature or no record at all. This is useful if you need to work with DNS systems that do not support alias records. Default: ApplicationLoadBalancedServiceRecordType.ALIAS\n')
    redirect_http: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether the load balancer should redirect traffic on port 80 to port 443 to support HTTP->HTTPS redirects This is only valid if the protocol of the ALB is HTTPS. Default: false\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    ssl_policy: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.SslPolicy] = pydantic.Field(None, description='The security policy that defines which ciphers and protocols are supported by the ALB Listener. Default: - The recommended elastic load balancing security policy\n')
    target_protocol: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.ApplicationProtocol] = pydantic.Field(None, description='The protocol for connections from the load balancer to the ECS tasks. The default target port is determined from the protocol (port 80 for HTTP, port 443 for HTTPS). Default: HTTP.\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.ApplicationLoadBalancedTaskImageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. TaskDefinition or TaskImageOptions must be specified, but not both. Default: none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n')
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments 8192 (8 vCPU) - Available memory values: Between 16GB and 60GB in 4GB increments 16384 (16 vCPU) - Available memory values: Between 32GB and 120GB in 8GB increments This default is set in the underlying FargateTaskDefinition construct. Default: 256\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The amount (in MiB) of memory used by the task. This field is required and you must use one of the following values, which determines your range of valid values for the cpu parameter: 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB) - Available cpu values: 256 (.25 vCPU) 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB) - Available cpu values: 512 (.5 vCPU) 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB) - Available cpu values: 1024 (1 vCPU) Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB) - Available cpu values: 2048 (2 vCPU) Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB) - Available cpu values: 4096 (4 vCPU) Between 16384 (16 GB) and 61440 (60 GB) in increments of 4096 (4 GB) - Available cpu values: 8192 (8 vCPU) Between 32768 (32 GB) and 122880 (120 GB) in increments of 8192 (8 GB) - Available cpu values: 16384 (16 vCPU) This default is set in the underlying FargateTaskDefinition construct. Default: 512\n')
    platform_version: typing.Optional[aws_cdk.aws_ecs.FargatePlatformVersion] = pydantic.Field(None, description='The platform version on which to run your service. If one is not specified, the LATEST platform version is used by default. For more information, see `AWS Fargate Platform Versions <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html>`_ in the Amazon Elastic Container Service Developer Guide. Default: Latest\n')
    runtime_platform: typing.Union[models.aws_ecs.RuntimePlatformDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The runtime platform of the task definition. Default: - If the property is undefined, ``operatingSystemFamily`` is LINUX and ``cpuArchitecture`` is X86_64\n')
    task_definition: typing.Optional[models.aws_ecs.FargateTaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. TaskDefinition or TaskImageOptions must be specified, but not both. [disable-awslint:ref-via-interface] Default: - none')
    _init_params: typing.ClassVar[list[str]] = ['assign_public_ip', 'security_groups', 'task_subnets', 'capacity_provider_strategies', 'certificate', 'circuit_breaker', 'cloud_map_options', 'cluster', 'deployment_controller', 'desired_count', 'domain_name', 'domain_zone', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'idle_timeout', 'listener_port', 'load_balancer', 'load_balancer_name', 'max_healthy_percent', 'min_healthy_percent', 'open_listener', 'propagate_tags', 'protocol', 'protocol_version', 'public_load_balancer', 'record_type', 'redirect_http', 'service_name', 'ssl_policy', 'target_protocol', 'task_image_options', 'vpc', 'cpu', 'memory_limit_mib', 'platform_version', 'runtime_platform', 'task_definition']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedFargateService'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.ApplicationLoadBalancedFargateServiceDefConfig] = pydantic.Field(None)


class ApplicationLoadBalancedFargateServiceDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEcsIClusterDefConfig] = pydantic.Field(None)
    listener_config: typing.Optional[models.aws_elasticloadbalancingv2.ApplicationListenerDefConfig] = pydantic.Field(None)
    load_balancer_config: typing.Optional[models.aws_elasticloadbalancingv2.ApplicationLoadBalancerDefConfig] = pydantic.Field(None)
    service_config: typing.Optional[models.aws_ecs.FargateServiceDefConfig] = pydantic.Field(None)
    target_group_config: typing.Optional[models.aws_elasticloadbalancingv2.ApplicationTargetGroupDefConfig] = pydantic.Field(None)
    task_definition_config: typing.Optional[models.aws_ecs.FargateTaskDefinitionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.ApplicationMultipleTargetGroupsEc2Service
class ApplicationMultipleTargetGroupsEc2ServiceDef(BaseConstruct):
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of CPU units to reserve for the container. Valid values, which determines your range of valid values for the memory parameter: Default: - No minimum CPU units reserved.\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The amount (in MiB) of memory to present to the container. If your container attempts to exceed the allocated memory, the container is terminated. At least one of memoryLimitMiB and memoryReservationMiB is required. Default: - No memory limit.\n')
    memory_reservation_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The soft limit (in MiB) of memory to reserve for the container. When system memory is under heavy contention, Docker attempts to keep the container memory to this soft limit. However, your container can consume more memory when it needs to, up to either the hard limit specified with the memory parameter (if applicable), or all of the available memory on the container instance, whichever comes first. At least one of memoryLimitMiB and memoryReservationMiB is required. Note that this setting will be ignored if TaskImagesOptions is specified Default: - No memory reserved.\n')
    placement_constraints: typing.Optional[typing.Sequence[models.aws_ecs.PlacementConstraintDef]] = pydantic.Field(None, description='The placement constraints to use for tasks in the service. For more information, see `Amazon ECS Task Placement Constraints <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-constraints.html>`_. Default: - No constraints.\n')
    placement_strategies: typing.Optional[typing.Sequence[models.aws_ecs.PlacementStrategyDef]] = pydantic.Field(None, description='The placement strategies to use for tasks in the service. For more information, see `Amazon ECS Task Placement Strategies <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-strategies.html>`_. Default: - No strategies.\n')
    task_definition: typing.Optional[models.aws_ecs.Ec2TaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. Only one of TaskDefinition or TaskImageOptions must be specified. [disable-awslint:ref-via-interface] Default: - none\n')
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    load_balancers: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.ApplicationLoadBalancerPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The application load balancer that will serve traffic to the service. Default: - a new load balancer with a listener will be created.\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    target_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.ApplicationTargetPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Properties to specify ALB target groups. Default: - default portMapping registered as target group and attached to the first defined listener\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.ApplicationLoadBalancedTaskImagePropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. Only one of TaskDefinition or TaskImageOptions must be specified. Default: none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.')
    _init_params: typing.ClassVar[list[str]] = ['cpu', 'memory_limit_mib', 'memory_reservation_mib', 'placement_constraints', 'placement_strategies', 'task_definition', 'cloud_map_options', 'cluster', 'desired_count', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'load_balancers', 'propagate_tags', 'service_name', 'target_groups', 'task_image_options', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ApplicationMultipleTargetGroupsEc2Service'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.ApplicationMultipleTargetGroupsEc2ServiceDefConfig] = pydantic.Field(None)


class ApplicationMultipleTargetGroupsEc2ServiceDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEcsIClusterDefConfig] = pydantic.Field(None)
    listener_config: typing.Optional[models.aws_elasticloadbalancingv2.ApplicationListenerDefConfig] = pydantic.Field(None)
    load_balancer_config: typing.Optional[models.aws_elasticloadbalancingv2.ApplicationLoadBalancerDefConfig] = pydantic.Field(None)
    service_config: typing.Optional[models.aws_ecs.Ec2ServiceDefConfig] = pydantic.Field(None)
    target_group_config: typing.Optional[models.aws_elasticloadbalancingv2.ApplicationTargetGroupDefConfig] = pydantic.Field(None)
    task_definition_config: typing.Optional[models.aws_ecs.Ec2TaskDefinitionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.ApplicationMultipleTargetGroupsFargateService
class ApplicationMultipleTargetGroupsFargateServiceDef(BaseConstruct):
    assign_public_ip: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the service will be assigned a public IP address. Default: false\n')
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    load_balancers: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.ApplicationLoadBalancerPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The application load balancer that will serve traffic to the service. Default: - a new load balancer with a listener will be created.\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    target_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.ApplicationTargetPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Properties to specify ALB target groups. Default: - default portMapping registered as target group and attached to the first defined listener\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.ApplicationLoadBalancedTaskImagePropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. Only one of TaskDefinition or TaskImageOptions must be specified. Default: none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n')
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments 8192 (8 vCPU) - Available memory values: Between 16GB and 60GB in 4GB increments 16384 (16 vCPU) - Available memory values: Between 32GB and 120GB in 8GB increments This default is set in the underlying FargateTaskDefinition construct. Default: 256\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The amount (in MiB) of memory used by the task. This field is required and you must use one of the following values, which determines your range of valid values for the cpu parameter: 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB) - Available cpu values: 256 (.25 vCPU) 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB) - Available cpu values: 512 (.5 vCPU) 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB) - Available cpu values: 1024 (1 vCPU) Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB) - Available cpu values: 2048 (2 vCPU) Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB) - Available cpu values: 4096 (4 vCPU) Between 16384 (16 GB) and 61440 (60 GB) in increments of 4096 (4 GB) - Available cpu values: 8192 (8 vCPU) Between 32768 (32 GB) and 122880 (120 GB) in increments of 8192 (8 GB) - Available cpu values: 16384 (16 vCPU) This default is set in the underlying FargateTaskDefinition construct. Default: 512\n')
    platform_version: typing.Optional[aws_cdk.aws_ecs.FargatePlatformVersion] = pydantic.Field(None, description='The platform version on which to run your service. If one is not specified, the LATEST platform version is used by default. For more information, see `AWS Fargate Platform Versions <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html>`_ in the Amazon Elastic Container Service Developer Guide. Default: Latest\n')
    runtime_platform: typing.Union[models.aws_ecs.RuntimePlatformDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The runtime platform of the task definition. Default: - If the property is undefined, ``operatingSystemFamily`` is LINUX and ``cpuArchitecture`` is X86_64\n')
    task_definition: typing.Optional[models.aws_ecs.FargateTaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. TaskDefinition or TaskImageOptions must be specified, but not both. [disable-awslint:ref-via-interface] Default: - none')
    _init_params: typing.ClassVar[list[str]] = ['assign_public_ip', 'cloud_map_options', 'cluster', 'desired_count', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'load_balancers', 'propagate_tags', 'service_name', 'target_groups', 'task_image_options', 'vpc', 'cpu', 'memory_limit_mib', 'platform_version', 'runtime_platform', 'task_definition']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ApplicationMultipleTargetGroupsFargateService'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.ApplicationMultipleTargetGroupsFargateServiceDefConfig] = pydantic.Field(None)


class ApplicationMultipleTargetGroupsFargateServiceDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEcsIClusterDefConfig] = pydantic.Field(None)
    listener_config: typing.Optional[models.aws_elasticloadbalancingv2.ApplicationListenerDefConfig] = pydantic.Field(None)
    load_balancer_config: typing.Optional[models.aws_elasticloadbalancingv2.ApplicationLoadBalancerDefConfig] = pydantic.Field(None)
    service_config: typing.Optional[models.aws_ecs.FargateServiceDefConfig] = pydantic.Field(None)
    target_group_config: typing.Optional[models.aws_elasticloadbalancingv2.ApplicationTargetGroupDefConfig] = pydantic.Field(None)
    task_definition_config: typing.Optional[models.aws_ecs.FargateTaskDefinitionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.NetworkLoadBalancedEc2Service
class NetworkLoadBalancedEc2ServiceDef(BaseConstruct):
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments This default is set in the underlying FargateTaskDefinition construct. Default: none\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The hard limit (in MiB) of memory to present to the container. If your container attempts to exceed the allocated memory, the container is terminated. At least one of memoryLimitMiB and memoryReservationMiB is required. Default: - No memory limit.\n')
    memory_reservation_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The soft limit (in MiB) of memory to reserve for the container. When system memory is under contention, Docker attempts to keep the container memory within the limit. If the container requires more memory, it can consume up to the value specified by the Memory property or all of the available memory on the container instance—whichever comes first. At least one of memoryLimitMiB and memoryReservationMiB is required. Default: - No memory reserved.\n')
    placement_constraints: typing.Optional[typing.Sequence[models.aws_ecs.PlacementConstraintDef]] = pydantic.Field(None, description='The placement constraints to use for tasks in the service. For more information, see `Amazon ECS Task Placement Constraints <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-constraints.html>`_. Default: - No constraints.\n')
    placement_strategies: typing.Optional[typing.Sequence[models.aws_ecs.PlacementStrategyDef]] = pydantic.Field(None, description='The placement strategies to use for tasks in the service. For more information, see `Amazon ECS Task Placement Strategies <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-strategies.html>`_. Default: - No strategies.\n')
    task_definition: typing.Optional[models.aws_ecs.Ec2TaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. TaskDefinition or TaskImageOptions must be specified, but not both.. [disable-awslint:ref-via-interface] Default: - none\n')
    capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs.CapacityProviderStrategyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of Capacity Provider strategies used to place a service. Default: - undefined\n')
    circuit_breaker: typing.Union[models.aws_ecs.DeploymentCircuitBreakerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly enabled. Default: - disabled\n')
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    deployment_controller: typing.Union[models.aws_ecs.DeploymentControllerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies which deployment controller to use for the service. For more information, see `Amazon ECS Deployment Types <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html>`_ Default: - Rolling update (ECS)\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. The minimum value is 1 Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='The domain name for the service, e.g. "api.example.com.". Default: - No domain name.\n')
    domain_zone: typing.Optional[typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef]] = pydantic.Field(None, description='The Route53 hosted zone for the domain, e.g. "example.com.". Default: - No Route53 hosted domain zone.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    listener_port: typing.Union[int, float, None] = pydantic.Field(None, description='Listener port of the network load balancer that will serve traffic to the service. Default: 80\n')
    load_balancer: typing.Optional[typing.Union[models.aws_elasticloadbalancingv2.NetworkLoadBalancerDef]] = pydantic.Field(None, description='The network load balancer that will serve traffic to the service. If the load balancer has been imported, the vpc attribute must be specified in the call to fromNetworkLoadBalancerAttributes(). [disable-awslint:ref-via-interface] Default: - a new load balancer will be created.\n')
    max_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The maximum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that can run in a service during a deployment. Default: - 100 if daemon, otherwise 200\n")
    min_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The minimum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that must continue to run and remain healthy during a deployment. Default: - 0 if daemon, otherwise 50\n")
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    public_load_balancer: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the Load Balancer will be internet-facing. Default: true\n')
    record_type: typing.Optional[aws_cdk.aws_ecs_patterns.NetworkLoadBalancedServiceRecordType] = pydantic.Field(None, description='Specifies whether the Route53 record should be a CNAME, an A record using the Alias feature or no record at all. This is useful if you need to work with DNS systems that do not support alias records. Default: NetworkLoadBalancedServiceRecordType.ALIAS\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.NetworkLoadBalancedTaskImageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. One of taskImageOptions or taskDefinition must be specified. Default: - none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.')
    _init_params: typing.ClassVar[list[str]] = ['cpu', 'memory_limit_mib', 'memory_reservation_mib', 'placement_constraints', 'placement_strategies', 'task_definition', 'capacity_provider_strategies', 'circuit_breaker', 'cloud_map_options', 'cluster', 'deployment_controller', 'desired_count', 'domain_name', 'domain_zone', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'listener_port', 'load_balancer', 'max_healthy_percent', 'min_healthy_percent', 'propagate_tags', 'public_load_balancer', 'record_type', 'service_name', 'task_image_options', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.NetworkLoadBalancedEc2Service'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.NetworkLoadBalancedEc2ServiceDefConfig] = pydantic.Field(None)


class NetworkLoadBalancedEc2ServiceDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEcsIClusterDefConfig] = pydantic.Field(None)
    listener_config: typing.Optional[models.aws_elasticloadbalancingv2.NetworkListenerDefConfig] = pydantic.Field(None)
    load_balancer_config: typing.Optional[models.aws_elasticloadbalancingv2.NetworkLoadBalancerDefConfig] = pydantic.Field(None)
    service_config: typing.Optional[models.aws_ecs.Ec2ServiceDefConfig] = pydantic.Field(None)
    target_group_config: typing.Optional[models.aws_elasticloadbalancingv2.NetworkTargetGroupDefConfig] = pydantic.Field(None)
    task_definition_config: typing.Optional[models.aws_ecs.Ec2TaskDefinitionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.NetworkLoadBalancedFargateService
class NetworkLoadBalancedFargateServiceDef(BaseConstruct):
    assign_public_ip: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the service will be assigned a public IP address. Default: false\n')
    task_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The subnets to associate with the service. Default: - Public subnets if ``assignPublicIp`` is set, otherwise the first available one of Private, Isolated, Public, in that order.\n')
    capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs.CapacityProviderStrategyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of Capacity Provider strategies used to place a service. Default: - undefined\n')
    circuit_breaker: typing.Union[models.aws_ecs.DeploymentCircuitBreakerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly enabled. Default: - disabled\n')
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    deployment_controller: typing.Union[models.aws_ecs.DeploymentControllerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies which deployment controller to use for the service. For more information, see `Amazon ECS Deployment Types <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html>`_ Default: - Rolling update (ECS)\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. The minimum value is 1 Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='The domain name for the service, e.g. "api.example.com.". Default: - No domain name.\n')
    domain_zone: typing.Optional[typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef]] = pydantic.Field(None, description='The Route53 hosted zone for the domain, e.g. "example.com.". Default: - No Route53 hosted domain zone.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    listener_port: typing.Union[int, float, None] = pydantic.Field(None, description='Listener port of the network load balancer that will serve traffic to the service. Default: 80\n')
    load_balancer: typing.Optional[typing.Union[models.aws_elasticloadbalancingv2.NetworkLoadBalancerDef]] = pydantic.Field(None, description='The network load balancer that will serve traffic to the service. If the load balancer has been imported, the vpc attribute must be specified in the call to fromNetworkLoadBalancerAttributes(). [disable-awslint:ref-via-interface] Default: - a new load balancer will be created.\n')
    max_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The maximum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that can run in a service during a deployment. Default: - 100 if daemon, otherwise 200\n")
    min_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The minimum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that must continue to run and remain healthy during a deployment. Default: - 0 if daemon, otherwise 50\n")
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    public_load_balancer: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the Load Balancer will be internet-facing. Default: true\n')
    record_type: typing.Optional[aws_cdk.aws_ecs_patterns.NetworkLoadBalancedServiceRecordType] = pydantic.Field(None, description='Specifies whether the Route53 record should be a CNAME, an A record using the Alias feature or no record at all. This is useful if you need to work with DNS systems that do not support alias records. Default: NetworkLoadBalancedServiceRecordType.ALIAS\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.NetworkLoadBalancedTaskImageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. One of taskImageOptions or taskDefinition must be specified. Default: - none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n')
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments 8192 (8 vCPU) - Available memory values: Between 16GB and 60GB in 4GB increments 16384 (16 vCPU) - Available memory values: Between 32GB and 120GB in 8GB increments This default is set in the underlying FargateTaskDefinition construct. Default: 256\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The amount (in MiB) of memory used by the task. This field is required and you must use one of the following values, which determines your range of valid values for the cpu parameter: 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB) - Available cpu values: 256 (.25 vCPU) 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB) - Available cpu values: 512 (.5 vCPU) 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB) - Available cpu values: 1024 (1 vCPU) Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB) - Available cpu values: 2048 (2 vCPU) Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB) - Available cpu values: 4096 (4 vCPU) Between 16384 (16 GB) and 61440 (60 GB) in increments of 4096 (4 GB) - Available cpu values: 8192 (8 vCPU) Between 32768 (32 GB) and 122880 (120 GB) in increments of 8192 (8 GB) - Available cpu values: 16384 (16 vCPU) This default is set in the underlying FargateTaskDefinition construct. Default: 512\n')
    platform_version: typing.Optional[aws_cdk.aws_ecs.FargatePlatformVersion] = pydantic.Field(None, description='The platform version on which to run your service. If one is not specified, the LATEST platform version is used by default. For more information, see `AWS Fargate Platform Versions <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html>`_ in the Amazon Elastic Container Service Developer Guide. Default: Latest\n')
    runtime_platform: typing.Union[models.aws_ecs.RuntimePlatformDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The runtime platform of the task definition. Default: - If the property is undefined, ``operatingSystemFamily`` is LINUX and ``cpuArchitecture`` is X86_64\n')
    task_definition: typing.Optional[models.aws_ecs.FargateTaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. TaskDefinition or TaskImageOptions must be specified, but not both. [disable-awslint:ref-via-interface] Default: - none')
    _init_params: typing.ClassVar[list[str]] = ['assign_public_ip', 'task_subnets', 'capacity_provider_strategies', 'circuit_breaker', 'cloud_map_options', 'cluster', 'deployment_controller', 'desired_count', 'domain_name', 'domain_zone', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'listener_port', 'load_balancer', 'max_healthy_percent', 'min_healthy_percent', 'propagate_tags', 'public_load_balancer', 'record_type', 'service_name', 'task_image_options', 'vpc', 'cpu', 'memory_limit_mib', 'platform_version', 'runtime_platform', 'task_definition']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.NetworkLoadBalancedFargateService'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.NetworkLoadBalancedFargateServiceDefConfig] = pydantic.Field(None)


class NetworkLoadBalancedFargateServiceDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEcsIClusterDefConfig] = pydantic.Field(None)
    listener_config: typing.Optional[models.aws_elasticloadbalancingv2.NetworkListenerDefConfig] = pydantic.Field(None)
    load_balancer_config: typing.Optional[models.aws_elasticloadbalancingv2.NetworkLoadBalancerDefConfig] = pydantic.Field(None)
    service_config: typing.Optional[models.aws_ecs.FargateServiceDefConfig] = pydantic.Field(None)
    target_group_config: typing.Optional[models.aws_elasticloadbalancingv2.NetworkTargetGroupDefConfig] = pydantic.Field(None)
    task_definition_config: typing.Optional[models.aws_ecs.FargateTaskDefinitionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.NetworkMultipleTargetGroupsEc2Service
class NetworkMultipleTargetGroupsEc2ServiceDef(BaseConstruct):
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of CPU units to reserve for the container. Valid values, which determines your range of valid values for the memory parameter: Default: - No minimum CPU units reserved.\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The amount (in MiB) of memory to present to the container. If your container attempts to exceed the allocated memory, the container is terminated. At least one of memoryLimitMiB and memoryReservationMiB is required. Default: - No memory limit.\n')
    memory_reservation_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The soft limit (in MiB) of memory to reserve for the container. When system memory is under heavy contention, Docker attempts to keep the container memory to this soft limit. However, your container can consume more memory when it needs to, up to either the hard limit specified with the memory parameter (if applicable), or all of the available memory on the container instance, whichever comes first. At least one of memoryLimitMiB and memoryReservationMiB is required. Note that this setting will be ignored if TaskImagesOptions is specified. Default: - No memory reserved.\n')
    placement_constraints: typing.Optional[typing.Sequence[models.aws_ecs.PlacementConstraintDef]] = pydantic.Field(None, description='The placement constraints to use for tasks in the service. For more information, see `Amazon ECS Task Placement Constraints <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-constraints.html>`_. Default: - No constraints.\n')
    placement_strategies: typing.Optional[typing.Sequence[models.aws_ecs.PlacementStrategyDef]] = pydantic.Field(None, description='The placement strategies to use for tasks in the service. For more information, see `Amazon ECS Task Placement Strategies <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-strategies.html>`_. Default: - No strategies.\n')
    task_definition: typing.Optional[models.aws_ecs.Ec2TaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. Only one of TaskDefinition or TaskImageOptions must be specified. [disable-awslint:ref-via-interface] Default: - none\n')
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. The minimum value is 1 Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    load_balancers: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.NetworkLoadBalancerPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The network load balancer that will serve traffic to the service. Default: - a new load balancer with a listener will be created.\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='Name of the service. Default: - CloudFormation-generated name.\n')
    target_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.NetworkTargetPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Properties to specify NLB target groups. Default: - default portMapping registered as target group and attached to the first defined listener\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.NetworkLoadBalancedTaskImagePropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. Only one of TaskDefinition or TaskImageOptions must be specified. Default: - none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.')
    _init_params: typing.ClassVar[list[str]] = ['cpu', 'memory_limit_mib', 'memory_reservation_mib', 'placement_constraints', 'placement_strategies', 'task_definition', 'cloud_map_options', 'cluster', 'desired_count', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'load_balancers', 'propagate_tags', 'service_name', 'target_groups', 'task_image_options', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.NetworkMultipleTargetGroupsEc2Service'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.NetworkMultipleTargetGroupsEc2ServiceDefConfig] = pydantic.Field(None)


class NetworkMultipleTargetGroupsEc2ServiceDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEcsIClusterDefConfig] = pydantic.Field(None)
    listener_config: typing.Optional[models.aws_elasticloadbalancingv2.NetworkListenerDefConfig] = pydantic.Field(None)
    load_balancer_config: typing.Optional[models.aws_elasticloadbalancingv2.NetworkLoadBalancerDefConfig] = pydantic.Field(None)
    service_config: typing.Optional[models.aws_ecs.Ec2ServiceDefConfig] = pydantic.Field(None)
    target_group_config: typing.Optional[models.aws_elasticloadbalancingv2.NetworkTargetGroupDefConfig] = pydantic.Field(None)
    task_definition_config: typing.Optional[models.aws_ecs.Ec2TaskDefinitionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.NetworkMultipleTargetGroupsFargateService
class NetworkMultipleTargetGroupsFargateServiceDef(BaseConstruct):
    assign_public_ip: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the service will be assigned a public IP address. Default: false\n')
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. The minimum value is 1 Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    load_balancers: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.NetworkLoadBalancerPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The network load balancer that will serve traffic to the service. Default: - a new load balancer with a listener will be created.\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='Name of the service. Default: - CloudFormation-generated name.\n')
    target_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.NetworkTargetPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Properties to specify NLB target groups. Default: - default portMapping registered as target group and attached to the first defined listener\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.NetworkLoadBalancedTaskImagePropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. Only one of TaskDefinition or TaskImageOptions must be specified. Default: - none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n')
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments 8192 (8 vCPU) - Available memory values: Between 16GB and 60GB in 4GB increments 16384 (16 vCPU) - Available memory values: Between 32GB and 120GB in 8GB increments This default is set in the underlying FargateTaskDefinition construct. Default: 256\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The amount (in MiB) of memory used by the task. This field is required and you must use one of the following values, which determines your range of valid values for the cpu parameter: 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB) - Available cpu values: 256 (.25 vCPU) 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB) - Available cpu values: 512 (.5 vCPU) 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB) - Available cpu values: 1024 (1 vCPU) Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB) - Available cpu values: 2048 (2 vCPU) Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB) - Available cpu values: 4096 (4 vCPU) Between 16384 (16 GB) and 61440 (60 GB) in increments of 4096 (4 GB) - Available cpu values: 8192 (8 vCPU) Between 32768 (32 GB) and 122880 (120 GB) in increments of 8192 (8 GB) - Available cpu values: 16384 (16 vCPU) This default is set in the underlying FargateTaskDefinition construct. Default: 512\n')
    platform_version: typing.Optional[aws_cdk.aws_ecs.FargatePlatformVersion] = pydantic.Field(None, description='The platform version on which to run your service. If one is not specified, the LATEST platform version is used by default. For more information, see `AWS Fargate Platform Versions <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html>`_ in the Amazon Elastic Container Service Developer Guide. Default: Latest\n')
    runtime_platform: typing.Union[models.aws_ecs.RuntimePlatformDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The runtime platform of the task definition. Default: - If the property is undefined, ``operatingSystemFamily`` is LINUX and ``cpuArchitecture`` is X86_64\n')
    task_definition: typing.Optional[models.aws_ecs.FargateTaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. TaskDefinition or TaskImageOptions must be specified, but not both. [disable-awslint:ref-via-interface] Default: - none')
    _init_params: typing.ClassVar[list[str]] = ['assign_public_ip', 'cloud_map_options', 'cluster', 'desired_count', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'load_balancers', 'propagate_tags', 'service_name', 'target_groups', 'task_image_options', 'vpc', 'cpu', 'memory_limit_mib', 'platform_version', 'runtime_platform', 'task_definition']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.NetworkMultipleTargetGroupsFargateService'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.NetworkMultipleTargetGroupsFargateServiceDefConfig] = pydantic.Field(None)


class NetworkMultipleTargetGroupsFargateServiceDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEcsIClusterDefConfig] = pydantic.Field(None)
    listener_config: typing.Optional[models.aws_elasticloadbalancingv2.NetworkListenerDefConfig] = pydantic.Field(None)
    load_balancer_config: typing.Optional[models.aws_elasticloadbalancingv2.NetworkLoadBalancerDefConfig] = pydantic.Field(None)
    service_config: typing.Optional[models.aws_ecs.FargateServiceDefConfig] = pydantic.Field(None)
    target_group_config: typing.Optional[models.aws_elasticloadbalancingv2.NetworkTargetGroupDefConfig] = pydantic.Field(None)
    task_definition_config: typing.Optional[models.aws_ecs.FargateTaskDefinitionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.QueueProcessingEc2Service
class QueueProcessingEc2ServiceDef(BaseConstruct):
    container_name: typing.Optional[str] = pydantic.Field(None, description='Optional name for the container added. Default: - QueueProcessingContainer\n')
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments This default is set in the underlying FargateTaskDefinition construct. Default: none\n')
    gpu_count: typing.Union[int, float, None] = pydantic.Field(None, description='Gpu count for container in task definition. Set this if you want to use gpu based instances. Default: - No GPUs assigned.\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The hard limit (in MiB) of memory to present to the container. If your container attempts to exceed the allocated memory, the container is terminated. At least one of memoryLimitMiB and memoryReservationMiB is required for non-Fargate services. Default: - No memory limit.\n')
    memory_reservation_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The soft limit (in MiB) of memory to reserve for the container. When system memory is under contention, Docker attempts to keep the container memory within the limit. If the container requires more memory, it can consume up to the value specified by the Memory property or all of the available memory on the container instance—whichever comes first. At least one of memoryLimitMiB and memoryReservationMiB is required for non-Fargate services. Default: - No memory reserved.\n')
    placement_constraints: typing.Optional[typing.Sequence[models.aws_ecs.PlacementConstraintDef]] = pydantic.Field(None, description='The placement constraints to use for tasks in the service. For more information, see `Amazon ECS Task Placement Constraints <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-constraints.html>`_. Default: - No constraints.\n')
    placement_strategies: typing.Optional[typing.Sequence[models.aws_ecs.PlacementStrategyDef]] = pydantic.Field(None, description='The placement strategies to use for tasks in the service. For more information, see `Amazon ECS Task Placement Strategies <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-strategies.html>`_. Default: - No strategies.\n')
    image: typing.Union[models.aws_ecs.ContainerImageDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The image used to start a container.\n')
    capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs.CapacityProviderStrategyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of Capacity Provider strategies used to place a service. Default: - undefined\n')
    circuit_breaker: typing.Union[models.aws_ecs.DeploymentCircuitBreakerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly enabled. Default: - disabled\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    command: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The command that is passed to the container. If you provide a shell command as a single string, you have to quote command-line arguments. Default: - CMD value built into container image.\n')
    deployment_controller: typing.Union[models.aws_ecs.DeploymentControllerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies which deployment controller to use for the service. For more information, see `Amazon ECS Deployment Types <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html>`_ Default: - Rolling update (ECS)\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    enable_logging: typing.Optional[bool] = pydantic.Field(None, description='Flag to indicate whether to enable logging. Default: true\n')
    environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description="The environment variables to pass to the container. The variable ``QUEUE_NAME`` with value ``queue.queueName`` will always be passed. Default: 'QUEUE_NAME: queue.queueName'\n")
    family: typing.Optional[str] = pydantic.Field(None, description='The name of a family that the task definition is registered to. A family groups multiple versions of a task definition. Default: - Automatically generated name.\n')
    log_driver: typing.Optional[models.aws_ecs.LogDriverDef] = pydantic.Field(None, description='The log driver to use. Default: - AwsLogDriver if enableLogging is true\n')
    max_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The maximum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that can run in a service during a deployment. Default: - default from underlying service.\n")
    max_receive_count: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of times that a message can be received by consumers. When this value is exceeded for a message the message will be automatically sent to the Dead Letter Queue. If the queue construct is specified, maxReceiveCount should be omitted. Default: 3\n')
    max_scaling_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Maximum capacity to scale to. Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is (desiredTaskCount * 2); if true, the default is 2.\n')
    min_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The minimum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that must continue to run and remain healthy during a deployment. Default: - default from underlying service.\n")
    min_scaling_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Minimum capacity to scale to. Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is the desiredTaskCount; if true, the default is 1.\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    queue: typing.Optional[typing.Union[models.aws_sqs.QueueBaseDef, models.aws_sqs.QueueDef]] = pydantic.Field(None, description="A queue for which to process items from. If specified and this is a FIFO queue, the queue name must end in the string '.fifo'. See `CreateQueue <https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_CreateQueue.html>`_ Default: 'SQSQueue with CloudFormation-generated name'\n")
    retention_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The number of seconds that Dead Letter Queue retains a message. If the queue construct is specified, retentionPeriod should be omitted. Default: Duration.days(14)\n')
    scaling_steps: typing.Optional[typing.Sequence[typing.Union[models.aws_applicationautoscaling.ScalingIntervalDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="The intervals for scaling based on the SQS queue's ApproximateNumberOfMessagesVisible metric. Maps a range of metric values to a particular scaling behavior. See `Simple and Step Scaling Policies for Amazon EC2 Auto Scaling <https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-simple-step.html>`_ Default: [{ upper: 0, change: -1 },{ lower: 100, change: +1 },{ lower: 500, change: +5 }]\n")
    secrets: typing.Optional[typing.Mapping[str, models.aws_ecs.SecretDef]] = pydantic.Field(None, description='The secret to expose to the container as an environment variable. Default: - No secret environment variables.\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    visibility_timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Timeout of processing a single message. After dequeuing, the processor has this much time to handle the message and delete it from the queue before it becomes visible again for dequeueing by another processor. Values must be between 0 and (12 hours). If the queue construct is specified, visibilityTimeout should be omitted. Default: Duration.seconds(30)\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.')
    _init_params: typing.ClassVar[list[str]] = ['container_name', 'cpu', 'gpu_count', 'memory_limit_mib', 'memory_reservation_mib', 'placement_constraints', 'placement_strategies', 'image', 'capacity_provider_strategies', 'circuit_breaker', 'cluster', 'command', 'deployment_controller', 'enable_ecs_managed_tags', 'enable_execute_command', 'enable_logging', 'environment', 'family', 'log_driver', 'max_healthy_percent', 'max_receive_count', 'max_scaling_capacity', 'min_healthy_percent', 'min_scaling_capacity', 'propagate_tags', 'queue', 'retention_period', 'scaling_steps', 'secrets', 'service_name', 'visibility_timeout', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.QueueProcessingEc2Service'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.QueueProcessingEc2ServiceDefConfig] = pydantic.Field(None)


class QueueProcessingEc2ServiceDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEcsIClusterDefConfig] = pydantic.Field(None)
    service_config: typing.Optional[models.aws_ecs.Ec2ServiceDefConfig] = pydantic.Field(None)
    sqs_queue_config: typing.Optional[models._interface_methods.AwsSqsIQueueDefConfig] = pydantic.Field(None)
    task_definition_config: typing.Optional[models.aws_ecs.Ec2TaskDefinitionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.QueueProcessingFargateService
class QueueProcessingFargateServiceDef(BaseConstruct):
    assign_public_ip: typing.Optional[bool] = pydantic.Field(None, description="Specifies whether the task's elastic network interface receives a public IP address. If true, each task will receive a public IP address. Default: false\n")
    container_name: typing.Optional[str] = pydantic.Field(None, description='Optional name for the container added. Default: - QueueProcessingContainer\n')
    health_check: typing.Union[models.aws_ecs.HealthCheckDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The health check command and associated configuration parameters for the container. Default: - Health check configuration from container.\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='The security groups to associate with the service. If you do not specify a security group, a new security group is created. Default: - A new security group is created.\n')
    task_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The subnets to associate with the service. Default: - Public subnets if ``assignPublicIp`` is set, otherwise the first available one of Private, Isolated, Public, in that order.\n')
    image: typing.Union[models.aws_ecs.ContainerImageDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The image used to start a container.\n')
    capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs.CapacityProviderStrategyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of Capacity Provider strategies used to place a service. Default: - undefined\n')
    circuit_breaker: typing.Union[models.aws_ecs.DeploymentCircuitBreakerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly enabled. Default: - disabled\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    command: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The command that is passed to the container. If you provide a shell command as a single string, you have to quote command-line arguments. Default: - CMD value built into container image.\n')
    deployment_controller: typing.Union[models.aws_ecs.DeploymentControllerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies which deployment controller to use for the service. For more information, see `Amazon ECS Deployment Types <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html>`_ Default: - Rolling update (ECS)\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    enable_logging: typing.Optional[bool] = pydantic.Field(None, description='Flag to indicate whether to enable logging. Default: true\n')
    environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description="The environment variables to pass to the container. The variable ``QUEUE_NAME`` with value ``queue.queueName`` will always be passed. Default: 'QUEUE_NAME: queue.queueName'\n")
    family: typing.Optional[str] = pydantic.Field(None, description='The name of a family that the task definition is registered to. A family groups multiple versions of a task definition. Default: - Automatically generated name.\n')
    log_driver: typing.Optional[models.aws_ecs.LogDriverDef] = pydantic.Field(None, description='The log driver to use. Default: - AwsLogDriver if enableLogging is true\n')
    max_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The maximum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that can run in a service during a deployment. Default: - default from underlying service.\n")
    max_receive_count: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of times that a message can be received by consumers. When this value is exceeded for a message the message will be automatically sent to the Dead Letter Queue. If the queue construct is specified, maxReceiveCount should be omitted. Default: 3\n')
    max_scaling_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Maximum capacity to scale to. Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is (desiredTaskCount * 2); if true, the default is 2.\n')
    min_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The minimum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that must continue to run and remain healthy during a deployment. Default: - default from underlying service.\n")
    min_scaling_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Minimum capacity to scale to. Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is the desiredTaskCount; if true, the default is 1.\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    queue: typing.Optional[typing.Union[models.aws_sqs.QueueBaseDef, models.aws_sqs.QueueDef]] = pydantic.Field(None, description="A queue for which to process items from. If specified and this is a FIFO queue, the queue name must end in the string '.fifo'. See `CreateQueue <https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_CreateQueue.html>`_ Default: 'SQSQueue with CloudFormation-generated name'\n")
    retention_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The number of seconds that Dead Letter Queue retains a message. If the queue construct is specified, retentionPeriod should be omitted. Default: Duration.days(14)\n')
    scaling_steps: typing.Optional[typing.Sequence[typing.Union[models.aws_applicationautoscaling.ScalingIntervalDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="The intervals for scaling based on the SQS queue's ApproximateNumberOfMessagesVisible metric. Maps a range of metric values to a particular scaling behavior. See `Simple and Step Scaling Policies for Amazon EC2 Auto Scaling <https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-simple-step.html>`_ Default: [{ upper: 0, change: -1 },{ lower: 100, change: +1 },{ lower: 500, change: +5 }]\n")
    secrets: typing.Optional[typing.Mapping[str, models.aws_ecs.SecretDef]] = pydantic.Field(None, description='The secret to expose to the container as an environment variable. Default: - No secret environment variables.\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    visibility_timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Timeout of processing a single message. After dequeuing, the processor has this much time to handle the message and delete it from the queue before it becomes visible again for dequeueing by another processor. Values must be between 0 and (12 hours). If the queue construct is specified, visibilityTimeout should be omitted. Default: Duration.seconds(30)\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n')
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments 8192 (8 vCPU) - Available memory values: Between 16GB and 60GB in 4GB increments 16384 (16 vCPU) - Available memory values: Between 32GB and 120GB in 8GB increments This default is set in the underlying FargateTaskDefinition construct. Default: 256\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The amount (in MiB) of memory used by the task. This field is required and you must use one of the following values, which determines your range of valid values for the cpu parameter: 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB) - Available cpu values: 256 (.25 vCPU) 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB) - Available cpu values: 512 (.5 vCPU) 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB) - Available cpu values: 1024 (1 vCPU) Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB) - Available cpu values: 2048 (2 vCPU) Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB) - Available cpu values: 4096 (4 vCPU) Between 16384 (16 GB) and 61440 (60 GB) in increments of 4096 (4 GB) - Available cpu values: 8192 (8 vCPU) Between 32768 (32 GB) and 122880 (120 GB) in increments of 8192 (8 GB) - Available cpu values: 16384 (16 vCPU) This default is set in the underlying FargateTaskDefinition construct. Default: 512\n')
    platform_version: typing.Optional[aws_cdk.aws_ecs.FargatePlatformVersion] = pydantic.Field(None, description='The platform version on which to run your service. If one is not specified, the LATEST platform version is used by default. For more information, see `AWS Fargate Platform Versions <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html>`_ in the Amazon Elastic Container Service Developer Guide. Default: Latest\n')
    runtime_platform: typing.Union[models.aws_ecs.RuntimePlatformDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The runtime platform of the task definition. Default: - If the property is undefined, ``operatingSystemFamily`` is LINUX and ``cpuArchitecture`` is X86_64\n')
    task_definition: typing.Optional[models.aws_ecs.FargateTaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. TaskDefinition or TaskImageOptions must be specified, but not both. [disable-awslint:ref-via-interface] Default: - none')
    _init_params: typing.ClassVar[list[str]] = ['assign_public_ip', 'container_name', 'health_check', 'security_groups', 'task_subnets', 'image', 'capacity_provider_strategies', 'circuit_breaker', 'cluster', 'command', 'deployment_controller', 'enable_ecs_managed_tags', 'enable_execute_command', 'enable_logging', 'environment', 'family', 'log_driver', 'max_healthy_percent', 'max_receive_count', 'max_scaling_capacity', 'min_healthy_percent', 'min_scaling_capacity', 'propagate_tags', 'queue', 'retention_period', 'scaling_steps', 'secrets', 'service_name', 'visibility_timeout', 'vpc', 'cpu', 'memory_limit_mib', 'platform_version', 'runtime_platform', 'task_definition']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.QueueProcessingFargateService'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.QueueProcessingFargateServiceDefConfig] = pydantic.Field(None)


class QueueProcessingFargateServiceDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEcsIClusterDefConfig] = pydantic.Field(None)
    service_config: typing.Optional[models.aws_ecs.FargateServiceDefConfig] = pydantic.Field(None)
    sqs_queue_config: typing.Optional[models._interface_methods.AwsSqsIQueueDefConfig] = pydantic.Field(None)
    task_definition_config: typing.Optional[models.aws_ecs.FargateTaskDefinitionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.ScheduledEc2Task
class ScheduledEc2TaskDef(BaseConstruct):
    scheduled_ec2_task_definition_options: typing.Union[models.aws_ecs_patterns.ScheduledEc2TaskDefinitionOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties to define if using an existing TaskDefinition in this construct. ScheduledEc2TaskDefinitionOptions or ScheduledEc2TaskImageOptions must be defined, but not both. Default: none\n')
    scheduled_ec2_task_image_options: typing.Union[models.aws_ecs_patterns.ScheduledEc2TaskImageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties to define if the construct is to create a TaskDefinition. ScheduledEc2TaskDefinitionOptions or ScheduledEc2TaskImageOptions must be defined, but not both. Default: none\n')
    schedule: typing.Union[models.aws_applicationautoscaling.ScheduleDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The schedule or rate (frequency) that determines when CloudWatch Events runs the rule. For more information, see `Schedule Expression Syntax for Rules <https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html>`_ in the Amazon CloudWatch User Guide.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    desired_task_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. Default: 1\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the rule is enabled. Default: true\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Default: - Tags will not be propagated\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: - AWS CloudFormation generates a unique physical ID and uses that ID for the rule name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_.\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='Existing security groups to use for your service. Default: - a new security group will be created.\n')
    subnet_selection: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description="In what subnets to place the task's ENIs. (Only applicable in case the TaskDefinition is configured for AwsVpc networking) Default: Private subnets\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.aws_events_targets.TagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The metadata that you apply to the task to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. Default: - No tags are applied to the task\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.')
    _init_params: typing.ClassVar[list[str]] = ['scheduled_ec2_task_definition_options', 'scheduled_ec2_task_image_options', 'schedule', 'cluster', 'desired_task_count', 'enabled', 'propagate_tags', 'rule_name', 'security_groups', 'subnet_selection', 'tags', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ScheduledEc2Task'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.ScheduledEc2TaskDefConfig] = pydantic.Field(None)


class ScheduledEc2TaskDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEcsIClusterDefConfig] = pydantic.Field(None)
    event_rule_config: typing.Optional[models.aws_events.RuleDefConfig] = pydantic.Field(None)
    task_config: typing.Optional[models.aws_events_targets.EcsTaskDefConfig] = pydantic.Field(None)
    task_definition_config: typing.Optional[models.aws_ecs.Ec2TaskDefinitionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.ScheduledFargateTask
class ScheduledFargateTaskDef(BaseConstruct):
    scheduled_fargate_task_definition_options: typing.Union[models.aws_ecs_patterns.ScheduledFargateTaskDefinitionOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties to define if using an existing TaskDefinition in this construct. ScheduledFargateTaskDefinitionOptions or ScheduledFargateTaskImageOptions must be defined, but not both. Default: none\n')
    scheduled_fargate_task_image_options: typing.Union[models.aws_ecs_patterns.ScheduledFargateTaskImageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties to define if the construct is to create a TaskDefinition. ScheduledFargateTaskDefinitionOptions or ScheduledFargateTaskImageOptions must be defined, but not both. Default: none\n')
    schedule: typing.Union[models.aws_applicationautoscaling.ScheduleDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The schedule or rate (frequency) that determines when CloudWatch Events runs the rule. For more information, see `Schedule Expression Syntax for Rules <https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html>`_ in the Amazon CloudWatch User Guide.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    desired_task_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. Default: 1\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the rule is enabled. Default: true\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Default: - Tags will not be propagated\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: - AWS CloudFormation generates a unique physical ID and uses that ID for the rule name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_.\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='Existing security groups to use for your service. Default: - a new security group will be created.\n')
    subnet_selection: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description="In what subnets to place the task's ENIs. (Only applicable in case the TaskDefinition is configured for AwsVpc networking) Default: Private subnets\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.aws_events_targets.TagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The metadata that you apply to the task to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. Default: - No tags are applied to the task\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n')
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments 8192 (8 vCPU) - Available memory values: Between 16GB and 60GB in 4GB increments 16384 (16 vCPU) - Available memory values: Between 32GB and 120GB in 8GB increments This default is set in the underlying FargateTaskDefinition construct. Default: 256\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The amount (in MiB) of memory used by the task. This field is required and you must use one of the following values, which determines your range of valid values for the cpu parameter: 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB) - Available cpu values: 256 (.25 vCPU) 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB) - Available cpu values: 512 (.5 vCPU) 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB) - Available cpu values: 1024 (1 vCPU) Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB) - Available cpu values: 2048 (2 vCPU) Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB) - Available cpu values: 4096 (4 vCPU) Between 16384 (16 GB) and 61440 (60 GB) in increments of 4096 (4 GB) - Available cpu values: 8192 (8 vCPU) Between 32768 (32 GB) and 122880 (120 GB) in increments of 8192 (8 GB) - Available cpu values: 16384 (16 vCPU) This default is set in the underlying FargateTaskDefinition construct. Default: 512\n')
    platform_version: typing.Optional[aws_cdk.aws_ecs.FargatePlatformVersion] = pydantic.Field(None, description='The platform version on which to run your service. If one is not specified, the LATEST platform version is used by default. For more information, see `AWS Fargate Platform Versions <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html>`_ in the Amazon Elastic Container Service Developer Guide. Default: Latest\n')
    runtime_platform: typing.Union[models.aws_ecs.RuntimePlatformDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The runtime platform of the task definition. Default: - If the property is undefined, ``operatingSystemFamily`` is LINUX and ``cpuArchitecture`` is X86_64\n')
    task_definition: typing.Optional[models.aws_ecs.FargateTaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. TaskDefinition or TaskImageOptions must be specified, but not both. [disable-awslint:ref-via-interface] Default: - none')
    _init_params: typing.ClassVar[list[str]] = ['scheduled_fargate_task_definition_options', 'scheduled_fargate_task_image_options', 'schedule', 'cluster', 'desired_task_count', 'enabled', 'propagate_tags', 'rule_name', 'security_groups', 'subnet_selection', 'tags', 'vpc', 'cpu', 'memory_limit_mib', 'platform_version', 'runtime_platform', 'task_definition']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ScheduledFargateTask'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.ScheduledFargateTaskDefConfig] = pydantic.Field(None)


class ScheduledFargateTaskDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEcsIClusterDefConfig] = pydantic.Field(None)
    event_rule_config: typing.Optional[models.aws_events.RuleDefConfig] = pydantic.Field(None)
    task_config: typing.Optional[models.aws_events_targets.EcsTaskDefConfig] = pydantic.Field(None)
    task_definition_config: typing.Optional[models.aws_ecs.FargateTaskDefinitionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.ApplicationListenerProps
class ApplicationListenerPropsDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Name of the listener.\n')
    certificate: typing.Optional[typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef]] = pydantic.Field(None, description="Certificate Manager certificate to associate with the load balancer. Setting this option will set the load balancer protocol to HTTPS. Default: - No certificate associated with the load balancer, if using the HTTP protocol. For HTTPS, a DNS-validated certificate will be created for the load balancer's specified domain name.\n")
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The port on which the listener listens for requests. Default: - Determined from protocol if known.\n')
    protocol: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.ApplicationProtocol] = pydantic.Field(None, description='The protocol for connections from clients to the load balancer. The load balancer port is determined from the protocol (port 80 for HTTP, port 443 for HTTPS). A domain name and zone must be also be specified if using HTTPS. Default: ApplicationProtocol.HTTP. If a certificate is specified, the protocol will be set by default to ApplicationProtocol.HTTPS.\n')
    ssl_policy: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.SslPolicy] = pydantic.Field(None, description='The security policy that defines which ciphers and protocols are supported by the ALB Listener. Default: - The recommended elastic load balancing security policy\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_certificatemanager as certificatemanager\n    from aws_cdk import aws_ecs_patterns as ecs_patterns\n    from aws_cdk import aws_elasticloadbalancingv2 as elbv2\n\n    # certificate: certificatemanager.Certificate\n\n    application_listener_props = ecs_patterns.ApplicationListenerProps(\n        name="name",\n\n        # the properties below are optional\n        certificate=certificate,\n        port=123,\n        protocol=elbv2.ApplicationProtocol.HTTP,\n        ssl_policy=elbv2.SslPolicy.RECOMMENDED_TLS\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'certificate', 'port', 'protocol', 'ssl_policy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ApplicationListenerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedEc2ServiceProps
class ApplicationLoadBalancedEc2ServicePropsDef(BaseStruct):
    capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs.CapacityProviderStrategyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of Capacity Provider strategies used to place a service. Default: - undefined\n')
    certificate: typing.Optional[typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef]] = pydantic.Field(None, description="Certificate Manager certificate to associate with the load balancer. Setting this option will set the load balancer protocol to HTTPS. Default: - No certificate associated with the load balancer, if using the HTTP protocol. For HTTPS, a DNS-validated certificate will be created for the load balancer's specified domain name if a domain name and domain zone are specified.\n")
    circuit_breaker: typing.Union[models.aws_ecs.DeploymentCircuitBreakerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly enabled. Default: - disabled\n')
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    deployment_controller: typing.Union[models.aws_ecs.DeploymentControllerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies which deployment controller to use for the service. For more information, see `Amazon ECS Deployment Types <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html>`_ Default: - Rolling update (ECS)\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. The minimum value is 1 Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='The domain name for the service, e.g. "api.example.com.". Default: - No domain name.\n')
    domain_zone: typing.Optional[typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef]] = pydantic.Field(None, description='The Route53 hosted zone for the domain, e.g. "example.com.". Default: - No Route53 hosted domain zone.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    idle_timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The load balancer idle timeout, in seconds. Can be between 1 and 4000 seconds Default: - CloudFormation sets idle timeout to 60 seconds\n')
    listener_port: typing.Union[int, float, None] = pydantic.Field(None, description='Listener port of the application load balancer that will serve traffic to the service. Default: - The default listener port is determined from the protocol (port 80 for HTTP, port 443 for HTTPS). A domain name and zone must be also be specified if using HTTPS.\n')
    load_balancer: typing.Optional[typing.Union[models.aws_elasticloadbalancingv2.ApplicationLoadBalancerDef]] = pydantic.Field(None, description='The application load balancer that will serve traffic to the service. The VPC attribute of a load balancer must be specified for it to be used to create a new service with this pattern. [disable-awslint:ref-via-interface] Default: - a new load balancer will be created.\n')
    load_balancer_name: typing.Optional[str] = pydantic.Field(None, description='Name of the load balancer. Default: - Automatically generated name.\n')
    max_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The maximum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that can run in a service during a deployment. Default: - 100 if daemon, otherwise 200\n")
    min_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The minimum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that must continue to run and remain healthy during a deployment. Default: - 0 if daemon, otherwise 50\n")
    open_listener: typing.Optional[bool] = pydantic.Field(None, description="Determines whether or not the Security Group for the Load Balancer's Listener will be open to all traffic by default. Default: true -- The security group allows ingress from all IP addresses.\n")
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    protocol: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.ApplicationProtocol] = pydantic.Field(None, description='The protocol for connections from clients to the load balancer. The load balancer port is determined from the protocol (port 80 for HTTP, port 443 for HTTPS). If HTTPS, either a certificate or domain name and domain zone must also be specified. Default: HTTP. If a certificate is specified, the protocol will be set by default to HTTPS.\n')
    protocol_version: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.ApplicationProtocolVersion] = pydantic.Field(None, description='The protocol version to use. Default: ApplicationProtocolVersion.HTTP1\n')
    public_load_balancer: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the Load Balancer will be internet-facing. Default: true\n')
    record_type: typing.Optional[aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedServiceRecordType] = pydantic.Field(None, description='Specifies whether the Route53 record should be a CNAME, an A record using the Alias feature or no record at all. This is useful if you need to work with DNS systems that do not support alias records. Default: ApplicationLoadBalancedServiceRecordType.ALIAS\n')
    redirect_http: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether the load balancer should redirect traffic on port 80 to port 443 to support HTTP->HTTPS redirects This is only valid if the protocol of the ALB is HTTPS. Default: false\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    ssl_policy: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.SslPolicy] = pydantic.Field(None, description='The security policy that defines which ciphers and protocols are supported by the ALB Listener. Default: - The recommended elastic load balancing security policy\n')
    target_protocol: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.ApplicationProtocol] = pydantic.Field(None, description='The protocol for connections from the load balancer to the ECS tasks. The default target port is determined from the protocol (port 80 for HTTP, port 443 for HTTPS). Default: HTTP.\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.ApplicationLoadBalancedTaskImageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. TaskDefinition or TaskImageOptions must be specified, but not both. Default: none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n')
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments This default is set in the underlying FargateTaskDefinition construct. Default: none\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The hard limit (in MiB) of memory to present to the container. If your container attempts to exceed the allocated memory, the container is terminated. At least one of memoryLimitMiB and memoryReservationMiB is required. Default: - No memory limit.\n')
    memory_reservation_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The soft limit (in MiB) of memory to reserve for the container. When system memory is under contention, Docker attempts to keep the container memory within the limit. If the container requires more memory, it can consume up to the value specified by the Memory property or all of the available memory on the container instance—whichever comes first. At least one of memoryLimitMiB and memoryReservationMiB is required. Default: - No memory reserved.\n')
    placement_constraints: typing.Optional[typing.Sequence[models.aws_ecs.PlacementConstraintDef]] = pydantic.Field(None, description='The placement constraints to use for tasks in the service. For more information, see `Amazon ECS Task Placement Constraints <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-constraints.html>`_. Default: - No constraints.\n')
    placement_strategies: typing.Optional[typing.Sequence[models.aws_ecs.PlacementStrategyDef]] = pydantic.Field(None, description='The placement strategies to use for tasks in the service. For more information, see `Amazon ECS Task Placement Strategies <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-strategies.html>`_. Default: - No strategies.\n')
    task_definition: typing.Optional[models.aws_ecs.Ec2TaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. TaskDefinition or TaskImageOptions must be specified, but not both.. [disable-awslint:ref-via-interface] Default: - none\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: ecs.Cluster\n\n    load_balanced_ecs_service = ecs_patterns.ApplicationLoadBalancedEc2Service(self, "Service",\n        cluster=cluster,\n        memory_limit_mi_b=1024,\n        task_image_options=ecsPatterns.ApplicationLoadBalancedTaskImageOptions(\n            image=ecs.ContainerImage.from_registry("test"),\n            environment={\n                "TEST_ENVIRONMENT_VARIABLE1": "test environment variable 1 value",\n                "TEST_ENVIRONMENT_VARIABLE2": "test environment variable 2 value"\n            },\n            command=["command"],\n            entry_point=["entry", "point"]\n        ),\n        desired_count=2\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['capacity_provider_strategies', 'certificate', 'circuit_breaker', 'cloud_map_options', 'cluster', 'deployment_controller', 'desired_count', 'domain_name', 'domain_zone', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'idle_timeout', 'listener_port', 'load_balancer', 'load_balancer_name', 'max_healthy_percent', 'min_healthy_percent', 'open_listener', 'propagate_tags', 'protocol', 'protocol_version', 'public_load_balancer', 'record_type', 'redirect_http', 'service_name', 'ssl_policy', 'target_protocol', 'task_image_options', 'vpc', 'cpu', 'memory_limit_mib', 'memory_reservation_mib', 'placement_constraints', 'placement_strategies', 'task_definition']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedEc2ServiceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedFargateServiceProps
class ApplicationLoadBalancedFargateServicePropsDef(BaseStruct):
    capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs.CapacityProviderStrategyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of Capacity Provider strategies used to place a service. Default: - undefined\n')
    certificate: typing.Optional[typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef]] = pydantic.Field(None, description="Certificate Manager certificate to associate with the load balancer. Setting this option will set the load balancer protocol to HTTPS. Default: - No certificate associated with the load balancer, if using the HTTP protocol. For HTTPS, a DNS-validated certificate will be created for the load balancer's specified domain name if a domain name and domain zone are specified.\n")
    circuit_breaker: typing.Union[models.aws_ecs.DeploymentCircuitBreakerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly enabled. Default: - disabled\n')
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    deployment_controller: typing.Union[models.aws_ecs.DeploymentControllerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies which deployment controller to use for the service. For more information, see `Amazon ECS Deployment Types <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html>`_ Default: - Rolling update (ECS)\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. The minimum value is 1 Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='The domain name for the service, e.g. "api.example.com.". Default: - No domain name.\n')
    domain_zone: typing.Optional[typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef]] = pydantic.Field(None, description='The Route53 hosted zone for the domain, e.g. "example.com.". Default: - No Route53 hosted domain zone.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    idle_timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The load balancer idle timeout, in seconds. Can be between 1 and 4000 seconds Default: - CloudFormation sets idle timeout to 60 seconds\n')
    listener_port: typing.Union[int, float, None] = pydantic.Field(None, description='Listener port of the application load balancer that will serve traffic to the service. Default: - The default listener port is determined from the protocol (port 80 for HTTP, port 443 for HTTPS). A domain name and zone must be also be specified if using HTTPS.\n')
    load_balancer: typing.Optional[typing.Union[models.aws_elasticloadbalancingv2.ApplicationLoadBalancerDef]] = pydantic.Field(None, description='The application load balancer that will serve traffic to the service. The VPC attribute of a load balancer must be specified for it to be used to create a new service with this pattern. [disable-awslint:ref-via-interface] Default: - a new load balancer will be created.\n')
    load_balancer_name: typing.Optional[str] = pydantic.Field(None, description='Name of the load balancer. Default: - Automatically generated name.\n')
    max_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The maximum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that can run in a service during a deployment. Default: - 100 if daemon, otherwise 200\n")
    min_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The minimum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that must continue to run and remain healthy during a deployment. Default: - 0 if daemon, otherwise 50\n")
    open_listener: typing.Optional[bool] = pydantic.Field(None, description="Determines whether or not the Security Group for the Load Balancer's Listener will be open to all traffic by default. Default: true -- The security group allows ingress from all IP addresses.\n")
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    protocol: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.ApplicationProtocol] = pydantic.Field(None, description='The protocol for connections from clients to the load balancer. The load balancer port is determined from the protocol (port 80 for HTTP, port 443 for HTTPS). If HTTPS, either a certificate or domain name and domain zone must also be specified. Default: HTTP. If a certificate is specified, the protocol will be set by default to HTTPS.\n')
    protocol_version: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.ApplicationProtocolVersion] = pydantic.Field(None, description='The protocol version to use. Default: ApplicationProtocolVersion.HTTP1\n')
    public_load_balancer: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the Load Balancer will be internet-facing. Default: true\n')
    record_type: typing.Optional[aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedServiceRecordType] = pydantic.Field(None, description='Specifies whether the Route53 record should be a CNAME, an A record using the Alias feature or no record at all. This is useful if you need to work with DNS systems that do not support alias records. Default: ApplicationLoadBalancedServiceRecordType.ALIAS\n')
    redirect_http: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether the load balancer should redirect traffic on port 80 to port 443 to support HTTP->HTTPS redirects This is only valid if the protocol of the ALB is HTTPS. Default: false\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    ssl_policy: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.SslPolicy] = pydantic.Field(None, description='The security policy that defines which ciphers and protocols are supported by the ALB Listener. Default: - The recommended elastic load balancing security policy\n')
    target_protocol: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.ApplicationProtocol] = pydantic.Field(None, description='The protocol for connections from the load balancer to the ECS tasks. The default target port is determined from the protocol (port 80 for HTTP, port 443 for HTTPS). Default: HTTP.\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.ApplicationLoadBalancedTaskImageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. TaskDefinition or TaskImageOptions must be specified, but not both. Default: none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n')
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments 8192 (8 vCPU) - Available memory values: Between 16GB and 60GB in 4GB increments 16384 (16 vCPU) - Available memory values: Between 32GB and 120GB in 8GB increments This default is set in the underlying FargateTaskDefinition construct. Default: 256\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The amount (in MiB) of memory used by the task. This field is required and you must use one of the following values, which determines your range of valid values for the cpu parameter: 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB) - Available cpu values: 256 (.25 vCPU) 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB) - Available cpu values: 512 (.5 vCPU) 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB) - Available cpu values: 1024 (1 vCPU) Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB) - Available cpu values: 2048 (2 vCPU) Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB) - Available cpu values: 4096 (4 vCPU) Between 16384 (16 GB) and 61440 (60 GB) in increments of 4096 (4 GB) - Available cpu values: 8192 (8 vCPU) Between 32768 (32 GB) and 122880 (120 GB) in increments of 8192 (8 GB) - Available cpu values: 16384 (16 vCPU) This default is set in the underlying FargateTaskDefinition construct. Default: 512\n')
    platform_version: typing.Optional[aws_cdk.aws_ecs.FargatePlatformVersion] = pydantic.Field(None, description='The platform version on which to run your service. If one is not specified, the LATEST platform version is used by default. For more information, see `AWS Fargate Platform Versions <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html>`_ in the Amazon Elastic Container Service Developer Guide. Default: Latest\n')
    runtime_platform: typing.Union[models.aws_ecs.RuntimePlatformDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The runtime platform of the task definition. Default: - If the property is undefined, ``operatingSystemFamily`` is LINUX and ``cpuArchitecture`` is X86_64\n')
    task_definition: typing.Optional[models.aws_ecs.FargateTaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. TaskDefinition or TaskImageOptions must be specified, but not both. [disable-awslint:ref-via-interface] Default: - none\n')
    assign_public_ip: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the service will be assigned a public IP address. Default: false\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='The security groups to associate with the service. If you do not specify a security group, a new security group is created. Default: - A new security group is created.\n')
    task_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The subnets to associate with the service. Default: - Public subnets if ``assignPublicIp`` is set, otherwise the first available one of Private, Isolated, Public, in that order.\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: ecs.Cluster\n\n    load_balanced_fargate_service = ecs_patterns.ApplicationLoadBalancedFargateService(self, "Service",\n        cluster=cluster,\n        memory_limit_mi_b=1024,\n        desired_count=1,\n        cpu=512,\n        task_image_options=ecsPatterns.ApplicationLoadBalancedTaskImageOptions(\n            image=ecs.ContainerImage.from_registry("amazon/amazon-ecs-sample")\n        ),\n        task_subnets=ec2.SubnetSelection(\n            subnets=[ec2.Subnet.from_subnet_id(self, "subnet", "VpcISOLATEDSubnet1Subnet80F07FA0")]\n        ),\n        load_balancer_name="application-lb-name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['capacity_provider_strategies', 'certificate', 'circuit_breaker', 'cloud_map_options', 'cluster', 'deployment_controller', 'desired_count', 'domain_name', 'domain_zone', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'idle_timeout', 'listener_port', 'load_balancer', 'load_balancer_name', 'max_healthy_percent', 'min_healthy_percent', 'open_listener', 'propagate_tags', 'protocol', 'protocol_version', 'public_load_balancer', 'record_type', 'redirect_http', 'service_name', 'ssl_policy', 'target_protocol', 'task_image_options', 'vpc', 'cpu', 'memory_limit_mib', 'platform_version', 'runtime_platform', 'task_definition', 'assign_public_ip', 'security_groups', 'task_subnets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedFargateServiceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedServiceBaseProps
class ApplicationLoadBalancedServiceBasePropsDef(BaseStruct):
    capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs.CapacityProviderStrategyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of Capacity Provider strategies used to place a service. Default: - undefined\n')
    certificate: typing.Optional[typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef]] = pydantic.Field(None, description="Certificate Manager certificate to associate with the load balancer. Setting this option will set the load balancer protocol to HTTPS. Default: - No certificate associated with the load balancer, if using the HTTP protocol. For HTTPS, a DNS-validated certificate will be created for the load balancer's specified domain name if a domain name and domain zone are specified.\n")
    circuit_breaker: typing.Union[models.aws_ecs.DeploymentCircuitBreakerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly enabled. Default: - disabled\n')
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    deployment_controller: typing.Union[models.aws_ecs.DeploymentControllerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies which deployment controller to use for the service. For more information, see `Amazon ECS Deployment Types <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html>`_ Default: - Rolling update (ECS)\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. The minimum value is 1 Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='The domain name for the service, e.g. "api.example.com.". Default: - No domain name.\n')
    domain_zone: typing.Optional[typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef]] = pydantic.Field(None, description='The Route53 hosted zone for the domain, e.g. "example.com.". Default: - No Route53 hosted domain zone.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    idle_timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The load balancer idle timeout, in seconds. Can be between 1 and 4000 seconds Default: - CloudFormation sets idle timeout to 60 seconds\n')
    listener_port: typing.Union[int, float, None] = pydantic.Field(None, description='Listener port of the application load balancer that will serve traffic to the service. Default: - The default listener port is determined from the protocol (port 80 for HTTP, port 443 for HTTPS). A domain name and zone must be also be specified if using HTTPS.\n')
    load_balancer: typing.Optional[typing.Union[models.aws_elasticloadbalancingv2.ApplicationLoadBalancerDef]] = pydantic.Field(None, description='The application load balancer that will serve traffic to the service. The VPC attribute of a load balancer must be specified for it to be used to create a new service with this pattern. [disable-awslint:ref-via-interface] Default: - a new load balancer will be created.\n')
    load_balancer_name: typing.Optional[str] = pydantic.Field(None, description='Name of the load balancer. Default: - Automatically generated name.\n')
    max_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The maximum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that can run in a service during a deployment. Default: - 100 if daemon, otherwise 200\n")
    min_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The minimum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that must continue to run and remain healthy during a deployment. Default: - 0 if daemon, otherwise 50\n")
    open_listener: typing.Optional[bool] = pydantic.Field(None, description="Determines whether or not the Security Group for the Load Balancer's Listener will be open to all traffic by default. Default: true -- The security group allows ingress from all IP addresses.\n")
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    protocol: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.ApplicationProtocol] = pydantic.Field(None, description='The protocol for connections from clients to the load balancer. The load balancer port is determined from the protocol (port 80 for HTTP, port 443 for HTTPS). If HTTPS, either a certificate or domain name and domain zone must also be specified. Default: HTTP. If a certificate is specified, the protocol will be set by default to HTTPS.\n')
    protocol_version: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.ApplicationProtocolVersion] = pydantic.Field(None, description='The protocol version to use. Default: ApplicationProtocolVersion.HTTP1\n')
    public_load_balancer: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the Load Balancer will be internet-facing. Default: true\n')
    record_type: typing.Optional[aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedServiceRecordType] = pydantic.Field(None, description='Specifies whether the Route53 record should be a CNAME, an A record using the Alias feature or no record at all. This is useful if you need to work with DNS systems that do not support alias records. Default: ApplicationLoadBalancedServiceRecordType.ALIAS\n')
    redirect_http: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether the load balancer should redirect traffic on port 80 to port 443 to support HTTP->HTTPS redirects This is only valid if the protocol of the ALB is HTTPS. Default: false\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    ssl_policy: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.SslPolicy] = pydantic.Field(None, description='The security policy that defines which ciphers and protocols are supported by the ALB Listener. Default: - The recommended elastic load balancing security policy\n')
    target_protocol: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.ApplicationProtocol] = pydantic.Field(None, description='The protocol for connections from the load balancer to the ECS tasks. The default target port is determined from the protocol (port 80 for HTTP, port 443 for HTTPS). Default: HTTP.\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.ApplicationLoadBalancedTaskImageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. TaskDefinition or TaskImageOptions must be specified, but not both. Default: none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_certificatemanager as certificatemanager\n    from aws_cdk import aws_ec2 as ec2\n    from aws_cdk import aws_ecs as ecs\n    from aws_cdk import aws_ecs_patterns as ecs_patterns\n    from aws_cdk import aws_elasticloadbalancingv2 as elbv2\n    from aws_cdk import aws_iam as iam\n    from aws_cdk import aws_route53 as route53\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    # application_load_balancer: elbv2.ApplicationLoadBalancer\n    # certificate: certificatemanager.Certificate\n    # cluster: ecs.Cluster\n    # container_definition: ecs.ContainerDefinition\n    # container_image: ecs.ContainerImage\n    # hosted_zone: route53.HostedZone\n    # log_driver: ecs.LogDriver\n    # namespace: servicediscovery.INamespace\n    # role: iam.Role\n    # secret: ecs.Secret\n    # vpc: ec2.Vpc\n\n    application_load_balanced_service_base_props = ecs_patterns.ApplicationLoadBalancedServiceBaseProps(\n        capacity_provider_strategies=[ecs.CapacityProviderStrategy(\n            capacity_provider="capacityProvider",\n\n            # the properties below are optional\n            base=123,\n            weight=123\n        )],\n        certificate=certificate,\n        circuit_breaker=ecs.DeploymentCircuitBreaker(\n            rollback=False\n        ),\n        cloud_map_options=ecs.CloudMapOptions(\n            cloud_map_namespace=namespace,\n            container=container_definition,\n            container_port=123,\n            dns_record_type=servicediscovery.DnsRecordType.A,\n            dns_ttl=cdk.Duration.minutes(30),\n            failure_threshold=123,\n            name="name"\n        ),\n        cluster=cluster,\n        deployment_controller=ecs.DeploymentController(\n            type=ecs.DeploymentControllerType.ECS\n        ),\n        desired_count=123,\n        domain_name="domainName",\n        domain_zone=hosted_zone,\n        enable_eCSManaged_tags=False,\n        enable_execute_command=False,\n        health_check_grace_period=cdk.Duration.minutes(30),\n        idle_timeout=cdk.Duration.minutes(30),\n        listener_port=123,\n        load_balancer=application_load_balancer,\n        load_balancer_name="loadBalancerName",\n        max_healthy_percent=123,\n        min_healthy_percent=123,\n        open_listener=False,\n        propagate_tags=ecs.PropagatedTagSource.SERVICE,\n        protocol=elbv2.ApplicationProtocol.HTTP,\n        protocol_version=elbv2.ApplicationProtocolVersion.GRPC,\n        public_load_balancer=False,\n        record_type=ecs_patterns.ApplicationLoadBalancedServiceRecordType.ALIAS,\n        redirect_hTTP=False,\n        service_name="serviceName",\n        ssl_policy=elbv2.SslPolicy.RECOMMENDED_TLS,\n        target_protocol=elbv2.ApplicationProtocol.HTTP,\n        task_image_options=ecs_patterns.ApplicationLoadBalancedTaskImageOptions(\n            image=container_image,\n\n            # the properties below are optional\n            command=["command"],\n            container_name="containerName",\n            container_port=123,\n            docker_labels={\n                "docker_labels_key": "dockerLabels"\n            },\n            enable_logging=False,\n            entry_point=["entryPoint"],\n            environment={\n                "environment_key": "environment"\n            },\n            execution_role=role,\n            family="family",\n            log_driver=log_driver,\n            secrets={\n                "secrets_key": secret\n            },\n            task_role=role\n        ),\n        vpc=vpc\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['capacity_provider_strategies', 'certificate', 'circuit_breaker', 'cloud_map_options', 'cluster', 'deployment_controller', 'desired_count', 'domain_name', 'domain_zone', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'idle_timeout', 'listener_port', 'load_balancer', 'load_balancer_name', 'max_healthy_percent', 'min_healthy_percent', 'open_listener', 'propagate_tags', 'protocol', 'protocol_version', 'public_load_balancer', 'record_type', 'redirect_http', 'service_name', 'ssl_policy', 'target_protocol', 'task_image_options', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedServiceBaseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedTaskImageOptions
class ApplicationLoadBalancedTaskImageOptionsDef(BaseStruct):
    image: typing.Union[models.aws_ecs.ContainerImageDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The image used to start a container. Image or taskDefinition must be specified, not both. Default: - none')
    command: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The command that's passed to the container. If there are multiple arguments, make sure that each argument is a separated string in the array. This parameter maps to ``Cmd`` in the `Create a container <https://docs.docker.com/engine/api/v1.38/#operation/ContainerCreate>`_ section of the `Docker Remote API <https://docs.docker.com/engine/api/v1.38/>`_ and the ``COMMAND`` parameter to `docker run <https://docs.docker.com/engine/reference/commandline/run/>`_. For more information about the Docker ``CMD`` parameter, see https://docs.docker.com/engine/reference/builder/#cmd. Default: none\n")
    container_name: typing.Optional[str] = pydantic.Field(None, description='The container name value to be specified in the task definition. Default: - none\n')
    container_port: typing.Union[int, float, None] = pydantic.Field(None, description='The port number on the container that is bound to the user-specified or automatically assigned host port. If you are using containers in a task with the awsvpc or host network mode, exposed ports should be specified using containerPort. If you are using containers in a task with the bridge network mode and you specify a container port and not a host port, your container automatically receives a host port in the ephemeral port range. Port mappings that are automatically assigned in this way do not count toward the 100 reserved ports limit of a container instance. For more information, see `hostPort <https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PortMapping.html#ECS-Type-PortMapping-hostPort>`_. Default: 80\n')
    docker_labels: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='A key/value map of labels to add to the container. Default: - No labels.\n')
    enable_logging: typing.Optional[bool] = pydantic.Field(None, description='Flag to indicate whether to enable logging. Default: true\n')
    entry_point: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The entry point that's passed to the container. This parameter maps to ``Entrypoint`` in the `Create a container <https://docs.docker.com/engine/api/v1.38/#operation/ContainerCreate>`_ section of the `Docker Remote API <https://docs.docker.com/engine/api/v1.38/>`_ and the ``--entrypoint`` option to `docker run <https://docs.docker.com/engine/reference/commandline/run/>`_. For more information about the Docker ``ENTRYPOINT`` parameter, see https://docs.docker.com/engine/reference/builder/#entrypoint. Default: none\n")
    environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The environment variables to pass to the container. Default: - No environment variables.\n')
    execution_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The name of the task execution IAM role that grants the Amazon ECS container agent permission to call AWS APIs on your behalf. Default: - No value\n')
    family: typing.Optional[str] = pydantic.Field(None, description='The name of a family that this task definition is registered to. A family groups multiple versions of a task definition. Default: - Automatically generated name.\n')
    log_driver: typing.Optional[models.aws_ecs.LogDriverDef] = pydantic.Field(None, description='The log driver to use. Default: - AwsLogDriver if enableLogging is true\n')
    secrets: typing.Optional[typing.Mapping[str, models.aws_ecs.SecretDef]] = pydantic.Field(None, description='The secret to expose to the container as an environment variable. Default: - No secret environment variables.\n')
    task_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The name of the task IAM role that grants containers in the task permission to call AWS APIs on your behalf. Default: - A task role is automatically created for you.\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: ecs.Cluster\n\n    load_balanced_fargate_service = ecs_patterns.ApplicationLoadBalancedFargateService(self, "Service",\n        cluster=cluster,\n        memory_limit_mi_b=1024,\n        desired_count=1,\n        cpu=512,\n        task_image_options=ecsPatterns.ApplicationLoadBalancedTaskImageOptions(\n            image=ecs.ContainerImage.from_registry("amazon/amazon-ecs-sample")\n        ),\n        task_subnets=ec2.SubnetSelection(\n            subnets=[ec2.Subnet.from_subnet_id(self, "subnet", "VpcISOLATEDSubnet1Subnet80F07FA0")]\n        ),\n        load_balancer_name="application-lb-name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['image', 'command', 'container_name', 'container_port', 'docker_labels', 'enable_logging', 'entry_point', 'environment', 'execution_role', 'family', 'log_driver', 'secrets', 'task_role']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedTaskImageOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.ApplicationLoadBalancedTaskImageOptionsDefConfig] = pydantic.Field(None)


class ApplicationLoadBalancedTaskImageOptionsDefConfig(pydantic.BaseModel):
    image_config: typing.Optional[models.aws_ecs.ContainerImageDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedTaskImageProps
class ApplicationLoadBalancedTaskImagePropsDef(BaseStruct):
    image: typing.Union[models.aws_ecs.ContainerImageDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The image used to start a container. Image or taskDefinition must be specified, not both. Default: - none\n')
    container_name: typing.Optional[str] = pydantic.Field(None, description='The container name value to be specified in the task definition. Default: - web\n')
    container_ports: typing.Optional[typing.Sequence[typing.Union[int, float]]] = pydantic.Field(None, description='A list of port numbers on the container that is bound to the user-specified or automatically assigned host port. If you are using containers in a task with the awsvpc or host network mode, exposed ports should be specified using containerPort. If you are using containers in a task with the bridge network mode and you specify a container port and not a host port, your container automatically receives a host port in the ephemeral port range. Port mappings that are automatically assigned in this way do not count toward the 100 reserved ports limit of a container instance. For more information, see `hostPort <https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PortMapping.html#ECS-Type-PortMapping-hostPort>`_. Default: - [80]\n')
    docker_labels: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='A key/value map of labels to add to the container. Default: - No labels.\n')
    enable_logging: typing.Optional[bool] = pydantic.Field(None, description='Flag to indicate whether to enable logging. Default: true\n')
    environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The environment variables to pass to the container. Default: - No environment variables.\n')
    execution_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The name of the task execution IAM role that grants the Amazon ECS container agent permission to call AWS APIs on your behalf. Default: - No value\n')
    family: typing.Optional[str] = pydantic.Field(None, description='The name of a family that this task definition is registered to. A family groups multiple versions of a task definition. Default: - Automatically generated name.\n')
    log_driver: typing.Optional[models.aws_ecs.LogDriverDef] = pydantic.Field(None, description='The log driver to use. Default: - AwsLogDriver if enableLogging is true\n')
    secrets: typing.Optional[typing.Mapping[str, models.aws_ecs.SecretDef]] = pydantic.Field(None, description='The secrets to expose to the container as an environment variable. Default: - No secret environment variables.\n')
    task_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The name of the task IAM role that grants containers in the task permission to call AWS APIs on your behalf. Default: - A task role is automatically created for you.\n\n:exampleMetadata: infused\n\nExample::\n\n    from aws_cdk.aws_certificatemanager import Certificate\n    from aws_cdk.aws_ec2 import InstanceType\n    from aws_cdk.aws_ecs import Cluster, ContainerImage\n    from aws_cdk.aws_elasticloadbalancingv2 import ApplicationProtocol, SslPolicy\n    from aws_cdk.aws_route53 import PublicHostedZone\n\n    vpc = ec2.Vpc(self, "Vpc", max_azs=1)\n    load_balanced_fargate_service = ecs_patterns.ApplicationMultipleTargetGroupsFargateService(self, "myService",\n        cluster=ecs.Cluster(self, "EcsCluster", vpc=vpc),\n        memory_limit_mi_b=256,\n        task_image_options=ecsPatterns.ApplicationLoadBalancedTaskImageProps(\n            image=ecs.ContainerImage.from_registry("amazon/amazon-ecs-sample")\n        ),\n        enable_execute_command=True,\n        load_balancers=[ecsPatterns.ApplicationLoadBalancerProps(\n            name="lb",\n            idle_timeout=Duration.seconds(400),\n            domain_name="api.example.com",\n            domain_zone=PublicHostedZone(self, "HostedZone", zone_name="example.com"),\n            listeners=[ecsPatterns.ApplicationListenerProps(\n                name="listener",\n                protocol=ApplicationProtocol.HTTPS,\n                certificate=Certificate.from_certificate_arn(self, "Cert", "helloworld"),\n                ssl_policy=SslPolicy.TLS12_EXT\n            )\n            ]\n        ), ecsPatterns.ApplicationLoadBalancerProps(\n            name="lb2",\n            idle_timeout=Duration.seconds(120),\n            domain_name="frontend.com",\n            domain_zone=PublicHostedZone(self, "HostedZone", zone_name="frontend.com"),\n            listeners=[ecsPatterns.ApplicationListenerProps(\n                name="listener2",\n                protocol=ApplicationProtocol.HTTPS,\n                certificate=Certificate.from_certificate_arn(self, "Cert2", "helloworld"),\n                ssl_policy=SslPolicy.TLS12_EXT\n            )\n            ]\n        )\n        ],\n        target_groups=[ecsPatterns.ApplicationTargetProps(\n            container_port=80,\n            listener="listener"\n        ), ecsPatterns.ApplicationTargetProps(\n            container_port=90,\n            path_pattern="a/b/c",\n            priority=10,\n            listener="listener"\n        ), ecsPatterns.ApplicationTargetProps(\n            container_port=443,\n            listener="listener2"\n        ), ecsPatterns.ApplicationTargetProps(\n            container_port=80,\n            path_pattern="a/b/c",\n            priority=10,\n            listener="listener2"\n        )\n        ]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['image', 'container_name', 'container_ports', 'docker_labels', 'enable_logging', 'environment', 'execution_role', 'family', 'log_driver', 'secrets', 'task_role']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedTaskImageProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.ApplicationLoadBalancedTaskImagePropsDefConfig] = pydantic.Field(None)


class ApplicationLoadBalancedTaskImagePropsDefConfig(pydantic.BaseModel):
    image_config: typing.Optional[models.aws_ecs.ContainerImageDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.ApplicationLoadBalancerProps
class ApplicationLoadBalancerPropsDef(BaseStruct):
    listeners: typing.Union[typing.Sequence[typing.Union[models.aws_ecs_patterns.ApplicationListenerPropsDef, dict[str, typing.Any]]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Listeners (at least one listener) attached to this load balancer.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Name of the load balancer.\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='The domain name for the service, e.g. "api.example.com.". Default: - No domain name.\n')
    domain_zone: typing.Optional[typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef]] = pydantic.Field(None, description='The Route53 hosted zone for the domain, e.g. "example.com.". Default: - No Route53 hosted domain zone.\n')
    idle_timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The load balancer idle timeout, in seconds. Can be between 1 and 4000 seconds. Default: - CloudFormation sets idle timeout to 60 seconds\n')
    public_load_balancer: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the Load Balancer will be internet-facing. Default: true\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_certificatemanager as certificatemanager\n    from aws_cdk import aws_ecs_patterns as ecs_patterns\n    from aws_cdk import aws_elasticloadbalancingv2 as elbv2\n    from aws_cdk import aws_route53 as route53\n\n    # certificate: certificatemanager.Certificate\n    # hosted_zone: route53.HostedZone\n\n    application_load_balancer_props = ecs_patterns.ApplicationLoadBalancerProps(\n        listeners=[ecs_patterns.ApplicationListenerProps(\n            name="name",\n\n            # the properties below are optional\n            certificate=certificate,\n            port=123,\n            protocol=elbv2.ApplicationProtocol.HTTP,\n            ssl_policy=elbv2.SslPolicy.RECOMMENDED_TLS\n        )],\n        name="name",\n\n        # the properties below are optional\n        domain_name="domainName",\n        domain_zone=hosted_zone,\n        idle_timeout=cdk.Duration.minutes(30),\n        public_load_balancer=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['listeners', 'name', 'domain_name', 'domain_zone', 'idle_timeout', 'public_load_balancer']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ApplicationLoadBalancerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecs_patterns.ApplicationMultipleTargetGroupsEc2ServiceProps
class ApplicationMultipleTargetGroupsEc2ServicePropsDef(BaseStruct):
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    load_balancers: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.ApplicationLoadBalancerPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The application load balancer that will serve traffic to the service. Default: - a new load balancer with a listener will be created.\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    target_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.ApplicationTargetPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Properties to specify ALB target groups. Default: - default portMapping registered as target group and attached to the first defined listener\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.ApplicationLoadBalancedTaskImagePropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. Only one of TaskDefinition or TaskImageOptions must be specified. Default: none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n')
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of CPU units to reserve for the container. Valid values, which determines your range of valid values for the memory parameter: Default: - No minimum CPU units reserved.\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The amount (in MiB) of memory to present to the container. If your container attempts to exceed the allocated memory, the container is terminated. At least one of memoryLimitMiB and memoryReservationMiB is required. Default: - No memory limit.\n')
    memory_reservation_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The soft limit (in MiB) of memory to reserve for the container. When system memory is under heavy contention, Docker attempts to keep the container memory to this soft limit. However, your container can consume more memory when it needs to, up to either the hard limit specified with the memory parameter (if applicable), or all of the available memory on the container instance, whichever comes first. At least one of memoryLimitMiB and memoryReservationMiB is required. Note that this setting will be ignored if TaskImagesOptions is specified Default: - No memory reserved.\n')
    placement_constraints: typing.Optional[typing.Sequence[models.aws_ecs.PlacementConstraintDef]] = pydantic.Field(None, description='The placement constraints to use for tasks in the service. For more information, see `Amazon ECS Task Placement Constraints <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-constraints.html>`_. Default: - No constraints.\n')
    placement_strategies: typing.Optional[typing.Sequence[models.aws_ecs.PlacementStrategyDef]] = pydantic.Field(None, description='The placement strategies to use for tasks in the service. For more information, see `Amazon ECS Task Placement Strategies <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-strategies.html>`_. Default: - No strategies.\n')
    task_definition: typing.Optional[models.aws_ecs.Ec2TaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. Only one of TaskDefinition or TaskImageOptions must be specified. [disable-awslint:ref-via-interface] Default: - none\n\n:exampleMetadata: infused\n\nExample::\n\n    # One application load balancer with one listener and two target groups.\n    # cluster: ecs.Cluster\n\n    load_balanced_ec2_service = ecs_patterns.ApplicationMultipleTargetGroupsEc2Service(self, "Service",\n        cluster=cluster,\n        memory_limit_mi_b=256,\n        task_image_options=ecsPatterns.ApplicationLoadBalancedTaskImageProps(\n            image=ecs.ContainerImage.from_registry("amazon/amazon-ecs-sample")\n        ),\n        target_groups=[ecsPatterns.ApplicationTargetProps(\n            container_port=80\n        ), ecsPatterns.ApplicationTargetProps(\n            container_port=90,\n            path_pattern="a/b/c",\n            priority=10\n        )\n        ]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cloud_map_options', 'cluster', 'desired_count', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'load_balancers', 'propagate_tags', 'service_name', 'target_groups', 'task_image_options', 'vpc', 'cpu', 'memory_limit_mib', 'memory_reservation_mib', 'placement_constraints', 'placement_strategies', 'task_definition']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ApplicationMultipleTargetGroupsEc2ServiceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecs_patterns.ApplicationMultipleTargetGroupsFargateServiceProps
class ApplicationMultipleTargetGroupsFargateServicePropsDef(BaseStruct):
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    load_balancers: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.ApplicationLoadBalancerPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The application load balancer that will serve traffic to the service. Default: - a new load balancer with a listener will be created.\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    target_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.ApplicationTargetPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Properties to specify ALB target groups. Default: - default portMapping registered as target group and attached to the first defined listener\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.ApplicationLoadBalancedTaskImagePropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. Only one of TaskDefinition or TaskImageOptions must be specified. Default: none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n')
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments 8192 (8 vCPU) - Available memory values: Between 16GB and 60GB in 4GB increments 16384 (16 vCPU) - Available memory values: Between 32GB and 120GB in 8GB increments This default is set in the underlying FargateTaskDefinition construct. Default: 256\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The amount (in MiB) of memory used by the task. This field is required and you must use one of the following values, which determines your range of valid values for the cpu parameter: 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB) - Available cpu values: 256 (.25 vCPU) 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB) - Available cpu values: 512 (.5 vCPU) 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB) - Available cpu values: 1024 (1 vCPU) Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB) - Available cpu values: 2048 (2 vCPU) Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB) - Available cpu values: 4096 (4 vCPU) Between 16384 (16 GB) and 61440 (60 GB) in increments of 4096 (4 GB) - Available cpu values: 8192 (8 vCPU) Between 32768 (32 GB) and 122880 (120 GB) in increments of 8192 (8 GB) - Available cpu values: 16384 (16 vCPU) This default is set in the underlying FargateTaskDefinition construct. Default: 512\n')
    platform_version: typing.Optional[aws_cdk.aws_ecs.FargatePlatformVersion] = pydantic.Field(None, description='The platform version on which to run your service. If one is not specified, the LATEST platform version is used by default. For more information, see `AWS Fargate Platform Versions <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html>`_ in the Amazon Elastic Container Service Developer Guide. Default: Latest\n')
    runtime_platform: typing.Union[models.aws_ecs.RuntimePlatformDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The runtime platform of the task definition. Default: - If the property is undefined, ``operatingSystemFamily`` is LINUX and ``cpuArchitecture`` is X86_64\n')
    task_definition: typing.Optional[models.aws_ecs.FargateTaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. TaskDefinition or TaskImageOptions must be specified, but not both. [disable-awslint:ref-via-interface] Default: - none\n')
    assign_public_ip: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the service will be assigned a public IP address. Default: false\n\n:exampleMetadata: infused\n\nExample::\n\n    from aws_cdk.aws_certificatemanager import Certificate\n    from aws_cdk.aws_ec2 import InstanceType\n    from aws_cdk.aws_ecs import Cluster, ContainerImage\n    from aws_cdk.aws_elasticloadbalancingv2 import ApplicationProtocol, SslPolicy\n    from aws_cdk.aws_route53 import PublicHostedZone\n\n    vpc = ec2.Vpc(self, "Vpc", max_azs=1)\n    load_balanced_fargate_service = ecs_patterns.ApplicationMultipleTargetGroupsFargateService(self, "myService",\n        cluster=ecs.Cluster(self, "EcsCluster", vpc=vpc),\n        memory_limit_mi_b=256,\n        task_image_options=ecsPatterns.ApplicationLoadBalancedTaskImageProps(\n            image=ecs.ContainerImage.from_registry("amazon/amazon-ecs-sample")\n        ),\n        enable_execute_command=True,\n        load_balancers=[ecsPatterns.ApplicationLoadBalancerProps(\n            name="lb",\n            idle_timeout=Duration.seconds(400),\n            domain_name="api.example.com",\n            domain_zone=PublicHostedZone(self, "HostedZone", zone_name="example.com"),\n            listeners=[ecsPatterns.ApplicationListenerProps(\n                name="listener",\n                protocol=ApplicationProtocol.HTTPS,\n                certificate=Certificate.from_certificate_arn(self, "Cert", "helloworld"),\n                ssl_policy=SslPolicy.TLS12_EXT\n            )\n            ]\n        ), ecsPatterns.ApplicationLoadBalancerProps(\n            name="lb2",\n            idle_timeout=Duration.seconds(120),\n            domain_name="frontend.com",\n            domain_zone=PublicHostedZone(self, "HostedZone", zone_name="frontend.com"),\n            listeners=[ecsPatterns.ApplicationListenerProps(\n                name="listener2",\n                protocol=ApplicationProtocol.HTTPS,\n                certificate=Certificate.from_certificate_arn(self, "Cert2", "helloworld"),\n                ssl_policy=SslPolicy.TLS12_EXT\n            )\n            ]\n        )\n        ],\n        target_groups=[ecsPatterns.ApplicationTargetProps(\n            container_port=80,\n            listener="listener"\n        ), ecsPatterns.ApplicationTargetProps(\n            container_port=90,\n            path_pattern="a/b/c",\n            priority=10,\n            listener="listener"\n        ), ecsPatterns.ApplicationTargetProps(\n            container_port=443,\n            listener="listener2"\n        ), ecsPatterns.ApplicationTargetProps(\n            container_port=80,\n            path_pattern="a/b/c",\n            priority=10,\n            listener="listener2"\n        )\n        ]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cloud_map_options', 'cluster', 'desired_count', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'load_balancers', 'propagate_tags', 'service_name', 'target_groups', 'task_image_options', 'vpc', 'cpu', 'memory_limit_mib', 'platform_version', 'runtime_platform', 'task_definition', 'assign_public_ip']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ApplicationMultipleTargetGroupsFargateServiceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecs_patterns.ApplicationMultipleTargetGroupsServiceBaseProps
class ApplicationMultipleTargetGroupsServiceBasePropsDef(BaseStruct):
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    load_balancers: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.ApplicationLoadBalancerPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The application load balancer that will serve traffic to the service. Default: - a new load balancer with a listener will be created.\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    target_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.ApplicationTargetPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Properties to specify ALB target groups. Default: - default portMapping registered as target group and attached to the first defined listener\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.ApplicationLoadBalancedTaskImagePropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. Only one of TaskDefinition or TaskImageOptions must be specified. Default: none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_certificatemanager as certificatemanager\n    from aws_cdk import aws_ec2 as ec2\n    from aws_cdk import aws_ecs as ecs\n    from aws_cdk import aws_ecs_patterns as ecs_patterns\n    from aws_cdk import aws_elasticloadbalancingv2 as elbv2\n    from aws_cdk import aws_iam as iam\n    from aws_cdk import aws_route53 as route53\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    # certificate: certificatemanager.Certificate\n    # cluster: ecs.Cluster\n    # container_definition: ecs.ContainerDefinition\n    # container_image: ecs.ContainerImage\n    # hosted_zone: route53.HostedZone\n    # log_driver: ecs.LogDriver\n    # namespace: servicediscovery.INamespace\n    # role: iam.Role\n    # secret: ecs.Secret\n    # vpc: ec2.Vpc\n\n    application_multiple_target_groups_service_base_props = ecs_patterns.ApplicationMultipleTargetGroupsServiceBaseProps(\n        cloud_map_options=ecs.CloudMapOptions(\n            cloud_map_namespace=namespace,\n            container=container_definition,\n            container_port=123,\n            dns_record_type=servicediscovery.DnsRecordType.A,\n            dns_ttl=cdk.Duration.minutes(30),\n            failure_threshold=123,\n            name="name"\n        ),\n        cluster=cluster,\n        desired_count=123,\n        enable_eCSManaged_tags=False,\n        enable_execute_command=False,\n        health_check_grace_period=cdk.Duration.minutes(30),\n        load_balancers=[ecs_patterns.ApplicationLoadBalancerProps(\n            listeners=[ecs_patterns.ApplicationListenerProps(\n                name="name",\n\n                # the properties below are optional\n                certificate=certificate,\n                port=123,\n                protocol=elbv2.ApplicationProtocol.HTTP,\n                ssl_policy=elbv2.SslPolicy.RECOMMENDED_TLS\n            )],\n            name="name",\n\n            # the properties below are optional\n            domain_name="domainName",\n            domain_zone=hosted_zone,\n            idle_timeout=cdk.Duration.minutes(30),\n            public_load_balancer=False\n        )],\n        propagate_tags=ecs.PropagatedTagSource.SERVICE,\n        service_name="serviceName",\n        target_groups=[ecs_patterns.ApplicationTargetProps(\n            container_port=123,\n\n            # the properties below are optional\n            host_header="hostHeader",\n            listener="listener",\n            path_pattern="pathPattern",\n            priority=123,\n            protocol=ecs.Protocol.TCP\n        )],\n        task_image_options=ecs_patterns.ApplicationLoadBalancedTaskImageProps(\n            image=container_image,\n\n            # the properties below are optional\n            container_name="containerName",\n            container_ports=[123],\n            docker_labels={\n                "docker_labels_key": "dockerLabels"\n            },\n            enable_logging=False,\n            environment={\n                "environment_key": "environment"\n            },\n            execution_role=role,\n            family="family",\n            log_driver=log_driver,\n            secrets={\n                "secrets_key": secret\n            },\n            task_role=role\n        ),\n        vpc=vpc\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cloud_map_options', 'cluster', 'desired_count', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'load_balancers', 'propagate_tags', 'service_name', 'target_groups', 'task_image_options', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ApplicationMultipleTargetGroupsServiceBaseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecs_patterns.ApplicationTargetProps
class ApplicationTargetPropsDef(BaseStruct):
    container_port: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The port number of the container. Only applicable when using application/network load balancers.\n')
    host_header: typing.Optional[str] = pydantic.Field(None, description="Rule applies if the requested host matches the indicated host. May contain up to three '*' wildcards. Requires that priority is set. Default: No host condition\n")
    listener: typing.Optional[str] = pydantic.Field(None, description='Name of the listener the target group attached to. Default: - default listener (first added listener)\n')
    path_pattern: typing.Optional[str] = pydantic.Field(None, description="Rule applies if the requested path matches the given path pattern. May contain up to three '*' wildcards. Requires that priority is set. Default: No path condition\n")
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='Priority of this target group. The rule with the lowest priority will be used for every request. If priority is not given, these target groups will be added as defaults, and must not have conditions. Priorities must be unique. Default: Target groups are used as defaults\n')
    protocol: typing.Optional[aws_cdk.aws_ecs.Protocol] = pydantic.Field(None, description='The protocol used for the port mapping. Only applicable when using application load balancers. Default: ecs.Protocol.TCP\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ecs as ecs\n    from aws_cdk import aws_ecs_patterns as ecs_patterns\n\n    application_target_props = ecs_patterns.ApplicationTargetProps(\n        container_port=123,\n\n        # the properties below are optional\n        host_header="hostHeader",\n        listener="listener",\n        path_pattern="pathPattern",\n        priority=123,\n        protocol=ecs.Protocol.TCP\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['container_port', 'host_header', 'listener', 'path_pattern', 'priority', 'protocol']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ApplicationTargetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecs_patterns.FargateServiceBaseProps
class FargateServiceBasePropsDef(BaseStruct):
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments 8192 (8 vCPU) - Available memory values: Between 16GB and 60GB in 4GB increments 16384 (16 vCPU) - Available memory values: Between 32GB and 120GB in 8GB increments This default is set in the underlying FargateTaskDefinition construct. Default: 256')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The amount (in MiB) of memory used by the task. This field is required and you must use one of the following values, which determines your range of valid values for the cpu parameter: 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB) - Available cpu values: 256 (.25 vCPU) 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB) - Available cpu values: 512 (.5 vCPU) 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB) - Available cpu values: 1024 (1 vCPU) Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB) - Available cpu values: 2048 (2 vCPU) Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB) - Available cpu values: 4096 (4 vCPU) Between 16384 (16 GB) and 61440 (60 GB) in increments of 4096 (4 GB) - Available cpu values: 8192 (8 vCPU) Between 32768 (32 GB) and 122880 (120 GB) in increments of 8192 (8 GB) - Available cpu values: 16384 (16 vCPU) This default is set in the underlying FargateTaskDefinition construct. Default: 512\n')
    platform_version: typing.Optional[aws_cdk.aws_ecs.FargatePlatformVersion] = pydantic.Field(None, description='The platform version on which to run your service. If one is not specified, the LATEST platform version is used by default. For more information, see `AWS Fargate Platform Versions <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html>`_ in the Amazon Elastic Container Service Developer Guide. Default: Latest\n')
    runtime_platform: typing.Union[models.aws_ecs.RuntimePlatformDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The runtime platform of the task definition. Default: - If the property is undefined, ``operatingSystemFamily`` is LINUX and ``cpuArchitecture`` is X86_64\n')
    task_definition: typing.Optional[models.aws_ecs.FargateTaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. TaskDefinition or TaskImageOptions must be specified, but not both. [disable-awslint:ref-via-interface] Default: - none\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ecs as ecs\n    from aws_cdk import aws_ecs_patterns as ecs_patterns\n\n    # cpu_architecture: ecs.CpuArchitecture\n    # fargate_task_definition: ecs.FargateTaskDefinition\n    # operating_system_family: ecs.OperatingSystemFamily\n\n    fargate_service_base_props = ecs_patterns.FargateServiceBaseProps(\n        cpu=123,\n        memory_limit_mi_b=123,\n        platform_version=ecs.FargatePlatformVersion.LATEST,\n        runtime_platform=ecs.RuntimePlatform(\n            cpu_architecture=cpu_architecture,\n            operating_system_family=operating_system_family\n        ),\n        task_definition=fargate_task_definition\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cpu', 'memory_limit_mib', 'platform_version', 'runtime_platform', 'task_definition']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.FargateServiceBaseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecs_patterns.NetworkListenerProps
class NetworkListenerPropsDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Name of the listener.\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The port on which the listener listens for requests. Default: 80\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ecs_patterns as ecs_patterns\n\n    network_listener_props = ecs_patterns.NetworkListenerProps(\n        name="name",\n\n        # the properties below are optional\n        port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.NetworkListenerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecs_patterns.NetworkLoadBalancedEc2ServiceProps
class NetworkLoadBalancedEc2ServicePropsDef(BaseStruct):
    capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs.CapacityProviderStrategyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of Capacity Provider strategies used to place a service. Default: - undefined\n')
    circuit_breaker: typing.Union[models.aws_ecs.DeploymentCircuitBreakerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly enabled. Default: - disabled\n')
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    deployment_controller: typing.Union[models.aws_ecs.DeploymentControllerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies which deployment controller to use for the service. For more information, see `Amazon ECS Deployment Types <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html>`_ Default: - Rolling update (ECS)\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. The minimum value is 1 Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='The domain name for the service, e.g. "api.example.com.". Default: - No domain name.\n')
    domain_zone: typing.Optional[typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef]] = pydantic.Field(None, description='The Route53 hosted zone for the domain, e.g. "example.com.". Default: - No Route53 hosted domain zone.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    listener_port: typing.Union[int, float, None] = pydantic.Field(None, description='Listener port of the network load balancer that will serve traffic to the service. Default: 80\n')
    load_balancer: typing.Optional[typing.Union[models.aws_elasticloadbalancingv2.NetworkLoadBalancerDef]] = pydantic.Field(None, description='The network load balancer that will serve traffic to the service. If the load balancer has been imported, the vpc attribute must be specified in the call to fromNetworkLoadBalancerAttributes(). [disable-awslint:ref-via-interface] Default: - a new load balancer will be created.\n')
    max_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The maximum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that can run in a service during a deployment. Default: - 100 if daemon, otherwise 200\n")
    min_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The minimum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that must continue to run and remain healthy during a deployment. Default: - 0 if daemon, otherwise 50\n")
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    public_load_balancer: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the Load Balancer will be internet-facing. Default: true\n')
    record_type: typing.Optional[aws_cdk.aws_ecs_patterns.NetworkLoadBalancedServiceRecordType] = pydantic.Field(None, description='Specifies whether the Route53 record should be a CNAME, an A record using the Alias feature or no record at all. This is useful if you need to work with DNS systems that do not support alias records. Default: NetworkLoadBalancedServiceRecordType.ALIAS\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.NetworkLoadBalancedTaskImageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. One of taskImageOptions or taskDefinition must be specified. Default: - none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n')
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments This default is set in the underlying FargateTaskDefinition construct. Default: none\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The hard limit (in MiB) of memory to present to the container. If your container attempts to exceed the allocated memory, the container is terminated. At least one of memoryLimitMiB and memoryReservationMiB is required. Default: - No memory limit.\n')
    memory_reservation_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The soft limit (in MiB) of memory to reserve for the container. When system memory is under contention, Docker attempts to keep the container memory within the limit. If the container requires more memory, it can consume up to the value specified by the Memory property or all of the available memory on the container instance—whichever comes first. At least one of memoryLimitMiB and memoryReservationMiB is required. Default: - No memory reserved.\n')
    placement_constraints: typing.Optional[typing.Sequence[models.aws_ecs.PlacementConstraintDef]] = pydantic.Field(None, description='The placement constraints to use for tasks in the service. For more information, see `Amazon ECS Task Placement Constraints <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-constraints.html>`_. Default: - No constraints.\n')
    placement_strategies: typing.Optional[typing.Sequence[models.aws_ecs.PlacementStrategyDef]] = pydantic.Field(None, description='The placement strategies to use for tasks in the service. For more information, see `Amazon ECS Task Placement Strategies <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-strategies.html>`_. Default: - No strategies.\n')
    task_definition: typing.Optional[models.aws_ecs.Ec2TaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. TaskDefinition or TaskImageOptions must be specified, but not both.. [disable-awslint:ref-via-interface] Default: - none\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: ecs.Cluster\n\n    load_balanced_ecs_service = ecs_patterns.NetworkLoadBalancedEc2Service(self, "Service",\n        cluster=cluster,\n        memory_limit_mi_b=1024,\n        task_image_options=ecsPatterns.NetworkLoadBalancedTaskImageOptions(\n            image=ecs.ContainerImage.from_registry("test"),\n            environment={\n                "TEST_ENVIRONMENT_VARIABLE1": "test environment variable 1 value",\n                "TEST_ENVIRONMENT_VARIABLE2": "test environment variable 2 value"\n            }\n        ),\n        desired_count=2\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['capacity_provider_strategies', 'circuit_breaker', 'cloud_map_options', 'cluster', 'deployment_controller', 'desired_count', 'domain_name', 'domain_zone', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'listener_port', 'load_balancer', 'max_healthy_percent', 'min_healthy_percent', 'propagate_tags', 'public_load_balancer', 'record_type', 'service_name', 'task_image_options', 'vpc', 'cpu', 'memory_limit_mib', 'memory_reservation_mib', 'placement_constraints', 'placement_strategies', 'task_definition']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.NetworkLoadBalancedEc2ServiceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecs_patterns.NetworkLoadBalancedFargateServiceProps
class NetworkLoadBalancedFargateServicePropsDef(BaseStruct):
    capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs.CapacityProviderStrategyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of Capacity Provider strategies used to place a service. Default: - undefined\n')
    circuit_breaker: typing.Union[models.aws_ecs.DeploymentCircuitBreakerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly enabled. Default: - disabled\n')
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    deployment_controller: typing.Union[models.aws_ecs.DeploymentControllerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies which deployment controller to use for the service. For more information, see `Amazon ECS Deployment Types <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html>`_ Default: - Rolling update (ECS)\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. The minimum value is 1 Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='The domain name for the service, e.g. "api.example.com.". Default: - No domain name.\n')
    domain_zone: typing.Optional[typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef]] = pydantic.Field(None, description='The Route53 hosted zone for the domain, e.g. "example.com.". Default: - No Route53 hosted domain zone.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    listener_port: typing.Union[int, float, None] = pydantic.Field(None, description='Listener port of the network load balancer that will serve traffic to the service. Default: 80\n')
    load_balancer: typing.Optional[typing.Union[models.aws_elasticloadbalancingv2.NetworkLoadBalancerDef]] = pydantic.Field(None, description='The network load balancer that will serve traffic to the service. If the load balancer has been imported, the vpc attribute must be specified in the call to fromNetworkLoadBalancerAttributes(). [disable-awslint:ref-via-interface] Default: - a new load balancer will be created.\n')
    max_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The maximum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that can run in a service during a deployment. Default: - 100 if daemon, otherwise 200\n")
    min_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The minimum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that must continue to run and remain healthy during a deployment. Default: - 0 if daemon, otherwise 50\n")
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    public_load_balancer: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the Load Balancer will be internet-facing. Default: true\n')
    record_type: typing.Optional[aws_cdk.aws_ecs_patterns.NetworkLoadBalancedServiceRecordType] = pydantic.Field(None, description='Specifies whether the Route53 record should be a CNAME, an A record using the Alias feature or no record at all. This is useful if you need to work with DNS systems that do not support alias records. Default: NetworkLoadBalancedServiceRecordType.ALIAS\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.NetworkLoadBalancedTaskImageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. One of taskImageOptions or taskDefinition must be specified. Default: - none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n')
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments 8192 (8 vCPU) - Available memory values: Between 16GB and 60GB in 4GB increments 16384 (16 vCPU) - Available memory values: Between 32GB and 120GB in 8GB increments This default is set in the underlying FargateTaskDefinition construct. Default: 256\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The amount (in MiB) of memory used by the task. This field is required and you must use one of the following values, which determines your range of valid values for the cpu parameter: 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB) - Available cpu values: 256 (.25 vCPU) 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB) - Available cpu values: 512 (.5 vCPU) 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB) - Available cpu values: 1024 (1 vCPU) Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB) - Available cpu values: 2048 (2 vCPU) Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB) - Available cpu values: 4096 (4 vCPU) Between 16384 (16 GB) and 61440 (60 GB) in increments of 4096 (4 GB) - Available cpu values: 8192 (8 vCPU) Between 32768 (32 GB) and 122880 (120 GB) in increments of 8192 (8 GB) - Available cpu values: 16384 (16 vCPU) This default is set in the underlying FargateTaskDefinition construct. Default: 512\n')
    platform_version: typing.Optional[aws_cdk.aws_ecs.FargatePlatformVersion] = pydantic.Field(None, description='The platform version on which to run your service. If one is not specified, the LATEST platform version is used by default. For more information, see `AWS Fargate Platform Versions <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html>`_ in the Amazon Elastic Container Service Developer Guide. Default: Latest\n')
    runtime_platform: typing.Union[models.aws_ecs.RuntimePlatformDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The runtime platform of the task definition. Default: - If the property is undefined, ``operatingSystemFamily`` is LINUX and ``cpuArchitecture`` is X86_64\n')
    task_definition: typing.Optional[models.aws_ecs.FargateTaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. TaskDefinition or TaskImageOptions must be specified, but not both. [disable-awslint:ref-via-interface] Default: - none\n')
    assign_public_ip: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the service will be assigned a public IP address. Default: false\n')
    task_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The subnets to associate with the service. Default: - Public subnets if ``assignPublicIp`` is set, otherwise the first available one of Private, Isolated, Public, in that order.\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: ecs.Cluster\n\n    load_balanced_fargate_service = ecs_patterns.NetworkLoadBalancedFargateService(self, "Service",\n        cluster=cluster,\n        memory_limit_mi_b=1024,\n        cpu=512,\n        task_image_options=ecsPatterns.NetworkLoadBalancedTaskImageOptions(\n            image=ecs.ContainerImage.from_registry("amazon/amazon-ecs-sample")\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['capacity_provider_strategies', 'circuit_breaker', 'cloud_map_options', 'cluster', 'deployment_controller', 'desired_count', 'domain_name', 'domain_zone', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'listener_port', 'load_balancer', 'max_healthy_percent', 'min_healthy_percent', 'propagate_tags', 'public_load_balancer', 'record_type', 'service_name', 'task_image_options', 'vpc', 'cpu', 'memory_limit_mib', 'platform_version', 'runtime_platform', 'task_definition', 'assign_public_ip', 'task_subnets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.NetworkLoadBalancedFargateServiceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecs_patterns.NetworkLoadBalancedServiceBaseProps
class NetworkLoadBalancedServiceBasePropsDef(BaseStruct):
    capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs.CapacityProviderStrategyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of Capacity Provider strategies used to place a service. Default: - undefined\n')
    circuit_breaker: typing.Union[models.aws_ecs.DeploymentCircuitBreakerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly enabled. Default: - disabled\n')
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    deployment_controller: typing.Union[models.aws_ecs.DeploymentControllerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies which deployment controller to use for the service. For more information, see `Amazon ECS Deployment Types <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html>`_ Default: - Rolling update (ECS)\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. The minimum value is 1 Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='The domain name for the service, e.g. "api.example.com.". Default: - No domain name.\n')
    domain_zone: typing.Optional[typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef]] = pydantic.Field(None, description='The Route53 hosted zone for the domain, e.g. "example.com.". Default: - No Route53 hosted domain zone.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    listener_port: typing.Union[int, float, None] = pydantic.Field(None, description='Listener port of the network load balancer that will serve traffic to the service. Default: 80\n')
    load_balancer: typing.Optional[typing.Union[models.aws_elasticloadbalancingv2.NetworkLoadBalancerDef]] = pydantic.Field(None, description='The network load balancer that will serve traffic to the service. If the load balancer has been imported, the vpc attribute must be specified in the call to fromNetworkLoadBalancerAttributes(). [disable-awslint:ref-via-interface] Default: - a new load balancer will be created.\n')
    max_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The maximum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that can run in a service during a deployment. Default: - 100 if daemon, otherwise 200\n")
    min_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The minimum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that must continue to run and remain healthy during a deployment. Default: - 0 if daemon, otherwise 50\n")
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    public_load_balancer: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the Load Balancer will be internet-facing. Default: true\n')
    record_type: typing.Optional[aws_cdk.aws_ecs_patterns.NetworkLoadBalancedServiceRecordType] = pydantic.Field(None, description='Specifies whether the Route53 record should be a CNAME, an A record using the Alias feature or no record at all. This is useful if you need to work with DNS systems that do not support alias records. Default: NetworkLoadBalancedServiceRecordType.ALIAS\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.NetworkLoadBalancedTaskImageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. One of taskImageOptions or taskDefinition must be specified. Default: - none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_ec2 as ec2\n    from aws_cdk import aws_ecs as ecs\n    from aws_cdk import aws_ecs_patterns as ecs_patterns\n    from aws_cdk import aws_elasticloadbalancingv2 as elbv2\n    from aws_cdk import aws_iam as iam\n    from aws_cdk import aws_route53 as route53\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    # cluster: ecs.Cluster\n    # container_definition: ecs.ContainerDefinition\n    # container_image: ecs.ContainerImage\n    # hosted_zone: route53.HostedZone\n    # log_driver: ecs.LogDriver\n    # namespace: servicediscovery.INamespace\n    # network_load_balancer: elbv2.NetworkLoadBalancer\n    # role: iam.Role\n    # secret: ecs.Secret\n    # vpc: ec2.Vpc\n\n    network_load_balanced_service_base_props = ecs_patterns.NetworkLoadBalancedServiceBaseProps(\n        capacity_provider_strategies=[ecs.CapacityProviderStrategy(\n            capacity_provider="capacityProvider",\n\n            # the properties below are optional\n            base=123,\n            weight=123\n        )],\n        circuit_breaker=ecs.DeploymentCircuitBreaker(\n            rollback=False\n        ),\n        cloud_map_options=ecs.CloudMapOptions(\n            cloud_map_namespace=namespace,\n            container=container_definition,\n            container_port=123,\n            dns_record_type=servicediscovery.DnsRecordType.A,\n            dns_ttl=cdk.Duration.minutes(30),\n            failure_threshold=123,\n            name="name"\n        ),\n        cluster=cluster,\n        deployment_controller=ecs.DeploymentController(\n            type=ecs.DeploymentControllerType.ECS\n        ),\n        desired_count=123,\n        domain_name="domainName",\n        domain_zone=hosted_zone,\n        enable_eCSManaged_tags=False,\n        enable_execute_command=False,\n        health_check_grace_period=cdk.Duration.minutes(30),\n        listener_port=123,\n        load_balancer=network_load_balancer,\n        max_healthy_percent=123,\n        min_healthy_percent=123,\n        propagate_tags=ecs.PropagatedTagSource.SERVICE,\n        public_load_balancer=False,\n        record_type=ecs_patterns.NetworkLoadBalancedServiceRecordType.ALIAS,\n        service_name="serviceName",\n        task_image_options=ecs_patterns.NetworkLoadBalancedTaskImageOptions(\n            image=container_image,\n\n            # the properties below are optional\n            container_name="containerName",\n            container_port=123,\n            docker_labels={\n                "docker_labels_key": "dockerLabels"\n            },\n            enable_logging=False,\n            environment={\n                "environment_key": "environment"\n            },\n            execution_role=role,\n            family="family",\n            log_driver=log_driver,\n            secrets={\n                "secrets_key": secret\n            },\n            task_role=role\n        ),\n        vpc=vpc\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['capacity_provider_strategies', 'circuit_breaker', 'cloud_map_options', 'cluster', 'deployment_controller', 'desired_count', 'domain_name', 'domain_zone', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'listener_port', 'load_balancer', 'max_healthy_percent', 'min_healthy_percent', 'propagate_tags', 'public_load_balancer', 'record_type', 'service_name', 'task_image_options', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.NetworkLoadBalancedServiceBaseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecs_patterns.NetworkLoadBalancedTaskImageOptions
class NetworkLoadBalancedTaskImageOptionsDef(BaseStruct):
    image: typing.Union[models.aws_ecs.ContainerImageDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The image used to start a container. Image or taskDefinition must be specified, but not both. Default: - none')
    container_name: typing.Optional[str] = pydantic.Field(None, description='The container name value to be specified in the task definition. Default: - none\n')
    container_port: typing.Union[int, float, None] = pydantic.Field(None, description='The port number on the container that is bound to the user-specified or automatically assigned host port. If you are using containers in a task with the awsvpc or host network mode, exposed ports should be specified using containerPort. If you are using containers in a task with the bridge network mode and you specify a container port and not a host port, your container automatically receives a host port in the ephemeral port range. Port mappings that are automatically assigned in this way do not count toward the 100 reserved ports limit of a container instance. For more information, see `hostPort <https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PortMapping.html#ECS-Type-PortMapping-hostPort>`_. Default: 80\n')
    docker_labels: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='A key/value map of labels to add to the container. Default: - No labels.\n')
    enable_logging: typing.Optional[bool] = pydantic.Field(None, description='Flag to indicate whether to enable logging. Default: true\n')
    environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The environment variables to pass to the container. Default: - No environment variables.\n')
    execution_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The name of the task execution IAM role that grants the Amazon ECS container agent permission to call AWS APIs on your behalf. Default: - No value\n')
    family: typing.Optional[str] = pydantic.Field(None, description='The name of a family that this task definition is registered to. A family groups multiple versions of a task definition. Default: - Automatically generated name.\n')
    log_driver: typing.Optional[models.aws_ecs.LogDriverDef] = pydantic.Field(None, description='The log driver to use. Default: - AwsLogDriver if enableLogging is true\n')
    secrets: typing.Optional[typing.Mapping[str, models.aws_ecs.SecretDef]] = pydantic.Field(None, description='The secret to expose to the container as an environment variable. Default: - No secret environment variables.\n')
    task_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The name of the task IAM role that grants containers in the task permission to call AWS APIs on your behalf. Default: - A task role is automatically created for you.\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: ecs.Cluster\n\n    load_balanced_ecs_service = ecs_patterns.NetworkLoadBalancedEc2Service(self, "Service",\n        cluster=cluster,\n        memory_limit_mi_b=1024,\n        task_image_options=ecsPatterns.NetworkLoadBalancedTaskImageOptions(\n            image=ecs.ContainerImage.from_registry("test"),\n            environment={\n                "TEST_ENVIRONMENT_VARIABLE1": "test environment variable 1 value",\n                "TEST_ENVIRONMENT_VARIABLE2": "test environment variable 2 value"\n            }\n        ),\n        desired_count=2\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['image', 'container_name', 'container_port', 'docker_labels', 'enable_logging', 'environment', 'execution_role', 'family', 'log_driver', 'secrets', 'task_role']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.NetworkLoadBalancedTaskImageOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.NetworkLoadBalancedTaskImageOptionsDefConfig] = pydantic.Field(None)


class NetworkLoadBalancedTaskImageOptionsDefConfig(pydantic.BaseModel):
    image_config: typing.Optional[models.aws_ecs.ContainerImageDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.NetworkLoadBalancedTaskImageProps
class NetworkLoadBalancedTaskImagePropsDef(BaseStruct):
    image: typing.Union[models.aws_ecs.ContainerImageDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The image used to start a container. Image or taskDefinition must be specified, but not both. Default: - none\n')
    container_name: typing.Optional[str] = pydantic.Field(None, description='The container name value to be specified in the task definition. Default: - none\n')
    container_ports: typing.Optional[typing.Sequence[typing.Union[int, float]]] = pydantic.Field(None, description='A list of port numbers on the container that is bound to the user-specified or automatically assigned host port. If you are using containers in a task with the awsvpc or host network mode, exposed ports should be specified using containerPort. If you are using containers in a task with the bridge network mode and you specify a container port and not a host port, your container automatically receives a host port in the ephemeral port range. Port mappings that are automatically assigned in this way do not count toward the 100 reserved ports limit of a container instance. For more information, see `hostPort <https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PortMapping.html#ECS-Type-PortMapping-hostPort>`_. Default: - [80]\n')
    docker_labels: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='A key/value map of labels to add to the container. Default: - No labels.\n')
    enable_logging: typing.Optional[bool] = pydantic.Field(None, description='Flag to indicate whether to enable logging. Default: true\n')
    environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The environment variables to pass to the container. Default: - No environment variables.\n')
    execution_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The name of the task execution IAM role that grants the Amazon ECS container agent permission to call AWS APIs on your behalf. Default: - No value\n')
    family: typing.Optional[str] = pydantic.Field(None, description='The name of a family that this task definition is registered to. A family groups multiple versions of a task definition. Default: - Automatically generated name.\n')
    log_driver: typing.Optional[models.aws_ecs.LogDriverDef] = pydantic.Field(None, description='The log driver to use. Default: - AwsLogDriver if enableLogging is true\n')
    secrets: typing.Optional[typing.Mapping[str, models.aws_ecs.SecretDef]] = pydantic.Field(None, description='The secrets to expose to the container as an environment variable. Default: - No secret environment variables.\n')
    task_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The name of the task IAM role that grants containers in the task permission to call AWS APIs on your behalf. Default: - A task role is automatically created for you.\n\n:exampleMetadata: infused\n\nExample::\n\n    # Two network load balancers, each with their own listener and target group.\n    # cluster: ecs.Cluster\n\n    load_balanced_ec2_service = ecs_patterns.NetworkMultipleTargetGroupsEc2Service(self, "Service",\n        cluster=cluster,\n        memory_limit_mi_b=256,\n        task_image_options=ecsPatterns.NetworkLoadBalancedTaskImageProps(\n            image=ecs.ContainerImage.from_registry("amazon/amazon-ecs-sample")\n        ),\n        load_balancers=[ecsPatterns.NetworkLoadBalancerProps(\n            name="lb1",\n            listeners=[ecsPatterns.NetworkListenerProps(\n                name="listener1"\n            )\n            ]\n        ), ecsPatterns.NetworkLoadBalancerProps(\n            name="lb2",\n            listeners=[ecsPatterns.NetworkListenerProps(\n                name="listener2"\n            )\n            ]\n        )\n        ],\n        target_groups=[ecsPatterns.NetworkTargetProps(\n            container_port=80,\n            listener="listener1"\n        ), ecsPatterns.NetworkTargetProps(\n            container_port=90,\n            listener="listener2"\n        )\n        ]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['image', 'container_name', 'container_ports', 'docker_labels', 'enable_logging', 'environment', 'execution_role', 'family', 'log_driver', 'secrets', 'task_role']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.NetworkLoadBalancedTaskImageProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.NetworkLoadBalancedTaskImagePropsDefConfig] = pydantic.Field(None)


class NetworkLoadBalancedTaskImagePropsDefConfig(pydantic.BaseModel):
    image_config: typing.Optional[models.aws_ecs.ContainerImageDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.NetworkLoadBalancerProps
class NetworkLoadBalancerPropsDef(BaseStruct):
    listeners: typing.Union[typing.Sequence[typing.Union[models.aws_ecs_patterns.NetworkListenerPropsDef, dict[str, typing.Any]]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Listeners (at least one listener) attached to this load balancer. Default: - none\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Name of the load balancer.\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='The domain name for the service, e.g. "api.example.com.". Default: - No domain name.\n')
    domain_zone: typing.Optional[typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef]] = pydantic.Field(None, description='The Route53 hosted zone for the domain, e.g. "example.com.". Default: - No Route53 hosted domain zone.\n')
    public_load_balancer: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the Load Balancer will be internet-facing. Default: true\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ecs_patterns as ecs_patterns\n    from aws_cdk import aws_route53 as route53\n\n    # hosted_zone: route53.HostedZone\n\n    network_load_balancer_props = ecs_patterns.NetworkLoadBalancerProps(\n        listeners=[ecs_patterns.NetworkListenerProps(\n            name="name",\n\n            # the properties below are optional\n            port=123\n        )],\n        name="name",\n\n        # the properties below are optional\n        domain_name="domainName",\n        domain_zone=hosted_zone,\n        public_load_balancer=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['listeners', 'name', 'domain_name', 'domain_zone', 'public_load_balancer']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.NetworkLoadBalancerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecs_patterns.NetworkMultipleTargetGroupsEc2ServiceProps
class NetworkMultipleTargetGroupsEc2ServicePropsDef(BaseStruct):
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. The minimum value is 1 Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    load_balancers: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.NetworkLoadBalancerPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The network load balancer that will serve traffic to the service. Default: - a new load balancer with a listener will be created.\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='Name of the service. Default: - CloudFormation-generated name.\n')
    target_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.NetworkTargetPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Properties to specify NLB target groups. Default: - default portMapping registered as target group and attached to the first defined listener\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.NetworkLoadBalancedTaskImagePropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. Only one of TaskDefinition or TaskImageOptions must be specified. Default: - none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n')
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of CPU units to reserve for the container. Valid values, which determines your range of valid values for the memory parameter: Default: - No minimum CPU units reserved.\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The amount (in MiB) of memory to present to the container. If your container attempts to exceed the allocated memory, the container is terminated. At least one of memoryLimitMiB and memoryReservationMiB is required. Default: - No memory limit.\n')
    memory_reservation_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The soft limit (in MiB) of memory to reserve for the container. When system memory is under heavy contention, Docker attempts to keep the container memory to this soft limit. However, your container can consume more memory when it needs to, up to either the hard limit specified with the memory parameter (if applicable), or all of the available memory on the container instance, whichever comes first. At least one of memoryLimitMiB and memoryReservationMiB is required. Note that this setting will be ignored if TaskImagesOptions is specified. Default: - No memory reserved.\n')
    placement_constraints: typing.Optional[typing.Sequence[models.aws_ecs.PlacementConstraintDef]] = pydantic.Field(None, description='The placement constraints to use for tasks in the service. For more information, see `Amazon ECS Task Placement Constraints <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-constraints.html>`_. Default: - No constraints.\n')
    placement_strategies: typing.Optional[typing.Sequence[models.aws_ecs.PlacementStrategyDef]] = pydantic.Field(None, description='The placement strategies to use for tasks in the service. For more information, see `Amazon ECS Task Placement Strategies <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-strategies.html>`_. Default: - No strategies.\n')
    task_definition: typing.Optional[models.aws_ecs.Ec2TaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. Only one of TaskDefinition or TaskImageOptions must be specified. [disable-awslint:ref-via-interface] Default: - none\n\n:exampleMetadata: infused\n\nExample::\n\n    # Two network load balancers, each with their own listener and target group.\n    # cluster: ecs.Cluster\n\n    load_balanced_ec2_service = ecs_patterns.NetworkMultipleTargetGroupsEc2Service(self, "Service",\n        cluster=cluster,\n        memory_limit_mi_b=256,\n        task_image_options=ecsPatterns.NetworkLoadBalancedTaskImageProps(\n            image=ecs.ContainerImage.from_registry("amazon/amazon-ecs-sample")\n        ),\n        load_balancers=[ecsPatterns.NetworkLoadBalancerProps(\n            name="lb1",\n            listeners=[ecsPatterns.NetworkListenerProps(\n                name="listener1"\n            )\n            ]\n        ), ecsPatterns.NetworkLoadBalancerProps(\n            name="lb2",\n            listeners=[ecsPatterns.NetworkListenerProps(\n                name="listener2"\n            )\n            ]\n        )\n        ],\n        target_groups=[ecsPatterns.NetworkTargetProps(\n            container_port=80,\n            listener="listener1"\n        ), ecsPatterns.NetworkTargetProps(\n            container_port=90,\n            listener="listener2"\n        )\n        ]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cloud_map_options', 'cluster', 'desired_count', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'load_balancers', 'propagate_tags', 'service_name', 'target_groups', 'task_image_options', 'vpc', 'cpu', 'memory_limit_mib', 'memory_reservation_mib', 'placement_constraints', 'placement_strategies', 'task_definition']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.NetworkMultipleTargetGroupsEc2ServiceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecs_patterns.NetworkMultipleTargetGroupsFargateServiceProps
class NetworkMultipleTargetGroupsFargateServicePropsDef(BaseStruct):
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. The minimum value is 1 Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    load_balancers: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.NetworkLoadBalancerPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The network load balancer that will serve traffic to the service. Default: - a new load balancer with a listener will be created.\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='Name of the service. Default: - CloudFormation-generated name.\n')
    target_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.NetworkTargetPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Properties to specify NLB target groups. Default: - default portMapping registered as target group and attached to the first defined listener\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.NetworkLoadBalancedTaskImagePropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. Only one of TaskDefinition or TaskImageOptions must be specified. Default: - none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n')
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments 8192 (8 vCPU) - Available memory values: Between 16GB and 60GB in 4GB increments 16384 (16 vCPU) - Available memory values: Between 32GB and 120GB in 8GB increments This default is set in the underlying FargateTaskDefinition construct. Default: 256\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The amount (in MiB) of memory used by the task. This field is required and you must use one of the following values, which determines your range of valid values for the cpu parameter: 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB) - Available cpu values: 256 (.25 vCPU) 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB) - Available cpu values: 512 (.5 vCPU) 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB) - Available cpu values: 1024 (1 vCPU) Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB) - Available cpu values: 2048 (2 vCPU) Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB) - Available cpu values: 4096 (4 vCPU) Between 16384 (16 GB) and 61440 (60 GB) in increments of 4096 (4 GB) - Available cpu values: 8192 (8 vCPU) Between 32768 (32 GB) and 122880 (120 GB) in increments of 8192 (8 GB) - Available cpu values: 16384 (16 vCPU) This default is set in the underlying FargateTaskDefinition construct. Default: 512\n')
    platform_version: typing.Optional[aws_cdk.aws_ecs.FargatePlatformVersion] = pydantic.Field(None, description='The platform version on which to run your service. If one is not specified, the LATEST platform version is used by default. For more information, see `AWS Fargate Platform Versions <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html>`_ in the Amazon Elastic Container Service Developer Guide. Default: Latest\n')
    runtime_platform: typing.Union[models.aws_ecs.RuntimePlatformDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The runtime platform of the task definition. Default: - If the property is undefined, ``operatingSystemFamily`` is LINUX and ``cpuArchitecture`` is X86_64\n')
    task_definition: typing.Optional[models.aws_ecs.FargateTaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. TaskDefinition or TaskImageOptions must be specified, but not both. [disable-awslint:ref-via-interface] Default: - none\n')
    assign_public_ip: typing.Optional[bool] = pydantic.Field(None, description='Determines whether the service will be assigned a public IP address. Default: false\n\n:exampleMetadata: infused\n\nExample::\n\n    # Two network load balancers, each with their own listener and target group.\n    # cluster: ecs.Cluster\n\n    load_balanced_fargate_service = ecs_patterns.NetworkMultipleTargetGroupsFargateService(self, "Service",\n        cluster=cluster,\n        memory_limit_mi_b=512,\n        task_image_options=ecsPatterns.NetworkLoadBalancedTaskImageProps(\n            image=ecs.ContainerImage.from_registry("amazon/amazon-ecs-sample")\n        ),\n        load_balancers=[ecsPatterns.NetworkLoadBalancerProps(\n            name="lb1",\n            listeners=[ecsPatterns.NetworkListenerProps(\n                name="listener1"\n            )\n            ]\n        ), ecsPatterns.NetworkLoadBalancerProps(\n            name="lb2",\n            listeners=[ecsPatterns.NetworkListenerProps(\n                name="listener2"\n            )\n            ]\n        )\n        ],\n        target_groups=[ecsPatterns.NetworkTargetProps(\n            container_port=80,\n            listener="listener1"\n        ), ecsPatterns.NetworkTargetProps(\n            container_port=90,\n            listener="listener2"\n        )\n        ]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cloud_map_options', 'cluster', 'desired_count', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'load_balancers', 'propagate_tags', 'service_name', 'target_groups', 'task_image_options', 'vpc', 'cpu', 'memory_limit_mib', 'platform_version', 'runtime_platform', 'task_definition', 'assign_public_ip']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.NetworkMultipleTargetGroupsFargateServiceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecs_patterns.NetworkMultipleTargetGroupsServiceBaseProps
class NetworkMultipleTargetGroupsServiceBasePropsDef(BaseStruct):
    cloud_map_options: typing.Union[models.aws_ecs.CloudMapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    desired_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. The minimum value is 1 Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1; if true, the default is 1 for all new services and uses the existing services desired count when updating an existing service.\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    health_check_grace_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n')
    load_balancers: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.NetworkLoadBalancerPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The network load balancer that will serve traffic to the service. Default: - a new load balancer with a listener will be created.\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='Name of the service. Default: - CloudFormation-generated name.\n')
    target_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs_patterns.NetworkTargetPropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Properties to specify NLB target groups. Default: - default portMapping registered as target group and attached to the first defined listener\n')
    task_image_options: typing.Union[models.aws_ecs_patterns.NetworkLoadBalancedTaskImagePropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties required to create a new task definition. Only one of TaskDefinition or TaskImageOptions must be specified. Default: - none\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_ec2 as ec2\n    from aws_cdk import aws_ecs as ecs\n    from aws_cdk import aws_ecs_patterns as ecs_patterns\n    from aws_cdk import aws_iam as iam\n    from aws_cdk import aws_route53 as route53\n    from aws_cdk import aws_servicediscovery as servicediscovery\n\n    # cluster: ecs.Cluster\n    # container_definition: ecs.ContainerDefinition\n    # container_image: ecs.ContainerImage\n    # hosted_zone: route53.HostedZone\n    # log_driver: ecs.LogDriver\n    # namespace: servicediscovery.INamespace\n    # role: iam.Role\n    # secret: ecs.Secret\n    # vpc: ec2.Vpc\n\n    network_multiple_target_groups_service_base_props = ecs_patterns.NetworkMultipleTargetGroupsServiceBaseProps(\n        cloud_map_options=ecs.CloudMapOptions(\n            cloud_map_namespace=namespace,\n            container=container_definition,\n            container_port=123,\n            dns_record_type=servicediscovery.DnsRecordType.A,\n            dns_ttl=cdk.Duration.minutes(30),\n            failure_threshold=123,\n            name="name"\n        ),\n        cluster=cluster,\n        desired_count=123,\n        enable_eCSManaged_tags=False,\n        enable_execute_command=False,\n        health_check_grace_period=cdk.Duration.minutes(30),\n        load_balancers=[ecs_patterns.NetworkLoadBalancerProps(\n            listeners=[ecs_patterns.NetworkListenerProps(\n                name="name",\n\n                # the properties below are optional\n                port=123\n            )],\n            name="name",\n\n            # the properties below are optional\n            domain_name="domainName",\n            domain_zone=hosted_zone,\n            public_load_balancer=False\n        )],\n        propagate_tags=ecs.PropagatedTagSource.SERVICE,\n        service_name="serviceName",\n        target_groups=[ecs_patterns.NetworkTargetProps(\n            container_port=123,\n\n            # the properties below are optional\n            listener="listener"\n        )],\n        task_image_options=ecs_patterns.NetworkLoadBalancedTaskImageProps(\n            image=container_image,\n\n            # the properties below are optional\n            container_name="containerName",\n            container_ports=[123],\n            docker_labels={\n                "docker_labels_key": "dockerLabels"\n            },\n            enable_logging=False,\n            environment={\n                "environment_key": "environment"\n            },\n            execution_role=role,\n            family="family",\n            log_driver=log_driver,\n            secrets={\n                "secrets_key": secret\n            },\n            task_role=role\n        ),\n        vpc=vpc\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cloud_map_options', 'cluster', 'desired_count', 'enable_ecs_managed_tags', 'enable_execute_command', 'health_check_grace_period', 'load_balancers', 'propagate_tags', 'service_name', 'target_groups', 'task_image_options', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.NetworkMultipleTargetGroupsServiceBaseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecs_patterns.NetworkTargetProps
class NetworkTargetPropsDef(BaseStruct):
    container_port: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The port number of the container. Only applicable when using application/network load balancers.\n')
    listener: typing.Optional[str] = pydantic.Field(None, description='Name of the listener the target group attached to. Default: - default listener (first added listener)\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ecs_patterns as ecs_patterns\n\n    network_target_props = ecs_patterns.NetworkTargetProps(\n        container_port=123,\n\n        # the properties below are optional\n        listener="listener"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['container_port', 'listener']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.NetworkTargetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecs_patterns.QueueProcessingEc2ServiceProps
class QueueProcessingEc2ServicePropsDef(BaseStruct):
    image: typing.Union[models.aws_ecs.ContainerImageDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The image used to start a container.\n')
    capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs.CapacityProviderStrategyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of Capacity Provider strategies used to place a service. Default: - undefined\n')
    circuit_breaker: typing.Union[models.aws_ecs.DeploymentCircuitBreakerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly enabled. Default: - disabled\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    command: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The command that is passed to the container. If you provide a shell command as a single string, you have to quote command-line arguments. Default: - CMD value built into container image.\n')
    deployment_controller: typing.Union[models.aws_ecs.DeploymentControllerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies which deployment controller to use for the service. For more information, see `Amazon ECS Deployment Types <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html>`_ Default: - Rolling update (ECS)\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    enable_logging: typing.Optional[bool] = pydantic.Field(None, description='Flag to indicate whether to enable logging. Default: true\n')
    environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description="The environment variables to pass to the container. The variable ``QUEUE_NAME`` with value ``queue.queueName`` will always be passed. Default: 'QUEUE_NAME: queue.queueName'\n")
    family: typing.Optional[str] = pydantic.Field(None, description='The name of a family that the task definition is registered to. A family groups multiple versions of a task definition. Default: - Automatically generated name.\n')
    log_driver: typing.Optional[models.aws_ecs.LogDriverDef] = pydantic.Field(None, description='The log driver to use. Default: - AwsLogDriver if enableLogging is true\n')
    max_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The maximum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that can run in a service during a deployment. Default: - default from underlying service.\n")
    max_receive_count: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of times that a message can be received by consumers. When this value is exceeded for a message the message will be automatically sent to the Dead Letter Queue. If the queue construct is specified, maxReceiveCount should be omitted. Default: 3\n')
    max_scaling_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Maximum capacity to scale to. Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is (desiredTaskCount * 2); if true, the default is 2.\n')
    min_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The minimum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that must continue to run and remain healthy during a deployment. Default: - default from underlying service.\n")
    min_scaling_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Minimum capacity to scale to. Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is the desiredTaskCount; if true, the default is 1.\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    queue: typing.Optional[typing.Union[models.aws_sqs.QueueBaseDef, models.aws_sqs.QueueDef]] = pydantic.Field(None, description="A queue for which to process items from. If specified and this is a FIFO queue, the queue name must end in the string '.fifo'. See `CreateQueue <https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_CreateQueue.html>`_ Default: 'SQSQueue with CloudFormation-generated name'\n")
    retention_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The number of seconds that Dead Letter Queue retains a message. If the queue construct is specified, retentionPeriod should be omitted. Default: Duration.days(14)\n')
    scaling_steps: typing.Optional[typing.Sequence[typing.Union[models.aws_applicationautoscaling.ScalingIntervalDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="The intervals for scaling based on the SQS queue's ApproximateNumberOfMessagesVisible metric. Maps a range of metric values to a particular scaling behavior. See `Simple and Step Scaling Policies for Amazon EC2 Auto Scaling <https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-simple-step.html>`_ Default: [{ upper: 0, change: -1 },{ lower: 100, change: +1 },{ lower: 500, change: +5 }]\n")
    secrets: typing.Optional[typing.Mapping[str, models.aws_ecs.SecretDef]] = pydantic.Field(None, description='The secret to expose to the container as an environment variable. Default: - No secret environment variables.\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    visibility_timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Timeout of processing a single message. After dequeuing, the processor has this much time to handle the message and delete it from the queue before it becomes visible again for dequeueing by another processor. Values must be between 0 and (12 hours). If the queue construct is specified, visibilityTimeout should be omitted. Default: Duration.seconds(30)\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n')
    container_name: typing.Optional[str] = pydantic.Field(None, description='Optional name for the container added. Default: - QueueProcessingContainer\n')
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments This default is set in the underlying FargateTaskDefinition construct. Default: none\n')
    gpu_count: typing.Union[int, float, None] = pydantic.Field(None, description='Gpu count for container in task definition. Set this if you want to use gpu based instances. Default: - No GPUs assigned.\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The hard limit (in MiB) of memory to present to the container. If your container attempts to exceed the allocated memory, the container is terminated. At least one of memoryLimitMiB and memoryReservationMiB is required for non-Fargate services. Default: - No memory limit.\n')
    memory_reservation_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The soft limit (in MiB) of memory to reserve for the container. When system memory is under contention, Docker attempts to keep the container memory within the limit. If the container requires more memory, it can consume up to the value specified by the Memory property or all of the available memory on the container instance—whichever comes first. At least one of memoryLimitMiB and memoryReservationMiB is required for non-Fargate services. Default: - No memory reserved.\n')
    placement_constraints: typing.Optional[typing.Sequence[models.aws_ecs.PlacementConstraintDef]] = pydantic.Field(None, description='The placement constraints to use for tasks in the service. For more information, see `Amazon ECS Task Placement Constraints <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-constraints.html>`_. Default: - No constraints.\n')
    placement_strategies: typing.Optional[typing.Sequence[models.aws_ecs.PlacementStrategyDef]] = pydantic.Field(None, description='The placement strategies to use for tasks in the service. For more information, see `Amazon ECS Task Placement Strategies <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-strategies.html>`_. Default: - No strategies.\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: ecs.Cluster\n\n    queue_processing_ec2_service = ecs_patterns.QueueProcessingEc2Service(self, "Service",\n        cluster=cluster,\n        memory_limit_mi_b=1024,\n        image=ecs.ContainerImage.from_registry("test"),\n        command=["-c", "4", "amazon.com"],\n        enable_logging=False,\n        desired_task_count=2,\n        environment={\n            "TEST_ENVIRONMENT_VARIABLE1": "test environment variable 1 value",\n            "TEST_ENVIRONMENT_VARIABLE2": "test environment variable 2 value"\n        },\n        max_scaling_capacity=5,\n        container_name="test"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['image', 'capacity_provider_strategies', 'circuit_breaker', 'cluster', 'command', 'deployment_controller', 'enable_ecs_managed_tags', 'enable_execute_command', 'enable_logging', 'environment', 'family', 'log_driver', 'max_healthy_percent', 'max_receive_count', 'max_scaling_capacity', 'min_healthy_percent', 'min_scaling_capacity', 'propagate_tags', 'queue', 'retention_period', 'scaling_steps', 'secrets', 'service_name', 'visibility_timeout', 'vpc', 'container_name', 'cpu', 'gpu_count', 'memory_limit_mib', 'memory_reservation_mib', 'placement_constraints', 'placement_strategies']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.QueueProcessingEc2ServiceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.QueueProcessingEc2ServicePropsDefConfig] = pydantic.Field(None)


class QueueProcessingEc2ServicePropsDefConfig(pydantic.BaseModel):
    image_config: typing.Optional[models.aws_ecs.ContainerImageDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.QueueProcessingFargateServiceProps
class QueueProcessingFargateServicePropsDef(BaseStruct):
    image: typing.Union[models.aws_ecs.ContainerImageDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The image used to start a container.\n')
    capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs.CapacityProviderStrategyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of Capacity Provider strategies used to place a service. Default: - undefined\n')
    circuit_breaker: typing.Union[models.aws_ecs.DeploymentCircuitBreakerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly enabled. Default: - disabled\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    command: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The command that is passed to the container. If you provide a shell command as a single string, you have to quote command-line arguments. Default: - CMD value built into container image.\n')
    deployment_controller: typing.Union[models.aws_ecs.DeploymentControllerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies which deployment controller to use for the service. For more information, see `Amazon ECS Deployment Types <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html>`_ Default: - Rolling update (ECS)\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    enable_logging: typing.Optional[bool] = pydantic.Field(None, description='Flag to indicate whether to enable logging. Default: true\n')
    environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description="The environment variables to pass to the container. The variable ``QUEUE_NAME`` with value ``queue.queueName`` will always be passed. Default: 'QUEUE_NAME: queue.queueName'\n")
    family: typing.Optional[str] = pydantic.Field(None, description='The name of a family that the task definition is registered to. A family groups multiple versions of a task definition. Default: - Automatically generated name.\n')
    log_driver: typing.Optional[models.aws_ecs.LogDriverDef] = pydantic.Field(None, description='The log driver to use. Default: - AwsLogDriver if enableLogging is true\n')
    max_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The maximum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that can run in a service during a deployment. Default: - default from underlying service.\n")
    max_receive_count: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of times that a message can be received by consumers. When this value is exceeded for a message the message will be automatically sent to the Dead Letter Queue. If the queue construct is specified, maxReceiveCount should be omitted. Default: 3\n')
    max_scaling_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Maximum capacity to scale to. Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is (desiredTaskCount * 2); if true, the default is 2.\n')
    min_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The minimum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that must continue to run and remain healthy during a deployment. Default: - default from underlying service.\n")
    min_scaling_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Minimum capacity to scale to. Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is the desiredTaskCount; if true, the default is 1.\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    queue: typing.Optional[typing.Union[models.aws_sqs.QueueBaseDef, models.aws_sqs.QueueDef]] = pydantic.Field(None, description="A queue for which to process items from. If specified and this is a FIFO queue, the queue name must end in the string '.fifo'. See `CreateQueue <https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_CreateQueue.html>`_ Default: 'SQSQueue with CloudFormation-generated name'\n")
    retention_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The number of seconds that Dead Letter Queue retains a message. If the queue construct is specified, retentionPeriod should be omitted. Default: Duration.days(14)\n')
    scaling_steps: typing.Optional[typing.Sequence[typing.Union[models.aws_applicationautoscaling.ScalingIntervalDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="The intervals for scaling based on the SQS queue's ApproximateNumberOfMessagesVisible metric. Maps a range of metric values to a particular scaling behavior. See `Simple and Step Scaling Policies for Amazon EC2 Auto Scaling <https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-simple-step.html>`_ Default: [{ upper: 0, change: -1 },{ lower: 100, change: +1 },{ lower: 500, change: +5 }]\n")
    secrets: typing.Optional[typing.Mapping[str, models.aws_ecs.SecretDef]] = pydantic.Field(None, description='The secret to expose to the container as an environment variable. Default: - No secret environment variables.\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    visibility_timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Timeout of processing a single message. After dequeuing, the processor has this much time to handle the message and delete it from the queue before it becomes visible again for dequeueing by another processor. Values must be between 0 and (12 hours). If the queue construct is specified, visibilityTimeout should be omitted. Default: Duration.seconds(30)\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n')
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments 8192 (8 vCPU) - Available memory values: Between 16GB and 60GB in 4GB increments 16384 (16 vCPU) - Available memory values: Between 32GB and 120GB in 8GB increments This default is set in the underlying FargateTaskDefinition construct. Default: 256\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The amount (in MiB) of memory used by the task. This field is required and you must use one of the following values, which determines your range of valid values for the cpu parameter: 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB) - Available cpu values: 256 (.25 vCPU) 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB) - Available cpu values: 512 (.5 vCPU) 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB) - Available cpu values: 1024 (1 vCPU) Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB) - Available cpu values: 2048 (2 vCPU) Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB) - Available cpu values: 4096 (4 vCPU) Between 16384 (16 GB) and 61440 (60 GB) in increments of 4096 (4 GB) - Available cpu values: 8192 (8 vCPU) Between 32768 (32 GB) and 122880 (120 GB) in increments of 8192 (8 GB) - Available cpu values: 16384 (16 vCPU) This default is set in the underlying FargateTaskDefinition construct. Default: 512\n')
    platform_version: typing.Optional[aws_cdk.aws_ecs.FargatePlatformVersion] = pydantic.Field(None, description='The platform version on which to run your service. If one is not specified, the LATEST platform version is used by default. For more information, see `AWS Fargate Platform Versions <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html>`_ in the Amazon Elastic Container Service Developer Guide. Default: Latest\n')
    runtime_platform: typing.Union[models.aws_ecs.RuntimePlatformDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The runtime platform of the task definition. Default: - If the property is undefined, ``operatingSystemFamily`` is LINUX and ``cpuArchitecture`` is X86_64\n')
    task_definition: typing.Optional[models.aws_ecs.FargateTaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. TaskDefinition or TaskImageOptions must be specified, but not both. [disable-awslint:ref-via-interface] Default: - none\n')
    assign_public_ip: typing.Optional[bool] = pydantic.Field(None, description="Specifies whether the task's elastic network interface receives a public IP address. If true, each task will receive a public IP address. Default: false\n")
    container_name: typing.Optional[str] = pydantic.Field(None, description='Optional name for the container added. Default: - QueueProcessingContainer\n')
    health_check: typing.Union[models.aws_ecs.HealthCheckDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The health check command and associated configuration parameters for the container. Default: - Health check configuration from container.\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='The security groups to associate with the service. If you do not specify a security group, a new security group is created. Default: - A new security group is created.\n')
    task_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The subnets to associate with the service. Default: - Public subnets if ``assignPublicIp`` is set, otherwise the first available one of Private, Isolated, Public, in that order.\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: ecs.Cluster\n\n    cluster.enable_fargate_capacity_providers()\n\n    queue_processing_fargate_service = ecs_patterns.QueueProcessingFargateService(self, "Service",\n        cluster=cluster,\n        memory_limit_mi_b=512,\n        image=ecs.ContainerImage.from_registry("test"),\n        capacity_provider_strategies=[ecs.CapacityProviderStrategy(\n            capacity_provider="FARGATE_SPOT",\n            weight=2\n        ), ecs.CapacityProviderStrategy(\n            capacity_provider="FARGATE",\n            weight=1\n        )\n        ]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['image', 'capacity_provider_strategies', 'circuit_breaker', 'cluster', 'command', 'deployment_controller', 'enable_ecs_managed_tags', 'enable_execute_command', 'enable_logging', 'environment', 'family', 'log_driver', 'max_healthy_percent', 'max_receive_count', 'max_scaling_capacity', 'min_healthy_percent', 'min_scaling_capacity', 'propagate_tags', 'queue', 'retention_period', 'scaling_steps', 'secrets', 'service_name', 'visibility_timeout', 'vpc', 'cpu', 'memory_limit_mib', 'platform_version', 'runtime_platform', 'task_definition', 'assign_public_ip', 'container_name', 'health_check', 'security_groups', 'task_subnets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.QueueProcessingFargateServiceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.QueueProcessingFargateServicePropsDefConfig] = pydantic.Field(None)


class QueueProcessingFargateServicePropsDefConfig(pydantic.BaseModel):
    image_config: typing.Optional[models.aws_ecs.ContainerImageDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.QueueProcessingServiceBaseProps
class QueueProcessingServiceBasePropsDef(BaseStruct):
    image: typing.Union[models.aws_ecs.ContainerImageDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The image used to start a container.\n')
    capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[models.aws_ecs.CapacityProviderStrategyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of Capacity Provider strategies used to place a service. Default: - undefined\n')
    circuit_breaker: typing.Union[models.aws_ecs.DeploymentCircuitBreakerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly enabled. Default: - disabled\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    command: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The command that is passed to the container. If you provide a shell command as a single string, you have to quote command-line arguments. Default: - CMD value built into container image.\n')
    deployment_controller: typing.Union[models.aws_ecs.DeploymentControllerDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies which deployment controller to use for the service. For more information, see `Amazon ECS Deployment Types <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html>`_ Default: - Rolling update (ECS)\n')
    enable_ecs_managed_tags: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false\n')
    enable_execute_command: typing.Optional[bool] = pydantic.Field(None, description='Whether ECS Exec should be enabled. Default: - false\n')
    enable_logging: typing.Optional[bool] = pydantic.Field(None, description='Flag to indicate whether to enable logging. Default: true\n')
    environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description="The environment variables to pass to the container. The variable ``QUEUE_NAME`` with value ``queue.queueName`` will always be passed. Default: 'QUEUE_NAME: queue.queueName'\n")
    family: typing.Optional[str] = pydantic.Field(None, description='The name of a family that the task definition is registered to. A family groups multiple versions of a task definition. Default: - Automatically generated name.\n')
    log_driver: typing.Optional[models.aws_ecs.LogDriverDef] = pydantic.Field(None, description='The log driver to use. Default: - AwsLogDriver if enableLogging is true\n')
    max_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The maximum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that can run in a service during a deployment. Default: - default from underlying service.\n")
    max_receive_count: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of times that a message can be received by consumers. When this value is exceeded for a message the message will be automatically sent to the Dead Letter Queue. If the queue construct is specified, maxReceiveCount should be omitted. Default: 3\n')
    max_scaling_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Maximum capacity to scale to. Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is (desiredTaskCount * 2); if true, the default is 2.\n')
    min_healthy_percent: typing.Union[int, float, None] = pydantic.Field(None, description="The minimum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that must continue to run and remain healthy during a deployment. Default: - default from underlying service.\n")
    min_scaling_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Minimum capacity to scale to. Default: - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is the desiredTaskCount; if true, the default is 1.\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Tags can only be propagated to the tasks within the service during service creation. Default: - none\n')
    queue: typing.Optional[typing.Union[models.aws_sqs.QueueBaseDef, models.aws_sqs.QueueDef]] = pydantic.Field(None, description="A queue for which to process items from. If specified and this is a FIFO queue, the queue name must end in the string '.fifo'. See `CreateQueue <https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_CreateQueue.html>`_ Default: 'SQSQueue with CloudFormation-generated name'\n")
    retention_period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The number of seconds that Dead Letter Queue retains a message. If the queue construct is specified, retentionPeriod should be omitted. Default: Duration.days(14)\n')
    scaling_steps: typing.Optional[typing.Sequence[typing.Union[models.aws_applicationautoscaling.ScalingIntervalDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="The intervals for scaling based on the SQS queue's ApproximateNumberOfMessagesVisible metric. Maps a range of metric values to a particular scaling behavior. See `Simple and Step Scaling Policies for Amazon EC2 Auto Scaling <https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-simple-step.html>`_ Default: [{ upper: 0, change: -1 },{ lower: 100, change: +1 },{ lower: 500, change: +5 }]\n")
    secrets: typing.Optional[typing.Mapping[str, models.aws_ecs.SecretDef]] = pydantic.Field(None, description='The secret to expose to the container as an environment variable. Default: - No secret environment variables.\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the service. Default: - CloudFormation-generated name.\n')
    visibility_timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Timeout of processing a single message. After dequeuing, the processor has this much time to handle the message and delete it from the queue before it becomes visible again for dequeueing by another processor. Values must be between 0 and (12 hours). If the queue construct is specified, visibilityTimeout should be omitted. Default: Duration.seconds(30)\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_ec2 as ec2\n    from aws_cdk import aws_ecs as ecs\n    from aws_cdk import aws_ecs_patterns as ecs_patterns\n    from aws_cdk import aws_sqs as sqs\n\n    # cluster: ecs.Cluster\n    # container_image: ecs.ContainerImage\n    # log_driver: ecs.LogDriver\n    # queue: sqs.Queue\n    # secret: ecs.Secret\n    # vpc: ec2.Vpc\n\n    queue_processing_service_base_props = ecs_patterns.QueueProcessingServiceBaseProps(\n        image=container_image,\n\n        # the properties below are optional\n        capacity_provider_strategies=[ecs.CapacityProviderStrategy(\n            capacity_provider="capacityProvider",\n\n            # the properties below are optional\n            base=123,\n            weight=123\n        )],\n        circuit_breaker=ecs.DeploymentCircuitBreaker(\n            rollback=False\n        ),\n        cluster=cluster,\n        command=["command"],\n        deployment_controller=ecs.DeploymentController(\n            type=ecs.DeploymentControllerType.ECS\n        ),\n        enable_eCSManaged_tags=False,\n        enable_execute_command=False,\n        enable_logging=False,\n        environment={\n            "environment_key": "environment"\n        },\n        family="family",\n        log_driver=log_driver,\n        max_healthy_percent=123,\n        max_receive_count=123,\n        max_scaling_capacity=123,\n        min_healthy_percent=123,\n        min_scaling_capacity=123,\n        propagate_tags=ecs.PropagatedTagSource.SERVICE,\n        queue=queue,\n        retention_period=cdk.Duration.minutes(30),\n        scaling_steps=[cdk.aws_applicationautoscaling.ScalingInterval(\n            change=123,\n\n            # the properties below are optional\n            lower=123,\n            upper=123\n        )],\n        secrets={\n            "secrets_key": secret\n        },\n        service_name="serviceName",\n        visibility_timeout=cdk.Duration.minutes(30),\n        vpc=vpc\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['image', 'capacity_provider_strategies', 'circuit_breaker', 'cluster', 'command', 'deployment_controller', 'enable_ecs_managed_tags', 'enable_execute_command', 'enable_logging', 'environment', 'family', 'log_driver', 'max_healthy_percent', 'max_receive_count', 'max_scaling_capacity', 'min_healthy_percent', 'min_scaling_capacity', 'propagate_tags', 'queue', 'retention_period', 'scaling_steps', 'secrets', 'service_name', 'visibility_timeout', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.QueueProcessingServiceBaseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.QueueProcessingServiceBasePropsDefConfig] = pydantic.Field(None)


class QueueProcessingServiceBasePropsDefConfig(pydantic.BaseModel):
    image_config: typing.Optional[models.aws_ecs.ContainerImageDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.ScheduledEc2TaskDefinitionOptions
class ScheduledEc2TaskDefinitionOptionsDef(BaseStruct):
    task_definition: typing.Union[models.aws_ecs.Ec2TaskDefinitionDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The task definition to use for tasks in the service. One of image or taskDefinition must be specified. [disable-awslint:ref-via-interface] Default: - none\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ecs as ecs\n    from aws_cdk import aws_ecs_patterns as ecs_patterns\n\n    # ec2_task_definition: ecs.Ec2TaskDefinition\n\n    scheduled_ec2_task_definition_options = ecs_patterns.ScheduledEc2TaskDefinitionOptions(\n        task_definition=ec2_task_definition\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['task_definition']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ScheduledEc2TaskDefinitionOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.ScheduledEc2TaskDefinitionOptionsDefConfig] = pydantic.Field(None)


class ScheduledEc2TaskDefinitionOptionsDefConfig(pydantic.BaseModel):
    task_definition_config: typing.Optional[models.aws_ecs.Ec2TaskDefinitionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.ScheduledEc2TaskImageOptions
class ScheduledEc2TaskImageOptionsDef(BaseStruct):
    image: typing.Union[models.aws_ecs.ContainerImageDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The image used to start a container. Image or taskDefinition must be specified, but not both. Default: - none\n')
    command: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The command that is passed to the container. If you provide a shell command as a single string, you have to quote command-line arguments. Default: - CMD value built into container image.\n')
    environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The environment variables to pass to the container. Default: none\n')
    log_driver: typing.Optional[models.aws_ecs.LogDriverDef] = pydantic.Field(None, description='The log driver to use. Default: - AwsLogDriver if enableLogging is true\n')
    secrets: typing.Optional[typing.Mapping[str, models.aws_ecs.SecretDef]] = pydantic.Field(None, description='The secret to expose to the container as an environment variable. Default: - No secret environment variables.\n')
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of CPU units to reserve for the container. Default: none\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The hard limit (in MiB) of memory to present to the container. If your container attempts to exceed the allocated memory, the container is terminated. At least one of memoryLimitMiB and memoryReservationMiB is required for non-Fargate services. Default: - No memory limit.\n')
    memory_reservation_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The soft limit (in MiB) of memory to reserve for the container. When system memory is under contention, Docker attempts to keep the container memory within the limit. If the container requires more memory, it can consume up to the value specified by the Memory property or all of the available memory on the container instance—whichever comes first. At least one of memoryLimitMiB and memoryReservationMiB is required for non-Fargate services. Default: - No memory reserved.\n\n:exampleMetadata: infused\n\nExample::\n\n    # Instantiate an Amazon EC2 Task to run at a scheduled interval\n    # cluster: ecs.Cluster\n\n    ecs_scheduled_task = ecs_patterns.ScheduledEc2Task(self, "ScheduledTask",\n        cluster=cluster,\n        scheduled_ec2_task_image_options=ecsPatterns.ScheduledEc2TaskImageOptions(\n            image=ecs.ContainerImage.from_registry("amazon/amazon-ecs-sample"),\n            memory_limit_mi_b=256,\n            environment={"name": "TRIGGER", "value": "CloudWatch Events"}\n        ),\n        schedule=appscaling.Schedule.expression("rate(1 minute)"),\n        enabled=True,\n        rule_name="sample-scheduled-task-rule"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['image', 'command', 'environment', 'log_driver', 'secrets', 'cpu', 'memory_limit_mib', 'memory_reservation_mib']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ScheduledEc2TaskImageOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.ScheduledEc2TaskImageOptionsDefConfig] = pydantic.Field(None)


class ScheduledEc2TaskImageOptionsDefConfig(pydantic.BaseModel):
    image_config: typing.Optional[models.aws_ecs.ContainerImageDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.ScheduledEc2TaskProps
class ScheduledEc2TaskPropsDef(BaseStruct):
    schedule: typing.Union[models.aws_applicationautoscaling.ScheduleDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The schedule or rate (frequency) that determines when CloudWatch Events runs the rule. For more information, see `Schedule Expression Syntax for Rules <https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html>`_ in the Amazon CloudWatch User Guide.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    desired_task_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. Default: 1\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the rule is enabled. Default: true\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Default: - Tags will not be propagated\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: - AWS CloudFormation generates a unique physical ID and uses that ID for the rule name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_.\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='Existing security groups to use for your service. Default: - a new security group will be created.\n')
    subnet_selection: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description="In what subnets to place the task's ENIs. (Only applicable in case the TaskDefinition is configured for AwsVpc networking) Default: Private subnets\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.aws_events_targets.TagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The metadata that you apply to the task to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. Default: - No tags are applied to the task\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n')
    scheduled_ec2_task_definition_options: typing.Union[models.aws_ecs_patterns.ScheduledEc2TaskDefinitionOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties to define if using an existing TaskDefinition in this construct. ScheduledEc2TaskDefinitionOptions or ScheduledEc2TaskImageOptions must be defined, but not both. Default: none\n')
    scheduled_ec2_task_image_options: typing.Union[models.aws_ecs_patterns.ScheduledEc2TaskImageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties to define if the construct is to create a TaskDefinition. ScheduledEc2TaskDefinitionOptions or ScheduledEc2TaskImageOptions must be defined, but not both. Default: none\n\n:exampleMetadata: infused\n\nExample::\n\n    # Instantiate an Amazon EC2 Task to run at a scheduled interval\n    # cluster: ecs.Cluster\n\n    ecs_scheduled_task = ecs_patterns.ScheduledEc2Task(self, "ScheduledTask",\n        cluster=cluster,\n        scheduled_ec2_task_image_options=ecsPatterns.ScheduledEc2TaskImageOptions(\n            image=ecs.ContainerImage.from_registry("amazon/amazon-ecs-sample"),\n            memory_limit_mi_b=256,\n            environment={"name": "TRIGGER", "value": "CloudWatch Events"}\n        ),\n        schedule=appscaling.Schedule.expression("rate(1 minute)"),\n        enabled=True,\n        rule_name="sample-scheduled-task-rule"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['schedule', 'cluster', 'desired_task_count', 'enabled', 'propagate_tags', 'rule_name', 'security_groups', 'subnet_selection', 'tags', 'vpc', 'scheduled_ec2_task_definition_options', 'scheduled_ec2_task_image_options']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ScheduledEc2TaskProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.ScheduledEc2TaskPropsDefConfig] = pydantic.Field(None)


class ScheduledEc2TaskPropsDefConfig(pydantic.BaseModel):
    schedule_config: typing.Optional[models.aws_applicationautoscaling.ScheduleDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.ScheduledFargateTaskDefinitionOptions
class ScheduledFargateTaskDefinitionOptionsDef(BaseStruct):
    task_definition: typing.Union[models.aws_ecs.FargateTaskDefinitionDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The task definition to use for tasks in the service. Image or taskDefinition must be specified, but not both. [disable-awslint:ref-via-interface] Default: - none\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ecs as ecs\n    from aws_cdk import aws_ecs_patterns as ecs_patterns\n\n    # fargate_task_definition: ecs.FargateTaskDefinition\n\n    scheduled_fargate_task_definition_options = ecs_patterns.ScheduledFargateTaskDefinitionOptions(\n        task_definition=fargate_task_definition\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['task_definition']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ScheduledFargateTaskDefinitionOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.ScheduledFargateTaskDefinitionOptionsDefConfig] = pydantic.Field(None)


class ScheduledFargateTaskDefinitionOptionsDefConfig(pydantic.BaseModel):
    task_definition_config: typing.Optional[models.aws_ecs.FargateTaskDefinitionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.ScheduledFargateTaskImageOptions
class ScheduledFargateTaskImageOptionsDef(BaseStruct):
    image: typing.Union[models.aws_ecs.ContainerImageDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The image used to start a container. Image or taskDefinition must be specified, but not both. Default: - none\n')
    command: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The command that is passed to the container. If you provide a shell command as a single string, you have to quote command-line arguments. Default: - CMD value built into container image.\n')
    environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The environment variables to pass to the container. Default: none\n')
    log_driver: typing.Optional[models.aws_ecs.LogDriverDef] = pydantic.Field(None, description='The log driver to use. Default: - AwsLogDriver if enableLogging is true\n')
    secrets: typing.Optional[typing.Mapping[str, models.aws_ecs.SecretDef]] = pydantic.Field(None, description='The secret to expose to the container as an environment variable. Default: - No secret environment variables.\n')
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments 8192 (8 vCPU) - Available memory values: Between 16GB and 60GB in 4GB increments 16384 (16 vCPU) - Available memory values: Between 32GB and 120GB in 8GB increments This default is set in the underlying FargateTaskDefinition construct. Default: 256\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The amount (in MiB) of memory used by the task. This field is required and you must use one of the following values, which determines your range of valid values for the cpu parameter: 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB) - Available cpu values: 256 (.25 vCPU) 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB) - Available cpu values: 512 (.5 vCPU) 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB) - Available cpu values: 1024 (1 vCPU) Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB) - Available cpu values: 2048 (2 vCPU) Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB) - Available cpu values: 4096 (4 vCPU) Between 16384 (16 GB) and 61440 (60 GB) in increments of 4096 (4 GB) - Available cpu values: 8192 (8 vCPU) Between 32768 (32 GB) and 122880 (120 GB) in increments of 8192 (8 GB) - Available cpu values: 16384 (16 vCPU) This default is set in the underlying FargateTaskDefinition construct. Default: 512\n')
    platform_version: typing.Optional[aws_cdk.aws_ecs.FargatePlatformVersion] = pydantic.Field(None, description='The platform version on which to run your service. If one is not specified, the LATEST platform version is used by default. For more information, see `AWS Fargate Platform Versions <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html>`_ in the Amazon Elastic Container Service Developer Guide. Default: Latest\n')
    runtime_platform: typing.Union[models.aws_ecs.RuntimePlatformDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The runtime platform of the task definition. Default: - If the property is undefined, ``operatingSystemFamily`` is LINUX and ``cpuArchitecture`` is X86_64\n')
    task_definition: typing.Optional[models.aws_ecs.FargateTaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. TaskDefinition or TaskImageOptions must be specified, but not both. [disable-awslint:ref-via-interface] Default: - none\n\n:exampleMetadata: infused\n\nExample::\n\n    vpc = ec2.Vpc(self, "Vpc", max_azs=1)\n    cluster = ecs.Cluster(self, "EcsCluster", vpc=vpc)\n    scheduled_fargate_task = ecs_patterns.ScheduledFargateTask(self, "ScheduledFargateTask",\n        cluster=cluster,\n        scheduled_fargate_task_image_options=ecsPatterns.ScheduledFargateTaskImageOptions(\n            image=ecs.ContainerImage.from_registry("amazon/amazon-ecs-sample"),\n            memory_limit_mi_b=512\n        ),\n        schedule=appscaling.Schedule.expression("rate(1 minute)"),\n        tags=[Tag(\n            key="my-tag",\n            value="my-tag-value"\n        )\n        ]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['image', 'command', 'environment', 'log_driver', 'secrets', 'cpu', 'memory_limit_mib', 'platform_version', 'runtime_platform', 'task_definition']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ScheduledFargateTaskImageOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.ScheduledFargateTaskImageOptionsDefConfig] = pydantic.Field(None)


class ScheduledFargateTaskImageOptionsDefConfig(pydantic.BaseModel):
    image_config: typing.Optional[models.aws_ecs.ContainerImageDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.ScheduledFargateTaskProps
class ScheduledFargateTaskPropsDef(BaseStruct):
    schedule: typing.Union[models.aws_applicationautoscaling.ScheduleDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The schedule or rate (frequency) that determines when CloudWatch Events runs the rule. For more information, see `Schedule Expression Syntax for Rules <https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html>`_ in the Amazon CloudWatch User Guide.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    desired_task_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. Default: 1\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the rule is enabled. Default: true\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Default: - Tags will not be propagated\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: - AWS CloudFormation generates a unique physical ID and uses that ID for the rule name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_.\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='Existing security groups to use for your service. Default: - a new security group will be created.\n')
    subnet_selection: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description="In what subnets to place the task's ENIs. (Only applicable in case the TaskDefinition is configured for AwsVpc networking) Default: Private subnets\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.aws_events_targets.TagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The metadata that you apply to the task to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. Default: - No tags are applied to the task\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n')
    cpu: typing.Union[int, float, None] = pydantic.Field(None, description='The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments 8192 (8 vCPU) - Available memory values: Between 16GB and 60GB in 4GB increments 16384 (16 vCPU) - Available memory values: Between 32GB and 120GB in 8GB increments This default is set in the underlying FargateTaskDefinition construct. Default: 256\n')
    memory_limit_mib: typing.Union[int, float, None] = pydantic.Field(None, description='The amount (in MiB) of memory used by the task. This field is required and you must use one of the following values, which determines your range of valid values for the cpu parameter: 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB) - Available cpu values: 256 (.25 vCPU) 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB) - Available cpu values: 512 (.5 vCPU) 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB) - Available cpu values: 1024 (1 vCPU) Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB) - Available cpu values: 2048 (2 vCPU) Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB) - Available cpu values: 4096 (4 vCPU) Between 16384 (16 GB) and 61440 (60 GB) in increments of 4096 (4 GB) - Available cpu values: 8192 (8 vCPU) Between 32768 (32 GB) and 122880 (120 GB) in increments of 8192 (8 GB) - Available cpu values: 16384 (16 vCPU) This default is set in the underlying FargateTaskDefinition construct. Default: 512\n')
    platform_version: typing.Optional[aws_cdk.aws_ecs.FargatePlatformVersion] = pydantic.Field(None, description='The platform version on which to run your service. If one is not specified, the LATEST platform version is used by default. For more information, see `AWS Fargate Platform Versions <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html>`_ in the Amazon Elastic Container Service Developer Guide. Default: Latest\n')
    runtime_platform: typing.Union[models.aws_ecs.RuntimePlatformDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The runtime platform of the task definition. Default: - If the property is undefined, ``operatingSystemFamily`` is LINUX and ``cpuArchitecture`` is X86_64\n')
    task_definition: typing.Optional[models.aws_ecs.FargateTaskDefinitionDef] = pydantic.Field(None, description='The task definition to use for tasks in the service. TaskDefinition or TaskImageOptions must be specified, but not both. [disable-awslint:ref-via-interface] Default: - none\n')
    scheduled_fargate_task_definition_options: typing.Union[models.aws_ecs_patterns.ScheduledFargateTaskDefinitionOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties to define if using an existing TaskDefinition in this construct. ScheduledFargateTaskDefinitionOptions or ScheduledFargateTaskImageOptions must be defined, but not both. Default: none\n')
    scheduled_fargate_task_image_options: typing.Union[models.aws_ecs_patterns.ScheduledFargateTaskImageOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties to define if the construct is to create a TaskDefinition. ScheduledFargateTaskDefinitionOptions or ScheduledFargateTaskImageOptions must be defined, but not both. Default: none\n\n:exampleMetadata: infused\n\nExample::\n\n    vpc = ec2.Vpc(self, "Vpc", max_azs=1)\n    cluster = ecs.Cluster(self, "EcsCluster", vpc=vpc)\n    scheduled_fargate_task = ecs_patterns.ScheduledFargateTask(self, "ScheduledFargateTask",\n        cluster=cluster,\n        scheduled_fargate_task_image_options=ecsPatterns.ScheduledFargateTaskImageOptions(\n            image=ecs.ContainerImage.from_registry("amazon/amazon-ecs-sample"),\n            memory_limit_mi_b=512\n        ),\n        schedule=appscaling.Schedule.expression("rate(1 minute)"),\n        tags=[Tag(\n            key="my-tag",\n            value="my-tag-value"\n        )\n        ]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['schedule', 'cluster', 'desired_task_count', 'enabled', 'propagate_tags', 'rule_name', 'security_groups', 'subnet_selection', 'tags', 'vpc', 'cpu', 'memory_limit_mib', 'platform_version', 'runtime_platform', 'task_definition', 'scheduled_fargate_task_definition_options', 'scheduled_fargate_task_image_options']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ScheduledFargateTaskProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.ScheduledFargateTaskPropsDefConfig] = pydantic.Field(None)


class ScheduledFargateTaskPropsDefConfig(pydantic.BaseModel):
    schedule_config: typing.Optional[models.aws_applicationautoscaling.ScheduleDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.ScheduledTaskBaseProps
class ScheduledTaskBasePropsDef(BaseStruct):
    schedule: typing.Union[models.aws_applicationautoscaling.ScheduleDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The schedule or rate (frequency) that determines when CloudWatch Events runs the rule. For more information, see `Schedule Expression Syntax for Rules <https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html>`_ in the Amazon CloudWatch User Guide.\n')
    cluster: typing.Optional[typing.Union[models.aws_ecs.ClusterDef]] = pydantic.Field(None, description='The name of the cluster that hosts the service. If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc. Default: - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n')
    desired_task_count: typing.Union[int, float, None] = pydantic.Field(None, description='The desired number of instantiations of the task definition to keep running on the service. Default: 1\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the rule is enabled. Default: true\n')
    propagate_tags: typing.Optional[aws_cdk.aws_ecs.PropagatedTagSource] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Default: - Tags will not be propagated\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: - AWS CloudFormation generates a unique physical ID and uses that ID for the rule name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_.\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='Existing security groups to use for your service. Default: - a new security group will be created.\n')
    subnet_selection: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description="In what subnets to place the task's ENIs. (Only applicable in case the TaskDefinition is configured for AwsVpc networking) Default: Private subnets\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.aws_events_targets.TagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The metadata that you apply to the task to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. Default: - No tags are applied to the task\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed. If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster. Default: - uses the VPC defined in the cluster or creates a new VPC.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_applicationautoscaling as appscaling\n    from aws_cdk import aws_ec2 as ec2\n    from aws_cdk import aws_ecs as ecs\n    from aws_cdk import aws_ecs_patterns as ecs_patterns\n\n    # cluster: ecs.Cluster\n    # schedule: appscaling.Schedule\n    # security_group: ec2.SecurityGroup\n    # subnet: ec2.Subnet\n    # subnet_filter: ec2.SubnetFilter\n    # vpc: ec2.Vpc\n\n    scheduled_task_base_props = ecs_patterns.ScheduledTaskBaseProps(\n        schedule=schedule,\n\n        # the properties below are optional\n        cluster=cluster,\n        desired_task_count=123,\n        enabled=False,\n        propagate_tags=ecs.PropagatedTagSource.SERVICE,\n        rule_name="ruleName",\n        security_groups=[security_group],\n        subnet_selection=ec2.SubnetSelection(\n            availability_zones=["availabilityZones"],\n            one_per_az=False,\n            subnet_filters=[subnet_filter],\n            subnet_group_name="subnetGroupName",\n            subnets=[subnet],\n            subnet_type=ec2.SubnetType.PRIVATE_ISOLATED\n        ),\n        tags=[Tag(\n            key="key",\n            value="value"\n        )],\n        vpc=vpc\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['schedule', 'cluster', 'desired_task_count', 'enabled', 'propagate_tags', 'rule_name', 'security_groups', 'subnet_selection', 'tags', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ScheduledTaskBaseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.ScheduledTaskBasePropsDefConfig] = pydantic.Field(None)


class ScheduledTaskBasePropsDefConfig(pydantic.BaseModel):
    schedule_config: typing.Optional[models.aws_applicationautoscaling.ScheduleDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.ScheduledTaskImageProps
class ScheduledTaskImagePropsDef(BaseStruct):
    image: typing.Union[models.aws_ecs.ContainerImageDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The image used to start a container. Image or taskDefinition must be specified, but not both. Default: - none')
    command: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The command that is passed to the container. If you provide a shell command as a single string, you have to quote command-line arguments. Default: - CMD value built into container image.\n')
    environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The environment variables to pass to the container. Default: none\n')
    log_driver: typing.Optional[models.aws_ecs.LogDriverDef] = pydantic.Field(None, description='The log driver to use. Default: - AwsLogDriver if enableLogging is true\n')
    secrets: typing.Optional[typing.Mapping[str, models.aws_ecs.SecretDef]] = pydantic.Field(None, description='The secret to expose to the container as an environment variable. Default: - No secret environment variables.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ecs as ecs\n    from aws_cdk import aws_ecs_patterns as ecs_patterns\n\n    # container_image: ecs.ContainerImage\n    # log_driver: ecs.LogDriver\n    # secret: ecs.Secret\n\n    scheduled_task_image_props = ecs_patterns.ScheduledTaskImageProps(\n        image=container_image,\n\n        # the properties below are optional\n        command=["command"],\n        environment={\n            "environment_key": "environment"\n        },\n        log_driver=log_driver,\n        secrets={\n            "secrets_key": secret\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['image', 'command', 'environment', 'log_driver', 'secrets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecs_patterns.ScheduledTaskImageProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecs_patterns.ScheduledTaskImagePropsDefConfig] = pydantic.Field(None)


class ScheduledTaskImagePropsDefConfig(pydantic.BaseModel):
    image_config: typing.Optional[models.aws_ecs.ContainerImageDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedServiceRecordType
# skipping emum

#  autogenerated from aws_cdk.aws_ecs_patterns.NetworkLoadBalancedServiceRecordType
# skipping emum

class ModuleModel(pydantic.BaseModel):
    ApplicationLoadBalancedServiceBase: typing.Optional[dict[str, models.aws_ecs_patterns.ApplicationLoadBalancedServiceBaseDef]] = pydantic.Field(None)
    ApplicationMultipleTargetGroupsServiceBase: typing.Optional[dict[str, models.aws_ecs_patterns.ApplicationMultipleTargetGroupsServiceBaseDef]] = pydantic.Field(None)
    NetworkLoadBalancedServiceBase: typing.Optional[dict[str, models.aws_ecs_patterns.NetworkLoadBalancedServiceBaseDef]] = pydantic.Field(None)
    NetworkMultipleTargetGroupsServiceBase: typing.Optional[dict[str, models.aws_ecs_patterns.NetworkMultipleTargetGroupsServiceBaseDef]] = pydantic.Field(None)
    QueueProcessingServiceBase: typing.Optional[dict[str, models.aws_ecs_patterns.QueueProcessingServiceBaseDef]] = pydantic.Field(None)
    ScheduledTaskBase: typing.Optional[dict[str, models.aws_ecs_patterns.ScheduledTaskBaseDef]] = pydantic.Field(None)
    ApplicationLoadBalancedEc2Service: typing.Optional[dict[str, models.aws_ecs_patterns.ApplicationLoadBalancedEc2ServiceDef]] = pydantic.Field(None)
    ApplicationLoadBalancedFargateService: typing.Optional[dict[str, models.aws_ecs_patterns.ApplicationLoadBalancedFargateServiceDef]] = pydantic.Field(None)
    ApplicationMultipleTargetGroupsEc2Service: typing.Optional[dict[str, models.aws_ecs_patterns.ApplicationMultipleTargetGroupsEc2ServiceDef]] = pydantic.Field(None)
    ApplicationMultipleTargetGroupsFargateService: typing.Optional[dict[str, models.aws_ecs_patterns.ApplicationMultipleTargetGroupsFargateServiceDef]] = pydantic.Field(None)
    NetworkLoadBalancedEc2Service: typing.Optional[dict[str, models.aws_ecs_patterns.NetworkLoadBalancedEc2ServiceDef]] = pydantic.Field(None)
    NetworkLoadBalancedFargateService: typing.Optional[dict[str, models.aws_ecs_patterns.NetworkLoadBalancedFargateServiceDef]] = pydantic.Field(None)
    NetworkMultipleTargetGroupsEc2Service: typing.Optional[dict[str, models.aws_ecs_patterns.NetworkMultipleTargetGroupsEc2ServiceDef]] = pydantic.Field(None)
    NetworkMultipleTargetGroupsFargateService: typing.Optional[dict[str, models.aws_ecs_patterns.NetworkMultipleTargetGroupsFargateServiceDef]] = pydantic.Field(None)
    QueueProcessingEc2Service: typing.Optional[dict[str, models.aws_ecs_patterns.QueueProcessingEc2ServiceDef]] = pydantic.Field(None)
    QueueProcessingFargateService: typing.Optional[dict[str, models.aws_ecs_patterns.QueueProcessingFargateServiceDef]] = pydantic.Field(None)
    ScheduledEc2Task: typing.Optional[dict[str, models.aws_ecs_patterns.ScheduledEc2TaskDef]] = pydantic.Field(None)
    ScheduledFargateTask: typing.Optional[dict[str, models.aws_ecs_patterns.ScheduledFargateTaskDef]] = pydantic.Field(None)
    ApplicationListenerProps: typing.Optional[dict[str, models.aws_ecs_patterns.ApplicationListenerPropsDef]] = pydantic.Field(None)
    ApplicationLoadBalancedEc2ServiceProps: typing.Optional[dict[str, models.aws_ecs_patterns.ApplicationLoadBalancedEc2ServicePropsDef]] = pydantic.Field(None)
    ApplicationLoadBalancedFargateServiceProps: typing.Optional[dict[str, models.aws_ecs_patterns.ApplicationLoadBalancedFargateServicePropsDef]] = pydantic.Field(None)
    ApplicationLoadBalancedServiceBaseProps: typing.Optional[dict[str, models.aws_ecs_patterns.ApplicationLoadBalancedServiceBasePropsDef]] = pydantic.Field(None)
    ApplicationLoadBalancedTaskImageOptions: typing.Optional[dict[str, models.aws_ecs_patterns.ApplicationLoadBalancedTaskImageOptionsDef]] = pydantic.Field(None)
    ApplicationLoadBalancedTaskImageProps: typing.Optional[dict[str, models.aws_ecs_patterns.ApplicationLoadBalancedTaskImagePropsDef]] = pydantic.Field(None)
    ApplicationLoadBalancerProps: typing.Optional[dict[str, models.aws_ecs_patterns.ApplicationLoadBalancerPropsDef]] = pydantic.Field(None)
    ApplicationMultipleTargetGroupsEc2ServiceProps: typing.Optional[dict[str, models.aws_ecs_patterns.ApplicationMultipleTargetGroupsEc2ServicePropsDef]] = pydantic.Field(None)
    ApplicationMultipleTargetGroupsFargateServiceProps: typing.Optional[dict[str, models.aws_ecs_patterns.ApplicationMultipleTargetGroupsFargateServicePropsDef]] = pydantic.Field(None)
    ApplicationMultipleTargetGroupsServiceBaseProps: typing.Optional[dict[str, models.aws_ecs_patterns.ApplicationMultipleTargetGroupsServiceBasePropsDef]] = pydantic.Field(None)
    ApplicationTargetProps: typing.Optional[dict[str, models.aws_ecs_patterns.ApplicationTargetPropsDef]] = pydantic.Field(None)
    FargateServiceBaseProps: typing.Optional[dict[str, models.aws_ecs_patterns.FargateServiceBasePropsDef]] = pydantic.Field(None)
    NetworkListenerProps: typing.Optional[dict[str, models.aws_ecs_patterns.NetworkListenerPropsDef]] = pydantic.Field(None)
    NetworkLoadBalancedEc2ServiceProps: typing.Optional[dict[str, models.aws_ecs_patterns.NetworkLoadBalancedEc2ServicePropsDef]] = pydantic.Field(None)
    NetworkLoadBalancedFargateServiceProps: typing.Optional[dict[str, models.aws_ecs_patterns.NetworkLoadBalancedFargateServicePropsDef]] = pydantic.Field(None)
    NetworkLoadBalancedServiceBaseProps: typing.Optional[dict[str, models.aws_ecs_patterns.NetworkLoadBalancedServiceBasePropsDef]] = pydantic.Field(None)
    NetworkLoadBalancedTaskImageOptions: typing.Optional[dict[str, models.aws_ecs_patterns.NetworkLoadBalancedTaskImageOptionsDef]] = pydantic.Field(None)
    NetworkLoadBalancedTaskImageProps: typing.Optional[dict[str, models.aws_ecs_patterns.NetworkLoadBalancedTaskImagePropsDef]] = pydantic.Field(None)
    NetworkLoadBalancerProps: typing.Optional[dict[str, models.aws_ecs_patterns.NetworkLoadBalancerPropsDef]] = pydantic.Field(None)
    NetworkMultipleTargetGroupsEc2ServiceProps: typing.Optional[dict[str, models.aws_ecs_patterns.NetworkMultipleTargetGroupsEc2ServicePropsDef]] = pydantic.Field(None)
    NetworkMultipleTargetGroupsFargateServiceProps: typing.Optional[dict[str, models.aws_ecs_patterns.NetworkMultipleTargetGroupsFargateServicePropsDef]] = pydantic.Field(None)
    NetworkMultipleTargetGroupsServiceBaseProps: typing.Optional[dict[str, models.aws_ecs_patterns.NetworkMultipleTargetGroupsServiceBasePropsDef]] = pydantic.Field(None)
    NetworkTargetProps: typing.Optional[dict[str, models.aws_ecs_patterns.NetworkTargetPropsDef]] = pydantic.Field(None)
    QueueProcessingEc2ServiceProps: typing.Optional[dict[str, models.aws_ecs_patterns.QueueProcessingEc2ServicePropsDef]] = pydantic.Field(None)
    QueueProcessingFargateServiceProps: typing.Optional[dict[str, models.aws_ecs_patterns.QueueProcessingFargateServicePropsDef]] = pydantic.Field(None)
    QueueProcessingServiceBaseProps: typing.Optional[dict[str, models.aws_ecs_patterns.QueueProcessingServiceBasePropsDef]] = pydantic.Field(None)
    ScheduledEc2TaskDefinitionOptions: typing.Optional[dict[str, models.aws_ecs_patterns.ScheduledEc2TaskDefinitionOptionsDef]] = pydantic.Field(None)
    ScheduledEc2TaskImageOptions: typing.Optional[dict[str, models.aws_ecs_patterns.ScheduledEc2TaskImageOptionsDef]] = pydantic.Field(None)
    ScheduledEc2TaskProps: typing.Optional[dict[str, models.aws_ecs_patterns.ScheduledEc2TaskPropsDef]] = pydantic.Field(None)
    ScheduledFargateTaskDefinitionOptions: typing.Optional[dict[str, models.aws_ecs_patterns.ScheduledFargateTaskDefinitionOptionsDef]] = pydantic.Field(None)
    ScheduledFargateTaskImageOptions: typing.Optional[dict[str, models.aws_ecs_patterns.ScheduledFargateTaskImageOptionsDef]] = pydantic.Field(None)
    ScheduledFargateTaskProps: typing.Optional[dict[str, models.aws_ecs_patterns.ScheduledFargateTaskPropsDef]] = pydantic.Field(None)
    ScheduledTaskBaseProps: typing.Optional[dict[str, models.aws_ecs_patterns.ScheduledTaskBasePropsDef]] = pydantic.Field(None)
    ScheduledTaskImageProps: typing.Optional[dict[str, models.aws_ecs_patterns.ScheduledTaskImagePropsDef]] = pydantic.Field(None)
    ...

import models
