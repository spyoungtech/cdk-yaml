from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_verifiedpermissions.CfnIdentitySource.CognitoGroupConfigurationProperty
class CfnIdentitySource_CognitoGroupConfigurationPropertyDef(BaseStruct):
    group_entity_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the schema entity type that\'s mapped to the user pool group. Defaults to ``AWS::CognitoGroup`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-verifiedpermissions-identitysource-cognitogroupconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_verifiedpermissions as verifiedpermissions\n\n    cognito_group_configuration_property = verifiedpermissions.CfnIdentitySource.CognitoGroupConfigurationProperty(\n        group_entity_type="groupEntityType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['group_entity_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_verifiedpermissions.CfnIdentitySource.CognitoGroupConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_verifiedpermissions.CfnIdentitySource.CognitoUserPoolConfigurationProperty
class CfnIdentitySource_CognitoUserPoolConfigurationPropertyDef(BaseStruct):
    user_pool_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The `Amazon Resource Name (ARN) <https://docs.aws.amazon.com//general/latest/gr/aws-arns-and-namespaces.html>`_ of the Amazon Cognito user pool that contains the identities to be authorized.\n')
    client_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The unique application client IDs that are associated with the specified Amazon Cognito user pool. Example: ``"ClientIds": ["&ExampleCogClientId;"]``\n')
    group_configuration: typing.Union[models.UnsupportedResource, models.aws_verifiedpermissions.CfnIdentitySource_CognitoGroupConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of entity that a policy store maps to groups from an Amazon Cognito user pool identity source.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-verifiedpermissions-identitysource-cognitouserpoolconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_verifiedpermissions as verifiedpermissions\n\n    cognito_user_pool_configuration_property = verifiedpermissions.CfnIdentitySource.CognitoUserPoolConfigurationProperty(\n        user_pool_arn="userPoolArn",\n\n        # the properties below are optional\n        client_ids=["clientIds"],\n        group_configuration=verifiedpermissions.CfnIdentitySource.CognitoGroupConfigurationProperty(\n            group_entity_type="groupEntityType"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['user_pool_arn', 'client_ids', 'group_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_verifiedpermissions.CfnIdentitySource.CognitoUserPoolConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_verifiedpermissions.CfnIdentitySource.IdentitySourceConfigurationProperty
class CfnIdentitySource_IdentitySourceConfigurationPropertyDef(BaseStruct):
    cognito_user_pool_configuration: typing.Union[models.UnsupportedResource, models.aws_verifiedpermissions.CfnIdentitySource_CognitoUserPoolConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A structure that contains configuration information used when creating or updating an identity source that represents a connection to an Amazon Cognito user pool used as an identity provider for Verified Permissions .\n')
    open_id_connect_configuration: typing.Union[models.UnsupportedResource, aws_cdk.aws_verifiedpermissions.CfnIdentitySource.OpenIdConnectConfigurationProperty, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    _init_params: typing.ClassVar[list[str]] = ['cognito_user_pool_configuration', 'open_id_connect_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_verifiedpermissions.CfnIdentitySource.IdentitySourceConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_verifiedpermissions.CfnIdentitySource.IdentitySourceDetailsProperty
class CfnIdentitySource_IdentitySourceDetailsPropertyDef(BaseStruct):
    client_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    discovery_url: typing.Optional[str] = pydantic.Field(None, description='')
    open_id_issuer: typing.Optional[str] = pydantic.Field(None, description='')
    user_pool_arn: typing.Optional[str] = pydantic.Field(None, description='')
    _init_params: typing.ClassVar[list[str]] = ['client_ids', 'discovery_url', 'open_id_issuer', 'user_pool_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_verifiedpermissions.CfnIdentitySource.IdentitySourceDetailsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_verifiedpermissions.CfnPolicy.EntityIdentifierProperty
class CfnPolicy_EntityIdentifierPropertyDef(BaseStruct):
    entity_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of an entity. ``"entityId":" *identifier* "``\n')
    entity_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of an entity. Example: ``"entityType":" *typeName* "``\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-verifiedpermissions-policy-entityidentifier.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_verifiedpermissions as verifiedpermissions\n\n    entity_identifier_property = verifiedpermissions.CfnPolicy.EntityIdentifierProperty(\n        entity_id="entityId",\n        entity_type="entityType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['entity_id', 'entity_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_verifiedpermissions.CfnPolicy.EntityIdentifierProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_verifiedpermissions.CfnPolicy.PolicyDefinitionProperty
class CfnPolicy_PolicyDefinitionPropertyDef(BaseStruct):
    static: typing.Union[models.UnsupportedResource, models.aws_verifiedpermissions.CfnPolicy_StaticPolicyDefinitionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="A structure that describes a static policy. An static policy doesn't use a template or allow placeholders for entities.\n")
    template_linked: typing.Union[models.UnsupportedResource, models.aws_verifiedpermissions.CfnPolicy_TemplateLinkedPolicyDefinitionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A structure that describes a policy that was instantiated from a template. The template can specify placeholders for ``principal`` and ``resource`` . When you use `CreatePolicy <https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreatePolicy.html>`_ to create a policy from a template, you specify the exact principal and resource to use for the instantiated policy.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-verifiedpermissions-policy-policydefinition.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_verifiedpermissions as verifiedpermissions\n\n    policy_definition_property = verifiedpermissions.CfnPolicy.PolicyDefinitionProperty(\n        static=verifiedpermissions.CfnPolicy.StaticPolicyDefinitionProperty(\n            statement="statement",\n\n            # the properties below are optional\n            description="description"\n        ),\n        template_linked=verifiedpermissions.CfnPolicy.TemplateLinkedPolicyDefinitionProperty(\n            policy_template_id="policyTemplateId",\n\n            # the properties below are optional\n            principal=verifiedpermissions.CfnPolicy.EntityIdentifierProperty(\n                entity_id="entityId",\n                entity_type="entityType"\n            ),\n            resource=verifiedpermissions.CfnPolicy.EntityIdentifierProperty(\n                entity_id="entityId",\n                entity_type="entityType"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['static', 'template_linked']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_verifiedpermissions.CfnPolicy.PolicyDefinitionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_verifiedpermissions.CfnPolicy.StaticPolicyDefinitionProperty
class CfnPolicy_StaticPolicyDefinitionPropertyDef(BaseStruct):
    statement: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The policy content of the static policy, written in the Cedar policy language.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the static policy.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-verifiedpermissions-policy-staticpolicydefinition.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_verifiedpermissions as verifiedpermissions\n\n    static_policy_definition_property = verifiedpermissions.CfnPolicy.StaticPolicyDefinitionProperty(\n        statement="statement",\n\n        # the properties below are optional\n        description="description"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['statement', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_verifiedpermissions.CfnPolicy.StaticPolicyDefinitionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_verifiedpermissions.CfnPolicy.TemplateLinkedPolicyDefinitionProperty
class CfnPolicy_TemplateLinkedPolicyDefinitionPropertyDef(BaseStruct):
    policy_template_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique identifier of the policy template used to create this policy.\n')
    principal: typing.Union[models.UnsupportedResource, models.aws_verifiedpermissions.CfnPolicy_EntityIdentifierPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The principal associated with this template-linked policy. Verified Permissions substitutes this principal for the ``?principal`` placeholder in the policy template when it evaluates an authorization request.\n')
    resource: typing.Union[models.UnsupportedResource, models.aws_verifiedpermissions.CfnPolicy_EntityIdentifierPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The resource associated with this template-linked policy. Verified Permissions substitutes this resource for the ``?resource`` placeholder in the policy template when it evaluates an authorization request.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-verifiedpermissions-policy-templatelinkedpolicydefinition.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_verifiedpermissions as verifiedpermissions\n\n    template_linked_policy_definition_property = verifiedpermissions.CfnPolicy.TemplateLinkedPolicyDefinitionProperty(\n        policy_template_id="policyTemplateId",\n\n        # the properties below are optional\n        principal=verifiedpermissions.CfnPolicy.EntityIdentifierProperty(\n            entity_id="entityId",\n            entity_type="entityType"\n        ),\n        resource=verifiedpermissions.CfnPolicy.EntityIdentifierProperty(\n            entity_id="entityId",\n            entity_type="entityType"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['policy_template_id', 'principal', 'resource']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_verifiedpermissions.CfnPolicy.TemplateLinkedPolicyDefinitionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_verifiedpermissions.CfnPolicyStore.SchemaDefinitionProperty
class CfnPolicyStore_SchemaDefinitionPropertyDef(BaseStruct):
    cedar_json: typing.Optional[str] = pydantic.Field(None, description='A JSON string representation of the schema supported by applications that use this policy store. For more information, see `Policy store schema <https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/schema.html>`_ in the *Amazon Verified Permissions User Guide* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-verifiedpermissions-policystore-schemadefinition.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_verifiedpermissions as verifiedpermissions\n\n    schema_definition_property = verifiedpermissions.CfnPolicyStore.SchemaDefinitionProperty(\n        cedar_json="cedarJson"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cedar_json']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_verifiedpermissions.CfnPolicyStore.SchemaDefinitionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_verifiedpermissions.CfnPolicyStore.ValidationSettingsProperty
class CfnPolicyStore_ValidationSettingsPropertyDef(BaseStruct):
    mode: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The validation mode currently configured for this policy store. The valid values are:. - *OFF* – Neither Verified Permissions nor Cedar perform any validation on policies. No validation errors are reported by either service. - *STRICT* – Requires a schema to be present in the policy store. Cedar performs validation on all submitted new or updated static policies and policy templates. Any that fail validation are rejected and Cedar doesn\'t store them in the policy store. .. epigraph:: If ``Mode=STRICT`` and the policy store doesn\'t contain a schema, Verified Permissions rejects all static policies and policy templates because there is no schema to validate against. To submit a static policy or policy template without a schema, you must turn off validation.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-verifiedpermissions-policystore-validationsettings.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_verifiedpermissions as verifiedpermissions\n\n    validation_settings_property = verifiedpermissions.CfnPolicyStore.ValidationSettingsProperty(\n        mode="mode"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['mode']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_verifiedpermissions.CfnPolicyStore.ValidationSettingsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_verifiedpermissions.CfnIdentitySource
class CfnIdentitySourceDef(BaseCfnResource):
    configuration: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_verifiedpermissions.CfnIdentitySource_IdentitySourceConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Contains configuration information about an identity source.\n')
    policy_store_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the ID of the policy store in which you want to store this identity source. Only policies and requests made using this policy store can reference identities from the identity provider configured in the new identity source.\n')
    principal_entity_type: typing.Optional[str] = pydantic.Field(None, description='Specifies the namespace and data type of the principals generated for identities authenticated by the new identity source.')
    _init_params: typing.ClassVar[list[str]] = ['configuration', 'policy_store_id', 'principal_entity_type']
    _method_names: typing.ClassVar[list[str]] = ['CognitoGroupConfigurationProperty', 'CognitoUserPoolConfigurationProperty', 'IdentitySourceConfigurationProperty', 'IdentitySourceDetailsProperty', 'OpenIdConnectAccessTokenConfigurationProperty', 'OpenIdConnectConfigurationProperty', 'OpenIdConnectGroupConfigurationProperty', 'OpenIdConnectIdentityTokenConfigurationProperty', 'OpenIdConnectTokenSelectionProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_verifiedpermissions.CfnIdentitySource'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_verifiedpermissions.CfnIdentitySourceDefConfig] = pydantic.Field(None)


class CfnIdentitySourceDefConfig(pydantic.BaseModel):
    CognitoGroupConfigurationProperty: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefCognitogroupconfigurationpropertyParams]] = pydantic.Field(None, description='')
    CognitoUserPoolConfigurationProperty: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefCognitouserpoolconfigurationpropertyParams]] = pydantic.Field(None, description='')
    IdentitySourceConfigurationProperty: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefIdentitysourceconfigurationpropertyParams]] = pydantic.Field(None, description='')
    IdentitySourceDetailsProperty: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefIdentitysourcedetailspropertyParams]] = pydantic.Field(None, description='')
    OpenIdConnectAccessTokenConfigurationProperty: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefOpenidconnectaccesstokenconfigurationpropertyParams]] = pydantic.Field(None, description='')
    OpenIdConnectConfigurationProperty: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefOpenidconnectconfigurationpropertyParams]] = pydantic.Field(None, description='')
    OpenIdConnectGroupConfigurationProperty: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefOpenidconnectgroupconfigurationpropertyParams]] = pydantic.Field(None, description='')
    OpenIdConnectIdentityTokenConfigurationProperty: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefOpenidconnectidentitytokenconfigurationpropertyParams]] = pydantic.Field(None, description='')
    OpenIdConnectTokenSelectionProperty: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefOpenidconnecttokenselectionpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_verifiedpermissions.CfnIdentitySourceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_details_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)

class CfnIdentitySourceDefCognitogroupconfigurationpropertyParams(pydantic.BaseModel):
    group_entity_type: str = pydantic.Field(..., description='')
    ...

class CfnIdentitySourceDefCognitouserpoolconfigurationpropertyParams(pydantic.BaseModel):
    user_pool_arn: str = pydantic.Field(..., description='')
    client_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    group_configuration: typing.Union[models.UnsupportedResource, models.aws_verifiedpermissions.CfnIdentitySource_CognitoGroupConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnIdentitySourceDefIdentitysourceconfigurationpropertyParams(pydantic.BaseModel):
    cognito_user_pool_configuration: typing.Union[models.UnsupportedResource, models.aws_verifiedpermissions.CfnIdentitySource_CognitoUserPoolConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    open_id_connect_configuration: typing.Union[models.UnsupportedResource, aws_cdk.aws_verifiedpermissions.CfnIdentitySource.OpenIdConnectConfigurationProperty, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnIdentitySourceDefIdentitysourcedetailspropertyParams(pydantic.BaseModel):
    client_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    discovery_url: typing.Optional[str] = pydantic.Field(None, description='')
    open_id_issuer: typing.Optional[str] = pydantic.Field(None, description='')
    user_pool_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnIdentitySourceDefOpenidconnectaccesstokenconfigurationpropertyParams(pydantic.BaseModel):
    audiences: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    principal_id_claim: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnIdentitySourceDefOpenidconnectconfigurationpropertyParams(pydantic.BaseModel):
    issuer: str = pydantic.Field(..., description='')
    token_selection: typing.Union[models.UnsupportedResource, aws_cdk.aws_verifiedpermissions.CfnIdentitySource.OpenIdConnectTokenSelectionProperty, dict[str, typing.Any]] = pydantic.Field(..., description='')
    entity_id_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    group_configuration: typing.Union[models.UnsupportedResource, aws_cdk.aws_verifiedpermissions.CfnIdentitySource.OpenIdConnectGroupConfigurationProperty, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnIdentitySourceDefOpenidconnectgroupconfigurationpropertyParams(pydantic.BaseModel):
    group_claim: str = pydantic.Field(..., description='')
    group_entity_type: str = pydantic.Field(..., description='')
    ...

class CfnIdentitySourceDefOpenidconnectidentitytokenconfigurationpropertyParams(pydantic.BaseModel):
    client_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    principal_id_claim: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnIdentitySourceDefOpenidconnecttokenselectionpropertyParams(pydantic.BaseModel):
    access_token_only: typing.Union[models.UnsupportedResource, aws_cdk.aws_verifiedpermissions.CfnIdentitySource.OpenIdConnectAccessTokenConfigurationProperty, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    identity_token_only: typing.Union[models.UnsupportedResource, aws_cdk.aws_verifiedpermissions.CfnIdentitySource.OpenIdConnectIdentityTokenConfigurationProperty, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnIdentitySourceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnIdentitySourceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIdentitySourceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnIdentitySourceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIdentitySourceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnIdentitySourceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnIdentitySourceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnIdentitySourceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnIdentitySourceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnIdentitySourceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIdentitySourceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnIdentitySourceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnIdentitySourceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIdentitySourceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_verifiedpermissions.CfnPolicy
class CfnPolicyDef(BaseCfnResource):
    definition: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_verifiedpermissions.CfnPolicy_PolicyDefinitionPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the policy type and content to use for the new or updated policy. The definition structure must include either a ``Static`` or a ``TemplateLinked`` element.\n')
    policy_store_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the ``PolicyStoreId`` of the policy store you want to store the policy in.')
    _init_params: typing.ClassVar[list[str]] = ['definition', 'policy_store_id']
    _method_names: typing.ClassVar[list[str]] = ['EntityIdentifierProperty', 'PolicyDefinitionProperty', 'StaticPolicyDefinitionProperty', 'TemplateLinkedPolicyDefinitionProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_verifiedpermissions.CfnPolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_verifiedpermissions.CfnPolicyDefConfig] = pydantic.Field(None)


class CfnPolicyDefConfig(pydantic.BaseModel):
    EntityIdentifierProperty: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyDefEntityidentifierpropertyParams]] = pydantic.Field(None, description='')
    PolicyDefinitionProperty: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyDefPolicydefinitionpropertyParams]] = pydantic.Field(None, description='')
    StaticPolicyDefinitionProperty: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyDefStaticpolicydefinitionpropertyParams]] = pydantic.Field(None, description='')
    TemplateLinkedPolicyDefinitionProperty: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyDefTemplatelinkedpolicydefinitionpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnPolicyDefEntityidentifierpropertyParams(pydantic.BaseModel):
    entity_id: str = pydantic.Field(..., description='')
    entity_type: str = pydantic.Field(..., description='')
    ...

class CfnPolicyDefPolicydefinitionpropertyParams(pydantic.BaseModel):
    static: typing.Union[models.UnsupportedResource, models.aws_verifiedpermissions.CfnPolicy_StaticPolicyDefinitionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    template_linked: typing.Union[models.UnsupportedResource, models.aws_verifiedpermissions.CfnPolicy_TemplateLinkedPolicyDefinitionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnPolicyDefStaticpolicydefinitionpropertyParams(pydantic.BaseModel):
    statement: str = pydantic.Field(..., description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnPolicyDefTemplatelinkedpolicydefinitionpropertyParams(pydantic.BaseModel):
    policy_template_id: str = pydantic.Field(..., description='')
    principal: typing.Union[models.UnsupportedResource, models.aws_verifiedpermissions.CfnPolicy_EntityIdentifierPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    resource: typing.Union[models.UnsupportedResource, models.aws_verifiedpermissions.CfnPolicy_EntityIdentifierPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnPolicyDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPolicyDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPolicyDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPolicyDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPolicyDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPolicyDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPolicyDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPolicyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPolicyDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPolicyDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPolicyDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnPolicyDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPolicyDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPolicyDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_verifiedpermissions.CfnPolicyStore
class CfnPolicyStoreDef(BaseCfnResource):
    validation_settings: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_verifiedpermissions.CfnPolicyStore_ValidationSettingsPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description="Specifies the validation setting for this policy store. Currently, the only valid and required value is ``Mode`` . .. epigraph:: We recommend that you turn on ``STRICT`` mode only after you define a schema. If a schema doesn't exist, then ``STRICT`` mode causes any policy to fail validation, and Verified Permissions rejects the policy. You can turn off validation by using the `UpdatePolicyStore <https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdatePolicyStore>`_ . Then, when you have a schema defined, use `UpdatePolicyStore <https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdatePolicyStore>`_ again to turn validation back on.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='Descriptive text that you can provide to help with identification of the current policy store.\n')
    schema_: typing.Union[models.UnsupportedResource, models.aws_verifiedpermissions.CfnPolicyStore_SchemaDefinitionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Creates or updates the policy schema in a policy store. Cedar can use the schema to validate any Cedar policies and policy templates submitted to the policy store. Any changes to the schema validate only policies and templates submitted after the schema change. Existing policies and templates are not re-evaluated against the changed schema. If you later update a policy, then it is evaluated against the new schema at that time.', alias='schema')
    _init_params: typing.ClassVar[list[str]] = ['validation_settings', 'description', 'schema']
    _method_names: typing.ClassVar[list[str]] = ['SchemaDefinitionProperty', 'ValidationSettingsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_verifiedpermissions.CfnPolicyStore'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_verifiedpermissions.CfnPolicyStoreDefConfig] = pydantic.Field(None)


class CfnPolicyStoreDefConfig(pydantic.BaseModel):
    SchemaDefinitionProperty: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyStoreDefSchemadefinitionpropertyParams]] = pydantic.Field(None, description='')
    ValidationSettingsProperty: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyStoreDefValidationsettingspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyStoreDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyStoreDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyStoreDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyStoreDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyStoreDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyStoreDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyStoreDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyStoreDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyStoreDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyStoreDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyStoreDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyStoreDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyStoreDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnPolicyStoreDefSchemadefinitionpropertyParams(pydantic.BaseModel):
    cedar_json: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnPolicyStoreDefValidationsettingspropertyParams(pydantic.BaseModel):
    mode: str = pydantic.Field(..., description='')
    ...

class CfnPolicyStoreDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPolicyStoreDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPolicyStoreDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPolicyStoreDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPolicyStoreDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPolicyStoreDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPolicyStoreDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPolicyStoreDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPolicyStoreDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPolicyStoreDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPolicyStoreDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnPolicyStoreDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPolicyStoreDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPolicyStoreDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_verifiedpermissions.CfnPolicyTemplate
class CfnPolicyTemplateDef(BaseCfnResource):
    policy_store_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique identifier of the policy store that contains the template.\n')
    statement: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the content that you want to use for the new policy template, written in the Cedar policy language.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description to attach to the new or updated policy template.')
    _init_params: typing.ClassVar[list[str]] = ['policy_store_id', 'statement', 'description']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_verifiedpermissions.CfnPolicyTemplate'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_verifiedpermissions.CfnPolicyTemplateDefConfig] = pydantic.Field(None)


class CfnPolicyTemplateDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyTemplateDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyTemplateDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyTemplateDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyTemplateDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyTemplateDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyTemplateDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyTemplateDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyTemplateDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyTemplateDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyTemplateDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyTemplateDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyTemplateDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_verifiedpermissions.CfnPolicyTemplateDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnPolicyTemplateDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPolicyTemplateDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPolicyTemplateDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPolicyTemplateDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPolicyTemplateDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPolicyTemplateDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPolicyTemplateDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPolicyTemplateDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPolicyTemplateDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPolicyTemplateDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPolicyTemplateDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnPolicyTemplateDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPolicyTemplateDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPolicyTemplateDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_verifiedpermissions.CfnIdentitySourceProps
class CfnIdentitySourcePropsDef(BaseCfnProperty):
    configuration: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_verifiedpermissions.CfnIdentitySource_IdentitySourceConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Contains configuration information about an identity source.\n')
    policy_store_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the ID of the policy store in which you want to store this identity source. Only policies and requests made using this policy store can reference identities from the identity provider configured in the new identity source.\n')
    principal_entity_type: typing.Optional[str] = pydantic.Field(None, description='Specifies the namespace and data type of the principals generated for identities authenticated by the new identity source.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-verifiedpermissions-identitysource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_verifiedpermissions as verifiedpermissions\n\n    cfn_identity_source_props = verifiedpermissions.CfnIdentitySourceProps(\n        configuration=verifiedpermissions.CfnIdentitySource.IdentitySourceConfigurationProperty(\n            cognito_user_pool_configuration=verifiedpermissions.CfnIdentitySource.CognitoUserPoolConfigurationProperty(\n                user_pool_arn="userPoolArn",\n\n                # the properties below are optional\n                client_ids=["clientIds"],\n                group_configuration=verifiedpermissions.CfnIdentitySource.CognitoGroupConfigurationProperty(\n                    group_entity_type="groupEntityType"\n                )\n            ),\n            open_id_connect_configuration=verifiedpermissions.CfnIdentitySource.OpenIdConnectConfigurationProperty(\n                issuer="issuer",\n                token_selection=verifiedpermissions.CfnIdentitySource.OpenIdConnectTokenSelectionProperty(\n                    access_token_only=verifiedpermissions.CfnIdentitySource.OpenIdConnectAccessTokenConfigurationProperty(\n                        audiences=["audiences"],\n                        principal_id_claim="principalIdClaim"\n                    ),\n                    identity_token_only=verifiedpermissions.CfnIdentitySource.OpenIdConnectIdentityTokenConfigurationProperty(\n                        client_ids=["clientIds"],\n                        principal_id_claim="principalIdClaim"\n                    )\n                ),\n\n                # the properties below are optional\n                entity_id_prefix="entityIdPrefix",\n                group_configuration=verifiedpermissions.CfnIdentitySource.OpenIdConnectGroupConfigurationProperty(\n                    group_claim="groupClaim",\n                    group_entity_type="groupEntityType"\n                )\n            )\n        ),\n        policy_store_id="policyStoreId",\n\n        # the properties below are optional\n        principal_entity_type="principalEntityType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['configuration', 'policy_store_id', 'principal_entity_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_verifiedpermissions.CfnIdentitySourceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_verifiedpermissions.CfnPolicyProps
class CfnPolicyPropsDef(BaseCfnProperty):
    definition: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_verifiedpermissions.CfnPolicy_PolicyDefinitionPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the policy type and content to use for the new or updated policy. The definition structure must include either a ``Static`` or a ``TemplateLinked`` element.\n')
    policy_store_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the ``PolicyStoreId`` of the policy store you want to store the policy in.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-verifiedpermissions-policy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_verifiedpermissions as verifiedpermissions\n\n    cfn_policy_props = verifiedpermissions.CfnPolicyProps(\n        definition=verifiedpermissions.CfnPolicy.PolicyDefinitionProperty(\n            static=verifiedpermissions.CfnPolicy.StaticPolicyDefinitionProperty(\n                statement="statement",\n\n                # the properties below are optional\n                description="description"\n            ),\n            template_linked=verifiedpermissions.CfnPolicy.TemplateLinkedPolicyDefinitionProperty(\n                policy_template_id="policyTemplateId",\n\n                # the properties below are optional\n                principal=verifiedpermissions.CfnPolicy.EntityIdentifierProperty(\n                    entity_id="entityId",\n                    entity_type="entityType"\n                ),\n                resource=verifiedpermissions.CfnPolicy.EntityIdentifierProperty(\n                    entity_id="entityId",\n                    entity_type="entityType"\n                )\n            )\n        ),\n        policy_store_id="policyStoreId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['definition', 'policy_store_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_verifiedpermissions.CfnPolicyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_verifiedpermissions.CfnPolicyStoreProps
class CfnPolicyStorePropsDef(BaseCfnProperty):
    validation_settings: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_verifiedpermissions.CfnPolicyStore_ValidationSettingsPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description="Specifies the validation setting for this policy store. Currently, the only valid and required value is ``Mode`` . .. epigraph:: We recommend that you turn on ``STRICT`` mode only after you define a schema. If a schema doesn't exist, then ``STRICT`` mode causes any policy to fail validation, and Verified Permissions rejects the policy. You can turn off validation by using the `UpdatePolicyStore <https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdatePolicyStore>`_ . Then, when you have a schema defined, use `UpdatePolicyStore <https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdatePolicyStore>`_ again to turn validation back on.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='Descriptive text that you can provide to help with identification of the current policy store.\n')
    schema_: typing.Union[models.UnsupportedResource, models.aws_verifiedpermissions.CfnPolicyStore_SchemaDefinitionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Creates or updates the policy schema in a policy store. Cedar can use the schema to validate any Cedar policies and policy templates submitted to the policy store. Any changes to the schema validate only policies and templates submitted after the schema change. Existing policies and templates are not re-evaluated against the changed schema. If you later update a policy, then it is evaluated against the new schema at that time.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-verifiedpermissions-policystore.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_verifiedpermissions as verifiedpermissions\n\n    cfn_policy_store_props = verifiedpermissions.CfnPolicyStoreProps(\n        validation_settings=verifiedpermissions.CfnPolicyStore.ValidationSettingsProperty(\n            mode="mode"\n        ),\n\n        # the properties below are optional\n        description="description",\n        schema=verifiedpermissions.CfnPolicyStore.SchemaDefinitionProperty(\n            cedar_json="cedarJson"\n        )\n    )\n', alias='schema')
    _init_params: typing.ClassVar[list[str]] = ['validation_settings', 'description', 'schema']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_verifiedpermissions.CfnPolicyStoreProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_verifiedpermissions.CfnPolicyTemplateProps
class CfnPolicyTemplatePropsDef(BaseCfnProperty):
    policy_store_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique identifier of the policy store that contains the template.\n')
    statement: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the content that you want to use for the new policy template, written in the Cedar policy language.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description to attach to the new or updated policy template.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-verifiedpermissions-policytemplate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_verifiedpermissions as verifiedpermissions\n\n    cfn_policy_template_props = verifiedpermissions.CfnPolicyTemplateProps(\n        policy_store_id="policyStoreId",\n        statement="statement",\n\n        # the properties below are optional\n        description="description"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['policy_store_id', 'statement', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_verifiedpermissions.CfnPolicyTemplateProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    CfnIdentitySource_CognitoGroupConfigurationProperty: typing.Optional[dict[str, models.aws_verifiedpermissions.CfnIdentitySource_CognitoGroupConfigurationPropertyDef]] = pydantic.Field(None)
    CfnIdentitySource_CognitoUserPoolConfigurationProperty: typing.Optional[dict[str, models.aws_verifiedpermissions.CfnIdentitySource_CognitoUserPoolConfigurationPropertyDef]] = pydantic.Field(None)
    CfnIdentitySource_IdentitySourceConfigurationProperty: typing.Optional[dict[str, models.aws_verifiedpermissions.CfnIdentitySource_IdentitySourceConfigurationPropertyDef]] = pydantic.Field(None)
    CfnIdentitySource_IdentitySourceDetailsProperty: typing.Optional[dict[str, models.aws_verifiedpermissions.CfnIdentitySource_IdentitySourceDetailsPropertyDef]] = pydantic.Field(None)
    CfnPolicy_EntityIdentifierProperty: typing.Optional[dict[str, models.aws_verifiedpermissions.CfnPolicy_EntityIdentifierPropertyDef]] = pydantic.Field(None)
    CfnPolicy_PolicyDefinitionProperty: typing.Optional[dict[str, models.aws_verifiedpermissions.CfnPolicy_PolicyDefinitionPropertyDef]] = pydantic.Field(None)
    CfnPolicy_StaticPolicyDefinitionProperty: typing.Optional[dict[str, models.aws_verifiedpermissions.CfnPolicy_StaticPolicyDefinitionPropertyDef]] = pydantic.Field(None)
    CfnPolicy_TemplateLinkedPolicyDefinitionProperty: typing.Optional[dict[str, models.aws_verifiedpermissions.CfnPolicy_TemplateLinkedPolicyDefinitionPropertyDef]] = pydantic.Field(None)
    CfnPolicyStore_SchemaDefinitionProperty: typing.Optional[dict[str, models.aws_verifiedpermissions.CfnPolicyStore_SchemaDefinitionPropertyDef]] = pydantic.Field(None)
    CfnPolicyStore_ValidationSettingsProperty: typing.Optional[dict[str, models.aws_verifiedpermissions.CfnPolicyStore_ValidationSettingsPropertyDef]] = pydantic.Field(None)
    CfnIdentitySource: typing.Optional[dict[str, models.aws_verifiedpermissions.CfnIdentitySourceDef]] = pydantic.Field(None)
    CfnPolicy: typing.Optional[dict[str, models.aws_verifiedpermissions.CfnPolicyDef]] = pydantic.Field(None)
    CfnPolicyStore: typing.Optional[dict[str, models.aws_verifiedpermissions.CfnPolicyStoreDef]] = pydantic.Field(None)
    CfnPolicyTemplate: typing.Optional[dict[str, models.aws_verifiedpermissions.CfnPolicyTemplateDef]] = pydantic.Field(None)
    CfnIdentitySourceProps: typing.Optional[dict[str, models.aws_verifiedpermissions.CfnIdentitySourcePropsDef]] = pydantic.Field(None)
    CfnPolicyProps: typing.Optional[dict[str, models.aws_verifiedpermissions.CfnPolicyPropsDef]] = pydantic.Field(None)
    CfnPolicyStoreProps: typing.Optional[dict[str, models.aws_verifiedpermissions.CfnPolicyStorePropsDef]] = pydantic.Field(None)
    CfnPolicyTemplateProps: typing.Optional[dict[str, models.aws_verifiedpermissions.CfnPolicyTemplatePropsDef]] = pydantic.Field(None)
    ...

import models
