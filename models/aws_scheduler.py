from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_scheduler.CfnSchedule.AwsVpcConfigurationProperty
class CfnSchedule_AwsVpcConfigurationPropertyDef(BaseStruct):
    subnets: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the subnets associated with the task. These subnets must all be in the same VPC. You can specify as many as 16 subnets.\n')
    assign_public_ip: typing.Optional[str] = pydantic.Field(None, description="Specifies whether the task's elastic network interface receives a public IP address. You can specify ``ENABLED`` only when ``LaunchType`` in ``EcsParameters`` is set to ``FARGATE`` .\n")
    security_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Specifies the security groups associated with the task. These security groups must all be in the same VPC. You can specify as many as five security groups. If you do not specify a security group, the default security group for the VPC is used.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-awsvpcconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_scheduler as scheduler\n\n    aws_vpc_configuration_property = scheduler.CfnSchedule.AwsVpcConfigurationProperty(\n        subnets=["subnets"],\n\n        # the properties below are optional\n        assign_public_ip="assignPublicIp",\n        security_groups=["securityGroups"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['subnets', 'assign_public_ip', 'security_groups']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_scheduler.CfnSchedule.AwsVpcConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_scheduler.CfnSchedule.CapacityProviderStrategyItemProperty
class CfnSchedule_CapacityProviderStrategyItemPropertyDef(BaseStruct):
    capacity_provider: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The short name of the capacity provider.\n')
    base: typing.Union[int, float, None] = pydantic.Field(None, description='The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. If no value is specified, the default value of ``0`` is used. Default: - 0\n')
    weight: typing.Union[int, float, None] = pydantic.Field(None, description='The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied. Default: - 0\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-capacityproviderstrategyitem.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_scheduler as scheduler\n\n    capacity_provider_strategy_item_property = scheduler.CfnSchedule.CapacityProviderStrategyItemProperty(\n        capacity_provider="capacityProvider",\n\n        # the properties below are optional\n        base=123,\n        weight=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['capacity_provider', 'base', 'weight']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_scheduler.CfnSchedule.CapacityProviderStrategyItemProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_scheduler.CfnSchedule.DeadLetterConfigProperty
class CfnSchedule_DeadLetterConfigPropertyDef(BaseStruct):
    arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the SQS queue specified as the destination for the dead-letter queue.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-deadletterconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_scheduler as scheduler\n\n    dead_letter_config_property = scheduler.CfnSchedule.DeadLetterConfigProperty(\n        arn="arn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_scheduler.CfnSchedule.DeadLetterConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_scheduler.CfnSchedule.EcsParametersProperty
class CfnSchedule_EcsParametersPropertyDef(BaseStruct):
    task_definition_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the task definition to use if the event target is an Amazon ECS task.\n')
    capacity_provider_strategy: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_CapacityProviderStrategyItemPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The capacity provider strategy to use for the task.\n')
    enable_ecs_managed_tags: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether to enable Amazon ECS managed tags for the task. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ in the *Amazon ECS Developer Guide* .\n')
    enable_execute_command: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task.\n')
    group: typing.Optional[str] = pydantic.Field(None, description='Specifies an Amazon ECS task group for the task. The maximum length is 255 characters.\n')
    launch_type: typing.Optional[str] = pydantic.Field(None, description='Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. The ``FARGATE`` value is supported only in the Regions where Fargate with Amazon ECS is supported. For more information, see `AWS Fargate on Amazon ECS <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html>`_ in the *Amazon ECS Developer Guide* .\n')
    network_configuration: typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_NetworkConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='This structure specifies the network configuration for an ECS task.\n')
    placement_constraints: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_PlacementConstraintPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime).\n')
    placement_strategy: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_PlacementStrategyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The task placement strategy for a task or service.\n')
    platform_version: typing.Optional[str] = pydantic.Field(None, description='Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as ``1.1.0`` .\n')
    propagate_tags: typing.Optional[str] = pydantic.Field(None, description='Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use the Amazon ECS ```TagResource`` <https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_TagResource.html>`_ API action.\n')
    reference_id: typing.Optional[str] = pydantic.Field(None, description='The reference ID to use for the task.\n')
    tags: typing.Any = pydantic.Field(None, description='The metadata that you apply to the task to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. For more information, see ```RunTask`` <https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html>`_ in the *Amazon ECS API Reference* .\n')
    task_count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of tasks to create based on ``TaskDefinition`` . The default is ``1`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-ecsparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_scheduler as scheduler\n\n    # tags: Any\n\n    ecs_parameters_property = scheduler.CfnSchedule.EcsParametersProperty(\n        task_definition_arn="taskDefinitionArn",\n\n        # the properties below are optional\n        capacity_provider_strategy=[scheduler.CfnSchedule.CapacityProviderStrategyItemProperty(\n            capacity_provider="capacityProvider",\n\n            # the properties below are optional\n            base=123,\n            weight=123\n        )],\n        enable_ecs_managed_tags=False,\n        enable_execute_command=False,\n        group="group",\n        launch_type="launchType",\n        network_configuration=scheduler.CfnSchedule.NetworkConfigurationProperty(\n            awsvpc_configuration=scheduler.CfnSchedule.AwsVpcConfigurationProperty(\n                subnets=["subnets"],\n\n                # the properties below are optional\n                assign_public_ip="assignPublicIp",\n                security_groups=["securityGroups"]\n            )\n        ),\n        placement_constraints=[scheduler.CfnSchedule.PlacementConstraintProperty(\n            expression="expression",\n            type="type"\n        )],\n        placement_strategy=[scheduler.CfnSchedule.PlacementStrategyProperty(\n            field="field",\n            type="type"\n        )],\n        platform_version="platformVersion",\n        propagate_tags="propagateTags",\n        reference_id="referenceId",\n        tags=tags,\n        task_count=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['task_definition_arn', 'capacity_provider_strategy', 'enable_ecs_managed_tags', 'enable_execute_command', 'group', 'launch_type', 'network_configuration', 'placement_constraints', 'placement_strategy', 'platform_version', 'propagate_tags', 'reference_id', 'tags', 'task_count']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_scheduler.CfnSchedule.EcsParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_scheduler.CfnSchedule.EventBridgeParametersProperty
class CfnSchedule_EventBridgeParametersPropertyDef(BaseStruct):
    detail_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A free-form string, with a maximum of 128 characters, used to decide what fields to expect in the event detail.\n')
    source: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The source of the event.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-eventbridgeparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_scheduler as scheduler\n\n    event_bridge_parameters_property = scheduler.CfnSchedule.EventBridgeParametersProperty(\n        detail_type="detailType",\n        source="source"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['detail_type', 'source']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_scheduler.CfnSchedule.EventBridgeParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_scheduler.CfnSchedule.FlexibleTimeWindowProperty
class CfnSchedule_FlexibleTimeWindowPropertyDef(BaseStruct):
    mode: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Determines whether the schedule is invoked within a flexible time window. You must use quotation marks when you specify this value in your JSON or YAML template. *Allowed Values* : ``"OFF"`` | ``"FLEXIBLE"``\n')
    maximum_window_in_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum time window during which a schedule can be invoked. *Minimum* : ``1`` *Maximum* : ``1440``\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-flexibletimewindow.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_scheduler as scheduler\n\n    flexible_time_window_property = scheduler.CfnSchedule.FlexibleTimeWindowProperty(\n        mode="mode",\n\n        # the properties below are optional\n        maximum_window_in_minutes=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['mode', 'maximum_window_in_minutes']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_scheduler.CfnSchedule.FlexibleTimeWindowProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_scheduler.CfnSchedule.KinesisParametersProperty
class CfnSchedule_KinesisParametersPropertyDef(BaseStruct):
    partition_key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the shard to which EventBridge Scheduler sends the event. For more information, see `Amazon Kinesis Data Streams terminology and concepts <https://docs.aws.amazon.com/streams/latest/dev/key-concepts.html>`_ in the *Amazon Kinesis Streams Developer Guide* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-kinesisparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_scheduler as scheduler\n\n    kinesis_parameters_property = scheduler.CfnSchedule.KinesisParametersProperty(\n        partition_key="partitionKey"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['partition_key']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_scheduler.CfnSchedule.KinesisParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_scheduler.CfnSchedule.NetworkConfigurationProperty
class CfnSchedule_NetworkConfigurationPropertyDef(BaseStruct):
    awsvpc_configuration: typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_AwsVpcConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies the Amazon VPC subnets and security groups for the task, and whether a public IP address is to be used. This structure is relevant only for ECS tasks that use the awsvpc network mode.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-networkconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_scheduler as scheduler\n\n    network_configuration_property = scheduler.CfnSchedule.NetworkConfigurationProperty(\n        awsvpc_configuration=scheduler.CfnSchedule.AwsVpcConfigurationProperty(\n            subnets=["subnets"],\n\n            # the properties below are optional\n            assign_public_ip="assignPublicIp",\n            security_groups=["securityGroups"]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['awsvpc_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_scheduler.CfnSchedule.NetworkConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_scheduler.CfnSchedule.PlacementConstraintProperty
class CfnSchedule_PlacementConstraintPropertyDef(BaseStruct):
    expression: typing.Optional[str] = pydantic.Field(None, description='A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is ``distinctInstance`` . For more information, see `Cluster query language <https://docs.aws.amazon.com/latest/developerguide/cluster-query-language.html>`_ in the *Amazon ECS Developer Guide* .\n')
    type: typing.Optional[str] = pydantic.Field(None, description='The type of constraint. Use ``distinctInstance`` to ensure that each task in a particular group is running on a different container instance. Use ``memberOf`` to restrict the selection to a group of valid candidates.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-placementconstraint.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_scheduler as scheduler\n\n    placement_constraint_property = scheduler.CfnSchedule.PlacementConstraintProperty(\n        expression="expression",\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['expression', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_scheduler.CfnSchedule.PlacementConstraintProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_scheduler.CfnSchedule.PlacementStrategyProperty
class CfnSchedule_PlacementStrategyPropertyDef(BaseStruct):
    field: typing.Optional[str] = pydantic.Field(None, description='The field to apply the placement strategy against. For the spread placement strategy, valid values are ``instanceId`` (or ``instanceId`` , which has the same effect), or any platform or custom attribute that is applied to a container instance, such as ``attribute:ecs.availability-zone`` . For the binpack placement strategy, valid values are ``cpu`` and ``memory`` . For the random placement strategy, this field is not used.\n')
    type: typing.Optional[str] = pydantic.Field(None, description='The type of placement strategy. The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the field parameter. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified with the field parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory (but still enough to run the task).\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-placementstrategy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_scheduler as scheduler\n\n    placement_strategy_property = scheduler.CfnSchedule.PlacementStrategyProperty(\n        field="field",\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['field', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_scheduler.CfnSchedule.PlacementStrategyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_scheduler.CfnSchedule.RetryPolicyProperty
class CfnSchedule_RetryPolicyPropertyDef(BaseStruct):
    maximum_event_age_in_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum amount of time, in seconds, to continue to make retry attempts.\n')
    maximum_retry_attempts: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of retry attempts to make before the request fails. Retry attempts with exponential backoff continue until either the maximum number of attempts is made or until the duration of the ``MaximumEventAgeInSeconds`` is reached.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-retrypolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_scheduler as scheduler\n\n    retry_policy_property = scheduler.CfnSchedule.RetryPolicyProperty(\n        maximum_event_age_in_seconds=123,\n        maximum_retry_attempts=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['maximum_event_age_in_seconds', 'maximum_retry_attempts']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_scheduler.CfnSchedule.RetryPolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_scheduler.CfnSchedule.SageMakerPipelineParameterProperty
class CfnSchedule_SageMakerPipelineParameterPropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Name of parameter to start execution of a SageMaker Model Building Pipeline.\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Value of parameter to start execution of a SageMaker Model Building Pipeline.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-sagemakerpipelineparameter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_scheduler as scheduler\n\n    sage_maker_pipeline_parameter_property = scheduler.CfnSchedule.SageMakerPipelineParameterProperty(\n        name="name",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_scheduler.CfnSchedule.SageMakerPipelineParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_scheduler.CfnSchedule.SageMakerPipelineParametersProperty
class CfnSchedule_SageMakerPipelineParametersPropertyDef(BaseStruct):
    pipeline_parameter_list: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_SageMakerPipelineParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='List of parameter names and values to use when executing the SageMaker Model Building Pipeline.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-sagemakerpipelineparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_scheduler as scheduler\n\n    sage_maker_pipeline_parameters_property = scheduler.CfnSchedule.SageMakerPipelineParametersProperty(\n        pipeline_parameter_list=[scheduler.CfnSchedule.SageMakerPipelineParameterProperty(\n            name="name",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['pipeline_parameter_list']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_scheduler.CfnSchedule.SageMakerPipelineParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_scheduler.CfnSchedule.SqsParametersProperty
class CfnSchedule_SqsParametersPropertyDef(BaseStruct):
    message_group_id: typing.Optional[str] = pydantic.Field(None, description='The FIFO message group ID to use as the target.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-sqsparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_scheduler as scheduler\n\n    sqs_parameters_property = scheduler.CfnSchedule.SqsParametersProperty(\n        message_group_id="messageGroupId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['message_group_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_scheduler.CfnSchedule.SqsParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_scheduler.CfnSchedule.TargetProperty
class CfnSchedule_TargetPropertyDef(BaseStruct):
    arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the target.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the IAM role that EventBridge Scheduler will use for this target when the schedule is invoked.\n')
    dead_letter_config: typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_DeadLetterConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that contains information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue.\n')
    ecs_parameters: typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_EcsParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The templated target type for the Amazon ECS ```RunTask`` <https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html>`_ API operation.\n')
    event_bridge_parameters: typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_EventBridgeParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The templated target type for the EventBridge ```PutEvents`` <https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEvents.html>`_ API operation.\n')
    input: typing.Optional[str] = pydantic.Field(None, description='The text, or well-formed JSON, passed to the target. If you are configuring a templated Lambda , AWS Step Functions , or Amazon EventBridge target, the input must be a well-formed JSON. For all other target types, a JSON is not required. If you do not specify anything for this field, Amazon EventBridge Scheduler delivers a default notification to the target.\n')
    kinesis_parameters: typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_KinesisParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The templated target type for the Amazon Kinesis ```PutRecord`` <https://docs.aws.amazon.com/kinesis/latest/APIReference/API_PutRecord.html>`_ API operation.\n')
    retry_policy: typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_RetryPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A ``RetryPolicy`` object that includes information about the retry policy settings, including the maximum age of an event, and the maximum number of times EventBridge Scheduler will try to deliver the event to a target.\n')
    sage_maker_pipeline_parameters: typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_SageMakerPipelineParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The templated target type for the Amazon SageMaker ```StartPipelineExecution`` <https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_StartPipelineExecution.html>`_ API operation.\n')
    sqs_parameters: typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_SqsParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The templated target type for the Amazon SQS ```SendMessage`` <https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SendMessage.html>`_ API operation. Contains the message group ID to use when the target is a FIFO queue. If you specify an Amazon SQS FIFO queue as a target, the queue must have content-based deduplication enabled. For more information, see `Using the Amazon SQS message deduplication ID <https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html>`_ in the *Amazon SQS Developer Guide* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-scheduler-schedule-target.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_scheduler as scheduler\n\n    # tags: Any\n\n    target_property = scheduler.CfnSchedule.TargetProperty(\n        arn="arn",\n        role_arn="roleArn",\n\n        # the properties below are optional\n        dead_letter_config=scheduler.CfnSchedule.DeadLetterConfigProperty(\n            arn="arn"\n        ),\n        ecs_parameters=scheduler.CfnSchedule.EcsParametersProperty(\n            task_definition_arn="taskDefinitionArn",\n\n            # the properties below are optional\n            capacity_provider_strategy=[scheduler.CfnSchedule.CapacityProviderStrategyItemProperty(\n                capacity_provider="capacityProvider",\n\n                # the properties below are optional\n                base=123,\n                weight=123\n            )],\n            enable_ecs_managed_tags=False,\n            enable_execute_command=False,\n            group="group",\n            launch_type="launchType",\n            network_configuration=scheduler.CfnSchedule.NetworkConfigurationProperty(\n                awsvpc_configuration=scheduler.CfnSchedule.AwsVpcConfigurationProperty(\n                    subnets=["subnets"],\n\n                    # the properties below are optional\n                    assign_public_ip="assignPublicIp",\n                    security_groups=["securityGroups"]\n                )\n            ),\n            placement_constraints=[scheduler.CfnSchedule.PlacementConstraintProperty(\n                expression="expression",\n                type="type"\n            )],\n            placement_strategy=[scheduler.CfnSchedule.PlacementStrategyProperty(\n                field="field",\n                type="type"\n            )],\n            platform_version="platformVersion",\n            propagate_tags="propagateTags",\n            reference_id="referenceId",\n            tags=tags,\n            task_count=123\n        ),\n        event_bridge_parameters=scheduler.CfnSchedule.EventBridgeParametersProperty(\n            detail_type="detailType",\n            source="source"\n        ),\n        input="input",\n        kinesis_parameters=scheduler.CfnSchedule.KinesisParametersProperty(\n            partition_key="partitionKey"\n        ),\n        retry_policy=scheduler.CfnSchedule.RetryPolicyProperty(\n            maximum_event_age_in_seconds=123,\n            maximum_retry_attempts=123\n        ),\n        sage_maker_pipeline_parameters=scheduler.CfnSchedule.SageMakerPipelineParametersProperty(\n            pipeline_parameter_list=[scheduler.CfnSchedule.SageMakerPipelineParameterProperty(\n                name="name",\n                value="value"\n            )]\n        ),\n        sqs_parameters=scheduler.CfnSchedule.SqsParametersProperty(\n            message_group_id="messageGroupId"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['arn', 'role_arn', 'dead_letter_config', 'ecs_parameters', 'event_bridge_parameters', 'input', 'kinesis_parameters', 'retry_policy', 'sage_maker_pipeline_parameters', 'sqs_parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_scheduler.CfnSchedule.TargetProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_scheduler.CfnSchedule
class CfnScheduleDef(BaseCfnResource):
    flexible_time_window: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_scheduler.CfnSchedule_FlexibleTimeWindowPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.\n')
    schedule_expression: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The expression that defines when the schedule runs. The following formats are supported. - ``at`` expression - ``at(yyyy-mm-ddThh:mm:ss)`` - ``rate`` expression - ``rate(value unit)`` - ``cron`` expression - ``cron(fields)`` You can use ``at`` expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use ``rate`` and ``cron`` expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month. A ``cron`` expression consists of six fields separated by white spaces: ``(minutes hours day_of_month month day_of_week year)`` . A ``rate`` expression consists of a *value* as a positive integer, and a *unit* with the following options: ``minute`` | ``minutes`` | ``hour`` | ``hours`` | ``day`` | ``days`` For more information and examples, see `Schedule types on EventBridge Scheduler <https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html>`_ in the *EventBridge Scheduler User Guide* .\n')
    target: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_scheduler.CfnSchedule_TargetPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description="The schedule's target details.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='The description you specify for the schedule.\n')
    end_date: typing.Optional[str] = pydantic.Field(None, description="The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the ``EndDate`` you specify. EventBridge Scheduler ignores ``EndDate`` for one-time schedules.\n")
    group_name: typing.Optional[str] = pydantic.Field(None, description='The name of the schedule group associated with this schedule.\n')
    kms_key_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) for the customer managed KMS key that EventBridge Scheduler will use to encrypt and decrypt your data.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the schedule.\n')
    schedule_expression_timezone: typing.Optional[str] = pydantic.Field(None, description='The timezone in which the scheduling expression is evaluated.\n')
    start_date: typing.Optional[str] = pydantic.Field(None, description="The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the ``StartDate`` you specify. EventBridge Scheduler ignores ``StartDate`` for one-time schedules.\n")
    state: typing.Optional[str] = pydantic.Field(None, description='Specifies whether the schedule is enabled or disabled. *Allowed Values* : ``ENABLED`` | ``DISABLED``')
    _init_params: typing.ClassVar[list[str]] = ['flexible_time_window', 'schedule_expression', 'target', 'description', 'end_date', 'group_name', 'kms_key_arn', 'name', 'schedule_expression_timezone', 'start_date', 'state']
    _method_names: typing.ClassVar[list[str]] = ['AwsVpcConfigurationProperty', 'CapacityProviderStrategyItemProperty', 'DeadLetterConfigProperty', 'EcsParametersProperty', 'EventBridgeParametersProperty', 'FlexibleTimeWindowProperty', 'KinesisParametersProperty', 'NetworkConfigurationProperty', 'PlacementConstraintProperty', 'PlacementStrategyProperty', 'RetryPolicyProperty', 'SageMakerPipelineParameterProperty', 'SageMakerPipelineParametersProperty', 'SqsParametersProperty', 'TargetProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_scheduler.CfnSchedule'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_scheduler.CfnScheduleDefConfig] = pydantic.Field(None)


class CfnScheduleDefConfig(pydantic.BaseModel):
    AwsVpcConfigurationProperty: typing.Optional[list[models.aws_scheduler.CfnScheduleDefAwsvpcconfigurationpropertyParams]] = pydantic.Field(None, description='')
    CapacityProviderStrategyItemProperty: typing.Optional[list[models.aws_scheduler.CfnScheduleDefCapacityproviderstrategyitempropertyParams]] = pydantic.Field(None, description='')
    DeadLetterConfigProperty: typing.Optional[list[models.aws_scheduler.CfnScheduleDefDeadletterconfigpropertyParams]] = pydantic.Field(None, description='')
    EcsParametersProperty: typing.Optional[list[models.aws_scheduler.CfnScheduleDefEcsparameterspropertyParams]] = pydantic.Field(None, description='')
    EventBridgeParametersProperty: typing.Optional[list[models.aws_scheduler.CfnScheduleDefEventbridgeparameterspropertyParams]] = pydantic.Field(None, description='')
    FlexibleTimeWindowProperty: typing.Optional[list[models.aws_scheduler.CfnScheduleDefFlexibletimewindowpropertyParams]] = pydantic.Field(None, description='')
    KinesisParametersProperty: typing.Optional[list[models.aws_scheduler.CfnScheduleDefKinesisparameterspropertyParams]] = pydantic.Field(None, description='')
    NetworkConfigurationProperty: typing.Optional[list[models.aws_scheduler.CfnScheduleDefNetworkconfigurationpropertyParams]] = pydantic.Field(None, description='')
    PlacementConstraintProperty: typing.Optional[list[models.aws_scheduler.CfnScheduleDefPlacementconstraintpropertyParams]] = pydantic.Field(None, description='')
    PlacementStrategyProperty: typing.Optional[list[models.aws_scheduler.CfnScheduleDefPlacementstrategypropertyParams]] = pydantic.Field(None, description='')
    RetryPolicyProperty: typing.Optional[list[models.aws_scheduler.CfnScheduleDefRetrypolicypropertyParams]] = pydantic.Field(None, description='')
    SageMakerPipelineParameterProperty: typing.Optional[list[models.aws_scheduler.CfnScheduleDefSagemakerpipelineparameterpropertyParams]] = pydantic.Field(None, description='')
    SageMakerPipelineParametersProperty: typing.Optional[list[models.aws_scheduler.CfnScheduleDefSagemakerpipelineparameterspropertyParams]] = pydantic.Field(None, description='')
    SqsParametersProperty: typing.Optional[list[models.aws_scheduler.CfnScheduleDefSqsparameterspropertyParams]] = pydantic.Field(None, description='')
    TargetProperty: typing.Optional[list[models.aws_scheduler.CfnScheduleDefTargetpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_scheduler.CfnScheduleDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_scheduler.CfnScheduleDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_scheduler.CfnScheduleDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_scheduler.CfnScheduleDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_scheduler.CfnScheduleDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_scheduler.CfnScheduleDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_scheduler.CfnScheduleDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_scheduler.CfnScheduleDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_scheduler.CfnScheduleDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_scheduler.CfnScheduleDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_scheduler.CfnScheduleDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_scheduler.CfnScheduleDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_scheduler.CfnScheduleDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnScheduleDefAwsvpcconfigurationpropertyParams(pydantic.BaseModel):
    subnets: typing.Sequence[str] = pydantic.Field(..., description='')
    assign_public_ip: typing.Optional[str] = pydantic.Field(None, description='')
    security_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnScheduleDefCapacityproviderstrategyitempropertyParams(pydantic.BaseModel):
    capacity_provider: str = pydantic.Field(..., description='')
    base: typing.Union[int, float, None] = pydantic.Field(None, description='')
    weight: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnScheduleDefDeadletterconfigpropertyParams(pydantic.BaseModel):
    arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnScheduleDefEcsparameterspropertyParams(pydantic.BaseModel):
    task_definition_arn: str = pydantic.Field(..., description='')
    capacity_provider_strategy: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_CapacityProviderStrategyItemPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    enable_ecs_managed_tags: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    enable_execute_command: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    group: typing.Optional[str] = pydantic.Field(None, description='')
    launch_type: typing.Optional[str] = pydantic.Field(None, description='')
    network_configuration: typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_NetworkConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    placement_constraints: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_PlacementConstraintPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    placement_strategy: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_PlacementStrategyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    platform_version: typing.Optional[str] = pydantic.Field(None, description='')
    propagate_tags: typing.Optional[str] = pydantic.Field(None, description='')
    reference_id: typing.Optional[str] = pydantic.Field(None, description='')
    tags: typing.Any = pydantic.Field(None, description='')
    task_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnScheduleDefEventbridgeparameterspropertyParams(pydantic.BaseModel):
    detail_type: str = pydantic.Field(..., description='')
    source: str = pydantic.Field(..., description='')
    ...

class CfnScheduleDefFlexibletimewindowpropertyParams(pydantic.BaseModel):
    mode: str = pydantic.Field(..., description='')
    maximum_window_in_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnScheduleDefKinesisparameterspropertyParams(pydantic.BaseModel):
    partition_key: str = pydantic.Field(..., description='')
    ...

class CfnScheduleDefNetworkconfigurationpropertyParams(pydantic.BaseModel):
    awsvpc_configuration: typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_AwsVpcConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnScheduleDefPlacementconstraintpropertyParams(pydantic.BaseModel):
    expression: typing.Optional[str] = pydantic.Field(None, description='')
    type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnScheduleDefPlacementstrategypropertyParams(pydantic.BaseModel):
    field: typing.Optional[str] = pydantic.Field(None, description='')
    type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnScheduleDefRetrypolicypropertyParams(pydantic.BaseModel):
    maximum_event_age_in_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='')
    maximum_retry_attempts: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnScheduleDefSagemakerpipelineparameterpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnScheduleDefSagemakerpipelineparameterspropertyParams(pydantic.BaseModel):
    pipeline_parameter_list: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_SageMakerPipelineParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnScheduleDefSqsparameterspropertyParams(pydantic.BaseModel):
    message_group_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnScheduleDefTargetpropertyParams(pydantic.BaseModel):
    arn: str = pydantic.Field(..., description='')
    role_arn: str = pydantic.Field(..., description='')
    dead_letter_config: typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_DeadLetterConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ecs_parameters: typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_EcsParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    event_bridge_parameters: typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_EventBridgeParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    input: typing.Optional[str] = pydantic.Field(None, description='')
    kinesis_parameters: typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_KinesisParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    retry_policy: typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_RetryPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    sage_maker_pipeline_parameters: typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_SageMakerPipelineParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    sqs_parameters: typing.Union[models.UnsupportedResource, models.aws_scheduler.CfnSchedule_SqsParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnScheduleDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnScheduleDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnScheduleDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnScheduleDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnScheduleDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnScheduleDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnScheduleDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnScheduleDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnScheduleDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnScheduleDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnScheduleDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnScheduleDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnScheduleDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnScheduleDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_scheduler.CfnScheduleGroup
class CfnScheduleGroupDef(BaseCfnResource):
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the schedule group.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .')
    _init_params: typing.ClassVar[list[str]] = ['name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_scheduler.CfnScheduleGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_scheduler.CfnScheduleGroupDefConfig] = pydantic.Field(None)


class CfnScheduleGroupDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_scheduler.CfnScheduleGroupDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_scheduler.CfnScheduleGroupDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_scheduler.CfnScheduleGroupDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_scheduler.CfnScheduleGroupDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_scheduler.CfnScheduleGroupDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_scheduler.CfnScheduleGroupDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_scheduler.CfnScheduleGroupDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_scheduler.CfnScheduleGroupDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_scheduler.CfnScheduleGroupDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_scheduler.CfnScheduleGroupDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_scheduler.CfnScheduleGroupDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_scheduler.CfnScheduleGroupDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_scheduler.CfnScheduleGroupDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnScheduleGroupDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnScheduleGroupDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnScheduleGroupDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnScheduleGroupDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnScheduleGroupDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnScheduleGroupDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnScheduleGroupDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnScheduleGroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnScheduleGroupDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnScheduleGroupDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnScheduleGroupDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnScheduleGroupDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnScheduleGroupDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnScheduleGroupDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_scheduler.CfnScheduleGroupProps
class CfnScheduleGroupPropsDef(BaseCfnProperty):
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the schedule group.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedulegroup.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_scheduler as scheduler\n\n    cfn_schedule_group_props = scheduler.CfnScheduleGroupProps(\n        name="name",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_scheduler.CfnScheduleGroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_scheduler.CfnScheduleProps
class CfnSchedulePropsDef(BaseCfnProperty):
    flexible_time_window: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_scheduler.CfnSchedule_FlexibleTimeWindowPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.\n')
    schedule_expression: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The expression that defines when the schedule runs. The following formats are supported. - ``at`` expression - ``at(yyyy-mm-ddThh:mm:ss)`` - ``rate`` expression - ``rate(value unit)`` - ``cron`` expression - ``cron(fields)`` You can use ``at`` expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use ``rate`` and ``cron`` expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month. A ``cron`` expression consists of six fields separated by white spaces: ``(minutes hours day_of_month month day_of_week year)`` . A ``rate`` expression consists of a *value* as a positive integer, and a *unit* with the following options: ``minute`` | ``minutes`` | ``hour`` | ``hours`` | ``day`` | ``days`` For more information and examples, see `Schedule types on EventBridge Scheduler <https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html>`_ in the *EventBridge Scheduler User Guide* .\n')
    target: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_scheduler.CfnSchedule_TargetPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description="The schedule's target details.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='The description you specify for the schedule.\n')
    end_date: typing.Optional[str] = pydantic.Field(None, description="The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the ``EndDate`` you specify. EventBridge Scheduler ignores ``EndDate`` for one-time schedules.\n")
    group_name: typing.Optional[str] = pydantic.Field(None, description='The name of the schedule group associated with this schedule.\n')
    kms_key_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) for the customer managed KMS key that EventBridge Scheduler will use to encrypt and decrypt your data.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the schedule.\n')
    schedule_expression_timezone: typing.Optional[str] = pydantic.Field(None, description='The timezone in which the scheduling expression is evaluated.\n')
    start_date: typing.Optional[str] = pydantic.Field(None, description="The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the ``StartDate`` you specify. EventBridge Scheduler ignores ``StartDate`` for one-time schedules.\n")
    state: typing.Optional[str] = pydantic.Field(None, description='Specifies whether the schedule is enabled or disabled. *Allowed Values* : ``ENABLED`` | ``DISABLED``\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-scheduler-schedule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_scheduler as scheduler\n\n    # tags: Any\n\n    cfn_schedule_props = scheduler.CfnScheduleProps(\n        flexible_time_window=scheduler.CfnSchedule.FlexibleTimeWindowProperty(\n            mode="mode",\n\n            # the properties below are optional\n            maximum_window_in_minutes=123\n        ),\n        schedule_expression="scheduleExpression",\n        target=scheduler.CfnSchedule.TargetProperty(\n            arn="arn",\n            role_arn="roleArn",\n\n            # the properties below are optional\n            dead_letter_config=scheduler.CfnSchedule.DeadLetterConfigProperty(\n                arn="arn"\n            ),\n            ecs_parameters=scheduler.CfnSchedule.EcsParametersProperty(\n                task_definition_arn="taskDefinitionArn",\n\n                # the properties below are optional\n                capacity_provider_strategy=[scheduler.CfnSchedule.CapacityProviderStrategyItemProperty(\n                    capacity_provider="capacityProvider",\n\n                    # the properties below are optional\n                    base=123,\n                    weight=123\n                )],\n                enable_ecs_managed_tags=False,\n                enable_execute_command=False,\n                group="group",\n                launch_type="launchType",\n                network_configuration=scheduler.CfnSchedule.NetworkConfigurationProperty(\n                    awsvpc_configuration=scheduler.CfnSchedule.AwsVpcConfigurationProperty(\n                        subnets=["subnets"],\n\n                        # the properties below are optional\n                        assign_public_ip="assignPublicIp",\n                        security_groups=["securityGroups"]\n                    )\n                ),\n                placement_constraints=[scheduler.CfnSchedule.PlacementConstraintProperty(\n                    expression="expression",\n                    type="type"\n                )],\n                placement_strategy=[scheduler.CfnSchedule.PlacementStrategyProperty(\n                    field="field",\n                    type="type"\n                )],\n                platform_version="platformVersion",\n                propagate_tags="propagateTags",\n                reference_id="referenceId",\n                tags=tags,\n                task_count=123\n            ),\n            event_bridge_parameters=scheduler.CfnSchedule.EventBridgeParametersProperty(\n                detail_type="detailType",\n                source="source"\n            ),\n            input="input",\n            kinesis_parameters=scheduler.CfnSchedule.KinesisParametersProperty(\n                partition_key="partitionKey"\n            ),\n            retry_policy=scheduler.CfnSchedule.RetryPolicyProperty(\n                maximum_event_age_in_seconds=123,\n                maximum_retry_attempts=123\n            ),\n            sage_maker_pipeline_parameters=scheduler.CfnSchedule.SageMakerPipelineParametersProperty(\n                pipeline_parameter_list=[scheduler.CfnSchedule.SageMakerPipelineParameterProperty(\n                    name="name",\n                    value="value"\n                )]\n            ),\n            sqs_parameters=scheduler.CfnSchedule.SqsParametersProperty(\n                message_group_id="messageGroupId"\n            )\n        ),\n\n        # the properties below are optional\n        description="description",\n        end_date="endDate",\n        group_name="groupName",\n        kms_key_arn="kmsKeyArn",\n        name="name",\n        schedule_expression_timezone="scheduleExpressionTimezone",\n        start_date="startDate",\n        state="state"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['flexible_time_window', 'schedule_expression', 'target', 'description', 'end_date', 'group_name', 'kms_key_arn', 'name', 'schedule_expression_timezone', 'start_date', 'state']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_scheduler.CfnScheduleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    CfnSchedule_AwsVpcConfigurationProperty: typing.Optional[dict[str, models.aws_scheduler.CfnSchedule_AwsVpcConfigurationPropertyDef]] = pydantic.Field(None)
    CfnSchedule_CapacityProviderStrategyItemProperty: typing.Optional[dict[str, models.aws_scheduler.CfnSchedule_CapacityProviderStrategyItemPropertyDef]] = pydantic.Field(None)
    CfnSchedule_DeadLetterConfigProperty: typing.Optional[dict[str, models.aws_scheduler.CfnSchedule_DeadLetterConfigPropertyDef]] = pydantic.Field(None)
    CfnSchedule_EcsParametersProperty: typing.Optional[dict[str, models.aws_scheduler.CfnSchedule_EcsParametersPropertyDef]] = pydantic.Field(None)
    CfnSchedule_EventBridgeParametersProperty: typing.Optional[dict[str, models.aws_scheduler.CfnSchedule_EventBridgeParametersPropertyDef]] = pydantic.Field(None)
    CfnSchedule_FlexibleTimeWindowProperty: typing.Optional[dict[str, models.aws_scheduler.CfnSchedule_FlexibleTimeWindowPropertyDef]] = pydantic.Field(None)
    CfnSchedule_KinesisParametersProperty: typing.Optional[dict[str, models.aws_scheduler.CfnSchedule_KinesisParametersPropertyDef]] = pydantic.Field(None)
    CfnSchedule_NetworkConfigurationProperty: typing.Optional[dict[str, models.aws_scheduler.CfnSchedule_NetworkConfigurationPropertyDef]] = pydantic.Field(None)
    CfnSchedule_PlacementConstraintProperty: typing.Optional[dict[str, models.aws_scheduler.CfnSchedule_PlacementConstraintPropertyDef]] = pydantic.Field(None)
    CfnSchedule_PlacementStrategyProperty: typing.Optional[dict[str, models.aws_scheduler.CfnSchedule_PlacementStrategyPropertyDef]] = pydantic.Field(None)
    CfnSchedule_RetryPolicyProperty: typing.Optional[dict[str, models.aws_scheduler.CfnSchedule_RetryPolicyPropertyDef]] = pydantic.Field(None)
    CfnSchedule_SageMakerPipelineParameterProperty: typing.Optional[dict[str, models.aws_scheduler.CfnSchedule_SageMakerPipelineParameterPropertyDef]] = pydantic.Field(None)
    CfnSchedule_SageMakerPipelineParametersProperty: typing.Optional[dict[str, models.aws_scheduler.CfnSchedule_SageMakerPipelineParametersPropertyDef]] = pydantic.Field(None)
    CfnSchedule_SqsParametersProperty: typing.Optional[dict[str, models.aws_scheduler.CfnSchedule_SqsParametersPropertyDef]] = pydantic.Field(None)
    CfnSchedule_TargetProperty: typing.Optional[dict[str, models.aws_scheduler.CfnSchedule_TargetPropertyDef]] = pydantic.Field(None)
    CfnSchedule: typing.Optional[dict[str, models.aws_scheduler.CfnScheduleDef]] = pydantic.Field(None)
    CfnScheduleGroup: typing.Optional[dict[str, models.aws_scheduler.CfnScheduleGroupDef]] = pydantic.Field(None)
    CfnScheduleGroupProps: typing.Optional[dict[str, models.aws_scheduler.CfnScheduleGroupPropsDef]] = pydantic.Field(None)
    CfnScheduleProps: typing.Optional[dict[str, models.aws_scheduler.CfnSchedulePropsDef]] = pydantic.Field(None)
    ...

import models
