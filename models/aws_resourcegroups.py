from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_resourcegroups.CfnGroup.ConfigurationItemProperty
class CfnGroup_ConfigurationItemPropertyDef(BaseStruct):
    parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_resourcegroups.CfnGroup_ConfigurationParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A collection of parameters for this configuration item. For the list of parameters that you can use with each configuration item ``Type`` , see `Supported resource types and parameters <https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types>`_ in the *AWS Resource Groups User Guide* .\n')
    type: typing.Optional[str] = pydantic.Field(None, description='Specifies the type of configuration item. Each item must have a unique value for type. For the list of the types that you can specify for a configuration item, see `Supported resource types and parameters <https://docs.aws.amazon.com/ARG/latest/APIReference/about-slg.html#about-slg-types>`_ in the *AWS Resource Groups User Guide* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resourcegroups-group-configurationitem.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_resourcegroups as resourcegroups\n\n    configuration_item_property = resourcegroups.CfnGroup.ConfigurationItemProperty(\n        parameters=[resourcegroups.CfnGroup.ConfigurationParameterProperty(\n            name="name",\n            values=["values"]\n        )],\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['parameters', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_resourcegroups.CfnGroup.ConfigurationItemProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_resourcegroups.CfnGroup.ConfigurationParameterProperty
class CfnGroup_ConfigurationParameterPropertyDef(BaseStruct):
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the group configuration parameter. For the list of parameters that you can use with each configuration item type, see `Supported resource types and parameters <https://docs.aws.amazon.com//ARG/latest/APIReference/about-slg.html#about-slg-types>`_ in the *AWS Resource Groups User Guide* .\n')
    values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The value or values to be used for the specified parameter. For the list of values you can use with each parameter, see `Supported resource types and parameters <https://docs.aws.amazon.com//ARG/latest/APIReference/about-slg.html#about-slg-types>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resourcegroups-group-configurationparameter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_resourcegroups as resourcegroups\n\n    configuration_parameter_property = resourcegroups.CfnGroup.ConfigurationParameterProperty(\n        name="name",\n        values=["values"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'values']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_resourcegroups.CfnGroup.ConfigurationParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_resourcegroups.CfnGroup.QueryProperty
class CfnGroup_QueryPropertyDef(BaseStruct):
    resource_type_filters: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Specifies limits to the types of resources that can be included in the resource group. For example, if ``ResourceTypeFilters`` is ``["AWS::EC2::Instance", "AWS::DynamoDB::Table"]`` , only EC2 instances or DynamoDB tables can be members of this resource group. The default value is ``["AWS::AllSupported"]`` .\n')
    stack_identifier: typing.Optional[str] = pydantic.Field(None, description="Specifies the ARN of a CloudFormation stack. All supported resources of the CloudFormation stack are members of the resource group. If you don't specify an ARN, this parameter defaults to the current stack that you are defining, which means that all the resources of the current stack are grouped. You can specify a value for ``StackIdentifier`` only when the ``ResourceQuery.Type`` property is ``CLOUDFORMATION_STACK_1_0.``\n")
    tag_filters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_resourcegroups.CfnGroup_TagFilterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of key-value pair objects that limit which resources can be members of the resource group. This property is required when the ``ResourceQuery.Type`` property is ``TAG_FILTERS_1_0`` . A resource must have a tag that matches every filter that is provided in the ``TagFilters`` list.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resourcegroups-group-query.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_resourcegroups as resourcegroups\n\n    query_property = resourcegroups.CfnGroup.QueryProperty(\n        resource_type_filters=["resourceTypeFilters"],\n        stack_identifier="stackIdentifier",\n        tag_filters=[resourcegroups.CfnGroup.TagFilterProperty(\n            key="key",\n            values=["values"]\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resource_type_filters', 'stack_identifier', 'tag_filters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_resourcegroups.CfnGroup.QueryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_resourcegroups.CfnGroup.ResourceQueryProperty
class CfnGroup_ResourceQueryPropertyDef(BaseStruct):
    query: typing.Union[models.UnsupportedResource, models.aws_resourcegroups.CfnGroup_QueryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The query that defines the membership of the group. This is a structure with properties that depend on the ``Type`` . The ``Query`` structure must be included in the following scenarios: - When the ``Type`` is ``TAG_FILTERS_1_0`` , you must specify a ``Query`` structure that contains a ``TagFilters`` list of tags. Resources with tags that match those in the ``TagFilter`` list become members of the resource group. - When the ``Type`` is ``CLOUDFORMATION_STACK_1_0`` then this field is required only when you must specify a CloudFormation stack other than the one you are defining. To do this, the ``Query`` structure must contain the ``StackIdentifier`` property. If you don't specify either a ``Query`` structure or a ``StackIdentifier`` within that ``Query`` , then it defaults to the CloudFormation stack that you're currently constructing.\n")
    type: typing.Optional[str] = pydantic.Field(None, description='Specifies the type of resource query that determines this group\'s membership. There are two valid query types:. - ``TAG_FILTERS_1_0`` indicates that the group is a tag-based group. To complete the group membership, you must include the ``TagFilters`` property to specify the tag filters to use in the query. - ``CLOUDFORMATION_STACK_1_0`` , the default, indicates that the group is a CloudFormation stack-based group. Group membership is based on the CloudFormation stack. You must specify the ``StackIdentifier`` property in the query to define which stack to associate the group with, or leave it empty to default to the stack where the group is defined.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resourcegroups-group-resourcequery.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_resourcegroups as resourcegroups\n\n    resource_query_property = resourcegroups.CfnGroup.ResourceQueryProperty(\n        query=resourcegroups.CfnGroup.QueryProperty(\n            resource_type_filters=["resourceTypeFilters"],\n            stack_identifier="stackIdentifier",\n            tag_filters=[resourcegroups.CfnGroup.TagFilterProperty(\n                key="key",\n                values=["values"]\n            )]\n        ),\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['query', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_resourcegroups.CfnGroup.ResourceQueryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_resourcegroups.CfnGroup.TagFilterProperty
class CfnGroup_TagFilterPropertyDef(BaseStruct):
    key: typing.Optional[str] = pydantic.Field(None, description="A string that defines a tag key. Only resources in the account that are tagged with a specified tag key are members of the tag-based resource group. This field is required when the ``ResourceQuery`` structure's ``Type`` property is ``TAG_FILTERS_1_0`` . You must specify at least one tag key.\n")
    values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of tag values that can be included in the tag-based resource group. This is optional. If you don\'t specify a value or values for a key, then an AWS resource with any value for that key is a member.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resourcegroups-group-tagfilter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_resourcegroups as resourcegroups\n\n    tag_filter_property = resourcegroups.CfnGroup.TagFilterProperty(\n        key="key",\n        values=["values"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'values']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_resourcegroups.CfnGroup.TagFilterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_resourcegroups.CfnGroup
class CfnGroupDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of a resource group. The name must be unique within the AWS Region in which you create the resource. To create multiple resource groups based on the same CloudFormation stack, you must generate unique names for each.\n')
    configuration: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_resourcegroups.CfnGroup_ConfigurationItemPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The service configuration currently associated with the resource group and in effect for the members of the resource group. A ``Configuration`` consists of one or more ``ConfigurationItem`` entries. For information about service configurations for resource groups and how to construct them, see `Service configurations for resource groups <https://docs.aws.amazon.com//ARG/latest/APIReference/about-slg.html>`_ in the *AWS Resource Groups User Guide* . .. epigraph:: You can include either a ``Configuration`` or a ``ResourceQuery`` , but not both.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the resource group.\n')
    resource_query: typing.Union[models.UnsupportedResource, models.aws_resourcegroups.CfnGroup_ResourceQueryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The resource query structure that is used to dynamically determine which AWS resources are members of the associated resource group. For more information about queries and how to construct them, see `Build queries and groups in AWS Resource Groups <https://docs.aws.amazon.com//ARG/latest/userguide/gettingstarted-query.html>`_ in the *AWS Resource Groups User Guide* .. epigraph:: - You can include either a ``ResourceQuery`` or a ``Configuration`` , but not both. - You can specify the group's membership either by using a ``ResourceQuery`` or by using a list of ``Resources`` , but not both.\n")
    resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of the Amazon Resource Names (ARNs) of AWS resources that you want to add to the specified group. .. epigraph:: - You can specify the group membership either by using a list of ``Resources`` or by using a ``ResourceQuery`` , but not both. - You can include a ``Resources`` property only if you also specify a ``Configuration`` property.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tag key and value pairs that are attached to the resource group.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'configuration', 'description', 'resource_query', 'resources', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['ConfigurationItemProperty', 'ConfigurationParameterProperty', 'QueryProperty', 'ResourceQueryProperty', 'TagFilterProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_resourcegroups.CfnGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_resourcegroups.CfnGroupDefConfig] = pydantic.Field(None)


class CfnGroupDefConfig(pydantic.BaseModel):
    ConfigurationItemProperty: typing.Optional[list[models.aws_resourcegroups.CfnGroupDefConfigurationitempropertyParams]] = pydantic.Field(None, description='')
    ConfigurationParameterProperty: typing.Optional[list[models.aws_resourcegroups.CfnGroupDefConfigurationparameterpropertyParams]] = pydantic.Field(None, description='')
    QueryProperty: typing.Optional[list[models.aws_resourcegroups.CfnGroupDefQuerypropertyParams]] = pydantic.Field(None, description='')
    ResourceQueryProperty: typing.Optional[list[models.aws_resourcegroups.CfnGroupDefResourcequerypropertyParams]] = pydantic.Field(None, description='')
    TagFilterProperty: typing.Optional[list[models.aws_resourcegroups.CfnGroupDefTagfilterpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_resourcegroups.CfnGroupDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_resourcegroups.CfnGroupDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_resourcegroups.CfnGroupDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_resourcegroups.CfnGroupDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_resourcegroups.CfnGroupDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_resourcegroups.CfnGroupDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_resourcegroups.CfnGroupDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_resourcegroups.CfnGroupDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_resourcegroups.CfnGroupDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_resourcegroups.CfnGroupDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_resourcegroups.CfnGroupDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_resourcegroups.CfnGroupDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_resourcegroups.CfnGroupDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnGroupDefConfigurationitempropertyParams(pydantic.BaseModel):
    parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_resourcegroups.CfnGroup_ConfigurationParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnGroupDefConfigurationparameterpropertyParams(pydantic.BaseModel):
    name: typing.Optional[str] = pydantic.Field(None, description='')
    values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnGroupDefQuerypropertyParams(pydantic.BaseModel):
    resource_type_filters: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    stack_identifier: typing.Optional[str] = pydantic.Field(None, description='')
    tag_filters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_resourcegroups.CfnGroup_TagFilterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnGroupDefResourcequerypropertyParams(pydantic.BaseModel):
    query: typing.Union[models.UnsupportedResource, models.aws_resourcegroups.CfnGroup_QueryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnGroupDefTagfilterpropertyParams(pydantic.BaseModel):
    key: typing.Optional[str] = pydantic.Field(None, description='')
    values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnGroupDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnGroupDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGroupDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnGroupDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGroupDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnGroupDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnGroupDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnGroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnGroupDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnGroupDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGroupDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnGroupDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnGroupDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGroupDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_resourcegroups.CfnGroupProps
class CfnGroupPropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of a resource group. The name must be unique within the AWS Region in which you create the resource. To create multiple resource groups based on the same CloudFormation stack, you must generate unique names for each.\n')
    configuration: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_resourcegroups.CfnGroup_ConfigurationItemPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The service configuration currently associated with the resource group and in effect for the members of the resource group. A ``Configuration`` consists of one or more ``ConfigurationItem`` entries. For information about service configurations for resource groups and how to construct them, see `Service configurations for resource groups <https://docs.aws.amazon.com//ARG/latest/APIReference/about-slg.html>`_ in the *AWS Resource Groups User Guide* . .. epigraph:: You can include either a ``Configuration`` or a ``ResourceQuery`` , but not both.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the resource group.\n')
    resource_query: typing.Union[models.UnsupportedResource, models.aws_resourcegroups.CfnGroup_ResourceQueryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The resource query structure that is used to dynamically determine which AWS resources are members of the associated resource group. For more information about queries and how to construct them, see `Build queries and groups in AWS Resource Groups <https://docs.aws.amazon.com//ARG/latest/userguide/gettingstarted-query.html>`_ in the *AWS Resource Groups User Guide* .. epigraph:: - You can include either a ``ResourceQuery`` or a ``Configuration`` , but not both. - You can specify the group's membership either by using a ``ResourceQuery`` or by using a list of ``Resources`` , but not both.\n")
    resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of the Amazon Resource Names (ARNs) of AWS resources that you want to add to the specified group. .. epigraph:: - You can specify the group membership either by using a list of ``Resources`` or by using a ``ResourceQuery`` , but not both. - You can include a ``Resources`` property only if you also specify a ``Configuration`` property.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tag key and value pairs that are attached to the resource group.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-resourcegroups-group.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_resourcegroups as resourcegroups\n\n    cfn_group_props = resourcegroups.CfnGroupProps(\n        name="name",\n\n        # the properties below are optional\n        configuration=[resourcegroups.CfnGroup.ConfigurationItemProperty(\n            parameters=[resourcegroups.CfnGroup.ConfigurationParameterProperty(\n                name="name",\n                values=["values"]\n            )],\n            type="type"\n        )],\n        description="description",\n        resource_query=resourcegroups.CfnGroup.ResourceQueryProperty(\n            query=resourcegroups.CfnGroup.QueryProperty(\n                resource_type_filters=["resourceTypeFilters"],\n                stack_identifier="stackIdentifier",\n                tag_filters=[resourcegroups.CfnGroup.TagFilterProperty(\n                    key="key",\n                    values=["values"]\n                )]\n            ),\n            type="type"\n        ),\n        resources=["resources"],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'configuration', 'description', 'resource_query', 'resources', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_resourcegroups.CfnGroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    CfnGroup_ConfigurationItemProperty: typing.Optional[dict[str, models.aws_resourcegroups.CfnGroup_ConfigurationItemPropertyDef]] = pydantic.Field(None)
    CfnGroup_ConfigurationParameterProperty: typing.Optional[dict[str, models.aws_resourcegroups.CfnGroup_ConfigurationParameterPropertyDef]] = pydantic.Field(None)
    CfnGroup_QueryProperty: typing.Optional[dict[str, models.aws_resourcegroups.CfnGroup_QueryPropertyDef]] = pydantic.Field(None)
    CfnGroup_ResourceQueryProperty: typing.Optional[dict[str, models.aws_resourcegroups.CfnGroup_ResourceQueryPropertyDef]] = pydantic.Field(None)
    CfnGroup_TagFilterProperty: typing.Optional[dict[str, models.aws_resourcegroups.CfnGroup_TagFilterPropertyDef]] = pydantic.Field(None)
    CfnGroup: typing.Optional[dict[str, models.aws_resourcegroups.CfnGroupDef]] = pydantic.Field(None)
    CfnGroupProps: typing.Optional[dict[str, models.aws_resourcegroups.CfnGroupPropsDef]] = pydantic.Field(None)
    ...

import models
