from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_ecr_assets.NetworkMode
class NetworkModeDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['custom', 'from_container']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecr_assets.NetworkMode'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_container']
    ...


    from_container: typing.Optional[models.aws_ecr_assets.NetworkModeDefFromContainerParams] = pydantic.Field(None, description="Reuse another container's network stack.")
    resource_config: typing.Optional[models.aws_ecr_assets.NetworkModeDefConfig] = pydantic.Field(None)


class NetworkModeDefConfig(pydantic.BaseModel):
    custom: typing.Optional[list[models.aws_ecr_assets.NetworkModeDefCustomParams]] = pydantic.Field(None, description='Used to specify a custom networking mode Use this if the networking mode name is not yet supported by the CDK.')

class NetworkModeDefCustomParams(pydantic.BaseModel):
    mode: str = pydantic.Field(..., description='The networking mode to use for docker build.')
    return_config: typing.Optional[list[models.aws_ecr_assets.NetworkModeDefConfig]] = pydantic.Field(None)
    ...

class NetworkModeDefFromContainerParams(pydantic.BaseModel):
    container_id: str = pydantic.Field(..., description="The target container's id or name.")
    ...


#  autogenerated from aws_cdk.aws_ecr_assets.Platform
class PlatformDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['custom']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecr_assets.Platform'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecr_assets.PlatformDefConfig] = pydantic.Field(None)


class PlatformDefConfig(pydantic.BaseModel):
    custom: typing.Optional[list[models.aws_ecr_assets.PlatformDefCustomParams]] = pydantic.Field(None, description='Used to specify a custom platform Use this if the platform name is not yet supported by the CDK.')

class PlatformDefCustomParams(pydantic.BaseModel):
    platform: str = pydantic.Field(..., description='The platform to use for docker build.')
    return_config: typing.Optional[list[models.aws_ecr_assets.PlatformDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_ecr_assets.DockerImageAsset
class DockerImageAssetDef(BaseConstruct):
    directory: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The directory where the Dockerfile is stored. Any directory inside with a name that matches the CDK output folder (cdk.out by default) will be excluded from the asset\n')
    asset_name: typing.Optional[str] = pydantic.Field(None, description='Unique identifier of the docker image asset and its potential revisions. Required if using AppScopedStagingSynthesizer. Default: - no asset name\n')
    build_args: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Build args to pass to the ``docker build`` command. Since Docker build arguments are resolved before deployment, keys and values cannot refer to unresolved tokens (such as ``lambda.functionArn`` or ``queue.queueUrl``). Default: - no build args are passed\n')
    build_secrets: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Build secrets. Docker BuildKit must be enabled to use build secrets. Default: - no build secrets\n')
    build_ssh: typing.Optional[str] = pydantic.Field(None, description='SSH agent socket or keys to pass to the ``docker build`` command. Docker BuildKit must be enabled to use the ssh flag Default: - no --ssh flag\n')
    cache_from: typing.Optional[typing.Sequence[typing.Union[models.aws_ecr_assets.DockerCacheOptionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Cache from options to pass to the ``docker build`` command. Default: - no cache from options are passed to the build command\n')
    cache_to: typing.Union[models.aws_ecr_assets.DockerCacheOptionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Cache to options to pass to the ``docker build`` command. Default: - no cache to options are passed to the build command\n')
    file: typing.Optional[str] = pydantic.Field(None, description="Path to the Dockerfile (relative to the directory). Default: 'Dockerfile'\n")
    invalidation: typing.Union[models.aws_ecr_assets.DockerImageAssetInvalidationOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Options to control which parameters are used to invalidate the asset hash. Default: - hash all parameters\n')
    network_mode: typing.Optional[models.aws_ecr_assets.NetworkModeDef] = pydantic.Field(None, description='Networking mode for the RUN commands during build. Support docker API 1.25+. Default: - no networking mode specified (the default networking mode ``NetworkMode.DEFAULT`` will be used)\n')
    outputs: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Outputs to pass to the ``docker build`` command. Default: - no outputs are passed to the build command (default outputs are used)\n')
    platform: typing.Optional[models.aws_ecr_assets.PlatformDef] = pydantic.Field(None, description='Platform to build for. *Requires Docker Buildx*. Default: - no platform specified (the current machine architecture will be used)\n')
    target: typing.Optional[str] = pydantic.Field(None, description='Docker target to build to. Default: - no target\n')
    extra_hash: typing.Optional[str] = pydantic.Field(None, description='Extra information to encode into the fingerprint (e.g. build instructions and other inputs). Default: - hash is only based on source content\n')
    exclude: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='File paths matching the patterns will be excluded. See ``ignoreMode`` to set the matching behavior. Has no effect on Assets bundled using the ``bundling`` property. Default: - nothing is excluded\n')
    follow_symlinks: typing.Optional[aws_cdk.SymlinkFollowMode] = pydantic.Field(None, description='A strategy for how to handle symlinks. Default: SymlinkFollowMode.NEVER\n')
    ignore_mode: typing.Optional[aws_cdk.IgnoreMode] = pydantic.Field(None, description='The ignore behavior to use for ``exclude`` patterns. Default: IgnoreMode.GLOB')
    _init_params: typing.ClassVar[list[str]] = ['directory', 'asset_name', 'build_args', 'build_secrets', 'build_ssh', 'cache_from', 'cache_to', 'file', 'invalidation', 'network_mode', 'outputs', 'platform', 'target', 'extra_hash', 'exclude', 'follow_symlinks', 'ignore_mode']
    _method_names: typing.ClassVar[list[str]] = ['add_resource_metadata']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecr_assets.DockerImageAsset'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecr_assets.DockerImageAssetDefConfig] = pydantic.Field(None)


class DockerImageAssetDefConfig(pydantic.BaseModel):
    add_resource_metadata: typing.Optional[list[models.aws_ecr_assets.DockerImageAssetDefAddResourceMetadataParams]] = pydantic.Field(None, description='Adds CloudFormation template metadata to the specified resource with information that indicates which resource property is mapped to this local asset.\nThis can be used by tools such as SAM CLI to provide local\nexperience such as local invocation and debugging of Lambda functions.\n\nAsset metadata will only be included if the stack is synthesized with the\n"aws:cdk:enable-asset-metadata" context key defined, which is the default\nbehavior when synthesizing via the CDK Toolkit.')
    repository_config: typing.Optional[models._interface_methods.AwsEcrIRepositoryDefConfig] = pydantic.Field(None)

class DockerImageAssetDefAddResourceMetadataParams(pydantic.BaseModel):
    resource: models.CfnResourceDef = pydantic.Field(..., description='The CloudFormation resource which is using this asset [disable-awslint:ref-via-interface].\n')
    resource_property: str = pydantic.Field(..., description='The property name where this asset is referenced.\n\n:see: https://github.com/aws/aws-cdk/issues/1432\n')
    ...


#  autogenerated from aws_cdk.aws_ecr_assets.TarballImageAsset
class TarballImageAssetDef(BaseConstruct):
    tarball_file: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Absolute path to the tarball. It is recommended to to use the script running directory (e.g. ``__dirname`` in Node.js projects or dirname of ``__file__`` in Python) if your tarball is located as a resource inside your project.')
    _init_params: typing.ClassVar[list[str]] = ['tarball_file']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecr_assets.TarballImageAsset'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ecr_assets.TarballImageAssetDefConfig] = pydantic.Field(None)


class TarballImageAssetDefConfig(pydantic.BaseModel):
    repository_config: typing.Optional[models._interface_methods.AwsEcrIRepositoryDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ecr_assets.DockerCacheOption
class DockerCacheOptionDef(BaseStruct):
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of cache to use. Refer to https://docs.docker.com/build/cache/backends/ for full list of backends. Default: - unspecified\n')
    params: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Any parameters to pass into the docker cache backend configuration. Refer to https://docs.docker.com/build/cache/backends/ for cache backend configuration. Default: {} No options provided\n\n:exampleMetadata: infused\n\nExample::\n\n    from aws_cdk.aws_ecr_assets import DockerImageAsset, Platform\n\n\n    asset = DockerImageAsset(self, "MyBuildImage",\n        directory=path.join(__dirname, "my-image"),\n        cache_from=[ecr_assets.DockerCacheOption(type="registry", params={"ref": "ghcr.io/myorg/myimage:cache"})],\n        cache_to=ecr_assets.DockerCacheOption(type="registry", params={"ref": "ghcr.io/myorg/myimage:cache", "mode": "max", "compression": "zstd"})\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'params']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecr_assets.DockerCacheOption'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecr_assets.DockerImageAssetInvalidationOptions
class DockerImageAssetInvalidationOptionsDef(BaseStruct):
    build_args: typing.Optional[bool] = pydantic.Field(None, description='Use ``buildArgs`` while calculating the asset hash. Default: true\n')
    build_secrets: typing.Optional[bool] = pydantic.Field(None, description='Use ``buildSecrets`` while calculating the asset hash. Default: true\n')
    build_ssh: typing.Optional[bool] = pydantic.Field(None, description='Use ``buildSsh`` while calculating the asset hash. Default: true\n')
    extra_hash: typing.Optional[bool] = pydantic.Field(None, description='Use ``extraHash`` while calculating the asset hash. Default: true\n')
    file: typing.Optional[bool] = pydantic.Field(None, description='Use ``file`` while calculating the asset hash. Default: true\n')
    network_mode: typing.Optional[bool] = pydantic.Field(None, description='Use ``networkMode`` while calculating the asset hash. Default: true\n')
    outputs: typing.Optional[bool] = pydantic.Field(None, description='Use ``outputs`` while calculating the asset hash. Default: true\n')
    platform: typing.Optional[bool] = pydantic.Field(None, description='Use ``platform`` while calculating the asset hash. Default: true\n')
    repository_name: typing.Optional[bool] = pydantic.Field(None, description='Use ``repositoryName`` while calculating the asset hash. Default: true\n')
    target: typing.Optional[bool] = pydantic.Field(None, description='Use ``target`` while calculating the asset hash. Default: true\n\n:exampleMetadata: infused\n\nExample::\n\n    from aws_cdk.aws_ecr_assets import DockerImageAsset\n\n\n    asset = DockerImageAsset(self, "MyBuildImage",\n        directory=path.join(__dirname, "my-image"),\n        build_args={\n            "HTTP_PROXY": "http://10.20.30.2:1234"\n        },\n        invalidation=ecr_assets.DockerImageAssetInvalidationOptions(\n            build_args=False\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['build_args', 'build_secrets', 'build_ssh', 'extra_hash', 'file', 'network_mode', 'outputs', 'platform', 'repository_name', 'target']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecr_assets.DockerImageAssetInvalidationOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecr_assets.DockerImageAssetOptions
class DockerImageAssetOptionsDef(BaseStruct):
    exclude: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='File paths matching the patterns will be excluded. See ``ignoreMode`` to set the matching behavior. Has no effect on Assets bundled using the ``bundling`` property. Default: - nothing is excluded\n')
    follow_symlinks: typing.Optional[aws_cdk.SymlinkFollowMode] = pydantic.Field(None, description='A strategy for how to handle symlinks. Default: SymlinkFollowMode.NEVER\n')
    ignore_mode: typing.Optional[aws_cdk.IgnoreMode] = pydantic.Field(None, description='The ignore behavior to use for ``exclude`` patterns. Default: IgnoreMode.GLOB\n')
    extra_hash: typing.Optional[str] = pydantic.Field(None, description='Extra information to encode into the fingerprint (e.g. build instructions and other inputs). Default: - hash is only based on source content\n')
    asset_name: typing.Optional[str] = pydantic.Field(None, description='Unique identifier of the docker image asset and its potential revisions. Required if using AppScopedStagingSynthesizer. Default: - no asset name\n')
    build_args: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Build args to pass to the ``docker build`` command. Since Docker build arguments are resolved before deployment, keys and values cannot refer to unresolved tokens (such as ``lambda.functionArn`` or ``queue.queueUrl``). Default: - no build args are passed\n')
    build_secrets: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Build secrets. Docker BuildKit must be enabled to use build secrets. Default: - no build secrets\n')
    build_ssh: typing.Optional[str] = pydantic.Field(None, description='SSH agent socket or keys to pass to the ``docker build`` command. Docker BuildKit must be enabled to use the ssh flag Default: - no --ssh flag\n')
    cache_from: typing.Optional[typing.Sequence[typing.Union[models.aws_ecr_assets.DockerCacheOptionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Cache from options to pass to the ``docker build`` command. Default: - no cache from options are passed to the build command\n')
    cache_to: typing.Union[models.aws_ecr_assets.DockerCacheOptionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Cache to options to pass to the ``docker build`` command. Default: - no cache to options are passed to the build command\n')
    file: typing.Optional[str] = pydantic.Field(None, description="Path to the Dockerfile (relative to the directory). Default: 'Dockerfile'\n")
    invalidation: typing.Union[models.aws_ecr_assets.DockerImageAssetInvalidationOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Options to control which parameters are used to invalidate the asset hash. Default: - hash all parameters\n')
    network_mode: typing.Optional[models.aws_ecr_assets.NetworkModeDef] = pydantic.Field(None, description='Networking mode for the RUN commands during build. Support docker API 1.25+. Default: - no networking mode specified (the default networking mode ``NetworkMode.DEFAULT`` will be used)\n')
    outputs: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Outputs to pass to the ``docker build`` command. Default: - no outputs are passed to the build command (default outputs are used)\n')
    platform: typing.Optional[models.aws_ecr_assets.PlatformDef] = pydantic.Field(None, description='Platform to build for. *Requires Docker Buildx*. Default: - no platform specified (the current machine architecture will be used)\n')
    target: typing.Optional[str] = pydantic.Field(None, description='Docker target to build to. Default: - no target\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_ecr_assets as ecr_assets\n\n    # network_mode: ecr_assets.NetworkMode\n    # platform: ecr_assets.Platform\n\n    docker_image_asset_options = ecr_assets.DockerImageAssetOptions(\n        asset_name="assetName",\n        build_args={\n            "build_args_key": "buildArgs"\n        },\n        build_secrets={\n            "build_secrets_key": "buildSecrets"\n        },\n        build_ssh="buildSsh",\n        cache_from=[ecr_assets.DockerCacheOption(\n            type="type",\n\n            # the properties below are optional\n            params={\n                "params_key": "params"\n            }\n        )],\n        cache_to=ecr_assets.DockerCacheOption(\n            type="type",\n\n            # the properties below are optional\n            params={\n                "params_key": "params"\n            }\n        ),\n        exclude=["exclude"],\n        extra_hash="extraHash",\n        file="file",\n        follow_symlinks=cdk.SymlinkFollowMode.NEVER,\n        ignore_mode=cdk.IgnoreMode.GLOB,\n        invalidation=ecr_assets.DockerImageAssetInvalidationOptions(\n            build_args=False,\n            build_secrets=False,\n            build_ssh=False,\n            extra_hash=False,\n            file=False,\n            network_mode=False,\n            outputs=False,\n            platform=False,\n            repository_name=False,\n            target=False\n        ),\n        network_mode=network_mode,\n        outputs=["outputs"],\n        platform=platform,\n        target="target"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['exclude', 'follow_symlinks', 'ignore_mode', 'extra_hash', 'asset_name', 'build_args', 'build_secrets', 'build_ssh', 'cache_from', 'cache_to', 'file', 'invalidation', 'network_mode', 'outputs', 'platform', 'target']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecr_assets.DockerImageAssetOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecr_assets.DockerImageAssetProps
class DockerImageAssetPropsDef(BaseStruct):
    exclude: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='File paths matching the patterns will be excluded. See ``ignoreMode`` to set the matching behavior. Has no effect on Assets bundled using the ``bundling`` property. Default: - nothing is excluded\n')
    follow_symlinks: typing.Optional[aws_cdk.SymlinkFollowMode] = pydantic.Field(None, description='A strategy for how to handle symlinks. Default: SymlinkFollowMode.NEVER\n')
    ignore_mode: typing.Optional[aws_cdk.IgnoreMode] = pydantic.Field(None, description='The ignore behavior to use for ``exclude`` patterns. Default: IgnoreMode.GLOB\n')
    extra_hash: typing.Optional[str] = pydantic.Field(None, description='Extra information to encode into the fingerprint (e.g. build instructions and other inputs). Default: - hash is only based on source content\n')
    asset_name: typing.Optional[str] = pydantic.Field(None, description='Unique identifier of the docker image asset and its potential revisions. Required if using AppScopedStagingSynthesizer. Default: - no asset name\n')
    build_args: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Build args to pass to the ``docker build`` command. Since Docker build arguments are resolved before deployment, keys and values cannot refer to unresolved tokens (such as ``lambda.functionArn`` or ``queue.queueUrl``). Default: - no build args are passed\n')
    build_secrets: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Build secrets. Docker BuildKit must be enabled to use build secrets. Default: - no build secrets\n')
    build_ssh: typing.Optional[str] = pydantic.Field(None, description='SSH agent socket or keys to pass to the ``docker build`` command. Docker BuildKit must be enabled to use the ssh flag Default: - no --ssh flag\n')
    cache_from: typing.Optional[typing.Sequence[typing.Union[models.aws_ecr_assets.DockerCacheOptionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Cache from options to pass to the ``docker build`` command. Default: - no cache from options are passed to the build command\n')
    cache_to: typing.Union[models.aws_ecr_assets.DockerCacheOptionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Cache to options to pass to the ``docker build`` command. Default: - no cache to options are passed to the build command\n')
    file: typing.Optional[str] = pydantic.Field(None, description="Path to the Dockerfile (relative to the directory). Default: 'Dockerfile'\n")
    invalidation: typing.Union[models.aws_ecr_assets.DockerImageAssetInvalidationOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Options to control which parameters are used to invalidate the asset hash. Default: - hash all parameters\n')
    network_mode: typing.Optional[models.aws_ecr_assets.NetworkModeDef] = pydantic.Field(None, description='Networking mode for the RUN commands during build. Support docker API 1.25+. Default: - no networking mode specified (the default networking mode ``NetworkMode.DEFAULT`` will be used)\n')
    outputs: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Outputs to pass to the ``docker build`` command. Default: - no outputs are passed to the build command (default outputs are used)\n')
    platform: typing.Optional[models.aws_ecr_assets.PlatformDef] = pydantic.Field(None, description='Platform to build for. *Requires Docker Buildx*. Default: - no platform specified (the current machine architecture will be used)\n')
    target: typing.Optional[str] = pydantic.Field(None, description='Docker target to build to. Default: - no target\n')
    directory: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The directory where the Dockerfile is stored. Any directory inside with a name that matches the CDK output folder (cdk.out by default) will be excluded from the asset\n\n:exampleMetadata: infused\n\nExample::\n\n    from aws_cdk.aws_ecr_assets import DockerImageAsset\n\n\n    asset = DockerImageAsset(self, "MyBuildImage",\n        directory=path.join(__dirname, "my-image"),\n        build_args={\n            "HTTP_PROXY": "http://10.20.30.2:1234"\n        },\n        invalidation=ecr_assets.DockerImageAssetInvalidationOptions(\n            build_args=False\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['exclude', 'follow_symlinks', 'ignore_mode', 'extra_hash', 'asset_name', 'build_args', 'build_secrets', 'build_ssh', 'cache_from', 'cache_to', 'file', 'invalidation', 'network_mode', 'outputs', 'platform', 'target', 'directory']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecr_assets.DockerImageAssetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ecr_assets.TarballImageAssetProps
class TarballImageAssetPropsDef(BaseStruct):
    tarball_file: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Absolute path to the tarball. It is recommended to to use the script running directory (e.g. ``__dirname`` in Node.js projects or dirname of ``__file__`` in Python) if your tarball is located as a resource inside your project.\n\n:exampleMetadata: infused\n\nExample::\n\n    from aws_cdk.aws_ecr_assets import TarballImageAsset\n\n\n    asset = TarballImageAsset(self, "MyBuildImage",\n        tarball_file="local-image.tar"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['tarball_file']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ecr_assets.TarballImageAssetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    NetworkMode: typing.Optional[dict[str, models.aws_ecr_assets.NetworkModeDef]] = pydantic.Field(None)
    Platform: typing.Optional[dict[str, models.aws_ecr_assets.PlatformDef]] = pydantic.Field(None)
    DockerImageAsset: typing.Optional[dict[str, models.aws_ecr_assets.DockerImageAssetDef]] = pydantic.Field(None)
    TarballImageAsset: typing.Optional[dict[str, models.aws_ecr_assets.TarballImageAssetDef]] = pydantic.Field(None)
    DockerCacheOption: typing.Optional[dict[str, models.aws_ecr_assets.DockerCacheOptionDef]] = pydantic.Field(None)
    DockerImageAssetInvalidationOptions: typing.Optional[dict[str, models.aws_ecr_assets.DockerImageAssetInvalidationOptionsDef]] = pydantic.Field(None)
    DockerImageAssetOptions: typing.Optional[dict[str, models.aws_ecr_assets.DockerImageAssetOptionsDef]] = pydantic.Field(None)
    DockerImageAssetProps: typing.Optional[dict[str, models.aws_ecr_assets.DockerImageAssetPropsDef]] = pydantic.Field(None)
    TarballImageAssetProps: typing.Optional[dict[str, models.aws_ecr_assets.TarballImageAssetPropsDef]] = pydantic.Field(None)
    ...

import models
