from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_eks.AccessPolicy
class AccessPolicyDef(BaseClass):
    access_scope: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.AccessScopeDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The scope of the access policy, which determines the level of access granted.\n')
    policy: typing.Union[models.aws_eks.AccessPolicyArnDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The access policy itself, which defines the specific permissions.')
    _init_params: typing.ClassVar[list[str]] = ['access_scope', 'policy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_access_policy_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.AccessPolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_access_policy_name']
    ...


    from_access_policy_name: typing.Optional[models.aws_eks.AccessPolicyDefFromAccessPolicyNameParams] = pydantic.Field(None, description='Import AccessPolicy by name.')

class AccessPolicyDefFromAccessPolicyNameParams(pydantic.BaseModel):
    policy_name: str = pydantic.Field(..., description='-\n')
    access_scope_type: aws_cdk.aws_eks.AccessScopeType = pydantic.Field(..., description='The scope of the access policy. This determines the level of access granted by the policy.\n')
    namespaces: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='An optional array of Kubernetes namespaces to which the access policy applies. Default: - no specific namespaces for this scope')
    ...


#  autogenerated from aws_cdk.aws_eks.AccessPolicyArn
class AccessPolicyArnDef(BaseClass):
    policy_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='- The name of the Amazon EKS access policy. This is used to construct the policy ARN.')
    _init_params: typing.ClassVar[list[str]] = ['policy_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['of']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.AccessPolicyArn'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.AccessPolicyArnDefConfig] = pydantic.Field(None)


class AccessPolicyArnDefConfig(pydantic.BaseModel):
    of: typing.Optional[list[models.aws_eks.AccessPolicyArnDefOfParams]] = pydantic.Field(None, description='Creates a new instance of the AccessPolicy class with the specified policy name.')

class AccessPolicyArnDefOfParams(pydantic.BaseModel):
    policy_name: str = pydantic.Field(..., description='The name of the access policy.\n')
    return_config: typing.Optional[list[models.aws_eks.AccessPolicyArnDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_eks.AlbControllerVersion
class AlbControllerVersionDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['of']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.AlbControllerVersion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.AlbControllerVersionDefConfig] = pydantic.Field(None)


class AlbControllerVersionDefConfig(pydantic.BaseModel):
    of: typing.Optional[list[models.aws_eks.AlbControllerVersionDefOfParams]] = pydantic.Field(None, description='Specify a custom version and an associated helm chart version.\nUse this if the version you need is not available in one of the predefined versions.\nNote that in this case, you will also need to provide an IAM policy in the controller options.\n\nALB controller version and helm chart version compatibility information can be found\nhere: https://github.com/aws/eks-charts/blob/v0.0.133/stable/aws-load-balancer-controller/Chart.yaml')

class AlbControllerVersionDefOfParams(pydantic.BaseModel):
    version: str = pydantic.Field(..., description='The version number.\n')
    helm_chart_version: typing.Optional[str] = pydantic.Field(None, description='The version of the helm chart. Version 1.4.1 is the default version to support legacy users.')
    return_config: typing.Optional[list[models.aws_eks.AlbControllerVersionDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_eks.EksOptimizedImage
class EksOptimizedImageDef(BaseClass):
    cpu_arch: typing.Optional[aws_cdk.aws_eks.CpuArch] = pydantic.Field(None, description='What cpu architecture to retrieve the image for (arm64 or x86_64). Default: CpuArch.X86_64\n')
    kubernetes_version: typing.Optional[str] = pydantic.Field(None, description='The Kubernetes version to use. Default: - The latest version\n')
    node_type: typing.Optional[aws_cdk.aws_eks.NodeType] = pydantic.Field(None, description='What instance type to retrieve the image for (standard or GPU-optimized). Default: NodeType.STANDARD')
    _init_params: typing.ClassVar[list[str]] = ['cpu_arch', 'kubernetes_version', 'node_type']
    _method_names: typing.ClassVar[list[str]] = ['get_image']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.EksOptimizedImage'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.EksOptimizedImageDefConfig] = pydantic.Field(None)


class EksOptimizedImageDefConfig(pydantic.BaseModel):
    get_image: typing.Optional[list[models.aws_eks.EksOptimizedImageDefGetImageParams]] = pydantic.Field(None, description='Return the correct image.')

class EksOptimizedImageDefGetImageParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_eks.EndpointAccess
class EndpointAccessDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['only_from']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.EndpointAccess'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.EndpointAccessDefConfig] = pydantic.Field(None)


class EndpointAccessDefConfig(pydantic.BaseModel):
    only_from: typing.Optional[list[models.aws_eks.EndpointAccessDefOnlyFromParams]] = pydantic.Field(None, description='Restrict public access to specific CIDR blocks.\nIf public access is disabled, this method will result in an error.')

class EndpointAccessDefOnlyFromParams(pydantic.BaseModel):
    cidr: list[str] = pydantic.Field(...)
    return_config: typing.Optional[list[models.aws_eks.EndpointAccessDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_eks.KubernetesVersion
class KubernetesVersionDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['of']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.KubernetesVersion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.KubernetesVersionDefConfig] = pydantic.Field(None)


class KubernetesVersionDefConfig(pydantic.BaseModel):
    of: typing.Optional[list[models.aws_eks.KubernetesVersionDefOfParams]] = pydantic.Field(None, description='Custom cluster version.')

class KubernetesVersionDefOfParams(pydantic.BaseModel):
    version: str = pydantic.Field(..., description='custom version number.')
    return_config: typing.Optional[list[models.aws_eks.KubernetesVersionDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_eks.AccessEntry
class AccessEntryDef(BaseConstruct):
    access_policies: typing.Union[typing.Sequence[typing.Union[models.aws_eks.AccessPolicyDef]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The access policies that define the permissions and scope for the access entry.\n')
    cluster: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ClusterDef, models.aws_eks.FargateClusterDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon EKS cluster to which the access entry applies.\n')
    principal: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the principal (user or role) to associate the access entry with.\n')
    access_entry_name: typing.Optional[str] = pydantic.Field(None, description='The name of the AccessEntry. Default: - No access entry name is provided\n')
    access_entry_type: typing.Optional[aws_cdk.aws_eks.AccessEntryType] = pydantic.Field(None, description='The type of the AccessEntry. Default: STANDARD')
    _init_params: typing.ClassVar[list[str]] = ['access_policies', 'cluster', 'principal', 'access_entry_name', 'access_entry_type']
    _method_names: typing.ClassVar[list[str]] = ['add_access_policies', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_access_entry_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.AccessEntry'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_access_entry_attributes']
    ...


    from_access_entry_attributes: typing.Optional[models.aws_eks.AccessEntryDefFromAccessEntryAttributesParams] = pydantic.Field(None, description='Imports an ``AccessEntry`` from its attributes.')
    resource_config: typing.Optional[models.aws_eks.AccessEntryDefConfig] = pydantic.Field(None)


class AccessEntryDefConfig(pydantic.BaseModel):
    add_access_policies: typing.Optional[list[models.aws_eks.AccessEntryDefAddAccessPoliciesParams]] = pydantic.Field(None, description='Add the access policies for this entry.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class AccessEntryDefAddAccessPoliciesParams(pydantic.BaseModel):
    new_access_policies: typing.Sequence[typing.Union[models.aws_eks.AccessPolicyDef]] = pydantic.Field(..., description='- The new access policies to add.')
    ...

class AccessEntryDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class AccessEntryDefFromAccessEntryAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='- The parent construct.\n')
    id: str = pydantic.Field(..., description='- The ID of the imported construct.\n')
    access_entry_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the access entry.\n')
    access_entry_name: str = pydantic.Field(..., description='The name of the access entry.\n')
    ...


#  autogenerated from aws_cdk.aws_eks.AlbController
class AlbControllerDef(BaseConstruct):
    cluster: typing.Union[models.aws_eks.ClusterDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='[disable-awslint:ref-via-interface] Cluster to install the controller onto.\n')
    version: typing.Union[models.aws_eks.AlbControllerVersionDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Version of the controller.\n')
    policy: typing.Any = pydantic.Field(None, description="The IAM policy to apply to the service account. If you're using one of the built-in versions, this is not required since CDK ships with the appropriate policies for those versions. However, if you are using a custom version, this is required (and validated). Default: - Corresponds to the predefined version.\n")
    repository: typing.Optional[str] = pydantic.Field(None, description="The repository to pull the controller image from. Note that the default repository works for most regions, but not all. If the repository is not applicable to your region, use a custom repository according to the information here: https://github.com/kubernetes-sigs/aws-load-balancer-controller/releases. Default: '602401143452.dkr.ecr.us-west-2.amazonaws.com/amazon/aws-load-balancer-controller'")
    _init_params: typing.ClassVar[list[str]] = ['cluster', 'version', 'policy', 'repository']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['create']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.AlbController'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.AlbControllerDefConfig] = pydantic.Field(None)


class AlbControllerDefConfig(pydantic.BaseModel):
    create: typing.Optional[list[models.aws_eks.AlbControllerDefCreateParams]] = pydantic.Field(None, description='Create the controller construct associated with this cluster and scope.\nSingleton per stack/cluster.')

class AlbControllerDefCreateParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    cluster: models.aws_eks.ClusterDef = pydantic.Field(..., description='[disable-awslint:ref-via-interface] Cluster to install the controller onto.\n')
    version: models.aws_eks.AlbControllerVersionDef = pydantic.Field(..., description='Version of the controller.\n')
    policy: typing.Any = pydantic.Field(None, description="The IAM policy to apply to the service account. If you're using one of the built-in versions, this is not required since CDK ships with the appropriate policies for those versions. However, if you are using a custom version, this is required (and validated). Default: - Corresponds to the predefined version.\n")
    repository: typing.Optional[str] = pydantic.Field(None, description="The repository to pull the controller image from. Note that the default repository works for most regions, but not all. If the repository is not applicable to your region, use a custom repository according to the information here: https://github.com/kubernetes-sigs/aws-load-balancer-controller/releases. Default: '602401143452.dkr.ecr.us-west-2.amazonaws.com/amazon/aws-load-balancer-controller'")
    return_config: typing.Optional[list[models.aws_eks.AlbControllerDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_eks.AwsAuth
class AwsAuthDef(BaseConstruct):
    cluster: typing.Union[models.aws_eks.ClusterDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The EKS cluster to apply this configuration to. [disable-awslint:ref-via-interface]')
    _init_params: typing.ClassVar[list[str]] = ['cluster']
    _method_names: typing.ClassVar[list[str]] = ['add_account', 'add_masters_role', 'add_role_mapping', 'add_user_mapping']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.AwsAuth'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.AwsAuthDefConfig] = pydantic.Field(None)


class AwsAuthDefConfig(pydantic.BaseModel):
    add_account: typing.Optional[list[models.aws_eks.AwsAuthDefAddAccountParams]] = pydantic.Field(None, description='Additional AWS account to add to the aws-auth configmap.')
    add_masters_role: typing.Optional[list[models.aws_eks.AwsAuthDefAddMastersRoleParams]] = pydantic.Field(None, description='Adds the specified IAM role to the ``system:masters`` RBAC group, which means that anyone that can assume it will be able to administer this Kubernetes system.')
    add_role_mapping: typing.Optional[list[models.aws_eks.AwsAuthDefAddRoleMappingParams]] = pydantic.Field(None, description='Adds a mapping between an IAM role to a Kubernetes user and groups.')
    add_user_mapping: typing.Optional[list[models.aws_eks.AwsAuthDefAddUserMappingParams]] = pydantic.Field(None, description='Adds a mapping between an IAM user to a Kubernetes user and groups.')

class AwsAuthDefAddAccountParams(pydantic.BaseModel):
    account_id: str = pydantic.Field(..., description='account number.')
    ...

class AwsAuthDefAddMastersRoleParams(pydantic.BaseModel):
    role: typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef] = pydantic.Field(..., description='The IAM role to add.\n')
    username: typing.Optional[str] = pydantic.Field(None, description='Optional user (defaults to the role ARN).')
    ...

class AwsAuthDefAddRoleMappingParams(pydantic.BaseModel):
    role: typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef] = pydantic.Field(..., description='The IAM role to map.\n')
    groups: typing.Sequence[str] = pydantic.Field(..., description='A list of groups within Kubernetes to which the role is mapped.\n')
    username: typing.Optional[str] = pydantic.Field(None, description='The user name within Kubernetes to map to the IAM role. Default: - By default, the user name is the ARN of the IAM role.')
    ...

class AwsAuthDefAddUserMappingParams(pydantic.BaseModel):
    user: typing.Union[models.aws_iam.UserDef] = pydantic.Field(..., description='The IAM user to map.\n')
    groups: typing.Sequence[str] = pydantic.Field(..., description='A list of groups within Kubernetes to which the role is mapped.\n')
    username: typing.Optional[str] = pydantic.Field(None, description='The user name within Kubernetes to map to the IAM role. Default: - By default, the user name is the ARN of the IAM role.')
    ...


#  autogenerated from aws_cdk.aws_eks.Cluster
class ClusterDef(BaseConstruct):
    bootstrap_cluster_creator_admin_permissions: typing.Optional[bool] = pydantic.Field(None, description='Whether or not IAM principal of the cluster creator was set as a cluster admin access entry during cluster creation time. Changing this value after the cluster has been created will result in the cluster being replaced. Default: true\n')
    default_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Number of instances to allocate as an initial capacity for this cluster. Instance type can be configured through ``defaultCapacityInstanceType``, which defaults to ``m5.large``. Use ``cluster.addAutoScalingGroupCapacity`` to add additional customized capacity. Set this to ``0`` is you wish to avoid the initial capacity allocation. Default: 2\n')
    default_capacity_instance: typing.Optional[models.aws_ec2.InstanceTypeDef] = pydantic.Field(None, description='The instance type to use for the default capacity. This will only be taken into account if ``defaultCapacity`` is > 0. Default: m5.large\n')
    default_capacity_type: typing.Optional[aws_cdk.aws_eks.DefaultCapacityType] = pydantic.Field(None, description='The default capacity type for the cluster. Default: NODEGROUP\n')
    kubectl_lambda_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The IAM role to pass to the Kubectl Lambda Handler. Default: - Default Lambda IAM Execution Role\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The tags assigned to the EKS cluster. Default: - none\n')
    alb_controller: typing.Union[models.aws_eks.AlbControllerOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Install the AWS Load Balancer Controller onto the cluster. Default: - The controller is not installed.\n')
    authentication_mode: typing.Optional[aws_cdk.aws_eks.AuthenticationMode] = pydantic.Field(None, description='The desired authentication mode for the cluster. Default: AuthenticationMode.CONFIG_MAP\n')
    awscli_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description='An AWS Lambda layer that contains the ``aws`` CLI. The handler expects the layer to include the following executables:: /opt/awscli/aws Default: - a default layer with the AWS CLI 1.x\n')
    cluster_handler_environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom environment variables when interacting with the EKS endpoint to manage the cluster lifecycle. Default: - No environment variables.\n')
    cluster_handler_security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description="A security group to associate with the Cluster Handler's Lambdas. The Cluster Handler's Lambdas are responsible for calling AWS's EKS API. Requires ``placeClusterHandlerInVpc`` to be set to true. Default: - No security group.\n")
    cluster_logging: typing.Optional[typing.Sequence[aws_cdk.aws_eks.ClusterLoggingTypes]] = pydantic.Field(None, description='The cluster log types which you want to enable. Default: - none\n')
    core_dns_compute_type: typing.Optional[aws_cdk.aws_eks.CoreDnsComputeType] = pydantic.Field(None, description='Controls the "eks.amazonaws.com/compute-type" annotation in the CoreDNS configuration on your cluster to determine which compute type to use for CoreDNS. Default: CoreDnsComputeType.EC2 (for ``FargateCluster`` the default is FARGATE)\n')
    endpoint_access: typing.Optional[models.aws_eks.EndpointAccessDef] = pydantic.Field(None, description='Configure access to the Kubernetes API server endpoint.. Default: EndpointAccess.PUBLIC_AND_PRIVATE\n')
    ip_family: typing.Optional[aws_cdk.aws_eks.IpFamily] = pydantic.Field(None, description='Specify which IP family is used to assign Kubernetes pod and service IP addresses. Default: - IpFamily.IP_V4\n')
    kubectl_environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Environment variables for the kubectl execution. Only relevant for kubectl enabled clusters. Default: - No environment variables.\n')
    kubectl_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description="An AWS Lambda Layer which includes ``kubectl`` and Helm. This layer is used by the kubectl handler to apply manifests and install helm charts. You must pick an appropriate releases of one of the ``@aws-cdk/layer-kubectl-vXX`` packages, that works with the version of Kubernetes you have chosen. If you don't supply this value ``kubectl`` 1.20 will be used, but that version is most likely too old. The handler expects the layer to include the following executables:: /opt/helm/helm /opt/kubectl/kubectl Default: - a default layer with Kubectl 1.20.\n")
    kubectl_memory: typing.Optional[models.SizeDef] = pydantic.Field(None, description="Amount of memory to allocate to the provider's lambda function. Default: Size.gibibytes(1)\n")
    masters_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role that will be added to the ``system:masters`` Kubernetes RBAC group. Default: - no masters role.\n')
    on_event_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description='An AWS Lambda Layer which includes the NPM dependency ``proxy-agent``. This layer is used by the onEvent handler to route AWS SDK requests through a proxy. By default, the provider will use the layer included in the "aws-lambda-layer-node-proxy-agent" SAR application which is available in all commercial regions. To deploy the layer locally define it in your app as follows:: const layer = new lambda.LayerVersion(this, \'proxy-agent-layer\', { code: lambda.Code.fromAsset(`${__dirname}/layer.zip`), compatibleRuntimes: [lambda.Runtime.NODEJS_LATEST], }); Default: - a layer bundled with this module.\n')
    output_masters_role_arn: typing.Optional[bool] = pydantic.Field(None, description='Determines whether a CloudFormation output with the ARN of the "masters" IAM role will be synthesized (if ``mastersRole`` is specified). Default: false\n')
    place_cluster_handler_in_vpc: typing.Optional[bool] = pydantic.Field(None, description='If set to true, the cluster handler functions will be placed in the private subnets of the cluster vpc, subject to the ``vpcSubnets`` selection strategy. Default: false\n')
    prune: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether Kubernetes resources added through ``addManifest()`` can be automatically pruned. When this is enabled (default), prune labels will be allocated and injected to each resource. These labels will then be used when issuing the ``kubectl apply`` operation with the ``--prune`` switch. Default: true\n')
    secrets_encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='KMS secret for envelope encryption for Kubernetes secrets. Default: - By default, Kubernetes stores all secret object data within etcd and all etcd volumes used by Amazon EKS are encrypted at the disk-level using AWS-Managed encryption keys.\n')
    service_ipv4_cidr: typing.Optional[str] = pydantic.Field(None, description='The CIDR block to assign Kubernetes service IP addresses from. Default: - Kubernetes assigns addresses from either the 10.100.0.0/16 or 172.20.0.0/16 CIDR blocks\n')
    version: typing.Union[models.aws_eks.KubernetesVersionDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Kubernetes version to run in the cluster.\n')
    cluster_name: typing.Optional[str] = pydantic.Field(None, description='Name for the cluster. Default: - Automatically generated name\n')
    output_cluster_name: typing.Optional[bool] = pydantic.Field(None, description='Determines whether a CloudFormation output with the name of the cluster will be synthesized. Default: false\n')
    output_config_command: typing.Optional[bool] = pydantic.Field(None, description='Determines whether a CloudFormation output with the ``aws eks update-kubeconfig`` command will be synthesized. This command will include the cluster name and, if applicable, the ARN of the masters IAM role. Default: true\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='Role that provides permissions for the Kubernetes control plane to make calls to AWS API operations on your behalf. Default: - A role is automatically created for you\n')
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='Security Group to use for Control Plane ENIs. Default: - A security group is automatically created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC in which to create the Cluster. Default: - a VPC with default configuration will be created and can be accessed through ``cluster.vpc``.\n')
    vpc_subnets: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Where to place EKS Control Plane ENIs. For example, to only select private subnets, supply the following: ``vpcSubnets: [{ subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS }]`` Default: - All public and private subnets')
    _init_params: typing.ClassVar[list[str]] = ['bootstrap_cluster_creator_admin_permissions', 'default_capacity', 'default_capacity_instance', 'default_capacity_type', 'kubectl_lambda_role', 'tags', 'alb_controller', 'authentication_mode', 'awscli_layer', 'cluster_handler_environment', 'cluster_handler_security_group', 'cluster_logging', 'core_dns_compute_type', 'endpoint_access', 'ip_family', 'kubectl_environment', 'kubectl_layer', 'kubectl_memory', 'masters_role', 'on_event_layer', 'output_masters_role_arn', 'place_cluster_handler_in_vpc', 'prune', 'secrets_encryption_key', 'service_ipv4_cidr', 'version', 'cluster_name', 'output_cluster_name', 'output_config_command', 'role', 'security_group', 'vpc', 'vpc_subnets']
    _method_names: typing.ClassVar[list[str]] = ['add_auto_scaling_group_capacity', 'add_cdk8s_chart', 'add_fargate_profile', 'add_helm_chart', 'add_manifest', 'add_nodegroup_capacity', 'add_service_account', 'apply_removal_policy', 'connect_auto_scaling_group_capacity', 'get_ingress_load_balancer_address', 'get_service_load_balancer_address', 'grant_access']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_cluster_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.Cluster'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_cluster_attributes']
    ...


    from_cluster_attributes: typing.Optional[models.aws_eks.ClusterDefFromClusterAttributesParams] = pydantic.Field(None, description='Import an existing cluster.')
    resource_config: typing.Optional[models.aws_eks.ClusterDefConfig] = pydantic.Field(None)


class ClusterDefConfig(pydantic.BaseModel):
    add_auto_scaling_group_capacity: typing.Optional[list[models.aws_eks.ClusterDefAddAutoScalingGroupCapacityParams]] = pydantic.Field(None, description='Add nodes to this EKS cluster.\nThe nodes will automatically be configured with the right VPC and AMI\nfor the instance type and Kubernetes version.\n\nNote that if you specify ``updateType: RollingUpdate`` or ``updateType: ReplacingUpdate``, your nodes might be replaced at deploy\ntime without notice in case the recommended AMI for your machine image type has been updated by AWS.\nThe default behavior for ``updateType`` is ``None``, which means only new instances will be launched using the new AMI.\n\nSpot instances will be labeled ``lifecycle=Ec2Spot`` and tainted with ``PreferNoSchedule``.\nIn addition, the `spot interrupt handler <https://github.com/awslabs/ec2-spot-labs/tree/master/ec2-spot-eks-solution/spot-termination-handler>`_\ndaemon will be installed on all spot instances to handle\n`EC2 Spot Instance Termination Notices <https://aws.amazon.com/blogs/aws/new-ec2-spot-instance-termination-notices/>`_.')
    add_cdk8s_chart: typing.Optional[list[models.aws_eks.ClusterDefAddCdk8SChartParams]] = pydantic.Field(None, description='Defines a CDK8s chart in this cluster.')
    add_fargate_profile: typing.Optional[list[models.aws_eks.ClusterDefAddFargateProfileParams]] = pydantic.Field(None, description='Adds a Fargate profile to this cluster.')
    add_helm_chart: typing.Optional[list[models.aws_eks.ClusterDefAddHelmChartParams]] = pydantic.Field(None, description='Defines a Helm chart in this cluster.')
    add_manifest: typing.Optional[list[models.aws_eks.ClusterDefAddManifestParams]] = pydantic.Field(None, description='Defines a Kubernetes resource in this cluster.\nThe manifest will be applied/deleted using kubectl as needed.')
    add_nodegroup_capacity: typing.Optional[list[models.aws_eks.ClusterDefAddNodegroupCapacityParams]] = pydantic.Field(None, description='Add managed nodegroup to this Amazon EKS cluster.\nThis method will create a new managed nodegroup and add into the capacity.')
    add_service_account: typing.Optional[list[models.aws_eks.ClusterDefAddServiceAccountParams]] = pydantic.Field(None, description='Creates a new service account with corresponding IAM Role (IRSA).')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    connect_auto_scaling_group_capacity: typing.Optional[list[models.aws_eks.ClusterDefConnectAutoScalingGroupCapacityParams]] = pydantic.Field(None, description="Connect capacity in the form of an existing AutoScalingGroup to the EKS cluster.\nThe AutoScalingGroup must be running an EKS-optimized AMI containing the\n/etc/eks/bootstrap.sh script. This method will configure Security Groups,\nadd the right policies to the instance role, apply the right tags, and add\nthe required user data to the instance's launch configuration.\n\nSpot instances will be labeled ``lifecycle=Ec2Spot`` and tainted with ``PreferNoSchedule``.\nIf kubectl is enabled, the\n`spot interrupt handler <https://github.com/awslabs/ec2-spot-labs/tree/master/ec2-spot-eks-solution/spot-termination-handler>`_\ndaemon will be installed on all spot instances to handle\n`EC2 Spot Instance Termination Notices <https://aws.amazon.com/blogs/aws/new-ec2-spot-instance-termination-notices/>`_.\n\nPrefer to use ``addAutoScalingGroupCapacity`` if possible.")
    get_ingress_load_balancer_address: typing.Optional[list[models.aws_eks.ClusterDefGetIngressLoadBalancerAddressParams]] = pydantic.Field(None, description='Fetch the load balancer address of an ingress backed by a load balancer.')
    get_service_load_balancer_address: typing.Optional[list[models.aws_eks.ClusterDefGetServiceLoadBalancerAddressParams]] = pydantic.Field(None, description="Fetch the load balancer address of a service of type 'LoadBalancer'.")
    grant_access: typing.Optional[list[models.aws_eks.ClusterDefGrantAccessParams]] = pydantic.Field(None, description='Grants the specified IAM principal access to the EKS cluster based on the provided access policies.\nThis method creates an ``AccessEntry`` construct that grants the specified IAM principal the access permissions\ndefined by the provided ``IAccessPolicy`` array. This allows the IAM principal to perform the actions permitted\nby the access policies within the EKS cluster.')
    admin_role_config: typing.Optional[models.aws_iam.RoleDefConfig] = pydantic.Field(None)
    aws_auth_config: typing.Optional[models.aws_eks.AwsAuthDefConfig] = pydantic.Field(None)
    cluster_security_group_config: typing.Optional[models._interface_methods.AwsEc2ISecurityGroupDefConfig] = pydantic.Field(None)
    connections_config: typing.Optional[models.aws_ec2.ConnectionsDefConfig] = pydantic.Field(None)
    open_id_connect_provider_config: typing.Optional[models._interface_methods.AwsIamIOpenIdConnectProviderDefConfig] = pydantic.Field(None)
    role_config: typing.Optional[models._interface_methods.AwsIamIRoleDefConfig] = pydantic.Field(None)
    vpc_config: typing.Optional[models._interface_methods.AwsEc2IVpcDefConfig] = pydantic.Field(None)

class ClusterDefAddAutoScalingGroupCapacityParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    instance_type: models.aws_ec2.InstanceTypeDef = pydantic.Field(..., description='Instance type of the instances to start.\n')
    bootstrap_enabled: typing.Optional[bool] = pydantic.Field(None, description='Configures the EC2 user-data script for instances in this autoscaling group to bootstrap the node (invoke ``/etc/eks/bootstrap.sh``) and associate it with the EKS cluster. If you wish to provide a custom user data script, set this to ``false`` and manually invoke ``autoscalingGroup.addUserData()``. Default: true\n')
    bootstrap_options: typing.Union[models.aws_eks.BootstrapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='EKS node bootstrapping options. Default: - none\n')
    machine_image_type: typing.Optional[aws_cdk.aws_eks.MachineImageType] = pydantic.Field(None, description='Machine image type. Default: MachineImageType.AMAZON_LINUX_2\n')
    map_role: typing.Optional[bool] = pydantic.Field(None, description='Will automatically update the aws-auth ConfigMap to map the IAM instance role to RBAC. This cannot be explicitly set to ``true`` if the cluster has kubectl disabled. Default: - true if the cluster has kubectl enabled (which is the default).\n')
    spot_interrupt_handler: typing.Optional[bool] = pydantic.Field(None, description="Installs the AWS spot instance interrupt handler on the cluster if it's not already added. Only relevant if ``spotPrice`` is used. Default: true\n")
    allow_all_outbound: typing.Optional[bool] = pydantic.Field(None, description='Whether the instances can initiate connections to anywhere by default. Default: true\n')
    associate_public_ip_address: typing.Optional[bool] = pydantic.Field(None, description='Whether instances in the Auto Scaling Group should have public IP addresses associated with them. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified Default: - Use subnet setting.\n')
    auto_scaling_group_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Auto Scaling group. This name must be unique per Region per account. Default: - Auto generated by CloudFormation\n')
    block_devices: typing.Optional[typing.Sequence[typing.Union[models.aws_autoscaling.BlockDeviceDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Specifies how block devices are exposed to the instance. You can specify virtual devices and EBS volumes. Each instance that is launched has an associated root device volume, either an Amazon EBS volume or an instance store volume. You can use block device mappings to specify additional EBS volumes or instance store volumes to attach to an instance when it is launched. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified Default: - Uses the block device mapping of the AMI\n')
    capacity_rebalance: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether Capacity Rebalancing is enabled. When you turn on Capacity Rebalancing, Amazon EC2 Auto Scaling attempts to launch a Spot Instance whenever Amazon EC2 notifies that a Spot Instance is at an elevated risk of interruption. After launching a new instance, it then terminates an old instance. Default: false\n')
    cooldown: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Default scaling cooldown for this AutoScalingGroup. Default: Duration.minutes(5)\n')
    default_instance_warmup: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The amount of time, in seconds, until a newly launched instance can contribute to the Amazon CloudWatch metrics. This delay lets an instance finish initializing before Amazon EC2 Auto Scaling aggregates instance metrics, resulting in more reliable usage data. Set this value equal to the amount of time that it takes for resource consumption to become stable after an instance reaches the InService state. To optimize the performance of scaling policies that scale continuously, such as target tracking and step scaling policies, we strongly recommend that you enable the default instance warmup, even if its value is set to 0 seconds Default instance warmup will not be added if no value is specified Default: None\n')
    desired_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Initial amount of instances in the fleet. If this is set to a number, every deployment will reset the amount of instances to this number. It is recommended to leave this value blank. Default: minCapacity, and leave unchanged during deployment\n')
    group_metrics: typing.Optional[typing.Sequence[models.aws_autoscaling.GroupMetricsDef]] = pydantic.Field(None, description='Enable monitoring for group metrics, these metrics describe the group rather than any of its instances. To report all group metrics use ``GroupMetrics.all()`` Group metrics are reported in a granularity of 1 minute at no additional charge. Default: - no group metrics will be reported\n')
    health_check: typing.Optional[models.aws_autoscaling.HealthCheckDef] = pydantic.Field(None, description='Configuration for health checks. Default: - HealthCheck.ec2 with no grace period\n')
    ignore_unmodified_size_properties: typing.Optional[bool] = pydantic.Field(None, description="If the ASG has scheduled actions, don't reset unchanged group sizes. Only used if the ASG has scheduled actions (which may scale your ASG up or down regardless of cdk deployments). If true, the size of the group will only be reset if it has been changed in the CDK app. If false, the sizes will always be changed back to what they were in the CDK app on deployment. Default: true\n")
    instance_monitoring: typing.Optional[aws_cdk.aws_autoscaling.Monitoring] = pydantic.Field(None, description='Controls whether instances in this group are launched with detailed or basic monitoring. When detailed monitoring is enabled, Amazon CloudWatch generates metrics every minute and your account is charged a fee. When you disable detailed monitoring, CloudWatch generates metrics every 5 minutes. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified Default: - Monitoring.DETAILED\n')
    key_name: typing.Optional[str] = pydantic.Field(None, description='(deprecated) Name of SSH keypair to grant access to instances. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified You can either specify ``keyPair`` or ``keyName``, not both. Default: - No SSH access will be possible.\n')
    key_pair: typing.Optional[typing.Union[models.aws_ec2.KeyPairDef]] = pydantic.Field(None, description='The SSH keypair to grant access to the instance. Feature flag ``AUTOSCALING_GENERATE_LAUNCH_TEMPLATE`` must be enabled to use this property. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified. You can either specify ``keyPair`` or ``keyName``, not both. Default: - No SSH access will be possible.\n')
    max_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Maximum number of instances in the fleet. Default: desiredCapacity\n')
    max_instance_lifetime: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum amount of time that an instance can be in service. The maximum duration applies to all current and future instances in the group. As an instance approaches its maximum duration, it is terminated and replaced, and cannot be used again. You must specify a value of at least 604,800 seconds (7 days). To clear a previously set value, leave this property undefined. Default: none\n')
    min_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Minimum number of instances in the fleet. Default: 1\n')
    new_instances_protected_from_scale_in: typing.Optional[bool] = pydantic.Field(None, description="Whether newly-launched instances are protected from termination by Amazon EC2 Auto Scaling when scaling in. By default, Auto Scaling can terminate an instance at any time after launch when scaling in an Auto Scaling Group, subject to the group's termination policy. However, you may wish to protect newly-launched instances from being scaled in if they are going to run critical applications that should not be prematurely terminated. This flag must be enabled if the Auto Scaling Group will be associated with an ECS Capacity Provider with managed termination protection. Default: false\n")
    notifications: typing.Optional[typing.Sequence[typing.Union[models.aws_autoscaling.NotificationConfigurationDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Configure autoscaling group to send notifications about fleet changes to an SNS topic(s). Default: - No fleet change notifications will be sent.\n')
    signals: typing.Optional[models.aws_autoscaling.SignalsDef] = pydantic.Field(None, description='Configure waiting for signals during deployment. Use this to pause the CloudFormation deployment to wait for the instances in the AutoScalingGroup to report successful startup during creation and updates. The UserData script needs to invoke ``cfn-signal`` with a success or failure code after it is done setting up the instance. Without waiting for signals, the CloudFormation deployment will proceed as soon as the AutoScalingGroup has been created or updated but before the instances in the group have been started. For example, to have instances wait for an Elastic Load Balancing health check before they signal success, add a health-check verification by using the cfn-init helper script. For an example, see the verify_instance_health command in the Auto Scaling rolling updates sample template: https://github.com/awslabs/aws-cloudformation-templates/blob/master/aws/services/AutoScaling/AutoScalingRollingUpdates.yaml Default: - Do not wait for signals\n')
    spot_price: typing.Optional[str] = pydantic.Field(None, description='The maximum hourly price (in USD) to be paid for any Spot Instance launched to fulfill the request. Spot Instances are launched when the price you specify exceeds the current Spot market price. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified Default: none\n')
    ssm_session_permissions: typing.Optional[bool] = pydantic.Field(None, description='Add SSM session permissions to the instance role. Setting this to ``true`` adds the necessary permissions to connect to the instance using SSM Session Manager. You can do this from the AWS Console. NOTE: Setting this flag to ``true`` may not be enough by itself. You must also use an AMI that comes with the SSM Agent, or install the SSM Agent yourself. See `Working with SSM Agent <https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-agent.html>`_ in the SSM Developer Guide. Default: false\n')
    termination_policies: typing.Optional[typing.Sequence[aws_cdk.aws_autoscaling.TerminationPolicy]] = pydantic.Field(None, description='A policy or a list of policies that are used to select the instances to terminate. The policies are executed in the order that you list them. Default: - ``TerminationPolicy.DEFAULT``\n')
    termination_policy_custom_lambda_function_arn: typing.Optional[str] = pydantic.Field(None, description='A lambda function Arn that can be used as a custom termination policy to select the instances to terminate. This property must be specified if the TerminationPolicy.CUSTOM_LAMBDA_FUNCTION is used. Default: - No lambda function Arn will be supplied\n')
    update_policy: typing.Optional[models.aws_autoscaling.UpdatePolicyDef] = pydantic.Field(None, description="What to do when an AutoScalingGroup's instance configuration is changed. This is applied when any of the settings on the ASG are changed that affect how the instances should be created (VPC, instance type, startup scripts, etc.). It indicates how the existing instances should be replaced with new instances matching the new config. By default, nothing is done and only new instances are launched with the new config. Default: - ``UpdatePolicy.rollingUpdate()`` if using ``init``, ``UpdatePolicy.none()`` otherwise\n")
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Where to place instances within the VPC. Default: - All Private subnets.')
    return_config: typing.Optional[list[models.aws_autoscaling.AutoScalingGroupDefConfig]] = pydantic.Field(None)
    ...

class ClusterDefAddCdk8SChartParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='logical id of this chart.\n')
    chart: models.constructs.ConstructDef = pydantic.Field(..., description='the cdk8s chart.\n')
    ingress_alb: typing.Optional[bool] = pydantic.Field(None, description='Automatically detect ``Ingress`` resources in the manifest and annotate them so they are picked up by an ALB Ingress Controller. Default: false\n')
    ingress_alb_scheme: typing.Optional[aws_cdk.aws_eks.AlbScheme] = pydantic.Field(None, description='Specify the ALB scheme that should be applied to ``Ingress`` resources. Only applicable if ``ingressAlb`` is set to ``true``. Default: AlbScheme.INTERNAL\n')
    prune: typing.Optional[bool] = pydantic.Field(None, description='When a resource is removed from a Kubernetes manifest, it no longer appears in the manifest, and there is no way to know that this resource needs to be deleted. To address this, ``kubectl apply`` has a ``--prune`` option which will query the cluster for all resources with a specific label and will remove all the labeld resources that are not part of the applied manifest. If this option is disabled and a resource is removed, it will become "orphaned" and will not be deleted from the cluster. When this option is enabled (default), the construct will inject a label to all Kubernetes resources included in this manifest which will be used to prune resources when the manifest changes via ``kubectl apply --prune``. The label name will be ``aws.cdk.eks/prune-<ADDR>`` where ``<ADDR>`` is the 42-char unique address of this construct in the construct tree. Value is empty. Default: - based on the prune option of the cluster, which is ``true`` unless otherwise specified.\n')
    skip_validation: typing.Optional[bool] = pydantic.Field(None, description='A flag to signify if the manifest validation should be skipped. Default: false\n')
    ...

class ClusterDefAddFargateProfileParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='the id of this profile.\n')
    selectors: typing.Sequence[typing.Union[models.aws_eks.SelectorDef, dict[str, typing.Any]]] = pydantic.Field(..., description='The selectors to match for pods to use this Fargate profile. Each selector must have an associated namespace. Optionally, you can also specify labels for a namespace. At least one selector is required and you may specify up to five selectors.\n')
    fargate_profile_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Fargate profile. Default: - generated\n')
    pod_execution_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The pod execution role to use for pods that match the selectors in the Fargate profile. The pod execution role allows Fargate infrastructure to register with your cluster as a node, and it provides read access to Amazon ECR image repositories. Default: - a role will be automatically created\n')
    subnet_selection: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Select which subnets to launch your pods into. At this time, pods running on Fargate are not assigned public IP addresses, so only private subnets (with no direct route to an Internet Gateway) are allowed. You must specify the VPC to customize the subnet selection Default: - all private subnets of the VPC are selected.\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC from which to select subnets to launch your pods into. By default, all private subnets are selected. You can customize this using ``subnetSelection``. Default: - all private subnets used by the EKS cluster\n\n:see: https://docs.aws.amazon.com/eks/latest/userguide/fargate-profile.html\n')
    return_config: typing.Optional[list[models.aws_eks.FargateProfileDefConfig]] = pydantic.Field(None)
    ...

class ClusterDefAddHelmChartParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='logical id of this chart.\n')
    atomic: typing.Optional[bool] = pydantic.Field(None, description='Whether or not Helm should treat this operation as atomic; if set, upgrade process rolls back changes made in case of failed upgrade. The --wait flag will be set automatically if --atomic is used. Default: false\n')
    chart: typing.Optional[str] = pydantic.Field(None, description='The name of the chart. Either this or ``chartAsset`` must be specified. Default: - No chart name. Implies ``chartAsset`` is used.\n')
    chart_asset: typing.Optional[models.aws_s3_assets.AssetDef] = pydantic.Field(None, description='The chart in the form of an asset. Either this or ``chart`` must be specified. Default: - No chart asset. Implies ``chart`` is used.\n')
    create_namespace: typing.Optional[bool] = pydantic.Field(None, description='create namespace if not exist. Default: true\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description='The Kubernetes namespace scope of the requests. Default: default\n')
    release: typing.Optional[str] = pydantic.Field(None, description="The name of the release. Default: - If no release name is given, it will use the last 53 characters of the node's unique id.\n")
    repository: typing.Optional[str] = pydantic.Field(None, description='The repository which contains the chart. For example: https://charts.helm.sh/stable/ Default: - No repository will be used, which means that the chart needs to be an absolute URL.\n')
    skip_crds: typing.Optional[bool] = pydantic.Field(None, description='if set, no CRDs will be installed. Default: - CRDs are installed if not already present\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Amount of time to wait for any individual Kubernetes operation. Maximum 15 minutes. Default: Duration.minutes(5)\n')
    values: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='The values to be used by the chart. For nested values use a nested dictionary. For example: values: { installationCRDs: true, webhook: { port: 9443 } } Default: - No values are provided to the chart.\n')
    version: typing.Optional[str] = pydantic.Field(None, description='The chart version to install. Default: - If this is not specified, the latest version is installed\n')
    wait: typing.Optional[bool] = pydantic.Field(None, description='Whether or not Helm should wait until all Pods, PVCs, Services, and minimum number of Pods of a Deployment, StatefulSet, or ReplicaSet are in a ready state before marking the release as successful. Default: - Helm will not wait before marking release as successful\n')
    ...

class ClusterDefAddManifestParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='logical id of this manifest.\n')
    manifest: list[typing.Mapping[str, typing.Any]] = pydantic.Field(...)
    ...

class ClusterDefAddNodegroupCapacityParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='The ID of the nodegroup.\n')
    ami_type: typing.Optional[aws_cdk.aws_eks.NodegroupAmiType] = pydantic.Field(None, description='The AMI type for your node group. If you explicitly specify the launchTemplate with custom AMI, do not specify this property, or the node group deployment will fail. In other cases, you will need to specify correct amiType for the nodegroup. Default: - auto-determined from the instanceTypes property when launchTemplateSpec property is not specified\n')
    capacity_type: typing.Optional[aws_cdk.aws_eks.CapacityType] = pydantic.Field(None, description='The capacity type of the nodegroup. Default: - ON_DEMAND\n')
    desired_size: typing.Union[int, float, None] = pydantic.Field(None, description='The current number of worker nodes that the managed node group should maintain. If not specified, the nodewgroup will initially create ``minSize`` instances. Default: 2\n')
    disk_size: typing.Union[int, float, None] = pydantic.Field(None, description='The root device disk size (in GiB) for your node group instances. Default: 20\n')
    force_update: typing.Optional[bool] = pydantic.Field(None, description="Force the update if the existing node group's pods are unable to be drained due to a pod disruption budget issue. If an update fails because pods could not be drained, you can force the update after it fails to terminate the old node whether or not any pods are running on the node. Default: true\n")
    instance_types: typing.Optional[typing.Sequence[models.aws_ec2.InstanceTypeDef]] = pydantic.Field(None, description='The instance types to use for your node group. Default: t3.medium will be used according to the cloudformation document.\n')
    labels: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The Kubernetes labels to be applied to the nodes in the node group when they are created. Default: - None\n')
    launch_template_spec: typing.Union[models.aws_eks.LaunchTemplateSpecDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Launch template specification used for the nodegroup. Default: - no launch template\n')
    max_size: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of worker nodes that the managed node group can scale out to. Managed node groups can support up to 100 nodes by default. Default: - desiredSize\n')
    max_unavailable: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of nodes unavailable at once during a version update. Nodes will be updated in parallel. The maximum number is 100. This value or ``maxUnavailablePercentage`` is required to have a value for custom update configurations to be applied. Default: 1\n')
    max_unavailable_percentage: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum percentage of nodes unavailable during a version update. This percentage of nodes will be updated in parallel, up to 100 nodes at once. This value or ``maxUnavailable`` is required to have a value for custom update configurations to be applied. Default: undefined - node groups will update instances one at a time\n')
    min_size: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of worker nodes that the managed node group can scale in to. This number must be greater than or equal to zero. Default: 1\n')
    nodegroup_name: typing.Optional[str] = pydantic.Field(None, description='Name of the Nodegroup. Default: - resource ID\n')
    node_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The IAM role to associate with your node group. The Amazon EKS worker node kubelet daemon makes calls to AWS APIs on your behalf. Worker nodes receive permissions for these API calls through an IAM instance profile and associated policies. Before you can launch worker nodes and register them into a cluster, you must create an IAM role for those worker nodes to use when they are launched. Default: - None. Auto-generated if not specified.\n')
    release_version: typing.Optional[str] = pydantic.Field(None, description="The AMI version of the Amazon EKS-optimized AMI to use with your node group (for example, ``1.14.7-YYYYMMDD``). Default: - The latest available AMI version for the node group's current Kubernetes version is used.\n")
    remote_access: typing.Union[models.aws_eks.NodegroupRemoteAccessDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The remote access (SSH) configuration to use with your node group. Disabled by default, however, if you specify an Amazon EC2 SSH key but do not specify a source security group when you create a managed node group, then port 22 on the worker nodes is opened to the internet (0.0.0.0/0) Default: - disabled\n')
    subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The subnets to use for the Auto Scaling group that is created for your node group. By specifying the SubnetSelection, the selected subnets will automatically apply required tags i.e. ``kubernetes.io/cluster/CLUSTER_NAME`` with a value of ``shared``, where ``CLUSTER_NAME`` is replaced with the name of your cluster. Default: - private subnets\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The metadata to apply to the node group to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Node group tags do not propagate to any other resources associated with the node group, such as the Amazon EC2 instances or subnets. Default: - None\n')
    taints: typing.Optional[typing.Sequence[typing.Union[models.aws_eks.TaintSpecDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The Kubernetes taints to be applied to the nodes in the node group when they are created. Default: - None\n\n:see: https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html\n')
    return_config: typing.Optional[list[models.aws_eks.NodegroupDefConfig]] = pydantic.Field(None)
    ...

class ClusterDefAddServiceAccountParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    annotations: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Additional annotations of the service account. Default: - no additional annotations\n')
    identity_type: typing.Optional[aws_cdk.aws_eks.IdentityType] = pydantic.Field(None, description='The identity type to use for the service account. Default: IdentityType.IRSA\n')
    labels: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Additional labels of the service account. Default: - no additional labels\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the service account. The name of a ServiceAccount object must be a valid DNS subdomain name. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ Default: - If no name is given, it will use the id of the resource.\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description='The namespace of the service account. All namespace names must be valid RFC 1123 DNS labels. https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/#namespaces-and-dns Default: "default"')
    return_config: typing.Optional[list[models.aws_eks.ServiceAccountDefConfig]] = pydantic.Field(None)
    ...

class ClusterDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class ClusterDefConnectAutoScalingGroupCapacityParams(pydantic.BaseModel):
    auto_scaling_group: models.aws_autoscaling.AutoScalingGroupDef = pydantic.Field(..., description='[disable-awslint:ref-via-interface].\n')
    bootstrap_enabled: typing.Optional[bool] = pydantic.Field(None, description='Configures the EC2 user-data script for instances in this autoscaling group to bootstrap the node (invoke ``/etc/eks/bootstrap.sh``) and associate it with the EKS cluster. If you wish to provide a custom user data script, set this to ``false`` and manually invoke ``autoscalingGroup.addUserData()``. Default: true\n')
    bootstrap_options: typing.Union[models.aws_eks.BootstrapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Allows options for node bootstrapping through EC2 user data. Default: - default options\n')
    machine_image_type: typing.Optional[aws_cdk.aws_eks.MachineImageType] = pydantic.Field(None, description='Allow options to specify different machine image type. Default: MachineImageType.AMAZON_LINUX_2\n')
    map_role: typing.Optional[bool] = pydantic.Field(None, description='Will automatically update the aws-auth ConfigMap to map the IAM instance role to RBAC. This cannot be explicitly set to ``true`` if the cluster has kubectl disabled. Default: - true if the cluster has kubectl enabled (which is the default).\n')
    spot_interrupt_handler: typing.Optional[bool] = pydantic.Field(None, description="Installs the AWS spot instance interrupt handler on the cluster if it's not already added. Only relevant if ``spotPrice`` is configured on the auto-scaling group. Default: true\n\n:see: https://docs.aws.amazon.com/eks/latest/userguide/launch-workers.html\n")
    ...

class ClusterDefFromClusterAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description="the construct scope, in most cases 'this'.\n")
    id: str = pydantic.Field(..., description='the id or name to import as.\n')
    cluster_name: str = pydantic.Field(..., description='The physical name of the Cluster.\n')
    awscli_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description='An AWS Lambda layer that contains the ``aws`` CLI. The handler expects the layer to include the following executables:: /opt/awscli/aws Default: - a default layer with the AWS CLI 1.x\n')
    cluster_certificate_authority_data: typing.Optional[str] = pydantic.Field(None, description='The certificate-authority-data for your cluster. Default: - if not specified ``cluster.clusterCertificateAuthorityData`` will throw an error\n')
    cluster_encryption_config_key_arn: typing.Optional[str] = pydantic.Field(None, description='Amazon Resource Name (ARN) or alias of the customer master key (CMK). Default: - if not specified ``cluster.clusterEncryptionConfigKeyArn`` will throw an error\n')
    cluster_endpoint: typing.Optional[str] = pydantic.Field(None, description='The API Server endpoint URL. Default: - if not specified ``cluster.clusterEndpoint`` will throw an error.\n')
    cluster_handler_security_group_id: typing.Optional[str] = pydantic.Field(None, description="A security group id to associate with the Cluster Handler's Lambdas. The Cluster Handler's Lambdas are responsible for calling AWS's EKS API. Default: - No security group.\n")
    cluster_security_group_id: typing.Optional[str] = pydantic.Field(None, description='The cluster security group that was created by Amazon EKS for the cluster. Default: - if not specified ``cluster.clusterSecurityGroupId`` will throw an error\n')
    ip_family: typing.Optional[aws_cdk.aws_eks.IpFamily] = pydantic.Field(None, description='Specify which IP family is used to assign Kubernetes pod and service IP addresses. Default: - IpFamily.IP_V4\n')
    kubectl_environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Environment variables to use when running ``kubectl`` against this cluster. Default: - no additional variables\n')
    kubectl_lambda_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role that can perform kubectl operations against this cluster. The role should be mapped to the ``system:masters`` Kubernetes RBAC role. This role is directly passed to the lambda handler that sends Kube Ctl commands to the cluster. Default: - if not specified, the default role created by a lambda function will be used.\n')
    kubectl_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description="An AWS Lambda Layer which includes ``kubectl`` and Helm. This layer is used by the kubectl handler to apply manifests and install helm charts. You must pick an appropriate releases of one of the ``@aws-cdk/layer-kubectl-vXX`` packages, that works with the version of Kubernetes you have chosen. If you don't supply this value ``kubectl`` 1.20 will be used, but that version is most likely too old. The handler expects the layer to include the following executables:: /opt/helm/helm /opt/kubectl/kubectl Default: - a default layer with Kubectl 1.20 and helm 3.8.\n")
    kubectl_memory: typing.Optional[models.SizeDef] = pydantic.Field(None, description="Amount of memory to allocate to the provider's lambda function. Default: Size.gibibytes(1)\n")
    kubectl_private_subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Subnets to host the ``kubectl`` compute resources. If not specified, the k8s endpoint is expected to be accessible publicly. Default: - k8s endpoint is expected to be accessible publicly\n')
    kubectl_provider: typing.Optional[typing.Union[models.aws_eks.KubectlProviderDef]] = pydantic.Field(None, description='KubectlProvider for issuing kubectl commands. Default: - Default CDK provider\n')
    kubectl_role_arn: typing.Optional[str] = pydantic.Field(None, description='An IAM role with cluster administrator and "system:masters" permissions. Default: - if not specified, it not be possible to issue ``kubectl`` commands against an imported cluster.\n')
    kubectl_security_group_id: typing.Optional[str] = pydantic.Field(None, description='A security group to use for ``kubectl`` execution. If not specified, the k8s endpoint is expected to be accessible publicly. Default: - k8s endpoint is expected to be accessible publicly\n')
    on_event_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description='An AWS Lambda Layer which includes the NPM dependency ``proxy-agent``. This layer is used by the onEvent handler to route AWS SDK requests through a proxy. The handler expects the layer to include the following node_modules: proxy-agent Default: - a layer bundled with this module.\n')
    open_id_connect_provider: typing.Optional[typing.Union[models.aws_eks.OpenIdConnectProviderDef, models.aws_iam.OpenIdConnectProviderDef]] = pydantic.Field(None, description='An Open ID Connect provider for this cluster that can be used to configure service accounts. You can either import an existing provider using ``iam.OpenIdConnectProvider.fromProviderArn``, or create a new provider using ``new eks.OpenIdConnectProvider`` Default: - if not specified ``cluster.openIdConnectProvider`` and ``cluster.addServiceAccount`` will throw an error.\n')
    prune: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether Kubernetes resources added through ``addManifest()`` can be automatically pruned. When this is enabled (default), prune labels will be allocated and injected to each resource. These labels will then be used when issuing the ``kubectl apply`` operation with the ``--prune`` switch. Default: true\n')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Additional security groups associated with this cluster. Default: - if not specified, no additional security groups will be considered in ``cluster.connections``.\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC in which this Cluster was created. Default: - if not specified ``cluster.vpc`` will throw an error')
    ...

class ClusterDefGetIngressLoadBalancerAddressParams(pydantic.BaseModel):
    ingress_name: str = pydantic.Field(..., description='The name of the ingress.\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description="The namespace the service belongs to. Default: 'default'\n")
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Timeout for waiting on the load balancer address. Default: Duration.minutes(5)')
    ...

class ClusterDefGetServiceLoadBalancerAddressParams(pydantic.BaseModel):
    service_name: str = pydantic.Field(..., description='The name of the service.\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description="The namespace the service belongs to. Default: 'default'\n")
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Timeout for waiting on the load balancer address. Default: Duration.minutes(5)')
    ...

class ClusterDefGrantAccessParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='- The ID of the ``AccessEntry`` construct to be created.\n')
    principal: str = pydantic.Field(..., description='- The IAM principal (role or user) to be granted access to the EKS cluster.\n')
    access_policies: typing.Sequence[typing.Union[models.aws_eks.AccessPolicyDef]] = pydantic.Field(..., description='- An array of ``IAccessPolicy`` objects that define the access permissions to be granted to the IAM principal.')
    ...


#  autogenerated from aws_cdk.aws_eks.FargateCluster
class FargateClusterDef(BaseConstruct):
    default_profile: typing.Union[models.aws_eks.FargateProfileOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Fargate Profile to create along with the cluster. Default: - A profile called "default" with \'default\' and \'kube-system\' selectors will be created if this is left undefined.\n')
    alb_controller: typing.Union[models.aws_eks.AlbControllerOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Install the AWS Load Balancer Controller onto the cluster. Default: - The controller is not installed.\n')
    authentication_mode: typing.Optional[aws_cdk.aws_eks.AuthenticationMode] = pydantic.Field(None, description='The desired authentication mode for the cluster. Default: AuthenticationMode.CONFIG_MAP\n')
    awscli_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description='An AWS Lambda layer that contains the ``aws`` CLI. The handler expects the layer to include the following executables:: /opt/awscli/aws Default: - a default layer with the AWS CLI 1.x\n')
    cluster_handler_environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom environment variables when interacting with the EKS endpoint to manage the cluster lifecycle. Default: - No environment variables.\n')
    cluster_handler_security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description="A security group to associate with the Cluster Handler's Lambdas. The Cluster Handler's Lambdas are responsible for calling AWS's EKS API. Requires ``placeClusterHandlerInVpc`` to be set to true. Default: - No security group.\n")
    cluster_logging: typing.Optional[typing.Sequence[aws_cdk.aws_eks.ClusterLoggingTypes]] = pydantic.Field(None, description='The cluster log types which you want to enable. Default: - none\n')
    core_dns_compute_type: typing.Optional[aws_cdk.aws_eks.CoreDnsComputeType] = pydantic.Field(None, description='Controls the "eks.amazonaws.com/compute-type" annotation in the CoreDNS configuration on your cluster to determine which compute type to use for CoreDNS. Default: CoreDnsComputeType.EC2 (for ``FargateCluster`` the default is FARGATE)\n')
    endpoint_access: typing.Optional[models.aws_eks.EndpointAccessDef] = pydantic.Field(None, description='Configure access to the Kubernetes API server endpoint.. Default: EndpointAccess.PUBLIC_AND_PRIVATE\n')
    ip_family: typing.Optional[aws_cdk.aws_eks.IpFamily] = pydantic.Field(None, description='Specify which IP family is used to assign Kubernetes pod and service IP addresses. Default: - IpFamily.IP_V4\n')
    kubectl_environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Environment variables for the kubectl execution. Only relevant for kubectl enabled clusters. Default: - No environment variables.\n')
    kubectl_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description="An AWS Lambda Layer which includes ``kubectl`` and Helm. This layer is used by the kubectl handler to apply manifests and install helm charts. You must pick an appropriate releases of one of the ``@aws-cdk/layer-kubectl-vXX`` packages, that works with the version of Kubernetes you have chosen. If you don't supply this value ``kubectl`` 1.20 will be used, but that version is most likely too old. The handler expects the layer to include the following executables:: /opt/helm/helm /opt/kubectl/kubectl Default: - a default layer with Kubectl 1.20.\n")
    kubectl_memory: typing.Optional[models.SizeDef] = pydantic.Field(None, description="Amount of memory to allocate to the provider's lambda function. Default: Size.gibibytes(1)\n")
    masters_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role that will be added to the ``system:masters`` Kubernetes RBAC group. Default: - no masters role.\n')
    on_event_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description='An AWS Lambda Layer which includes the NPM dependency ``proxy-agent``. This layer is used by the onEvent handler to route AWS SDK requests through a proxy. By default, the provider will use the layer included in the "aws-lambda-layer-node-proxy-agent" SAR application which is available in all commercial regions. To deploy the layer locally define it in your app as follows:: const layer = new lambda.LayerVersion(this, \'proxy-agent-layer\', { code: lambda.Code.fromAsset(`${__dirname}/layer.zip`), compatibleRuntimes: [lambda.Runtime.NODEJS_LATEST], }); Default: - a layer bundled with this module.\n')
    output_masters_role_arn: typing.Optional[bool] = pydantic.Field(None, description='Determines whether a CloudFormation output with the ARN of the "masters" IAM role will be synthesized (if ``mastersRole`` is specified). Default: false\n')
    place_cluster_handler_in_vpc: typing.Optional[bool] = pydantic.Field(None, description='If set to true, the cluster handler functions will be placed in the private subnets of the cluster vpc, subject to the ``vpcSubnets`` selection strategy. Default: false\n')
    prune: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether Kubernetes resources added through ``addManifest()`` can be automatically pruned. When this is enabled (default), prune labels will be allocated and injected to each resource. These labels will then be used when issuing the ``kubectl apply`` operation with the ``--prune`` switch. Default: true\n')
    secrets_encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='KMS secret for envelope encryption for Kubernetes secrets. Default: - By default, Kubernetes stores all secret object data within etcd and all etcd volumes used by Amazon EKS are encrypted at the disk-level using AWS-Managed encryption keys.\n')
    service_ipv4_cidr: typing.Optional[str] = pydantic.Field(None, description='The CIDR block to assign Kubernetes service IP addresses from. Default: - Kubernetes assigns addresses from either the 10.100.0.0/16 or 172.20.0.0/16 CIDR blocks\n')
    version: typing.Union[models.aws_eks.KubernetesVersionDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Kubernetes version to run in the cluster.\n')
    cluster_name: typing.Optional[str] = pydantic.Field(None, description='Name for the cluster. Default: - Automatically generated name\n')
    output_cluster_name: typing.Optional[bool] = pydantic.Field(None, description='Determines whether a CloudFormation output with the name of the cluster will be synthesized. Default: false\n')
    output_config_command: typing.Optional[bool] = pydantic.Field(None, description='Determines whether a CloudFormation output with the ``aws eks update-kubeconfig`` command will be synthesized. This command will include the cluster name and, if applicable, the ARN of the masters IAM role. Default: true\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='Role that provides permissions for the Kubernetes control plane to make calls to AWS API operations on your behalf. Default: - A role is automatically created for you\n')
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='Security Group to use for Control Plane ENIs. Default: - A security group is automatically created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC in which to create the Cluster. Default: - a VPC with default configuration will be created and can be accessed through ``cluster.vpc``.\n')
    vpc_subnets: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Where to place EKS Control Plane ENIs. For example, to only select private subnets, supply the following: ``vpcSubnets: [{ subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS }]`` Default: - All public and private subnets')
    _init_params: typing.ClassVar[list[str]] = ['default_profile', 'alb_controller', 'authentication_mode', 'awscli_layer', 'cluster_handler_environment', 'cluster_handler_security_group', 'cluster_logging', 'core_dns_compute_type', 'endpoint_access', 'ip_family', 'kubectl_environment', 'kubectl_layer', 'kubectl_memory', 'masters_role', 'on_event_layer', 'output_masters_role_arn', 'place_cluster_handler_in_vpc', 'prune', 'secrets_encryption_key', 'service_ipv4_cidr', 'version', 'cluster_name', 'output_cluster_name', 'output_config_command', 'role', 'security_group', 'vpc', 'vpc_subnets']
    _method_names: typing.ClassVar[list[str]] = ['add_auto_scaling_group_capacity', 'add_cdk8s_chart', 'add_fargate_profile', 'add_helm_chart', 'add_manifest', 'add_nodegroup_capacity', 'add_service_account', 'apply_removal_policy', 'connect_auto_scaling_group_capacity', 'get_ingress_load_balancer_address', 'get_service_load_balancer_address', 'grant_access']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_cluster_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.FargateCluster'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_cluster_attributes']
    ...


    from_cluster_attributes: typing.Optional[models.aws_eks.FargateClusterDefFromClusterAttributesParams] = pydantic.Field(None, description='Import an existing cluster.')
    resource_config: typing.Optional[models.aws_eks.FargateClusterDefConfig] = pydantic.Field(None)


class FargateClusterDefConfig(pydantic.BaseModel):
    add_auto_scaling_group_capacity: typing.Optional[list[models.aws_eks.FargateClusterDefAddAutoScalingGroupCapacityParams]] = pydantic.Field(None, description='Add nodes to this EKS cluster.\nThe nodes will automatically be configured with the right VPC and AMI\nfor the instance type and Kubernetes version.\n\nNote that if you specify ``updateType: RollingUpdate`` or ``updateType: ReplacingUpdate``, your nodes might be replaced at deploy\ntime without notice in case the recommended AMI for your machine image type has been updated by AWS.\nThe default behavior for ``updateType`` is ``None``, which means only new instances will be launched using the new AMI.\n\nSpot instances will be labeled ``lifecycle=Ec2Spot`` and tainted with ``PreferNoSchedule``.\nIn addition, the `spot interrupt handler <https://github.com/awslabs/ec2-spot-labs/tree/master/ec2-spot-eks-solution/spot-termination-handler>`_\ndaemon will be installed on all spot instances to handle\n`EC2 Spot Instance Termination Notices <https://aws.amazon.com/blogs/aws/new-ec2-spot-instance-termination-notices/>`_.')
    add_cdk8s_chart: typing.Optional[list[models.aws_eks.FargateClusterDefAddCdk8SChartParams]] = pydantic.Field(None, description='Defines a CDK8s chart in this cluster.')
    add_fargate_profile: typing.Optional[list[models.aws_eks.FargateClusterDefAddFargateProfileParams]] = pydantic.Field(None, description='Adds a Fargate profile to this cluster.')
    add_helm_chart: typing.Optional[list[models.aws_eks.FargateClusterDefAddHelmChartParams]] = pydantic.Field(None, description='Defines a Helm chart in this cluster.')
    add_manifest: typing.Optional[list[models.aws_eks.FargateClusterDefAddManifestParams]] = pydantic.Field(None, description='Defines a Kubernetes resource in this cluster.\nThe manifest will be applied/deleted using kubectl as needed.')
    add_nodegroup_capacity: typing.Optional[list[models.aws_eks.FargateClusterDefAddNodegroupCapacityParams]] = pydantic.Field(None, description='Add managed nodegroup to this Amazon EKS cluster.\nThis method will create a new managed nodegroup and add into the capacity.')
    add_service_account: typing.Optional[list[models.aws_eks.FargateClusterDefAddServiceAccountParams]] = pydantic.Field(None, description='Creates a new service account with corresponding IAM Role (IRSA).')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    connect_auto_scaling_group_capacity: typing.Optional[list[models.aws_eks.FargateClusterDefConnectAutoScalingGroupCapacityParams]] = pydantic.Field(None, description="Connect capacity in the form of an existing AutoScalingGroup to the EKS cluster.\nThe AutoScalingGroup must be running an EKS-optimized AMI containing the\n/etc/eks/bootstrap.sh script. This method will configure Security Groups,\nadd the right policies to the instance role, apply the right tags, and add\nthe required user data to the instance's launch configuration.\n\nSpot instances will be labeled ``lifecycle=Ec2Spot`` and tainted with ``PreferNoSchedule``.\nIf kubectl is enabled, the\n`spot interrupt handler <https://github.com/awslabs/ec2-spot-labs/tree/master/ec2-spot-eks-solution/spot-termination-handler>`_\ndaemon will be installed on all spot instances to handle\n`EC2 Spot Instance Termination Notices <https://aws.amazon.com/blogs/aws/new-ec2-spot-instance-termination-notices/>`_.\n\nPrefer to use ``addAutoScalingGroupCapacity`` if possible.")
    get_ingress_load_balancer_address: typing.Optional[list[models.aws_eks.FargateClusterDefGetIngressLoadBalancerAddressParams]] = pydantic.Field(None, description='Fetch the load balancer address of an ingress backed by a load balancer.')
    get_service_load_balancer_address: typing.Optional[list[models.aws_eks.FargateClusterDefGetServiceLoadBalancerAddressParams]] = pydantic.Field(None, description="Fetch the load balancer address of a service of type 'LoadBalancer'.")
    grant_access: typing.Optional[list[models.aws_eks.FargateClusterDefGrantAccessParams]] = pydantic.Field(None, description='Grants the specified IAM principal access to the EKS cluster based on the provided access policies.\nThis method creates an ``AccessEntry`` construct that grants the specified IAM principal the access permissions\ndefined by the provided ``IAccessPolicy`` array. This allows the IAM principal to perform the actions permitted\nby the access policies within the EKS cluster.')
    admin_role_config: typing.Optional[models.aws_iam.RoleDefConfig] = pydantic.Field(None)
    aws_auth_config: typing.Optional[models.aws_eks.AwsAuthDefConfig] = pydantic.Field(None)
    cluster_security_group_config: typing.Optional[models._interface_methods.AwsEc2ISecurityGroupDefConfig] = pydantic.Field(None)
    connections_config: typing.Optional[models.aws_ec2.ConnectionsDefConfig] = pydantic.Field(None)
    open_id_connect_provider_config: typing.Optional[models._interface_methods.AwsIamIOpenIdConnectProviderDefConfig] = pydantic.Field(None)
    role_config: typing.Optional[models._interface_methods.AwsIamIRoleDefConfig] = pydantic.Field(None)
    vpc_config: typing.Optional[models._interface_methods.AwsEc2IVpcDefConfig] = pydantic.Field(None)

class FargateClusterDefAddAutoScalingGroupCapacityParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    instance_type: models.aws_ec2.InstanceTypeDef = pydantic.Field(..., description='Instance type of the instances to start.\n')
    bootstrap_enabled: typing.Optional[bool] = pydantic.Field(None, description='Configures the EC2 user-data script for instances in this autoscaling group to bootstrap the node (invoke ``/etc/eks/bootstrap.sh``) and associate it with the EKS cluster. If you wish to provide a custom user data script, set this to ``false`` and manually invoke ``autoscalingGroup.addUserData()``. Default: true\n')
    bootstrap_options: typing.Union[models.aws_eks.BootstrapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='EKS node bootstrapping options. Default: - none\n')
    machine_image_type: typing.Optional[aws_cdk.aws_eks.MachineImageType] = pydantic.Field(None, description='Machine image type. Default: MachineImageType.AMAZON_LINUX_2\n')
    map_role: typing.Optional[bool] = pydantic.Field(None, description='Will automatically update the aws-auth ConfigMap to map the IAM instance role to RBAC. This cannot be explicitly set to ``true`` if the cluster has kubectl disabled. Default: - true if the cluster has kubectl enabled (which is the default).\n')
    spot_interrupt_handler: typing.Optional[bool] = pydantic.Field(None, description="Installs the AWS spot instance interrupt handler on the cluster if it's not already added. Only relevant if ``spotPrice`` is used. Default: true\n")
    allow_all_outbound: typing.Optional[bool] = pydantic.Field(None, description='Whether the instances can initiate connections to anywhere by default. Default: true\n')
    associate_public_ip_address: typing.Optional[bool] = pydantic.Field(None, description='Whether instances in the Auto Scaling Group should have public IP addresses associated with them. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified Default: - Use subnet setting.\n')
    auto_scaling_group_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Auto Scaling group. This name must be unique per Region per account. Default: - Auto generated by CloudFormation\n')
    block_devices: typing.Optional[typing.Sequence[typing.Union[models.aws_autoscaling.BlockDeviceDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Specifies how block devices are exposed to the instance. You can specify virtual devices and EBS volumes. Each instance that is launched has an associated root device volume, either an Amazon EBS volume or an instance store volume. You can use block device mappings to specify additional EBS volumes or instance store volumes to attach to an instance when it is launched. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified Default: - Uses the block device mapping of the AMI\n')
    capacity_rebalance: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether Capacity Rebalancing is enabled. When you turn on Capacity Rebalancing, Amazon EC2 Auto Scaling attempts to launch a Spot Instance whenever Amazon EC2 notifies that a Spot Instance is at an elevated risk of interruption. After launching a new instance, it then terminates an old instance. Default: false\n')
    cooldown: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Default scaling cooldown for this AutoScalingGroup. Default: Duration.minutes(5)\n')
    default_instance_warmup: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The amount of time, in seconds, until a newly launched instance can contribute to the Amazon CloudWatch metrics. This delay lets an instance finish initializing before Amazon EC2 Auto Scaling aggregates instance metrics, resulting in more reliable usage data. Set this value equal to the amount of time that it takes for resource consumption to become stable after an instance reaches the InService state. To optimize the performance of scaling policies that scale continuously, such as target tracking and step scaling policies, we strongly recommend that you enable the default instance warmup, even if its value is set to 0 seconds Default instance warmup will not be added if no value is specified Default: None\n')
    desired_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Initial amount of instances in the fleet. If this is set to a number, every deployment will reset the amount of instances to this number. It is recommended to leave this value blank. Default: minCapacity, and leave unchanged during deployment\n')
    group_metrics: typing.Optional[typing.Sequence[models.aws_autoscaling.GroupMetricsDef]] = pydantic.Field(None, description='Enable monitoring for group metrics, these metrics describe the group rather than any of its instances. To report all group metrics use ``GroupMetrics.all()`` Group metrics are reported in a granularity of 1 minute at no additional charge. Default: - no group metrics will be reported\n')
    health_check: typing.Optional[models.aws_autoscaling.HealthCheckDef] = pydantic.Field(None, description='Configuration for health checks. Default: - HealthCheck.ec2 with no grace period\n')
    ignore_unmodified_size_properties: typing.Optional[bool] = pydantic.Field(None, description="If the ASG has scheduled actions, don't reset unchanged group sizes. Only used if the ASG has scheduled actions (which may scale your ASG up or down regardless of cdk deployments). If true, the size of the group will only be reset if it has been changed in the CDK app. If false, the sizes will always be changed back to what they were in the CDK app on deployment. Default: true\n")
    instance_monitoring: typing.Optional[aws_cdk.aws_autoscaling.Monitoring] = pydantic.Field(None, description='Controls whether instances in this group are launched with detailed or basic monitoring. When detailed monitoring is enabled, Amazon CloudWatch generates metrics every minute and your account is charged a fee. When you disable detailed monitoring, CloudWatch generates metrics every 5 minutes. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified Default: - Monitoring.DETAILED\n')
    key_name: typing.Optional[str] = pydantic.Field(None, description='(deprecated) Name of SSH keypair to grant access to instances. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified You can either specify ``keyPair`` or ``keyName``, not both. Default: - No SSH access will be possible.\n')
    key_pair: typing.Optional[typing.Union[models.aws_ec2.KeyPairDef]] = pydantic.Field(None, description='The SSH keypair to grant access to the instance. Feature flag ``AUTOSCALING_GENERATE_LAUNCH_TEMPLATE`` must be enabled to use this property. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified. You can either specify ``keyPair`` or ``keyName``, not both. Default: - No SSH access will be possible.\n')
    max_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Maximum number of instances in the fleet. Default: desiredCapacity\n')
    max_instance_lifetime: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum amount of time that an instance can be in service. The maximum duration applies to all current and future instances in the group. As an instance approaches its maximum duration, it is terminated and replaced, and cannot be used again. You must specify a value of at least 604,800 seconds (7 days). To clear a previously set value, leave this property undefined. Default: none\n')
    min_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Minimum number of instances in the fleet. Default: 1\n')
    new_instances_protected_from_scale_in: typing.Optional[bool] = pydantic.Field(None, description="Whether newly-launched instances are protected from termination by Amazon EC2 Auto Scaling when scaling in. By default, Auto Scaling can terminate an instance at any time after launch when scaling in an Auto Scaling Group, subject to the group's termination policy. However, you may wish to protect newly-launched instances from being scaled in if they are going to run critical applications that should not be prematurely terminated. This flag must be enabled if the Auto Scaling Group will be associated with an ECS Capacity Provider with managed termination protection. Default: false\n")
    notifications: typing.Optional[typing.Sequence[typing.Union[models.aws_autoscaling.NotificationConfigurationDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Configure autoscaling group to send notifications about fleet changes to an SNS topic(s). Default: - No fleet change notifications will be sent.\n')
    signals: typing.Optional[models.aws_autoscaling.SignalsDef] = pydantic.Field(None, description='Configure waiting for signals during deployment. Use this to pause the CloudFormation deployment to wait for the instances in the AutoScalingGroup to report successful startup during creation and updates. The UserData script needs to invoke ``cfn-signal`` with a success or failure code after it is done setting up the instance. Without waiting for signals, the CloudFormation deployment will proceed as soon as the AutoScalingGroup has been created or updated but before the instances in the group have been started. For example, to have instances wait for an Elastic Load Balancing health check before they signal success, add a health-check verification by using the cfn-init helper script. For an example, see the verify_instance_health command in the Auto Scaling rolling updates sample template: https://github.com/awslabs/aws-cloudformation-templates/blob/master/aws/services/AutoScaling/AutoScalingRollingUpdates.yaml Default: - Do not wait for signals\n')
    spot_price: typing.Optional[str] = pydantic.Field(None, description='The maximum hourly price (in USD) to be paid for any Spot Instance launched to fulfill the request. Spot Instances are launched when the price you specify exceeds the current Spot market price. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified Default: none\n')
    ssm_session_permissions: typing.Optional[bool] = pydantic.Field(None, description='Add SSM session permissions to the instance role. Setting this to ``true`` adds the necessary permissions to connect to the instance using SSM Session Manager. You can do this from the AWS Console. NOTE: Setting this flag to ``true`` may not be enough by itself. You must also use an AMI that comes with the SSM Agent, or install the SSM Agent yourself. See `Working with SSM Agent <https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-agent.html>`_ in the SSM Developer Guide. Default: false\n')
    termination_policies: typing.Optional[typing.Sequence[aws_cdk.aws_autoscaling.TerminationPolicy]] = pydantic.Field(None, description='A policy or a list of policies that are used to select the instances to terminate. The policies are executed in the order that you list them. Default: - ``TerminationPolicy.DEFAULT``\n')
    termination_policy_custom_lambda_function_arn: typing.Optional[str] = pydantic.Field(None, description='A lambda function Arn that can be used as a custom termination policy to select the instances to terminate. This property must be specified if the TerminationPolicy.CUSTOM_LAMBDA_FUNCTION is used. Default: - No lambda function Arn will be supplied\n')
    update_policy: typing.Optional[models.aws_autoscaling.UpdatePolicyDef] = pydantic.Field(None, description="What to do when an AutoScalingGroup's instance configuration is changed. This is applied when any of the settings on the ASG are changed that affect how the instances should be created (VPC, instance type, startup scripts, etc.). It indicates how the existing instances should be replaced with new instances matching the new config. By default, nothing is done and only new instances are launched with the new config. Default: - ``UpdatePolicy.rollingUpdate()`` if using ``init``, ``UpdatePolicy.none()`` otherwise\n")
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Where to place instances within the VPC. Default: - All Private subnets.')
    return_config: typing.Optional[list[models.aws_autoscaling.AutoScalingGroupDefConfig]] = pydantic.Field(None)
    ...

class FargateClusterDefAddCdk8SChartParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='logical id of this chart.\n')
    chart: models.constructs.ConstructDef = pydantic.Field(..., description='the cdk8s chart.\n')
    ingress_alb: typing.Optional[bool] = pydantic.Field(None, description='Automatically detect ``Ingress`` resources in the manifest and annotate them so they are picked up by an ALB Ingress Controller. Default: false\n')
    ingress_alb_scheme: typing.Optional[aws_cdk.aws_eks.AlbScheme] = pydantic.Field(None, description='Specify the ALB scheme that should be applied to ``Ingress`` resources. Only applicable if ``ingressAlb`` is set to ``true``. Default: AlbScheme.INTERNAL\n')
    prune: typing.Optional[bool] = pydantic.Field(None, description='When a resource is removed from a Kubernetes manifest, it no longer appears in the manifest, and there is no way to know that this resource needs to be deleted. To address this, ``kubectl apply`` has a ``--prune`` option which will query the cluster for all resources with a specific label and will remove all the labeld resources that are not part of the applied manifest. If this option is disabled and a resource is removed, it will become "orphaned" and will not be deleted from the cluster. When this option is enabled (default), the construct will inject a label to all Kubernetes resources included in this manifest which will be used to prune resources when the manifest changes via ``kubectl apply --prune``. The label name will be ``aws.cdk.eks/prune-<ADDR>`` where ``<ADDR>`` is the 42-char unique address of this construct in the construct tree. Value is empty. Default: - based on the prune option of the cluster, which is ``true`` unless otherwise specified.\n')
    skip_validation: typing.Optional[bool] = pydantic.Field(None, description='A flag to signify if the manifest validation should be skipped. Default: false\n')
    ...

class FargateClusterDefAddFargateProfileParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='the id of this profile.\n')
    selectors: typing.Sequence[typing.Union[models.aws_eks.SelectorDef, dict[str, typing.Any]]] = pydantic.Field(..., description='The selectors to match for pods to use this Fargate profile. Each selector must have an associated namespace. Optionally, you can also specify labels for a namespace. At least one selector is required and you may specify up to five selectors.\n')
    fargate_profile_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Fargate profile. Default: - generated\n')
    pod_execution_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The pod execution role to use for pods that match the selectors in the Fargate profile. The pod execution role allows Fargate infrastructure to register with your cluster as a node, and it provides read access to Amazon ECR image repositories. Default: - a role will be automatically created\n')
    subnet_selection: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Select which subnets to launch your pods into. At this time, pods running on Fargate are not assigned public IP addresses, so only private subnets (with no direct route to an Internet Gateway) are allowed. You must specify the VPC to customize the subnet selection Default: - all private subnets of the VPC are selected.\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC from which to select subnets to launch your pods into. By default, all private subnets are selected. You can customize this using ``subnetSelection``. Default: - all private subnets used by the EKS cluster\n\n:see: https://docs.aws.amazon.com/eks/latest/userguide/fargate-profile.html\n')
    return_config: typing.Optional[list[models.aws_eks.FargateProfileDefConfig]] = pydantic.Field(None)
    ...

class FargateClusterDefAddHelmChartParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='logical id of this chart.\n')
    atomic: typing.Optional[bool] = pydantic.Field(None, description='Whether or not Helm should treat this operation as atomic; if set, upgrade process rolls back changes made in case of failed upgrade. The --wait flag will be set automatically if --atomic is used. Default: false\n')
    chart: typing.Optional[str] = pydantic.Field(None, description='The name of the chart. Either this or ``chartAsset`` must be specified. Default: - No chart name. Implies ``chartAsset`` is used.\n')
    chart_asset: typing.Optional[models.aws_s3_assets.AssetDef] = pydantic.Field(None, description='The chart in the form of an asset. Either this or ``chart`` must be specified. Default: - No chart asset. Implies ``chart`` is used.\n')
    create_namespace: typing.Optional[bool] = pydantic.Field(None, description='create namespace if not exist. Default: true\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description='The Kubernetes namespace scope of the requests. Default: default\n')
    release: typing.Optional[str] = pydantic.Field(None, description="The name of the release. Default: - If no release name is given, it will use the last 53 characters of the node's unique id.\n")
    repository: typing.Optional[str] = pydantic.Field(None, description='The repository which contains the chart. For example: https://charts.helm.sh/stable/ Default: - No repository will be used, which means that the chart needs to be an absolute URL.\n')
    skip_crds: typing.Optional[bool] = pydantic.Field(None, description='if set, no CRDs will be installed. Default: - CRDs are installed if not already present\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Amount of time to wait for any individual Kubernetes operation. Maximum 15 minutes. Default: Duration.minutes(5)\n')
    values: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='The values to be used by the chart. For nested values use a nested dictionary. For example: values: { installationCRDs: true, webhook: { port: 9443 } } Default: - No values are provided to the chart.\n')
    version: typing.Optional[str] = pydantic.Field(None, description='The chart version to install. Default: - If this is not specified, the latest version is installed\n')
    wait: typing.Optional[bool] = pydantic.Field(None, description='Whether or not Helm should wait until all Pods, PVCs, Services, and minimum number of Pods of a Deployment, StatefulSet, or ReplicaSet are in a ready state before marking the release as successful. Default: - Helm will not wait before marking release as successful\n')
    ...

class FargateClusterDefAddManifestParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='logical id of this manifest.\n')
    manifest: list[typing.Mapping[str, typing.Any]] = pydantic.Field(...)
    ...

class FargateClusterDefAddNodegroupCapacityParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='The ID of the nodegroup.\n')
    ami_type: typing.Optional[aws_cdk.aws_eks.NodegroupAmiType] = pydantic.Field(None, description='The AMI type for your node group. If you explicitly specify the launchTemplate with custom AMI, do not specify this property, or the node group deployment will fail. In other cases, you will need to specify correct amiType for the nodegroup. Default: - auto-determined from the instanceTypes property when launchTemplateSpec property is not specified\n')
    capacity_type: typing.Optional[aws_cdk.aws_eks.CapacityType] = pydantic.Field(None, description='The capacity type of the nodegroup. Default: - ON_DEMAND\n')
    desired_size: typing.Union[int, float, None] = pydantic.Field(None, description='The current number of worker nodes that the managed node group should maintain. If not specified, the nodewgroup will initially create ``minSize`` instances. Default: 2\n')
    disk_size: typing.Union[int, float, None] = pydantic.Field(None, description='The root device disk size (in GiB) for your node group instances. Default: 20\n')
    force_update: typing.Optional[bool] = pydantic.Field(None, description="Force the update if the existing node group's pods are unable to be drained due to a pod disruption budget issue. If an update fails because pods could not be drained, you can force the update after it fails to terminate the old node whether or not any pods are running on the node. Default: true\n")
    instance_types: typing.Optional[typing.Sequence[models.aws_ec2.InstanceTypeDef]] = pydantic.Field(None, description='The instance types to use for your node group. Default: t3.medium will be used according to the cloudformation document.\n')
    labels: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The Kubernetes labels to be applied to the nodes in the node group when they are created. Default: - None\n')
    launch_template_spec: typing.Union[models.aws_eks.LaunchTemplateSpecDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Launch template specification used for the nodegroup. Default: - no launch template\n')
    max_size: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of worker nodes that the managed node group can scale out to. Managed node groups can support up to 100 nodes by default. Default: - desiredSize\n')
    max_unavailable: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of nodes unavailable at once during a version update. Nodes will be updated in parallel. The maximum number is 100. This value or ``maxUnavailablePercentage`` is required to have a value for custom update configurations to be applied. Default: 1\n')
    max_unavailable_percentage: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum percentage of nodes unavailable during a version update. This percentage of nodes will be updated in parallel, up to 100 nodes at once. This value or ``maxUnavailable`` is required to have a value for custom update configurations to be applied. Default: undefined - node groups will update instances one at a time\n')
    min_size: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of worker nodes that the managed node group can scale in to. This number must be greater than or equal to zero. Default: 1\n')
    nodegroup_name: typing.Optional[str] = pydantic.Field(None, description='Name of the Nodegroup. Default: - resource ID\n')
    node_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The IAM role to associate with your node group. The Amazon EKS worker node kubelet daemon makes calls to AWS APIs on your behalf. Worker nodes receive permissions for these API calls through an IAM instance profile and associated policies. Before you can launch worker nodes and register them into a cluster, you must create an IAM role for those worker nodes to use when they are launched. Default: - None. Auto-generated if not specified.\n')
    release_version: typing.Optional[str] = pydantic.Field(None, description="The AMI version of the Amazon EKS-optimized AMI to use with your node group (for example, ``1.14.7-YYYYMMDD``). Default: - The latest available AMI version for the node group's current Kubernetes version is used.\n")
    remote_access: typing.Union[models.aws_eks.NodegroupRemoteAccessDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The remote access (SSH) configuration to use with your node group. Disabled by default, however, if you specify an Amazon EC2 SSH key but do not specify a source security group when you create a managed node group, then port 22 on the worker nodes is opened to the internet (0.0.0.0/0) Default: - disabled\n')
    subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The subnets to use for the Auto Scaling group that is created for your node group. By specifying the SubnetSelection, the selected subnets will automatically apply required tags i.e. ``kubernetes.io/cluster/CLUSTER_NAME`` with a value of ``shared``, where ``CLUSTER_NAME`` is replaced with the name of your cluster. Default: - private subnets\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The metadata to apply to the node group to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Node group tags do not propagate to any other resources associated with the node group, such as the Amazon EC2 instances or subnets. Default: - None\n')
    taints: typing.Optional[typing.Sequence[typing.Union[models.aws_eks.TaintSpecDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The Kubernetes taints to be applied to the nodes in the node group when they are created. Default: - None\n\n:see: https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html\n')
    return_config: typing.Optional[list[models.aws_eks.NodegroupDefConfig]] = pydantic.Field(None)
    ...

class FargateClusterDefAddServiceAccountParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    annotations: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Additional annotations of the service account. Default: - no additional annotations\n')
    identity_type: typing.Optional[aws_cdk.aws_eks.IdentityType] = pydantic.Field(None, description='The identity type to use for the service account. Default: IdentityType.IRSA\n')
    labels: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Additional labels of the service account. Default: - no additional labels\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the service account. The name of a ServiceAccount object must be a valid DNS subdomain name. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ Default: - If no name is given, it will use the id of the resource.\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description='The namespace of the service account. All namespace names must be valid RFC 1123 DNS labels. https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/#namespaces-and-dns Default: "default"')
    return_config: typing.Optional[list[models.aws_eks.ServiceAccountDefConfig]] = pydantic.Field(None)
    ...

class FargateClusterDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class FargateClusterDefConnectAutoScalingGroupCapacityParams(pydantic.BaseModel):
    auto_scaling_group: models.aws_autoscaling.AutoScalingGroupDef = pydantic.Field(..., description='[disable-awslint:ref-via-interface].\n')
    bootstrap_enabled: typing.Optional[bool] = pydantic.Field(None, description='Configures the EC2 user-data script for instances in this autoscaling group to bootstrap the node (invoke ``/etc/eks/bootstrap.sh``) and associate it with the EKS cluster. If you wish to provide a custom user data script, set this to ``false`` and manually invoke ``autoscalingGroup.addUserData()``. Default: true\n')
    bootstrap_options: typing.Union[models.aws_eks.BootstrapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Allows options for node bootstrapping through EC2 user data. Default: - default options\n')
    machine_image_type: typing.Optional[aws_cdk.aws_eks.MachineImageType] = pydantic.Field(None, description='Allow options to specify different machine image type. Default: MachineImageType.AMAZON_LINUX_2\n')
    map_role: typing.Optional[bool] = pydantic.Field(None, description='Will automatically update the aws-auth ConfigMap to map the IAM instance role to RBAC. This cannot be explicitly set to ``true`` if the cluster has kubectl disabled. Default: - true if the cluster has kubectl enabled (which is the default).\n')
    spot_interrupt_handler: typing.Optional[bool] = pydantic.Field(None, description="Installs the AWS spot instance interrupt handler on the cluster if it's not already added. Only relevant if ``spotPrice`` is configured on the auto-scaling group. Default: true\n\n:see: https://docs.aws.amazon.com/eks/latest/userguide/launch-workers.html\n")
    ...

class FargateClusterDefFromClusterAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description="the construct scope, in most cases 'this'.\n")
    id: str = pydantic.Field(..., description='the id or name to import as.\n')
    cluster_name: str = pydantic.Field(..., description='The physical name of the Cluster.\n')
    awscli_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description='An AWS Lambda layer that contains the ``aws`` CLI. The handler expects the layer to include the following executables:: /opt/awscli/aws Default: - a default layer with the AWS CLI 1.x\n')
    cluster_certificate_authority_data: typing.Optional[str] = pydantic.Field(None, description='The certificate-authority-data for your cluster. Default: - if not specified ``cluster.clusterCertificateAuthorityData`` will throw an error\n')
    cluster_encryption_config_key_arn: typing.Optional[str] = pydantic.Field(None, description='Amazon Resource Name (ARN) or alias of the customer master key (CMK). Default: - if not specified ``cluster.clusterEncryptionConfigKeyArn`` will throw an error\n')
    cluster_endpoint: typing.Optional[str] = pydantic.Field(None, description='The API Server endpoint URL. Default: - if not specified ``cluster.clusterEndpoint`` will throw an error.\n')
    cluster_handler_security_group_id: typing.Optional[str] = pydantic.Field(None, description="A security group id to associate with the Cluster Handler's Lambdas. The Cluster Handler's Lambdas are responsible for calling AWS's EKS API. Default: - No security group.\n")
    cluster_security_group_id: typing.Optional[str] = pydantic.Field(None, description='The cluster security group that was created by Amazon EKS for the cluster. Default: - if not specified ``cluster.clusterSecurityGroupId`` will throw an error\n')
    ip_family: typing.Optional[aws_cdk.aws_eks.IpFamily] = pydantic.Field(None, description='Specify which IP family is used to assign Kubernetes pod and service IP addresses. Default: - IpFamily.IP_V4\n')
    kubectl_environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Environment variables to use when running ``kubectl`` against this cluster. Default: - no additional variables\n')
    kubectl_lambda_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role that can perform kubectl operations against this cluster. The role should be mapped to the ``system:masters`` Kubernetes RBAC role. This role is directly passed to the lambda handler that sends Kube Ctl commands to the cluster. Default: - if not specified, the default role created by a lambda function will be used.\n')
    kubectl_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description="An AWS Lambda Layer which includes ``kubectl`` and Helm. This layer is used by the kubectl handler to apply manifests and install helm charts. You must pick an appropriate releases of one of the ``@aws-cdk/layer-kubectl-vXX`` packages, that works with the version of Kubernetes you have chosen. If you don't supply this value ``kubectl`` 1.20 will be used, but that version is most likely too old. The handler expects the layer to include the following executables:: /opt/helm/helm /opt/kubectl/kubectl Default: - a default layer with Kubectl 1.20 and helm 3.8.\n")
    kubectl_memory: typing.Optional[models.SizeDef] = pydantic.Field(None, description="Amount of memory to allocate to the provider's lambda function. Default: Size.gibibytes(1)\n")
    kubectl_private_subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Subnets to host the ``kubectl`` compute resources. If not specified, the k8s endpoint is expected to be accessible publicly. Default: - k8s endpoint is expected to be accessible publicly\n')
    kubectl_provider: typing.Optional[typing.Union[models.aws_eks.KubectlProviderDef]] = pydantic.Field(None, description='KubectlProvider for issuing kubectl commands. Default: - Default CDK provider\n')
    kubectl_role_arn: typing.Optional[str] = pydantic.Field(None, description='An IAM role with cluster administrator and "system:masters" permissions. Default: - if not specified, it not be possible to issue ``kubectl`` commands against an imported cluster.\n')
    kubectl_security_group_id: typing.Optional[str] = pydantic.Field(None, description='A security group to use for ``kubectl`` execution. If not specified, the k8s endpoint is expected to be accessible publicly. Default: - k8s endpoint is expected to be accessible publicly\n')
    on_event_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description='An AWS Lambda Layer which includes the NPM dependency ``proxy-agent``. This layer is used by the onEvent handler to route AWS SDK requests through a proxy. The handler expects the layer to include the following node_modules: proxy-agent Default: - a layer bundled with this module.\n')
    open_id_connect_provider: typing.Optional[typing.Union[models.aws_eks.OpenIdConnectProviderDef, models.aws_iam.OpenIdConnectProviderDef]] = pydantic.Field(None, description='An Open ID Connect provider for this cluster that can be used to configure service accounts. You can either import an existing provider using ``iam.OpenIdConnectProvider.fromProviderArn``, or create a new provider using ``new eks.OpenIdConnectProvider`` Default: - if not specified ``cluster.openIdConnectProvider`` and ``cluster.addServiceAccount`` will throw an error.\n')
    prune: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether Kubernetes resources added through ``addManifest()`` can be automatically pruned. When this is enabled (default), prune labels will be allocated and injected to each resource. These labels will then be used when issuing the ``kubectl apply`` operation with the ``--prune`` switch. Default: true\n')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Additional security groups associated with this cluster. Default: - if not specified, no additional security groups will be considered in ``cluster.connections``.\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC in which this Cluster was created. Default: - if not specified ``cluster.vpc`` will throw an error')
    ...

class FargateClusterDefGetIngressLoadBalancerAddressParams(pydantic.BaseModel):
    ingress_name: str = pydantic.Field(..., description='The name of the ingress.\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description="The namespace the service belongs to. Default: 'default'\n")
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Timeout for waiting on the load balancer address. Default: Duration.minutes(5)')
    ...

class FargateClusterDefGetServiceLoadBalancerAddressParams(pydantic.BaseModel):
    service_name: str = pydantic.Field(..., description='The name of the service.\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description="The namespace the service belongs to. Default: 'default'\n")
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Timeout for waiting on the load balancer address. Default: Duration.minutes(5)')
    ...

class FargateClusterDefGrantAccessParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='- The ID of the ``AccessEntry`` construct to be created.\n')
    principal: str = pydantic.Field(..., description='- The IAM principal (role or user) to be granted access to the EKS cluster.\n')
    access_policies: typing.Sequence[typing.Union[models.aws_eks.AccessPolicyDef]] = pydantic.Field(..., description='- An array of ``IAccessPolicy`` objects that define the access permissions to be granted to the IAM principal.')
    ...


#  autogenerated from aws_cdk.aws_eks.FargateProfile
class FargateProfileDef(BaseConstruct):
    cluster: typing.Union[models.aws_eks.ClusterDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The EKS cluster to apply the Fargate profile to. [disable-awslint:ref-via-interface]\n')
    selectors: typing.Union[typing.Sequence[typing.Union[models.aws_eks.SelectorDef, dict[str, typing.Any]]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The selectors to match for pods to use this Fargate profile. Each selector must have an associated namespace. Optionally, you can also specify labels for a namespace. At least one selector is required and you may specify up to five selectors.\n')
    fargate_profile_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Fargate profile. Default: - generated\n')
    pod_execution_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The pod execution role to use for pods that match the selectors in the Fargate profile. The pod execution role allows Fargate infrastructure to register with your cluster as a node, and it provides read access to Amazon ECR image repositories. Default: - a role will be automatically created\n')
    subnet_selection: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Select which subnets to launch your pods into. At this time, pods running on Fargate are not assigned public IP addresses, so only private subnets (with no direct route to an Internet Gateway) are allowed. You must specify the VPC to customize the subnet selection Default: - all private subnets of the VPC are selected.\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC from which to select subnets to launch your pods into. By default, all private subnets are selected. You can customize this using ``subnetSelection``. Default: - all private subnets used by the EKS cluster')
    _init_params: typing.ClassVar[list[str]] = ['cluster', 'selectors', 'fargate_profile_name', 'pod_execution_role', 'subnet_selection', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.FargateProfile'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.FargateProfileDefConfig] = pydantic.Field(None)


class FargateProfileDefConfig(pydantic.BaseModel):
    pod_execution_role_config: typing.Optional[models._interface_methods.AwsIamIRoleDefConfig] = pydantic.Field(None)
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_eks.HelmChart
class HelmChartDef(BaseConstruct):
    cluster: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ClusterDef, models.aws_eks.FargateClusterDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The EKS cluster to apply this configuration to. [disable-awslint:ref-via-interface]\n')
    atomic: typing.Optional[bool] = pydantic.Field(None, description='Whether or not Helm should treat this operation as atomic; if set, upgrade process rolls back changes made in case of failed upgrade. The --wait flag will be set automatically if --atomic is used. Default: false\n')
    chart: typing.Optional[str] = pydantic.Field(None, description='The name of the chart. Either this or ``chartAsset`` must be specified. Default: - No chart name. Implies ``chartAsset`` is used.\n')
    chart_asset: typing.Optional[models.aws_s3_assets.AssetDef] = pydantic.Field(None, description='The chart in the form of an asset. Either this or ``chart`` must be specified. Default: - No chart asset. Implies ``chart`` is used.\n')
    create_namespace: typing.Optional[bool] = pydantic.Field(None, description='create namespace if not exist. Default: true\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description='The Kubernetes namespace scope of the requests. Default: default\n')
    release: typing.Optional[str] = pydantic.Field(None, description="The name of the release. Default: - If no release name is given, it will use the last 53 characters of the node's unique id.\n")
    repository: typing.Optional[str] = pydantic.Field(None, description='The repository which contains the chart. For example: https://charts.helm.sh/stable/ Default: - No repository will be used, which means that the chart needs to be an absolute URL.\n')
    skip_crds: typing.Optional[bool] = pydantic.Field(None, description='if set, no CRDs will be installed. Default: - CRDs are installed if not already present\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Amount of time to wait for any individual Kubernetes operation. Maximum 15 minutes. Default: Duration.minutes(5)\n')
    values: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='The values to be used by the chart. For nested values use a nested dictionary. For example: values: { installationCRDs: true, webhook: { port: 9443 } } Default: - No values are provided to the chart.\n')
    version: typing.Optional[str] = pydantic.Field(None, description='The chart version to install. Default: - If this is not specified, the latest version is installed\n')
    wait: typing.Optional[bool] = pydantic.Field(None, description='Whether or not Helm should wait until all Pods, PVCs, Services, and minimum number of Pods of a Deployment, StatefulSet, or ReplicaSet are in a ready state before marking the release as successful. Default: - Helm will not wait before marking release as successful')
    _init_params: typing.ClassVar[list[str]] = ['cluster', 'atomic', 'chart', 'chart_asset', 'create_namespace', 'namespace', 'release', 'repository', 'skip_crds', 'timeout', 'values', 'version', 'wait']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.HelmChart'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.KubectlProvider
class KubectlProviderDef(BaseConstruct):
    cluster: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ClusterDef, models.aws_eks.FargateClusterDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The cluster to control.')
    _init_params: typing.ClassVar[list[str]] = ['cluster']
    _method_names: typing.ClassVar[list[str]] = ['add_dependency', 'add_metadata', 'add_transform', 'export_string_list_value', 'export_value', 'format_arn', 'get_logical_id', 'regional_fact', 'rename_logical_id', 'report_missing_context_key', 'resolve', 'set_parameter', 'split_arn']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_kubectl_provider_attributes', 'get_or_create', 'of']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.KubectlProvider'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_kubectl_provider_attributes', 'get_or_create']
    ...


    from_kubectl_provider_attributes: typing.Optional[models.aws_eks.KubectlProviderDefFromKubectlProviderAttributesParams] = pydantic.Field(None, description='Import an existing provider.')
    get_or_create: typing.Optional[models.aws_eks.KubectlProviderDefGetOrCreateParams] = pydantic.Field(None, description='Take existing provider or create new based on cluster.')
    resource_config: typing.Optional[models.aws_eks.KubectlProviderDefConfig] = pydantic.Field(None)


class KubectlProviderDefConfig(pydantic.BaseModel):
    add_dependency: typing.Optional[list[models.aws_eks.KubectlProviderDefAddDependencyParams]] = pydantic.Field(None, description='Add a dependency between this stack and another stack.\nThis can be used to define dependencies between any two stacks within an\napp, and also supports nested stacks.')
    add_metadata: typing.Optional[list[models.aws_eks.KubectlProviderDefAddMetadataParams]] = pydantic.Field(None, description='Adds an arbitary key-value pair, with information you want to record about the stack.\nThese get translated to the Metadata section of the generated template.')
    add_transform: typing.Optional[list[models.aws_eks.KubectlProviderDefAddTransformParams]] = pydantic.Field(None, description='Add a Transform to this stack. A Transform is a macro that AWS CloudFormation uses to process your template.\nDuplicate values are removed when stack is synthesized.')
    export_string_list_value: typing.Optional[list[models.aws_eks.KubectlProviderDefExportStringListValueParams]] = pydantic.Field(None, description="Create a CloudFormation Export for a string list value.\nReturns a string list representing the corresponding ``Fn.importValue()``\nexpression for this Export. The export expression is automatically wrapped with an\n``Fn::Join`` and the import value with an ``Fn::Split``, since CloudFormation can only\nexport strings. You can control the name for the export by passing the ``name`` option.\n\nIf you don't supply a value for ``name``, the value you're exporting must be\na Resource attribute (for example: ``bucket.bucketName``) and it will be\ngiven the same name as the automatic cross-stack reference that would be created\nif you used the attribute in another Stack.\n\nOne of the uses for this method is to *remove* the relationship between\ntwo Stacks established by automatic cross-stack references. It will\ntemporarily ensure that the CloudFormation Export still exists while you\nremove the reference from the consuming stack. After that, you can remove\nthe resource and the manual export.\n\nSee ``exportValue`` for an example of this process.")
    export_value: typing.Optional[list[models.aws_eks.KubectlProviderDefExportValueParams]] = pydantic.Field(None, description="Create a CloudFormation Export for a string value.\nReturns a string representing the corresponding ``Fn.importValue()``\nexpression for this Export. You can control the name for the export by\npassing the ``name`` option.\n\nIf you don't supply a value for ``name``, the value you're exporting must be\na Resource attribute (for example: ``bucket.bucketName``) and it will be\ngiven the same name as the automatic cross-stack reference that would be created\nif you used the attribute in another Stack.\n\nOne of the uses for this method is to *remove* the relationship between\ntwo Stacks established by automatic cross-stack references. It will\ntemporarily ensure that the CloudFormation Export still exists while you\nremove the reference from the consuming stack. After that, you can remove\nthe resource and the manual export.\n\n\nExample\n\nHere is how the process works. Let's say there are two stacks,\n``producerStack`` and ``consumerStack``, and ``producerStack`` has a bucket\ncalled ``bucket``, which is referenced by ``consumerStack`` (perhaps because\nan AWS Lambda Function writes into it, or something like that).\n\nIt is not safe to remove ``producerStack.bucket`` because as the bucket is being\ndeleted, ``consumerStack`` might still be using it.\n\nInstead, the process takes two deployments:\n\n\nDeployment 1: break the relationship\n\n- Make sure ``consumerStack`` no longer references ``bucket.bucketName`` (maybe the consumer\n  stack now uses its own bucket, or it writes to an AWS DynamoDB table, or maybe you just\n  remove the Lambda Function altogether).\n- In the ``ProducerStack`` class, call ``this.exportValue(this.bucket.bucketName)``. This\n  will make sure the CloudFormation Export continues to exist while the relationship\n  between the two stacks is being broken.\n- Deploy (this will effectively only change the ``consumerStack``, but it's safe to deploy both).\n\n\n\nDeployment 2: remove the bucket resource\n\n- You are now free to remove the ``bucket`` resource from ``producerStack``.\n- Don't forget to remove the ``exportValue()`` call as well.\n- Deploy again (this time only the ``producerStack`` will be changed -- the bucket will be deleted).")
    format_arn: typing.Optional[list[models.aws_eks.KubectlProviderDefFormatArnParams]] = pydantic.Field(None, description="Creates an ARN from components.\nIf ``partition``, ``region`` or ``account`` are not specified, the stack's\npartition, region and account will be used.\n\nIf any component is the empty string, an empty string will be inserted\ninto the generated ARN at the location that component corresponds to.\n\nThe ARN will be formatted as follows:\n\narn:{partition}:{service}:{region}:{account}:{resource}{sep}{resource-name}\n\nThe required ARN pieces that are omitted will be taken from the stack that\nthe 'scope' is attached to. If all ARN pieces are supplied, the supplied scope\ncan be 'undefined'.")
    get_logical_id: typing.Optional[list[models.aws_eks.KubectlProviderDefGetLogicalIdParams]] = pydantic.Field(None, description='Allocates a stack-unique CloudFormation-compatible logical identity for a specific resource.\nThis method is called when a ``CfnElement`` is created and used to render the\ninitial logical identity of resources. Logical ID renames are applied at\nthis stage.\n\nThis method uses the protected method ``allocateLogicalId`` to render the\nlogical ID for an element. To modify the naming scheme, extend the ``Stack``\nclass and override this method.')
    of: typing.Optional[list[models.aws_eks.KubectlProviderDefOfParams]] = pydantic.Field(None, description='Looks up the first stack scope in which ``construct`` is defined.\nFails if there is no stack up the tree.')
    regional_fact: typing.Optional[list[models.aws_eks.KubectlProviderDefRegionalFactParams]] = pydantic.Field(None, description='Look up a fact value for the given fact for the region of this stack.\nWill return a definite value only if the region of the current stack is resolved.\nIf not, a lookup map will be added to the stack and the lookup will be done at\nCDK deployment time.\n\nWhat regions will be included in the lookup map is controlled by the\n``@aws-cdk/core:target-partitions`` context value: it must be set to a list\nof partitions, and only regions from the given partitions will be included.\nIf no such context key is set, all regions will be included.\n\nThis function is intended to be used by construct library authors. Application\nbuilders can rely on the abstractions offered by construct libraries and do\nnot have to worry about regional facts.\n\nIf ``defaultValue`` is not given, it is an error if the fact is unknown for\nthe given region.')
    rename_logical_id: typing.Optional[list[models.aws_eks.KubectlProviderDefRenameLogicalIdParams]] = pydantic.Field(None, description='Rename a generated logical identities.\nTo modify the naming scheme strategy, extend the ``Stack`` class and\noverride the ``allocateLogicalId`` method.')
    report_missing_context_key: typing.Optional[list[models.aws_eks.KubectlProviderDefReportMissingContextKeyParams]] = pydantic.Field(None, description='Indicate that a context key was expected.\nContains instructions which will be emitted into the cloud assembly on how\nthe key should be supplied.')
    resolve: typing.Optional[list[models.aws_eks.KubectlProviderDefResolveParams]] = pydantic.Field(None, description='Resolve a tokenized value in the context of the current stack.')
    set_parameter: typing.Optional[list[models.aws_eks.KubectlProviderDefSetParameterParams]] = pydantic.Field(None, description='Assign a value to one of the nested stack parameters.')
    split_arn: typing.Optional[list[models.aws_eks.KubectlProviderDefSplitArnParams]] = pydantic.Field(None, description="Splits the provided ARN into its components.\nWorks both if 'arn' is a string like 'arn:aws:s3:::bucket',\nand a Token representing a dynamic CloudFormation expression\n(in which case the returned components will also be dynamic CloudFormation expressions,\nencoded as Tokens).")
    handler_role_config: typing.Optional[models._interface_methods.AwsIamIRoleDefConfig] = pydantic.Field(None)
    synthesizer_config: typing.Optional[models._interface_methods.CoreIStackSynthesizerDefConfig] = pydantic.Field(None)

class KubectlProviderDefAddDependencyParams(pydantic.BaseModel):
    target: models.StackDef = pydantic.Field(..., description='-\n')
    reason: typing.Optional[str] = pydantic.Field(None, description='-')
    ...

class KubectlProviderDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n')
    ...

class KubectlProviderDefAddTransformParams(pydantic.BaseModel):
    transform: str = pydantic.Field(..., description='The transform to add.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/transform-section-structure.html\n\nExample::\n\n    # stack: Stack\n\n\n    stack.add_transform("AWS::Serverless-2016-10-31")\n')
    ...

class KubectlProviderDefExportStringListValueParams(pydantic.BaseModel):
    exported_value: typing.Any = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the outputs. Default: - No description\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the export to create. Default: - A name is automatically chosen')
    ...

class KubectlProviderDefExportValueParams(pydantic.BaseModel):
    exported_value: typing.Any = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the outputs. Default: - No description\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the export to create. Default: - A name is automatically chosen')
    ...

class KubectlProviderDefFormatArnParams(pydantic.BaseModel):
    resource: str = pydantic.Field(..., description='Resource type (e.g. "table", "autoScalingGroup", "certificate"). For some resource types, e.g. S3 buckets, this field defines the bucket name.\n')
    service: str = pydantic.Field(..., description="The service namespace that identifies the AWS product (for example, 's3', 'iam', 'codepipeline').\n")
    account: typing.Optional[str] = pydantic.Field(None, description="The ID of the AWS account that owns the resource, without the hyphens. For example, 123456789012. Note that the ARNs for some resources don't require an account number, so this component might be omitted. Default: The account the stack is deployed to.\n")
    arn_format: typing.Optional[aws_cdk.ArnFormat] = pydantic.Field(None, description='The specific ARN format to use for this ARN value. Default: - uses value of ``sep`` as the separator for formatting, ``ArnFormat.SLASH_RESOURCE_NAME`` if that property was also not provided\n')
    partition: typing.Optional[str] = pydantic.Field(None, description='The partition that the resource is in. For standard AWS regions, the partition is aws. If you have resources in other partitions, the partition is aws-partitionname. For example, the partition for resources in the China (Beijing) region is aws-cn. Default: The AWS partition the stack is deployed to.\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region the resource resides in. Note that the ARNs for some resources do not require a region, so this component might be omitted. Default: The region the stack is deployed to.\n')
    resource_name: typing.Optional[str] = pydantic.Field(None, description='Resource name or path within the resource (i.e. S3 bucket object key) or a wildcard such as ``"*"``. This is service-dependent.')
    ...

class KubectlProviderDefFromKubectlProviderAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='Construct.\n')
    id: str = pydantic.Field(..., description='an id of resource.\n')
    function_arn: str = pydantic.Field(..., description="The custom resource provider's service token.\n")
    handler_role: typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef] = pydantic.Field(..., description='The IAM execution role of the handler. This role must be able to assume kubectlRoleArn\n')
    kubectl_role_arn: str = pydantic.Field(..., description='The IAM role to assume in order to perform kubectl operations against this cluster.')
    ...

class KubectlProviderDefGetLogicalIdParams(pydantic.BaseModel):
    element: models.CfnElementDef = pydantic.Field(..., description='The CloudFormation element for which a logical identity is needed.')
    ...

class KubectlProviderDefGetOrCreateParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='Construct.\n')
    cluster: typing.Union[models.aws_eks.ClusterDef, models.aws_eks.FargateClusterDef] = pydantic.Field(..., description='k8s cluster.')
    ...

class KubectlProviderDefOfParams(pydantic.BaseModel):
    construct_: models.AnyResource = pydantic.Field(..., description='The construct to start the search from.', alias='construct')
    return_config: typing.Optional[list[models.core.StackDefConfig]] = pydantic.Field(None)
    ...

class KubectlProviderDefRegionalFactParams(pydantic.BaseModel):
    fact_name: str = pydantic.Field(..., description='-\n')
    default_value: typing.Optional[str] = pydantic.Field(None, description='-')
    ...

class KubectlProviderDefRenameLogicalIdParams(pydantic.BaseModel):
    old_id: str = pydantic.Field(..., description='-\n')
    new_id: str = pydantic.Field(..., description='-')
    ...

class KubectlProviderDefReportMissingContextKeyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='The missing context key.\n')
    props: typing.Union[models.cloud_assembly_schema.AmiContextQueryDef, dict[str, typing.Any], models.cloud_assembly_schema.AvailabilityZonesContextQueryDef, models.cloud_assembly_schema.HostedZoneContextQueryDef, models.cloud_assembly_schema.SSMParameterContextQueryDef, models.cloud_assembly_schema.VpcContextQueryDef, models.cloud_assembly_schema.EndpointServiceAvailabilityZonesContextQueryDef, models.cloud_assembly_schema.LoadBalancerContextQueryDef, models.cloud_assembly_schema.LoadBalancerListenerContextQueryDef, models.cloud_assembly_schema.SecurityGroupContextQueryDef, models.cloud_assembly_schema.KeyContextQueryDef, models.cloud_assembly_schema.PluginContextQueryDef] = pydantic.Field(..., description='A set of provider-specific options.\n')
    provider: aws_cdk.cloud_assembly_schema.ContextProvider = pydantic.Field(..., description='The provider from which we expect this context key to be obtained.')
    ...

class KubectlProviderDefResolveParams(pydantic.BaseModel):
    obj: typing.Any = pydantic.Field(..., description='-')
    ...

class KubectlProviderDefSetParameterParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='The parameter name (ID).\n')
    value: str = pydantic.Field(..., description='The value to assign.')
    ...

class KubectlProviderDefSplitArnParams(pydantic.BaseModel):
    arn: str = pydantic.Field(..., description='the ARN to split into its components.\n')
    arn_format: aws_cdk.ArnFormat = pydantic.Field(..., description="the expected format of 'arn' - depends on what format the service 'arn' represents uses.")
    ...


#  autogenerated from aws_cdk.aws_eks.KubernetesManifest
class KubernetesManifestDef(BaseConstruct):
    cluster: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ClusterDef, models.aws_eks.FargateClusterDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The EKS cluster to apply this manifest to. [disable-awslint:ref-via-interface]\n')
    manifest: typing.Union[typing.Sequence[typing.Mapping[str, typing.Any]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The manifest to apply. Consists of any number of child resources. When the resources are created/updated, this manifest will be applied to the cluster through ``kubectl apply`` and when the resources or the stack is deleted, the resources in the manifest will be deleted through ``kubectl delete``.\n')
    overwrite: typing.Optional[bool] = pydantic.Field(None, description='Overwrite any existing resources. If this is set, we will use ``kubectl apply`` instead of ``kubectl create`` when the resource is created. Otherwise, if there is already a resource in the cluster with the same name, the operation will fail. Default: false\n')
    ingress_alb: typing.Optional[bool] = pydantic.Field(None, description='Automatically detect ``Ingress`` resources in the manifest and annotate them so they are picked up by an ALB Ingress Controller. Default: false\n')
    ingress_alb_scheme: typing.Optional[aws_cdk.aws_eks.AlbScheme] = pydantic.Field(None, description='Specify the ALB scheme that should be applied to ``Ingress`` resources. Only applicable if ``ingressAlb`` is set to ``true``. Default: AlbScheme.INTERNAL\n')
    prune: typing.Optional[bool] = pydantic.Field(None, description='When a resource is removed from a Kubernetes manifest, it no longer appears in the manifest, and there is no way to know that this resource needs to be deleted. To address this, ``kubectl apply`` has a ``--prune`` option which will query the cluster for all resources with a specific label and will remove all the labeld resources that are not part of the applied manifest. If this option is disabled and a resource is removed, it will become "orphaned" and will not be deleted from the cluster. When this option is enabled (default), the construct will inject a label to all Kubernetes resources included in this manifest which will be used to prune resources when the manifest changes via ``kubectl apply --prune``. The label name will be ``aws.cdk.eks/prune-<ADDR>`` where ``<ADDR>`` is the 42-char unique address of this construct in the construct tree. Value is empty. Default: - based on the prune option of the cluster, which is ``true`` unless otherwise specified.\n')
    skip_validation: typing.Optional[bool] = pydantic.Field(None, description='A flag to signify if the manifest validation should be skipped. Default: false')
    _init_params: typing.ClassVar[list[str]] = ['cluster', 'manifest', 'overwrite', 'ingress_alb', 'ingress_alb_scheme', 'prune', 'skip_validation']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.KubernetesManifest'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.KubernetesObjectValue
class KubernetesObjectValueDef(BaseConstruct):
    cluster: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ClusterDef, models.aws_eks.FargateClusterDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The EKS cluster to fetch attributes from. [disable-awslint:ref-via-interface]\n')
    json_path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='JSONPath to the specific value.\n')
    object_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the object to query.\n')
    object_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The object type to query. (e.g 'service', 'pod'...)\n")
    object_namespace: typing.Optional[str] = pydantic.Field(None, description="The namespace the object belongs to. Default: 'default'\n")
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Timeout for waiting on a value. Default: Duration.minutes(5)')
    _init_params: typing.ClassVar[list[str]] = ['cluster', 'json_path', 'object_name', 'object_type', 'object_namespace', 'timeout']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.KubernetesObjectValue'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.KubernetesPatch
class KubernetesPatchDef(BaseConstruct):
    apply_patch: typing.Union[typing.Mapping[str, typing.Any], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The JSON object to pass to ``kubectl patch`` when the resource is created/updated.\n')
    cluster: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ClusterDef, models.aws_eks.FargateClusterDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The cluster to apply the patch to. [disable-awslint:ref-via-interface]\n')
    resource_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The full name of the resource to patch (e.g. ``deployment/coredns``).\n')
    restore_patch: typing.Union[typing.Mapping[str, typing.Any], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The JSON object to pass to ``kubectl patch`` when the resource is removed.\n')
    patch_type: typing.Optional[aws_cdk.aws_eks.PatchType] = pydantic.Field(None, description='The patch type to pass to ``kubectl patch``. The default type used by ``kubectl patch`` is "strategic". Default: PatchType.STRATEGIC\n')
    resource_namespace: typing.Optional[str] = pydantic.Field(None, description='The kubernetes API namespace. Default: "default"')
    _init_params: typing.ClassVar[list[str]] = ['apply_patch', 'cluster', 'resource_name', 'restore_patch', 'patch_type', 'resource_namespace']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.KubernetesPatch'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.Nodegroup
class NodegroupDef(BaseConstruct):
    cluster: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ClusterDef, models.aws_eks.FargateClusterDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='Cluster resource.\n')
    ami_type: typing.Optional[aws_cdk.aws_eks.NodegroupAmiType] = pydantic.Field(None, description='The AMI type for your node group. If you explicitly specify the launchTemplate with custom AMI, do not specify this property, or the node group deployment will fail. In other cases, you will need to specify correct amiType for the nodegroup. Default: - auto-determined from the instanceTypes property when launchTemplateSpec property is not specified\n')
    capacity_type: typing.Optional[aws_cdk.aws_eks.CapacityType] = pydantic.Field(None, description='The capacity type of the nodegroup. Default: - ON_DEMAND\n')
    desired_size: typing.Union[int, float, None] = pydantic.Field(None, description='The current number of worker nodes that the managed node group should maintain. If not specified, the nodewgroup will initially create ``minSize`` instances. Default: 2\n')
    disk_size: typing.Union[int, float, None] = pydantic.Field(None, description='The root device disk size (in GiB) for your node group instances. Default: 20\n')
    force_update: typing.Optional[bool] = pydantic.Field(None, description="Force the update if the existing node group's pods are unable to be drained due to a pod disruption budget issue. If an update fails because pods could not be drained, you can force the update after it fails to terminate the old node whether or not any pods are running on the node. Default: true\n")
    instance_types: typing.Optional[typing.Sequence[models.aws_ec2.InstanceTypeDef]] = pydantic.Field(None, description='The instance types to use for your node group. Default: t3.medium will be used according to the cloudformation document.\n')
    labels: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The Kubernetes labels to be applied to the nodes in the node group when they are created. Default: - None\n')
    launch_template_spec: typing.Union[models.aws_eks.LaunchTemplateSpecDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Launch template specification used for the nodegroup. Default: - no launch template\n')
    max_size: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of worker nodes that the managed node group can scale out to. Managed node groups can support up to 100 nodes by default. Default: - desiredSize\n')
    max_unavailable: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of nodes unavailable at once during a version update. Nodes will be updated in parallel. The maximum number is 100. This value or ``maxUnavailablePercentage`` is required to have a value for custom update configurations to be applied. Default: 1\n')
    max_unavailable_percentage: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum percentage of nodes unavailable during a version update. This percentage of nodes will be updated in parallel, up to 100 nodes at once. This value or ``maxUnavailable`` is required to have a value for custom update configurations to be applied. Default: undefined - node groups will update instances one at a time\n')
    min_size: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of worker nodes that the managed node group can scale in to. This number must be greater than or equal to zero. Default: 1\n')
    nodegroup_name: typing.Optional[str] = pydantic.Field(None, description='Name of the Nodegroup. Default: - resource ID\n')
    node_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The IAM role to associate with your node group. The Amazon EKS worker node kubelet daemon makes calls to AWS APIs on your behalf. Worker nodes receive permissions for these API calls through an IAM instance profile and associated policies. Before you can launch worker nodes and register them into a cluster, you must create an IAM role for those worker nodes to use when they are launched. Default: - None. Auto-generated if not specified.\n')
    release_version: typing.Optional[str] = pydantic.Field(None, description="The AMI version of the Amazon EKS-optimized AMI to use with your node group (for example, ``1.14.7-YYYYMMDD``). Default: - The latest available AMI version for the node group's current Kubernetes version is used.\n")
    remote_access: typing.Union[models.aws_eks.NodegroupRemoteAccessDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The remote access (SSH) configuration to use with your node group. Disabled by default, however, if you specify an Amazon EC2 SSH key but do not specify a source security group when you create a managed node group, then port 22 on the worker nodes is opened to the internet (0.0.0.0/0) Default: - disabled\n')
    subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The subnets to use for the Auto Scaling group that is created for your node group. By specifying the SubnetSelection, the selected subnets will automatically apply required tags i.e. ``kubernetes.io/cluster/CLUSTER_NAME`` with a value of ``shared``, where ``CLUSTER_NAME`` is replaced with the name of your cluster. Default: - private subnets\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The metadata to apply to the node group to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Node group tags do not propagate to any other resources associated with the node group, such as the Amazon EC2 instances or subnets. Default: - None\n')
    taints: typing.Optional[typing.Sequence[typing.Union[models.aws_eks.TaintSpecDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The Kubernetes taints to be applied to the nodes in the node group when they are created. Default: - None')
    _init_params: typing.ClassVar[list[str]] = ['cluster', 'ami_type', 'capacity_type', 'desired_size', 'disk_size', 'force_update', 'instance_types', 'labels', 'launch_template_spec', 'max_size', 'max_unavailable', 'max_unavailable_percentage', 'min_size', 'nodegroup_name', 'node_role', 'release_version', 'remote_access', 'subnets', 'tags', 'taints']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_nodegroup_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.Nodegroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_nodegroup_name']
    ...


    from_nodegroup_name: typing.Optional[models.aws_eks.NodegroupDefFromNodegroupNameParams] = pydantic.Field(None, description='Import the Nodegroup from attributes.')
    resource_config: typing.Optional[models.aws_eks.NodegroupDefConfig] = pydantic.Field(None)


class NodegroupDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    cluster_config: typing.Optional[models._interface_methods.AwsEksIClusterDefConfig] = pydantic.Field(None)
    role_config: typing.Optional[models._interface_methods.AwsIamIRoleDefConfig] = pydantic.Field(None)

class NodegroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class NodegroupDefFromNodegroupNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    nodegroup_name: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_eks.OpenIdConnectProvider
class OpenIdConnectProviderDef(BaseConstruct):
    url: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The URL of the identity provider. The URL must begin with https:// and should correspond to the iss claim in the provider\'s OpenID Connect ID tokens. Per the OIDC standard, path components are allowed but query parameters are not. Typically the URL consists of only a hostname, like https://server.example.org or https://example.com. You can find your OIDC Issuer URL by: aws eks describe-cluster --name %cluster_name% --query "cluster.identity.oidc.issuer" --output text')
    _init_params: typing.ClassVar[list[str]] = ['url']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_open_id_connect_provider_arn']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.OpenIdConnectProvider'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_open_id_connect_provider_arn']
    ...


    from_open_id_connect_provider_arn: typing.Optional[models.aws_eks.OpenIdConnectProviderDefFromOpenIdConnectProviderArnParams] = pydantic.Field(None, description='Imports an Open ID connect provider from an ARN.')
    resource_config: typing.Optional[models.aws_eks.OpenIdConnectProviderDefConfig] = pydantic.Field(None)


class OpenIdConnectProviderDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class OpenIdConnectProviderDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class OpenIdConnectProviderDefFromOpenIdConnectProviderArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The definition scope.\n')
    id: str = pydantic.Field(..., description='ID of the construct.\n')
    open_id_connect_provider_arn: str = pydantic.Field(..., description='the ARN to import.')
    ...


#  autogenerated from aws_cdk.aws_eks.ServiceAccount
class ServiceAccountDef(BaseConstruct):
    cluster: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ClusterDef, models.aws_eks.FargateClusterDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The cluster to apply the patch to.\n')
    annotations: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Additional annotations of the service account. Default: - no additional annotations\n')
    identity_type: typing.Optional[aws_cdk.aws_eks.IdentityType] = pydantic.Field(None, description='The identity type to use for the service account. Default: IdentityType.IRSA\n')
    labels: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Additional labels of the service account. Default: - no additional labels\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the service account. The name of a ServiceAccount object must be a valid DNS subdomain name. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ Default: - If no name is given, it will use the id of the resource.\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description='The namespace of the service account. All namespace names must be valid RFC 1123 DNS labels. https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/#namespaces-and-dns Default: "default"')
    _init_params: typing.ClassVar[list[str]] = ['cluster', 'annotations', 'identity_type', 'labels', 'name', 'namespace']
    _method_names: typing.ClassVar[list[str]] = ['add_to_principal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.ServiceAccount'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.ServiceAccountDefConfig] = pydantic.Field(None)


class ServiceAccountDefConfig(pydantic.BaseModel):
    add_to_principal_policy: typing.Optional[list[models.aws_eks.ServiceAccountDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)
    role_config: typing.Optional[models._interface_methods.AwsIamIRoleDefConfig] = pydantic.Field(None)

class ServiceAccountDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_eks.AccessEntryAttributes
class AccessEntryAttributesDef(BaseStruct):
    access_entry_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the access entry.\n')
    access_entry_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the access entry.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    access_entry_attributes = eks.AccessEntryAttributes(\n        access_entry_arn="accessEntryArn",\n        access_entry_name="accessEntryName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['access_entry_arn', 'access_entry_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.AccessEntryAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.AccessEntryProps
class AccessEntryPropsDef(BaseStruct):
    access_policies: typing.Union[typing.Sequence[typing.Union[models.aws_eks.AccessPolicyDef]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The access policies that define the permissions and scope for the access entry.\n')
    cluster: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ClusterDef, models.aws_eks.FargateClusterDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon EKS cluster to which the access entry applies.\n')
    principal: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the principal (user or role) to associate the access entry with.\n')
    access_entry_name: typing.Optional[str] = pydantic.Field(None, description='The name of the AccessEntry. Default: - No access entry name is provided\n')
    access_entry_type: typing.Optional[aws_cdk.aws_eks.AccessEntryType] = pydantic.Field(None, description='The type of the AccessEntry. Default: STANDARD\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    # access_policy: eks.AccessPolicy\n    # cluster: eks.Cluster\n\n    access_entry_props = eks.AccessEntryProps(\n        access_policies=[access_policy],\n        cluster=cluster,\n        principal="principal",\n\n        # the properties below are optional\n        access_entry_name="accessEntryName",\n        access_entry_type=eks.AccessEntryType.STANDARD\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['access_policies', 'cluster', 'principal', 'access_entry_name', 'access_entry_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.AccessEntryProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.AccessPolicyNameOptions
class AccessPolicyNameOptionsDef(BaseStruct):
    access_scope_type: typing.Union[aws_cdk.aws_eks.AccessScopeType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The scope of the access policy. This determines the level of access granted by the policy.\n')
    namespaces: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='An optional array of Kubernetes namespaces to which the access policy applies. Default: - no specific namespaces for this scope\n\n:exampleMetadata: infused\n\nExample::\n\n    # AmazonEKSClusterAdminPolicy with `cluster` scope\n    eks.AccessPolicy.from_access_policy_name("AmazonEKSClusterAdminPolicy",\n        access_scope_type=eks.AccessScopeType.CLUSTER\n    )\n    # AmazonEKSAdminPolicy with `namespace` scope\n    eks.AccessPolicy.from_access_policy_name("AmazonEKSAdminPolicy",\n        access_scope_type=eks.AccessScopeType.NAMESPACE,\n        namespaces=["foo", "bar"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['access_scope_type', 'namespaces']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.AccessPolicyNameOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.AccessPolicyProps
class AccessPolicyPropsDef(BaseStruct):
    access_scope: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.AccessScopeDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The scope of the access policy, which determines the level of access granted.\n')
    policy: typing.Union[models.aws_eks.AccessPolicyArnDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The access policy itself, which defines the specific permissions.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    # access_policy_arn: eks.AccessPolicyArn\n\n    access_policy_props = eks.AccessPolicyProps(\n        access_scope=eks.AccessScope(\n            type=eks.AccessScopeType.NAMESPACE,\n\n            # the properties below are optional\n            namespaces=["namespaces"]\n        ),\n        policy=access_policy_arn\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['access_scope', 'policy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.AccessPolicyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.AccessPolicyPropsDefConfig] = pydantic.Field(None)


class AccessPolicyPropsDefConfig(pydantic.BaseModel):
    policy_config: typing.Optional[models.aws_eks.AccessPolicyArnDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_eks.AccessScope
class AccessScopeDef(BaseStruct):
    type: typing.Union[aws_cdk.aws_eks.AccessScopeType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The scope type of the policy, either 'namespace' or 'cluster'.\n")
    namespaces: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A Kubernetes namespace that an access policy is scoped to. A value is required if you specified namespace for Type. Default: - no specific namespaces for this scope.\n\n:interface: AccessScope\n:property: {AccessScopeType} type - The scope type of the policy, either \'namespace\' or \'cluster\'.\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    access_scope = eks.AccessScope(\n        type=eks.AccessScopeType.NAMESPACE,\n\n        # the properties below are optional\n        namespaces=["namespaces"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'namespaces']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.AccessScope'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.AlbControllerOptions
class AlbControllerOptionsDef(BaseStruct):
    version: typing.Union[models.aws_eks.AlbControllerVersionDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Version of the controller.\n')
    policy: typing.Any = pydantic.Field(None, description="The IAM policy to apply to the service account. If you're using one of the built-in versions, this is not required since CDK ships with the appropriate policies for those versions. However, if you are using a custom version, this is required (and validated). Default: - Corresponds to the predefined version.\n")
    repository: typing.Optional[str] = pydantic.Field(None, description='The repository to pull the controller image from. Note that the default repository works for most regions, but not all. If the repository is not applicable to your region, use a custom repository according to the information here: https://github.com/kubernetes-sigs/aws-load-balancer-controller/releases. Default: \'602401143452.dkr.ecr.us-west-2.amazonaws.com/amazon/aws-load-balancer-controller\'\n\n:exampleMetadata: infused\n\nExample::\n\n    eks.Cluster(self, "HelloEKS",\n        version=eks.KubernetesVersion.V1_30,\n        alb_controller=eks.AlbControllerOptions(\n            version=eks.AlbControllerVersion.V2_6_2\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['version', 'policy', 'repository']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.AlbControllerOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.AlbControllerProps
class AlbControllerPropsDef(BaseStruct):
    version: typing.Union[models.aws_eks.AlbControllerVersionDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Version of the controller.\n')
    policy: typing.Any = pydantic.Field(None, description="The IAM policy to apply to the service account. If you're using one of the built-in versions, this is not required since CDK ships with the appropriate policies for those versions. However, if you are using a custom version, this is required (and validated). Default: - Corresponds to the predefined version.\n")
    repository: typing.Optional[str] = pydantic.Field(None, description="The repository to pull the controller image from. Note that the default repository works for most regions, but not all. If the repository is not applicable to your region, use a custom repository according to the information here: https://github.com/kubernetes-sigs/aws-load-balancer-controller/releases. Default: '602401143452.dkr.ecr.us-west-2.amazonaws.com/amazon/aws-load-balancer-controller'\n")
    cluster: typing.Union[models.aws_eks.ClusterDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='[disable-awslint:ref-via-interface] Cluster to install the controller onto.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    # alb_controller_version: eks.AlbControllerVersion\n    # cluster: eks.Cluster\n    # policy: Any\n\n    alb_controller_props = eks.AlbControllerProps(\n        cluster=cluster,\n        version=alb_controller_version,\n\n        # the properties below are optional\n        policy=policy,\n        repository="repository"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['version', 'policy', 'repository', 'cluster']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.AlbControllerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.AutoScalingGroupCapacityOptions
class AutoScalingGroupCapacityOptionsDef(BaseStruct):
    allow_all_outbound: typing.Optional[bool] = pydantic.Field(None, description='Whether the instances can initiate connections to anywhere by default. Default: true\n')
    associate_public_ip_address: typing.Optional[bool] = pydantic.Field(None, description='Whether instances in the Auto Scaling Group should have public IP addresses associated with them. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified Default: - Use subnet setting.\n')
    auto_scaling_group_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Auto Scaling group. This name must be unique per Region per account. Default: - Auto generated by CloudFormation\n')
    block_devices: typing.Optional[typing.Sequence[typing.Union[models.aws_autoscaling.BlockDeviceDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Specifies how block devices are exposed to the instance. You can specify virtual devices and EBS volumes. Each instance that is launched has an associated root device volume, either an Amazon EBS volume or an instance store volume. You can use block device mappings to specify additional EBS volumes or instance store volumes to attach to an instance when it is launched. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified Default: - Uses the block device mapping of the AMI\n')
    capacity_rebalance: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether Capacity Rebalancing is enabled. When you turn on Capacity Rebalancing, Amazon EC2 Auto Scaling attempts to launch a Spot Instance whenever Amazon EC2 notifies that a Spot Instance is at an elevated risk of interruption. After launching a new instance, it then terminates an old instance. Default: false\n')
    cooldown: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Default scaling cooldown for this AutoScalingGroup. Default: Duration.minutes(5)\n')
    default_instance_warmup: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The amount of time, in seconds, until a newly launched instance can contribute to the Amazon CloudWatch metrics. This delay lets an instance finish initializing before Amazon EC2 Auto Scaling aggregates instance metrics, resulting in more reliable usage data. Set this value equal to the amount of time that it takes for resource consumption to become stable after an instance reaches the InService state. To optimize the performance of scaling policies that scale continuously, such as target tracking and step scaling policies, we strongly recommend that you enable the default instance warmup, even if its value is set to 0 seconds Default instance warmup will not be added if no value is specified Default: None\n')
    desired_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Initial amount of instances in the fleet. If this is set to a number, every deployment will reset the amount of instances to this number. It is recommended to leave this value blank. Default: minCapacity, and leave unchanged during deployment\n')
    group_metrics: typing.Optional[typing.Sequence[models.aws_autoscaling.GroupMetricsDef]] = pydantic.Field(None, description='Enable monitoring for group metrics, these metrics describe the group rather than any of its instances. To report all group metrics use ``GroupMetrics.all()`` Group metrics are reported in a granularity of 1 minute at no additional charge. Default: - no group metrics will be reported\n')
    health_check: typing.Optional[models.aws_autoscaling.HealthCheckDef] = pydantic.Field(None, description='Configuration for health checks. Default: - HealthCheck.ec2 with no grace period\n')
    ignore_unmodified_size_properties: typing.Optional[bool] = pydantic.Field(None, description="If the ASG has scheduled actions, don't reset unchanged group sizes. Only used if the ASG has scheduled actions (which may scale your ASG up or down regardless of cdk deployments). If true, the size of the group will only be reset if it has been changed in the CDK app. If false, the sizes will always be changed back to what they were in the CDK app on deployment. Default: true\n")
    instance_monitoring: typing.Optional[aws_cdk.aws_autoscaling.Monitoring] = pydantic.Field(None, description='Controls whether instances in this group are launched with detailed or basic monitoring. When detailed monitoring is enabled, Amazon CloudWatch generates metrics every minute and your account is charged a fee. When you disable detailed monitoring, CloudWatch generates metrics every 5 minutes. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified Default: - Monitoring.DETAILED\n')
    key_name: typing.Optional[str] = pydantic.Field(None, description='(deprecated) Name of SSH keypair to grant access to instances. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified You can either specify ``keyPair`` or ``keyName``, not both. Default: - No SSH access will be possible.\n')
    key_pair: typing.Optional[typing.Union[models.aws_ec2.KeyPairDef]] = pydantic.Field(None, description='The SSH keypair to grant access to the instance. Feature flag ``AUTOSCALING_GENERATE_LAUNCH_TEMPLATE`` must be enabled to use this property. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified. You can either specify ``keyPair`` or ``keyName``, not both. Default: - No SSH access will be possible.\n')
    max_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Maximum number of instances in the fleet. Default: desiredCapacity\n')
    max_instance_lifetime: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum amount of time that an instance can be in service. The maximum duration applies to all current and future instances in the group. As an instance approaches its maximum duration, it is terminated and replaced, and cannot be used again. You must specify a value of at least 604,800 seconds (7 days). To clear a previously set value, leave this property undefined. Default: none\n')
    min_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Minimum number of instances in the fleet. Default: 1\n')
    new_instances_protected_from_scale_in: typing.Optional[bool] = pydantic.Field(None, description="Whether newly-launched instances are protected from termination by Amazon EC2 Auto Scaling when scaling in. By default, Auto Scaling can terminate an instance at any time after launch when scaling in an Auto Scaling Group, subject to the group's termination policy. However, you may wish to protect newly-launched instances from being scaled in if they are going to run critical applications that should not be prematurely terminated. This flag must be enabled if the Auto Scaling Group will be associated with an ECS Capacity Provider with managed termination protection. Default: false\n")
    notifications: typing.Optional[typing.Sequence[typing.Union[models.aws_autoscaling.NotificationConfigurationDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Configure autoscaling group to send notifications about fleet changes to an SNS topic(s). Default: - No fleet change notifications will be sent.\n')
    signals: typing.Optional[models.aws_autoscaling.SignalsDef] = pydantic.Field(None, description='Configure waiting for signals during deployment. Use this to pause the CloudFormation deployment to wait for the instances in the AutoScalingGroup to report successful startup during creation and updates. The UserData script needs to invoke ``cfn-signal`` with a success or failure code after it is done setting up the instance. Without waiting for signals, the CloudFormation deployment will proceed as soon as the AutoScalingGroup has been created or updated but before the instances in the group have been started. For example, to have instances wait for an Elastic Load Balancing health check before they signal success, add a health-check verification by using the cfn-init helper script. For an example, see the verify_instance_health command in the Auto Scaling rolling updates sample template: https://github.com/awslabs/aws-cloudformation-templates/blob/master/aws/services/AutoScaling/AutoScalingRollingUpdates.yaml Default: - Do not wait for signals\n')
    spot_price: typing.Optional[str] = pydantic.Field(None, description='The maximum hourly price (in USD) to be paid for any Spot Instance launched to fulfill the request. Spot Instances are launched when the price you specify exceeds the current Spot market price. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified Default: none\n')
    ssm_session_permissions: typing.Optional[bool] = pydantic.Field(None, description='Add SSM session permissions to the instance role. Setting this to ``true`` adds the necessary permissions to connect to the instance using SSM Session Manager. You can do this from the AWS Console. NOTE: Setting this flag to ``true`` may not be enough by itself. You must also use an AMI that comes with the SSM Agent, or install the SSM Agent yourself. See `Working with SSM Agent <https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-agent.html>`_ in the SSM Developer Guide. Default: false\n')
    termination_policies: typing.Optional[typing.Sequence[aws_cdk.aws_autoscaling.TerminationPolicy]] = pydantic.Field(None, description='A policy or a list of policies that are used to select the instances to terminate. The policies are executed in the order that you list them. Default: - ``TerminationPolicy.DEFAULT``\n')
    termination_policy_custom_lambda_function_arn: typing.Optional[str] = pydantic.Field(None, description='A lambda function Arn that can be used as a custom termination policy to select the instances to terminate. This property must be specified if the TerminationPolicy.CUSTOM_LAMBDA_FUNCTION is used. Default: - No lambda function Arn will be supplied\n')
    update_policy: typing.Optional[models.aws_autoscaling.UpdatePolicyDef] = pydantic.Field(None, description="What to do when an AutoScalingGroup's instance configuration is changed. This is applied when any of the settings on the ASG are changed that affect how the instances should be created (VPC, instance type, startup scripts, etc.). It indicates how the existing instances should be replaced with new instances matching the new config. By default, nothing is done and only new instances are launched with the new config. Default: - ``UpdatePolicy.rollingUpdate()`` if using ``init``, ``UpdatePolicy.none()`` otherwise\n")
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Where to place instances within the VPC. Default: - All Private subnets.\n')
    instance_type: typing.Union[models.aws_ec2.InstanceTypeDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Instance type of the instances to start.\n')
    bootstrap_enabled: typing.Optional[bool] = pydantic.Field(None, description='Configures the EC2 user-data script for instances in this autoscaling group to bootstrap the node (invoke ``/etc/eks/bootstrap.sh``) and associate it with the EKS cluster. If you wish to provide a custom user data script, set this to ``false`` and manually invoke ``autoscalingGroup.addUserData()``. Default: true\n')
    bootstrap_options: typing.Union[models.aws_eks.BootstrapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='EKS node bootstrapping options. Default: - none\n')
    machine_image_type: typing.Optional[aws_cdk.aws_eks.MachineImageType] = pydantic.Field(None, description='Machine image type. Default: MachineImageType.AMAZON_LINUX_2\n')
    map_role: typing.Optional[bool] = pydantic.Field(None, description='Will automatically update the aws-auth ConfigMap to map the IAM instance role to RBAC. This cannot be explicitly set to ``true`` if the cluster has kubectl disabled. Default: - true if the cluster has kubectl enabled (which is the default).\n')
    spot_interrupt_handler: typing.Optional[bool] = pydantic.Field(None, description='Installs the AWS spot instance interrupt handler on the cluster if it\'s not already added. Only relevant if ``spotPrice`` is used. Default: true\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: eks.Cluster\n\n    cluster.add_auto_scaling_group_capacity("BottlerocketNodes",\n        instance_type=ec2.InstanceType("t3.small"),\n        min_capacity=2,\n        machine_image_type=eks.MachineImageType.BOTTLEROCKET\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allow_all_outbound', 'associate_public_ip_address', 'auto_scaling_group_name', 'block_devices', 'capacity_rebalance', 'cooldown', 'default_instance_warmup', 'desired_capacity', 'group_metrics', 'health_check', 'ignore_unmodified_size_properties', 'instance_monitoring', 'key_name', 'key_pair', 'max_capacity', 'max_instance_lifetime', 'min_capacity', 'new_instances_protected_from_scale_in', 'notifications', 'signals', 'spot_price', 'ssm_session_permissions', 'termination_policies', 'termination_policy_custom_lambda_function_arn', 'update_policy', 'vpc_subnets', 'instance_type', 'bootstrap_enabled', 'bootstrap_options', 'machine_image_type', 'map_role', 'spot_interrupt_handler']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.AutoScalingGroupCapacityOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.AutoScalingGroupCapacityOptionsDefConfig] = pydantic.Field(None)


class AutoScalingGroupCapacityOptionsDefConfig(pydantic.BaseModel):
    instance_type_config: typing.Optional[models.aws_ec2.InstanceTypeDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_eks.AutoScalingGroupOptions
class AutoScalingGroupOptionsDef(BaseStruct):
    bootstrap_enabled: typing.Optional[bool] = pydantic.Field(None, description='Configures the EC2 user-data script for instances in this autoscaling group to bootstrap the node (invoke ``/etc/eks/bootstrap.sh``) and associate it with the EKS cluster. If you wish to provide a custom user data script, set this to ``false`` and manually invoke ``autoscalingGroup.addUserData()``. Default: true\n')
    bootstrap_options: typing.Union[models.aws_eks.BootstrapOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Allows options for node bootstrapping through EC2 user data. Default: - default options\n')
    machine_image_type: typing.Optional[aws_cdk.aws_eks.MachineImageType] = pydantic.Field(None, description='Allow options to specify different machine image type. Default: MachineImageType.AMAZON_LINUX_2\n')
    map_role: typing.Optional[bool] = pydantic.Field(None, description='Will automatically update the aws-auth ConfigMap to map the IAM instance role to RBAC. This cannot be explicitly set to ``true`` if the cluster has kubectl disabled. Default: - true if the cluster has kubectl enabled (which is the default).\n')
    spot_interrupt_handler: typing.Optional[bool] = pydantic.Field(None, description="Installs the AWS spot instance interrupt handler on the cluster if it's not already added. Only relevant if ``spotPrice`` is configured on the auto-scaling group. Default: true\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: eks.Cluster\n    # asg: autoscaling.AutoScalingGroup\n\n    cluster.connect_auto_scaling_group_capacity(asg)\n")
    _init_params: typing.ClassVar[list[str]] = ['bootstrap_enabled', 'bootstrap_options', 'machine_image_type', 'map_role', 'spot_interrupt_handler']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.AutoScalingGroupOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.AwsAuthMapping
class AwsAuthMappingDef(BaseStruct):
    groups: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of groups within Kubernetes to which the role is mapped.\n')
    username: typing.Optional[str] = pydantic.Field(None, description='The user name within Kubernetes to map to the IAM role. Default: - By default, the user name is the ARN of the IAM role.\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: eks.Cluster\n\n    admin_user = iam.User(self, "Admin")\n    cluster.aws_auth.add_user_mapping(admin_user, groups=["system:masters"])\n')
    _init_params: typing.ClassVar[list[str]] = ['groups', 'username']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.AwsAuthMapping'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.AwsAuthProps
class AwsAuthPropsDef(BaseStruct):
    cluster: typing.Union[models.aws_eks.ClusterDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The EKS cluster to apply this configuration to. [disable-awslint:ref-via-interface]\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    # cluster: eks.Cluster\n\n    aws_auth_props = eks.AwsAuthProps(\n        cluster=cluster\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cluster']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.AwsAuthProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.BootstrapOptions
class BootstrapOptionsDef(BaseStruct):
    additional_args: typing.Optional[str] = pydantic.Field(None, description='Additional command line arguments to pass to the ``/etc/eks/bootstrap.sh`` command. Default: - none\n')
    aws_api_retry_attempts: typing.Union[int, float, None] = pydantic.Field(None, description='Number of retry attempts for AWS API call (DescribeCluster). Default: 3\n')
    dns_cluster_ip: typing.Optional[str] = pydantic.Field(None, description='Overrides the IP address to use for DNS queries within the cluster. Default: - 10.100.0.10 or 172.20.0.10 based on the IP address of the primary interface.\n')
    docker_config_json: typing.Optional[str] = pydantic.Field(None, description='The contents of the ``/etc/docker/daemon.json`` file. Useful if you want a custom config differing from the default one in the EKS AMI. Default: - none\n')
    enable_docker_bridge: typing.Optional[bool] = pydantic.Field(None, description='Restores the docker default bridge network. Default: false\n')
    kubelet_extra_args: typing.Optional[str] = pydantic.Field(None, description='Extra arguments to add to the kubelet. Useful for adding labels or taints. For example, ``--node-labels foo=bar,goo=far``. Default: - none\n')
    use_max_pods: typing.Optional[bool] = pydantic.Field(None, description='Sets ``--max-pods`` for the kubelet based on the capacity of the EC2 instance. Default: true\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: eks.Cluster\n\n    cluster.add_auto_scaling_group_capacity("spot",\n        instance_type=ec2.InstanceType("t3.large"),\n        min_capacity=2,\n        bootstrap_options=eks.BootstrapOptions(\n            kubelet_extra_args="--node-labels foo=bar,goo=far",\n            aws_api_retry_attempts=5\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['additional_args', 'aws_api_retry_attempts', 'dns_cluster_ip', 'docker_config_json', 'enable_docker_bridge', 'kubelet_extra_args', 'use_max_pods']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.BootstrapOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnAccessEntry.AccessPolicyProperty
class CfnAccessEntry_AccessPolicyPropertyDef(BaseStruct):
    access_scope: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_eks.CfnAccessEntry_AccessScopePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description="The scope of an ``AccessPolicy`` that's associated to an ``AccessEntry`` .\n")
    policy_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the access policy.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-accessentry-accesspolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    access_policy_property = eks.CfnAccessEntry.AccessPolicyProperty(\n        access_scope=eks.CfnAccessEntry.AccessScopeProperty(\n            type="type",\n\n            # the properties below are optional\n            namespaces=["namespaces"]\n        ),\n        policy_arn="policyArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['access_scope', 'policy_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnAccessEntry.AccessPolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnAccessEntry.AccessScopeProperty
class CfnAccessEntry_AccessScopePropertyDef(BaseStruct):
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The scope type of an access policy.\n')
    namespaces: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A Kubernetes ``namespace`` that an access policy is scoped to. A value is required if you specified ``namespace`` for ``Type`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-accessentry-accessscope.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    access_scope_property = eks.CfnAccessEntry.AccessScopeProperty(\n        type="type",\n\n        # the properties below are optional\n        namespaces=["namespaces"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'namespaces']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnAccessEntry.AccessScopeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnAddon.PodIdentityAssociationProperty
class CfnAddon_PodIdentityAssociationPropertyDef(BaseStruct):
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the IAM role to associate with the service account. The EKS Pod Identity agent manages credentials to assume this role for applications in the containers in the pods that use this service account.\n')
    service_account: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the Kubernetes service account inside the cluster to associate the IAM credentials with.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-addon-podidentityassociation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    pod_identity_association_property = eks.CfnAddon.PodIdentityAssociationProperty(\n        role_arn="roleArn",\n        service_account="serviceAccount"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['role_arn', 'service_account']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnAddon.PodIdentityAssociationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnCluster.AccessConfigProperty
class CfnCluster_AccessConfigPropertyDef(BaseStruct):
    authentication_mode: typing.Optional[str] = pydantic.Field(None, description='The desired authentication mode for the cluster. If you create a cluster by using the EKS API, AWS SDKs, or AWS CloudFormation , the default is ``CONFIG_MAP`` . If you create the cluster by using the AWS Management Console , the default value is ``API_AND_CONFIG_MAP`` .\n')
    bootstrap_cluster_creator_admin_permissions: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether or not the cluster creator IAM principal was set as a cluster admin access entry during cluster creation time. The default value is ``true`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-cluster-accessconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    access_config_property = eks.CfnCluster.AccessConfigProperty(\n        authentication_mode="authenticationMode",\n        bootstrap_cluster_creator_admin_permissions=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['authentication_mode', 'bootstrap_cluster_creator_admin_permissions']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnCluster.AccessConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnCluster.ClusterLoggingProperty
class CfnCluster_ClusterLoggingPropertyDef(BaseStruct):
    enabled_types: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_eks.CfnCluster_LoggingTypeConfigPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The enabled control plane logs for your cluster. All log types are disabled if the array is empty. .. epigraph:: When updating a resource, you must include this ``EnabledTypes`` property if the previous CloudFormation template of the resource had it.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-cluster-clusterlogging.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    cluster_logging_property = eks.CfnCluster.ClusterLoggingProperty(\n        enabled_types=[eks.CfnCluster.LoggingTypeConfigProperty(\n            type="type"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled_types']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnCluster.ClusterLoggingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnCluster.ControlPlanePlacementProperty
class CfnCluster_ControlPlanePlacementPropertyDef(BaseStruct):
    group_name: typing.Optional[str] = pydantic.Field(None, description='The name of the placement group for the Kubernetes control plane instances. This property is only used for a local cluster on an AWS Outpost.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-cluster-controlplaneplacement.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    control_plane_placement_property = eks.CfnCluster.ControlPlanePlacementProperty(\n        group_name="groupName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['group_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnCluster.ControlPlanePlacementProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnCluster.EncryptionConfigProperty
class CfnCluster_EncryptionConfigPropertyDef(BaseStruct):
    provider: typing.Union[models.UnsupportedResource, models.aws_eks.CfnCluster_ProviderPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The encryption provider for the cluster.\n')
    resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Specifies the resources to be encrypted. The only supported value is ``secrets`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-cluster-encryptionconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    encryption_config_property = eks.CfnCluster.EncryptionConfigProperty(\n        provider=eks.CfnCluster.ProviderProperty(\n            key_arn="keyArn"\n        ),\n        resources=["resources"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['provider', 'resources']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnCluster.EncryptionConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnCluster.KubernetesNetworkConfigProperty
class CfnCluster_KubernetesNetworkConfigPropertyDef(BaseStruct):
    ip_family: typing.Optional[str] = pydantic.Field(None, description="Specify which IP family is used to assign Kubernetes pod and service IP addresses. If you don't specify a value, ``ipv4`` is used by default. You can only specify an IP family when you create a cluster and can't change this value once the cluster is created. If you specify ``ipv6`` , the VPC and subnets that you specify for cluster creation must have both ``IPv4`` and ``IPv6`` CIDR blocks assigned to them. You can't specify ``ipv6`` for clusters in China Regions. You can only specify ``ipv6`` for ``1.21`` and later clusters that use version ``1.10.1`` or later of the Amazon VPC CNI add-on. If you specify ``ipv6`` , then ensure that your VPC meets the requirements listed in the considerations listed in `Assigning IPv6 addresses to pods and services <https://docs.aws.amazon.com/eks/latest/userguide/cni-ipv6.html>`_ in the Amazon EKS User Guide. Kubernetes assigns services ``IPv6`` addresses from the unique local address range ``(fc00::/7)`` . You can't specify a custom ``IPv6`` CIDR block. Pod addresses are assigned from the subnet's ``IPv6`` CIDR.\n")
    service_ipv4_cidr: typing.Optional[str] = pydantic.Field(None, description="Don't specify a value if you select ``ipv6`` for *ipFamily* . The CIDR block to assign Kubernetes service IP addresses from. If you don't specify a block, Kubernetes assigns addresses from either the ``10.100.0.0/16`` or ``172.20.0.0/16`` CIDR blocks. We recommend that you specify a block that does not overlap with resources in other networks that are peered or connected to your VPC. The block must meet the following requirements: - Within one of the following private IP address blocks: ``10.0.0.0/8`` , ``172.16.0.0/12`` , or ``192.168.0.0/16`` . - Doesn't overlap with any CIDR block assigned to the VPC that you selected for VPC. - Between ``/24`` and ``/12`` . .. epigraph:: You can only specify a custom CIDR block when you create a cluster. You can't change this value after the cluster is created.\n")
    service_ipv6_cidr: typing.Optional[str] = pydantic.Field(None, description='The CIDR block that Kubernetes pod and service IP addresses are assigned from if you created a 1.21 or later cluster with version 1.10.1 or later of the Amazon VPC CNI add-on and specified ``ipv6`` for *ipFamily* when you created the cluster. Kubernetes assigns service addresses from the unique local address range ( ``fc00::/7`` ) because you can\'t specify a custom IPv6 CIDR block when you create the cluster.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-cluster-kubernetesnetworkconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    kubernetes_network_config_property = eks.CfnCluster.KubernetesNetworkConfigProperty(\n        ip_family="ipFamily",\n        service_ipv4_cidr="serviceIpv4Cidr",\n        service_ipv6_cidr="serviceIpv6Cidr"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ip_family', 'service_ipv4_cidr', 'service_ipv6_cidr']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnCluster.KubernetesNetworkConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnCluster.LoggingProperty
class CfnCluster_LoggingPropertyDef(BaseStruct):
    cluster_logging: typing.Union[models.UnsupportedResource, models.aws_eks.CfnCluster_ClusterLoggingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The cluster control plane logging configuration for your cluster.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-cluster-logging.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    logging_property = eks.CfnCluster.LoggingProperty(\n        cluster_logging=eks.CfnCluster.ClusterLoggingProperty(\n            enabled_types=[eks.CfnCluster.LoggingTypeConfigProperty(\n                type="type"\n            )]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cluster_logging']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnCluster.LoggingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnCluster.LoggingTypeConfigProperty
class CfnCluster_LoggingTypeConfigPropertyDef(BaseStruct):
    type: typing.Optional[str] = pydantic.Field(None, description='The name of the log type.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-cluster-loggingtypeconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    logging_type_config_property = eks.CfnCluster.LoggingTypeConfigProperty(\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnCluster.LoggingTypeConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnCluster.OutpostConfigProperty
class CfnCluster_OutpostConfigPropertyDef(BaseStruct):
    control_plane_instance_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The Amazon EC2 instance type that you want to use for your local Amazon EKS cluster on Outposts. Choose an instance type based on the number of nodes that your cluster will have. For more information, see `Capacity considerations <https://docs.aws.amazon.com/eks/latest/userguide/eks-outposts-capacity-considerations.html>`_ in the *Amazon EKS User Guide* . The instance type that you specify is used for all Kubernetes control plane instances. The instance type can't be changed after cluster creation. The control plane is not automatically scaled by Amazon EKS.\n")
    outpost_arns: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the Outpost that you want to use for your local Amazon EKS cluster on Outposts. Only a single Outpost ARN is supported.\n')
    control_plane_placement: typing.Union[models.UnsupportedResource, models.aws_eks.CfnCluster_ControlPlanePlacementPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object representing the placement configuration for all the control plane instances of your local Amazon EKS cluster on an AWS Outpost. For more information, see `Capacity considerations <https://docs.aws.amazon.com/eks/latest/userguide/eks-outposts-capacity-considerations.html>`_ in the *Amazon EKS User Guide* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-cluster-outpostconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    outpost_config_property = eks.CfnCluster.OutpostConfigProperty(\n        control_plane_instance_type="controlPlaneInstanceType",\n        outpost_arns=["outpostArns"],\n\n        # the properties below are optional\n        control_plane_placement=eks.CfnCluster.ControlPlanePlacementProperty(\n            group_name="groupName"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['control_plane_instance_type', 'outpost_arns', 'control_plane_placement']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnCluster.OutpostConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnCluster.ProviderProperty
class CfnCluster_ProviderPropertyDef(BaseStruct):
    key_arn: typing.Optional[str] = pydantic.Field(None, description='Amazon Resource Name (ARN) or alias of the KMS key. The KMS key must be symmetric and created in the same AWS Region as the cluster. If the KMS key was created in a different account, the `IAM principal <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_terms-and-concepts.html>`_ must have access to the KMS key. For more information, see `Allowing users in other accounts to use a KMS key <https://docs.aws.amazon.com/kms/latest/developerguide/key-policy-modifying-external-accounts.html>`_ in the *AWS Key Management Service Developer Guide* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-cluster-provider.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    provider_property = eks.CfnCluster.ProviderProperty(\n        key_arn="keyArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnCluster.ProviderProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnCluster.ResourcesVpcConfigProperty
class CfnCluster_ResourcesVpcConfigPropertyDef(BaseStruct):
    subnet_ids: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specify subnets for your Amazon EKS nodes. Amazon EKS creates cross-account elastic network interfaces in these subnets to allow communication between your nodes and the Kubernetes control plane.\n')
    endpoint_private_access: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="Set this value to ``true`` to enable private access for your cluster's Kubernetes API server endpoint. If you enable private access, Kubernetes API requests from within your cluster's VPC use the private VPC endpoint. The default value for this parameter is ``false`` , which disables private access for your Kubernetes API server. If you disable private access and you have nodes or AWS Fargate pods in the cluster, then ensure that ``publicAccessCidrs`` includes the necessary CIDR blocks for communication with the nodes or Fargate pods. For more information, see `Amazon EKS cluster endpoint access control <https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html>`_ in the **Amazon EKS User Guide** .\n")
    endpoint_public_access: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="Set this value to ``false`` to disable public access to your cluster's Kubernetes API server endpoint. If you disable public access, your cluster's Kubernetes API server can only receive requests from within the cluster VPC. The default value for this parameter is ``true`` , which enables public access for your Kubernetes API server. For more information, see `Amazon EKS cluster endpoint access control <https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html>`_ in the **Amazon EKS User Guide** .\n")
    public_access_cidrs: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The CIDR blocks that are allowed access to your cluster's public Kubernetes API server endpoint. Communication to the endpoint from addresses outside of the CIDR blocks that you specify is denied. The default value is ``0.0.0.0/0`` . If you've disabled private endpoint access, make sure that you specify the necessary CIDR blocks for every node and AWS Fargate ``Pod`` in the cluster. For more information, see `Amazon EKS cluster endpoint access control <https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html>`_ in the **Amazon EKS User Guide** .\n")
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Specify one or more security groups for the cross-account elastic network interfaces that Amazon EKS creates to use that allow communication between your nodes and the Kubernetes control plane. If you don\'t specify any security groups, then familiarize yourself with the difference between Amazon EKS defaults for clusters deployed with Kubernetes. For more information, see `Amazon EKS security group considerations <https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html>`_ in the **Amazon EKS User Guide** .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-cluster-resourcesvpcconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    resources_vpc_config_property = eks.CfnCluster.ResourcesVpcConfigProperty(\n        subnet_ids=["subnetIds"],\n\n        # the properties below are optional\n        endpoint_private_access=False,\n        endpoint_public_access=False,\n        public_access_cidrs=["publicAccessCidrs"],\n        security_group_ids=["securityGroupIds"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['subnet_ids', 'endpoint_private_access', 'endpoint_public_access', 'public_access_cidrs', 'security_group_ids']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnCluster.ResourcesVpcConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnFargateProfile.LabelProperty
class CfnFargateProfile_LabelPropertyDef(BaseStruct):
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Enter a key.\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Enter a value.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-fargateprofile-label.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    label_property = eks.CfnFargateProfile.LabelProperty(\n        key="key",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnFargateProfile.LabelProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnFargateProfile.SelectorProperty
class CfnFargateProfile_SelectorPropertyDef(BaseStruct):
    namespace: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Kubernetes ``namespace`` that the selector should match.\n')
    labels: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_eks.CfnFargateProfile_LabelPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The Kubernetes labels that the selector should match. A pod must contain all of the labels that are specified in the selector for it to be considered a match.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-fargateprofile-selector.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    selector_property = eks.CfnFargateProfile.SelectorProperty(\n        namespace="namespace",\n\n        # the properties below are optional\n        labels=[eks.CfnFargateProfile.LabelProperty(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['namespace', 'labels']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnFargateProfile.SelectorProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnIdentityProviderConfig.OidcIdentityProviderConfigProperty
class CfnIdentityProviderConfig_OidcIdentityProviderConfigPropertyDef(BaseStruct):
    client_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='This is also known as *audience* . The ID of the client application that makes authentication requests to the OIDC identity provider.\n')
    issuer_url: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The URL of the OIDC identity provider that allows the API server to discover public signing keys for verifying tokens.\n')
    groups_claim: typing.Optional[str] = pydantic.Field(None, description='The JSON web token (JWT) claim that the provider uses to return your groups.\n')
    groups_prefix: typing.Optional[str] = pydantic.Field(None, description="The prefix that is prepended to group claims to prevent clashes with existing names (such as ``system:`` groups). For example, the value ``oidc:`` creates group names like ``oidc:engineering`` and ``oidc:infra`` . The prefix can't contain ``system:``\n")
    required_claims: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_eks.CfnIdentityProviderConfig_RequiredClaimPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The key-value pairs that describe required claims in the identity token. If set, each claim is verified to be present in the token with a matching value.\n')
    username_claim: typing.Optional[str] = pydantic.Field(None, description='The JSON Web token (JWT) claim that is used as the username.\n')
    username_prefix: typing.Optional[str] = pydantic.Field(None, description='The prefix that is prepended to username claims to prevent clashes with existing names. The prefix can\'t contain ``system:``\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-identityproviderconfig-oidcidentityproviderconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    oidc_identity_provider_config_property = eks.CfnIdentityProviderConfig.OidcIdentityProviderConfigProperty(\n        client_id="clientId",\n        issuer_url="issuerUrl",\n\n        # the properties below are optional\n        groups_claim="groupsClaim",\n        groups_prefix="groupsPrefix",\n        required_claims=[eks.CfnIdentityProviderConfig.RequiredClaimProperty(\n            key="key",\n            value="value"\n        )],\n        username_claim="usernameClaim",\n        username_prefix="usernamePrefix"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['client_id', 'issuer_url', 'groups_claim', 'groups_prefix', 'required_claims', 'username_claim', 'username_prefix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnIdentityProviderConfig.OidcIdentityProviderConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnIdentityProviderConfig.RequiredClaimProperty
class CfnIdentityProviderConfig_RequiredClaimPropertyDef(BaseStruct):
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The key to match from the token.\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The value for the key from the token.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-identityproviderconfig-requiredclaim.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    required_claim_property = eks.CfnIdentityProviderConfig.RequiredClaimProperty(\n        key="key",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnIdentityProviderConfig.RequiredClaimProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnNodegroup.LaunchTemplateSpecificationProperty
class CfnNodegroup_LaunchTemplateSpecificationPropertyDef(BaseStruct):
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the launch template. You must specify either the launch template name or the launch template ID in the request, but not both.\n')
    version: typing.Optional[str] = pydantic.Field(None, description='The version number of the launch template to use. If no version is specified, then the template\'s default version is used.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-nodegroup-launchtemplatespecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    launch_template_specification_property = eks.CfnNodegroup.LaunchTemplateSpecificationProperty(\n        id="id",\n        name="name",\n        version="version"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnNodegroup.LaunchTemplateSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnNodegroup.RemoteAccessProperty
class CfnNodegroup_RemoteAccessPropertyDef(BaseStruct):
    ec2_ssh_key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon EC2 SSH key name that provides access for SSH communication with the nodes in the managed node group. For more information, see `Amazon EC2 key pairs and Linux instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html>`_ in the *Amazon Elastic Compute Cloud User Guide for Linux Instances* . For Windows, an Amazon EC2 SSH key is used to obtain the RDP password. For more information, see `Amazon EC2 key pairs and Windows instances <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-key-pairs.html>`_ in the *Amazon Elastic Compute Cloud User Guide for Windows Instances* .\n')
    source_security_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The security group IDs that are allowed SSH access (port 22) to the nodes. For Windows, the port is 3389. If you specify an Amazon EC2 SSH key but don\'t specify a source security group when you create a managed node group, then the port on the nodes is opened to the internet ( ``0.0.0.0/0`` ). For more information, see `Security Groups for Your VPC <https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html>`_ in the *Amazon Virtual Private Cloud User Guide* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-nodegroup-remoteaccess.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    remote_access_property = eks.CfnNodegroup.RemoteAccessProperty(\n        ec2_ssh_key="ec2SshKey",\n\n        # the properties below are optional\n        source_security_groups=["sourceSecurityGroups"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ec2_ssh_key', 'source_security_groups']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnNodegroup.RemoteAccessProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnNodegroup.ScalingConfigProperty
class CfnNodegroup_ScalingConfigPropertyDef(BaseStruct):
    desired_size: typing.Union[int, float, None] = pydantic.Field(None, description="The current number of nodes that the managed node group should maintain. .. epigraph:: If you use the Kubernetes `Cluster Autoscaler <https://docs.aws.amazon.com/https://github.com/kubernetes/autoscaler#kubernetes-autoscaler>`_ , you shouldn't change the ``desiredSize`` value directly, as this can cause the Cluster Autoscaler to suddenly scale up or scale down. Whenever this parameter changes, the number of worker nodes in the node group is updated to the specified size. If this parameter is given a value that is smaller than the current number of running worker nodes, the necessary number of worker nodes are terminated to match the given value. When using CloudFormation, no action occurs if you remove this parameter from your CFN template. This parameter can be different from ``minSize`` in some cases, such as when starting with extra hosts for testing. This parameter can also be different when you want to start with an estimated number of needed hosts, but let the Cluster Autoscaler reduce the number if there are too many. When the Cluster Autoscaler is used, the ``desiredSize`` parameter is altered by the Cluster Autoscaler (but can be out-of-date for short periods of time). the Cluster Autoscaler doesn't scale a managed node group lower than ``minSize`` or higher than ``maxSize`` .\n")
    max_size: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of nodes that the managed node group can scale out to. For information about the maximum number that you can specify, see `Amazon EKS service quotas <https://docs.aws.amazon.com/eks/latest/userguide/service-quotas.html>`_ in the *Amazon EKS User Guide* .\n')
    min_size: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of nodes that the managed node group can scale in to.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-nodegroup-scalingconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    scaling_config_property = eks.CfnNodegroup.ScalingConfigProperty(\n        desired_size=123,\n        max_size=123,\n        min_size=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['desired_size', 'max_size', 'min_size']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnNodegroup.ScalingConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnNodegroup.TaintProperty
class CfnNodegroup_TaintPropertyDef(BaseStruct):
    effect: typing.Optional[str] = pydantic.Field(None, description='The effect of the taint.\n')
    key: typing.Optional[str] = pydantic.Field(None, description='The key of the taint.\n')
    value: typing.Optional[str] = pydantic.Field(None, description='The value of the taint.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-nodegroup-taint.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    taint_property = eks.CfnNodegroup.TaintProperty(\n        effect="effect",\n        key="key",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['effect', 'key', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnNodegroup.TaintProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnNodegroup.UpdateConfigProperty
class CfnNodegroup_UpdateConfigPropertyDef(BaseStruct):
    max_unavailable: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of nodes unavailable at once during a version update. Nodes are updated in parallel. This value or ``maxUnavailablePercentage`` is required to have a value.The maximum number is 100.\n')
    max_unavailable_percentage: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum percentage of nodes unavailable during a version update. This percentage of nodes are updated in parallel, up to 100 nodes at once. This value or ``maxUnavailable`` is required to have a value.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-nodegroup-updateconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    update_config_property = eks.CfnNodegroup.UpdateConfigProperty(\n        max_unavailable=123,\n        max_unavailable_percentage=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max_unavailable', 'max_unavailable_percentage']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnNodegroup.UpdateConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.ClusterAttributes
class ClusterAttributesDef(BaseStruct):
    cluster_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The physical name of the Cluster.\n')
    awscli_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description='An AWS Lambda layer that contains the ``aws`` CLI. The handler expects the layer to include the following executables:: /opt/awscli/aws Default: - a default layer with the AWS CLI 1.x\n')
    cluster_certificate_authority_data: typing.Optional[str] = pydantic.Field(None, description='The certificate-authority-data for your cluster. Default: - if not specified ``cluster.clusterCertificateAuthorityData`` will throw an error\n')
    cluster_encryption_config_key_arn: typing.Optional[str] = pydantic.Field(None, description='Amazon Resource Name (ARN) or alias of the customer master key (CMK). Default: - if not specified ``cluster.clusterEncryptionConfigKeyArn`` will throw an error\n')
    cluster_endpoint: typing.Optional[str] = pydantic.Field(None, description='The API Server endpoint URL. Default: - if not specified ``cluster.clusterEndpoint`` will throw an error.\n')
    cluster_handler_security_group_id: typing.Optional[str] = pydantic.Field(None, description="A security group id to associate with the Cluster Handler's Lambdas. The Cluster Handler's Lambdas are responsible for calling AWS's EKS API. Default: - No security group.\n")
    cluster_security_group_id: typing.Optional[str] = pydantic.Field(None, description='The cluster security group that was created by Amazon EKS for the cluster. Default: - if not specified ``cluster.clusterSecurityGroupId`` will throw an error\n')
    ip_family: typing.Optional[aws_cdk.aws_eks.IpFamily] = pydantic.Field(None, description='Specify which IP family is used to assign Kubernetes pod and service IP addresses. Default: - IpFamily.IP_V4\n')
    kubectl_environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Environment variables to use when running ``kubectl`` against this cluster. Default: - no additional variables\n')
    kubectl_lambda_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role that can perform kubectl operations against this cluster. The role should be mapped to the ``system:masters`` Kubernetes RBAC role. This role is directly passed to the lambda handler that sends Kube Ctl commands to the cluster. Default: - if not specified, the default role created by a lambda function will be used.\n')
    kubectl_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description="An AWS Lambda Layer which includes ``kubectl`` and Helm. This layer is used by the kubectl handler to apply manifests and install helm charts. You must pick an appropriate releases of one of the ``@aws-cdk/layer-kubectl-vXX`` packages, that works with the version of Kubernetes you have chosen. If you don't supply this value ``kubectl`` 1.20 will be used, but that version is most likely too old. The handler expects the layer to include the following executables:: /opt/helm/helm /opt/kubectl/kubectl Default: - a default layer with Kubectl 1.20 and helm 3.8.\n")
    kubectl_memory: typing.Optional[models.SizeDef] = pydantic.Field(None, description="Amount of memory to allocate to the provider's lambda function. Default: Size.gibibytes(1)\n")
    kubectl_private_subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Subnets to host the ``kubectl`` compute resources. If not specified, the k8s endpoint is expected to be accessible publicly. Default: - k8s endpoint is expected to be accessible publicly\n')
    kubectl_provider: typing.Optional[typing.Union[models.aws_eks.KubectlProviderDef]] = pydantic.Field(None, description='KubectlProvider for issuing kubectl commands. Default: - Default CDK provider\n')
    kubectl_role_arn: typing.Optional[str] = pydantic.Field(None, description='An IAM role with cluster administrator and "system:masters" permissions. Default: - if not specified, it not be possible to issue ``kubectl`` commands against an imported cluster.\n')
    kubectl_security_group_id: typing.Optional[str] = pydantic.Field(None, description='A security group to use for ``kubectl`` execution. If not specified, the k8s endpoint is expected to be accessible publicly. Default: - k8s endpoint is expected to be accessible publicly\n')
    on_event_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description='An AWS Lambda Layer which includes the NPM dependency ``proxy-agent``. This layer is used by the onEvent handler to route AWS SDK requests through a proxy. The handler expects the layer to include the following node_modules: proxy-agent Default: - a layer bundled with this module.\n')
    open_id_connect_provider: typing.Optional[typing.Union[models.aws_eks.OpenIdConnectProviderDef, models.aws_iam.OpenIdConnectProviderDef]] = pydantic.Field(None, description='An Open ID Connect provider for this cluster that can be used to configure service accounts. You can either import an existing provider using ``iam.OpenIdConnectProvider.fromProviderArn``, or create a new provider using ``new eks.OpenIdConnectProvider`` Default: - if not specified ``cluster.openIdConnectProvider`` and ``cluster.addServiceAccount`` will throw an error.\n')
    prune: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether Kubernetes resources added through ``addManifest()`` can be automatically pruned. When this is enabled (default), prune labels will be allocated and injected to each resource. These labels will then be used when issuing the ``kubectl apply`` operation with the ``--prune`` switch. Default: true\n')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Additional security groups associated with this cluster. Default: - if not specified, no additional security groups will be considered in ``cluster.connections``.\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC in which this Cluster was created. Default: - if not specified ``cluster.vpc`` will throw an error\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: eks.Cluster\n    # asg: autoscaling.AutoScalingGroup\n\n    imported_cluster = eks.Cluster.from_cluster_attributes(self, "ImportedCluster",\n        cluster_name=cluster.cluster_name,\n        cluster_security_group_id=cluster.cluster_security_group_id\n    )\n\n    imported_cluster.connect_auto_scaling_group_capacity(asg)\n')
    _init_params: typing.ClassVar[list[str]] = ['cluster_name', 'awscli_layer', 'cluster_certificate_authority_data', 'cluster_encryption_config_key_arn', 'cluster_endpoint', 'cluster_handler_security_group_id', 'cluster_security_group_id', 'ip_family', 'kubectl_environment', 'kubectl_lambda_role', 'kubectl_layer', 'kubectl_memory', 'kubectl_private_subnet_ids', 'kubectl_provider', 'kubectl_role_arn', 'kubectl_security_group_id', 'on_event_layer', 'open_id_connect_provider', 'prune', 'security_group_ids', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.ClusterAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.ClusterOptions
class ClusterOptionsDef(BaseStruct):
    version: typing.Union[models.aws_eks.KubernetesVersionDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Kubernetes version to run in the cluster.\n')
    cluster_name: typing.Optional[str] = pydantic.Field(None, description='Name for the cluster. Default: - Automatically generated name\n')
    output_cluster_name: typing.Optional[bool] = pydantic.Field(None, description='Determines whether a CloudFormation output with the name of the cluster will be synthesized. Default: false\n')
    output_config_command: typing.Optional[bool] = pydantic.Field(None, description='Determines whether a CloudFormation output with the ``aws eks update-kubeconfig`` command will be synthesized. This command will include the cluster name and, if applicable, the ARN of the masters IAM role. Default: true\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='Role that provides permissions for the Kubernetes control plane to make calls to AWS API operations on your behalf. Default: - A role is automatically created for you\n')
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='Security Group to use for Control Plane ENIs. Default: - A security group is automatically created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC in which to create the Cluster. Default: - a VPC with default configuration will be created and can be accessed through ``cluster.vpc``.\n')
    vpc_subnets: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Where to place EKS Control Plane ENIs. For example, to only select private subnets, supply the following: ``vpcSubnets: [{ subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS }]`` Default: - All public and private subnets\n')
    alb_controller: typing.Union[models.aws_eks.AlbControllerOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Install the AWS Load Balancer Controller onto the cluster. Default: - The controller is not installed.\n')
    authentication_mode: typing.Optional[aws_cdk.aws_eks.AuthenticationMode] = pydantic.Field(None, description='The desired authentication mode for the cluster. Default: AuthenticationMode.CONFIG_MAP\n')
    awscli_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description='An AWS Lambda layer that contains the ``aws`` CLI. The handler expects the layer to include the following executables:: /opt/awscli/aws Default: - a default layer with the AWS CLI 1.x\n')
    cluster_handler_environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom environment variables when interacting with the EKS endpoint to manage the cluster lifecycle. Default: - No environment variables.\n')
    cluster_handler_security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description="A security group to associate with the Cluster Handler's Lambdas. The Cluster Handler's Lambdas are responsible for calling AWS's EKS API. Requires ``placeClusterHandlerInVpc`` to be set to true. Default: - No security group.\n")
    cluster_logging: typing.Optional[typing.Sequence[aws_cdk.aws_eks.ClusterLoggingTypes]] = pydantic.Field(None, description='The cluster log types which you want to enable. Default: - none\n')
    core_dns_compute_type: typing.Optional[aws_cdk.aws_eks.CoreDnsComputeType] = pydantic.Field(None, description='Controls the "eks.amazonaws.com/compute-type" annotation in the CoreDNS configuration on your cluster to determine which compute type to use for CoreDNS. Default: CoreDnsComputeType.EC2 (for ``FargateCluster`` the default is FARGATE)\n')
    endpoint_access: typing.Optional[models.aws_eks.EndpointAccessDef] = pydantic.Field(None, description='Configure access to the Kubernetes API server endpoint.. Default: EndpointAccess.PUBLIC_AND_PRIVATE\n')
    ip_family: typing.Optional[aws_cdk.aws_eks.IpFamily] = pydantic.Field(None, description='Specify which IP family is used to assign Kubernetes pod and service IP addresses. Default: - IpFamily.IP_V4\n')
    kubectl_environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Environment variables for the kubectl execution. Only relevant for kubectl enabled clusters. Default: - No environment variables.\n')
    kubectl_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description="An AWS Lambda Layer which includes ``kubectl`` and Helm. This layer is used by the kubectl handler to apply manifests and install helm charts. You must pick an appropriate releases of one of the ``@aws-cdk/layer-kubectl-vXX`` packages, that works with the version of Kubernetes you have chosen. If you don't supply this value ``kubectl`` 1.20 will be used, but that version is most likely too old. The handler expects the layer to include the following executables:: /opt/helm/helm /opt/kubectl/kubectl Default: - a default layer with Kubectl 1.20.\n")
    kubectl_memory: typing.Optional[models.SizeDef] = pydantic.Field(None, description="Amount of memory to allocate to the provider's lambda function. Default: Size.gibibytes(1)\n")
    masters_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role that will be added to the ``system:masters`` Kubernetes RBAC group. Default: - no masters role.\n')
    on_event_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description='An AWS Lambda Layer which includes the NPM dependency ``proxy-agent``. This layer is used by the onEvent handler to route AWS SDK requests through a proxy. By default, the provider will use the layer included in the "aws-lambda-layer-node-proxy-agent" SAR application which is available in all commercial regions. To deploy the layer locally define it in your app as follows:: const layer = new lambda.LayerVersion(this, \'proxy-agent-layer\', { code: lambda.Code.fromAsset(`${__dirname}/layer.zip`), compatibleRuntimes: [lambda.Runtime.NODEJS_LATEST], }); Default: - a layer bundled with this module.\n')
    output_masters_role_arn: typing.Optional[bool] = pydantic.Field(None, description='Determines whether a CloudFormation output with the ARN of the "masters" IAM role will be synthesized (if ``mastersRole`` is specified). Default: false\n')
    place_cluster_handler_in_vpc: typing.Optional[bool] = pydantic.Field(None, description='If set to true, the cluster handler functions will be placed in the private subnets of the cluster vpc, subject to the ``vpcSubnets`` selection strategy. Default: false\n')
    prune: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether Kubernetes resources added through ``addManifest()`` can be automatically pruned. When this is enabled (default), prune labels will be allocated and injected to each resource. These labels will then be used when issuing the ``kubectl apply`` operation with the ``--prune`` switch. Default: true\n')
    secrets_encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='KMS secret for envelope encryption for Kubernetes secrets. Default: - By default, Kubernetes stores all secret object data within etcd and all etcd volumes used by Amazon EKS are encrypted at the disk-level using AWS-Managed encryption keys.\n')
    service_ipv4_cidr: typing.Optional[str] = pydantic.Field(None, description='The CIDR block to assign Kubernetes service IP addresses from. Default: - Kubernetes assigns addresses from either the 10.100.0.0/16 or 172.20.0.0/16 CIDR blocks\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_ec2 as ec2\n    from aws_cdk import aws_eks as eks\n    from aws_cdk import aws_iam as iam\n    from aws_cdk import aws_kms as kms\n    from aws_cdk import aws_lambda as lambda_\n\n    # alb_controller_version: eks.AlbControllerVersion\n    # endpoint_access: eks.EndpointAccess\n    # key: kms.Key\n    # kubernetes_version: eks.KubernetesVersion\n    # layer_version: lambda.LayerVersion\n    # policy: Any\n    # role: iam.Role\n    # security_group: ec2.SecurityGroup\n    # size: cdk.Size\n    # subnet: ec2.Subnet\n    # subnet_filter: ec2.SubnetFilter\n    # vpc: ec2.Vpc\n\n    cluster_options = eks.ClusterOptions(\n        version=kubernetes_version,\n\n        # the properties below are optional\n        alb_controller=eks.AlbControllerOptions(\n            version=alb_controller_version,\n\n            # the properties below are optional\n            policy=policy,\n            repository="repository"\n        ),\n        authentication_mode=eks.AuthenticationMode.CONFIG_MAP,\n        awscli_layer=layer_version,\n        cluster_handler_environment={\n            "cluster_handler_environment_key": "clusterHandlerEnvironment"\n        },\n        cluster_handler_security_group=security_group,\n        cluster_logging=[eks.ClusterLoggingTypes.API],\n        cluster_name="clusterName",\n        core_dns_compute_type=eks.CoreDnsComputeType.EC2,\n        endpoint_access=endpoint_access,\n        ip_family=eks.IpFamily.IP_V4,\n        kubectl_environment={\n            "kubectl_environment_key": "kubectlEnvironment"\n        },\n        kubectl_layer=layer_version,\n        kubectl_memory=size,\n        masters_role=role,\n        on_event_layer=layer_version,\n        output_cluster_name=False,\n        output_config_command=False,\n        output_masters_role_arn=False,\n        place_cluster_handler_in_vpc=False,\n        prune=False,\n        role=role,\n        secrets_encryption_key=key,\n        security_group=security_group,\n        service_ipv4_cidr="serviceIpv4Cidr",\n        vpc=vpc,\n        vpc_subnets=[ec2.SubnetSelection(\n            availability_zones=["availabilityZones"],\n            one_per_az=False,\n            subnet_filters=[subnet_filter],\n            subnet_group_name="subnetGroupName",\n            subnets=[subnet],\n            subnet_type=ec2.SubnetType.PRIVATE_ISOLATED\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['version', 'cluster_name', 'output_cluster_name', 'output_config_command', 'role', 'security_group', 'vpc', 'vpc_subnets', 'alb_controller', 'authentication_mode', 'awscli_layer', 'cluster_handler_environment', 'cluster_handler_security_group', 'cluster_logging', 'core_dns_compute_type', 'endpoint_access', 'ip_family', 'kubectl_environment', 'kubectl_layer', 'kubectl_memory', 'masters_role', 'on_event_layer', 'output_masters_role_arn', 'place_cluster_handler_in_vpc', 'prune', 'secrets_encryption_key', 'service_ipv4_cidr']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.ClusterOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.ClusterOptionsDefConfig] = pydantic.Field(None)


class ClusterOptionsDefConfig(pydantic.BaseModel):
    version_config: typing.Optional[models.aws_eks.KubernetesVersionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_eks.ClusterProps
class ClusterPropsDef(BaseStruct):
    version: typing.Union[models.aws_eks.KubernetesVersionDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Kubernetes version to run in the cluster.\n')
    cluster_name: typing.Optional[str] = pydantic.Field(None, description='Name for the cluster. Default: - Automatically generated name\n')
    output_cluster_name: typing.Optional[bool] = pydantic.Field(None, description='Determines whether a CloudFormation output with the name of the cluster will be synthesized. Default: false\n')
    output_config_command: typing.Optional[bool] = pydantic.Field(None, description='Determines whether a CloudFormation output with the ``aws eks update-kubeconfig`` command will be synthesized. This command will include the cluster name and, if applicable, the ARN of the masters IAM role. Default: true\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='Role that provides permissions for the Kubernetes control plane to make calls to AWS API operations on your behalf. Default: - A role is automatically created for you\n')
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='Security Group to use for Control Plane ENIs. Default: - A security group is automatically created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC in which to create the Cluster. Default: - a VPC with default configuration will be created and can be accessed through ``cluster.vpc``.\n')
    vpc_subnets: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Where to place EKS Control Plane ENIs. For example, to only select private subnets, supply the following: ``vpcSubnets: [{ subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS }]`` Default: - All public and private subnets\n')
    alb_controller: typing.Union[models.aws_eks.AlbControllerOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Install the AWS Load Balancer Controller onto the cluster. Default: - The controller is not installed.\n')
    authentication_mode: typing.Optional[aws_cdk.aws_eks.AuthenticationMode] = pydantic.Field(None, description='The desired authentication mode for the cluster. Default: AuthenticationMode.CONFIG_MAP\n')
    awscli_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description='An AWS Lambda layer that contains the ``aws`` CLI. The handler expects the layer to include the following executables:: /opt/awscli/aws Default: - a default layer with the AWS CLI 1.x\n')
    cluster_handler_environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom environment variables when interacting with the EKS endpoint to manage the cluster lifecycle. Default: - No environment variables.\n')
    cluster_handler_security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description="A security group to associate with the Cluster Handler's Lambdas. The Cluster Handler's Lambdas are responsible for calling AWS's EKS API. Requires ``placeClusterHandlerInVpc`` to be set to true. Default: - No security group.\n")
    cluster_logging: typing.Optional[typing.Sequence[aws_cdk.aws_eks.ClusterLoggingTypes]] = pydantic.Field(None, description='The cluster log types which you want to enable. Default: - none\n')
    core_dns_compute_type: typing.Optional[aws_cdk.aws_eks.CoreDnsComputeType] = pydantic.Field(None, description='Controls the "eks.amazonaws.com/compute-type" annotation in the CoreDNS configuration on your cluster to determine which compute type to use for CoreDNS. Default: CoreDnsComputeType.EC2 (for ``FargateCluster`` the default is FARGATE)\n')
    endpoint_access: typing.Optional[models.aws_eks.EndpointAccessDef] = pydantic.Field(None, description='Configure access to the Kubernetes API server endpoint.. Default: EndpointAccess.PUBLIC_AND_PRIVATE\n')
    ip_family: typing.Optional[aws_cdk.aws_eks.IpFamily] = pydantic.Field(None, description='Specify which IP family is used to assign Kubernetes pod and service IP addresses. Default: - IpFamily.IP_V4\n')
    kubectl_environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Environment variables for the kubectl execution. Only relevant for kubectl enabled clusters. Default: - No environment variables.\n')
    kubectl_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description="An AWS Lambda Layer which includes ``kubectl`` and Helm. This layer is used by the kubectl handler to apply manifests and install helm charts. You must pick an appropriate releases of one of the ``@aws-cdk/layer-kubectl-vXX`` packages, that works with the version of Kubernetes you have chosen. If you don't supply this value ``kubectl`` 1.20 will be used, but that version is most likely too old. The handler expects the layer to include the following executables:: /opt/helm/helm /opt/kubectl/kubectl Default: - a default layer with Kubectl 1.20.\n")
    kubectl_memory: typing.Optional[models.SizeDef] = pydantic.Field(None, description="Amount of memory to allocate to the provider's lambda function. Default: Size.gibibytes(1)\n")
    masters_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role that will be added to the ``system:masters`` Kubernetes RBAC group. Default: - no masters role.\n')
    on_event_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description='An AWS Lambda Layer which includes the NPM dependency ``proxy-agent``. This layer is used by the onEvent handler to route AWS SDK requests through a proxy. By default, the provider will use the layer included in the "aws-lambda-layer-node-proxy-agent" SAR application which is available in all commercial regions. To deploy the layer locally define it in your app as follows:: const layer = new lambda.LayerVersion(this, \'proxy-agent-layer\', { code: lambda.Code.fromAsset(`${__dirname}/layer.zip`), compatibleRuntimes: [lambda.Runtime.NODEJS_LATEST], }); Default: - a layer bundled with this module.\n')
    output_masters_role_arn: typing.Optional[bool] = pydantic.Field(None, description='Determines whether a CloudFormation output with the ARN of the "masters" IAM role will be synthesized (if ``mastersRole`` is specified). Default: false\n')
    place_cluster_handler_in_vpc: typing.Optional[bool] = pydantic.Field(None, description='If set to true, the cluster handler functions will be placed in the private subnets of the cluster vpc, subject to the ``vpcSubnets`` selection strategy. Default: false\n')
    prune: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether Kubernetes resources added through ``addManifest()`` can be automatically pruned. When this is enabled (default), prune labels will be allocated and injected to each resource. These labels will then be used when issuing the ``kubectl apply`` operation with the ``--prune`` switch. Default: true\n')
    secrets_encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='KMS secret for envelope encryption for Kubernetes secrets. Default: - By default, Kubernetes stores all secret object data within etcd and all etcd volumes used by Amazon EKS are encrypted at the disk-level using AWS-Managed encryption keys.\n')
    service_ipv4_cidr: typing.Optional[str] = pydantic.Field(None, description='The CIDR block to assign Kubernetes service IP addresses from. Default: - Kubernetes assigns addresses from either the 10.100.0.0/16 or 172.20.0.0/16 CIDR blocks\n')
    bootstrap_cluster_creator_admin_permissions: typing.Optional[bool] = pydantic.Field(None, description='Whether or not IAM principal of the cluster creator was set as a cluster admin access entry during cluster creation time. Changing this value after the cluster has been created will result in the cluster being replaced. Default: true\n')
    default_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='Number of instances to allocate as an initial capacity for this cluster. Instance type can be configured through ``defaultCapacityInstanceType``, which defaults to ``m5.large``. Use ``cluster.addAutoScalingGroupCapacity`` to add additional customized capacity. Set this to ``0`` is you wish to avoid the initial capacity allocation. Default: 2\n')
    default_capacity_instance: typing.Optional[models.aws_ec2.InstanceTypeDef] = pydantic.Field(None, description='The instance type to use for the default capacity. This will only be taken into account if ``defaultCapacity`` is > 0. Default: m5.large\n')
    default_capacity_type: typing.Optional[aws_cdk.aws_eks.DefaultCapacityType] = pydantic.Field(None, description='The default capacity type for the cluster. Default: NODEGROUP\n')
    kubectl_lambda_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The IAM role to pass to the Kubectl Lambda Handler. Default: - Default Lambda IAM Execution Role\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The tags assigned to the EKS cluster. Default: - none\n\n:exampleMetadata: infused\n\nExample::\n\n    # or\n    # vpc: ec2.Vpc\n    eks.Cluster(self, "MyCluster",\n        kubectl_memory=Size.gibibytes(4),\n        version=eks.KubernetesVersion.V1_30\n    )\n    eks.Cluster.from_cluster_attributes(self, "MyCluster",\n        kubectl_memory=Size.gibibytes(4),\n        vpc=vpc,\n        cluster_name="cluster-name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['version', 'cluster_name', 'output_cluster_name', 'output_config_command', 'role', 'security_group', 'vpc', 'vpc_subnets', 'alb_controller', 'authentication_mode', 'awscli_layer', 'cluster_handler_environment', 'cluster_handler_security_group', 'cluster_logging', 'core_dns_compute_type', 'endpoint_access', 'ip_family', 'kubectl_environment', 'kubectl_layer', 'kubectl_memory', 'masters_role', 'on_event_layer', 'output_masters_role_arn', 'place_cluster_handler_in_vpc', 'prune', 'secrets_encryption_key', 'service_ipv4_cidr', 'bootstrap_cluster_creator_admin_permissions', 'default_capacity', 'default_capacity_instance', 'default_capacity_type', 'kubectl_lambda_role', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.ClusterProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.ClusterPropsDefConfig] = pydantic.Field(None)


class ClusterPropsDefConfig(pydantic.BaseModel):
    version_config: typing.Optional[models.aws_eks.KubernetesVersionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_eks.CommonClusterOptions
class CommonClusterOptionsDef(BaseStruct):
    version: typing.Union[models.aws_eks.KubernetesVersionDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Kubernetes version to run in the cluster.\n')
    cluster_name: typing.Optional[str] = pydantic.Field(None, description='Name for the cluster. Default: - Automatically generated name\n')
    output_cluster_name: typing.Optional[bool] = pydantic.Field(None, description='Determines whether a CloudFormation output with the name of the cluster will be synthesized. Default: false\n')
    output_config_command: typing.Optional[bool] = pydantic.Field(None, description='Determines whether a CloudFormation output with the ``aws eks update-kubeconfig`` command will be synthesized. This command will include the cluster name and, if applicable, the ARN of the masters IAM role. Default: true\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='Role that provides permissions for the Kubernetes control plane to make calls to AWS API operations on your behalf. Default: - A role is automatically created for you\n')
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='Security Group to use for Control Plane ENIs. Default: - A security group is automatically created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC in which to create the Cluster. Default: - a VPC with default configuration will be created and can be accessed through ``cluster.vpc``.\n')
    vpc_subnets: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Where to place EKS Control Plane ENIs. For example, to only select private subnets, supply the following: ``vpcSubnets: [{ subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS }]`` Default: - All public and private subnets\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n    from aws_cdk import aws_eks as eks\n    from aws_cdk import aws_iam as iam\n\n    # kubernetes_version: eks.KubernetesVersion\n    # role: iam.Role\n    # security_group: ec2.SecurityGroup\n    # subnet: ec2.Subnet\n    # subnet_filter: ec2.SubnetFilter\n    # vpc: ec2.Vpc\n\n    common_cluster_options = eks.CommonClusterOptions(\n        version=kubernetes_version,\n\n        # the properties below are optional\n        cluster_name="clusterName",\n        output_cluster_name=False,\n        output_config_command=False,\n        role=role,\n        security_group=security_group,\n        vpc=vpc,\n        vpc_subnets=[ec2.SubnetSelection(\n            availability_zones=["availabilityZones"],\n            one_per_az=False,\n            subnet_filters=[subnet_filter],\n            subnet_group_name="subnetGroupName",\n            subnets=[subnet],\n            subnet_type=ec2.SubnetType.PRIVATE_ISOLATED\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['version', 'cluster_name', 'output_cluster_name', 'output_config_command', 'role', 'security_group', 'vpc', 'vpc_subnets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CommonClusterOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.EksOptimizedImageProps
class EksOptimizedImagePropsDef(BaseStruct):
    cpu_arch: typing.Optional[aws_cdk.aws_eks.CpuArch] = pydantic.Field(None, description='What cpu architecture to retrieve the image for (arm64 or x86_64). Default: CpuArch.X86_64\n')
    kubernetes_version: typing.Optional[str] = pydantic.Field(None, description='The Kubernetes version to use. Default: - The latest version\n')
    node_type: typing.Optional[aws_cdk.aws_eks.NodeType] = pydantic.Field(None, description='What instance type to retrieve the image for (standard or GPU-optimized). Default: NodeType.STANDARD\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    eks_optimized_image_props = eks.EksOptimizedImageProps(\n        cpu_arch=eks.CpuArch.ARM_64,\n        kubernetes_version="kubernetesVersion",\n        node_type=eks.NodeType.STANDARD\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cpu_arch', 'kubernetes_version', 'node_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.EksOptimizedImageProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.FargateClusterProps
class FargateClusterPropsDef(BaseStruct):
    version: typing.Union[models.aws_eks.KubernetesVersionDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Kubernetes version to run in the cluster.\n')
    cluster_name: typing.Optional[str] = pydantic.Field(None, description='Name for the cluster. Default: - Automatically generated name\n')
    output_cluster_name: typing.Optional[bool] = pydantic.Field(None, description='Determines whether a CloudFormation output with the name of the cluster will be synthesized. Default: false\n')
    output_config_command: typing.Optional[bool] = pydantic.Field(None, description='Determines whether a CloudFormation output with the ``aws eks update-kubeconfig`` command will be synthesized. This command will include the cluster name and, if applicable, the ARN of the masters IAM role. Default: true\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='Role that provides permissions for the Kubernetes control plane to make calls to AWS API operations on your behalf. Default: - A role is automatically created for you\n')
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='Security Group to use for Control Plane ENIs. Default: - A security group is automatically created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC in which to create the Cluster. Default: - a VPC with default configuration will be created and can be accessed through ``cluster.vpc``.\n')
    vpc_subnets: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Where to place EKS Control Plane ENIs. For example, to only select private subnets, supply the following: ``vpcSubnets: [{ subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS }]`` Default: - All public and private subnets\n')
    alb_controller: typing.Union[models.aws_eks.AlbControllerOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Install the AWS Load Balancer Controller onto the cluster. Default: - The controller is not installed.\n')
    authentication_mode: typing.Optional[aws_cdk.aws_eks.AuthenticationMode] = pydantic.Field(None, description='The desired authentication mode for the cluster. Default: AuthenticationMode.CONFIG_MAP\n')
    awscli_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description='An AWS Lambda layer that contains the ``aws`` CLI. The handler expects the layer to include the following executables:: /opt/awscli/aws Default: - a default layer with the AWS CLI 1.x\n')
    cluster_handler_environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Custom environment variables when interacting with the EKS endpoint to manage the cluster lifecycle. Default: - No environment variables.\n')
    cluster_handler_security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description="A security group to associate with the Cluster Handler's Lambdas. The Cluster Handler's Lambdas are responsible for calling AWS's EKS API. Requires ``placeClusterHandlerInVpc`` to be set to true. Default: - No security group.\n")
    cluster_logging: typing.Optional[typing.Sequence[aws_cdk.aws_eks.ClusterLoggingTypes]] = pydantic.Field(None, description='The cluster log types which you want to enable. Default: - none\n')
    core_dns_compute_type: typing.Optional[aws_cdk.aws_eks.CoreDnsComputeType] = pydantic.Field(None, description='Controls the "eks.amazonaws.com/compute-type" annotation in the CoreDNS configuration on your cluster to determine which compute type to use for CoreDNS. Default: CoreDnsComputeType.EC2 (for ``FargateCluster`` the default is FARGATE)\n')
    endpoint_access: typing.Optional[models.aws_eks.EndpointAccessDef] = pydantic.Field(None, description='Configure access to the Kubernetes API server endpoint.. Default: EndpointAccess.PUBLIC_AND_PRIVATE\n')
    ip_family: typing.Optional[aws_cdk.aws_eks.IpFamily] = pydantic.Field(None, description='Specify which IP family is used to assign Kubernetes pod and service IP addresses. Default: - IpFamily.IP_V4\n')
    kubectl_environment: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Environment variables for the kubectl execution. Only relevant for kubectl enabled clusters. Default: - No environment variables.\n')
    kubectl_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description="An AWS Lambda Layer which includes ``kubectl`` and Helm. This layer is used by the kubectl handler to apply manifests and install helm charts. You must pick an appropriate releases of one of the ``@aws-cdk/layer-kubectl-vXX`` packages, that works with the version of Kubernetes you have chosen. If you don't supply this value ``kubectl`` 1.20 will be used, but that version is most likely too old. The handler expects the layer to include the following executables:: /opt/helm/helm /opt/kubectl/kubectl Default: - a default layer with Kubectl 1.20.\n")
    kubectl_memory: typing.Optional[models.SizeDef] = pydantic.Field(None, description="Amount of memory to allocate to the provider's lambda function. Default: Size.gibibytes(1)\n")
    masters_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role that will be added to the ``system:masters`` Kubernetes RBAC group. Default: - no masters role.\n')
    on_event_layer: typing.Optional[typing.Union[models.aws_lambda.LayerVersionDef, models.lambda_layer_awscli.AwsCliLayerDef, models.lambda_layer_kubectl.KubectlLayerDef, models.lambda_layer_node_proxy_agent.NodeProxyAgentLayerDef]] = pydantic.Field(None, description='An AWS Lambda Layer which includes the NPM dependency ``proxy-agent``. This layer is used by the onEvent handler to route AWS SDK requests through a proxy. By default, the provider will use the layer included in the "aws-lambda-layer-node-proxy-agent" SAR application which is available in all commercial regions. To deploy the layer locally define it in your app as follows:: const layer = new lambda.LayerVersion(this, \'proxy-agent-layer\', { code: lambda.Code.fromAsset(`${__dirname}/layer.zip`), compatibleRuntimes: [lambda.Runtime.NODEJS_LATEST], }); Default: - a layer bundled with this module.\n')
    output_masters_role_arn: typing.Optional[bool] = pydantic.Field(None, description='Determines whether a CloudFormation output with the ARN of the "masters" IAM role will be synthesized (if ``mastersRole`` is specified). Default: false\n')
    place_cluster_handler_in_vpc: typing.Optional[bool] = pydantic.Field(None, description='If set to true, the cluster handler functions will be placed in the private subnets of the cluster vpc, subject to the ``vpcSubnets`` selection strategy. Default: false\n')
    prune: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether Kubernetes resources added through ``addManifest()`` can be automatically pruned. When this is enabled (default), prune labels will be allocated and injected to each resource. These labels will then be used when issuing the ``kubectl apply`` operation with the ``--prune`` switch. Default: true\n')
    secrets_encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='KMS secret for envelope encryption for Kubernetes secrets. Default: - By default, Kubernetes stores all secret object data within etcd and all etcd volumes used by Amazon EKS are encrypted at the disk-level using AWS-Managed encryption keys.\n')
    service_ipv4_cidr: typing.Optional[str] = pydantic.Field(None, description='The CIDR block to assign Kubernetes service IP addresses from. Default: - Kubernetes assigns addresses from either the 10.100.0.0/16 or 172.20.0.0/16 CIDR blocks\n')
    default_profile: typing.Union[models.aws_eks.FargateProfileOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Fargate Profile to create along with the cluster. Default: - A profile called "default" with \'default\' and \'kube-system\' selectors will be created if this is left undefined.\n\n:exampleMetadata: infused\n\nExample::\n\n    cluster = eks.FargateCluster(self, "MyCluster",\n        version=eks.KubernetesVersion.V1_30\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['version', 'cluster_name', 'output_cluster_name', 'output_config_command', 'role', 'security_group', 'vpc', 'vpc_subnets', 'alb_controller', 'authentication_mode', 'awscli_layer', 'cluster_handler_environment', 'cluster_handler_security_group', 'cluster_logging', 'core_dns_compute_type', 'endpoint_access', 'ip_family', 'kubectl_environment', 'kubectl_layer', 'kubectl_memory', 'masters_role', 'on_event_layer', 'output_masters_role_arn', 'place_cluster_handler_in_vpc', 'prune', 'secrets_encryption_key', 'service_ipv4_cidr', 'default_profile']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.FargateClusterProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.FargateClusterPropsDefConfig] = pydantic.Field(None)


class FargateClusterPropsDefConfig(pydantic.BaseModel):
    version_config: typing.Optional[models.aws_eks.KubernetesVersionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_eks.FargateProfileOptions
class FargateProfileOptionsDef(BaseStruct):
    selectors: typing.Union[typing.Sequence[typing.Union[models.aws_eks.SelectorDef, dict[str, typing.Any]]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The selectors to match for pods to use this Fargate profile. Each selector must have an associated namespace. Optionally, you can also specify labels for a namespace. At least one selector is required and you may specify up to five selectors.\n')
    fargate_profile_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Fargate profile. Default: - generated\n')
    pod_execution_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The pod execution role to use for pods that match the selectors in the Fargate profile. The pod execution role allows Fargate infrastructure to register with your cluster as a node, and it provides read access to Amazon ECR image repositories. Default: - a role will be automatically created\n')
    subnet_selection: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Select which subnets to launch your pods into. At this time, pods running on Fargate are not assigned public IP addresses, so only private subnets (with no direct route to an Internet Gateway) are allowed. You must specify the VPC to customize the subnet selection Default: - all private subnets of the VPC are selected.\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC from which to select subnets to launch your pods into. By default, all private subnets are selected. You can customize this using ``subnetSelection``. Default: - all private subnets used by the EKS cluster\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: eks.Cluster\n\n    cluster.add_fargate_profile("MyProfile",\n        selectors=[eks.Selector(namespace="default")]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['selectors', 'fargate_profile_name', 'pod_execution_role', 'subnet_selection', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.FargateProfileOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.FargateProfileProps
class FargateProfilePropsDef(BaseStruct):
    selectors: typing.Union[typing.Sequence[typing.Union[models.aws_eks.SelectorDef, dict[str, typing.Any]]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The selectors to match for pods to use this Fargate profile. Each selector must have an associated namespace. Optionally, you can also specify labels for a namespace. At least one selector is required and you may specify up to five selectors.\n')
    fargate_profile_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Fargate profile. Default: - generated\n')
    pod_execution_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The pod execution role to use for pods that match the selectors in the Fargate profile. The pod execution role allows Fargate infrastructure to register with your cluster as a node, and it provides read access to Amazon ECR image repositories. Default: - a role will be automatically created\n')
    subnet_selection: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Select which subnets to launch your pods into. At this time, pods running on Fargate are not assigned public IP addresses, so only private subnets (with no direct route to an Internet Gateway) are allowed. You must specify the VPC to customize the subnet selection Default: - all private subnets of the VPC are selected.\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC from which to select subnets to launch your pods into. By default, all private subnets are selected. You can customize this using ``subnetSelection``. Default: - all private subnets used by the EKS cluster\n')
    cluster: typing.Union[models.aws_eks.ClusterDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The EKS cluster to apply the Fargate profile to. [disable-awslint:ref-via-interface]\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: eks.Cluster\n\n    eks.FargateProfile(self, "MyProfile",\n        cluster=cluster,\n        selectors=[eks.Selector(namespace="default")]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['selectors', 'fargate_profile_name', 'pod_execution_role', 'subnet_selection', 'vpc', 'cluster']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.FargateProfileProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.HelmChartOptions
class HelmChartOptionsDef(BaseStruct):
    atomic: typing.Optional[bool] = pydantic.Field(None, description='Whether or not Helm should treat this operation as atomic; if set, upgrade process rolls back changes made in case of failed upgrade. The --wait flag will be set automatically if --atomic is used. Default: false\n')
    chart: typing.Optional[str] = pydantic.Field(None, description='The name of the chart. Either this or ``chartAsset`` must be specified. Default: - No chart name. Implies ``chartAsset`` is used.\n')
    chart_asset: typing.Optional[models.aws_s3_assets.AssetDef] = pydantic.Field(None, description='The chart in the form of an asset. Either this or ``chart`` must be specified. Default: - No chart asset. Implies ``chart`` is used.\n')
    create_namespace: typing.Optional[bool] = pydantic.Field(None, description='create namespace if not exist. Default: true\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description='The Kubernetes namespace scope of the requests. Default: default\n')
    release: typing.Optional[str] = pydantic.Field(None, description="The name of the release. Default: - If no release name is given, it will use the last 53 characters of the node's unique id.\n")
    repository: typing.Optional[str] = pydantic.Field(None, description='The repository which contains the chart. For example: https://charts.helm.sh/stable/ Default: - No repository will be used, which means that the chart needs to be an absolute URL.\n')
    skip_crds: typing.Optional[bool] = pydantic.Field(None, description='if set, no CRDs will be installed. Default: - CRDs are installed if not already present\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Amount of time to wait for any individual Kubernetes operation. Maximum 15 minutes. Default: Duration.minutes(5)\n')
    values: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='The values to be used by the chart. For nested values use a nested dictionary. For example: values: { installationCRDs: true, webhook: { port: 9443 } } Default: - No values are provided to the chart.\n')
    version: typing.Optional[str] = pydantic.Field(None, description='The chart version to install. Default: - If this is not specified, the latest version is installed\n')
    wait: typing.Optional[bool] = pydantic.Field(None, description='Whether or not Helm should wait until all Pods, PVCs, Services, and minimum number of Pods of a Deployment, StatefulSet, or ReplicaSet are in a ready state before marking the release as successful. Default: - Helm will not wait before marking release as successful\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_s3_assets as s3_assets\n\n    # cluster: eks.Cluster\n\n    chart_asset = s3_assets.Asset(self, "ChartAsset",\n        path="/path/to/asset"\n    )\n\n    cluster.add_helm_chart("test-chart",\n        chart_asset=chart_asset\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['atomic', 'chart', 'chart_asset', 'create_namespace', 'namespace', 'release', 'repository', 'skip_crds', 'timeout', 'values', 'version', 'wait']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.HelmChartOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.HelmChartProps
class HelmChartPropsDef(BaseStruct):
    atomic: typing.Optional[bool] = pydantic.Field(None, description='Whether or not Helm should treat this operation as atomic; if set, upgrade process rolls back changes made in case of failed upgrade. The --wait flag will be set automatically if --atomic is used. Default: false\n')
    chart: typing.Optional[str] = pydantic.Field(None, description='The name of the chart. Either this or ``chartAsset`` must be specified. Default: - No chart name. Implies ``chartAsset`` is used.\n')
    chart_asset: typing.Optional[models.aws_s3_assets.AssetDef] = pydantic.Field(None, description='The chart in the form of an asset. Either this or ``chart`` must be specified. Default: - No chart asset. Implies ``chart`` is used.\n')
    create_namespace: typing.Optional[bool] = pydantic.Field(None, description='create namespace if not exist. Default: true\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description='The Kubernetes namespace scope of the requests. Default: default\n')
    release: typing.Optional[str] = pydantic.Field(None, description="The name of the release. Default: - If no release name is given, it will use the last 53 characters of the node's unique id.\n")
    repository: typing.Optional[str] = pydantic.Field(None, description='The repository which contains the chart. For example: https://charts.helm.sh/stable/ Default: - No repository will be used, which means that the chart needs to be an absolute URL.\n')
    skip_crds: typing.Optional[bool] = pydantic.Field(None, description='if set, no CRDs will be installed. Default: - CRDs are installed if not already present\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Amount of time to wait for any individual Kubernetes operation. Maximum 15 minutes. Default: Duration.minutes(5)\n')
    values: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='The values to be used by the chart. For nested values use a nested dictionary. For example: values: { installationCRDs: true, webhook: { port: 9443 } } Default: - No values are provided to the chart.\n')
    version: typing.Optional[str] = pydantic.Field(None, description='The chart version to install. Default: - If this is not specified, the latest version is installed\n')
    wait: typing.Optional[bool] = pydantic.Field(None, description='Whether or not Helm should wait until all Pods, PVCs, Services, and minimum number of Pods of a Deployment, StatefulSet, or ReplicaSet are in a ready state before marking the release as successful. Default: - Helm will not wait before marking release as successful\n')
    cluster: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ClusterDef, models.aws_eks.FargateClusterDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The EKS cluster to apply this configuration to. [disable-awslint:ref-via-interface]\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: eks.Cluster\n\n    # option 1: use a construct\n    eks.HelmChart(self, "MyOCIChart",\n        cluster=cluster,\n        chart="some-chart",\n        repository="oci://${ACCOUNT_ID}.dkr.ecr.${ACCOUNT_REGION}.amazonaws.com/${REPO_NAME}",\n        namespace="oci",\n        version="0.0.1"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['atomic', 'chart', 'chart_asset', 'create_namespace', 'namespace', 'release', 'repository', 'skip_crds', 'timeout', 'values', 'version', 'wait', 'cluster']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.HelmChartProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.IngressLoadBalancerAddressOptions
class IngressLoadBalancerAddressOptionsDef(BaseStruct):
    namespace: typing.Optional[str] = pydantic.Field(None, description="The namespace the service belongs to. Default: 'default'\n")
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Timeout for waiting on the load balancer address. Default: Duration.minutes(5)\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_eks as eks\n\n    ingress_load_balancer_address_options = eks.IngressLoadBalancerAddressOptions(\n        namespace="namespace",\n        timeout=cdk.Duration.minutes(30)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['namespace', 'timeout']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.IngressLoadBalancerAddressOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.KubectlProviderAttributes
class KubectlProviderAttributesDef(BaseStruct):
    function_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The custom resource provider's service token.\n")
    handler_role: typing.Union[_REQUIRED_INIT_PARAM, models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The IAM execution role of the handler. This role must be able to assume kubectlRoleArn\n')
    kubectl_role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The IAM role to assume in order to perform kubectl operations against this cluster.\n\n:exampleMetadata: infused\n\nExample::\n\n    handler_role = iam.Role.from_role_arn(self, "HandlerRole", "arn:aws:iam::123456789012:role/lambda-role")\n    # get the serivceToken from the custom resource provider\n    function_arn = lambda_.Function.from_function_name(self, "ProviderOnEventFunc", "ProviderframeworkonEvent-XXX").function_arn\n    kubectl_provider = eks.KubectlProvider.from_kubectl_provider_attributes(self, "KubectlProvider",\n        function_arn=function_arn,\n        kubectl_role_arn="arn:aws:iam::123456789012:role/kubectl-role",\n        handler_role=handler_role\n    )\n\n    cluster = eks.Cluster.from_cluster_attributes(self, "Cluster",\n        cluster_name="cluster",\n        kubectl_provider=kubectl_provider\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['function_arn', 'handler_role', 'kubectl_role_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.KubectlProviderAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.KubectlProviderAttributesDefConfig] = pydantic.Field(None)


class KubectlProviderAttributesDefConfig(pydantic.BaseModel):
    handler_role_config: typing.Optional[models._interface_methods.AwsIamIRoleDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_eks.KubectlProviderProps
class KubectlProviderPropsDef(BaseStruct):
    cluster: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ClusterDef, models.aws_eks.FargateClusterDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The cluster to control.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    # cluster: eks.Cluster\n\n    kubectl_provider_props = eks.KubectlProviderProps(\n        cluster=cluster\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cluster']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.KubectlProviderProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.KubectlProviderPropsDefConfig] = pydantic.Field(None)


class KubectlProviderPropsDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEksIClusterDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_eks.KubernetesManifestOptions
class KubernetesManifestOptionsDef(BaseStruct):
    ingress_alb: typing.Optional[bool] = pydantic.Field(None, description='Automatically detect ``Ingress`` resources in the manifest and annotate them so they are picked up by an ALB Ingress Controller. Default: false\n')
    ingress_alb_scheme: typing.Optional[aws_cdk.aws_eks.AlbScheme] = pydantic.Field(None, description='Specify the ALB scheme that should be applied to ``Ingress`` resources. Only applicable if ``ingressAlb`` is set to ``true``. Default: AlbScheme.INTERNAL\n')
    prune: typing.Optional[bool] = pydantic.Field(None, description='When a resource is removed from a Kubernetes manifest, it no longer appears in the manifest, and there is no way to know that this resource needs to be deleted. To address this, ``kubectl apply`` has a ``--prune`` option which will query the cluster for all resources with a specific label and will remove all the labeld resources that are not part of the applied manifest. If this option is disabled and a resource is removed, it will become "orphaned" and will not be deleted from the cluster. When this option is enabled (default), the construct will inject a label to all Kubernetes resources included in this manifest which will be used to prune resources when the manifest changes via ``kubectl apply --prune``. The label name will be ``aws.cdk.eks/prune-<ADDR>`` where ``<ADDR>`` is the 42-char unique address of this construct in the construct tree. Value is empty. Default: - based on the prune option of the cluster, which is ``true`` unless otherwise specified.\n')
    skip_validation: typing.Optional[bool] = pydantic.Field(None, description='A flag to signify if the manifest validation should be skipped. Default: false\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    kubernetes_manifest_options = eks.KubernetesManifestOptions(\n        ingress_alb=False,\n        ingress_alb_scheme=eks.AlbScheme.INTERNAL,\n        prune=False,\n        skip_validation=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ingress_alb', 'ingress_alb_scheme', 'prune', 'skip_validation']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.KubernetesManifestOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.KubernetesManifestProps
class KubernetesManifestPropsDef(BaseStruct):
    ingress_alb: typing.Optional[bool] = pydantic.Field(None, description='Automatically detect ``Ingress`` resources in the manifest and annotate them so they are picked up by an ALB Ingress Controller. Default: false\n')
    ingress_alb_scheme: typing.Optional[aws_cdk.aws_eks.AlbScheme] = pydantic.Field(None, description='Specify the ALB scheme that should be applied to ``Ingress`` resources. Only applicable if ``ingressAlb`` is set to ``true``. Default: AlbScheme.INTERNAL\n')
    prune: typing.Optional[bool] = pydantic.Field(None, description='When a resource is removed from a Kubernetes manifest, it no longer appears in the manifest, and there is no way to know that this resource needs to be deleted. To address this, ``kubectl apply`` has a ``--prune`` option which will query the cluster for all resources with a specific label and will remove all the labeld resources that are not part of the applied manifest. If this option is disabled and a resource is removed, it will become "orphaned" and will not be deleted from the cluster. When this option is enabled (default), the construct will inject a label to all Kubernetes resources included in this manifest which will be used to prune resources when the manifest changes via ``kubectl apply --prune``. The label name will be ``aws.cdk.eks/prune-<ADDR>`` where ``<ADDR>`` is the 42-char unique address of this construct in the construct tree. Value is empty. Default: - based on the prune option of the cluster, which is ``true`` unless otherwise specified.\n')
    skip_validation: typing.Optional[bool] = pydantic.Field(None, description='A flag to signify if the manifest validation should be skipped. Default: false\n')
    cluster: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ClusterDef, models.aws_eks.FargateClusterDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The EKS cluster to apply this manifest to. [disable-awslint:ref-via-interface]\n')
    manifest: typing.Union[typing.Sequence[typing.Mapping[str, typing.Any]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The manifest to apply. Consists of any number of child resources. When the resources are created/updated, this manifest will be applied to the cluster through ``kubectl apply`` and when the resources or the stack is deleted, the resources in the manifest will be deleted through ``kubectl delete``.\n')
    overwrite: typing.Optional[bool] = pydantic.Field(None, description='Overwrite any existing resources. If this is set, we will use ``kubectl apply`` instead of ``kubectl create`` when the resource is created. Otherwise, if there is already a resource in the cluster with the same name, the operation will fail. Default: false\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: eks.Cluster\n\n    app_label = {"app": "hello-kubernetes"}\n\n    deployment = {\n        "api_version": "apps/v1",\n        "kind": "Deployment",\n        "metadata": {"name": "hello-kubernetes"},\n        "spec": {\n            "replicas": 3,\n            "selector": {"match_labels": app_label},\n            "template": {\n                "metadata": {"labels": app_label},\n                "spec": {\n                    "containers": [{\n                        "name": "hello-kubernetes",\n                        "image": "paulbouwer/hello-kubernetes:1.5",\n                        "ports": [{"container_port": 8080}]\n                    }\n                    ]\n                }\n            }\n        }\n    }\n\n    service = {\n        "api_version": "v1",\n        "kind": "Service",\n        "metadata": {"name": "hello-kubernetes"},\n        "spec": {\n            "type": "LoadBalancer",\n            "ports": [{"port": 80, "target_port": 8080}],\n            "selector": app_label\n        }\n    }\n\n    # option 1: use a construct\n    eks.KubernetesManifest(self, "hello-kub",\n        cluster=cluster,\n        manifest=[deployment, service]\n    )\n\n    # or, option2: use `addManifest`\n    cluster.add_manifest("hello-kub", service, deployment)\n')
    _init_params: typing.ClassVar[list[str]] = ['ingress_alb', 'ingress_alb_scheme', 'prune', 'skip_validation', 'cluster', 'manifest', 'overwrite']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.KubernetesManifestProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.KubernetesManifestPropsDefConfig] = pydantic.Field(None)


class KubernetesManifestPropsDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEksIClusterDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_eks.KubernetesObjectValueProps
class KubernetesObjectValuePropsDef(BaseStruct):
    cluster: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ClusterDef, models.aws_eks.FargateClusterDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The EKS cluster to fetch attributes from. [disable-awslint:ref-via-interface]\n')
    json_path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='JSONPath to the specific value.\n')
    object_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the object to query.\n')
    object_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The object type to query. (e.g 'service', 'pod'...)\n")
    object_namespace: typing.Optional[str] = pydantic.Field(None, description="The namespace the object belongs to. Default: 'default'\n")
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Timeout for waiting on a value. Default: Duration.minutes(5)\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: eks.Cluster\n\n    # query the load balancer address\n    my_service_address = eks.KubernetesObjectValue(self, "LoadBalancerAttribute",\n        cluster=cluster,\n        object_type="service",\n        object_name="my-service",\n        json_path=".status.loadBalancer.ingress[0].hostname"\n    )\n\n    # pass the address to a lambda function\n    proxy_function = lambda_.Function(self, "ProxyFunction",\n        handler="index.handler",\n        code=lambda_.Code.from_inline("my-code"),\n        runtime=lambda_.Runtime.NODEJS_LATEST,\n        environment={\n            "my_service_address": my_service_address.value\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cluster', 'json_path', 'object_name', 'object_type', 'object_namespace', 'timeout']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.KubernetesObjectValueProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.KubernetesObjectValuePropsDefConfig] = pydantic.Field(None)


class KubernetesObjectValuePropsDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEksIClusterDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_eks.KubernetesPatchProps
class KubernetesPatchPropsDef(BaseStruct):
    apply_patch: typing.Union[typing.Mapping[str, typing.Any], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The JSON object to pass to ``kubectl patch`` when the resource is created/updated.\n')
    cluster: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ClusterDef, models.aws_eks.FargateClusterDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The cluster to apply the patch to. [disable-awslint:ref-via-interface]\n')
    resource_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The full name of the resource to patch (e.g. ``deployment/coredns``).\n')
    restore_patch: typing.Union[typing.Mapping[str, typing.Any], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The JSON object to pass to ``kubectl patch`` when the resource is removed.\n')
    patch_type: typing.Optional[aws_cdk.aws_eks.PatchType] = pydantic.Field(None, description='The patch type to pass to ``kubectl patch``. The default type used by ``kubectl patch`` is "strategic". Default: PatchType.STRATEGIC\n')
    resource_namespace: typing.Optional[str] = pydantic.Field(None, description='The kubernetes API namespace. Default: "default"\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: eks.Cluster\n\n    eks.KubernetesPatch(self, "hello-kub-deployment-label",\n        cluster=cluster,\n        resource_name="deployment/hello-kubernetes",\n        apply_patch={"spec": {"replicas": 5}},\n        restore_patch={"spec": {"replicas": 3}}\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['apply_patch', 'cluster', 'resource_name', 'restore_patch', 'patch_type', 'resource_namespace']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.KubernetesPatchProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.KubernetesPatchPropsDefConfig] = pydantic.Field(None)


class KubernetesPatchPropsDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEksIClusterDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_eks.LaunchTemplateSpec
class LaunchTemplateSpecDef(BaseStruct):
    version: typing.Optional[str] = pydantic.Field(None, description='The launch template version to be used (optional). Default: - the default version of the launch template\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: eks.Cluster\n\n\n    user_data = """MIME-Version: 1.0\n    Content-Type: multipart/mixed; boundary="==MYBOUNDARY=="\n\n    --==MYBOUNDARY==\n    Content-Type: text/x-shellscript; charset="us-ascii"\n\n    #!/bin/bash\n    echo "Running custom user data script"\n\n    --==MYBOUNDARY==--\\\n    """\n    lt = ec2.CfnLaunchTemplate(self, "LaunchTemplate",\n        launch_template_data=ec2.CfnLaunchTemplate.LaunchTemplateDataProperty(\n            instance_type="t3.small",\n            user_data=Fn.base64(user_data)\n        )\n    )\n\n    cluster.add_nodegroup_capacity("extra-ng",\n        launch_template_spec=eks.LaunchTemplateSpec(\n            id=lt.ref,\n            version=lt.attr_latest_version_number\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.LaunchTemplateSpec'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.NodegroupOptions
class NodegroupOptionsDef(BaseStruct):
    ami_type: typing.Optional[aws_cdk.aws_eks.NodegroupAmiType] = pydantic.Field(None, description='The AMI type for your node group. If you explicitly specify the launchTemplate with custom AMI, do not specify this property, or the node group deployment will fail. In other cases, you will need to specify correct amiType for the nodegroup. Default: - auto-determined from the instanceTypes property when launchTemplateSpec property is not specified\n')
    capacity_type: typing.Optional[aws_cdk.aws_eks.CapacityType] = pydantic.Field(None, description='The capacity type of the nodegroup. Default: - ON_DEMAND\n')
    desired_size: typing.Union[int, float, None] = pydantic.Field(None, description='The current number of worker nodes that the managed node group should maintain. If not specified, the nodewgroup will initially create ``minSize`` instances. Default: 2\n')
    disk_size: typing.Union[int, float, None] = pydantic.Field(None, description='The root device disk size (in GiB) for your node group instances. Default: 20\n')
    force_update: typing.Optional[bool] = pydantic.Field(None, description="Force the update if the existing node group's pods are unable to be drained due to a pod disruption budget issue. If an update fails because pods could not be drained, you can force the update after it fails to terminate the old node whether or not any pods are running on the node. Default: true\n")
    instance_types: typing.Optional[typing.Sequence[models.aws_ec2.InstanceTypeDef]] = pydantic.Field(None, description='The instance types to use for your node group. Default: t3.medium will be used according to the cloudformation document.\n')
    labels: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The Kubernetes labels to be applied to the nodes in the node group when they are created. Default: - None\n')
    launch_template_spec: typing.Union[models.aws_eks.LaunchTemplateSpecDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Launch template specification used for the nodegroup. Default: - no launch template\n')
    max_size: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of worker nodes that the managed node group can scale out to. Managed node groups can support up to 100 nodes by default. Default: - desiredSize\n')
    max_unavailable: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of nodes unavailable at once during a version update. Nodes will be updated in parallel. The maximum number is 100. This value or ``maxUnavailablePercentage`` is required to have a value for custom update configurations to be applied. Default: 1\n')
    max_unavailable_percentage: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum percentage of nodes unavailable during a version update. This percentage of nodes will be updated in parallel, up to 100 nodes at once. This value or ``maxUnavailable`` is required to have a value for custom update configurations to be applied. Default: undefined - node groups will update instances one at a time\n')
    min_size: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of worker nodes that the managed node group can scale in to. This number must be greater than or equal to zero. Default: 1\n')
    nodegroup_name: typing.Optional[str] = pydantic.Field(None, description='Name of the Nodegroup. Default: - resource ID\n')
    node_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The IAM role to associate with your node group. The Amazon EKS worker node kubelet daemon makes calls to AWS APIs on your behalf. Worker nodes receive permissions for these API calls through an IAM instance profile and associated policies. Before you can launch worker nodes and register them into a cluster, you must create an IAM role for those worker nodes to use when they are launched. Default: - None. Auto-generated if not specified.\n')
    release_version: typing.Optional[str] = pydantic.Field(None, description="The AMI version of the Amazon EKS-optimized AMI to use with your node group (for example, ``1.14.7-YYYYMMDD``). Default: - The latest available AMI version for the node group's current Kubernetes version is used.\n")
    remote_access: typing.Union[models.aws_eks.NodegroupRemoteAccessDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The remote access (SSH) configuration to use with your node group. Disabled by default, however, if you specify an Amazon EC2 SSH key but do not specify a source security group when you create a managed node group, then port 22 on the worker nodes is opened to the internet (0.0.0.0/0) Default: - disabled\n')
    subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The subnets to use for the Auto Scaling group that is created for your node group. By specifying the SubnetSelection, the selected subnets will automatically apply required tags i.e. ``kubernetes.io/cluster/CLUSTER_NAME`` with a value of ``shared``, where ``CLUSTER_NAME`` is replaced with the name of your cluster. Default: - private subnets\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The metadata to apply to the node group to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Node group tags do not propagate to any other resources associated with the node group, such as the Amazon EC2 instances or subnets. Default: - None\n')
    taints: typing.Optional[typing.Sequence[typing.Union[models.aws_eks.TaintSpecDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The Kubernetes taints to be applied to the nodes in the node group when they are created. Default: - None\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: eks.Cluster\n\n    cluster.add_nodegroup_capacity("extra-ng-spot",\n        instance_types=[\n            ec2.InstanceType("c5.large"),\n            ec2.InstanceType("c5a.large"),\n            ec2.InstanceType("c5d.large")\n        ],\n        min_size=3,\n        capacity_type=eks.CapacityType.SPOT\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ami_type', 'capacity_type', 'desired_size', 'disk_size', 'force_update', 'instance_types', 'labels', 'launch_template_spec', 'max_size', 'max_unavailable', 'max_unavailable_percentage', 'min_size', 'nodegroup_name', 'node_role', 'release_version', 'remote_access', 'subnets', 'tags', 'taints']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.NodegroupOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.NodegroupProps
class NodegroupPropsDef(BaseStruct):
    ami_type: typing.Optional[aws_cdk.aws_eks.NodegroupAmiType] = pydantic.Field(None, description='The AMI type for your node group. If you explicitly specify the launchTemplate with custom AMI, do not specify this property, or the node group deployment will fail. In other cases, you will need to specify correct amiType for the nodegroup. Default: - auto-determined from the instanceTypes property when launchTemplateSpec property is not specified\n')
    capacity_type: typing.Optional[aws_cdk.aws_eks.CapacityType] = pydantic.Field(None, description='The capacity type of the nodegroup. Default: - ON_DEMAND\n')
    desired_size: typing.Union[int, float, None] = pydantic.Field(None, description='The current number of worker nodes that the managed node group should maintain. If not specified, the nodewgroup will initially create ``minSize`` instances. Default: 2\n')
    disk_size: typing.Union[int, float, None] = pydantic.Field(None, description='The root device disk size (in GiB) for your node group instances. Default: 20\n')
    force_update: typing.Optional[bool] = pydantic.Field(None, description="Force the update if the existing node group's pods are unable to be drained due to a pod disruption budget issue. If an update fails because pods could not be drained, you can force the update after it fails to terminate the old node whether or not any pods are running on the node. Default: true\n")
    instance_types: typing.Optional[typing.Sequence[models.aws_ec2.InstanceTypeDef]] = pydantic.Field(None, description='The instance types to use for your node group. Default: t3.medium will be used according to the cloudformation document.\n')
    labels: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The Kubernetes labels to be applied to the nodes in the node group when they are created. Default: - None\n')
    launch_template_spec: typing.Union[models.aws_eks.LaunchTemplateSpecDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Launch template specification used for the nodegroup. Default: - no launch template\n')
    max_size: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of worker nodes that the managed node group can scale out to. Managed node groups can support up to 100 nodes by default. Default: - desiredSize\n')
    max_unavailable: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of nodes unavailable at once during a version update. Nodes will be updated in parallel. The maximum number is 100. This value or ``maxUnavailablePercentage`` is required to have a value for custom update configurations to be applied. Default: 1\n')
    max_unavailable_percentage: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum percentage of nodes unavailable during a version update. This percentage of nodes will be updated in parallel, up to 100 nodes at once. This value or ``maxUnavailable`` is required to have a value for custom update configurations to be applied. Default: undefined - node groups will update instances one at a time\n')
    min_size: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of worker nodes that the managed node group can scale in to. This number must be greater than or equal to zero. Default: 1\n')
    nodegroup_name: typing.Optional[str] = pydantic.Field(None, description='Name of the Nodegroup. Default: - resource ID\n')
    node_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The IAM role to associate with your node group. The Amazon EKS worker node kubelet daemon makes calls to AWS APIs on your behalf. Worker nodes receive permissions for these API calls through an IAM instance profile and associated policies. Before you can launch worker nodes and register them into a cluster, you must create an IAM role for those worker nodes to use when they are launched. Default: - None. Auto-generated if not specified.\n')
    release_version: typing.Optional[str] = pydantic.Field(None, description="The AMI version of the Amazon EKS-optimized AMI to use with your node group (for example, ``1.14.7-YYYYMMDD``). Default: - The latest available AMI version for the node group's current Kubernetes version is used.\n")
    remote_access: typing.Union[models.aws_eks.NodegroupRemoteAccessDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The remote access (SSH) configuration to use with your node group. Disabled by default, however, if you specify an Amazon EC2 SSH key but do not specify a source security group when you create a managed node group, then port 22 on the worker nodes is opened to the internet (0.0.0.0/0) Default: - disabled\n')
    subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The subnets to use for the Auto Scaling group that is created for your node group. By specifying the SubnetSelection, the selected subnets will automatically apply required tags i.e. ``kubernetes.io/cluster/CLUSTER_NAME`` with a value of ``shared``, where ``CLUSTER_NAME`` is replaced with the name of your cluster. Default: - private subnets\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The metadata to apply to the node group to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Node group tags do not propagate to any other resources associated with the node group, such as the Amazon EC2 instances or subnets. Default: - None\n')
    taints: typing.Optional[typing.Sequence[typing.Union[models.aws_eks.TaintSpecDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The Kubernetes taints to be applied to the nodes in the node group when they are created. Default: - None\n')
    cluster: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ClusterDef, models.aws_eks.FargateClusterDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='Cluster resource.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n    from aws_cdk import aws_eks as eks\n    from aws_cdk import aws_iam as iam\n\n    # cluster: eks.Cluster\n    # instance_type: ec2.InstanceType\n    # role: iam.Role\n    # security_group: ec2.SecurityGroup\n    # subnet: ec2.Subnet\n    # subnet_filter: ec2.SubnetFilter\n\n    nodegroup_props = eks.NodegroupProps(\n        cluster=cluster,\n\n        # the properties below are optional\n        ami_type=eks.NodegroupAmiType.AL2_X86_64,\n        capacity_type=eks.CapacityType.SPOT,\n        desired_size=123,\n        disk_size=123,\n        force_update=False,\n        instance_types=[instance_type],\n        labels={\n            "labels_key": "labels"\n        },\n        launch_template_spec=eks.LaunchTemplateSpec(\n            id="id",\n\n            # the properties below are optional\n            version="version"\n        ),\n        max_size=123,\n        max_unavailable=123,\n        max_unavailable_percentage=123,\n        min_size=123,\n        nodegroup_name="nodegroupName",\n        node_role=role,\n        release_version="releaseVersion",\n        remote_access=eks.NodegroupRemoteAccess(\n            ssh_key_name="sshKeyName",\n\n            # the properties below are optional\n            source_security_groups=[security_group]\n        ),\n        subnets=ec2.SubnetSelection(\n            availability_zones=["availabilityZones"],\n            one_per_az=False,\n            subnet_filters=[subnet_filter],\n            subnet_group_name="subnetGroupName",\n            subnets=[subnet],\n            subnet_type=ec2.SubnetType.PRIVATE_ISOLATED\n        ),\n        tags={\n            "tags_key": "tags"\n        },\n        taints=[eks.TaintSpec(\n            effect=eks.TaintEffect.NO_SCHEDULE,\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ami_type', 'capacity_type', 'desired_size', 'disk_size', 'force_update', 'instance_types', 'labels', 'launch_template_spec', 'max_size', 'max_unavailable', 'max_unavailable_percentage', 'min_size', 'nodegroup_name', 'node_role', 'release_version', 'remote_access', 'subnets', 'tags', 'taints', 'cluster']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.NodegroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.NodegroupPropsDefConfig] = pydantic.Field(None)


class NodegroupPropsDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEksIClusterDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_eks.NodegroupRemoteAccess
class NodegroupRemoteAccessDef(BaseStruct):
    ssh_key_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon EC2 SSH key that provides access for SSH communication with the worker nodes in the managed node group.\n')
    source_security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='The security groups that are allowed SSH access (port 22) to the worker nodes. If you specify an Amazon EC2 SSH key but do not specify a source security group when you create a managed node group, then port 22 on the worker nodes is opened to the internet (0.0.0.0/0). Default: - port 22 on the worker nodes is opened to the internet (0.0.0.0/0)\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-nodegroup-remoteaccess.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n    from aws_cdk import aws_eks as eks\n\n    # security_group: ec2.SecurityGroup\n\n    nodegroup_remote_access = eks.NodegroupRemoteAccess(\n        ssh_key_name="sshKeyName",\n\n        # the properties below are optional\n        source_security_groups=[security_group]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ssh_key_name', 'source_security_groups']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.NodegroupRemoteAccess'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.OpenIdConnectProviderProps
class OpenIdConnectProviderPropsDef(BaseStruct):
    url: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The URL of the identity provider. The URL must begin with https:// and should correspond to the iss claim in the provider\'s OpenID Connect ID tokens. Per the OIDC standard, path components are allowed but query parameters are not. Typically the URL consists of only a hostname, like https://server.example.org or https://example.com. You can find your OIDC Issuer URL by: aws eks describe-cluster --name %cluster_name% --query "cluster.identity.oidc.issuer" --output text\n\n:exampleMetadata: infused\n\nExample::\n\n    # or create a new one using an existing issuer url\n    # issuer_url: str\n    # you can import an existing provider\n    provider = eks.OpenIdConnectProvider.from_open_id_connect_provider_arn(self, "Provider", "arn:aws:iam::123456:oidc-provider/oidc.eks.eu-west-1.amazonaws.com/id/AB123456ABC")\n    provider2 = eks.OpenIdConnectProvider(self, "Provider",\n        url=issuer_url\n    )\n\n    cluster = eks.Cluster.from_cluster_attributes(self, "MyCluster",\n        cluster_name="Cluster",\n        open_id_connect_provider=provider,\n        kubectl_role_arn="arn:aws:iam::123456:role/service-role/k8sservicerole"\n    )\n\n    service_account = cluster.add_service_account("MyServiceAccount")\n\n    bucket = s3.Bucket(self, "Bucket")\n    bucket.grant_read_write(service_account)\n')
    _init_params: typing.ClassVar[list[str]] = ['url']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.OpenIdConnectProviderProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.Selector
class SelectorDef(BaseStruct):
    namespace: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Kubernetes namespace that the selector should match. You must specify a namespace for a selector. The selector only matches pods that are created in this namespace, but you can create multiple selectors to target multiple namespaces.\n')
    labels: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The Kubernetes labels that the selector should match. A pod must contain all of the labels that are specified in the selector for it to be considered a match. Default: - all pods within the namespace will be selected.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    selector = eks.Selector(\n        namespace="namespace",\n\n        # the properties below are optional\n        labels={\n            "labels_key": "labels"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['namespace', 'labels']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.Selector'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.ServiceAccountOptions
class ServiceAccountOptionsDef(BaseStruct):
    annotations: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Additional annotations of the service account. Default: - no additional annotations\n')
    identity_type: typing.Optional[aws_cdk.aws_eks.IdentityType] = pydantic.Field(None, description='The identity type to use for the service account. Default: IdentityType.IRSA\n')
    labels: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Additional labels of the service account. Default: - no additional labels\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the service account. The name of a ServiceAccount object must be a valid DNS subdomain name. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ Default: - If no name is given, it will use the id of the resource.\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description='The namespace of the service account. All namespace names must be valid RFC 1123 DNS labels. https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/#namespaces-and-dns Default: "default"\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: eks.Cluster\n\n    # add service account with annotations and labels\n    service_account = cluster.add_service_account("MyServiceAccount",\n        annotations={\n            "eks.amazonaws.com/sts-regional-endpoints": "false"\n        },\n        labels={\n            "some-label": "with-some-value"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['annotations', 'identity_type', 'labels', 'name', 'namespace']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.ServiceAccountOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.ServiceAccountProps
class ServiceAccountPropsDef(BaseStruct):
    annotations: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Additional annotations of the service account. Default: - no additional annotations\n')
    identity_type: typing.Optional[aws_cdk.aws_eks.IdentityType] = pydantic.Field(None, description='The identity type to use for the service account. Default: IdentityType.IRSA\n')
    labels: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Additional labels of the service account. Default: - no additional labels\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the service account. The name of a ServiceAccount object must be a valid DNS subdomain name. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ Default: - If no name is given, it will use the id of the resource.\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description='The namespace of the service account. All namespace names must be valid RFC 1123 DNS labels. https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/#namespaces-and-dns Default: "default"\n')
    cluster: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ClusterDef, models.aws_eks.FargateClusterDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The cluster to apply the patch to.\n\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: eks.Cluster\n\n\n    eks.ServiceAccount(self, "ServiceAccount",\n        cluster=cluster,\n        name="test-sa",\n        namespace="default",\n        identity_type=eks.IdentityType.POD_IDENTITY\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['annotations', 'identity_type', 'labels', 'name', 'namespace', 'cluster']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.ServiceAccountProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.ServiceAccountPropsDefConfig] = pydantic.Field(None)


class ServiceAccountPropsDefConfig(pydantic.BaseModel):
    cluster_config: typing.Optional[models._interface_methods.AwsEksIClusterDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_eks.ServiceLoadBalancerAddressOptions
class ServiceLoadBalancerAddressOptionsDef(BaseStruct):
    namespace: typing.Optional[str] = pydantic.Field(None, description="The namespace the service belongs to. Default: 'default'\n")
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Timeout for waiting on the load balancer address. Default: Duration.minutes(5)\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_eks as eks\n\n    service_load_balancer_address_options = eks.ServiceLoadBalancerAddressOptions(\n        namespace="namespace",\n        timeout=cdk.Duration.minutes(30)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['namespace', 'timeout']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.ServiceLoadBalancerAddressOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.TaintSpec
class TaintSpecDef(BaseStruct):
    effect: typing.Optional[aws_cdk.aws_eks.TaintEffect] = pydantic.Field(None, description='Effect type. Default: - None\n')
    key: typing.Optional[str] = pydantic.Field(None, description='Taint key. Default: - None\n')
    value: typing.Optional[str] = pydantic.Field(None, description='Taint value. Default: - None\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    taint_spec = eks.TaintSpec(\n        effect=eks.TaintEffect.NO_SCHEDULE,\n        key="key",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['effect', 'key', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.TaintSpec'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.AccessEntryType
# skipping emum

#  autogenerated from aws_cdk.aws_eks.AccessScopeType
# skipping emum

#  autogenerated from aws_cdk.aws_eks.AlbScheme
# skipping emum

#  autogenerated from aws_cdk.aws_eks.AuthenticationMode
# skipping emum

#  autogenerated from aws_cdk.aws_eks.CapacityType
# skipping emum

#  autogenerated from aws_cdk.aws_eks.ClusterLoggingTypes
# skipping emum

#  autogenerated from aws_cdk.aws_eks.CoreDnsComputeType
# skipping emum

#  autogenerated from aws_cdk.aws_eks.CpuArch
# skipping emum

#  autogenerated from aws_cdk.aws_eks.DefaultCapacityType
# skipping emum

#  autogenerated from aws_cdk.aws_eks.IpFamily
# skipping emum

#  autogenerated from aws_cdk.aws_eks.MachineImageType
# skipping emum

#  autogenerated from aws_cdk.aws_eks.NodegroupAmiType
# skipping emum

#  autogenerated from aws_cdk.aws_eks.NodeType
# skipping emum

#  autogenerated from aws_cdk.aws_eks.PatchType
# skipping emum

#  autogenerated from aws_cdk.aws_eks.TaintEffect
# skipping emum

#  autogenerated from aws_cdk.aws_eks.IAccessEntry
#  skipping Interface

#  autogenerated from aws_cdk.aws_eks.IAccessPolicy
#  skipping Interface

#  autogenerated from aws_cdk.aws_eks.ICluster
#  skipping Interface

#  autogenerated from aws_cdk.aws_eks.IKubectlProvider
#  skipping Interface

#  autogenerated from aws_cdk.aws_eks.INodegroup
#  skipping Interface

#  autogenerated from aws_cdk.aws_eks.CfnAccessEntry
class CfnAccessEntryDef(BaseCfnResource):
    cluster_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of your cluster.\n')
    principal_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The ARN of the IAM principal for the ``AccessEntry`` . You can specify one ARN for each access entry. You can't specify the same ARN in more than one access entry. This value can't be changed after access entry creation. The valid principals differ depending on the type of the access entry in the ``type`` field. The only valid ARN is IAM roles for the types of access entries for nodes: `` `` . You can use every IAM principal type for ``STANDARD`` access entries. You can't use the STS session principal type with access entries because this is a temporary principal for each session and not a permanent identity that can be assigned permissions. `IAM best practices <https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#bp-users-federation-idp>`_ recommend using IAM roles with temporary credentials, rather than IAM users with long-term credentials.\n")
    access_policies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_eks.CfnAccessEntry_AccessPolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The access policies to associate to the access entry.\n')
    kubernetes_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The value for ``name`` that you've specified for ``kind: Group`` as a ``subject`` in a Kubernetes ``RoleBinding`` or ``ClusterRoleBinding`` object. Amazon EKS doesn't confirm that the value for ``name`` exists in any bindings on your cluster. You can specify one or more names. Kubernetes authorizes the ``principalArn`` of the access entry to access any cluster objects that you've specified in a Kubernetes ``Role`` or ``ClusterRole`` object that is also specified in a binding's ``roleRef`` . For more information about creating Kubernetes ``RoleBinding`` , ``ClusterRoleBinding`` , ``Role`` , or ``ClusterRole`` objects, see `Using RBAC Authorization in the Kubernetes documentation <https://docs.aws.amazon.com/https://kubernetes.io/docs/reference/access-authn-authz/rbac/>`_ . If you want Amazon EKS to authorize the ``principalArn`` (instead of, or in addition to Kubernetes authorizing the ``principalArn`` ), you can associate one or more access policies to the access entry using ``AssociateAccessPolicy`` . If you associate any access policies, the ``principalARN`` has all permissions assigned in the associated access policies and all permissions in any Kubernetes ``Role`` or ``ClusterRole`` objects that the group names are bound to.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or AWS resources.\n")
    type: typing.Optional[str] = pydantic.Field(None, description="The type of the new access entry. Valid values are ``Standard`` , ``FARGATE_LINUX`` , ``EC2_LINUX`` , and ``EC2_WINDOWS`` . If the ``principalArn`` is for an IAM role that's used for self-managed Amazon EC2 nodes, specify ``EC2_LINUX`` or ``EC2_WINDOWS`` . Amazon EKS grants the necessary permissions to the node for you. If the ``principalArn`` is for any other purpose, specify ``STANDARD`` . If you don't specify a value, Amazon EKS sets the value to ``STANDARD`` . It's unnecessary to create access entries for IAM roles used with Fargate profiles or managed Amazon EC2 nodes, because Amazon EKS creates entries in the ``aws-auth`` ``ConfigMap`` for the roles. You can't change this value once you've created the access entry. If you set the value to ``EC2_LINUX`` or ``EC2_WINDOWS`` , you can't specify values for ``kubernetesGroups`` , or associate an ``AccessPolicy`` to the access entry.\n")
    username: typing.Optional[str] = pydantic.Field(None, description='The username to authenticate to Kubernetes with. We recommend not specifying a username and letting Amazon EKS specify it for you. For more information about the value Amazon EKS specifies for you, or constraints before specifying your own username, see `Creating access entries <https://docs.aws.amazon.com/eks/latest/userguide/access-entries.html#creating-access-entries>`_ in the *Amazon EKS User Guide* .')
    _init_params: typing.ClassVar[list[str]] = ['cluster_name', 'principal_arn', 'access_policies', 'kubernetes_groups', 'tags', 'type', 'username']
    _method_names: typing.ClassVar[list[str]] = ['AccessPolicyProperty', 'AccessScopeProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnAccessEntry'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.CfnAccessEntryDefConfig] = pydantic.Field(None)


class CfnAccessEntryDefConfig(pydantic.BaseModel):
    AccessPolicyProperty: typing.Optional[list[models.aws_eks.CfnAccessEntryDefAccesspolicypropertyParams]] = pydantic.Field(None, description='')
    AccessScopeProperty: typing.Optional[list[models.aws_eks.CfnAccessEntryDefAccessscopepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_eks.CfnAccessEntryDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_eks.CfnAccessEntryDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_eks.CfnAccessEntryDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_eks.CfnAccessEntryDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_eks.CfnAccessEntryDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_eks.CfnAccessEntryDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_eks.CfnAccessEntryDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_eks.CfnAccessEntryDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_eks.CfnAccessEntryDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_eks.CfnAccessEntryDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_eks.CfnAccessEntryDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_eks.CfnAccessEntryDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_eks.CfnAccessEntryDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnAccessEntryDefAccesspolicypropertyParams(pydantic.BaseModel):
    access_scope: typing.Union[models.UnsupportedResource, models.aws_eks.CfnAccessEntry_AccessScopePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    policy_arn: str = pydantic.Field(..., description='')
    ...

class CfnAccessEntryDefAccessscopepropertyParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='')
    namespaces: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnAccessEntryDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAccessEntryDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAccessEntryDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAccessEntryDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAccessEntryDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAccessEntryDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAccessEntryDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAccessEntryDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAccessEntryDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAccessEntryDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAccessEntryDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnAccessEntryDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAccessEntryDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAccessEntryDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_eks.CfnAddon
class CfnAddonDef(BaseCfnResource):
    addon_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the add-on.\n')
    cluster_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of your cluster.\n')
    addon_version: typing.Optional[str] = pydantic.Field(None, description='The version of the add-on.\n')
    configuration_values: typing.Optional[str] = pydantic.Field(None, description='The configuration values that you provided.\n')
    pod_identity_associations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_eks.CfnAddon_PodIdentityAssociationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An array of Pod Identity Assocations owned by the Addon. Each EKS Pod Identity association maps a role to a service account in a namespace in the cluster. For more information, see `Attach an IAM Role to an Amazon EKS add-on using Pod Identity <https://docs.aws.amazon.com/eks/latest/userguide/add-ons-iam.html>`_ in the EKS User Guide.\n')
    preserve_on_delete: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="Specifying this option preserves the add-on software on your cluster but Amazon EKS stops managing any settings for the add-on. If an IAM account is associated with the add-on, it isn't removed.\n")
    resolve_conflicts: typing.Optional[str] = pydantic.Field(None, description="How to resolve field value conflicts for an Amazon EKS add-on. Conflicts are handled based on the value you choose: - *None* – If the self-managed version of the add-on is installed on your cluster, Amazon EKS doesn't change the value. Creation of the add-on might fail. - *Overwrite* – If the self-managed version of the add-on is installed on your cluster and the Amazon EKS default value is different than the existing value, Amazon EKS changes the value to the Amazon EKS default value. - *Preserve* – This is similar to the NONE option. If the self-managed version of the add-on is installed on your cluster Amazon EKS doesn't change the add-on resource properties. Creation of the add-on might fail if conflicts are detected. This option works differently during the update operation. For more information, see `UpdateAddon <https://docs.aws.amazon.com/eks/latest/APIReference/API_UpdateAddon.html>`_ . If you don't currently have the self-managed version of the add-on installed on your cluster, the Amazon EKS add-on is installed. Amazon EKS sets all values to default values, regardless of the option that you specify.\n")
    service_account_role_arn: typing.Optional[str] = pydantic.Field(None, description="The Amazon Resource Name (ARN) of an existing IAM role to bind to the add-on's service account. The role must be assigned the IAM permissions required by the add-on. If you don't specify an existing IAM role, then the add-on uses the permissions assigned to the node IAM role. For more information, see `Amazon EKS node IAM role <https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html>`_ in the *Amazon EKS User Guide* . .. epigraph:: To specify an existing IAM role, you must have an IAM OpenID Connect (OIDC) provider created for your cluster. For more information, see `Enabling IAM roles for service accounts on your cluster <https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html>`_ in the *Amazon EKS User Guide* .\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The metadata that you apply to the add-on to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Add-on tags do not propagate to any other resources associated with the cluster.')
    _init_params: typing.ClassVar[list[str]] = ['addon_name', 'cluster_name', 'addon_version', 'configuration_values', 'pod_identity_associations', 'preserve_on_delete', 'resolve_conflicts', 'service_account_role_arn', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['PodIdentityAssociationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnAddon'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.CfnAddonDefConfig] = pydantic.Field(None)


class CfnAddonDefConfig(pydantic.BaseModel):
    PodIdentityAssociationProperty: typing.Optional[list[models.aws_eks.CfnAddonDefPodidentityassociationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_eks.CfnAddonDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_eks.CfnAddonDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_eks.CfnAddonDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_eks.CfnAddonDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_eks.CfnAddonDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_eks.CfnAddonDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_eks.CfnAddonDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_eks.CfnAddonDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_eks.CfnAddonDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_eks.CfnAddonDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_eks.CfnAddonDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_eks.CfnAddonDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_eks.CfnAddonDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnAddonDefPodidentityassociationpropertyParams(pydantic.BaseModel):
    role_arn: str = pydantic.Field(..., description='')
    service_account: str = pydantic.Field(..., description='')
    ...

class CfnAddonDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAddonDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAddonDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAddonDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAddonDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAddonDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAddonDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAddonDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAddonDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAddonDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAddonDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnAddonDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAddonDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAddonDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_eks.CfnCluster
class CfnClusterDef(BaseCfnResource):
    resources_vpc_config: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_eks.CfnCluster_ResourcesVpcConfigPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description="The VPC configuration that's used by the cluster control plane. Amazon EKS VPC resources have specific requirements to work properly with Kubernetes. For more information, see `Cluster VPC Considerations <https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html>`_ and `Cluster Security Group Considerations <https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html>`_ in the *Amazon EKS User Guide* . You must specify at least two subnets. You can specify up to five security groups, but we recommend that you use a dedicated security group for your cluster control plane.\n")
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the IAM role that provides permissions for the Kubernetes control plane to make calls to AWS API operations on your behalf. For more information, see `Amazon EKS Service IAM Role <https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html>`_ in the **Amazon EKS User Guide** .\n')
    access_config: typing.Union[models.UnsupportedResource, models.aws_eks.CfnCluster_AccessConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The access configuration for the cluster.\n')
    bootstrap_self_managed_addons: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='If you set this value to ``False`` when creating a cluster, the default networking add-ons will not be installed. The default networking addons include vpc-cni, coredns, and kube-proxy. Use this option when you plan to install third-party alternative add-ons or self-manage the default networking add-ons.\n')
    encryption_config: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_eks.CfnCluster_EncryptionConfigPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The encryption configuration for the cluster.\n')
    kubernetes_network_config: typing.Union[models.UnsupportedResource, models.aws_eks.CfnCluster_KubernetesNetworkConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The Kubernetes network configuration for the cluster.\n')
    logging: typing.Union[models.UnsupportedResource, models.aws_eks.CfnCluster_LoggingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The logging configuration for your cluster.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The unique name to give to your cluster.\n')
    outpost_config: typing.Union[models.UnsupportedResource, models.aws_eks.CfnCluster_OutpostConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="An object representing the configuration of your local Amazon EKS cluster on an AWS Outpost. This object isn't available for clusters on the AWS cloud.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="The metadata that you apply to the cluster to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Cluster tags don't propagate to any other resources associated with the cluster. .. epigraph:: You must have the ``eks:TagResource`` and ``eks:UntagResource`` permissions for your `IAM principal <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_terms-and-concepts.html>`_ to manage the AWS CloudFormation stack. If you don't have these permissions, there might be unexpected behavior with stack-level tags propagating to the resource during resource creation and update.\n")
    version: typing.Optional[str] = pydantic.Field(None, description="The desired Kubernetes version for your cluster. If you don't specify a value here, the default version available in Amazon EKS is used. .. epigraph:: The default version might not be the latest version available.")
    _init_params: typing.ClassVar[list[str]] = ['resources_vpc_config', 'role_arn', 'access_config', 'bootstrap_self_managed_addons', 'encryption_config', 'kubernetes_network_config', 'logging', 'name', 'outpost_config', 'tags', 'version']
    _method_names: typing.ClassVar[list[str]] = ['AccessConfigProperty', 'ClusterLoggingProperty', 'ControlPlanePlacementProperty', 'EncryptionConfigProperty', 'KubernetesNetworkConfigProperty', 'LoggingProperty', 'LoggingTypeConfigProperty', 'OutpostConfigProperty', 'ProviderProperty', 'ResourcesVpcConfigProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnCluster'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.CfnClusterDefConfig] = pydantic.Field(None)


class CfnClusterDefConfig(pydantic.BaseModel):
    AccessConfigProperty: typing.Optional[list[models.aws_eks.CfnClusterDefAccessconfigpropertyParams]] = pydantic.Field(None, description='')
    ClusterLoggingProperty: typing.Optional[list[models.aws_eks.CfnClusterDefClusterloggingpropertyParams]] = pydantic.Field(None, description='')
    ControlPlanePlacementProperty: typing.Optional[list[models.aws_eks.CfnClusterDefControlplaneplacementpropertyParams]] = pydantic.Field(None, description='')
    EncryptionConfigProperty: typing.Optional[list[models.aws_eks.CfnClusterDefEncryptionconfigpropertyParams]] = pydantic.Field(None, description='')
    KubernetesNetworkConfigProperty: typing.Optional[list[models.aws_eks.CfnClusterDefKubernetesnetworkconfigpropertyParams]] = pydantic.Field(None, description='')
    LoggingProperty: typing.Optional[list[models.aws_eks.CfnClusterDefLoggingpropertyParams]] = pydantic.Field(None, description='')
    LoggingTypeConfigProperty: typing.Optional[list[models.aws_eks.CfnClusterDefLoggingtypeconfigpropertyParams]] = pydantic.Field(None, description='')
    OutpostConfigProperty: typing.Optional[list[models.aws_eks.CfnClusterDefOutpostconfigpropertyParams]] = pydantic.Field(None, description='')
    ProviderProperty: typing.Optional[list[models.aws_eks.CfnClusterDefProviderpropertyParams]] = pydantic.Field(None, description='')
    ResourcesVpcConfigProperty: typing.Optional[list[models.aws_eks.CfnClusterDefResourcesvpcconfigpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_eks.CfnClusterDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_eks.CfnClusterDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_eks.CfnClusterDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_eks.CfnClusterDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_eks.CfnClusterDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_eks.CfnClusterDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_eks.CfnClusterDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_eks.CfnClusterDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_eks.CfnClusterDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_eks.CfnClusterDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_eks.CfnClusterDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_eks.CfnClusterDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_eks.CfnClusterDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnClusterDefAccessconfigpropertyParams(pydantic.BaseModel):
    authentication_mode: typing.Optional[str] = pydantic.Field(None, description='')
    bootstrap_cluster_creator_admin_permissions: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnClusterDefClusterloggingpropertyParams(pydantic.BaseModel):
    enabled_types: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_eks.CfnCluster_LoggingTypeConfigPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnClusterDefControlplaneplacementpropertyParams(pydantic.BaseModel):
    group_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnClusterDefEncryptionconfigpropertyParams(pydantic.BaseModel):
    provider: typing.Union[models.UnsupportedResource, models.aws_eks.CfnCluster_ProviderPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnClusterDefKubernetesnetworkconfigpropertyParams(pydantic.BaseModel):
    ip_family: typing.Optional[str] = pydantic.Field(None, description='')
    service_ipv4_cidr: typing.Optional[str] = pydantic.Field(None, description='')
    service_ipv6_cidr: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnClusterDefLoggingpropertyParams(pydantic.BaseModel):
    cluster_logging: typing.Union[models.UnsupportedResource, models.aws_eks.CfnCluster_ClusterLoggingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnClusterDefLoggingtypeconfigpropertyParams(pydantic.BaseModel):
    type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnClusterDefOutpostconfigpropertyParams(pydantic.BaseModel):
    control_plane_instance_type: str = pydantic.Field(..., description='')
    outpost_arns: typing.Sequence[str] = pydantic.Field(..., description='')
    control_plane_placement: typing.Union[models.UnsupportedResource, models.aws_eks.CfnCluster_ControlPlanePlacementPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnClusterDefProviderpropertyParams(pydantic.BaseModel):
    key_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnClusterDefResourcesvpcconfigpropertyParams(pydantic.BaseModel):
    subnet_ids: typing.Sequence[str] = pydantic.Field(..., description='')
    endpoint_private_access: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    endpoint_public_access: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    public_access_cidrs: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnClusterDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnClusterDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnClusterDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnClusterDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnClusterDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnClusterDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnClusterDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnClusterDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnClusterDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnClusterDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnClusterDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnClusterDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnClusterDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnClusterDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_eks.CfnFargateProfile
class CfnFargateProfileDef(BaseCfnResource):
    cluster_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of your cluster.\n')
    pod_execution_role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the ``Pod`` execution role to use for a ``Pod`` that matches the selectors in the Fargate profile. The ``Pod`` execution role allows Fargate infrastructure to register with your cluster as a node, and it provides read access to Amazon ECR image repositories. For more information, see ```Pod`` execution role <https://docs.aws.amazon.com/eks/latest/userguide/pod-execution-role.html>`_ in the *Amazon EKS User Guide* .\n')
    selectors: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_eks.CfnFargateProfile_SelectorPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The selectors to match for a ``Pod`` to use this Fargate profile. Each selector must have an associated Kubernetes ``namespace`` . Optionally, you can also specify ``labels`` for a ``namespace`` . You may specify up to five selectors in a Fargate profile.\n')
    fargate_profile_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Fargate profile.\n')
    subnets: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The IDs of subnets to launch a ``Pod`` into. A ``Pod`` running on Fargate isn't assigned a public IP address, so only private subnets (with no direct route to an Internet Gateway) are accepted for this parameter.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or AWS resources.")
    _init_params: typing.ClassVar[list[str]] = ['cluster_name', 'pod_execution_role_arn', 'selectors', 'fargate_profile_name', 'subnets', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['LabelProperty', 'SelectorProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnFargateProfile'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.CfnFargateProfileDefConfig] = pydantic.Field(None)


class CfnFargateProfileDefConfig(pydantic.BaseModel):
    LabelProperty: typing.Optional[list[models.aws_eks.CfnFargateProfileDefLabelpropertyParams]] = pydantic.Field(None, description='')
    SelectorProperty: typing.Optional[list[models.aws_eks.CfnFargateProfileDefSelectorpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_eks.CfnFargateProfileDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_eks.CfnFargateProfileDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_eks.CfnFargateProfileDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_eks.CfnFargateProfileDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_eks.CfnFargateProfileDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_eks.CfnFargateProfileDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_eks.CfnFargateProfileDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_eks.CfnFargateProfileDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_eks.CfnFargateProfileDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_eks.CfnFargateProfileDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_eks.CfnFargateProfileDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_eks.CfnFargateProfileDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_eks.CfnFargateProfileDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnFargateProfileDefLabelpropertyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnFargateProfileDefSelectorpropertyParams(pydantic.BaseModel):
    namespace: str = pydantic.Field(..., description='')
    labels: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_eks.CfnFargateProfile_LabelPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnFargateProfileDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnFargateProfileDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFargateProfileDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnFargateProfileDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFargateProfileDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnFargateProfileDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnFargateProfileDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnFargateProfileDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnFargateProfileDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnFargateProfileDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFargateProfileDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnFargateProfileDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnFargateProfileDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFargateProfileDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_eks.CfnIdentityProviderConfig
class CfnIdentityProviderConfigDef(BaseCfnResource):
    cluster_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of your cluster.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of the identity provider configuration. The only type available is ``oidc`` .\n')
    identity_provider_config_name: typing.Optional[str] = pydantic.Field(None, description='The name of the configuration.\n')
    oidc: typing.Union[models.UnsupportedResource, models.aws_eks.CfnIdentityProviderConfig_OidcIdentityProviderConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object representing an OpenID Connect (OIDC) identity provider configuration.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or AWS resources.")
    _init_params: typing.ClassVar[list[str]] = ['cluster_name', 'type', 'identity_provider_config_name', 'oidc', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['OidcIdentityProviderConfigProperty', 'RequiredClaimProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnIdentityProviderConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.CfnIdentityProviderConfigDefConfig] = pydantic.Field(None)


class CfnIdentityProviderConfigDefConfig(pydantic.BaseModel):
    OidcIdentityProviderConfigProperty: typing.Optional[list[models.aws_eks.CfnIdentityProviderConfigDefOidcidentityproviderconfigpropertyParams]] = pydantic.Field(None, description='')
    RequiredClaimProperty: typing.Optional[list[models.aws_eks.CfnIdentityProviderConfigDefRequiredclaimpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_eks.CfnIdentityProviderConfigDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_eks.CfnIdentityProviderConfigDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_eks.CfnIdentityProviderConfigDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_eks.CfnIdentityProviderConfigDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_eks.CfnIdentityProviderConfigDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_eks.CfnIdentityProviderConfigDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_eks.CfnIdentityProviderConfigDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_eks.CfnIdentityProviderConfigDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_eks.CfnIdentityProviderConfigDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_eks.CfnIdentityProviderConfigDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_eks.CfnIdentityProviderConfigDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_eks.CfnIdentityProviderConfigDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_eks.CfnIdentityProviderConfigDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnIdentityProviderConfigDefOidcidentityproviderconfigpropertyParams(pydantic.BaseModel):
    client_id: str = pydantic.Field(..., description='')
    issuer_url: str = pydantic.Field(..., description='')
    groups_claim: typing.Optional[str] = pydantic.Field(None, description='')
    groups_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    required_claims: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_eks.CfnIdentityProviderConfig_RequiredClaimPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    username_claim: typing.Optional[str] = pydantic.Field(None, description='')
    username_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnIdentityProviderConfigDefRequiredclaimpropertyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnIdentityProviderConfigDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnIdentityProviderConfigDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIdentityProviderConfigDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnIdentityProviderConfigDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIdentityProviderConfigDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnIdentityProviderConfigDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnIdentityProviderConfigDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnIdentityProviderConfigDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnIdentityProviderConfigDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnIdentityProviderConfigDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIdentityProviderConfigDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnIdentityProviderConfigDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnIdentityProviderConfigDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIdentityProviderConfigDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_eks.CfnNodegroup
class CfnNodegroupDef(BaseCfnResource):
    cluster_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of your cluster.\n')
    node_role: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The Amazon Resource Name (ARN) of the IAM role to associate with your node group. The Amazon EKS worker node ``kubelet`` daemon makes calls to AWS APIs on your behalf. Nodes receive permissions for these API calls through an IAM instance profile and associated policies. Before you can launch nodes and register them into a cluster, you must create an IAM role for those nodes to use when they are launched. For more information, see `Amazon EKS node IAM role <https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html>`_ in the **Amazon EKS User Guide** . If you specify ``launchTemplate`` , then don't specify ``[IamInstanceProfile](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IamInstanceProfile.html)`` in your launch template, or the node group deployment will fail. For more information about using launch templates with Amazon EKS, see `Customizing managed nodes with launch templates <https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html>`_ in the *Amazon EKS User Guide* .\n")
    subnets: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The subnets to use for the Auto Scaling group that is created for your node group. If you specify ``launchTemplate`` , then don't specify ``[SubnetId](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateNetworkInterface.html)`` in your launch template, or the node group deployment will fail. For more information about using launch templates with Amazon EKS, see `Customizing managed nodes with launch templates <https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html>`_ in the *Amazon EKS User Guide* .\n")
    ami_type: typing.Optional[str] = pydantic.Field(None, description="The AMI type for your node group. If you specify ``launchTemplate`` , and your launch template uses a custom AMI, then don't specify ``amiType`` , or the node group deployment will fail. If your launch template uses a Windows custom AMI, then add ``eks:kube-proxy-windows`` to your Windows nodes ``rolearn`` in the ``aws-auth`` ``ConfigMap`` . For more information about using launch templates with Amazon EKS, see `Customizing managed nodes with launch templates <https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html>`_ in the *Amazon EKS User Guide* .\n")
    capacity_type: typing.Optional[str] = pydantic.Field(None, description='The capacity type of your managed node group.\n')
    disk_size: typing.Union[int, float, None] = pydantic.Field(None, description="The root device disk size (in GiB) for your node group instances. The default disk size is 20 GiB for Linux and Bottlerocket. The default disk size is 50 GiB for Windows. If you specify ``launchTemplate`` , then don't specify ``diskSize`` , or the node group deployment will fail. For more information about using launch templates with Amazon EKS, see `Customizing managed nodes with launch templates <https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html>`_ in the *Amazon EKS User Guide* .\n")
    force_update_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="Force the update if any ``Pod`` on the existing node group can't be drained due to a ``Pod`` disruption budget issue. If an update fails because all Pods can't be drained, you can force the update after it fails to terminate the old node whether or not any ``Pod`` is running on the node. Default: - false\n")
    instance_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="Specify the instance types for a node group. If you specify a GPU instance type, make sure to also specify an applicable GPU AMI type with the ``amiType`` parameter. If you specify ``launchTemplate`` , then you can specify zero or one instance type in your launch template *or* you can specify 0-20 instance types for ``instanceTypes`` . If however, you specify an instance type in your launch template *and* specify any ``instanceTypes`` , the node group deployment will fail. If you don't specify an instance type in a launch template or for ``instanceTypes`` , then ``t3.medium`` is used, by default. If you specify ``Spot`` for ``capacityType`` , then we recommend specifying multiple values for ``instanceTypes`` . For more information, see `Managed node group capacity types <https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html#managed-node-group-capacity-types>`_ and `Customizing managed nodes with launch templates <https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html>`_ in the *Amazon EKS User Guide* .\n")
    labels: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='The Kubernetes ``labels`` applied to the nodes in the node group. .. epigraph:: Only ``labels`` that are applied with the Amazon EKS API are shown here. There may be other Kubernetes ``labels`` applied to the nodes in this group.\n')
    launch_template: typing.Union[models.UnsupportedResource, models.aws_eks.CfnNodegroup_LaunchTemplateSpecificationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="An object representing a node group's launch template specification. When using this object, don't directly specify ``instanceTypes`` , ``diskSize`` , or ``remoteAccess`` . Make sure that the launch template meets the requirements in ``launchTemplateSpecification`` . Also refer to `Customizing managed nodes with launch templates <https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html>`_ in the *Amazon EKS User Guide* .\n")
    nodegroup_name: typing.Optional[str] = pydantic.Field(None, description='The unique name to give your node group.\n')
    release_version: typing.Optional[str] = pydantic.Field(None, description="The AMI version of the Amazon EKS optimized AMI to use with your node group (for example, ``1.14.7- *YYYYMMDD*`` ). By default, the latest available AMI version for the node group's current Kubernetes version is used. For more information, see `Amazon EKS optimized Linux AMI Versions <https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html>`_ in the *Amazon EKS User Guide* . .. epigraph:: Changing this value triggers an update of the node group if one is available. You can't update other properties at the same time as updating ``Release Version`` .\n")
    remote_access: typing.Union[models.UnsupportedResource, models.aws_eks.CfnNodegroup_RemoteAccessPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The remote access configuration to use with your node group. For Linux, the protocol is SSH. For Windows, the protocol is RDP. If you specify ``launchTemplate`` , then don't specify ``remoteAccess`` , or the node group deployment will fail. For more information about using launch templates with Amazon EKS, see `Customizing managed nodes with launch templates <https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html>`_ in the *Amazon EKS User Guide* .\n")
    scaling_config: typing.Union[models.UnsupportedResource, models.aws_eks.CfnNodegroup_ScalingConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The scaling configuration details for the Auto Scaling group that is created for your node group.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description="Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or AWS resources.\n")
    taints: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_eks.CfnNodegroup_TaintPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The Kubernetes taints to be applied to the nodes in the node group when they are created. Effect is one of ``No_Schedule`` , ``Prefer_No_Schedule`` , or ``No_Execute`` . Kubernetes taints can be used together with tolerations to control how workloads are scheduled to your nodes. For more information, see `Node taints on managed node groups <https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html>`_ .\n')
    update_config: typing.Union[models.UnsupportedResource, models.aws_eks.CfnNodegroup_UpdateConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The node group update configuration.\n')
    version: typing.Optional[str] = pydantic.Field(None, description="The Kubernetes version to use for your managed nodes. By default, the Kubernetes version of the cluster is used, and this is the only accepted specified value. If you specify ``launchTemplate`` , and your launch template uses a custom AMI, then don't specify ``version`` , or the node group deployment will fail. For more information about using launch templates with Amazon EKS, see `Launch template support <https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html>`_ in the *Amazon EKS User Guide* . .. epigraph:: You can't update other properties at the same time as updating ``Version`` .")
    _init_params: typing.ClassVar[list[str]] = ['cluster_name', 'node_role', 'subnets', 'ami_type', 'capacity_type', 'disk_size', 'force_update_enabled', 'instance_types', 'labels', 'launch_template', 'nodegroup_name', 'release_version', 'remote_access', 'scaling_config', 'tags', 'taints', 'update_config', 'version']
    _method_names: typing.ClassVar[list[str]] = ['LaunchTemplateSpecificationProperty', 'RemoteAccessProperty', 'ScalingConfigProperty', 'TaintProperty', 'UpdateConfigProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnNodegroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.CfnNodegroupDefConfig] = pydantic.Field(None)


class CfnNodegroupDefConfig(pydantic.BaseModel):
    LaunchTemplateSpecificationProperty: typing.Optional[list[models.aws_eks.CfnNodegroupDefLaunchtemplatespecificationpropertyParams]] = pydantic.Field(None, description='')
    RemoteAccessProperty: typing.Optional[list[models.aws_eks.CfnNodegroupDefRemoteaccesspropertyParams]] = pydantic.Field(None, description='')
    ScalingConfigProperty: typing.Optional[list[models.aws_eks.CfnNodegroupDefScalingconfigpropertyParams]] = pydantic.Field(None, description='')
    TaintProperty: typing.Optional[list[models.aws_eks.CfnNodegroupDefTaintpropertyParams]] = pydantic.Field(None, description='')
    UpdateConfigProperty: typing.Optional[list[models.aws_eks.CfnNodegroupDefUpdateconfigpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_eks.CfnNodegroupDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_eks.CfnNodegroupDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_eks.CfnNodegroupDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_eks.CfnNodegroupDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_eks.CfnNodegroupDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_eks.CfnNodegroupDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_eks.CfnNodegroupDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_eks.CfnNodegroupDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_eks.CfnNodegroupDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_eks.CfnNodegroupDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_eks.CfnNodegroupDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_eks.CfnNodegroupDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_eks.CfnNodegroupDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnNodegroupDefLaunchtemplatespecificationpropertyParams(pydantic.BaseModel):
    id: typing.Optional[str] = pydantic.Field(None, description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    version: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnNodegroupDefRemoteaccesspropertyParams(pydantic.BaseModel):
    ec2_ssh_key: str = pydantic.Field(..., description='')
    source_security_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnNodegroupDefScalingconfigpropertyParams(pydantic.BaseModel):
    desired_size: typing.Union[int, float, None] = pydantic.Field(None, description='')
    max_size: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min_size: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnNodegroupDefTaintpropertyParams(pydantic.BaseModel):
    effect: typing.Optional[str] = pydantic.Field(None, description='')
    key: typing.Optional[str] = pydantic.Field(None, description='')
    value: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnNodegroupDefUpdateconfigpropertyParams(pydantic.BaseModel):
    max_unavailable: typing.Union[int, float, None] = pydantic.Field(None, description='')
    max_unavailable_percentage: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnNodegroupDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnNodegroupDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNodegroupDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnNodegroupDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNodegroupDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnNodegroupDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnNodegroupDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnNodegroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnNodegroupDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnNodegroupDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNodegroupDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnNodegroupDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnNodegroupDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNodegroupDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_eks.CfnPodIdentityAssociation
class CfnPodIdentityAssociationDef(BaseCfnResource):
    cluster_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the cluster that the association is in.\n')
    namespace: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the Kubernetes namespace inside the cluster to create the association in. The service account and the pods that use the service account must be in this namespace.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the IAM role to associate with the service account. The EKS Pod Identity agent manages credentials to assume this role for applications in the containers in the pods that use this service account.\n')
    service_account: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the Kubernetes service account inside the cluster to associate the IAM credentials with.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or AWS resources. The following basic restrictions apply to tags: - Maximum number of tags per resource – 50 - For each resource, each tag key must be unique, and each tag key can have only one value. - Maximum key length – 128 Unicode characters in UTF-8 - Maximum value length – 256 Unicode characters in UTF-8 - If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : /")
    _init_params: typing.ClassVar[list[str]] = ['cluster_name', 'namespace', 'role_arn', 'service_account', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnPodIdentityAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_eks.CfnPodIdentityAssociationDefConfig] = pydantic.Field(None)


class CfnPodIdentityAssociationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_eks.CfnPodIdentityAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_eks.CfnPodIdentityAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_eks.CfnPodIdentityAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_eks.CfnPodIdentityAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_eks.CfnPodIdentityAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_eks.CfnPodIdentityAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_eks.CfnPodIdentityAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_eks.CfnPodIdentityAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_eks.CfnPodIdentityAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_eks.CfnPodIdentityAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_eks.CfnPodIdentityAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_eks.CfnPodIdentityAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_eks.CfnPodIdentityAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnPodIdentityAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPodIdentityAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPodIdentityAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPodIdentityAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPodIdentityAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPodIdentityAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPodIdentityAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPodIdentityAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPodIdentityAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPodIdentityAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPodIdentityAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnPodIdentityAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPodIdentityAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPodIdentityAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_eks.CfnAccessEntryProps
class CfnAccessEntryPropsDef(BaseCfnProperty):
    cluster_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of your cluster.\n')
    principal_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The ARN of the IAM principal for the ``AccessEntry`` . You can specify one ARN for each access entry. You can't specify the same ARN in more than one access entry. This value can't be changed after access entry creation. The valid principals differ depending on the type of the access entry in the ``type`` field. The only valid ARN is IAM roles for the types of access entries for nodes: `` `` . You can use every IAM principal type for ``STANDARD`` access entries. You can't use the STS session principal type with access entries because this is a temporary principal for each session and not a permanent identity that can be assigned permissions. `IAM best practices <https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#bp-users-federation-idp>`_ recommend using IAM roles with temporary credentials, rather than IAM users with long-term credentials.\n")
    access_policies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_eks.CfnAccessEntry_AccessPolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The access policies to associate to the access entry.\n')
    kubernetes_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The value for ``name`` that you've specified for ``kind: Group`` as a ``subject`` in a Kubernetes ``RoleBinding`` or ``ClusterRoleBinding`` object. Amazon EKS doesn't confirm that the value for ``name`` exists in any bindings on your cluster. You can specify one or more names. Kubernetes authorizes the ``principalArn`` of the access entry to access any cluster objects that you've specified in a Kubernetes ``Role`` or ``ClusterRole`` object that is also specified in a binding's ``roleRef`` . For more information about creating Kubernetes ``RoleBinding`` , ``ClusterRoleBinding`` , ``Role`` , or ``ClusterRole`` objects, see `Using RBAC Authorization in the Kubernetes documentation <https://docs.aws.amazon.com/https://kubernetes.io/docs/reference/access-authn-authz/rbac/>`_ . If you want Amazon EKS to authorize the ``principalArn`` (instead of, or in addition to Kubernetes authorizing the ``principalArn`` ), you can associate one or more access policies to the access entry using ``AssociateAccessPolicy`` . If you associate any access policies, the ``principalARN`` has all permissions assigned in the associated access policies and all permissions in any Kubernetes ``Role`` or ``ClusterRole`` objects that the group names are bound to.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or AWS resources.\n")
    type: typing.Optional[str] = pydantic.Field(None, description="The type of the new access entry. Valid values are ``Standard`` , ``FARGATE_LINUX`` , ``EC2_LINUX`` , and ``EC2_WINDOWS`` . If the ``principalArn`` is for an IAM role that's used for self-managed Amazon EC2 nodes, specify ``EC2_LINUX`` or ``EC2_WINDOWS`` . Amazon EKS grants the necessary permissions to the node for you. If the ``principalArn`` is for any other purpose, specify ``STANDARD`` . If you don't specify a value, Amazon EKS sets the value to ``STANDARD`` . It's unnecessary to create access entries for IAM roles used with Fargate profiles or managed Amazon EC2 nodes, because Amazon EKS creates entries in the ``aws-auth`` ``ConfigMap`` for the roles. You can't change this value once you've created the access entry. If you set the value to ``EC2_LINUX`` or ``EC2_WINDOWS`` , you can't specify values for ``kubernetesGroups`` , or associate an ``AccessPolicy`` to the access entry.\n")
    username: typing.Optional[str] = pydantic.Field(None, description='The username to authenticate to Kubernetes with. We recommend not specifying a username and letting Amazon EKS specify it for you. For more information about the value Amazon EKS specifies for you, or constraints before specifying your own username, see `Creating access entries <https://docs.aws.amazon.com/eks/latest/userguide/access-entries.html#creating-access-entries>`_ in the *Amazon EKS User Guide* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-eks-accessentry.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    cfn_access_entry_props = eks.CfnAccessEntryProps(\n        cluster_name="clusterName",\n        principal_arn="principalArn",\n\n        # the properties below are optional\n        access_policies=[eks.CfnAccessEntry.AccessPolicyProperty(\n            access_scope=eks.CfnAccessEntry.AccessScopeProperty(\n                type="type",\n\n                # the properties below are optional\n                namespaces=["namespaces"]\n            ),\n            policy_arn="policyArn"\n        )],\n        kubernetes_groups=["kubernetesGroups"],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        type="type",\n        username="username"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cluster_name', 'principal_arn', 'access_policies', 'kubernetes_groups', 'tags', 'type', 'username']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnAccessEntryProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnAddonProps
class CfnAddonPropsDef(BaseCfnProperty):
    addon_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the add-on.\n')
    cluster_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of your cluster.\n')
    addon_version: typing.Optional[str] = pydantic.Field(None, description='The version of the add-on.\n')
    configuration_values: typing.Optional[str] = pydantic.Field(None, description='The configuration values that you provided.\n')
    pod_identity_associations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_eks.CfnAddon_PodIdentityAssociationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An array of Pod Identity Assocations owned by the Addon. Each EKS Pod Identity association maps a role to a service account in a namespace in the cluster. For more information, see `Attach an IAM Role to an Amazon EKS add-on using Pod Identity <https://docs.aws.amazon.com/eks/latest/userguide/add-ons-iam.html>`_ in the EKS User Guide.\n')
    preserve_on_delete: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="Specifying this option preserves the add-on software on your cluster but Amazon EKS stops managing any settings for the add-on. If an IAM account is associated with the add-on, it isn't removed.\n")
    resolve_conflicts: typing.Optional[str] = pydantic.Field(None, description="How to resolve field value conflicts for an Amazon EKS add-on. Conflicts are handled based on the value you choose: - *None* – If the self-managed version of the add-on is installed on your cluster, Amazon EKS doesn't change the value. Creation of the add-on might fail. - *Overwrite* – If the self-managed version of the add-on is installed on your cluster and the Amazon EKS default value is different than the existing value, Amazon EKS changes the value to the Amazon EKS default value. - *Preserve* – This is similar to the NONE option. If the self-managed version of the add-on is installed on your cluster Amazon EKS doesn't change the add-on resource properties. Creation of the add-on might fail if conflicts are detected. This option works differently during the update operation. For more information, see `UpdateAddon <https://docs.aws.amazon.com/eks/latest/APIReference/API_UpdateAddon.html>`_ . If you don't currently have the self-managed version of the add-on installed on your cluster, the Amazon EKS add-on is installed. Amazon EKS sets all values to default values, regardless of the option that you specify.\n")
    service_account_role_arn: typing.Optional[str] = pydantic.Field(None, description="The Amazon Resource Name (ARN) of an existing IAM role to bind to the add-on's service account. The role must be assigned the IAM permissions required by the add-on. If you don't specify an existing IAM role, then the add-on uses the permissions assigned to the node IAM role. For more information, see `Amazon EKS node IAM role <https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html>`_ in the *Amazon EKS User Guide* . .. epigraph:: To specify an existing IAM role, you must have an IAM OpenID Connect (OIDC) provider created for your cluster. For more information, see `Enabling IAM roles for service accounts on your cluster <https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html>`_ in the *Amazon EKS User Guide* .\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The metadata that you apply to the add-on to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Add-on tags do not propagate to any other resources associated with the cluster.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-eks-addon.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    cfn_addon_props = eks.CfnAddonProps(\n        addon_name="addonName",\n        cluster_name="clusterName",\n\n        # the properties below are optional\n        addon_version="addonVersion",\n        configuration_values="configurationValues",\n        pod_identity_associations=[eks.CfnAddon.PodIdentityAssociationProperty(\n            role_arn="roleArn",\n            service_account="serviceAccount"\n        )],\n        preserve_on_delete=False,\n        resolve_conflicts="resolveConflicts",\n        service_account_role_arn="serviceAccountRoleArn",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['addon_name', 'cluster_name', 'addon_version', 'configuration_values', 'pod_identity_associations', 'preserve_on_delete', 'resolve_conflicts', 'service_account_role_arn', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnAddonProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnClusterProps
class CfnClusterPropsDef(BaseCfnProperty):
    resources_vpc_config: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_eks.CfnCluster_ResourcesVpcConfigPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description="The VPC configuration that's used by the cluster control plane. Amazon EKS VPC resources have specific requirements to work properly with Kubernetes. For more information, see `Cluster VPC Considerations <https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html>`_ and `Cluster Security Group Considerations <https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html>`_ in the *Amazon EKS User Guide* . You must specify at least two subnets. You can specify up to five security groups, but we recommend that you use a dedicated security group for your cluster control plane.\n")
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the IAM role that provides permissions for the Kubernetes control plane to make calls to AWS API operations on your behalf. For more information, see `Amazon EKS Service IAM Role <https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html>`_ in the **Amazon EKS User Guide** .\n')
    access_config: typing.Union[models.UnsupportedResource, models.aws_eks.CfnCluster_AccessConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The access configuration for the cluster.\n')
    bootstrap_self_managed_addons: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='If you set this value to ``False`` when creating a cluster, the default networking add-ons will not be installed. The default networking addons include vpc-cni, coredns, and kube-proxy. Use this option when you plan to install third-party alternative add-ons or self-manage the default networking add-ons.\n')
    encryption_config: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_eks.CfnCluster_EncryptionConfigPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The encryption configuration for the cluster.\n')
    kubernetes_network_config: typing.Union[models.UnsupportedResource, models.aws_eks.CfnCluster_KubernetesNetworkConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The Kubernetes network configuration for the cluster.\n')
    logging: typing.Union[models.UnsupportedResource, models.aws_eks.CfnCluster_LoggingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The logging configuration for your cluster.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The unique name to give to your cluster.\n')
    outpost_config: typing.Union[models.UnsupportedResource, models.aws_eks.CfnCluster_OutpostConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="An object representing the configuration of your local Amazon EKS cluster on an AWS Outpost. This object isn't available for clusters on the AWS cloud.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="The metadata that you apply to the cluster to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Cluster tags don't propagate to any other resources associated with the cluster. .. epigraph:: You must have the ``eks:TagResource`` and ``eks:UntagResource`` permissions for your `IAM principal <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_terms-and-concepts.html>`_ to manage the AWS CloudFormation stack. If you don't have these permissions, there might be unexpected behavior with stack-level tags propagating to the resource during resource creation and update.\n")
    version: typing.Optional[str] = pydantic.Field(None, description='The desired Kubernetes version for your cluster. If you don\'t specify a value here, the default version available in Amazon EKS is used. .. epigraph:: The default version might not be the latest version available.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-eks-cluster.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    cfn_cluster_props = eks.CfnClusterProps(\n        resources_vpc_config=eks.CfnCluster.ResourcesVpcConfigProperty(\n            subnet_ids=["subnetIds"],\n\n            # the properties below are optional\n            endpoint_private_access=False,\n            endpoint_public_access=False,\n            public_access_cidrs=["publicAccessCidrs"],\n            security_group_ids=["securityGroupIds"]\n        ),\n        role_arn="roleArn",\n\n        # the properties below are optional\n        access_config=eks.CfnCluster.AccessConfigProperty(\n            authentication_mode="authenticationMode",\n            bootstrap_cluster_creator_admin_permissions=False\n        ),\n        bootstrap_self_managed_addons=False,\n        encryption_config=[eks.CfnCluster.EncryptionConfigProperty(\n            provider=eks.CfnCluster.ProviderProperty(\n                key_arn="keyArn"\n            ),\n            resources=["resources"]\n        )],\n        kubernetes_network_config=eks.CfnCluster.KubernetesNetworkConfigProperty(\n            ip_family="ipFamily",\n            service_ipv4_cidr="serviceIpv4Cidr",\n            service_ipv6_cidr="serviceIpv6Cidr"\n        ),\n        logging=eks.CfnCluster.LoggingProperty(\n            cluster_logging=eks.CfnCluster.ClusterLoggingProperty(\n                enabled_types=[eks.CfnCluster.LoggingTypeConfigProperty(\n                    type="type"\n                )]\n            )\n        ),\n        name="name",\n        outpost_config=eks.CfnCluster.OutpostConfigProperty(\n            control_plane_instance_type="controlPlaneInstanceType",\n            outpost_arns=["outpostArns"],\n\n            # the properties below are optional\n            control_plane_placement=eks.CfnCluster.ControlPlanePlacementProperty(\n                group_name="groupName"\n            )\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        version="version"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resources_vpc_config', 'role_arn', 'access_config', 'bootstrap_self_managed_addons', 'encryption_config', 'kubernetes_network_config', 'logging', 'name', 'outpost_config', 'tags', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnClusterProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnFargateProfileProps
class CfnFargateProfilePropsDef(BaseCfnProperty):
    cluster_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of your cluster.\n')
    pod_execution_role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the ``Pod`` execution role to use for a ``Pod`` that matches the selectors in the Fargate profile. The ``Pod`` execution role allows Fargate infrastructure to register with your cluster as a node, and it provides read access to Amazon ECR image repositories. For more information, see ```Pod`` execution role <https://docs.aws.amazon.com/eks/latest/userguide/pod-execution-role.html>`_ in the *Amazon EKS User Guide* .\n')
    selectors: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_eks.CfnFargateProfile_SelectorPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The selectors to match for a ``Pod`` to use this Fargate profile. Each selector must have an associated Kubernetes ``namespace`` . Optionally, you can also specify ``labels`` for a ``namespace`` . You may specify up to five selectors in a Fargate profile.\n')
    fargate_profile_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Fargate profile.\n')
    subnets: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The IDs of subnets to launch a ``Pod`` into. A ``Pod`` running on Fargate isn't assigned a public IP address, so only private subnets (with no direct route to an Internet Gateway) are accepted for this parameter.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don\'t propagate to any other cluster or AWS resources.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-eks-fargateprofile.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    cfn_fargate_profile_props = eks.CfnFargateProfileProps(\n        cluster_name="clusterName",\n        pod_execution_role_arn="podExecutionRoleArn",\n        selectors=[eks.CfnFargateProfile.SelectorProperty(\n            namespace="namespace",\n\n            # the properties below are optional\n            labels=[eks.CfnFargateProfile.LabelProperty(\n                key="key",\n                value="value"\n            )]\n        )],\n\n        # the properties below are optional\n        fargate_profile_name="fargateProfileName",\n        subnets=["subnets"],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cluster_name', 'pod_execution_role_arn', 'selectors', 'fargate_profile_name', 'subnets', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnFargateProfileProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnIdentityProviderConfigProps
class CfnIdentityProviderConfigPropsDef(BaseCfnProperty):
    cluster_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of your cluster.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of the identity provider configuration. The only type available is ``oidc`` .\n')
    identity_provider_config_name: typing.Optional[str] = pydantic.Field(None, description='The name of the configuration.\n')
    oidc: typing.Union[models.UnsupportedResource, models.aws_eks.CfnIdentityProviderConfig_OidcIdentityProviderConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object representing an OpenID Connect (OIDC) identity provider configuration.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don\'t propagate to any other cluster or AWS resources.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-eks-identityproviderconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    cfn_identity_provider_config_props = eks.CfnIdentityProviderConfigProps(\n        cluster_name="clusterName",\n        type="type",\n\n        # the properties below are optional\n        identity_provider_config_name="identityProviderConfigName",\n        oidc=eks.CfnIdentityProviderConfig.OidcIdentityProviderConfigProperty(\n            client_id="clientId",\n            issuer_url="issuerUrl",\n\n            # the properties below are optional\n            groups_claim="groupsClaim",\n            groups_prefix="groupsPrefix",\n            required_claims=[eks.CfnIdentityProviderConfig.RequiredClaimProperty(\n                key="key",\n                value="value"\n            )],\n            username_claim="usernameClaim",\n            username_prefix="usernamePrefix"\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cluster_name', 'type', 'identity_provider_config_name', 'oidc', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnIdentityProviderConfigProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnNodegroupProps
class CfnNodegroupPropsDef(BaseCfnProperty):
    cluster_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of your cluster.\n')
    node_role: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The Amazon Resource Name (ARN) of the IAM role to associate with your node group. The Amazon EKS worker node ``kubelet`` daemon makes calls to AWS APIs on your behalf. Nodes receive permissions for these API calls through an IAM instance profile and associated policies. Before you can launch nodes and register them into a cluster, you must create an IAM role for those nodes to use when they are launched. For more information, see `Amazon EKS node IAM role <https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html>`_ in the **Amazon EKS User Guide** . If you specify ``launchTemplate`` , then don't specify ``[IamInstanceProfile](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IamInstanceProfile.html)`` in your launch template, or the node group deployment will fail. For more information about using launch templates with Amazon EKS, see `Customizing managed nodes with launch templates <https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html>`_ in the *Amazon EKS User Guide* .\n")
    subnets: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The subnets to use for the Auto Scaling group that is created for your node group. If you specify ``launchTemplate`` , then don't specify ``[SubnetId](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateNetworkInterface.html)`` in your launch template, or the node group deployment will fail. For more information about using launch templates with Amazon EKS, see `Customizing managed nodes with launch templates <https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html>`_ in the *Amazon EKS User Guide* .\n")
    ami_type: typing.Optional[str] = pydantic.Field(None, description="The AMI type for your node group. If you specify ``launchTemplate`` , and your launch template uses a custom AMI, then don't specify ``amiType`` , or the node group deployment will fail. If your launch template uses a Windows custom AMI, then add ``eks:kube-proxy-windows`` to your Windows nodes ``rolearn`` in the ``aws-auth`` ``ConfigMap`` . For more information about using launch templates with Amazon EKS, see `Customizing managed nodes with launch templates <https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html>`_ in the *Amazon EKS User Guide* .\n")
    capacity_type: typing.Optional[str] = pydantic.Field(None, description='The capacity type of your managed node group.\n')
    disk_size: typing.Union[int, float, None] = pydantic.Field(None, description="The root device disk size (in GiB) for your node group instances. The default disk size is 20 GiB for Linux and Bottlerocket. The default disk size is 50 GiB for Windows. If you specify ``launchTemplate`` , then don't specify ``diskSize`` , or the node group deployment will fail. For more information about using launch templates with Amazon EKS, see `Customizing managed nodes with launch templates <https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html>`_ in the *Amazon EKS User Guide* .\n")
    force_update_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="Force the update if any ``Pod`` on the existing node group can't be drained due to a ``Pod`` disruption budget issue. If an update fails because all Pods can't be drained, you can force the update after it fails to terminate the old node whether or not any ``Pod`` is running on the node. Default: - false\n")
    instance_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="Specify the instance types for a node group. If you specify a GPU instance type, make sure to also specify an applicable GPU AMI type with the ``amiType`` parameter. If you specify ``launchTemplate`` , then you can specify zero or one instance type in your launch template *or* you can specify 0-20 instance types for ``instanceTypes`` . If however, you specify an instance type in your launch template *and* specify any ``instanceTypes`` , the node group deployment will fail. If you don't specify an instance type in a launch template or for ``instanceTypes`` , then ``t3.medium`` is used, by default. If you specify ``Spot`` for ``capacityType`` , then we recommend specifying multiple values for ``instanceTypes`` . For more information, see `Managed node group capacity types <https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html#managed-node-group-capacity-types>`_ and `Customizing managed nodes with launch templates <https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html>`_ in the *Amazon EKS User Guide* .\n")
    labels: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='The Kubernetes ``labels`` applied to the nodes in the node group. .. epigraph:: Only ``labels`` that are applied with the Amazon EKS API are shown here. There may be other Kubernetes ``labels`` applied to the nodes in this group.\n')
    launch_template: typing.Union[models.UnsupportedResource, models.aws_eks.CfnNodegroup_LaunchTemplateSpecificationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="An object representing a node group's launch template specification. When using this object, don't directly specify ``instanceTypes`` , ``diskSize`` , or ``remoteAccess`` . Make sure that the launch template meets the requirements in ``launchTemplateSpecification`` . Also refer to `Customizing managed nodes with launch templates <https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html>`_ in the *Amazon EKS User Guide* .\n")
    nodegroup_name: typing.Optional[str] = pydantic.Field(None, description='The unique name to give your node group.\n')
    release_version: typing.Optional[str] = pydantic.Field(None, description="The AMI version of the Amazon EKS optimized AMI to use with your node group (for example, ``1.14.7- *YYYYMMDD*`` ). By default, the latest available AMI version for the node group's current Kubernetes version is used. For more information, see `Amazon EKS optimized Linux AMI Versions <https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html>`_ in the *Amazon EKS User Guide* . .. epigraph:: Changing this value triggers an update of the node group if one is available. You can't update other properties at the same time as updating ``Release Version`` .\n")
    remote_access: typing.Union[models.UnsupportedResource, models.aws_eks.CfnNodegroup_RemoteAccessPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The remote access configuration to use with your node group. For Linux, the protocol is SSH. For Windows, the protocol is RDP. If you specify ``launchTemplate`` , then don't specify ``remoteAccess`` , or the node group deployment will fail. For more information about using launch templates with Amazon EKS, see `Customizing managed nodes with launch templates <https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html>`_ in the *Amazon EKS User Guide* .\n")
    scaling_config: typing.Union[models.UnsupportedResource, models.aws_eks.CfnNodegroup_ScalingConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The scaling configuration details for the Auto Scaling group that is created for your node group.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description="Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or AWS resources.\n")
    taints: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_eks.CfnNodegroup_TaintPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The Kubernetes taints to be applied to the nodes in the node group when they are created. Effect is one of ``No_Schedule`` , ``Prefer_No_Schedule`` , or ``No_Execute`` . Kubernetes taints can be used together with tolerations to control how workloads are scheduled to your nodes. For more information, see `Node taints on managed node groups <https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html>`_ .\n')
    update_config: typing.Union[models.UnsupportedResource, models.aws_eks.CfnNodegroup_UpdateConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The node group update configuration.\n')
    version: typing.Optional[str] = pydantic.Field(None, description='The Kubernetes version to use for your managed nodes. By default, the Kubernetes version of the cluster is used, and this is the only accepted specified value. If you specify ``launchTemplate`` , and your launch template uses a custom AMI, then don\'t specify ``version`` , or the node group deployment will fail. For more information about using launch templates with Amazon EKS, see `Launch template support <https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html>`_ in the *Amazon EKS User Guide* . .. epigraph:: You can\'t update other properties at the same time as updating ``Version`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-eks-nodegroup.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    cfn_nodegroup_props = eks.CfnNodegroupProps(\n        cluster_name="clusterName",\n        node_role="nodeRole",\n        subnets=["subnets"],\n\n        # the properties below are optional\n        ami_type="amiType",\n        capacity_type="capacityType",\n        disk_size=123,\n        force_update_enabled=False,\n        instance_types=["instanceTypes"],\n        labels={\n            "labels_key": "labels"\n        },\n        launch_template=eks.CfnNodegroup.LaunchTemplateSpecificationProperty(\n            id="id",\n            name="name",\n            version="version"\n        ),\n        nodegroup_name="nodegroupName",\n        release_version="releaseVersion",\n        remote_access=eks.CfnNodegroup.RemoteAccessProperty(\n            ec2_ssh_key="ec2SshKey",\n\n            # the properties below are optional\n            source_security_groups=["sourceSecurityGroups"]\n        ),\n        scaling_config=eks.CfnNodegroup.ScalingConfigProperty(\n            desired_size=123,\n            max_size=123,\n            min_size=123\n        ),\n        tags={\n            "tags_key": "tags"\n        },\n        taints=[eks.CfnNodegroup.TaintProperty(\n            effect="effect",\n            key="key",\n            value="value"\n        )],\n        update_config=eks.CfnNodegroup.UpdateConfigProperty(\n            max_unavailable=123,\n            max_unavailable_percentage=123\n        ),\n        version="version"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cluster_name', 'node_role', 'subnets', 'ami_type', 'capacity_type', 'disk_size', 'force_update_enabled', 'instance_types', 'labels', 'launch_template', 'nodegroup_name', 'release_version', 'remote_access', 'scaling_config', 'tags', 'taints', 'update_config', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnNodegroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_eks.CfnPodIdentityAssociationProps
class CfnPodIdentityAssociationPropsDef(BaseCfnProperty):
    cluster_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the cluster that the association is in.\n')
    namespace: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the Kubernetes namespace inside the cluster to create the association in. The service account and the pods that use the service account must be in this namespace.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the IAM role to associate with the service account. The EKS Pod Identity agent manages credentials to assume this role for applications in the containers in the pods that use this service account.\n')
    service_account: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the Kubernetes service account inside the cluster to associate the IAM credentials with.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don\'t propagate to any other cluster or AWS resources. The following basic restrictions apply to tags: - Maximum number of tags per resource – 50 - For each resource, each tag key must be unique, and each tag key can have only one value. - Maximum key length – 128 Unicode characters in UTF-8 - Maximum value length – 256 Unicode characters in UTF-8 - If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : /\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-eks-podidentityassociation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_eks as eks\n\n    cfn_pod_identity_association_props = eks.CfnPodIdentityAssociationProps(\n        cluster_name="clusterName",\n        namespace="namespace",\n        role_arn="roleArn",\n        service_account="serviceAccount",\n\n        # the properties below are optional\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cluster_name', 'namespace', 'role_arn', 'service_account', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_eks.CfnPodIdentityAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    AccessPolicy: typing.Optional[dict[str, models.aws_eks.AccessPolicyDef]] = pydantic.Field(None)
    AccessPolicyArn: typing.Optional[dict[str, models.aws_eks.AccessPolicyArnDef]] = pydantic.Field(None)
    AlbControllerVersion: typing.Optional[dict[str, models.aws_eks.AlbControllerVersionDef]] = pydantic.Field(None)
    EksOptimizedImage: typing.Optional[dict[str, models.aws_eks.EksOptimizedImageDef]] = pydantic.Field(None)
    EndpointAccess: typing.Optional[dict[str, models.aws_eks.EndpointAccessDef]] = pydantic.Field(None)
    KubernetesVersion: typing.Optional[dict[str, models.aws_eks.KubernetesVersionDef]] = pydantic.Field(None)
    AccessEntry: typing.Optional[dict[str, models.aws_eks.AccessEntryDef]] = pydantic.Field(None)
    AlbController: typing.Optional[dict[str, models.aws_eks.AlbControllerDef]] = pydantic.Field(None)
    AwsAuth: typing.Optional[dict[str, models.aws_eks.AwsAuthDef]] = pydantic.Field(None)
    Cluster: typing.Optional[dict[str, models.aws_eks.ClusterDef]] = pydantic.Field(None)
    FargateCluster: typing.Optional[dict[str, models.aws_eks.FargateClusterDef]] = pydantic.Field(None)
    FargateProfile: typing.Optional[dict[str, models.aws_eks.FargateProfileDef]] = pydantic.Field(None)
    HelmChart: typing.Optional[dict[str, models.aws_eks.HelmChartDef]] = pydantic.Field(None)
    KubectlProvider: typing.Optional[dict[str, models.aws_eks.KubectlProviderDef]] = pydantic.Field(None)
    KubernetesManifest: typing.Optional[dict[str, models.aws_eks.KubernetesManifestDef]] = pydantic.Field(None)
    KubernetesObjectValue: typing.Optional[dict[str, models.aws_eks.KubernetesObjectValueDef]] = pydantic.Field(None)
    KubernetesPatch: typing.Optional[dict[str, models.aws_eks.KubernetesPatchDef]] = pydantic.Field(None)
    Nodegroup: typing.Optional[dict[str, models.aws_eks.NodegroupDef]] = pydantic.Field(None)
    OpenIdConnectProvider: typing.Optional[dict[str, models.aws_eks.OpenIdConnectProviderDef]] = pydantic.Field(None)
    ServiceAccount: typing.Optional[dict[str, models.aws_eks.ServiceAccountDef]] = pydantic.Field(None)
    AccessEntryAttributes: typing.Optional[dict[str, models.aws_eks.AccessEntryAttributesDef]] = pydantic.Field(None)
    AccessEntryProps: typing.Optional[dict[str, models.aws_eks.AccessEntryPropsDef]] = pydantic.Field(None)
    AccessPolicyNameOptions: typing.Optional[dict[str, models.aws_eks.AccessPolicyNameOptionsDef]] = pydantic.Field(None)
    AccessPolicyProps: typing.Optional[dict[str, models.aws_eks.AccessPolicyPropsDef]] = pydantic.Field(None)
    AccessScope: typing.Optional[dict[str, models.aws_eks.AccessScopeDef]] = pydantic.Field(None)
    AlbControllerOptions: typing.Optional[dict[str, models.aws_eks.AlbControllerOptionsDef]] = pydantic.Field(None)
    AlbControllerProps: typing.Optional[dict[str, models.aws_eks.AlbControllerPropsDef]] = pydantic.Field(None)
    AutoScalingGroupCapacityOptions: typing.Optional[dict[str, models.aws_eks.AutoScalingGroupCapacityOptionsDef]] = pydantic.Field(None)
    AutoScalingGroupOptions: typing.Optional[dict[str, models.aws_eks.AutoScalingGroupOptionsDef]] = pydantic.Field(None)
    AwsAuthMapping: typing.Optional[dict[str, models.aws_eks.AwsAuthMappingDef]] = pydantic.Field(None)
    AwsAuthProps: typing.Optional[dict[str, models.aws_eks.AwsAuthPropsDef]] = pydantic.Field(None)
    BootstrapOptions: typing.Optional[dict[str, models.aws_eks.BootstrapOptionsDef]] = pydantic.Field(None)
    CfnAccessEntry_AccessPolicyProperty: typing.Optional[dict[str, models.aws_eks.CfnAccessEntry_AccessPolicyPropertyDef]] = pydantic.Field(None)
    CfnAccessEntry_AccessScopeProperty: typing.Optional[dict[str, models.aws_eks.CfnAccessEntry_AccessScopePropertyDef]] = pydantic.Field(None)
    CfnAddon_PodIdentityAssociationProperty: typing.Optional[dict[str, models.aws_eks.CfnAddon_PodIdentityAssociationPropertyDef]] = pydantic.Field(None)
    CfnCluster_AccessConfigProperty: typing.Optional[dict[str, models.aws_eks.CfnCluster_AccessConfigPropertyDef]] = pydantic.Field(None)
    CfnCluster_ClusterLoggingProperty: typing.Optional[dict[str, models.aws_eks.CfnCluster_ClusterLoggingPropertyDef]] = pydantic.Field(None)
    CfnCluster_ControlPlanePlacementProperty: typing.Optional[dict[str, models.aws_eks.CfnCluster_ControlPlanePlacementPropertyDef]] = pydantic.Field(None)
    CfnCluster_EncryptionConfigProperty: typing.Optional[dict[str, models.aws_eks.CfnCluster_EncryptionConfigPropertyDef]] = pydantic.Field(None)
    CfnCluster_KubernetesNetworkConfigProperty: typing.Optional[dict[str, models.aws_eks.CfnCluster_KubernetesNetworkConfigPropertyDef]] = pydantic.Field(None)
    CfnCluster_LoggingProperty: typing.Optional[dict[str, models.aws_eks.CfnCluster_LoggingPropertyDef]] = pydantic.Field(None)
    CfnCluster_LoggingTypeConfigProperty: typing.Optional[dict[str, models.aws_eks.CfnCluster_LoggingTypeConfigPropertyDef]] = pydantic.Field(None)
    CfnCluster_OutpostConfigProperty: typing.Optional[dict[str, models.aws_eks.CfnCluster_OutpostConfigPropertyDef]] = pydantic.Field(None)
    CfnCluster_ProviderProperty: typing.Optional[dict[str, models.aws_eks.CfnCluster_ProviderPropertyDef]] = pydantic.Field(None)
    CfnCluster_ResourcesVpcConfigProperty: typing.Optional[dict[str, models.aws_eks.CfnCluster_ResourcesVpcConfigPropertyDef]] = pydantic.Field(None)
    CfnFargateProfile_LabelProperty: typing.Optional[dict[str, models.aws_eks.CfnFargateProfile_LabelPropertyDef]] = pydantic.Field(None)
    CfnFargateProfile_SelectorProperty: typing.Optional[dict[str, models.aws_eks.CfnFargateProfile_SelectorPropertyDef]] = pydantic.Field(None)
    CfnIdentityProviderConfig_OidcIdentityProviderConfigProperty: typing.Optional[dict[str, models.aws_eks.CfnIdentityProviderConfig_OidcIdentityProviderConfigPropertyDef]] = pydantic.Field(None)
    CfnIdentityProviderConfig_RequiredClaimProperty: typing.Optional[dict[str, models.aws_eks.CfnIdentityProviderConfig_RequiredClaimPropertyDef]] = pydantic.Field(None)
    CfnNodegroup_LaunchTemplateSpecificationProperty: typing.Optional[dict[str, models.aws_eks.CfnNodegroup_LaunchTemplateSpecificationPropertyDef]] = pydantic.Field(None)
    CfnNodegroup_RemoteAccessProperty: typing.Optional[dict[str, models.aws_eks.CfnNodegroup_RemoteAccessPropertyDef]] = pydantic.Field(None)
    CfnNodegroup_ScalingConfigProperty: typing.Optional[dict[str, models.aws_eks.CfnNodegroup_ScalingConfigPropertyDef]] = pydantic.Field(None)
    CfnNodegroup_TaintProperty: typing.Optional[dict[str, models.aws_eks.CfnNodegroup_TaintPropertyDef]] = pydantic.Field(None)
    CfnNodegroup_UpdateConfigProperty: typing.Optional[dict[str, models.aws_eks.CfnNodegroup_UpdateConfigPropertyDef]] = pydantic.Field(None)
    ClusterAttributes: typing.Optional[dict[str, models.aws_eks.ClusterAttributesDef]] = pydantic.Field(None)
    ClusterOptions: typing.Optional[dict[str, models.aws_eks.ClusterOptionsDef]] = pydantic.Field(None)
    ClusterProps: typing.Optional[dict[str, models.aws_eks.ClusterPropsDef]] = pydantic.Field(None)
    CommonClusterOptions: typing.Optional[dict[str, models.aws_eks.CommonClusterOptionsDef]] = pydantic.Field(None)
    EksOptimizedImageProps: typing.Optional[dict[str, models.aws_eks.EksOptimizedImagePropsDef]] = pydantic.Field(None)
    FargateClusterProps: typing.Optional[dict[str, models.aws_eks.FargateClusterPropsDef]] = pydantic.Field(None)
    FargateProfileOptions: typing.Optional[dict[str, models.aws_eks.FargateProfileOptionsDef]] = pydantic.Field(None)
    FargateProfileProps: typing.Optional[dict[str, models.aws_eks.FargateProfilePropsDef]] = pydantic.Field(None)
    HelmChartOptions: typing.Optional[dict[str, models.aws_eks.HelmChartOptionsDef]] = pydantic.Field(None)
    HelmChartProps: typing.Optional[dict[str, models.aws_eks.HelmChartPropsDef]] = pydantic.Field(None)
    IngressLoadBalancerAddressOptions: typing.Optional[dict[str, models.aws_eks.IngressLoadBalancerAddressOptionsDef]] = pydantic.Field(None)
    KubectlProviderAttributes: typing.Optional[dict[str, models.aws_eks.KubectlProviderAttributesDef]] = pydantic.Field(None)
    KubectlProviderProps: typing.Optional[dict[str, models.aws_eks.KubectlProviderPropsDef]] = pydantic.Field(None)
    KubernetesManifestOptions: typing.Optional[dict[str, models.aws_eks.KubernetesManifestOptionsDef]] = pydantic.Field(None)
    KubernetesManifestProps: typing.Optional[dict[str, models.aws_eks.KubernetesManifestPropsDef]] = pydantic.Field(None)
    KubernetesObjectValueProps: typing.Optional[dict[str, models.aws_eks.KubernetesObjectValuePropsDef]] = pydantic.Field(None)
    KubernetesPatchProps: typing.Optional[dict[str, models.aws_eks.KubernetesPatchPropsDef]] = pydantic.Field(None)
    LaunchTemplateSpec: typing.Optional[dict[str, models.aws_eks.LaunchTemplateSpecDef]] = pydantic.Field(None)
    NodegroupOptions: typing.Optional[dict[str, models.aws_eks.NodegroupOptionsDef]] = pydantic.Field(None)
    NodegroupProps: typing.Optional[dict[str, models.aws_eks.NodegroupPropsDef]] = pydantic.Field(None)
    NodegroupRemoteAccess: typing.Optional[dict[str, models.aws_eks.NodegroupRemoteAccessDef]] = pydantic.Field(None)
    OpenIdConnectProviderProps: typing.Optional[dict[str, models.aws_eks.OpenIdConnectProviderPropsDef]] = pydantic.Field(None)
    Selector: typing.Optional[dict[str, models.aws_eks.SelectorDef]] = pydantic.Field(None)
    ServiceAccountOptions: typing.Optional[dict[str, models.aws_eks.ServiceAccountOptionsDef]] = pydantic.Field(None)
    ServiceAccountProps: typing.Optional[dict[str, models.aws_eks.ServiceAccountPropsDef]] = pydantic.Field(None)
    ServiceLoadBalancerAddressOptions: typing.Optional[dict[str, models.aws_eks.ServiceLoadBalancerAddressOptionsDef]] = pydantic.Field(None)
    TaintSpec: typing.Optional[dict[str, models.aws_eks.TaintSpecDef]] = pydantic.Field(None)
    CfnAccessEntry: typing.Optional[dict[str, models.aws_eks.CfnAccessEntryDef]] = pydantic.Field(None)
    CfnAddon: typing.Optional[dict[str, models.aws_eks.CfnAddonDef]] = pydantic.Field(None)
    CfnCluster: typing.Optional[dict[str, models.aws_eks.CfnClusterDef]] = pydantic.Field(None)
    CfnFargateProfile: typing.Optional[dict[str, models.aws_eks.CfnFargateProfileDef]] = pydantic.Field(None)
    CfnIdentityProviderConfig: typing.Optional[dict[str, models.aws_eks.CfnIdentityProviderConfigDef]] = pydantic.Field(None)
    CfnNodegroup: typing.Optional[dict[str, models.aws_eks.CfnNodegroupDef]] = pydantic.Field(None)
    CfnPodIdentityAssociation: typing.Optional[dict[str, models.aws_eks.CfnPodIdentityAssociationDef]] = pydantic.Field(None)
    CfnAccessEntryProps: typing.Optional[dict[str, models.aws_eks.CfnAccessEntryPropsDef]] = pydantic.Field(None)
    CfnAddonProps: typing.Optional[dict[str, models.aws_eks.CfnAddonPropsDef]] = pydantic.Field(None)
    CfnClusterProps: typing.Optional[dict[str, models.aws_eks.CfnClusterPropsDef]] = pydantic.Field(None)
    CfnFargateProfileProps: typing.Optional[dict[str, models.aws_eks.CfnFargateProfilePropsDef]] = pydantic.Field(None)
    CfnIdentityProviderConfigProps: typing.Optional[dict[str, models.aws_eks.CfnIdentityProviderConfigPropsDef]] = pydantic.Field(None)
    CfnNodegroupProps: typing.Optional[dict[str, models.aws_eks.CfnNodegroupPropsDef]] = pydantic.Field(None)
    CfnPodIdentityAssociationProps: typing.Optional[dict[str, models.aws_eks.CfnPodIdentityAssociationPropsDef]] = pydantic.Field(None)
    ...

import models
