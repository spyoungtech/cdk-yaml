from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_codecommit.Code
class CodeDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_asset', 'from_directory', 'from_zip_file']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codecommit.Code'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_asset', 'from_directory', 'from_zip_file']
    ...


    from_asset: typing.Optional[models.aws_codecommit.CodeDefFromAssetParams] = pydantic.Field(None, description='Code from user-supplied asset.')
    from_directory: typing.Optional[models.aws_codecommit.CodeDefFromDirectoryParams] = pydantic.Field(None, description='Code from directory.')
    from_zip_file: typing.Optional[models.aws_codecommit.CodeDefFromZipFileParams] = pydantic.Field(None, description='Code from preexisting ZIP file.')
    resource_config: typing.Optional[models.aws_codecommit.CodeDefConfig] = pydantic.Field(None)


class CodeDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[models.aws_codecommit.CodeDefBindParams]] = pydantic.Field(None, description="This method is called after a repository is passed this instance of Code in its 'code' property.")

class CodeDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the binding scope.')
    ...

class CodeDefFromAssetParams(pydantic.BaseModel):
    asset: models.aws_s3_assets.AssetDef = pydantic.Field(..., description='pre-existing asset.\n')
    branch: typing.Optional[str] = pydantic.Field(None, description='the name of the branch to create in the repository. Default is "main"')
    ...

class CodeDefFromDirectoryParams(pydantic.BaseModel):
    directory_path: str = pydantic.Field(..., description='the path to the local directory containing the contents to initialize the repository with.\n')
    branch: typing.Optional[str] = pydantic.Field(None, description='the name of the branch to create in the repository. Default is "main"')
    ...

class CodeDefFromZipFileParams(pydantic.BaseModel):
    file_path: str = pydantic.Field(..., description='the path to the local ZIP file containing the contents to initialize the repository with.\n')
    branch: typing.Optional[str] = pydantic.Field(None, description='the name of the branch to create in the repository. Default is "main"')
    ...


#  autogenerated from aws_cdk.aws_codecommit.ReferenceEvent
class ReferenceEventDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codecommit.ReferenceEvent'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codecommit.Repository
class RepositoryDef(BaseConstruct):
    repository_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Name of the repository. This property is required for all CodeCommit repositories.\n')
    code: typing.Optional[models.aws_codecommit.CodeDef] = pydantic.Field(None, description='The contents with which to initialize the repository after it has been created. Default: - No initialization (create empty repo)\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the repository. Use the description to identify the purpose of the repository. Default: - No description.')
    _init_params: typing.ClassVar[list[str]] = ['repository_name', 'code', 'description']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'bind_as_notification_rule_source', 'grant', 'grant_pull', 'grant_pull_push', 'grant_read', 'notifiy_on_pull_request_merged', 'notify', 'notify_on', 'notify_on_approval_rule_overridden', 'notify_on_approval_status_changed', 'notify_on_branch_or_tag_created', 'notify_on_branch_or_tag_deleted', 'notify_on_pull_request_comment', 'notify_on_pull_request_created', 'notify_on_pull_request_merged', 'on_comment_on_commit', 'on_comment_on_pull_request', 'on_commit', 'on_event', 'on_pull_request_state_change', 'on_reference_created', 'on_reference_deleted', 'on_reference_updated', 'on_state_change']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_repository_arn', 'from_repository_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codecommit.Repository'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_repository_arn', 'from_repository_name']
    ...


    from_repository_arn: typing.Optional[models.aws_codecommit.RepositoryDefFromRepositoryArnParams] = pydantic.Field(None, description='Imports a codecommit repository.')
    from_repository_name: typing.Optional[models.aws_codecommit.RepositoryDefFromRepositoryNameParams] = pydantic.Field(None, description='')
    resource_config: typing.Optional[models.aws_codecommit.RepositoryDefConfig] = pydantic.Field(None)


class RepositoryDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    bind_as_notification_rule_source: typing.Optional[list[models.aws_codecommit.RepositoryDefBindAsNotificationRuleSourceParams]] = pydantic.Field(None, description='Returns a source configuration for notification rule.')
    grant: typing.Optional[list[models.aws_codecommit.RepositoryDefGrantParams]] = pydantic.Field(None, description='Grant the given principal identity permissions to perform the actions on this repository.')
    grant_pull: typing.Optional[list[models.aws_codecommit.RepositoryDefGrantPullParams]] = pydantic.Field(None, description='Grant the given identity permissions to pull this repository.')
    grant_pull_push: typing.Optional[list[models.aws_codecommit.RepositoryDefGrantPullPushParams]] = pydantic.Field(None, description='Grant the given identity permissions to pull and push this repository.')
    grant_read: typing.Optional[list[models.aws_codecommit.RepositoryDefGrantReadParams]] = pydantic.Field(None, description='Grant the given identity permissions to read this repository.')
    notifiy_on_pull_request_merged: typing.Optional[list[models.aws_codecommit.RepositoryDefNotifiyOnPullRequestMergedParams]] = pydantic.Field(None, description='Defines a CodeStar Notification rule which triggers when a pull request is merged.')
    notify: typing.Optional[list[models.aws_codecommit.RepositoryDefNotifyParams]] = pydantic.Field(None, description='Create a trigger to notify another service to run actions on repository events.')
    notify_on: typing.Optional[list[models.aws_codecommit.RepositoryDefNotifyOnParams]] = pydantic.Field(None, description='Defines a CodeStar Notification rule triggered when the project events specified by you are emitted. Similar to ``onEvent`` API.\nYou can also use the methods to define rules for the specific event emitted.\neg: ``notifyOnPullRequstCreated``.')
    notify_on_approval_rule_overridden: typing.Optional[list[models.aws_codecommit.RepositoryDefNotifyOnApprovalRuleOverriddenParams]] = pydantic.Field(None, description='Defines a CodeStar Notification rule which triggers when an approval rule is overridden.')
    notify_on_approval_status_changed: typing.Optional[list[models.aws_codecommit.RepositoryDefNotifyOnApprovalStatusChangedParams]] = pydantic.Field(None, description='Defines a CodeStar Notification rule which triggers when an approval status is changed.')
    notify_on_branch_or_tag_created: typing.Optional[list[models.aws_codecommit.RepositoryDefNotifyOnBranchOrTagCreatedParams]] = pydantic.Field(None, description='Defines a CodeStar Notification rule which triggers when a new branch or tag is created.')
    notify_on_branch_or_tag_deleted: typing.Optional[list[models.aws_codecommit.RepositoryDefNotifyOnBranchOrTagDeletedParams]] = pydantic.Field(None, description='Defines a CodeStar Notification rule which triggers when a branch or tag is deleted.')
    notify_on_pull_request_comment: typing.Optional[list[models.aws_codecommit.RepositoryDefNotifyOnPullRequestCommentParams]] = pydantic.Field(None, description='Defines a CodeStar Notification rule which triggers when a comment is made on a pull request.')
    notify_on_pull_request_created: typing.Optional[list[models.aws_codecommit.RepositoryDefNotifyOnPullRequestCreatedParams]] = pydantic.Field(None, description='Defines a CodeStar Notification rule which triggers when a pull request is created.')
    notify_on_pull_request_merged: typing.Optional[list[models.aws_codecommit.RepositoryDefNotifyOnPullRequestMergedParams]] = pydantic.Field(None, description='Defines a CodeStar Notification rule which triggers when a pull request is merged.')
    on_comment_on_commit: typing.Optional[list[models.aws_codecommit.RepositoryDefOnCommentOnCommitParams]] = pydantic.Field(None, description='Defines a CloudWatch event rule which triggers when a comment is made on a commit.')
    on_comment_on_pull_request: typing.Optional[list[models.aws_codecommit.RepositoryDefOnCommentOnPullRequestParams]] = pydantic.Field(None, description='Defines a CloudWatch event rule which triggers when a comment is made on a pull request.')
    on_commit: typing.Optional[list[models.aws_codecommit.RepositoryDefOnCommitParams]] = pydantic.Field(None, description='Defines a CloudWatch event rule which triggers when a commit is pushed to a branch.')
    on_event: typing.Optional[list[models.aws_codecommit.RepositoryDefOnEventParams]] = pydantic.Field(None, description='Defines a CloudWatch event rule which triggers for repository events.\nUse\n``rule.addEventPattern(pattern)`` to specify a filter.')
    on_pull_request_state_change: typing.Optional[list[models.aws_codecommit.RepositoryDefOnPullRequestStateChangeParams]] = pydantic.Field(None, description='Defines a CloudWatch event rule which triggers when a pull request state is changed.')
    on_reference_created: typing.Optional[list[models.aws_codecommit.RepositoryDefOnReferenceCreatedParams]] = pydantic.Field(None, description='Defines a CloudWatch event rule which triggers when a reference is created (i.e. a new branch/tag is created) to the repository.')
    on_reference_deleted: typing.Optional[list[models.aws_codecommit.RepositoryDefOnReferenceDeletedParams]] = pydantic.Field(None, description='Defines a CloudWatch event rule which triggers when a reference is delete (i.e. a branch/tag is deleted) from the repository.')
    on_reference_updated: typing.Optional[list[models.aws_codecommit.RepositoryDefOnReferenceUpdatedParams]] = pydantic.Field(None, description='Defines a CloudWatch event rule which triggers when a reference is updated (i.e. a commit is pushed to an existing or new branch) from the repository.')
    on_state_change: typing.Optional[list[models.aws_codecommit.RepositoryDefOnStateChangeParams]] = pydantic.Field(None, description='Defines a CloudWatch event rule which triggers when a "CodeCommit Repository State Change" event occurs.')

class RepositoryDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class RepositoryDefBindAsNotificationRuleSourceParams(pydantic.BaseModel):
    ...

class RepositoryDefFromRepositoryArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    repository_arn: str = pydantic.Field(..., description='(e.g. ``arn:aws:codecommit:us-east-1:123456789012:MyDemoRepo``).')
    ...

class RepositoryDefFromRepositoryNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    id: str = pydantic.Field(..., description='-\n')
    repository_name: str = pydantic.Field(..., description='-')
    ...

class RepositoryDefGrantParams(pydantic.BaseModel):
    grantee: models.AnyResource = pydantic.Field(..., description='-\n')
    actions: list[str] = pydantic.Field(...)
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefGrantPullParams(pydantic.BaseModel):
    grantee: models.AnyResource = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefGrantPullPushParams(pydantic.BaseModel):
    grantee: models.AnyResource = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefGrantReadParams(pydantic.BaseModel):
    grantee: models.AnyResource = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefNotifiyOnPullRequestMergedParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: models.UnsupportedResource = pydantic.Field(..., description='-\n')
    detail_type: typing.Optional[aws_cdk.aws_codestarnotifications.DetailType] = pydantic.Field(None, description='The level of detail to include in the notifications for this resource. BASIC will include only the contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created. Default: DetailType.FULL\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description="The status of the notification rule. If the enabled is set to DISABLED, notifications aren't sent for the notification rule. Default: true\n")
    notification_rule_name: typing.Optional[str] = pydantic.Field(None, description='The name for the notification rule. Notification rule names must be unique in your AWS account. Default: - generated from the ``id``')
    return_config: typing.Optional[list[models._interface_methods.AwsCodestarnotificationsINotificationRuleDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefNotifyParams(pydantic.BaseModel):
    arn: str = pydantic.Field(..., description='Arn of the resource that repository events will notify.\n')
    branches: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The names of the branches in the AWS CodeCommit repository that contain events that you want to include in the trigger. If you don't specify at least one branch, the trigger applies to all branches.\n")
    custom_data: typing.Optional[str] = pydantic.Field(None, description='When an event is triggered, additional information that AWS CodeCommit includes when it sends information to the target.\n')
    events: typing.Optional[typing.Sequence[aws_cdk.aws_codecommit.RepositoryEventTrigger]] = pydantic.Field(None, description="The repository events for which AWS CodeCommit sends information to the target, which you specified in the DestinationArn property.If you don't specify events, the trigger runs for all repository events.\n")
    name: typing.Optional[str] = pydantic.Field(None, description='A name for the trigger.Triggers on a repository must have unique names.')
    return_config: typing.Optional[list[models.aws_codecommit.RepositoryDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefNotifyOnParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: models.UnsupportedResource = pydantic.Field(..., description='-\n')
    events: typing.Sequence[aws_cdk.aws_codecommit.RepositoryNotificationEvents] = pydantic.Field(..., description='A list of event types associated with this notification rule for CodeCommit repositories. For a complete list of event types and IDs, see Notification concepts in the Developer Tools Console User Guide.\n')
    detail_type: typing.Optional[aws_cdk.aws_codestarnotifications.DetailType] = pydantic.Field(None, description='The level of detail to include in the notifications for this resource. BASIC will include only the contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created. Default: DetailType.FULL\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description="The status of the notification rule. If the enabled is set to DISABLED, notifications aren't sent for the notification rule. Default: true\n")
    notification_rule_name: typing.Optional[str] = pydantic.Field(None, description='The name for the notification rule. Notification rule names must be unique in your AWS account. Default: - generated from the ``id``')
    return_config: typing.Optional[list[models._interface_methods.AwsCodestarnotificationsINotificationRuleDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefNotifyOnApprovalRuleOverriddenParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: models.UnsupportedResource = pydantic.Field(..., description='-\n')
    detail_type: typing.Optional[aws_cdk.aws_codestarnotifications.DetailType] = pydantic.Field(None, description='The level of detail to include in the notifications for this resource. BASIC will include only the contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created. Default: DetailType.FULL\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description="The status of the notification rule. If the enabled is set to DISABLED, notifications aren't sent for the notification rule. Default: true\n")
    notification_rule_name: typing.Optional[str] = pydantic.Field(None, description='The name for the notification rule. Notification rule names must be unique in your AWS account. Default: - generated from the ``id``')
    return_config: typing.Optional[list[models._interface_methods.AwsCodestarnotificationsINotificationRuleDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefNotifyOnApprovalStatusChangedParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: models.UnsupportedResource = pydantic.Field(..., description='-\n')
    detail_type: typing.Optional[aws_cdk.aws_codestarnotifications.DetailType] = pydantic.Field(None, description='The level of detail to include in the notifications for this resource. BASIC will include only the contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created. Default: DetailType.FULL\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description="The status of the notification rule. If the enabled is set to DISABLED, notifications aren't sent for the notification rule. Default: true\n")
    notification_rule_name: typing.Optional[str] = pydantic.Field(None, description='The name for the notification rule. Notification rule names must be unique in your AWS account. Default: - generated from the ``id``')
    return_config: typing.Optional[list[models._interface_methods.AwsCodestarnotificationsINotificationRuleDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefNotifyOnBranchOrTagCreatedParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: models.UnsupportedResource = pydantic.Field(..., description='-\n')
    detail_type: typing.Optional[aws_cdk.aws_codestarnotifications.DetailType] = pydantic.Field(None, description='The level of detail to include in the notifications for this resource. BASIC will include only the contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created. Default: DetailType.FULL\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description="The status of the notification rule. If the enabled is set to DISABLED, notifications aren't sent for the notification rule. Default: true\n")
    notification_rule_name: typing.Optional[str] = pydantic.Field(None, description='The name for the notification rule. Notification rule names must be unique in your AWS account. Default: - generated from the ``id``')
    return_config: typing.Optional[list[models._interface_methods.AwsCodestarnotificationsINotificationRuleDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefNotifyOnBranchOrTagDeletedParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: models.UnsupportedResource = pydantic.Field(..., description='-\n')
    detail_type: typing.Optional[aws_cdk.aws_codestarnotifications.DetailType] = pydantic.Field(None, description='The level of detail to include in the notifications for this resource. BASIC will include only the contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created. Default: DetailType.FULL\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description="The status of the notification rule. If the enabled is set to DISABLED, notifications aren't sent for the notification rule. Default: true\n")
    notification_rule_name: typing.Optional[str] = pydantic.Field(None, description='The name for the notification rule. Notification rule names must be unique in your AWS account. Default: - generated from the ``id``')
    return_config: typing.Optional[list[models._interface_methods.AwsCodestarnotificationsINotificationRuleDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefNotifyOnPullRequestCommentParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: models.UnsupportedResource = pydantic.Field(..., description='-\n')
    detail_type: typing.Optional[aws_cdk.aws_codestarnotifications.DetailType] = pydantic.Field(None, description='The level of detail to include in the notifications for this resource. BASIC will include only the contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created. Default: DetailType.FULL\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description="The status of the notification rule. If the enabled is set to DISABLED, notifications aren't sent for the notification rule. Default: true\n")
    notification_rule_name: typing.Optional[str] = pydantic.Field(None, description='The name for the notification rule. Notification rule names must be unique in your AWS account. Default: - generated from the ``id``')
    return_config: typing.Optional[list[models._interface_methods.AwsCodestarnotificationsINotificationRuleDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefNotifyOnPullRequestCreatedParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: models.UnsupportedResource = pydantic.Field(..., description='-\n')
    detail_type: typing.Optional[aws_cdk.aws_codestarnotifications.DetailType] = pydantic.Field(None, description='The level of detail to include in the notifications for this resource. BASIC will include only the contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created. Default: DetailType.FULL\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description="The status of the notification rule. If the enabled is set to DISABLED, notifications aren't sent for the notification rule. Default: true\n")
    notification_rule_name: typing.Optional[str] = pydantic.Field(None, description='The name for the notification rule. Notification rule names must be unique in your AWS account. Default: - generated from the ``id``')
    return_config: typing.Optional[list[models._interface_methods.AwsCodestarnotificationsINotificationRuleDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefNotifyOnPullRequestMergedParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: models.UnsupportedResource = pydantic.Field(..., description='-\n')
    detail_type: typing.Optional[aws_cdk.aws_codestarnotifications.DetailType] = pydantic.Field(None, description='The level of detail to include in the notifications for this resource. BASIC will include only the contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created. Default: DetailType.FULL\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description="The status of the notification rule. If the enabled is set to DISABLED, notifications aren't sent for the notification rule. Default: true\n")
    notification_rule_name: typing.Optional[str] = pydantic.Field(None, description='The name for the notification rule. Notification rule names must be unique in your AWS account. Default: - generated from the ``id``')
    return_config: typing.Optional[list[models._interface_methods.AwsCodestarnotificationsINotificationRuleDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefOnCommentOnCommitParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefOnCommentOnPullRequestParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefOnCommitParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    branches: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The branch to monitor. Default: - All branches\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefOnEventParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefOnPullRequestStateChangeParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefOnReferenceCreatedParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefOnReferenceDeletedParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefOnReferenceUpdatedParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class RepositoryDefOnStateChangeParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_codecommit.CfnRepository.CodeProperty
class CfnRepository_CodePropertyDef(BaseStruct):
    s3: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_codecommit.CfnRepository_S3PropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Information about the Amazon S3 bucket that contains a ZIP file of code to be committed to the repository. Changes to this property are ignored after initial resource creation.\n')
    branch_name: typing.Optional[str] = pydantic.Field(None, description='Optional. Specifies a branch name to be used as the default branch when importing code into a repository on initial creation. If this property is not set, the name *main* will be used for the default branch for the repository. Changes to this property are ignored after initial resource creation. We recommend using this parameter to set the name to *main* to align with the default behavior of CodeCommit unless another name is needed.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codecommit-repository-code.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codecommit as codecommit\n\n    code_property = codecommit.CfnRepository.CodeProperty(\n        s3=codecommit.CfnRepository.S3Property(\n            bucket="bucket",\n            key="key",\n\n            # the properties below are optional\n            object_version="objectVersion"\n        ),\n\n        # the properties below are optional\n        branch_name="branchName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['s3', 'branch_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codecommit.CfnRepository.CodeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codecommit.CfnRepository.RepositoryTriggerProperty
class CfnRepository_RepositoryTriggerPropertyDef(BaseStruct):
    destination_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the resource that is the target for a trigger (for example, the ARN of a topic in Amazon SNS).\n')
    events: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The repository events that cause the trigger to run actions in another service, such as sending a notification through Amazon SNS. .. epigraph:: The valid value "all" cannot be used with any other values.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the trigger.\n')
    branches: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The branches to be included in the trigger configuration. If you specify an empty array, the trigger applies to all branches. .. epigraph:: Although no content is required in the array, you must include the array itself.\n')
    custom_data: typing.Optional[str] = pydantic.Field(None, description='Any custom data associated with the trigger to be included in the information sent to the target of the trigger.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codecommit-repository-repositorytrigger.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codecommit as codecommit\n\n    repository_trigger_property = codecommit.CfnRepository.RepositoryTriggerProperty(\n        destination_arn="destinationArn",\n        events=["events"],\n        name="name",\n\n        # the properties below are optional\n        branches=["branches"],\n        custom_data="customData"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_arn', 'events', 'name', 'branches', 'custom_data']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codecommit.CfnRepository.RepositoryTriggerProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codecommit.CfnRepository.S3Property
class CfnRepository_S3PropertyDef(BaseStruct):
    bucket: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the Amazon S3 bucket that contains the ZIP file with the content that will be committed to the new repository. This can be specified using the name of the bucket in the AWS account . Changes to this property are ignored after initial resource creation.\n')
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The key to use for accessing the Amazon S3 bucket. Changes to this property are ignored after initial resource creation. For more information, see `Creating object key names <https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html>`_ and `Uploading objects <https://docs.aws.amazon.com/AmazonS3/latest/userguide/upload-objects.html>`_ in the Amazon S3 User Guide.\n')
    object_version: typing.Optional[str] = pydantic.Field(None, description='The object version of the ZIP file, if versioning is enabled for the Amazon S3 bucket. Changes to this property are ignored after initial resource creation.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codecommit-repository-s3.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codecommit as codecommit\n\n    s3_property = codecommit.CfnRepository.S3Property(\n        bucket="bucket",\n        key="key",\n\n        # the properties below are optional\n        object_version="objectVersion"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket', 'key', 'object_version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codecommit.CfnRepository.S3Property'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codecommit.CodeConfig
class CodeConfigDef(BaseStruct):
    code: typing.Union[_REQUIRED_INIT_PARAM, models.aws_codecommit.CfnRepository_CodePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='represents the underlying code structure.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codecommit as codecommit\n\n    code_config = codecommit.CodeConfig(\n        code=codecommit.CfnRepository.CodeProperty(\n            s3=codecommit.CfnRepository.S3Property(\n                bucket="bucket",\n                key="key",\n\n                # the properties below are optional\n                object_version="objectVersion"\n            ),\n\n            # the properties below are optional\n            branch_name="branchName"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['code']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codecommit.CodeConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codecommit.OnCommitOptions
class OnCommitOptionsDef(BaseStruct):
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    branches: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The branch to monitor. Default: - All branches\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_codecommit as codecommit\n    import aws_cdk.aws_events_targets as targets\n\n    # repo: codecommit.Repository\n\n    my_topic = sns.Topic(self, "Topic")\n\n    repo.on_commit("OnCommit",\n        target=targets.SnsTopic(my_topic)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cross_stack_scope', 'description', 'event_pattern', 'rule_name', 'target', 'branches']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codecommit.OnCommitOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codecommit.RepositoryNotifyOnOptions
class RepositoryNotifyOnOptionsDef(BaseStruct):
    detail_type: typing.Optional[aws_cdk.aws_codestarnotifications.DetailType] = pydantic.Field(None, description='The level of detail to include in the notifications for this resource. BASIC will include only the contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created. Default: DetailType.FULL\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description="The status of the notification rule. If the enabled is set to DISABLED, notifications aren't sent for the notification rule. Default: true\n")
    notification_rule_name: typing.Optional[str] = pydantic.Field(None, description='The name for the notification rule. Notification rule names must be unique in your AWS account. Default: - generated from the ``id``\n')
    events: typing.Union[typing.Sequence[aws_cdk.aws_codecommit.RepositoryNotificationEvents], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of event types associated with this notification rule for CodeCommit repositories. For a complete list of event types and IDs, see Notification concepts in the Developer Tools Console User Guide.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codecommit as codecommit\n    from aws_cdk import aws_codestarnotifications as codestarnotifications\n\n    repository_notify_on_options = codecommit.RepositoryNotifyOnOptions(\n        events=[codecommit.RepositoryNotificationEvents.COMMIT_COMMENT],\n\n        # the properties below are optional\n        detail_type=codestarnotifications.DetailType.BASIC,\n        enabled=False,\n        notification_rule_name="notificationRuleName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['detail_type', 'enabled', 'notification_rule_name', 'events']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codecommit.RepositoryNotifyOnOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codecommit.RepositoryProps
class RepositoryPropsDef(BaseStruct):
    repository_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Name of the repository. This property is required for all CodeCommit repositories.')
    code: typing.Optional[models.aws_codecommit.CodeDef] = pydantic.Field(None, description='The contents with which to initialize the repository after it has been created. Default: - No initialization (create empty repo)\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the repository. Use the description to identify the purpose of the repository. Default: - No description.\n\n:exampleMetadata: lit=aws-codepipeline-actions/test/integ.cfn-template-from-repo.lit.ts infused\n\nExample::\n\n    # Source stage: read from repository\n    repo = codecommit.Repository(stack, "TemplateRepo",\n        repository_name="template-repo"\n    )\n    source_output = codepipeline.Artifact("SourceArtifact")\n    source = cpactions.CodeCommitSourceAction(\n        action_name="Source",\n        repository=repo,\n        output=source_output,\n        trigger=cpactions.CodeCommitTrigger.POLL\n    )\n    source_stage = {\n        "stage_name": "Source",\n        "actions": [source]\n    }\n\n    # Deployment stage: create and deploy changeset with manual approval\n    stack_name = "OurStack"\n    change_set_name = "StagedChangeSet"\n\n    prod_stage = {\n        "stage_name": "Deploy",\n        "actions": [\n            cpactions.CloudFormationCreateReplaceChangeSetAction(\n                action_name="PrepareChanges",\n                stack_name=stack_name,\n                change_set_name=change_set_name,\n                admin_permissions=True,\n                template_path=source_output.at_path("template.yaml"),\n                run_order=1\n            ),\n            cpactions.ManualApprovalAction(\n                action_name="ApproveChanges",\n                run_order=2\n            ),\n            cpactions.CloudFormationExecuteChangeSetAction(\n                action_name="ExecuteChanges",\n                stack_name=stack_name,\n                change_set_name=change_set_name,\n                run_order=3\n            )\n        ]\n    }\n\n    codepipeline.Pipeline(stack, "Pipeline",\n        stages=[source_stage, prod_stage\n        ]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['repository_name', 'code', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codecommit.RepositoryProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codecommit.RepositoryTriggerOptions
class RepositoryTriggerOptionsDef(BaseStruct):
    branches: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The names of the branches in the AWS CodeCommit repository that contain events that you want to include in the trigger. If you don't specify at least one branch, the trigger applies to all branches.\n")
    custom_data: typing.Optional[str] = pydantic.Field(None, description='When an event is triggered, additional information that AWS CodeCommit includes when it sends information to the target.\n')
    events: typing.Optional[typing.Sequence[aws_cdk.aws_codecommit.RepositoryEventTrigger]] = pydantic.Field(None, description="The repository events for which AWS CodeCommit sends information to the target, which you specified in the DestinationArn property.If you don't specify events, the trigger runs for all repository events.\n")
    name: typing.Optional[str] = pydantic.Field(None, description='A name for the trigger.Triggers on a repository must have unique names.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codecommit as codecommit\n\n    repository_trigger_options = codecommit.RepositoryTriggerOptions(\n        branches=["branches"],\n        custom_data="customData",\n        events=[codecommit.RepositoryEventTrigger.ALL],\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['branches', 'custom_data', 'events', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codecommit.RepositoryTriggerOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codecommit.RepositoryEventTrigger
# skipping emum

#  autogenerated from aws_cdk.aws_codecommit.RepositoryNotificationEvents
# skipping emum

#  autogenerated from aws_cdk.aws_codecommit.IRepository
#  skipping Interface

#  autogenerated from aws_cdk.aws_codecommit.CfnRepository
class CfnRepositoryDef(BaseCfnResource):
    repository_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the new repository to be created. .. epigraph:: The repository name must be unique across the calling AWS account . Repository names are limited to 100 alphanumeric, dash, and underscore characters, and cannot include certain characters. For more information about the limits on repository names, see `Quotas <https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html>`_ in the *AWS CodeCommit User Guide* . The suffix .git is prohibited.\n')
    code: typing.Union[models.UnsupportedResource, models.aws_codecommit.CfnRepository_CodePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about code to be committed to a repository after it is created in an AWS CloudFormation stack. Information about code is only used in resource creation. Updates to a stack will not reflect changes made to code properties after initial resource creation. .. epigraph:: You can only use this property to add code when creating a repository with a AWS CloudFormation template at creation time. This property cannot be used for updating code to an existing repository.\n')
    repository_description: typing.Optional[str] = pydantic.Field(None, description='A comment or description about the new repository. .. epigraph:: The description field for a repository accepts all HTML characters and all valid Unicode characters. Applications that do not HTML-encode the description and display it in a webpage can expose users to potentially malicious code. Make sure that you HTML-encode the description field in any application that uses this API to display the repository description on a webpage.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='One or more tag key-value pairs to use when tagging this repository.\n')
    triggers: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codecommit.CfnRepository_RepositoryTriggerPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The JSON block of configuration information for each trigger.')
    _init_params: typing.ClassVar[list[str]] = ['repository_name', 'code', 'repository_description', 'tags', 'triggers']
    _method_names: typing.ClassVar[list[str]] = ['CodeProperty', 'RepositoryTriggerProperty', 'S3Property', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codecommit.CfnRepository'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_codecommit.CfnRepositoryDefConfig] = pydantic.Field(None)


class CfnRepositoryDefConfig(pydantic.BaseModel):
    CodeProperty: typing.Optional[list[models.aws_codecommit.CfnRepositoryDefCodepropertyParams]] = pydantic.Field(None, description='')
    RepositoryTriggerProperty: typing.Optional[list[models.aws_codecommit.CfnRepositoryDefRepositorytriggerpropertyParams]] = pydantic.Field(None, description='')
    S3Property: typing.Optional[list[models.aws_codecommit.CfnRepositoryDefS3PropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_codecommit.CfnRepositoryDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_codecommit.CfnRepositoryDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_codecommit.CfnRepositoryDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_codecommit.CfnRepositoryDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_codecommit.CfnRepositoryDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_codecommit.CfnRepositoryDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_codecommit.CfnRepositoryDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_codecommit.CfnRepositoryDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_codecommit.CfnRepositoryDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_codecommit.CfnRepositoryDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_codecommit.CfnRepositoryDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_codecommit.CfnRepositoryDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_codecommit.CfnRepositoryDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnRepositoryDefCodepropertyParams(pydantic.BaseModel):
    s3: typing.Union[models.UnsupportedResource, models.aws_codecommit.CfnRepository_S3PropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    branch_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnRepositoryDefRepositorytriggerpropertyParams(pydantic.BaseModel):
    destination_arn: str = pydantic.Field(..., description='')
    events: typing.Sequence[str] = pydantic.Field(..., description='')
    name: str = pydantic.Field(..., description='')
    branches: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    custom_data: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnRepositoryDefS3PropertyParams(pydantic.BaseModel):
    bucket: str = pydantic.Field(..., description='')
    key: str = pydantic.Field(..., description='')
    object_version: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnRepositoryDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnRepositoryDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRepositoryDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnRepositoryDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRepositoryDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnRepositoryDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnRepositoryDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnRepositoryDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnRepositoryDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnRepositoryDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRepositoryDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnRepositoryDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnRepositoryDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRepositoryDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_codecommit.CfnRepositoryProps
class CfnRepositoryPropsDef(BaseCfnProperty):
    repository_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the new repository to be created. .. epigraph:: The repository name must be unique across the calling AWS account . Repository names are limited to 100 alphanumeric, dash, and underscore characters, and cannot include certain characters. For more information about the limits on repository names, see `Quotas <https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html>`_ in the *AWS CodeCommit User Guide* . The suffix .git is prohibited.\n')
    code: typing.Union[models.UnsupportedResource, models.aws_codecommit.CfnRepository_CodePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about code to be committed to a repository after it is created in an AWS CloudFormation stack. Information about code is only used in resource creation. Updates to a stack will not reflect changes made to code properties after initial resource creation. .. epigraph:: You can only use this property to add code when creating a repository with a AWS CloudFormation template at creation time. This property cannot be used for updating code to an existing repository.\n')
    repository_description: typing.Optional[str] = pydantic.Field(None, description='A comment or description about the new repository. .. epigraph:: The description field for a repository accepts all HTML characters and all valid Unicode characters. Applications that do not HTML-encode the description and display it in a webpage can expose users to potentially malicious code. Make sure that you HTML-encode the description field in any application that uses this API to display the repository description on a webpage.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='One or more tag key-value pairs to use when tagging this repository.\n')
    triggers: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_codecommit.CfnRepository_RepositoryTriggerPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The JSON block of configuration information for each trigger.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codecommit-repository.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codecommit as codecommit\n\n    cfn_repository_props = codecommit.CfnRepositoryProps(\n        repository_name="repositoryName",\n\n        # the properties below are optional\n        code=codecommit.CfnRepository.CodeProperty(\n            s3=codecommit.CfnRepository.S3Property(\n                bucket="bucket",\n                key="key",\n\n                # the properties below are optional\n                object_version="objectVersion"\n            ),\n\n            # the properties below are optional\n            branch_name="branchName"\n        ),\n        repository_description="repositoryDescription",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        triggers=[codecommit.CfnRepository.RepositoryTriggerProperty(\n            destination_arn="destinationArn",\n            events=["events"],\n            name="name",\n\n            # the properties below are optional\n            branches=["branches"],\n            custom_data="customData"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['repository_name', 'code', 'repository_description', 'tags', 'triggers']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codecommit.CfnRepositoryProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    Code: typing.Optional[dict[str, models.aws_codecommit.CodeDef]] = pydantic.Field(None)
    ReferenceEvent: typing.Optional[dict[str, models.aws_codecommit.ReferenceEventDef]] = pydantic.Field(None)
    Repository: typing.Optional[dict[str, models.aws_codecommit.RepositoryDef]] = pydantic.Field(None)
    CfnRepository_CodeProperty: typing.Optional[dict[str, models.aws_codecommit.CfnRepository_CodePropertyDef]] = pydantic.Field(None)
    CfnRepository_RepositoryTriggerProperty: typing.Optional[dict[str, models.aws_codecommit.CfnRepository_RepositoryTriggerPropertyDef]] = pydantic.Field(None)
    CfnRepository_S3Property: typing.Optional[dict[str, models.aws_codecommit.CfnRepository_S3PropertyDef]] = pydantic.Field(None)
    CodeConfig: typing.Optional[dict[str, models.aws_codecommit.CodeConfigDef]] = pydantic.Field(None)
    OnCommitOptions: typing.Optional[dict[str, models.aws_codecommit.OnCommitOptionsDef]] = pydantic.Field(None)
    RepositoryNotifyOnOptions: typing.Optional[dict[str, models.aws_codecommit.RepositoryNotifyOnOptionsDef]] = pydantic.Field(None)
    RepositoryProps: typing.Optional[dict[str, models.aws_codecommit.RepositoryPropsDef]] = pydantic.Field(None)
    RepositoryTriggerOptions: typing.Optional[dict[str, models.aws_codecommit.RepositoryTriggerOptionsDef]] = pydantic.Field(None)
    CfnRepository: typing.Optional[dict[str, models.aws_codecommit.CfnRepositoryDef]] = pydantic.Field(None)
    CfnRepositoryProps: typing.Optional[dict[str, models.aws_codecommit.CfnRepositoryPropsDef]] = pydantic.Field(None)
    ...

import models
