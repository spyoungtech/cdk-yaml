from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_cleanrooms.CfnAnalysisTemplate.AnalysisParameterProperty
class CfnAnalysisTemplate_AnalysisParameterPropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the parameter. The name must use only alphanumeric, underscore (_), or hyphen (-) characters but cannot start or end with a hyphen.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of parameter.\n')
    default_value: typing.Optional[str] = pydantic.Field(None, description='Optional. The default value that is applied in the analysis template. The member who can query can override this value in the query editor.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-analysistemplate-analysisparameter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    analysis_parameter_property = cleanrooms.CfnAnalysisTemplate.AnalysisParameterProperty(\n        name="name",\n        type="type",\n\n        # the properties below are optional\n        default_value="defaultValue"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'type', 'default_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnAnalysisTemplate.AnalysisParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnAnalysisTemplate.AnalysisSchemaProperty
class CfnAnalysisTemplate_AnalysisSchemaPropertyDef(BaseStruct):
    referenced_tables: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The tables referenced in the analysis schema.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-analysistemplate-analysisschema.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    analysis_schema_property = cleanrooms.CfnAnalysisTemplate.AnalysisSchemaProperty(\n        referenced_tables=["referencedTables"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['referenced_tables']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnAnalysisTemplate.AnalysisSchemaProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnAnalysisTemplate.AnalysisSourceProperty
class CfnAnalysisTemplate_AnalysisSourcePropertyDef(BaseStruct):
    text: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The query text.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-analysistemplate-analysissource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    analysis_source_property = cleanrooms.CfnAnalysisTemplate.AnalysisSourceProperty(\n        text="text"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['text']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnAnalysisTemplate.AnalysisSourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnCollaboration.DataEncryptionMetadataProperty
class CfnCollaboration_DataEncryptionMetadataPropertyDef(BaseStruct):
    allow_cleartext: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='Indicates whether encrypted tables can contain cleartext data ( ``TRUE`` ) or are to cryptographically process every column ( ``FALSE`` ).\n')
    allow_duplicates: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='Indicates whether Fingerprint columns can contain duplicate entries ( ``TRUE`` ) or are to contain only non-repeated values ( ``FALSE`` ).\n')
    allow_joins_on_columns_with_different_names: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='Indicates whether Fingerprint columns can be joined on any other Fingerprint column with a different name ( ``TRUE`` ) or can only be joined on Fingerprint columns of the same name ( ``FALSE`` ).\n')
    preserve_nulls: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='Indicates whether NULL values are to be copied as NULL to encrypted tables ( ``TRUE`` ) or cryptographically processed ( ``FALSE`` ).\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-collaboration-dataencryptionmetadata.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    data_encryption_metadata_property = cleanrooms.CfnCollaboration.DataEncryptionMetadataProperty(\n        allow_cleartext=False,\n        allow_duplicates=False,\n        allow_joins_on_columns_with_different_names=False,\n        preserve_nulls=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allow_cleartext', 'allow_duplicates', 'allow_joins_on_columns_with_different_names', 'preserve_nulls']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnCollaboration.DataEncryptionMetadataProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnCollaboration.MemberSpecificationProperty
class CfnCollaboration_MemberSpecificationPropertyDef(BaseStruct):
    account_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier used to reference members of the collaboration. Currently only supports AWS account ID.\n')
    display_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The member's display name.\n")
    member_abilities: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The abilities granted to the collaboration member. *Allowed Values* : ``CAN_QUERY`` | ``CAN_RECEIVE_RESULTS``\n')
    payment_configuration: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnCollaboration_PaymentConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The collaboration member\'s payment responsibilities set by the collaboration creator. If the collaboration creator hasn\'t speciÔ¨Åed anyone as the member paying for query compute costs, then the member who can query is the default payer.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-collaboration-memberspecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    member_specification_property = cleanrooms.CfnCollaboration.MemberSpecificationProperty(\n        account_id="accountId",\n        display_name="displayName",\n        member_abilities=["memberAbilities"],\n\n        # the properties below are optional\n        payment_configuration=cleanrooms.CfnCollaboration.PaymentConfigurationProperty(\n            query_compute=cleanrooms.CfnCollaboration.QueryComputePaymentConfigProperty(\n                is_responsible=False\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account_id', 'display_name', 'member_abilities', 'payment_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnCollaboration.MemberSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnCollaboration.PaymentConfigurationProperty
class CfnCollaboration_PaymentConfigurationPropertyDef(BaseStruct):
    query_compute: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_cleanrooms.CfnCollaboration_QueryComputePaymentConfigPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description="The collaboration member's payment responsibilities set by the collaboration creator for query compute costs.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-collaboration-paymentconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    payment_configuration_property = cleanrooms.CfnCollaboration.PaymentConfigurationProperty(\n        query_compute=cleanrooms.CfnCollaboration.QueryComputePaymentConfigProperty(\n            is_responsible=False\n        )\n    )\n")
    _init_params: typing.ClassVar[list[str]] = ['query_compute']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnCollaboration.PaymentConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnCollaboration.QueryComputePaymentConfigProperty
class CfnCollaboration_QueryComputePaymentConfigPropertyDef(BaseStruct):
    is_responsible: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description="Indicates whether the collaboration creator has configured the collaboration member to pay for query compute costs ( ``TRUE`` ) or has not configured the collaboration member to pay for query compute costs ( ``FALSE`` ). Exactly one member can be configured to pay for query compute costs. An error is returned if the collaboration creator sets a ``TRUE`` value for more than one member in the collaboration. If the collaboration creator hasn't specified anyone as the member paying for query compute costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a ``FALSE`` value for the member who can query.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-collaboration-querycomputepaymentconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    query_compute_payment_config_property = cleanrooms.CfnCollaboration.QueryComputePaymentConfigProperty(\n        is_responsible=False\n    )\n")
    _init_params: typing.ClassVar[list[str]] = ['is_responsible']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnCollaboration.QueryComputePaymentConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnConfiguredTable.AggregateColumnProperty
class CfnConfiguredTable_AggregateColumnPropertyDef(BaseStruct):
    column_names: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Column names in configured table of aggregate columns.\n')
    function: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Aggregation function that can be applied to aggregate column in query.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-configuredtable-aggregatecolumn.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    aggregate_column_property = cleanrooms.CfnConfiguredTable.AggregateColumnProperty(\n        column_names=["columnNames"],\n        function="function"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['column_names', 'function']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnConfiguredTable.AggregateColumnProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnConfiguredTable.AggregationConstraintProperty
class CfnConfiguredTable_AggregationConstraintPropertyDef(BaseStruct):
    column_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Column in aggregation constraint for which there must be a minimum number of distinct values in an output row for it to be in the query output.\n')
    minimum: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The minimum number of distinct values that an output row must be an aggregation of. Minimum threshold of distinct values for a specified column that must exist in an output row for it to be in the query output.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of aggregation the constraint allows. The only valid value is currently ``COUNT_DISTINCT``.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-configuredtable-aggregationconstraint.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    aggregation_constraint_property = cleanrooms.CfnConfiguredTable.AggregationConstraintProperty(\n        column_name="columnName",\n        minimum=123,\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['column_name', 'minimum', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnConfiguredTable.AggregationConstraintProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnConfiguredTable.AnalysisRuleAggregationProperty
class CfnConfiguredTable_AnalysisRuleAggregationPropertyDef(BaseStruct):
    aggregate_columns: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_AggregateColumnPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The columns that query runners are allowed to use in aggregation queries.\n')
    dimension_columns: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The columns that query runners are allowed to select, group by, or filter by.\n')
    join_columns: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Columns in configured table that can be used in join statements and/or as aggregate columns. They can never be outputted directly.\n')
    output_constraints: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_AggregationConstraintPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Columns that must meet a specific threshold value (after an aggregation function is applied to it) for each output row to be returned.\n')
    scalar_functions: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Set of scalar functions that are allowed to be used on dimension columns and the output of aggregation of metrics.\n')
    allowed_join_operators: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Which logical operators (if any) are to be used in an INNER JOIN match condition. Default is ``AND`` .\n')
    join_required: typing.Optional[str] = pydantic.Field(None, description='Control that requires member who runs query to do a join with their configured table and/or other configured table in query.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-configuredtable-analysisruleaggregation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    analysis_rule_aggregation_property = cleanrooms.CfnConfiguredTable.AnalysisRuleAggregationProperty(\n        aggregate_columns=[cleanrooms.CfnConfiguredTable.AggregateColumnProperty(\n            column_names=["columnNames"],\n            function="function"\n        )],\n        dimension_columns=["dimensionColumns"],\n        join_columns=["joinColumns"],\n        output_constraints=[cleanrooms.CfnConfiguredTable.AggregationConstraintProperty(\n            column_name="columnName",\n            minimum=123,\n            type="type"\n        )],\n        scalar_functions=["scalarFunctions"],\n\n        # the properties below are optional\n        allowed_join_operators=["allowedJoinOperators"],\n        join_required="joinRequired"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['aggregate_columns', 'dimension_columns', 'join_columns', 'output_constraints', 'scalar_functions', 'allowed_join_operators', 'join_required']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnConfiguredTable.AnalysisRuleAggregationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnConfiguredTable.AnalysisRuleCustomProperty
class CfnConfiguredTable_AnalysisRuleCustomPropertyDef(BaseStruct):
    allowed_analyses: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the analysis templates that are allowed by the custom analysis rule.\n')
    allowed_analysis_providers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of the AWS accounts that are allowed to query by the custom analysis rule. Required when ``allowedAnalyses`` is ``ANY_QUERY`` .\n')
    differential_privacy: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_DifferentialPrivacyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The differential privacy configuration.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-configuredtable-analysisrulecustom.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    analysis_rule_custom_property = cleanrooms.CfnConfiguredTable.AnalysisRuleCustomProperty(\n        allowed_analyses=["allowedAnalyses"],\n\n        # the properties below are optional\n        allowed_analysis_providers=["allowedAnalysisProviders"],\n        differential_privacy=cleanrooms.CfnConfiguredTable.DifferentialPrivacyProperty(\n            columns=[cleanrooms.CfnConfiguredTable.DifferentialPrivacyColumnProperty(\n                name="name"\n            )]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allowed_analyses', 'allowed_analysis_providers', 'differential_privacy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnConfiguredTable.AnalysisRuleCustomProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnConfiguredTable.AnalysisRuleListProperty
class CfnConfiguredTable_AnalysisRuleListPropertyDef(BaseStruct):
    join_columns: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="Columns that can be used to join a configured table with the table of the member who can query and other members' configured tables.\n")
    list_columns: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Columns that can be listed in the output.\n')
    allowed_join_operators: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The logical operators (if any) that are to be used in an INNER JOIN match condition. Default is ``AND`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-configuredtable-analysisrulelist.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    analysis_rule_list_property = cleanrooms.CfnConfiguredTable.AnalysisRuleListProperty(\n        join_columns=["joinColumns"],\n        list_columns=["listColumns"],\n\n        # the properties below are optional\n        allowed_join_operators=["allowedJoinOperators"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['join_columns', 'list_columns', 'allowed_join_operators']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnConfiguredTable.AnalysisRuleListProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnConfiguredTable.AnalysisRuleProperty
class CfnConfiguredTable_AnalysisRulePropertyDef(BaseStruct):
    policy: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_ConfiguredTableAnalysisRulePolicyPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A policy that describes the associated data usage limitations.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of analysis rule.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-configuredtable-analysisrule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    analysis_rule_property = cleanrooms.CfnConfiguredTable.AnalysisRuleProperty(\n        policy=cleanrooms.CfnConfiguredTable.ConfiguredTableAnalysisRulePolicyProperty(\n            v1=cleanrooms.CfnConfiguredTable.ConfiguredTableAnalysisRulePolicyV1Property(\n                aggregation=cleanrooms.CfnConfiguredTable.AnalysisRuleAggregationProperty(\n                    aggregate_columns=[cleanrooms.CfnConfiguredTable.AggregateColumnProperty(\n                        column_names=["columnNames"],\n                        function="function"\n                    )],\n                    dimension_columns=["dimensionColumns"],\n                    join_columns=["joinColumns"],\n                    output_constraints=[cleanrooms.CfnConfiguredTable.AggregationConstraintProperty(\n                        column_name="columnName",\n                        minimum=123,\n                        type="type"\n                    )],\n                    scalar_functions=["scalarFunctions"],\n\n                    # the properties below are optional\n                    allowed_join_operators=["allowedJoinOperators"],\n                    join_required="joinRequired"\n                ),\n                custom=cleanrooms.CfnConfiguredTable.AnalysisRuleCustomProperty(\n                    allowed_analyses=["allowedAnalyses"],\n\n                    # the properties below are optional\n                    allowed_analysis_providers=["allowedAnalysisProviders"],\n                    differential_privacy=cleanrooms.CfnConfiguredTable.DifferentialPrivacyProperty(\n                        columns=[cleanrooms.CfnConfiguredTable.DifferentialPrivacyColumnProperty(\n                            name="name"\n                        )]\n                    )\n                ),\n                list=cleanrooms.CfnConfiguredTable.AnalysisRuleListProperty(\n                    join_columns=["joinColumns"],\n                    list_columns=["listColumns"],\n\n                    # the properties below are optional\n                    allowed_join_operators=["allowedJoinOperators"]\n                )\n            )\n        ),\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['policy', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnConfiguredTable.AnalysisRuleProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnConfiguredTable.ConfiguredTableAnalysisRulePolicyProperty
class CfnConfiguredTable_ConfiguredTableAnalysisRulePolicyPropertyDef(BaseStruct):
    v1: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_ConfiguredTableAnalysisRulePolicyV1PropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Controls on the query specifications that can be run on a configured table.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-configuredtable-configuredtableanalysisrulepolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    configured_table_analysis_rule_policy_property = cleanrooms.CfnConfiguredTable.ConfiguredTableAnalysisRulePolicyProperty(\n        v1=cleanrooms.CfnConfiguredTable.ConfiguredTableAnalysisRulePolicyV1Property(\n            aggregation=cleanrooms.CfnConfiguredTable.AnalysisRuleAggregationProperty(\n                aggregate_columns=[cleanrooms.CfnConfiguredTable.AggregateColumnProperty(\n                    column_names=["columnNames"],\n                    function="function"\n                )],\n                dimension_columns=["dimensionColumns"],\n                join_columns=["joinColumns"],\n                output_constraints=[cleanrooms.CfnConfiguredTable.AggregationConstraintProperty(\n                    column_name="columnName",\n                    minimum=123,\n                    type="type"\n                )],\n                scalar_functions=["scalarFunctions"],\n\n                # the properties below are optional\n                allowed_join_operators=["allowedJoinOperators"],\n                join_required="joinRequired"\n            ),\n            custom=cleanrooms.CfnConfiguredTable.AnalysisRuleCustomProperty(\n                allowed_analyses=["allowedAnalyses"],\n\n                # the properties below are optional\n                allowed_analysis_providers=["allowedAnalysisProviders"],\n                differential_privacy=cleanrooms.CfnConfiguredTable.DifferentialPrivacyProperty(\n                    columns=[cleanrooms.CfnConfiguredTable.DifferentialPrivacyColumnProperty(\n                        name="name"\n                    )]\n                )\n            ),\n            list=cleanrooms.CfnConfiguredTable.AnalysisRuleListProperty(\n                join_columns=["joinColumns"],\n                list_columns=["listColumns"],\n\n                # the properties below are optional\n                allowed_join_operators=["allowedJoinOperators"]\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['v1']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnConfiguredTable.ConfiguredTableAnalysisRulePolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnConfiguredTable.ConfiguredTableAnalysisRulePolicyV1Property
class CfnConfiguredTable_ConfiguredTableAnalysisRulePolicyV1PropertyDef(BaseStruct):
    aggregation: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_AnalysisRuleAggregationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Analysis rule type that enables only aggregation queries on a configured table.\n')
    custom: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_AnalysisRuleCustomPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Analysis rule type that enables custom SQL queries on a configured table.\n')
    list_: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_AnalysisRuleListPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Analysis rule type that enables only list queries on a configured table.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-configuredtable-configuredtableanalysisrulepolicyv1.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    configured_table_analysis_rule_policy_v1_property = cleanrooms.CfnConfiguredTable.ConfiguredTableAnalysisRulePolicyV1Property(\n        aggregation=cleanrooms.CfnConfiguredTable.AnalysisRuleAggregationProperty(\n            aggregate_columns=[cleanrooms.CfnConfiguredTable.AggregateColumnProperty(\n                column_names=["columnNames"],\n                function="function"\n            )],\n            dimension_columns=["dimensionColumns"],\n            join_columns=["joinColumns"],\n            output_constraints=[cleanrooms.CfnConfiguredTable.AggregationConstraintProperty(\n                column_name="columnName",\n                minimum=123,\n                type="type"\n            )],\n            scalar_functions=["scalarFunctions"],\n\n            # the properties below are optional\n            allowed_join_operators=["allowedJoinOperators"],\n            join_required="joinRequired"\n        ),\n        custom=cleanrooms.CfnConfiguredTable.AnalysisRuleCustomProperty(\n            allowed_analyses=["allowedAnalyses"],\n\n            # the properties below are optional\n            allowed_analysis_providers=["allowedAnalysisProviders"],\n            differential_privacy=cleanrooms.CfnConfiguredTable.DifferentialPrivacyProperty(\n                columns=[cleanrooms.CfnConfiguredTable.DifferentialPrivacyColumnProperty(\n                    name="name"\n                )]\n            )\n        ),\n        list=cleanrooms.CfnConfiguredTable.AnalysisRuleListProperty(\n            join_columns=["joinColumns"],\n            list_columns=["listColumns"],\n\n            # the properties below are optional\n            allowed_join_operators=["allowedJoinOperators"]\n        )\n    )\n', alias='list')
    _init_params: typing.ClassVar[list[str]] = ['aggregation', 'custom', 'list']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnConfiguredTable.ConfiguredTableAnalysisRulePolicyV1Property'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnConfiguredTable.DifferentialPrivacyColumnProperty
class CfnConfiguredTable_DifferentialPrivacyColumnPropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the column, such as user_id, that contains the unique identifier of your users, whose privacy you want to protect. If you want to turn on differential privacy for two or more tables in a collaboration, you must configure the same column as the user identifier column in both analysis rules.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-configuredtable-differentialprivacycolumn.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    differential_privacy_column_property = cleanrooms.CfnConfiguredTable.DifferentialPrivacyColumnProperty(\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnConfiguredTable.DifferentialPrivacyColumnProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnConfiguredTable.DifferentialPrivacyProperty
class CfnConfiguredTable_DifferentialPrivacyPropertyDef(BaseStruct):
    columns: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_DifferentialPrivacyColumnPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the column, such as user_id, that contains the unique identifier of your users, whose privacy you want to protect. If you want to turn on differential privacy for two or more tables in a collaboration, you must configure the same column as the user identifier column in both analysis rules.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-configuredtable-differentialprivacy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    differential_privacy_property = cleanrooms.CfnConfiguredTable.DifferentialPrivacyProperty(\n        columns=[cleanrooms.CfnConfiguredTable.DifferentialPrivacyColumnProperty(\n            name="name"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['columns']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnConfiguredTable.DifferentialPrivacyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnConfiguredTable.GlueTableReferenceProperty
class CfnConfiguredTable_GlueTableReferencePropertyDef(BaseStruct):
    database_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the database the AWS Glue table belongs to.\n')
    table_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the AWS Glue table.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-configuredtable-gluetablereference.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    glue_table_reference_property = cleanrooms.CfnConfiguredTable.GlueTableReferenceProperty(\n        database_name="databaseName",\n        table_name="tableName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['database_name', 'table_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnConfiguredTable.GlueTableReferenceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnConfiguredTable.TableReferenceProperty
class CfnConfiguredTable_TableReferencePropertyDef(BaseStruct):
    glue: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_GlueTableReferencePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='If present, a reference to the AWS Glue table referred to by this table reference.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-configuredtable-tablereference.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    table_reference_property = cleanrooms.CfnConfiguredTable.TableReferenceProperty(\n        glue=cleanrooms.CfnConfiguredTable.GlueTableReferenceProperty(\n            database_name="databaseName",\n            table_name="tableName"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['glue']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnConfiguredTable.TableReferenceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnMembership.MembershipPaymentConfigurationProperty
class CfnMembership_MembershipPaymentConfigurationPropertyDef(BaseStruct):
    query_compute: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_cleanrooms.CfnMembership_MembershipQueryComputePaymentConfigPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The payment responsibilities accepted by the collaboration member for query compute costs.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-membership-membershippaymentconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    membership_payment_configuration_property = cleanrooms.CfnMembership.MembershipPaymentConfigurationProperty(\n        query_compute=cleanrooms.CfnMembership.MembershipQueryComputePaymentConfigProperty(\n            is_responsible=False\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['query_compute']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnMembership.MembershipPaymentConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnMembership.MembershipProtectedQueryOutputConfigurationProperty
class CfnMembership_MembershipProtectedQueryOutputConfigurationPropertyDef(BaseStruct):
    s3: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_cleanrooms.CfnMembership_ProtectedQueryS3OutputConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Required configuration for a protected query with an ``S3`` output type.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-membership-membershipprotectedqueryoutputconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    membership_protected_query_output_configuration_property = cleanrooms.CfnMembership.MembershipProtectedQueryOutputConfigurationProperty(\n        s3=cleanrooms.CfnMembership.ProtectedQueryS3OutputConfigurationProperty(\n            bucket="bucket",\n            result_format="resultFormat",\n\n            # the properties below are optional\n            key_prefix="keyPrefix"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['s3']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnMembership.MembershipProtectedQueryOutputConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnMembership.MembershipProtectedQueryResultConfigurationProperty
class CfnMembership_MembershipProtectedQueryResultConfigurationPropertyDef(BaseStruct):
    output_configuration: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_cleanrooms.CfnMembership_MembershipProtectedQueryOutputConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Configuration for protected query results.\n')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='The unique ARN for an IAM role that is used by AWS Clean Rooms to write protected query results to the result location, given by the member who can receive results.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-membership-membershipprotectedqueryresultconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    membership_protected_query_result_configuration_property = cleanrooms.CfnMembership.MembershipProtectedQueryResultConfigurationProperty(\n        output_configuration=cleanrooms.CfnMembership.MembershipProtectedQueryOutputConfigurationProperty(\n            s3=cleanrooms.CfnMembership.ProtectedQueryS3OutputConfigurationProperty(\n                bucket="bucket",\n                result_format="resultFormat",\n\n                # the properties below are optional\n                key_prefix="keyPrefix"\n            )\n        ),\n\n        # the properties below are optional\n        role_arn="roleArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['output_configuration', 'role_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnMembership.MembershipProtectedQueryResultConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnMembership.MembershipQueryComputePaymentConfigProperty
class CfnMembership_MembershipQueryComputePaymentConfigPropertyDef(BaseStruct):
    is_responsible: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='Indicates whether the collaboration member has accepted to pay for query compute costs ( ``TRUE`` ) or has not accepted to pay for query compute costs ( ``FALSE`` ). If the collaboration creator has not specified anyone to pay for query compute costs, then the member who can query is the default payer. An error message is returned for the following reasons: - If you set the value to ``FALSE`` but you are responsible to pay for query compute costs. - If you set the value to ``TRUE`` but you are not responsible to pay for query compute costs.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-membership-membershipquerycomputepaymentconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    membership_query_compute_payment_config_property = cleanrooms.CfnMembership.MembershipQueryComputePaymentConfigProperty(\n        is_responsible=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['is_responsible']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnMembership.MembershipQueryComputePaymentConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnMembership.ProtectedQueryS3OutputConfigurationProperty
class CfnMembership_ProtectedQueryS3OutputConfigurationPropertyDef(BaseStruct):
    bucket: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The S3 bucket to unload the protected query results.\n')
    result_format: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Intended file format of the result.\n')
    key_prefix: typing.Optional[str] = pydantic.Field(None, description='The S3 prefix to unload the protected query results.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-membership-protectedquerys3outputconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    protected_query_s3_output_configuration_property = cleanrooms.CfnMembership.ProtectedQueryS3OutputConfigurationProperty(\n        bucket="bucket",\n        result_format="resultFormat",\n\n        # the properties below are optional\n        key_prefix="keyPrefix"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket', 'result_format', 'key_prefix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnMembership.ProtectedQueryS3OutputConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnPrivacyBudgetTemplate.ParametersProperty
class CfnPrivacyBudgetTemplate_ParametersPropertyDef(BaseStruct):
    epsilon: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The epsilon value that you want to use.\n')
    users_noise_per_query: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='Noise added per query is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cleanrooms-privacybudgettemplate-parameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    parameters_property = cleanrooms.CfnPrivacyBudgetTemplate.ParametersProperty(\n        epsilon=123,\n        users_noise_per_query=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['epsilon', 'users_noise_per_query']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnPrivacyBudgetTemplate.ParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnAnalysisTemplate
class CfnAnalysisTemplateDef(BaseCfnResource):
    format: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The format of the analysis template.\n')
    membership_identifier: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier for a membership resource.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the analysis template.\n')
    source: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_cleanrooms.CfnAnalysisTemplate_AnalysisSourcePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The source of the analysis template.\n')
    analysis_parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnAnalysisTemplate_AnalysisParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The parameters of the analysis template.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the analysis template.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.')
    _init_params: typing.ClassVar[list[str]] = ['format', 'membership_identifier', 'name', 'source', 'analysis_parameters', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['AnalysisParameterProperty', 'AnalysisSchemaProperty', 'AnalysisSourceProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnAnalysisTemplate'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cleanrooms.CfnAnalysisTemplateDefConfig] = pydantic.Field(None)


class CfnAnalysisTemplateDefConfig(pydantic.BaseModel):
    AnalysisParameterProperty: typing.Optional[list[models.aws_cleanrooms.CfnAnalysisTemplateDefAnalysisparameterpropertyParams]] = pydantic.Field(None, description='')
    AnalysisSchemaProperty: typing.Optional[list[models.aws_cleanrooms.CfnAnalysisTemplateDefAnalysisschemapropertyParams]] = pydantic.Field(None, description='')
    AnalysisSourceProperty: typing.Optional[list[models.aws_cleanrooms.CfnAnalysisTemplateDefAnalysissourcepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_cleanrooms.CfnAnalysisTemplateDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_cleanrooms.CfnAnalysisTemplateDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_cleanrooms.CfnAnalysisTemplateDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_cleanrooms.CfnAnalysisTemplateDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_cleanrooms.CfnAnalysisTemplateDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_cleanrooms.CfnAnalysisTemplateDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_cleanrooms.CfnAnalysisTemplateDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_cleanrooms.CfnAnalysisTemplateDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_cleanrooms.CfnAnalysisTemplateDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_cleanrooms.CfnAnalysisTemplateDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_cleanrooms.CfnAnalysisTemplateDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_cleanrooms.CfnAnalysisTemplateDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_cleanrooms.CfnAnalysisTemplateDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_schema_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnAnalysisTemplateDefAnalysisparameterpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    default_value: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAnalysisTemplateDefAnalysisschemapropertyParams(pydantic.BaseModel):
    referenced_tables: typing.Sequence[str] = pydantic.Field(..., description='')
    ...

class CfnAnalysisTemplateDefAnalysissourcepropertyParams(pydantic.BaseModel):
    text: str = pydantic.Field(..., description='')
    ...

class CfnAnalysisTemplateDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAnalysisTemplateDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAnalysisTemplateDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAnalysisTemplateDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAnalysisTemplateDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAnalysisTemplateDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAnalysisTemplateDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAnalysisTemplateDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAnalysisTemplateDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAnalysisTemplateDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAnalysisTemplateDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnAnalysisTemplateDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAnalysisTemplateDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAnalysisTemplateDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_cleanrooms.CfnCollaboration
class CfnCollaborationDef(BaseCfnResource):
    creator_display_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A display name of the collaboration creator.\n')
    creator_member_abilities: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The abilities granted to the collaboration creator. *Allowed values* ``CAN_QUERY`` | ``CAN_RECEIVE_RESULTS``\n')
    description: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A description of the collaboration provided by the collaboration owner.\n')
    members: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnCollaboration_MemberSpecificationPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of initial members, not including the creator. This list is immutable.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A human-readable identifier provided by the collaboration owner. Display names are not unique.\n')
    query_log_status: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='An indicator as to whether query logging has been enabled or disabled for the collaboration.\n')
    creator_payment_configuration: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnCollaboration_PaymentConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="An object representing the collaboration member's payment responsibilities set by the collaboration creator.\n")
    data_encryption_metadata: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnCollaboration_DataEncryptionMetadataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The settings for client-side encryption for cryptographic computing.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.')
    _init_params: typing.ClassVar[list[str]] = ['creator_display_name', 'creator_member_abilities', 'description', 'members', 'name', 'query_log_status', 'creator_payment_configuration', 'data_encryption_metadata', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['DataEncryptionMetadataProperty', 'MemberSpecificationProperty', 'PaymentConfigurationProperty', 'QueryComputePaymentConfigProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnCollaboration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cleanrooms.CfnCollaborationDefConfig] = pydantic.Field(None)


class CfnCollaborationDefConfig(pydantic.BaseModel):
    DataEncryptionMetadataProperty: typing.Optional[list[models.aws_cleanrooms.CfnCollaborationDefDataencryptionmetadatapropertyParams]] = pydantic.Field(None, description='')
    MemberSpecificationProperty: typing.Optional[list[models.aws_cleanrooms.CfnCollaborationDefMemberspecificationpropertyParams]] = pydantic.Field(None, description='')
    PaymentConfigurationProperty: typing.Optional[list[models.aws_cleanrooms.CfnCollaborationDefPaymentconfigurationpropertyParams]] = pydantic.Field(None, description='')
    QueryComputePaymentConfigProperty: typing.Optional[list[models.aws_cleanrooms.CfnCollaborationDefQuerycomputepaymentconfigpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_cleanrooms.CfnCollaborationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_cleanrooms.CfnCollaborationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_cleanrooms.CfnCollaborationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_cleanrooms.CfnCollaborationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_cleanrooms.CfnCollaborationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_cleanrooms.CfnCollaborationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_cleanrooms.CfnCollaborationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_cleanrooms.CfnCollaborationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_cleanrooms.CfnCollaborationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_cleanrooms.CfnCollaborationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_cleanrooms.CfnCollaborationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_cleanrooms.CfnCollaborationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_cleanrooms.CfnCollaborationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnCollaborationDefDataencryptionmetadatapropertyParams(pydantic.BaseModel):
    allow_cleartext: typing.Union[bool, models.UnsupportedResource] = pydantic.Field(..., description='')
    allow_duplicates: typing.Union[bool, models.UnsupportedResource] = pydantic.Field(..., description='')
    allow_joins_on_columns_with_different_names: typing.Union[bool, models.UnsupportedResource] = pydantic.Field(..., description='')
    preserve_nulls: typing.Union[bool, models.UnsupportedResource] = pydantic.Field(..., description='')
    ...

class CfnCollaborationDefMemberspecificationpropertyParams(pydantic.BaseModel):
    account_id: str = pydantic.Field(..., description='')
    display_name: str = pydantic.Field(..., description='')
    member_abilities: typing.Sequence[str] = pydantic.Field(..., description='')
    payment_configuration: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnCollaboration_PaymentConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnCollaborationDefPaymentconfigurationpropertyParams(pydantic.BaseModel):
    query_compute: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnCollaboration_QueryComputePaymentConfigPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnCollaborationDefQuerycomputepaymentconfigpropertyParams(pydantic.BaseModel):
    is_responsible: typing.Union[bool, models.UnsupportedResource] = pydantic.Field(..., description='')
    ...

class CfnCollaborationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnCollaborationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCollaborationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnCollaborationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCollaborationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnCollaborationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnCollaborationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnCollaborationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnCollaborationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnCollaborationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCollaborationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnCollaborationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnCollaborationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCollaborationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_cleanrooms.CfnConfiguredTable
class CfnConfiguredTableDef(BaseCfnResource):
    allowed_columns: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The columns within the underlying AWS Glue table that can be utilized within collaborations.\n')
    analysis_method: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The analysis method for the configured table. The only valid value is currently ``DIRECT_QUERY``.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A name for the configured table.\n')
    table_reference: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_TableReferencePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The AWS Glue table that this configured table represents.\n')
    analysis_rules: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_AnalysisRulePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The entire created analysis rule.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the configured table.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.')
    _init_params: typing.ClassVar[list[str]] = ['allowed_columns', 'analysis_method', 'name', 'table_reference', 'analysis_rules', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['AggregateColumnProperty', 'AggregationConstraintProperty', 'AnalysisRuleAggregationProperty', 'AnalysisRuleCustomProperty', 'AnalysisRuleListProperty', 'AnalysisRuleProperty', 'ConfiguredTableAnalysisRulePolicyProperty', 'ConfiguredTableAnalysisRulePolicyV1Property', 'DifferentialPrivacyColumnProperty', 'DifferentialPrivacyProperty', 'GlueTableReferenceProperty', 'TableReferenceProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnConfiguredTable'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cleanrooms.CfnConfiguredTableDefConfig] = pydantic.Field(None)


class CfnConfiguredTableDefConfig(pydantic.BaseModel):
    AggregateColumnProperty: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefAggregatecolumnpropertyParams]] = pydantic.Field(None, description='')
    AggregationConstraintProperty: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefAggregationconstraintpropertyParams]] = pydantic.Field(None, description='')
    AnalysisRuleAggregationProperty: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefAnalysisruleaggregationpropertyParams]] = pydantic.Field(None, description='')
    AnalysisRuleCustomProperty: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefAnalysisrulecustompropertyParams]] = pydantic.Field(None, description='')
    AnalysisRuleListProperty: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefAnalysisrulelistpropertyParams]] = pydantic.Field(None, description='')
    AnalysisRuleProperty: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefAnalysisrulepropertyParams]] = pydantic.Field(None, description='')
    ConfiguredTableAnalysisRulePolicyProperty: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefConfiguredtableanalysisrulepolicypropertyParams]] = pydantic.Field(None, description='')
    ConfiguredTableAnalysisRulePolicyV1Property: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefConfiguredtableanalysisrulepolicyv1PropertyParams]] = pydantic.Field(None, description='')
    DifferentialPrivacyColumnProperty: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefDifferentialprivacycolumnpropertyParams]] = pydantic.Field(None, description='')
    DifferentialPrivacyProperty: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefDifferentialprivacypropertyParams]] = pydantic.Field(None, description='')
    GlueTableReferenceProperty: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefGluetablereferencepropertyParams]] = pydantic.Field(None, description='')
    TableReferenceProperty: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefTablereferencepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnConfiguredTableDefAggregatecolumnpropertyParams(pydantic.BaseModel):
    column_names: typing.Sequence[str] = pydantic.Field(..., description='')
    function: str = pydantic.Field(..., description='')
    ...

class CfnConfiguredTableDefAggregationconstraintpropertyParams(pydantic.BaseModel):
    column_name: str = pydantic.Field(..., description='')
    minimum: typing.Union[int, float] = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    ...

class CfnConfiguredTableDefAnalysisruleaggregationpropertyParams(pydantic.BaseModel):
    aggregate_columns: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_AggregateColumnPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    dimension_columns: typing.Sequence[str] = pydantic.Field(..., description='')
    join_columns: typing.Sequence[str] = pydantic.Field(..., description='')
    output_constraints: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_AggregationConstraintPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    scalar_functions: typing.Sequence[str] = pydantic.Field(..., description='')
    allowed_join_operators: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    join_required: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnConfiguredTableDefAnalysisrulecustompropertyParams(pydantic.BaseModel):
    allowed_analyses: typing.Sequence[str] = pydantic.Field(..., description='')
    allowed_analysis_providers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    differential_privacy: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_DifferentialPrivacyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnConfiguredTableDefAnalysisrulelistpropertyParams(pydantic.BaseModel):
    join_columns: typing.Sequence[str] = pydantic.Field(..., description='')
    list_columns: typing.Sequence[str] = pydantic.Field(..., description='')
    allowed_join_operators: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnConfiguredTableDefAnalysisrulepropertyParams(pydantic.BaseModel):
    policy: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_ConfiguredTableAnalysisRulePolicyPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    ...

class CfnConfiguredTableDefConfiguredtableanalysisrulepolicypropertyParams(pydantic.BaseModel):
    v1: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_ConfiguredTableAnalysisRulePolicyV1PropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnConfiguredTableDefConfiguredtableanalysisrulepolicyv1PropertyParams(pydantic.BaseModel):
    aggregation: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_AnalysisRuleAggregationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    custom: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_AnalysisRuleCustomPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    list_: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_AnalysisRuleListPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='', alias='list')
    ...

class CfnConfiguredTableDefDifferentialprivacycolumnpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    ...

class CfnConfiguredTableDefDifferentialprivacypropertyParams(pydantic.BaseModel):
    columns: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_DifferentialPrivacyColumnPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnConfiguredTableDefGluetablereferencepropertyParams(pydantic.BaseModel):
    database_name: str = pydantic.Field(..., description='')
    table_name: str = pydantic.Field(..., description='')
    ...

class CfnConfiguredTableDefTablereferencepropertyParams(pydantic.BaseModel):
    glue: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_GlueTableReferencePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnConfiguredTableDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnConfiguredTableDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConfiguredTableDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnConfiguredTableDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConfiguredTableDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnConfiguredTableDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnConfiguredTableDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnConfiguredTableDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnConfiguredTableDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnConfiguredTableDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConfiguredTableDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnConfiguredTableDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnConfiguredTableDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConfiguredTableDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_cleanrooms.CfnConfiguredTableAssociation
class CfnConfiguredTableAssociationDef(BaseCfnResource):
    configured_table_identifier: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A unique identifier for the configured table to be associated to. Currently accepts a configured table ID.\n')
    membership_identifier: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique ID for the membership this configured table association belongs to.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the configured table association, in lowercase. The table is identified by this name when running protected queries against the underlying data.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The service will assume this role to access catalog metadata and query the table.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the configured table association.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.')
    _init_params: typing.ClassVar[list[str]] = ['configured_table_identifier', 'membership_identifier', 'name', 'role_arn', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnConfiguredTableAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cleanrooms.CfnConfiguredTableAssociationDefConfig] = pydantic.Field(None)


class CfnConfiguredTableAssociationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_cleanrooms.CfnConfiguredTableAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnConfiguredTableAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnConfiguredTableAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConfiguredTableAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnConfiguredTableAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConfiguredTableAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnConfiguredTableAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnConfiguredTableAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnConfiguredTableAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnConfiguredTableAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnConfiguredTableAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConfiguredTableAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnConfiguredTableAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnConfiguredTableAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConfiguredTableAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_cleanrooms.CfnMembership
class CfnMembershipDef(BaseCfnResource):
    collaboration_identifier: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique ID for the associated collaboration.\n')
    query_log_status: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='An indicator as to whether query logging has been enabled or disabled for the membership.\n')
    default_result_configuration: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnMembership_MembershipProtectedQueryResultConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The default protected query result configuration as specified by the member who can receive results.\n')
    payment_configuration: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnMembership_MembershipPaymentConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The payment responsibilities accepted by the collaboration member.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.')
    _init_params: typing.ClassVar[list[str]] = ['collaboration_identifier', 'query_log_status', 'default_result_configuration', 'payment_configuration', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['MembershipPaymentConfigurationProperty', 'MembershipProtectedQueryOutputConfigurationProperty', 'MembershipProtectedQueryResultConfigurationProperty', 'MembershipQueryComputePaymentConfigProperty', 'ProtectedQueryS3OutputConfigurationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnMembership'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cleanrooms.CfnMembershipDefConfig] = pydantic.Field(None)


class CfnMembershipDefConfig(pydantic.BaseModel):
    MembershipPaymentConfigurationProperty: typing.Optional[list[models.aws_cleanrooms.CfnMembershipDefMembershippaymentconfigurationpropertyParams]] = pydantic.Field(None, description='')
    MembershipProtectedQueryOutputConfigurationProperty: typing.Optional[list[models.aws_cleanrooms.CfnMembershipDefMembershipprotectedqueryoutputconfigurationpropertyParams]] = pydantic.Field(None, description='')
    MembershipProtectedQueryResultConfigurationProperty: typing.Optional[list[models.aws_cleanrooms.CfnMembershipDefMembershipprotectedqueryresultconfigurationpropertyParams]] = pydantic.Field(None, description='')
    MembershipQueryComputePaymentConfigProperty: typing.Optional[list[models.aws_cleanrooms.CfnMembershipDefMembershipquerycomputepaymentconfigpropertyParams]] = pydantic.Field(None, description='')
    ProtectedQueryS3OutputConfigurationProperty: typing.Optional[list[models.aws_cleanrooms.CfnMembershipDefProtectedquerys3OutputconfigurationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_cleanrooms.CfnMembershipDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_cleanrooms.CfnMembershipDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_cleanrooms.CfnMembershipDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_cleanrooms.CfnMembershipDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_cleanrooms.CfnMembershipDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_cleanrooms.CfnMembershipDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_cleanrooms.CfnMembershipDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_cleanrooms.CfnMembershipDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_cleanrooms.CfnMembershipDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_cleanrooms.CfnMembershipDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_cleanrooms.CfnMembershipDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_cleanrooms.CfnMembershipDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_cleanrooms.CfnMembershipDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnMembershipDefMembershippaymentconfigurationpropertyParams(pydantic.BaseModel):
    query_compute: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnMembership_MembershipQueryComputePaymentConfigPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnMembershipDefMembershipprotectedqueryoutputconfigurationpropertyParams(pydantic.BaseModel):
    s3: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnMembership_ProtectedQueryS3OutputConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnMembershipDefMembershipprotectedqueryresultconfigurationpropertyParams(pydantic.BaseModel):
    output_configuration: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnMembership_MembershipProtectedQueryOutputConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnMembershipDefMembershipquerycomputepaymentconfigpropertyParams(pydantic.BaseModel):
    is_responsible: typing.Union[bool, models.UnsupportedResource] = pydantic.Field(..., description='')
    ...

class CfnMembershipDefProtectedquerys3OutputconfigurationpropertyParams(pydantic.BaseModel):
    bucket: str = pydantic.Field(..., description='')
    result_format: str = pydantic.Field(..., description='')
    key_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnMembershipDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnMembershipDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMembershipDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnMembershipDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMembershipDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnMembershipDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnMembershipDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnMembershipDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnMembershipDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnMembershipDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMembershipDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnMembershipDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnMembershipDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMembershipDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_cleanrooms.CfnPrivacyBudgetTemplate
class CfnPrivacyBudgetTemplateDef(BaseCfnResource):
    auto_refresh: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='How often the privacy budget refreshes. .. epigraph:: If you plan to regularly bring new data into the collaboration, use ``CALENDAR_MONTH`` to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queried across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.\n')
    membership_identifier: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier for a membership resource.\n')
    parameters: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_cleanrooms.CfnPrivacyBudgetTemplate_ParametersPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the epislon and noise parameters for the privacy budget template.\n')
    privacy_budget_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the type of the privacy budget template.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An arbitrary set of tags (key-value pairs) for this cleanrooms privacy budget template.')
    _init_params: typing.ClassVar[list[str]] = ['auto_refresh', 'membership_identifier', 'parameters', 'privacy_budget_type', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['ParametersProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnPrivacyBudgetTemplate'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_cleanrooms.CfnPrivacyBudgetTemplateDefConfig] = pydantic.Field(None)


class CfnPrivacyBudgetTemplateDefConfig(pydantic.BaseModel):
    ParametersProperty: typing.Optional[list[models.aws_cleanrooms.CfnPrivacyBudgetTemplateDefParameterspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_cleanrooms.CfnPrivacyBudgetTemplateDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_cleanrooms.CfnPrivacyBudgetTemplateDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_cleanrooms.CfnPrivacyBudgetTemplateDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_cleanrooms.CfnPrivacyBudgetTemplateDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_cleanrooms.CfnPrivacyBudgetTemplateDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_cleanrooms.CfnPrivacyBudgetTemplateDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_cleanrooms.CfnPrivacyBudgetTemplateDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_cleanrooms.CfnPrivacyBudgetTemplateDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_cleanrooms.CfnPrivacyBudgetTemplateDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_cleanrooms.CfnPrivacyBudgetTemplateDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_cleanrooms.CfnPrivacyBudgetTemplateDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_cleanrooms.CfnPrivacyBudgetTemplateDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_cleanrooms.CfnPrivacyBudgetTemplateDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnPrivacyBudgetTemplateDefParameterspropertyParams(pydantic.BaseModel):
    epsilon: typing.Union[int, float] = pydantic.Field(..., description='')
    users_noise_per_query: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnPrivacyBudgetTemplateDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPrivacyBudgetTemplateDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPrivacyBudgetTemplateDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPrivacyBudgetTemplateDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPrivacyBudgetTemplateDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPrivacyBudgetTemplateDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPrivacyBudgetTemplateDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPrivacyBudgetTemplateDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPrivacyBudgetTemplateDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPrivacyBudgetTemplateDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPrivacyBudgetTemplateDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnPrivacyBudgetTemplateDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPrivacyBudgetTemplateDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPrivacyBudgetTemplateDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_cleanrooms.CfnAnalysisTemplateProps
class CfnAnalysisTemplatePropsDef(BaseCfnProperty):
    format: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The format of the analysis template.\n')
    membership_identifier: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier for a membership resource.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the analysis template.\n')
    source: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_cleanrooms.CfnAnalysisTemplate_AnalysisSourcePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The source of the analysis template.\n')
    analysis_parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnAnalysisTemplate_AnalysisParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The parameters of the analysis template.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the analysis template.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cleanrooms-analysistemplate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    cfn_analysis_template_props = cleanrooms.CfnAnalysisTemplateProps(\n        format="format",\n        membership_identifier="membershipIdentifier",\n        name="name",\n        source=cleanrooms.CfnAnalysisTemplate.AnalysisSourceProperty(\n            text="text"\n        ),\n\n        # the properties below are optional\n        analysis_parameters=[cleanrooms.CfnAnalysisTemplate.AnalysisParameterProperty(\n            name="name",\n            type="type",\n\n            # the properties below are optional\n            default_value="defaultValue"\n        )],\n        description="description",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['format', 'membership_identifier', 'name', 'source', 'analysis_parameters', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnAnalysisTemplateProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnCollaborationProps
class CfnCollaborationPropsDef(BaseCfnProperty):
    creator_display_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A display name of the collaboration creator.\n')
    creator_member_abilities: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The abilities granted to the collaboration creator. *Allowed values* ``CAN_QUERY`` | ``CAN_RECEIVE_RESULTS``\n')
    description: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A description of the collaboration provided by the collaboration owner.\n')
    members: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnCollaboration_MemberSpecificationPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of initial members, not including the creator. This list is immutable.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A human-readable identifier provided by the collaboration owner. Display names are not unique.\n')
    query_log_status: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='An indicator as to whether query logging has been enabled or disabled for the collaboration.\n')
    creator_payment_configuration: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnCollaboration_PaymentConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="An object representing the collaboration member's payment responsibilities set by the collaboration creator.\n")
    data_encryption_metadata: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnCollaboration_DataEncryptionMetadataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The settings for client-side encryption for cryptographic computing.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cleanrooms-collaboration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    cfn_collaboration_props = cleanrooms.CfnCollaborationProps(\n        creator_display_name="creatorDisplayName",\n        creator_member_abilities=["creatorMemberAbilities"],\n        description="description",\n        members=[cleanrooms.CfnCollaboration.MemberSpecificationProperty(\n            account_id="accountId",\n            display_name="displayName",\n            member_abilities=["memberAbilities"],\n\n            # the properties below are optional\n            payment_configuration=cleanrooms.CfnCollaboration.PaymentConfigurationProperty(\n                query_compute=cleanrooms.CfnCollaboration.QueryComputePaymentConfigProperty(\n                    is_responsible=False\n                )\n            )\n        )],\n        name="name",\n        query_log_status="queryLogStatus",\n\n        # the properties below are optional\n        creator_payment_configuration=cleanrooms.CfnCollaboration.PaymentConfigurationProperty(\n            query_compute=cleanrooms.CfnCollaboration.QueryComputePaymentConfigProperty(\n                is_responsible=False\n            )\n        ),\n        data_encryption_metadata=cleanrooms.CfnCollaboration.DataEncryptionMetadataProperty(\n            allow_cleartext=False,\n            allow_duplicates=False,\n            allow_joins_on_columns_with_different_names=False,\n            preserve_nulls=False\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['creator_display_name', 'creator_member_abilities', 'description', 'members', 'name', 'query_log_status', 'creator_payment_configuration', 'data_encryption_metadata', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnCollaborationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnConfiguredTableAssociationProps
class CfnConfiguredTableAssociationPropsDef(BaseCfnProperty):
    configured_table_identifier: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A unique identifier for the configured table to be associated to. Currently accepts a configured table ID.\n')
    membership_identifier: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique ID for the membership this configured table association belongs to.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the configured table association, in lowercase. The table is identified by this name when running protected queries against the underlying data.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The service will assume this role to access catalog metadata and query the table.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the configured table association.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cleanrooms-configuredtableassociation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    cfn_configured_table_association_props = cleanrooms.CfnConfiguredTableAssociationProps(\n        configured_table_identifier="configuredTableIdentifier",\n        membership_identifier="membershipIdentifier",\n        name="name",\n        role_arn="roleArn",\n\n        # the properties below are optional\n        description="description",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['configured_table_identifier', 'membership_identifier', 'name', 'role_arn', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnConfiguredTableAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnConfiguredTableProps
class CfnConfiguredTablePropsDef(BaseCfnProperty):
    allowed_columns: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The columns within the underlying AWS Glue table that can be utilized within collaborations.\n')
    analysis_method: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The analysis method for the configured table. The only valid value is currently ``DIRECT_QUERY``.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A name for the configured table.\n')
    table_reference: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_TableReferencePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The AWS Glue table that this configured table represents.\n')
    analysis_rules: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnConfiguredTable_AnalysisRulePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The entire created analysis rule.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the configured table.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cleanrooms-configuredtable.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    cfn_configured_table_props = cleanrooms.CfnConfiguredTableProps(\n        allowed_columns=["allowedColumns"],\n        analysis_method="analysisMethod",\n        name="name",\n        table_reference=cleanrooms.CfnConfiguredTable.TableReferenceProperty(\n            glue=cleanrooms.CfnConfiguredTable.GlueTableReferenceProperty(\n                database_name="databaseName",\n                table_name="tableName"\n            )\n        ),\n\n        # the properties below are optional\n        analysis_rules=[cleanrooms.CfnConfiguredTable.AnalysisRuleProperty(\n            policy=cleanrooms.CfnConfiguredTable.ConfiguredTableAnalysisRulePolicyProperty(\n                v1=cleanrooms.CfnConfiguredTable.ConfiguredTableAnalysisRulePolicyV1Property(\n                    aggregation=cleanrooms.CfnConfiguredTable.AnalysisRuleAggregationProperty(\n                        aggregate_columns=[cleanrooms.CfnConfiguredTable.AggregateColumnProperty(\n                            column_names=["columnNames"],\n                            function="function"\n                        )],\n                        dimension_columns=["dimensionColumns"],\n                        join_columns=["joinColumns"],\n                        output_constraints=[cleanrooms.CfnConfiguredTable.AggregationConstraintProperty(\n                            column_name="columnName",\n                            minimum=123,\n                            type="type"\n                        )],\n                        scalar_functions=["scalarFunctions"],\n\n                        # the properties below are optional\n                        allowed_join_operators=["allowedJoinOperators"],\n                        join_required="joinRequired"\n                    ),\n                    custom=cleanrooms.CfnConfiguredTable.AnalysisRuleCustomProperty(\n                        allowed_analyses=["allowedAnalyses"],\n\n                        # the properties below are optional\n                        allowed_analysis_providers=["allowedAnalysisProviders"],\n                        differential_privacy=cleanrooms.CfnConfiguredTable.DifferentialPrivacyProperty(\n                            columns=[cleanrooms.CfnConfiguredTable.DifferentialPrivacyColumnProperty(\n                                name="name"\n                            )]\n                        )\n                    ),\n                    list=cleanrooms.CfnConfiguredTable.AnalysisRuleListProperty(\n                        join_columns=["joinColumns"],\n                        list_columns=["listColumns"],\n\n                        # the properties below are optional\n                        allowed_join_operators=["allowedJoinOperators"]\n                    )\n                )\n            ),\n            type="type"\n        )],\n        description="description",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allowed_columns', 'analysis_method', 'name', 'table_reference', 'analysis_rules', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnConfiguredTableProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnMembershipProps
class CfnMembershipPropsDef(BaseCfnProperty):
    collaboration_identifier: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique ID for the associated collaboration.\n')
    query_log_status: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='An indicator as to whether query logging has been enabled or disabled for the membership.\n')
    default_result_configuration: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnMembership_MembershipProtectedQueryResultConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The default protected query result configuration as specified by the member who can receive results.\n')
    payment_configuration: typing.Union[models.UnsupportedResource, models.aws_cleanrooms.CfnMembership_MembershipPaymentConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The payment responsibilities accepted by the collaboration member.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cleanrooms-membership.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    cfn_membership_props = cleanrooms.CfnMembershipProps(\n        collaboration_identifier="collaborationIdentifier",\n        query_log_status="queryLogStatus",\n\n        # the properties below are optional\n        default_result_configuration=cleanrooms.CfnMembership.MembershipProtectedQueryResultConfigurationProperty(\n            output_configuration=cleanrooms.CfnMembership.MembershipProtectedQueryOutputConfigurationProperty(\n                s3=cleanrooms.CfnMembership.ProtectedQueryS3OutputConfigurationProperty(\n                    bucket="bucket",\n                    result_format="resultFormat",\n\n                    # the properties below are optional\n                    key_prefix="keyPrefix"\n                )\n            ),\n\n            # the properties below are optional\n            role_arn="roleArn"\n        ),\n        payment_configuration=cleanrooms.CfnMembership.MembershipPaymentConfigurationProperty(\n            query_compute=cleanrooms.CfnMembership.MembershipQueryComputePaymentConfigProperty(\n                is_responsible=False\n            )\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['collaboration_identifier', 'query_log_status', 'default_result_configuration', 'payment_configuration', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnMembershipProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_cleanrooms.CfnPrivacyBudgetTemplateProps
class CfnPrivacyBudgetTemplatePropsDef(BaseCfnProperty):
    auto_refresh: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='How often the privacy budget refreshes. .. epigraph:: If you plan to regularly bring new data into the collaboration, use ``CALENDAR_MONTH`` to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queried across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.\n')
    membership_identifier: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier for a membership resource.\n')
    parameters: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_cleanrooms.CfnPrivacyBudgetTemplate_ParametersPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the epislon and noise parameters for the privacy budget template.\n')
    privacy_budget_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the type of the privacy budget template.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An arbitrary set of tags (key-value pairs) for this cleanrooms privacy budget template.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cleanrooms-privacybudgettemplate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_cleanrooms as cleanrooms\n\n    cfn_privacy_budget_template_props = cleanrooms.CfnPrivacyBudgetTemplateProps(\n        auto_refresh="autoRefresh",\n        membership_identifier="membershipIdentifier",\n        parameters=cleanrooms.CfnPrivacyBudgetTemplate.ParametersProperty(\n            epsilon=123,\n            users_noise_per_query=123\n        ),\n        privacy_budget_type="privacyBudgetType",\n\n        # the properties below are optional\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['auto_refresh', 'membership_identifier', 'parameters', 'privacy_budget_type', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_cleanrooms.CfnPrivacyBudgetTemplateProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    CfnAnalysisTemplate_AnalysisParameterProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnAnalysisTemplate_AnalysisParameterPropertyDef]] = pydantic.Field(None)
    CfnAnalysisTemplate_AnalysisSchemaProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnAnalysisTemplate_AnalysisSchemaPropertyDef]] = pydantic.Field(None)
    CfnAnalysisTemplate_AnalysisSourceProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnAnalysisTemplate_AnalysisSourcePropertyDef]] = pydantic.Field(None)
    CfnCollaboration_DataEncryptionMetadataProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnCollaboration_DataEncryptionMetadataPropertyDef]] = pydantic.Field(None)
    CfnCollaboration_MemberSpecificationProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnCollaboration_MemberSpecificationPropertyDef]] = pydantic.Field(None)
    CfnCollaboration_PaymentConfigurationProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnCollaboration_PaymentConfigurationPropertyDef]] = pydantic.Field(None)
    CfnCollaboration_QueryComputePaymentConfigProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnCollaboration_QueryComputePaymentConfigPropertyDef]] = pydantic.Field(None)
    CfnConfiguredTable_AggregateColumnProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnConfiguredTable_AggregateColumnPropertyDef]] = pydantic.Field(None)
    CfnConfiguredTable_AggregationConstraintProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnConfiguredTable_AggregationConstraintPropertyDef]] = pydantic.Field(None)
    CfnConfiguredTable_AnalysisRuleAggregationProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnConfiguredTable_AnalysisRuleAggregationPropertyDef]] = pydantic.Field(None)
    CfnConfiguredTable_AnalysisRuleCustomProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnConfiguredTable_AnalysisRuleCustomPropertyDef]] = pydantic.Field(None)
    CfnConfiguredTable_AnalysisRuleListProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnConfiguredTable_AnalysisRuleListPropertyDef]] = pydantic.Field(None)
    CfnConfiguredTable_AnalysisRuleProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnConfiguredTable_AnalysisRulePropertyDef]] = pydantic.Field(None)
    CfnConfiguredTable_ConfiguredTableAnalysisRulePolicyProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnConfiguredTable_ConfiguredTableAnalysisRulePolicyPropertyDef]] = pydantic.Field(None)
    CfnConfiguredTable_ConfiguredTableAnalysisRulePolicyV1Property: typing.Optional[dict[str, models.aws_cleanrooms.CfnConfiguredTable_ConfiguredTableAnalysisRulePolicyV1PropertyDef]] = pydantic.Field(None)
    CfnConfiguredTable_DifferentialPrivacyColumnProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnConfiguredTable_DifferentialPrivacyColumnPropertyDef]] = pydantic.Field(None)
    CfnConfiguredTable_DifferentialPrivacyProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnConfiguredTable_DifferentialPrivacyPropertyDef]] = pydantic.Field(None)
    CfnConfiguredTable_GlueTableReferenceProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnConfiguredTable_GlueTableReferencePropertyDef]] = pydantic.Field(None)
    CfnConfiguredTable_TableReferenceProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnConfiguredTable_TableReferencePropertyDef]] = pydantic.Field(None)
    CfnMembership_MembershipPaymentConfigurationProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnMembership_MembershipPaymentConfigurationPropertyDef]] = pydantic.Field(None)
    CfnMembership_MembershipProtectedQueryOutputConfigurationProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnMembership_MembershipProtectedQueryOutputConfigurationPropertyDef]] = pydantic.Field(None)
    CfnMembership_MembershipProtectedQueryResultConfigurationProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnMembership_MembershipProtectedQueryResultConfigurationPropertyDef]] = pydantic.Field(None)
    CfnMembership_MembershipQueryComputePaymentConfigProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnMembership_MembershipQueryComputePaymentConfigPropertyDef]] = pydantic.Field(None)
    CfnMembership_ProtectedQueryS3OutputConfigurationProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnMembership_ProtectedQueryS3OutputConfigurationPropertyDef]] = pydantic.Field(None)
    CfnPrivacyBudgetTemplate_ParametersProperty: typing.Optional[dict[str, models.aws_cleanrooms.CfnPrivacyBudgetTemplate_ParametersPropertyDef]] = pydantic.Field(None)
    CfnAnalysisTemplate: typing.Optional[dict[str, models.aws_cleanrooms.CfnAnalysisTemplateDef]] = pydantic.Field(None)
    CfnCollaboration: typing.Optional[dict[str, models.aws_cleanrooms.CfnCollaborationDef]] = pydantic.Field(None)
    CfnConfiguredTable: typing.Optional[dict[str, models.aws_cleanrooms.CfnConfiguredTableDef]] = pydantic.Field(None)
    CfnConfiguredTableAssociation: typing.Optional[dict[str, models.aws_cleanrooms.CfnConfiguredTableAssociationDef]] = pydantic.Field(None)
    CfnMembership: typing.Optional[dict[str, models.aws_cleanrooms.CfnMembershipDef]] = pydantic.Field(None)
    CfnPrivacyBudgetTemplate: typing.Optional[dict[str, models.aws_cleanrooms.CfnPrivacyBudgetTemplateDef]] = pydantic.Field(None)
    CfnAnalysisTemplateProps: typing.Optional[dict[str, models.aws_cleanrooms.CfnAnalysisTemplatePropsDef]] = pydantic.Field(None)
    CfnCollaborationProps: typing.Optional[dict[str, models.aws_cleanrooms.CfnCollaborationPropsDef]] = pydantic.Field(None)
    CfnConfiguredTableAssociationProps: typing.Optional[dict[str, models.aws_cleanrooms.CfnConfiguredTableAssociationPropsDef]] = pydantic.Field(None)
    CfnConfiguredTableProps: typing.Optional[dict[str, models.aws_cleanrooms.CfnConfiguredTablePropsDef]] = pydantic.Field(None)
    CfnMembershipProps: typing.Optional[dict[str, models.aws_cleanrooms.CfnMembershipPropsDef]] = pydantic.Field(None)
    CfnPrivacyBudgetTemplateProps: typing.Optional[dict[str, models.aws_cleanrooms.CfnPrivacyBudgetTemplatePropsDef]] = pydantic.Field(None)
    ...

import models
