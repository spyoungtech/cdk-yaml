from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty
class CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef(BaseStruct):
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='True if this audit check is enabled for this account.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    audit_check_configuration_property = iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n        enabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnAccountAuditConfiguration.AuditCheckConfigurationsProperty
class CfnAccountAuditConfiguration_AuditCheckConfigurationsPropertyDef(BaseStruct):
    authenticated_cognito_role_overly_permissive_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Checks the permissiveness of an authenticated Amazon Cognito identity pool role. For this check, AWS IoT Device Defender audits all Amazon Cognito identity pools that have been used to connect to the AWS IoT message broker during the 31 days before the audit is performed.\n')
    ca_certificate_expiring_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Checks if a CA certificate is expiring. This check applies to CA certificates expiring within 30 days or that have expired.\n')
    ca_certificate_key_quality_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Checks the quality of the CA certificate key. The quality checks if the key is in a valid format, not expired, and if the key meets a minimum required size. This check applies to CA certificates that are ``ACTIVE`` or ``PENDING_TRANSFER`` .\n')
    conflicting_client_ids_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Checks if multiple devices connect using the same client ID.\n')
    device_certificate_expiring_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Checks if a device certificate is expiring. This check applies to device certificates expiring within 30 days or that have expired.\n')
    device_certificate_key_quality_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Checks the quality of the device certificate key. The quality checks if the key is in a valid format, not expired, signed by a registered certificate authority, and if the key meets a minimum required size.\n')
    device_certificate_shared_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Checks if multiple concurrent connections use the same X.509 certificate to authenticate with AWS IoT .\n')
    intermediate_ca_revoked_for_active_device_certificates_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration for a specific audit check.\n')
    iot_policy_overly_permissive_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Checks the permissiveness of a policy attached to an authenticated Amazon Cognito identity pool role.\n')
    io_t_policy_potential_mis_configuration_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration for a specific audit check.\n')
    iot_role_alias_allows_access_to_unused_services_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Checks if a role alias has access to services that haven't been used for the AWS IoT device in the last year.\n")
    iot_role_alias_overly_permissive_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Checks if the temporary credentials provided by AWS IoT role aliases are overly permissive.\n')
    logging_disabled_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Checks if AWS IoT logs are disabled.\n')
    revoked_ca_certificate_still_active_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Checks if a revoked CA certificate is still active.\n')
    revoked_device_certificate_still_active_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Checks if a revoked device certificate is still active.\n')
    unauthenticated_cognito_role_overly_permissive_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Checks if policy attached to an unauthenticated Amazon Cognito identity pool role is too permissive.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    audit_check_configurations_property = iot.CfnAccountAuditConfiguration.AuditCheckConfigurationsProperty(\n        authenticated_cognito_role_overly_permissive_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n            enabled=False\n        ),\n        ca_certificate_expiring_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n            enabled=False\n        ),\n        ca_certificate_key_quality_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n            enabled=False\n        ),\n        conflicting_client_ids_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n            enabled=False\n        ),\n        device_certificate_expiring_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n            enabled=False\n        ),\n        device_certificate_key_quality_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n            enabled=False\n        ),\n        device_certificate_shared_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n            enabled=False\n        ),\n        intermediate_ca_revoked_for_active_device_certificates_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n            enabled=False\n        ),\n        iot_policy_overly_permissive_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n            enabled=False\n        ),\n        io_tPolicy_potential_mis_configuration_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n            enabled=False\n        ),\n        iot_role_alias_allows_access_to_unused_services_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n            enabled=False\n        ),\n        iot_role_alias_overly_permissive_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n            enabled=False\n        ),\n        logging_disabled_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n            enabled=False\n        ),\n        revoked_ca_certificate_still_active_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n            enabled=False\n        ),\n        revoked_device_certificate_still_active_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n            enabled=False\n        ),\n        unauthenticated_cognito_role_overly_permissive_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n            enabled=False\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['authenticated_cognito_role_overly_permissive_check', 'ca_certificate_expiring_check', 'ca_certificate_key_quality_check', 'conflicting_client_ids_check', 'device_certificate_expiring_check', 'device_certificate_key_quality_check', 'device_certificate_shared_check', 'intermediate_ca_revoked_for_active_device_certificates_check', 'iot_policy_overly_permissive_check', 'io_t_policy_potential_mis_configuration_check', 'iot_role_alias_allows_access_to_unused_services_check', 'iot_role_alias_overly_permissive_check', 'logging_disabled_check', 'revoked_ca_certificate_still_active_check', 'revoked_device_certificate_still_active_check', 'unauthenticated_cognito_role_overly_permissive_check']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnAccountAuditConfiguration.AuditCheckConfigurationsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnAccountAuditConfiguration.AuditNotificationTargetConfigurationsProperty
class CfnAccountAuditConfiguration_AuditNotificationTargetConfigurationsPropertyDef(BaseStruct):
    sns: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditNotificationTargetPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The ``Sns`` notification target.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditnotificationtargetconfigurations.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    audit_notification_target_configurations_property = iot.CfnAccountAuditConfiguration.AuditNotificationTargetConfigurationsProperty(\n        sns=iot.CfnAccountAuditConfiguration.AuditNotificationTargetProperty(\n            enabled=False,\n            role_arn="roleArn",\n            target_arn="targetArn"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['sns']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnAccountAuditConfiguration.AuditNotificationTargetConfigurationsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnAccountAuditConfiguration.AuditNotificationTargetProperty
class CfnAccountAuditConfiguration_AuditNotificationTargetPropertyDef(BaseStruct):
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='True if notifications to the target are enabled.\n')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the role that grants permission to send notifications to the target.\n')
    target_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the target (SNS topic) to which audit notifications are sent.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditnotificationtarget.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    audit_notification_target_property = iot.CfnAccountAuditConfiguration.AuditNotificationTargetProperty(\n        enabled=False,\n        role_arn="roleArn",\n        target_arn="targetArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'role_arn', 'target_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnAccountAuditConfiguration.AuditNotificationTargetProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnBillingGroup.BillingGroupPropertiesProperty
class CfnBillingGroup_BillingGroupPropertiesPropertyDef(BaseStruct):
    billing_group_description: typing.Optional[str] = pydantic.Field(None, description='The description of the billing group.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-billinggroup-billinggroupproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    billing_group_properties_property = iot.CfnBillingGroup.BillingGroupPropertiesProperty(\n        billing_group_description="billingGroupDescription"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['billing_group_description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnBillingGroup.BillingGroupPropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnCACertificate.RegistrationConfigProperty
class CfnCACertificate_RegistrationConfigPropertyDef(BaseStruct):
    role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the role.\n')
    template_body: typing.Optional[str] = pydantic.Field(None, description='The template body.\n')
    template_name: typing.Optional[str] = pydantic.Field(None, description='The name of the provisioning template.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-cacertificate-registrationconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    registration_config_property = iot.CfnCACertificate.RegistrationConfigProperty(\n        role_arn="roleArn",\n        template_body="templateBody",\n        template_name="templateName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['role_arn', 'template_body', 'template_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnCACertificate.RegistrationConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnDomainConfiguration.AuthorizerConfigProperty
class CfnDomainConfiguration_AuthorizerConfigPropertyDef(BaseStruct):
    allow_authorizer_override: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="A Boolean that specifies whether the domain configuration's authorization service can be overridden.\n")
    default_authorizer_name: typing.Optional[str] = pydantic.Field(None, description='The name of the authorization service for a domain configuration.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-domainconfiguration-authorizerconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    authorizer_config_property = iot.CfnDomainConfiguration.AuthorizerConfigProperty(\n        allow_authorizer_override=False,\n        default_authorizer_name="defaultAuthorizerName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allow_authorizer_override', 'default_authorizer_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnDomainConfiguration.AuthorizerConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnDomainConfiguration.ServerCertificateSummaryProperty
class CfnDomainConfiguration_ServerCertificateSummaryPropertyDef(BaseStruct):
    server_certificate_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the server certificate.\n')
    server_certificate_status: typing.Optional[str] = pydantic.Field(None, description='The status of the server certificate.\n')
    server_certificate_status_detail: typing.Optional[str] = pydantic.Field(None, description='Details that explain the status of the server certificate.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-domainconfiguration-servercertificatesummary.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    server_certificate_summary_property = iot.CfnDomainConfiguration.ServerCertificateSummaryProperty(\n        server_certificate_arn="serverCertificateArn",\n        server_certificate_status="serverCertificateStatus",\n        server_certificate_status_detail="serverCertificateStatusDetail"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['server_certificate_arn', 'server_certificate_status', 'server_certificate_status_detail']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnDomainConfiguration.ServerCertificateSummaryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnDomainConfiguration.TlsConfigProperty
class CfnDomainConfiguration_TlsConfigPropertyDef(BaseStruct):
    security_policy: typing.Optional[str] = pydantic.Field(None, description='The security policy for a domain configuration. For more information, see `Security policies <https://docs.aws.amazon.com/iot/latest/developerguide/transport-security.html#tls-policy-table>`_ in the *AWS IoT Core developer guide* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-domainconfiguration-tlsconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    tls_config_property = iot.CfnDomainConfiguration.TlsConfigProperty(\n        security_policy="securityPolicy"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['security_policy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnDomainConfiguration.TlsConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnFleetMetric.AggregationTypeProperty
class CfnFleetMetric_AggregationTypePropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the aggregation type.\n')
    values: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of the values of aggregation types.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-fleetmetric-aggregationtype.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    aggregation_type_property = iot.CfnFleetMetric.AggregationTypeProperty(\n        name="name",\n        values=["values"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'values']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnFleetMetric.AggregationTypeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnJobTemplate.AbortConfigProperty
class CfnJobTemplate_AbortConfigPropertyDef(BaseStruct):
    criteria_list: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnJobTemplate_AbortCriteriaPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The list of criteria that determine when and how to abort the job.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-abortconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    abort_config_property = iot.CfnJobTemplate.AbortConfigProperty(\n        criteria_list=[iot.CfnJobTemplate.AbortCriteriaProperty(\n            action="action",\n            failure_type="failureType",\n            min_number_of_executed_things=123,\n            threshold_percentage=123\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['criteria_list']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnJobTemplate.AbortConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnJobTemplate.AbortCriteriaProperty
class CfnJobTemplate_AbortCriteriaPropertyDef(BaseStruct):
    action: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of job action to take to initiate the job abort.\n')
    failure_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of job execution failures that can initiate a job abort.\n')
    min_number_of_executed_things: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The minimum number of things which must receive job execution notifications before the job can be aborted.\n')
    threshold_percentage: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The minimum percentage of job execution failures that must occur to initiate the job abort. AWS IoT Core supports up to two digits after the decimal (for example, 10.9 and 10.99, but not 10.999).\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-abortcriteria.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    abort_criteria_property = iot.CfnJobTemplate.AbortCriteriaProperty(\n        action="action",\n        failure_type="failureType",\n        min_number_of_executed_things=123,\n        threshold_percentage=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action', 'failure_type', 'min_number_of_executed_things', 'threshold_percentage']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnJobTemplate.AbortCriteriaProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnJobTemplate.ExponentialRolloutRateProperty
class CfnJobTemplate_ExponentialRolloutRatePropertyDef(BaseStruct):
    base_rate_per_minute: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The minimum number of things that will be notified of a pending job, per minute at the start of job rollout. This parameter allows you to define the initial rate of rollout.\n')
    increment_factor: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The exponential factor to increase the rate of rollout for a job. AWS IoT Core supports up to one digit after the decimal (for example, 1.5, but not 1.55).\n')
    rate_increase_criteria: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_iot.CfnJobTemplate_RateIncreaseCriteriaPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The criteria to initiate the increase in rate of rollout for a job.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-exponentialrolloutrate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    exponential_rollout_rate_property = iot.CfnJobTemplate.ExponentialRolloutRateProperty(\n        base_rate_per_minute=123,\n        increment_factor=123,\n        rate_increase_criteria=iot.CfnJobTemplate.RateIncreaseCriteriaProperty(\n            number_of_notified_things=123,\n            number_of_succeeded_things=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['base_rate_per_minute', 'increment_factor', 'rate_increase_criteria']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnJobTemplate.ExponentialRolloutRateProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnJobTemplate.JobExecutionsRetryConfigProperty
class CfnJobTemplate_JobExecutionsRetryConfigPropertyDef(BaseStruct):
    retry_criteria_list: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnJobTemplate_RetryCriteriaPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The list of criteria that determines how many retries are allowed for each failure type for a job.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-jobexecutionsretryconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    job_executions_retry_config_property = iot.CfnJobTemplate.JobExecutionsRetryConfigProperty(\n        retry_criteria_list=[iot.CfnJobTemplate.RetryCriteriaProperty(\n            failure_type="failureType",\n            number_of_retries=123\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['retry_criteria_list']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnJobTemplate.JobExecutionsRetryConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnJobTemplate.JobExecutionsRolloutConfigProperty
class CfnJobTemplate_JobExecutionsRolloutConfigPropertyDef(BaseStruct):
    exponential_rollout_rate: typing.Union[models.UnsupportedResource, models.aws_iot.CfnJobTemplate_ExponentialRolloutRatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The rate of increase for a job rollout. This parameter allows you to define an exponential rate for a job rollout.\n')
    maximum_per_minute: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of things that will be notified of a pending job, per minute. This parameter allows you to create a staged rollout.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-jobexecutionsrolloutconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    job_executions_rollout_config_property = iot.CfnJobTemplate.JobExecutionsRolloutConfigProperty(\n        exponential_rollout_rate=iot.CfnJobTemplate.ExponentialRolloutRateProperty(\n            base_rate_per_minute=123,\n            increment_factor=123,\n            rate_increase_criteria=iot.CfnJobTemplate.RateIncreaseCriteriaProperty(\n                number_of_notified_things=123,\n                number_of_succeeded_things=123\n            )\n        ),\n        maximum_per_minute=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['exponential_rollout_rate', 'maximum_per_minute']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnJobTemplate.JobExecutionsRolloutConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnJobTemplate.MaintenanceWindowProperty
class CfnJobTemplate_MaintenanceWindowPropertyDef(BaseStruct):
    duration_in_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='Displays the duration of the next maintenance window.\n')
    start_time: typing.Optional[str] = pydantic.Field(None, description='Displays the start time of the next maintenance window.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-maintenancewindow.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    maintenance_window_property = iot.CfnJobTemplate.MaintenanceWindowProperty(\n        duration_in_minutes=123,\n        start_time="startTime"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['duration_in_minutes', 'start_time']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnJobTemplate.MaintenanceWindowProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnJobTemplate.PresignedUrlConfigProperty
class CfnJobTemplate_PresignedUrlConfigPropertyDef(BaseStruct):
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of an IAM role that grants grants permission to download files from the S3 bucket where the job data/updates are stored. The role must also grant permission for IoT to download the files. .. epigraph:: For information about addressing the confused deputy problem, see `cross-service confused deputy prevention <https://docs.aws.amazon.com/iot/latest/developerguide/cross-service-confused-deputy-prevention.html>`_ in the *AWS IoT Core developer guide* .\n')
    expires_in_sec: typing.Union[int, float, None] = pydantic.Field(None, description='How long (in seconds) pre-signed URLs are valid. Valid values are 60 - 3600, the default value is 3600 seconds. Pre-signed URLs are generated when Jobs receives an MQTT request for the job document.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-presignedurlconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    presigned_url_config_property = iot.CfnJobTemplate.PresignedUrlConfigProperty(\n        role_arn="roleArn",\n\n        # the properties below are optional\n        expires_in_sec=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['role_arn', 'expires_in_sec']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnJobTemplate.PresignedUrlConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnJobTemplate.RateIncreaseCriteriaProperty
class CfnJobTemplate_RateIncreaseCriteriaPropertyDef(BaseStruct):
    number_of_notified_things: typing.Union[int, float, None] = pydantic.Field(None, description='The threshold for number of notified things that will initiate the increase in rate of rollout.\n')
    number_of_succeeded_things: typing.Union[int, float, None] = pydantic.Field(None, description='The threshold for number of succeeded things that will initiate the increase in rate of rollout.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-rateincreasecriteria.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    rate_increase_criteria_property = iot.CfnJobTemplate.RateIncreaseCriteriaProperty(\n        number_of_notified_things=123,\n        number_of_succeeded_things=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['number_of_notified_things', 'number_of_succeeded_things']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnJobTemplate.RateIncreaseCriteriaProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnJobTemplate.RetryCriteriaProperty
class CfnJobTemplate_RetryCriteriaPropertyDef(BaseStruct):
    failure_type: typing.Optional[str] = pydantic.Field(None, description='The type of job execution failures that can initiate a job retry.\n')
    number_of_retries: typing.Union[int, float, None] = pydantic.Field(None, description='The number of retries allowed for a failure type for the job.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-retrycriteria.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    retry_criteria_property = iot.CfnJobTemplate.RetryCriteriaProperty(\n        failure_type="failureType",\n        number_of_retries=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['failure_type', 'number_of_retries']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnJobTemplate.RetryCriteriaProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnJobTemplate.TimeoutConfigProperty
class CfnJobTemplate_TimeoutConfigPropertyDef(BaseStruct):
    in_progress_timeout_in_minutes: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description="Specifies the amount of time, in minutes, this device has to finish execution of this job. The timeout interval can be anywhere between 1 minute and 7 days (1 to 10080 minutes). The in progress timer can't be updated and will apply to all job executions for the job. Whenever a job execution remains in the IN_PROGRESS status for longer than this interval, the job execution will fail and switch to the terminal ``TIMED_OUT`` status.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-jobtemplate-timeoutconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    timeout_config_property = iot.CfnJobTemplate.TimeoutConfigProperty(\n        in_progress_timeout_in_minutes=123\n    )\n")
    _init_params: typing.ClassVar[list[str]] = ['in_progress_timeout_in_minutes']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnJobTemplate.TimeoutConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnMitigationAction.ActionParamsProperty
class CfnMitigationAction_ActionParamsPropertyDef(BaseStruct):
    add_things_to_thing_group_params: typing.Union[models.UnsupportedResource, models.aws_iot.CfnMitigationAction_AddThingsToThingGroupParamsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies the group to which you want to add the devices.\n')
    enable_io_t_logging_params: typing.Union[models.UnsupportedResource, models.aws_iot.CfnMitigationAction_EnableIoTLoggingParamsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies the logging level and the role with permissions for logging. You cannot specify a logging level of ``DISABLED`` .\n')
    publish_finding_to_sns_params: typing.Union[models.UnsupportedResource, models.aws_iot.CfnMitigationAction_PublishFindingToSnsParamsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies the topic to which the finding should be published.\n')
    replace_default_policy_version_params: typing.Union[models.UnsupportedResource, models.aws_iot.CfnMitigationAction_ReplaceDefaultPolicyVersionParamsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Replaces the policy version with a default or blank policy. You specify the template name. Only a value of ``BLANK_POLICY`` is currently supported.\n')
    update_ca_certificate_params: typing.Union[models.UnsupportedResource, models.aws_iot.CfnMitigationAction_UpdateCACertificateParamsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies the new state for the CA certificate. Only a value of ``DEACTIVATE`` is currently supported.\n')
    update_device_certificate_params: typing.Union[models.UnsupportedResource, models.aws_iot.CfnMitigationAction_UpdateDeviceCertificateParamsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies the new state for a device certificate. Only a value of ``DEACTIVATE`` is currently supported.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-actionparams.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    action_params_property = iot.CfnMitigationAction.ActionParamsProperty(\n        add_things_to_thing_group_params=iot.CfnMitigationAction.AddThingsToThingGroupParamsProperty(\n            thing_group_names=["thingGroupNames"],\n\n            # the properties below are optional\n            override_dynamic_groups=False\n        ),\n        enable_io_tLogging_params=iot.CfnMitigationAction.EnableIoTLoggingParamsProperty(\n            log_level="logLevel",\n            role_arn_for_logging="roleArnForLogging"\n        ),\n        publish_finding_to_sns_params=iot.CfnMitigationAction.PublishFindingToSnsParamsProperty(\n            topic_arn="topicArn"\n        ),\n        replace_default_policy_version_params=iot.CfnMitigationAction.ReplaceDefaultPolicyVersionParamsProperty(\n            template_name="templateName"\n        ),\n        update_ca_certificate_params=iot.CfnMitigationAction.UpdateCACertificateParamsProperty(\n            action="action"\n        ),\n        update_device_certificate_params=iot.CfnMitigationAction.UpdateDeviceCertificateParamsProperty(\n            action="action"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['add_things_to_thing_group_params', 'enable_io_t_logging_params', 'publish_finding_to_sns_params', 'replace_default_policy_version_params', 'update_ca_certificate_params', 'update_device_certificate_params']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnMitigationAction.ActionParamsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnMitigationAction.AddThingsToThingGroupParamsProperty
class CfnMitigationAction_AddThingsToThingGroupParamsPropertyDef(BaseStruct):
    thing_group_names: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The list of groups to which you want to add the things that triggered the mitigation action. You can add a thing to a maximum of 10 groups, but you can't add a thing to more than one group in the same hierarchy.\n")
    override_dynamic_groups: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies if this mitigation action can move the things that triggered the mitigation action even if they are part of one or more dynamic thing groups.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-addthingstothinggroupparams.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    add_things_to_thing_group_params_property = iot.CfnMitigationAction.AddThingsToThingGroupParamsProperty(\n        thing_group_names=["thingGroupNames"],\n\n        # the properties below are optional\n        override_dynamic_groups=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['thing_group_names', 'override_dynamic_groups']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnMitigationAction.AddThingsToThingGroupParamsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnMitigationAction.EnableIoTLoggingParamsProperty
class CfnMitigationAction_EnableIoTLoggingParamsPropertyDef(BaseStruct):
    log_level: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the type of information to be logged.\n')
    role_arn_for_logging: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the IAM role used for logging.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-enableiotloggingparams.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    enable_io_tLogging_params_property = iot.CfnMitigationAction.EnableIoTLoggingParamsProperty(\n        log_level="logLevel",\n        role_arn_for_logging="roleArnForLogging"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['log_level', 'role_arn_for_logging']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnMitigationAction.EnableIoTLoggingParamsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnMitigationAction.PublishFindingToSnsParamsProperty
class CfnMitigationAction_PublishFindingToSnsParamsPropertyDef(BaseStruct):
    topic_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the topic to which you want to publish the findings.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-publishfindingtosnsparams.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    publish_finding_to_sns_params_property = iot.CfnMitigationAction.PublishFindingToSnsParamsProperty(\n        topic_arn="topicArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['topic_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnMitigationAction.PublishFindingToSnsParamsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnMitigationAction.ReplaceDefaultPolicyVersionParamsProperty
class CfnMitigationAction_ReplaceDefaultPolicyVersionParamsPropertyDef(BaseStruct):
    template_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the template to be applied. The only supported value is ``BLANK_POLICY`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-replacedefaultpolicyversionparams.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    replace_default_policy_version_params_property = iot.CfnMitigationAction.ReplaceDefaultPolicyVersionParamsProperty(\n        template_name="templateName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['template_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnMitigationAction.ReplaceDefaultPolicyVersionParamsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnMitigationAction.UpdateCACertificateParamsProperty
class CfnMitigationAction_UpdateCACertificateParamsPropertyDef(BaseStruct):
    action: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The action that you want to apply to the CA certificate. The only supported value is ``DEACTIVATE`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-updatecacertificateparams.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    update_cACertificate_params_property = iot.CfnMitigationAction.UpdateCACertificateParamsProperty(\n        action="action"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnMitigationAction.UpdateCACertificateParamsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnMitigationAction.UpdateDeviceCertificateParamsProperty
class CfnMitigationAction_UpdateDeviceCertificateParamsPropertyDef(BaseStruct):
    action: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The action that you want to apply to the device certificate. The only supported value is ``DEACTIVATE`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-mitigationaction-updatedevicecertificateparams.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    update_device_certificate_params_property = iot.CfnMitigationAction.UpdateDeviceCertificateParamsProperty(\n        action="action"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnMitigationAction.UpdateDeviceCertificateParamsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnProvisioningTemplate.ProvisioningHookProperty
class CfnProvisioningTemplate_ProvisioningHookPropertyDef(BaseStruct):
    payload_version: typing.Optional[str] = pydantic.Field(None, description='The payload that was sent to the target function. The valid payload is ``"2020-04-01"`` .\n')
    target_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the target function.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-provisioningtemplate-provisioninghook.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    provisioning_hook_property = iot.CfnProvisioningTemplate.ProvisioningHookProperty(\n        payload_version="payloadVersion",\n        target_arn="targetArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['payload_version', 'target_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnProvisioningTemplate.ProvisioningHookProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnSecurityProfile.AlertTargetProperty
class CfnSecurityProfile_AlertTargetPropertyDef(BaseStruct):
    alert_target_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the notification target to which alerts are sent.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the role that grants permission to send alerts to the notification target.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-alerttarget.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    alert_target_property = iot.CfnSecurityProfile.AlertTargetProperty(\n        alert_target_arn="alertTargetArn",\n        role_arn="roleArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['alert_target_arn', 'role_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnSecurityProfile.AlertTargetProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnSecurityProfile.BehaviorCriteriaProperty
class CfnSecurityProfile_BehaviorCriteriaPropertyDef(BaseStruct):
    comparison_operator: typing.Optional[str] = pydantic.Field(None, description='The operator that relates the thing measured ( ``metric`` ) to the criteria (containing a ``value`` or ``statisticalThreshold`` ). Valid operators include: - ``string-list`` : ``in-set`` and ``not-in-set`` - ``number-list`` : ``in-set`` and ``not-in-set`` - ``ip-address-list`` : ``in-cidr-set`` and ``not-in-cidr-set`` - ``number`` : ``less-than`` , ``less-than-equals`` , ``greater-than`` , and ``greater-than-equals``\n')
    consecutive_datapoints_to_alarm: typing.Union[int, float, None] = pydantic.Field(None, description='If a device is in violation of the behavior for the specified number of consecutive datapoints, an alarm occurs. If not specified, the default is 1.\n')
    consecutive_datapoints_to_clear: typing.Union[int, float, None] = pydantic.Field(None, description='If an alarm has occurred and the offending device is no longer in violation of the behavior for the specified number of consecutive datapoints, the alarm is cleared. If not specified, the default is 1.\n')
    duration_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='Use this to specify the time duration over which the behavior is evaluated, for those criteria that have a time dimension (for example, ``NUM_MESSAGES_SENT`` ). For a ``statisticalThreshhold`` metric comparison, measurements from all devices are accumulated over this time duration before being used to calculate percentiles, and later, measurements from an individual device are also accumulated over this time duration before being given a percentile rank. Cannot be used with list-based metric datatypes.\n')
    ml_detection_config: typing.Union[models.UnsupportedResource, models.aws_iot.CfnSecurityProfile_MachineLearningDetectionConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The confidence level of the detection model.\n')
    statistical_threshold: typing.Union[models.UnsupportedResource, models.aws_iot.CfnSecurityProfile_StatisticalThresholdPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A statistical ranking (percentile)that indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.\n')
    value: typing.Union[models.UnsupportedResource, models.aws_iot.CfnSecurityProfile_MetricValuePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The value to be compared with the ``metric`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-behaviorcriteria.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    behavior_criteria_property = iot.CfnSecurityProfile.BehaviorCriteriaProperty(\n        comparison_operator="comparisonOperator",\n        consecutive_datapoints_to_alarm=123,\n        consecutive_datapoints_to_clear=123,\n        duration_seconds=123,\n        ml_detection_config=iot.CfnSecurityProfile.MachineLearningDetectionConfigProperty(\n            confidence_level="confidenceLevel"\n        ),\n        statistical_threshold=iot.CfnSecurityProfile.StatisticalThresholdProperty(\n            statistic="statistic"\n        ),\n        value=iot.CfnSecurityProfile.MetricValueProperty(\n            cidrs=["cidrs"],\n            count="count",\n            number=123,\n            numbers=[123],\n            ports=[123],\n            strings=["strings"]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['comparison_operator', 'consecutive_datapoints_to_alarm', 'consecutive_datapoints_to_clear', 'duration_seconds', 'ml_detection_config', 'statistical_threshold', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnSecurityProfile.BehaviorCriteriaProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnSecurityProfile.BehaviorProperty
class CfnSecurityProfile_BehaviorPropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The name you've given to the behavior.\n")
    criteria: typing.Union[models.UnsupportedResource, models.aws_iot.CfnSecurityProfile_BehaviorCriteriaPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The criteria that determine if a device is behaving normally in regard to the ``metric`` . .. epigraph:: In the AWS IoT console, you can choose to be sent an alert through Amazon SNS when AWS IoT Device Defender detects that a device is behaving anomalously.\n')
    metric: typing.Optional[str] = pydantic.Field(None, description='What is measured by the behavior.\n')
    metric_dimension: typing.Union[models.UnsupportedResource, models.aws_iot.CfnSecurityProfile_MetricDimensionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The dimension of the metric.\n')
    suppress_alerts: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='The alert status. If you set the value to ``true`` , alerts will be suppressed.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-behavior.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    behavior_property = iot.CfnSecurityProfile.BehaviorProperty(\n        name="name",\n\n        # the properties below are optional\n        criteria=iot.CfnSecurityProfile.BehaviorCriteriaProperty(\n            comparison_operator="comparisonOperator",\n            consecutive_datapoints_to_alarm=123,\n            consecutive_datapoints_to_clear=123,\n            duration_seconds=123,\n            ml_detection_config=iot.CfnSecurityProfile.MachineLearningDetectionConfigProperty(\n                confidence_level="confidenceLevel"\n            ),\n            statistical_threshold=iot.CfnSecurityProfile.StatisticalThresholdProperty(\n                statistic="statistic"\n            ),\n            value=iot.CfnSecurityProfile.MetricValueProperty(\n                cidrs=["cidrs"],\n                count="count",\n                number=123,\n                numbers=[123],\n                ports=[123],\n                strings=["strings"]\n            )\n        ),\n        metric="metric",\n        metric_dimension=iot.CfnSecurityProfile.MetricDimensionProperty(\n            dimension_name="dimensionName",\n\n            # the properties below are optional\n            operator="operator"\n        ),\n        suppress_alerts=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'criteria', 'metric', 'metric_dimension', 'suppress_alerts']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnSecurityProfile.BehaviorProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnSecurityProfile.MachineLearningDetectionConfigProperty
class CfnSecurityProfile_MachineLearningDetectionConfigPropertyDef(BaseStruct):
    confidence_level: typing.Optional[str] = pydantic.Field(None, description='The model confidence level. There are three levels of confidence, ``"high"`` , ``"medium"`` , and ``"low"`` . The higher the confidence level, the lower the sensitivity, and the lower the alarm frequency will be.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-machinelearningdetectionconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    machine_learning_detection_config_property = iot.CfnSecurityProfile.MachineLearningDetectionConfigProperty(\n        confidence_level="confidenceLevel"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['confidence_level']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnSecurityProfile.MachineLearningDetectionConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnSecurityProfile.MetricDimensionProperty
class CfnSecurityProfile_MetricDimensionPropertyDef(BaseStruct):
    dimension_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the dimension.\n')
    operator: typing.Optional[str] = pydantic.Field(None, description='Operators are constructs that perform logical operations. Valid values are ``IN`` and ``NOT_IN`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-metricdimension.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    metric_dimension_property = iot.CfnSecurityProfile.MetricDimensionProperty(\n        dimension_name="dimensionName",\n\n        # the properties below are optional\n        operator="operator"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['dimension_name', 'operator']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnSecurityProfile.MetricDimensionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnSecurityProfile.MetricToRetainProperty
class CfnSecurityProfile_MetricToRetainPropertyDef(BaseStruct):
    metric: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A standard of measurement.\n')
    metric_dimension: typing.Union[models.UnsupportedResource, models.aws_iot.CfnSecurityProfile_MetricDimensionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The dimension of the metric.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-metrictoretain.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    metric_to_retain_property = iot.CfnSecurityProfile.MetricToRetainProperty(\n        metric="metric",\n\n        # the properties below are optional\n        metric_dimension=iot.CfnSecurityProfile.MetricDimensionProperty(\n            dimension_name="dimensionName",\n\n            # the properties below are optional\n            operator="operator"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['metric', 'metric_dimension']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnSecurityProfile.MetricToRetainProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnSecurityProfile.MetricValueProperty
class CfnSecurityProfile_MetricValuePropertyDef(BaseStruct):
    cidrs: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='If the ``comparisonOperator`` calls for a set of CIDRs, use this to specify that set to be compared with the ``metric`` .\n')
    count: typing.Optional[str] = pydantic.Field(None, description='If the ``comparisonOperator`` calls for a numeric value, use this to specify that numeric value to be compared with the ``metric`` .\n')
    number: typing.Union[int, float, None] = pydantic.Field(None, description='The numeric values of a metric.\n')
    numbers: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[int, float]], None] = pydantic.Field(None, description='The numeric value of a metric.\n')
    ports: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[int, float]], None] = pydantic.Field(None, description='If the ``comparisonOperator`` calls for a set of ports, use this to specify that set to be compared with the ``metric`` .\n')
    strings: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The string values of a metric.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-metricvalue.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    metric_value_property = iot.CfnSecurityProfile.MetricValueProperty(\n        cidrs=["cidrs"],\n        count="count",\n        number=123,\n        numbers=[123],\n        ports=[123],\n        strings=["strings"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cidrs', 'count', 'number', 'numbers', 'ports', 'strings']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnSecurityProfile.MetricValueProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnSecurityProfile.StatisticalThresholdProperty
class CfnSecurityProfile_StatisticalThresholdPropertyDef(BaseStruct):
    statistic: typing.Optional[str] = pydantic.Field(None, description='The percentile that resolves to a threshold value by which compliance with a behavior is determined. Metrics are collected over the specified period ( ``durationSeconds`` ) from all reporting devices in your account and statistical ranks are calculated. Then, the measurements from a device are collected over the same period. If the accumulated measurements from the device fall above or below ( ``comparisonOperator`` ) the value associated with the percentile specified, then the device is considered to be in compliance with the behavior, otherwise a violation occurs.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-securityprofile-statisticalthreshold.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    statistical_threshold_property = iot.CfnSecurityProfile.StatisticalThresholdProperty(\n        statistic="statistic"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['statistic']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnSecurityProfile.StatisticalThresholdProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnThing.AttributePayloadProperty
class CfnThing_AttributePayloadPropertyDef(BaseStruct):
    attributes: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='A JSON string containing up to three key-value pair in JSON format. For example:. ``{\\"attributes\\":{\\"string1\\":\\"string2\\"}}``\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-thing-attributepayload.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    attribute_payload_property = iot.CfnThing.AttributePayloadProperty(\n        attributes={\n            "attributes_key": "attributes"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['attributes']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnThing.AttributePayloadProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnThingGroup.AttributePayloadProperty
class CfnThingGroup_AttributePayloadPropertyDef(BaseStruct):
    attributes: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='A JSON string containing up to three key-value pair in JSON format. For example:. ``{\\"attributes\\":{\\"string1\\":\\"string2\\"}}``\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-thinggroup-attributepayload.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    attribute_payload_property = iot.CfnThingGroup.AttributePayloadProperty(\n        attributes={\n            "attributes_key": "attributes"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['attributes']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnThingGroup.AttributePayloadProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnThingGroup.ThingGroupPropertiesProperty
class CfnThingGroup_ThingGroupPropertiesPropertyDef(BaseStruct):
    attribute_payload: typing.Union[models.UnsupportedResource, models.aws_iot.CfnThingGroup_AttributePayloadPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The thing group attributes in JSON format.\n')
    thing_group_description: typing.Optional[str] = pydantic.Field(None, description='The thing group description.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-thinggroup-thinggroupproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    thing_group_properties_property = iot.CfnThingGroup.ThingGroupPropertiesProperty(\n        attribute_payload=iot.CfnThingGroup.AttributePayloadProperty(\n            attributes={\n                "attributes_key": "attributes"\n            }\n        ),\n        thing_group_description="thingGroupDescription"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['attribute_payload', 'thing_group_description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnThingGroup.ThingGroupPropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnThingType.ThingTypePropertiesProperty
class CfnThingType_ThingTypePropertiesPropertyDef(BaseStruct):
    searchable_attributes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of searchable thing attribute names.\n')
    thing_type_description: typing.Optional[str] = pydantic.Field(None, description='The description of the thing type.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-thingtype-thingtypeproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    thing_type_properties_property = iot.CfnThingType.ThingTypePropertiesProperty(\n        searchable_attributes=["searchableAttributes"],\n        thing_type_description="thingTypeDescription"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['searchable_attributes', 'thing_type_description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnThingType.ThingTypePropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.ActionProperty
class CfnTopicRule_ActionPropertyDef(BaseStruct):
    cloudwatch_alarm: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_CloudwatchAlarmActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Change the state of a CloudWatch alarm.\n')
    cloudwatch_logs: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_CloudwatchLogsActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Sends data to CloudWatch.\n')
    cloudwatch_metric: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_CloudwatchMetricActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Capture a CloudWatch metric.\n')
    dynamo_db: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_DynamoDBActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Write to a DynamoDB table.\n')
    dynamo_d_bv2: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_DynamoDBv2ActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Write to a DynamoDB table. This is a new version of the DynamoDB action. It allows you to write each attribute in an MQTT message payload into a separate DynamoDB column.\n')
    elasticsearch: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_ElasticsearchActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Write data to an Amazon OpenSearch Service domain. .. epigraph:: The ``Elasticsearch`` action can only be used by existing rule actions. To create a new rule action or to update an existing rule action, use the ``OpenSearch`` rule action instead. For more information, see `OpenSearchAction <https://docs.aws.amazon.com//iot/latest/apireference/API_OpenSearchAction.html>`_ .\n')
    firehose: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_FirehoseActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Write to an Amazon Kinesis Firehose stream.\n')
    http: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_HttpActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Send data to an HTTPS endpoint.\n')
    iot_analytics: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_IotAnalyticsActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Sends message data to an AWS IoT Analytics channel.\n')
    iot_events: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_IotEventsActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Sends an input to an AWS IoT Events detector.\n')
    iot_site_wise: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_IotSiteWiseActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Sends data from the MQTT message that triggered the rule to AWS IoT SiteWise asset properties.\n')
    kafka: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_KafkaActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Send messages to an Amazon Managed Streaming for Apache Kafka (Amazon MSK) or self-managed Apache Kafka cluster.\n')
    kinesis: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_KinesisActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Write data to an Amazon Kinesis stream.\n')
    lambda_: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_LambdaActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Invoke a Lambda function.\n')
    location: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_LocationActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Sends device location data to `Amazon Location Service <https://docs.aws.amazon.com//location/latest/developerguide/welcome.html>`_ .\n')
    open_search: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_OpenSearchActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Write data to an Amazon OpenSearch Service domain.\n')
    republish: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_RepublishActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Publish to another MQTT topic.\n')
    s3: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_S3ActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Write to an Amazon S3 bucket.\n')
    sns: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_SnsActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Publish to an Amazon SNS topic.\n')
    sqs: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_SqsActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Publish to an Amazon SQS queue.\n')
    step_functions: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_StepFunctionsActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Starts execution of a Step Functions state machine.\n')
    timestream: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_TimestreamActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Writes attributes from an MQTT message.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-action.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    action_property = iot.CfnTopicRule.ActionProperty(\n        cloudwatch_alarm=iot.CfnTopicRule.CloudwatchAlarmActionProperty(\n            alarm_name="alarmName",\n            role_arn="roleArn",\n            state_reason="stateReason",\n            state_value="stateValue"\n        ),\n        cloudwatch_logs=iot.CfnTopicRule.CloudwatchLogsActionProperty(\n            log_group_name="logGroupName",\n            role_arn="roleArn",\n\n            # the properties below are optional\n            batch_mode=False\n        ),\n        cloudwatch_metric=iot.CfnTopicRule.CloudwatchMetricActionProperty(\n            metric_name="metricName",\n            metric_namespace="metricNamespace",\n            metric_unit="metricUnit",\n            metric_value="metricValue",\n            role_arn="roleArn",\n\n            # the properties below are optional\n            metric_timestamp="metricTimestamp"\n        ),\n        dynamo_db=iot.CfnTopicRule.DynamoDBActionProperty(\n            hash_key_field="hashKeyField",\n            hash_key_value="hashKeyValue",\n            role_arn="roleArn",\n            table_name="tableName",\n\n            # the properties below are optional\n            hash_key_type="hashKeyType",\n            payload_field="payloadField",\n            range_key_field="rangeKeyField",\n            range_key_type="rangeKeyType",\n            range_key_value="rangeKeyValue"\n        ),\n        dynamo_dBv2=iot.CfnTopicRule.DynamoDBv2ActionProperty(\n            put_item=iot.CfnTopicRule.PutItemInputProperty(\n                table_name="tableName"\n            ),\n            role_arn="roleArn"\n        ),\n        elasticsearch=iot.CfnTopicRule.ElasticsearchActionProperty(\n            endpoint="endpoint",\n            id="id",\n            index="index",\n            role_arn="roleArn",\n            type="type"\n        ),\n        firehose=iot.CfnTopicRule.FirehoseActionProperty(\n            delivery_stream_name="deliveryStreamName",\n            role_arn="roleArn",\n\n            # the properties below are optional\n            batch_mode=False,\n            separator="separator"\n        ),\n        http=iot.CfnTopicRule.HttpActionProperty(\n            url="url",\n\n            # the properties below are optional\n            auth=iot.CfnTopicRule.HttpAuthorizationProperty(\n                sigv4=iot.CfnTopicRule.SigV4AuthorizationProperty(\n                    role_arn="roleArn",\n                    service_name="serviceName",\n                    signing_region="signingRegion"\n                )\n            ),\n            confirmation_url="confirmationUrl",\n            headers=[iot.CfnTopicRule.HttpActionHeaderProperty(\n                key="key",\n                value="value"\n            )]\n        ),\n        iot_analytics=iot.CfnTopicRule.IotAnalyticsActionProperty(\n            channel_name="channelName",\n            role_arn="roleArn",\n\n            # the properties below are optional\n            batch_mode=False\n        ),\n        iot_events=iot.CfnTopicRule.IotEventsActionProperty(\n            input_name="inputName",\n            role_arn="roleArn",\n\n            # the properties below are optional\n            batch_mode=False,\n            message_id="messageId"\n        ),\n        iot_site_wise=iot.CfnTopicRule.IotSiteWiseActionProperty(\n            put_asset_property_value_entries=[iot.CfnTopicRule.PutAssetPropertyValueEntryProperty(\n                property_values=[iot.CfnTopicRule.AssetPropertyValueProperty(\n                    timestamp=iot.CfnTopicRule.AssetPropertyTimestampProperty(\n                        time_in_seconds="timeInSeconds",\n\n                        # the properties below are optional\n                        offset_in_nanos="offsetInNanos"\n                    ),\n                    value=iot.CfnTopicRule.AssetPropertyVariantProperty(\n                        boolean_value="booleanValue",\n                        double_value="doubleValue",\n                        integer_value="integerValue",\n                        string_value="stringValue"\n                    ),\n\n                    # the properties below are optional\n                    quality="quality"\n                )],\n\n                # the properties below are optional\n                asset_id="assetId",\n                entry_id="entryId",\n                property_alias="propertyAlias",\n                property_id="propertyId"\n            )],\n            role_arn="roleArn"\n        ),\n        kafka=iot.CfnTopicRule.KafkaActionProperty(\n            client_properties={\n                "client_properties_key": "clientProperties"\n            },\n            destination_arn="destinationArn",\n            topic="topic",\n\n            # the properties below are optional\n            headers=[iot.CfnTopicRule.KafkaActionHeaderProperty(\n                key="key",\n                value="value"\n            )],\n            key="key",\n            partition="partition"\n        ),\n        kinesis=iot.CfnTopicRule.KinesisActionProperty(\n            role_arn="roleArn",\n            stream_name="streamName",\n\n            # the properties below are optional\n            partition_key="partitionKey"\n        ),\n        lambda_=iot.CfnTopicRule.LambdaActionProperty(\n            function_arn="functionArn"\n        ),\n        location=iot.CfnTopicRule.LocationActionProperty(\n            device_id="deviceId",\n            latitude="latitude",\n            longitude="longitude",\n            role_arn="roleArn",\n            tracker_name="trackerName",\n\n            # the properties below are optional\n            timestamp=iot.CfnTopicRule.TimestampProperty(\n                value="value",\n\n                # the properties below are optional\n                unit="unit"\n            )\n        ),\n        open_search=iot.CfnTopicRule.OpenSearchActionProperty(\n            endpoint="endpoint",\n            id="id",\n            index="index",\n            role_arn="roleArn",\n            type="type"\n        ),\n        republish=iot.CfnTopicRule.RepublishActionProperty(\n            role_arn="roleArn",\n            topic="topic",\n\n            # the properties below are optional\n            headers=iot.CfnTopicRule.RepublishActionHeadersProperty(\n                content_type="contentType",\n                correlation_data="correlationData",\n                message_expiry="messageExpiry",\n                payload_format_indicator="payloadFormatIndicator",\n                response_topic="responseTopic",\n                user_properties=[iot.CfnTopicRule.UserPropertyProperty(\n                    key="key",\n                    value="value"\n                )]\n            ),\n            qos=123\n        ),\n        s3=iot.CfnTopicRule.S3ActionProperty(\n            bucket_name="bucketName",\n            key="key",\n            role_arn="roleArn",\n\n            # the properties below are optional\n            canned_acl="cannedAcl"\n        ),\n        sns=iot.CfnTopicRule.SnsActionProperty(\n            role_arn="roleArn",\n            target_arn="targetArn",\n\n            # the properties below are optional\n            message_format="messageFormat"\n        ),\n        sqs=iot.CfnTopicRule.SqsActionProperty(\n            queue_url="queueUrl",\n            role_arn="roleArn",\n\n            # the properties below are optional\n            use_base64=False\n        ),\n        step_functions=iot.CfnTopicRule.StepFunctionsActionProperty(\n            role_arn="roleArn",\n            state_machine_name="stateMachineName",\n\n            # the properties below are optional\n            execution_name_prefix="executionNamePrefix"\n        ),\n        timestream=iot.CfnTopicRule.TimestreamActionProperty(\n            database_name="databaseName",\n            dimensions=[iot.CfnTopicRule.TimestreamDimensionProperty(\n                name="name",\n                value="value"\n            )],\n            role_arn="roleArn",\n            table_name="tableName",\n\n            # the properties below are optional\n            timestamp=iot.CfnTopicRule.TimestreamTimestampProperty(\n                unit="unit",\n                value="value"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cloudwatch_alarm', 'cloudwatch_logs', 'cloudwatch_metric', 'dynamo_db', 'dynamo_d_bv2', 'elasticsearch', 'firehose', 'http', 'iot_analytics', 'iot_events', 'iot_site_wise', 'kafka', 'kinesis', 'lambda_', 'location', 'open_search', 'republish', 's3', 'sns', 'sqs', 'step_functions', 'timestream']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.ActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.AssetPropertyTimestampProperty
class CfnTopicRule_AssetPropertyTimestampPropertyDef(BaseStruct):
    time_in_seconds: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A string that contains the time in seconds since epoch. Accepts substitution templates.\n')
    offset_in_nanos: typing.Optional[str] = pydantic.Field(None, description='Optional. A string that contains the nanosecond time offset. Accepts substitution templates.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-assetpropertytimestamp.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    asset_property_timestamp_property = iot.CfnTopicRule.AssetPropertyTimestampProperty(\n        time_in_seconds="timeInSeconds",\n\n        # the properties below are optional\n        offset_in_nanos="offsetInNanos"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['time_in_seconds', 'offset_in_nanos']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.AssetPropertyTimestampProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.AssetPropertyValueProperty
class CfnTopicRule_AssetPropertyValuePropertyDef(BaseStruct):
    timestamp: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_iot.CfnTopicRule_AssetPropertyTimestampPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The asset property value timestamp.\n')
    value: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_iot.CfnTopicRule_AssetPropertyVariantPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The value of the asset property.\n')
    quality: typing.Optional[str] = pydantic.Field(None, description='Optional. A string that describes the quality of the value. Accepts substitution templates. Must be ``GOOD`` , ``BAD`` , or ``UNCERTAIN`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-assetpropertyvalue.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    asset_property_value_property = iot.CfnTopicRule.AssetPropertyValueProperty(\n        timestamp=iot.CfnTopicRule.AssetPropertyTimestampProperty(\n            time_in_seconds="timeInSeconds",\n\n            # the properties below are optional\n            offset_in_nanos="offsetInNanos"\n        ),\n        value=iot.CfnTopicRule.AssetPropertyVariantProperty(\n            boolean_value="booleanValue",\n            double_value="doubleValue",\n            integer_value="integerValue",\n            string_value="stringValue"\n        ),\n\n        # the properties below are optional\n        quality="quality"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['timestamp', 'value', 'quality']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.AssetPropertyValueProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.AssetPropertyVariantProperty
class CfnTopicRule_AssetPropertyVariantPropertyDef(BaseStruct):
    boolean_value: typing.Optional[str] = pydantic.Field(None, description='Optional. A string that contains the boolean value ( ``true`` or ``false`` ) of the value entry. Accepts substitution templates.\n')
    double_value: typing.Optional[str] = pydantic.Field(None, description='Optional. A string that contains the double value of the value entry. Accepts substitution templates.\n')
    integer_value: typing.Optional[str] = pydantic.Field(None, description='Optional. A string that contains the integer value of the value entry. Accepts substitution templates.\n')
    string_value: typing.Optional[str] = pydantic.Field(None, description='Optional. The string value of the value entry. Accepts substitution templates.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-assetpropertyvariant.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    asset_property_variant_property = iot.CfnTopicRule.AssetPropertyVariantProperty(\n        boolean_value="booleanValue",\n        double_value="doubleValue",\n        integer_value="integerValue",\n        string_value="stringValue"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['boolean_value', 'double_value', 'integer_value', 'string_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.AssetPropertyVariantProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.CloudwatchAlarmActionProperty
class CfnTopicRule_CloudwatchAlarmActionPropertyDef(BaseStruct):
    alarm_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The CloudWatch alarm name.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The IAM role that allows access to the CloudWatch alarm.\n')
    state_reason: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The reason for the alarm change.\n')
    state_value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-cloudwatchalarmaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cloudwatch_alarm_action_property = iot.CfnTopicRule.CloudwatchAlarmActionProperty(\n        alarm_name="alarmName",\n        role_arn="roleArn",\n        state_reason="stateReason",\n        state_value="stateValue"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['alarm_name', 'role_arn', 'state_reason', 'state_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.CloudwatchAlarmActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.CloudwatchLogsActionProperty
class CfnTopicRule_CloudwatchLogsActionPropertyDef(BaseStruct):
    log_group_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The CloudWatch log name.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The IAM role that allows access to the CloudWatch log.\n')
    batch_mode: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether batches of log records will be extracted and uploaded into CloudWatch.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-cloudwatchlogsaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cloudwatch_logs_action_property = iot.CfnTopicRule.CloudwatchLogsActionProperty(\n        log_group_name="logGroupName",\n        role_arn="roleArn",\n\n        # the properties below are optional\n        batch_mode=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['log_group_name', 'role_arn', 'batch_mode']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.CloudwatchLogsActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.CloudwatchMetricActionProperty
class CfnTopicRule_CloudwatchMetricActionPropertyDef(BaseStruct):
    metric_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The CloudWatch metric name.\n')
    metric_namespace: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The CloudWatch metric namespace name.\n')
    metric_unit: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The `metric unit <https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit>`_ supported by CloudWatch.\n')
    metric_value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The CloudWatch metric value.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The IAM role that allows access to the CloudWatch metric.\n')
    metric_timestamp: typing.Optional[str] = pydantic.Field(None, description='An optional `Unix timestamp <https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-cloudwatchmetricaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cloudwatch_metric_action_property = iot.CfnTopicRule.CloudwatchMetricActionProperty(\n        metric_name="metricName",\n        metric_namespace="metricNamespace",\n        metric_unit="metricUnit",\n        metric_value="metricValue",\n        role_arn="roleArn",\n\n        # the properties below are optional\n        metric_timestamp="metricTimestamp"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['metric_name', 'metric_namespace', 'metric_unit', 'metric_value', 'role_arn', 'metric_timestamp']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.CloudwatchMetricActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.DynamoDBActionProperty
class CfnTopicRule_DynamoDBActionPropertyDef(BaseStruct):
    hash_key_field: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The hash key name.\n')
    hash_key_value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The hash key value.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the IAM role that grants access to the DynamoDB table.\n')
    table_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the DynamoDB table.\n')
    hash_key_type: typing.Optional[str] = pydantic.Field(None, description='The hash key type. Valid values are "STRING" or "NUMBER"\n')
    payload_field: typing.Optional[str] = pydantic.Field(None, description='The action payload. This name can be customized.\n')
    range_key_field: typing.Optional[str] = pydantic.Field(None, description='The range key name.\n')
    range_key_type: typing.Optional[str] = pydantic.Field(None, description='The range key type. Valid values are "STRING" or "NUMBER"\n')
    range_key_value: typing.Optional[str] = pydantic.Field(None, description='The range key value.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-dynamodbaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    dynamo_dBAction_property = iot.CfnTopicRule.DynamoDBActionProperty(\n        hash_key_field="hashKeyField",\n        hash_key_value="hashKeyValue",\n        role_arn="roleArn",\n        table_name="tableName",\n\n        # the properties below are optional\n        hash_key_type="hashKeyType",\n        payload_field="payloadField",\n        range_key_field="rangeKeyField",\n        range_key_type="rangeKeyType",\n        range_key_value="rangeKeyValue"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['hash_key_field', 'hash_key_value', 'role_arn', 'table_name', 'hash_key_type', 'payload_field', 'range_key_field', 'range_key_type', 'range_key_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.DynamoDBActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.DynamoDBv2ActionProperty
class CfnTopicRule_DynamoDBv2ActionPropertyDef(BaseStruct):
    put_item: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_PutItemInputPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies the DynamoDB table to which the message data will be written. For example:. ``{ "dynamoDBv2": { "roleArn": "aws:iam:12341251:my-role" "putItem": { "tableName": "my-table" } } }`` Each attribute in the message payload will be written to a separate column in the DynamoDB database.\n')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the IAM role that grants access to the DynamoDB table.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-dynamodbv2action.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    dynamo_dBv2_action_property = iot.CfnTopicRule.DynamoDBv2ActionProperty(\n        put_item=iot.CfnTopicRule.PutItemInputProperty(\n            table_name="tableName"\n        ),\n        role_arn="roleArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['put_item', 'role_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.DynamoDBv2ActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.ElasticsearchActionProperty
class CfnTopicRule_ElasticsearchActionPropertyDef(BaseStruct):
    endpoint: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The endpoint of your OpenSearch domain.\n')
    index: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The index where you want to store your data.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The IAM role ARN that has access to OpenSearch.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of document you are storing.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-elasticsearchaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    elasticsearch_action_property = iot.CfnTopicRule.ElasticsearchActionProperty(\n        endpoint="endpoint",\n        id="id",\n        index="index",\n        role_arn="roleArn",\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['endpoint', 'index', 'role_arn', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.ElasticsearchActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.FirehoseActionProperty
class CfnTopicRule_FirehoseActionPropertyDef(BaseStruct):
    delivery_stream_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The delivery stream name.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The IAM role that grants access to the Amazon Kinesis Firehose stream.\n')
    batch_mode: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="Whether to deliver the Kinesis Data Firehose stream as a batch by using ```PutRecordBatch`` <https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html>`_ . The default value is ``false`` . When ``batchMode`` is ``true`` and the rule's SQL statement evaluates to an Array, each Array element forms one record in the ```PutRecordBatch`` <https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html>`_ request. The resulting array can't have more than 500 records.\n")
    separator: typing.Optional[str] = pydantic.Field(None, description='A character separator that will be used to separate records written to the Firehose stream. Valid values are: \'\\n\' (newline), \'\\t\' (tab), \'\\r\\n\' (Windows newline), \',\' (comma).\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-firehoseaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    firehose_action_property = iot.CfnTopicRule.FirehoseActionProperty(\n        delivery_stream_name="deliveryStreamName",\n        role_arn="roleArn",\n\n        # the properties below are optional\n        batch_mode=False,\n        separator="separator"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['delivery_stream_name', 'role_arn', 'batch_mode', 'separator']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.FirehoseActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.HttpActionHeaderProperty
class CfnTopicRule_HttpActionHeaderPropertyDef(BaseStruct):
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The HTTP header key.\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The HTTP header value. Substitution templates are supported.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-httpactionheader.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    http_action_header_property = iot.CfnTopicRule.HttpActionHeaderProperty(\n        key="key",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.HttpActionHeaderProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.HttpActionProperty
class CfnTopicRule_HttpActionPropertyDef(BaseStruct):
    url: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The endpoint URL. If substitution templates are used in the URL, you must also specify a ``confirmationUrl`` . If this is a new destination, a new ``TopicRuleDestination`` is created if possible.\n')
    auth: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_HttpAuthorizationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The authentication method to use when sending data to an HTTPS endpoint.\n')
    confirmation_url: typing.Optional[str] = pydantic.Field(None, description='The URL to which AWS IoT sends a confirmation message. The value of the confirmation URL must be a prefix of the endpoint URL. If you do not specify a confirmation URL AWS IoT uses the endpoint URL as the confirmation URL. If you use substitution templates in the confirmationUrl, you must create and enable topic rule destinations that match each possible value of the substitution template before traffic is allowed to your endpoint URL.\n')
    headers: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_HttpActionHeaderPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The HTTP headers to send with the message data.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-httpaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    http_action_property = iot.CfnTopicRule.HttpActionProperty(\n        url="url",\n\n        # the properties below are optional\n        auth=iot.CfnTopicRule.HttpAuthorizationProperty(\n            sigv4=iot.CfnTopicRule.SigV4AuthorizationProperty(\n                role_arn="roleArn",\n                service_name="serviceName",\n                signing_region="signingRegion"\n            )\n        ),\n        confirmation_url="confirmationUrl",\n        headers=[iot.CfnTopicRule.HttpActionHeaderProperty(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['url', 'auth', 'confirmation_url', 'headers']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.HttpActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.HttpAuthorizationProperty
class CfnTopicRule_HttpAuthorizationPropertyDef(BaseStruct):
    sigv4: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_SigV4AuthorizationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Use Sig V4 authorization. For more information, see `Signature Version 4 Signing Process <https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-httpauthorization.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    http_authorization_property = iot.CfnTopicRule.HttpAuthorizationProperty(\n        sigv4=iot.CfnTopicRule.SigV4AuthorizationProperty(\n            role_arn="roleArn",\n            service_name="serviceName",\n            signing_region="signingRegion"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['sigv4']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.HttpAuthorizationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.IotAnalyticsActionProperty
class CfnTopicRule_IotAnalyticsActionPropertyDef(BaseStruct):
    channel_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the IoT Analytics channel to which message data will be sent.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the role which has a policy that grants IoT Analytics permission to send message data via IoT Analytics (iotanalytics:BatchPutMessage).\n')
    batch_mode: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Whether to process the action as a batch. The default value is ``false`` . When ``batchMode`` is ``true`` and the rule SQL statement evaluates to an Array, each Array element is delivered as a separate message when passed by ```BatchPutMessage`` <https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_BatchPutMessage.html>`_ The resulting array can\'t have more than 100 messages.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-iotanalyticsaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    iot_analytics_action_property = iot.CfnTopicRule.IotAnalyticsActionProperty(\n        channel_name="channelName",\n        role_arn="roleArn",\n\n        # the properties below are optional\n        batch_mode=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['channel_name', 'role_arn', 'batch_mode']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.IotAnalyticsActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.IotEventsActionProperty
class CfnTopicRule_IotEventsActionPropertyDef(BaseStruct):
    input_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the AWS IoT Events input.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the role that grants AWS IoT permission to send an input to an AWS IoT Events detector. ("Action":"iotevents:BatchPutMessage").\n')
    batch_mode: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="Whether to process the event actions as a batch. The default value is ``false`` . When ``batchMode`` is ``true`` , you can't specify a ``messageId`` . When ``batchMode`` is ``true`` and the rule SQL statement evaluates to an Array, each Array element is treated as a separate message when Events by calling ```BatchPutMessage`` <https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchPutMessage.html>`_ . The resulting array can't have more than 10 messages.\n")
    message_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the message. The default ``messageId`` is a new UUID value. When ``batchMode`` is ``true`` , you can\'t specify a ``messageId`` --a new UUID value will be assigned. Assign a value to this property to ensure that only one input (message) with a given ``messageId`` will be processed by an AWS IoT Events detector.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-ioteventsaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    iot_events_action_property = iot.CfnTopicRule.IotEventsActionProperty(\n        input_name="inputName",\n        role_arn="roleArn",\n\n        # the properties below are optional\n        batch_mode=False,\n        message_id="messageId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['input_name', 'role_arn', 'batch_mode', 'message_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.IotEventsActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.IotSiteWiseActionProperty
class CfnTopicRule_IotSiteWiseActionPropertyDef(BaseStruct):
    put_asset_property_value_entries: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_PutAssetPropertyValueEntryPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of asset property value entries.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the role that grants AWS IoT permission to send an asset property value to AWS IoT SiteWise. ( ``"Action": "iotsitewise:BatchPutAssetPropertyValue"`` ). The trust policy can restrict access to specific asset hierarchy paths.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-iotsitewiseaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    iot_site_wise_action_property = iot.CfnTopicRule.IotSiteWiseActionProperty(\n        put_asset_property_value_entries=[iot.CfnTopicRule.PutAssetPropertyValueEntryProperty(\n            property_values=[iot.CfnTopicRule.AssetPropertyValueProperty(\n                timestamp=iot.CfnTopicRule.AssetPropertyTimestampProperty(\n                    time_in_seconds="timeInSeconds",\n\n                    # the properties below are optional\n                    offset_in_nanos="offsetInNanos"\n                ),\n                value=iot.CfnTopicRule.AssetPropertyVariantProperty(\n                    boolean_value="booleanValue",\n                    double_value="doubleValue",\n                    integer_value="integerValue",\n                    string_value="stringValue"\n                ),\n\n                # the properties below are optional\n                quality="quality"\n            )],\n\n            # the properties below are optional\n            asset_id="assetId",\n            entry_id="entryId",\n            property_alias="propertyAlias",\n            property_id="propertyId"\n        )],\n        role_arn="roleArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['put_asset_property_value_entries', 'role_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.IotSiteWiseActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.KafkaActionHeaderProperty
class CfnTopicRule_KafkaActionHeaderPropertyDef(BaseStruct):
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The key of the Kafka header.\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The value of the Kafka header.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-kafkaactionheader.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    kafka_action_header_property = iot.CfnTopicRule.KafkaActionHeaderProperty(\n        key="key",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.KafkaActionHeaderProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.KafkaActionProperty
class CfnTopicRule_KafkaActionPropertyDef(BaseStruct):
    client_properties: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Mapping[str, str]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Properties of the Apache Kafka producer client.\n')
    destination_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The ARN of Kafka action's VPC ``TopicRuleDestination`` .\n")
    topic: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Kafka topic for messages to be sent to the Kafka broker.\n')
    headers: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_KafkaActionHeaderPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The list of Kafka headers that you specify.\n')
    key: typing.Optional[str] = pydantic.Field(None, description='The Kafka message key.\n')
    partition: typing.Optional[str] = pydantic.Field(None, description='The Kafka message partition.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-kafkaaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    kafka_action_property = iot.CfnTopicRule.KafkaActionProperty(\n        client_properties={\n            "client_properties_key": "clientProperties"\n        },\n        destination_arn="destinationArn",\n        topic="topic",\n\n        # the properties below are optional\n        headers=[iot.CfnTopicRule.KafkaActionHeaderProperty(\n            key="key",\n            value="value"\n        )],\n        key="key",\n        partition="partition"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['client_properties', 'destination_arn', 'topic', 'headers', 'key', 'partition']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.KafkaActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.KinesisActionProperty
class CfnTopicRule_KinesisActionPropertyDef(BaseStruct):
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the IAM role that grants access to the Amazon Kinesis stream.\n')
    stream_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the Amazon Kinesis stream.\n')
    partition_key: typing.Optional[str] = pydantic.Field(None, description='The partition key.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-kinesisaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    kinesis_action_property = iot.CfnTopicRule.KinesisActionProperty(\n        role_arn="roleArn",\n        stream_name="streamName",\n\n        # the properties below are optional\n        partition_key="partitionKey"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['role_arn', 'stream_name', 'partition_key']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.KinesisActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.LambdaActionProperty
class CfnTopicRule_LambdaActionPropertyDef(BaseStruct):
    function_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the Lambda function.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-lambdaaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    lambda_action_property = iot.CfnTopicRule.LambdaActionProperty(\n        function_arn="functionArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['function_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.LambdaActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.LocationActionProperty
class CfnTopicRule_LocationActionPropertyDef(BaseStruct):
    device_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique ID of the device providing the location data.\n')
    latitude: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="A string that evaluates to a double value that represents the latitude of the device's location.\n")
    longitude: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="A string that evaluates to a double value that represents the longitude of the device's location.\n")
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The IAM role that grants permission to write to the Amazon Location resource.\n')
    tracker_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the tracker resource in Amazon Location in which the location is updated.\n')
    timestamp: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_TimestampPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The time that the location data was sampled. The default value is the time the MQTT message was processed.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-locationaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    location_action_property = iot.CfnTopicRule.LocationActionProperty(\n        device_id="deviceId",\n        latitude="latitude",\n        longitude="longitude",\n        role_arn="roleArn",\n        tracker_name="trackerName",\n\n        # the properties below are optional\n        timestamp=iot.CfnTopicRule.TimestampProperty(\n            value="value",\n\n            # the properties below are optional\n            unit="unit"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['device_id', 'latitude', 'longitude', 'role_arn', 'tracker_name', 'timestamp']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.LocationActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.OpenSearchActionProperty
class CfnTopicRule_OpenSearchActionPropertyDef(BaseStruct):
    endpoint: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The endpoint of your OpenSearch domain.\n')
    index: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The OpenSearch index where you want to store your data.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The IAM role ARN that has access to OpenSearch.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of document you are storing.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-opensearchaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    open_search_action_property = iot.CfnTopicRule.OpenSearchActionProperty(\n        endpoint="endpoint",\n        id="id",\n        index="index",\n        role_arn="roleArn",\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['endpoint', 'index', 'role_arn', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.OpenSearchActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.PutAssetPropertyValueEntryProperty
class CfnTopicRule_PutAssetPropertyValueEntryPropertyDef(BaseStruct):
    property_values: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_AssetPropertyValuePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of property values to insert that each contain timestamp, quality, and value (TQV) information.\n')
    asset_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the AWS IoT SiteWise asset. You must specify either a ``propertyAlias`` or both an ``aliasId`` and a ``propertyId`` . Accepts substitution templates.\n')
    entry_id: typing.Optional[str] = pydantic.Field(None, description='Optional. A unique identifier for this entry that you can define to better track which message caused an error in case of failure. Accepts substitution templates. Defaults to a new UUID.\n')
    property_alias: typing.Optional[str] = pydantic.Field(None, description='The name of the property alias associated with your asset property. You must specify either a ``propertyAlias`` or both an ``aliasId`` and a ``propertyId`` . Accepts substitution templates.\n')
    property_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the asset\'s property. You must specify either a ``propertyAlias`` or both an ``aliasId`` and a ``propertyId`` . Accepts substitution templates.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-putassetpropertyvalueentry.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    put_asset_property_value_entry_property = iot.CfnTopicRule.PutAssetPropertyValueEntryProperty(\n        property_values=[iot.CfnTopicRule.AssetPropertyValueProperty(\n            timestamp=iot.CfnTopicRule.AssetPropertyTimestampProperty(\n                time_in_seconds="timeInSeconds",\n\n                # the properties below are optional\n                offset_in_nanos="offsetInNanos"\n            ),\n            value=iot.CfnTopicRule.AssetPropertyVariantProperty(\n                boolean_value="booleanValue",\n                double_value="doubleValue",\n                integer_value="integerValue",\n                string_value="stringValue"\n            ),\n\n            # the properties below are optional\n            quality="quality"\n        )],\n\n        # the properties below are optional\n        asset_id="assetId",\n        entry_id="entryId",\n        property_alias="propertyAlias",\n        property_id="propertyId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['property_values', 'asset_id', 'entry_id', 'property_alias', 'property_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.PutAssetPropertyValueEntryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.PutItemInputProperty
class CfnTopicRule_PutItemInputPropertyDef(BaseStruct):
    table_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The table where the message data will be written.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-putiteminput.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    put_item_input_property = iot.CfnTopicRule.PutItemInputProperty(\n        table_name="tableName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['table_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.PutItemInputProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.RepublishActionHeadersProperty
class CfnTopicRule_RepublishActionHeadersPropertyDef(BaseStruct):
    content_type: typing.Optional[str] = pydantic.Field(None, description='A UTF-8 encoded string that describes the content of the publishing message. For more information, see `Content Type <https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901118>`_ in the MQTT Version 5.0 specification. Supports `substitution templates <https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html>`_ .\n')
    correlation_data: typing.Optional[str] = pydantic.Field(None, description='The base64-encoded binary data used by the sender of the request message to identify which request the response message is for. For more information, see `Correlation Data <https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901115>`_ in the MQTT Version 5.0 specification. Supports `substitution templates <https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html>`_ . .. epigraph:: This binary data must be base64-encoded.\n')
    message_expiry: typing.Optional[str] = pydantic.Field(None, description="A user-defined integer value that represents the message expiry interval at the broker. If the messages haven't been sent to the subscribers within that interval, the message expires and is removed. The value of ``messageExpiry`` represents the number of seconds before it expires. For more information about the limits of ``messageExpiry`` , see `Message broker and protocol limits and quotas <https://docs.aws.amazon.com//general/latest/gr/iot-core.html#limits_iot>`_ in the IoT Core Reference Guide. Supports `substitution templates <https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html>`_ .\n")
    payload_format_indicator: typing.Optional[str] = pydantic.Field(None, description='An ``Enum`` string value that indicates whether the payload is formatted as UTF-8. Valid values are ``UNSPECIFIED_BYTES`` and ``UTF8_DATA`` . For more information, see `Payload Format Indicator <https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901111>`_ from the MQTT Version 5.0 specification. Supports `substitution templates <https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html>`_ .\n')
    response_topic: typing.Optional[str] = pydantic.Field(None, description="A UTF-8 encoded string that's used as the topic name for a response message. The response topic is used to describe the topic to which the receiver should publish as part of the request-response flow. The topic must not contain wildcard characters. For more information, see `Response Topic <https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901114>`_ in the MQTT Version 5.0 specification. Supports `substitution templates <https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html>`_ .\n")
    user_properties: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_UserPropertyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An array of key-value pairs that you define in the MQTT5 header.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-republishactionheaders.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    republish_action_headers_property = iot.CfnTopicRule.RepublishActionHeadersProperty(\n        content_type="contentType",\n        correlation_data="correlationData",\n        message_expiry="messageExpiry",\n        payload_format_indicator="payloadFormatIndicator",\n        response_topic="responseTopic",\n        user_properties=[iot.CfnTopicRule.UserPropertyProperty(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['content_type', 'correlation_data', 'message_expiry', 'payload_format_indicator', 'response_topic', 'user_properties']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.RepublishActionHeadersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.RepublishActionProperty
class CfnTopicRule_RepublishActionPropertyDef(BaseStruct):
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the IAM role that grants access.\n')
    topic: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the MQTT topic.\n')
    headers: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_RepublishActionHeadersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='MQTT Version 5.0 headers information. For more information, see `MQTT <https://docs.aws.amazon.com//iot/latest/developerguide/mqtt.html>`_ in the IoT Core Developer Guide.\n')
    qos: typing.Union[int, float, None] = pydantic.Field(None, description='The Quality of Service (QoS) level to use when republishing messages. The default value is 0.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-republishaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    republish_action_property = iot.CfnTopicRule.RepublishActionProperty(\n        role_arn="roleArn",\n        topic="topic",\n\n        # the properties below are optional\n        headers=iot.CfnTopicRule.RepublishActionHeadersProperty(\n            content_type="contentType",\n            correlation_data="correlationData",\n            message_expiry="messageExpiry",\n            payload_format_indicator="payloadFormatIndicator",\n            response_topic="responseTopic",\n            user_properties=[iot.CfnTopicRule.UserPropertyProperty(\n                key="key",\n                value="value"\n            )]\n        ),\n        qos=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['role_arn', 'topic', 'headers', 'qos']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.RepublishActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.S3ActionProperty
class CfnTopicRule_S3ActionPropertyDef(BaseStruct):
    bucket_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon S3 bucket.\n')
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The object key. For more information, see `Actions, resources, and condition keys for Amazon S3 <https://docs.aws.amazon.com/AmazonS3/latest/dev/list_amazons3.html>`_ .\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the IAM role that grants access.\n')
    canned_acl: typing.Optional[str] = pydantic.Field(None, description='The Amazon S3 canned ACL that controls access to the object identified by the object key. For more information, see `S3 canned ACLs <https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-s3action.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    s3_action_property = iot.CfnTopicRule.S3ActionProperty(\n        bucket_name="bucketName",\n        key="key",\n        role_arn="roleArn",\n\n        # the properties below are optional\n        canned_acl="cannedAcl"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket_name', 'key', 'role_arn', 'canned_acl']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.S3ActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.SigV4AuthorizationProperty
class CfnTopicRule_SigV4AuthorizationPropertyDef(BaseStruct):
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the signing role.\n')
    service_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The service name to use while signing with Sig V4.\n')
    signing_region: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The signing region.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-sigv4authorization.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    sig_v4_authorization_property = iot.CfnTopicRule.SigV4AuthorizationProperty(\n        role_arn="roleArn",\n        service_name="serviceName",\n        signing_region="signingRegion"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['role_arn', 'service_name', 'signing_region']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.SigV4AuthorizationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.SnsActionProperty
class CfnTopicRule_SnsActionPropertyDef(BaseStruct):
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the IAM role that grants access.\n')
    target_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the SNS topic.\n')
    message_format: typing.Optional[str] = pydantic.Field(None, description='(Optional) The message format of the message to publish. Accepted values are "JSON" and "RAW". The default value of the attribute is "RAW". SNS uses this setting to determine if the payload should be parsed and relevant platform-specific bits of the payload should be extracted. For more information, see `Amazon SNS Message and JSON Formats <https://docs.aws.amazon.com/sns/latest/dg/json-formats.html>`_ in the *Amazon Simple Notification Service Developer Guide* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-snsaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    sns_action_property = iot.CfnTopicRule.SnsActionProperty(\n        role_arn="roleArn",\n        target_arn="targetArn",\n\n        # the properties below are optional\n        message_format="messageFormat"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['role_arn', 'target_arn', 'message_format']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.SnsActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.SqsActionProperty
class CfnTopicRule_SqsActionPropertyDef(BaseStruct):
    queue_url: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The URL of the Amazon SQS queue.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the IAM role that grants access.\n')
    use_base64: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether to use Base64 encoding.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-sqsaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    sqs_action_property = iot.CfnTopicRule.SqsActionProperty(\n        queue_url="queueUrl",\n        role_arn="roleArn",\n\n        # the properties below are optional\n        use_base64=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['queue_url', 'role_arn', 'use_base64']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.SqsActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.StepFunctionsActionProperty
class CfnTopicRule_StepFunctionsActionPropertyDef(BaseStruct):
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the role that grants IoT permission to start execution of a state machine ("Action":"states:StartExecution").\n')
    state_machine_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the Step Functions state machine whose execution will be started.\n')
    execution_name_prefix: typing.Optional[str] = pydantic.Field(None, description='(Optional) A name will be given to the state machine execution consisting of this prefix followed by a UUID. Step Functions automatically creates a unique name for each state machine execution if one is not provided.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-stepfunctionsaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    step_functions_action_property = iot.CfnTopicRule.StepFunctionsActionProperty(\n        role_arn="roleArn",\n        state_machine_name="stateMachineName",\n\n        # the properties below are optional\n        execution_name_prefix="executionNamePrefix"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['role_arn', 'state_machine_name', 'execution_name_prefix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.StepFunctionsActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.TimestampProperty
class CfnTopicRule_TimestampPropertyDef(BaseStruct):
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='An expression that returns a long epoch time value.\n')
    unit: typing.Optional[str] = pydantic.Field(None, description='The precision of the timestamp value that results from the expression described in ``value`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-timestamp.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    timestamp_property = iot.CfnTopicRule.TimestampProperty(\n        value="value",\n\n        # the properties below are optional\n        unit="unit"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['value', 'unit']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.TimestampProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.TimestreamActionProperty
class CfnTopicRule_TimestreamActionPropertyDef(BaseStruct):
    database_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of an Amazon Timestream database that has the table to write records into.\n')
    dimensions: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_TimestreamDimensionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Metadata attributes of the time series that are written in each measure record.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the role that grants AWS IoT permission to write to the Timestream database table.\n')
    table_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The table where the message data will be written.\n')
    timestamp: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_TimestreamTimestampPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The value to use for the entry\'s timestamp. If blank, the time that the entry was processed is used.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-timestreamaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    timestream_action_property = iot.CfnTopicRule.TimestreamActionProperty(\n        database_name="databaseName",\n        dimensions=[iot.CfnTopicRule.TimestreamDimensionProperty(\n            name="name",\n            value="value"\n        )],\n        role_arn="roleArn",\n        table_name="tableName",\n\n        # the properties below are optional\n        timestamp=iot.CfnTopicRule.TimestreamTimestampProperty(\n            unit="unit",\n            value="value"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['database_name', 'dimensions', 'role_arn', 'table_name', 'timestamp']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.TimestreamActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.TimestreamDimensionProperty
class CfnTopicRule_TimestreamDimensionPropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The metadata dimension name. This is the name of the column in the Amazon Timestream database table record.\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The value to write in this column of the database record.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-timestreamdimension.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    timestream_dimension_property = iot.CfnTopicRule.TimestreamDimensionProperty(\n        name="name",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.TimestreamDimensionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.TimestreamTimestampProperty
class CfnTopicRule_TimestreamTimestampPropertyDef(BaseStruct):
    unit: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The precision of the timestamp value that results from the expression described in ``value`` .\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='An expression that returns a long epoch time value.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-timestreamtimestamp.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    timestream_timestamp_property = iot.CfnTopicRule.TimestreamTimestampProperty(\n        unit="unit",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['unit', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.TimestreamTimestampProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.TopicRulePayloadProperty
class CfnTopicRule_TopicRulePayloadPropertyDef(BaseStruct):
    actions: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_ActionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The actions associated with the rule.\n')
    sql: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The SQL statement used to query the topic. For more information, see `AWS IoT SQL Reference <https://docs.aws.amazon.com/iot/latest/developerguide/iot-sql-reference.html>`_ in the *AWS IoT Developer Guide* .\n')
    aws_iot_sql_version: typing.Optional[str] = pydantic.Field(None, description='The version of the SQL rules engine to use when evaluating the rule. The default value is 2015-10-08.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the rule.\n')
    error_action: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_ActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The action to take when an error occurs.\n')
    rule_disabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether the rule is disabled.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-topicrulepayload.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    topic_rule_payload_property = iot.CfnTopicRule.TopicRulePayloadProperty(\n        actions=[iot.CfnTopicRule.ActionProperty(\n            cloudwatch_alarm=iot.CfnTopicRule.CloudwatchAlarmActionProperty(\n                alarm_name="alarmName",\n                role_arn="roleArn",\n                state_reason="stateReason",\n                state_value="stateValue"\n            ),\n            cloudwatch_logs=iot.CfnTopicRule.CloudwatchLogsActionProperty(\n                log_group_name="logGroupName",\n                role_arn="roleArn",\n\n                # the properties below are optional\n                batch_mode=False\n            ),\n            cloudwatch_metric=iot.CfnTopicRule.CloudwatchMetricActionProperty(\n                metric_name="metricName",\n                metric_namespace="metricNamespace",\n                metric_unit="metricUnit",\n                metric_value="metricValue",\n                role_arn="roleArn",\n\n                # the properties below are optional\n                metric_timestamp="metricTimestamp"\n            ),\n            dynamo_db=iot.CfnTopicRule.DynamoDBActionProperty(\n                hash_key_field="hashKeyField",\n                hash_key_value="hashKeyValue",\n                role_arn="roleArn",\n                table_name="tableName",\n\n                # the properties below are optional\n                hash_key_type="hashKeyType",\n                payload_field="payloadField",\n                range_key_field="rangeKeyField",\n                range_key_type="rangeKeyType",\n                range_key_value="rangeKeyValue"\n            ),\n            dynamo_dBv2=iot.CfnTopicRule.DynamoDBv2ActionProperty(\n                put_item=iot.CfnTopicRule.PutItemInputProperty(\n                    table_name="tableName"\n                ),\n                role_arn="roleArn"\n            ),\n            elasticsearch=iot.CfnTopicRule.ElasticsearchActionProperty(\n                endpoint="endpoint",\n                id="id",\n                index="index",\n                role_arn="roleArn",\n                type="type"\n            ),\n            firehose=iot.CfnTopicRule.FirehoseActionProperty(\n                delivery_stream_name="deliveryStreamName",\n                role_arn="roleArn",\n\n                # the properties below are optional\n                batch_mode=False,\n                separator="separator"\n            ),\n            http=iot.CfnTopicRule.HttpActionProperty(\n                url="url",\n\n                # the properties below are optional\n                auth=iot.CfnTopicRule.HttpAuthorizationProperty(\n                    sigv4=iot.CfnTopicRule.SigV4AuthorizationProperty(\n                        role_arn="roleArn",\n                        service_name="serviceName",\n                        signing_region="signingRegion"\n                    )\n                ),\n                confirmation_url="confirmationUrl",\n                headers=[iot.CfnTopicRule.HttpActionHeaderProperty(\n                    key="key",\n                    value="value"\n                )]\n            ),\n            iot_analytics=iot.CfnTopicRule.IotAnalyticsActionProperty(\n                channel_name="channelName",\n                role_arn="roleArn",\n\n                # the properties below are optional\n                batch_mode=False\n            ),\n            iot_events=iot.CfnTopicRule.IotEventsActionProperty(\n                input_name="inputName",\n                role_arn="roleArn",\n\n                # the properties below are optional\n                batch_mode=False,\n                message_id="messageId"\n            ),\n            iot_site_wise=iot.CfnTopicRule.IotSiteWiseActionProperty(\n                put_asset_property_value_entries=[iot.CfnTopicRule.PutAssetPropertyValueEntryProperty(\n                    property_values=[iot.CfnTopicRule.AssetPropertyValueProperty(\n                        timestamp=iot.CfnTopicRule.AssetPropertyTimestampProperty(\n                            time_in_seconds="timeInSeconds",\n\n                            # the properties below are optional\n                            offset_in_nanos="offsetInNanos"\n                        ),\n                        value=iot.CfnTopicRule.AssetPropertyVariantProperty(\n                            boolean_value="booleanValue",\n                            double_value="doubleValue",\n                            integer_value="integerValue",\n                            string_value="stringValue"\n                        ),\n\n                        # the properties below are optional\n                        quality="quality"\n                    )],\n\n                    # the properties below are optional\n                    asset_id="assetId",\n                    entry_id="entryId",\n                    property_alias="propertyAlias",\n                    property_id="propertyId"\n                )],\n                role_arn="roleArn"\n            ),\n            kafka=iot.CfnTopicRule.KafkaActionProperty(\n                client_properties={\n                    "client_properties_key": "clientProperties"\n                },\n                destination_arn="destinationArn",\n                topic="topic",\n\n                # the properties below are optional\n                headers=[iot.CfnTopicRule.KafkaActionHeaderProperty(\n                    key="key",\n                    value="value"\n                )],\n                key="key",\n                partition="partition"\n            ),\n            kinesis=iot.CfnTopicRule.KinesisActionProperty(\n                role_arn="roleArn",\n                stream_name="streamName",\n\n                # the properties below are optional\n                partition_key="partitionKey"\n            ),\n            lambda_=iot.CfnTopicRule.LambdaActionProperty(\n                function_arn="functionArn"\n            ),\n            location=iot.CfnTopicRule.LocationActionProperty(\n                device_id="deviceId",\n                latitude="latitude",\n                longitude="longitude",\n                role_arn="roleArn",\n                tracker_name="trackerName",\n\n                # the properties below are optional\n                timestamp=iot.CfnTopicRule.TimestampProperty(\n                    value="value",\n\n                    # the properties below are optional\n                    unit="unit"\n                )\n            ),\n            open_search=iot.CfnTopicRule.OpenSearchActionProperty(\n                endpoint="endpoint",\n                id="id",\n                index="index",\n                role_arn="roleArn",\n                type="type"\n            ),\n            republish=iot.CfnTopicRule.RepublishActionProperty(\n                role_arn="roleArn",\n                topic="topic",\n\n                # the properties below are optional\n                headers=iot.CfnTopicRule.RepublishActionHeadersProperty(\n                    content_type="contentType",\n                    correlation_data="correlationData",\n                    message_expiry="messageExpiry",\n                    payload_format_indicator="payloadFormatIndicator",\n                    response_topic="responseTopic",\n                    user_properties=[iot.CfnTopicRule.UserPropertyProperty(\n                        key="key",\n                        value="value"\n                    )]\n                ),\n                qos=123\n            ),\n            s3=iot.CfnTopicRule.S3ActionProperty(\n                bucket_name="bucketName",\n                key="key",\n                role_arn="roleArn",\n\n                # the properties below are optional\n                canned_acl="cannedAcl"\n            ),\n            sns=iot.CfnTopicRule.SnsActionProperty(\n                role_arn="roleArn",\n                target_arn="targetArn",\n\n                # the properties below are optional\n                message_format="messageFormat"\n            ),\n            sqs=iot.CfnTopicRule.SqsActionProperty(\n                queue_url="queueUrl",\n                role_arn="roleArn",\n\n                # the properties below are optional\n                use_base64=False\n            ),\n            step_functions=iot.CfnTopicRule.StepFunctionsActionProperty(\n                role_arn="roleArn",\n                state_machine_name="stateMachineName",\n\n                # the properties below are optional\n                execution_name_prefix="executionNamePrefix"\n            ),\n            timestream=iot.CfnTopicRule.TimestreamActionProperty(\n                database_name="databaseName",\n                dimensions=[iot.CfnTopicRule.TimestreamDimensionProperty(\n                    name="name",\n                    value="value"\n                )],\n                role_arn="roleArn",\n                table_name="tableName",\n\n                # the properties below are optional\n                timestamp=iot.CfnTopicRule.TimestreamTimestampProperty(\n                    unit="unit",\n                    value="value"\n                )\n            )\n        )],\n        sql="sql",\n\n        # the properties below are optional\n        aws_iot_sql_version="awsIotSqlVersion",\n        description="description",\n        error_action=iot.CfnTopicRule.ActionProperty(\n            cloudwatch_alarm=iot.CfnTopicRule.CloudwatchAlarmActionProperty(\n                alarm_name="alarmName",\n                role_arn="roleArn",\n                state_reason="stateReason",\n                state_value="stateValue"\n            ),\n            cloudwatch_logs=iot.CfnTopicRule.CloudwatchLogsActionProperty(\n                log_group_name="logGroupName",\n                role_arn="roleArn",\n\n                # the properties below are optional\n                batch_mode=False\n            ),\n            cloudwatch_metric=iot.CfnTopicRule.CloudwatchMetricActionProperty(\n                metric_name="metricName",\n                metric_namespace="metricNamespace",\n                metric_unit="metricUnit",\n                metric_value="metricValue",\n                role_arn="roleArn",\n\n                # the properties below are optional\n                metric_timestamp="metricTimestamp"\n            ),\n            dynamo_db=iot.CfnTopicRule.DynamoDBActionProperty(\n                hash_key_field="hashKeyField",\n                hash_key_value="hashKeyValue",\n                role_arn="roleArn",\n                table_name="tableName",\n\n                # the properties below are optional\n                hash_key_type="hashKeyType",\n                payload_field="payloadField",\n                range_key_field="rangeKeyField",\n                range_key_type="rangeKeyType",\n                range_key_value="rangeKeyValue"\n            ),\n            dynamo_dBv2=iot.CfnTopicRule.DynamoDBv2ActionProperty(\n                put_item=iot.CfnTopicRule.PutItemInputProperty(\n                    table_name="tableName"\n                ),\n                role_arn="roleArn"\n            ),\n            elasticsearch=iot.CfnTopicRule.ElasticsearchActionProperty(\n                endpoint="endpoint",\n                id="id",\n                index="index",\n                role_arn="roleArn",\n                type="type"\n            ),\n            firehose=iot.CfnTopicRule.FirehoseActionProperty(\n                delivery_stream_name="deliveryStreamName",\n                role_arn="roleArn",\n\n                # the properties below are optional\n                batch_mode=False,\n                separator="separator"\n            ),\n            http=iot.CfnTopicRule.HttpActionProperty(\n                url="url",\n\n                # the properties below are optional\n                auth=iot.CfnTopicRule.HttpAuthorizationProperty(\n                    sigv4=iot.CfnTopicRule.SigV4AuthorizationProperty(\n                        role_arn="roleArn",\n                        service_name="serviceName",\n                        signing_region="signingRegion"\n                    )\n                ),\n                confirmation_url="confirmationUrl",\n                headers=[iot.CfnTopicRule.HttpActionHeaderProperty(\n                    key="key",\n                    value="value"\n                )]\n            ),\n            iot_analytics=iot.CfnTopicRule.IotAnalyticsActionProperty(\n                channel_name="channelName",\n                role_arn="roleArn",\n\n                # the properties below are optional\n                batch_mode=False\n            ),\n            iot_events=iot.CfnTopicRule.IotEventsActionProperty(\n                input_name="inputName",\n                role_arn="roleArn",\n\n                # the properties below are optional\n                batch_mode=False,\n                message_id="messageId"\n            ),\n            iot_site_wise=iot.CfnTopicRule.IotSiteWiseActionProperty(\n                put_asset_property_value_entries=[iot.CfnTopicRule.PutAssetPropertyValueEntryProperty(\n                    property_values=[iot.CfnTopicRule.AssetPropertyValueProperty(\n                        timestamp=iot.CfnTopicRule.AssetPropertyTimestampProperty(\n                            time_in_seconds="timeInSeconds",\n\n                            # the properties below are optional\n                            offset_in_nanos="offsetInNanos"\n                        ),\n                        value=iot.CfnTopicRule.AssetPropertyVariantProperty(\n                            boolean_value="booleanValue",\n                            double_value="doubleValue",\n                            integer_value="integerValue",\n                            string_value="stringValue"\n                        ),\n\n                        # the properties below are optional\n                        quality="quality"\n                    )],\n\n                    # the properties below are optional\n                    asset_id="assetId",\n                    entry_id="entryId",\n                    property_alias="propertyAlias",\n                    property_id="propertyId"\n                )],\n                role_arn="roleArn"\n            ),\n            kafka=iot.CfnTopicRule.KafkaActionProperty(\n                client_properties={\n                    "client_properties_key": "clientProperties"\n                },\n                destination_arn="destinationArn",\n                topic="topic",\n\n                # the properties below are optional\n                headers=[iot.CfnTopicRule.KafkaActionHeaderProperty(\n                    key="key",\n                    value="value"\n                )],\n                key="key",\n                partition="partition"\n            ),\n            kinesis=iot.CfnTopicRule.KinesisActionProperty(\n                role_arn="roleArn",\n                stream_name="streamName",\n\n                # the properties below are optional\n                partition_key="partitionKey"\n            ),\n            lambda_=iot.CfnTopicRule.LambdaActionProperty(\n                function_arn="functionArn"\n            ),\n            location=iot.CfnTopicRule.LocationActionProperty(\n                device_id="deviceId",\n                latitude="latitude",\n                longitude="longitude",\n                role_arn="roleArn",\n                tracker_name="trackerName",\n\n                # the properties below are optional\n                timestamp=iot.CfnTopicRule.TimestampProperty(\n                    value="value",\n\n                    # the properties below are optional\n                    unit="unit"\n                )\n            ),\n            open_search=iot.CfnTopicRule.OpenSearchActionProperty(\n                endpoint="endpoint",\n                id="id",\n                index="index",\n                role_arn="roleArn",\n                type="type"\n            ),\n            republish=iot.CfnTopicRule.RepublishActionProperty(\n                role_arn="roleArn",\n                topic="topic",\n\n                # the properties below are optional\n                headers=iot.CfnTopicRule.RepublishActionHeadersProperty(\n                    content_type="contentType",\n                    correlation_data="correlationData",\n                    message_expiry="messageExpiry",\n                    payload_format_indicator="payloadFormatIndicator",\n                    response_topic="responseTopic",\n                    user_properties=[iot.CfnTopicRule.UserPropertyProperty(\n                        key="key",\n                        value="value"\n                    )]\n                ),\n                qos=123\n            ),\n            s3=iot.CfnTopicRule.S3ActionProperty(\n                bucket_name="bucketName",\n                key="key",\n                role_arn="roleArn",\n\n                # the properties below are optional\n                canned_acl="cannedAcl"\n            ),\n            sns=iot.CfnTopicRule.SnsActionProperty(\n                role_arn="roleArn",\n                target_arn="targetArn",\n\n                # the properties below are optional\n                message_format="messageFormat"\n            ),\n            sqs=iot.CfnTopicRule.SqsActionProperty(\n                queue_url="queueUrl",\n                role_arn="roleArn",\n\n                # the properties below are optional\n                use_base64=False\n            ),\n            step_functions=iot.CfnTopicRule.StepFunctionsActionProperty(\n                role_arn="roleArn",\n                state_machine_name="stateMachineName",\n\n                # the properties below are optional\n                execution_name_prefix="executionNamePrefix"\n            ),\n            timestream=iot.CfnTopicRule.TimestreamActionProperty(\n                database_name="databaseName",\n                dimensions=[iot.CfnTopicRule.TimestreamDimensionProperty(\n                    name="name",\n                    value="value"\n                )],\n                role_arn="roleArn",\n                table_name="tableName",\n\n                # the properties below are optional\n                timestamp=iot.CfnTopicRule.TimestreamTimestampProperty(\n                    unit="unit",\n                    value="value"\n                )\n            )\n        ),\n        rule_disabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['actions', 'sql', 'aws_iot_sql_version', 'description', 'error_action', 'rule_disabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.TopicRulePayloadProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRule.UserPropertyProperty
class CfnTopicRule_UserPropertyPropertyDef(BaseStruct):
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A key to be specified in ``UserProperty`` .\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A value to be specified in ``UserProperty`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicrule-userproperty.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    user_property_property = iot.CfnTopicRule.UserPropertyProperty(\n        key="key",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule.UserPropertyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRuleDestination.HttpUrlDestinationSummaryProperty
class CfnTopicRuleDestination_HttpUrlDestinationSummaryPropertyDef(BaseStruct):
    confirmation_url: typing.Optional[str] = pydantic.Field(None, description='The URL used to confirm the HTTP topic rule destination URL.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicruledestination-httpurldestinationsummary.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    http_url_destination_summary_property = iot.CfnTopicRuleDestination.HttpUrlDestinationSummaryProperty(\n        confirmation_url="confirmationUrl"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['confirmation_url']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRuleDestination.HttpUrlDestinationSummaryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRuleDestination.VpcDestinationPropertiesProperty
class CfnTopicRuleDestination_VpcDestinationPropertiesPropertyDef(BaseStruct):
    role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).\n')
    security_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The security groups of the VPC destination.\n')
    subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The subnet IDs of the VPC destination.\n')
    vpc_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the VPC.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-topicruledestination-vpcdestinationproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    vpc_destination_properties_property = iot.CfnTopicRuleDestination.VpcDestinationPropertiesProperty(\n        role_arn="roleArn",\n        security_groups=["securityGroups"],\n        subnet_ids=["subnetIds"],\n        vpc_id="vpcId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['role_arn', 'security_groups', 'subnet_ids', 'vpc_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRuleDestination.VpcDestinationPropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnAccountAuditConfiguration
class CfnAccountAuditConfigurationDef(BaseCfnResource):
    account_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the account. You can use the expression ``!Sub "${AWS::AccountId}"`` to use your account ID.\n')
    audit_check_configurations: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationsPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description="Specifies which audit checks are enabled and disabled for this account. Some data collection might start immediately when certain checks are enabled. When a check is disabled, any data collected so far in relation to the check is deleted. To disable a check, set the value of the ``Enabled:`` key to ``false`` . If an enabled check is removed from the template, it will also be disabled. You can't disable a check if it's used by any scheduled audit. You must delete the check from the scheduled audit or delete the scheduled audit itself to disable the check. For more information on avialbe auidt checks see `AWS::IoT::AccountAuditConfiguration AuditCheckConfigurations <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html>`_\n")
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the role that grants permission to AWS IoT to access information about your devices, policies, certificates, and other items as required when performing an audit.\n')
    audit_notification_target_configurations: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditNotificationTargetConfigurationsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about the targets to which audit notifications are sent.')
    _init_params: typing.ClassVar[list[str]] = ['account_id', 'audit_check_configurations', 'role_arn', 'audit_notification_target_configurations']
    _method_names: typing.ClassVar[list[str]] = ['AuditCheckConfigurationProperty', 'AuditCheckConfigurationsProperty', 'AuditNotificationTargetConfigurationsProperty', 'AuditNotificationTargetProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnAccountAuditConfiguration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnAccountAuditConfigurationDefConfig] = pydantic.Field(None)


class CfnAccountAuditConfigurationDefConfig(pydantic.BaseModel):
    AuditCheckConfigurationProperty: typing.Optional[list[CfnAccountAuditConfigurationDefAuditcheckconfigurationpropertyParams]] = pydantic.Field(None, description='')
    AuditCheckConfigurationsProperty: typing.Optional[list[CfnAccountAuditConfigurationDefAuditcheckconfigurationspropertyParams]] = pydantic.Field(None, description='')
    AuditNotificationTargetConfigurationsProperty: typing.Optional[list[CfnAccountAuditConfigurationDefAuditnotificationtargetconfigurationspropertyParams]] = pydantic.Field(None, description='')
    AuditNotificationTargetProperty: typing.Optional[list[CfnAccountAuditConfigurationDefAuditnotificationtargetpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnAccountAuditConfigurationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnAccountAuditConfigurationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnAccountAuditConfigurationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnAccountAuditConfigurationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnAccountAuditConfigurationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnAccountAuditConfigurationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnAccountAuditConfigurationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnAccountAuditConfigurationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnAccountAuditConfigurationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnAccountAuditConfigurationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnAccountAuditConfigurationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnAccountAuditConfigurationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnAccountAuditConfigurationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnAccountAuditConfigurationDefAuditcheckconfigurationpropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnAccountAuditConfigurationDefAuditcheckconfigurationspropertyParams(pydantic.BaseModel):
    authenticated_cognito_role_overly_permissive_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ca_certificate_expiring_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ca_certificate_key_quality_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    conflicting_client_ids_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    device_certificate_expiring_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    device_certificate_key_quality_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    device_certificate_shared_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    intermediate_ca_revoked_for_active_device_certificates_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    iot_policy_overly_permissive_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    io_t_policy_potential_mis_configuration_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    iot_role_alias_allows_access_to_unused_services_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    iot_role_alias_overly_permissive_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    logging_disabled_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    revoked_ca_certificate_still_active_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    revoked_device_certificate_still_active_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    unauthenticated_cognito_role_overly_permissive_check: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnAccountAuditConfigurationDefAuditnotificationtargetconfigurationspropertyParams(pydantic.BaseModel):
    sns: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditNotificationTargetPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnAccountAuditConfigurationDefAuditnotificationtargetpropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='')
    target_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAccountAuditConfigurationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAccountAuditConfigurationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAccountAuditConfigurationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAccountAuditConfigurationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAccountAuditConfigurationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAccountAuditConfigurationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAccountAuditConfigurationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAccountAuditConfigurationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAccountAuditConfigurationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAccountAuditConfigurationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAccountAuditConfigurationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnAccountAuditConfigurationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAccountAuditConfigurationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAccountAuditConfigurationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnAuthorizer
class CfnAuthorizerDef(BaseCfnResource):
    authorizer_function_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The authorizer's Lambda function ARN.\n")
    authorizer_name: typing.Optional[str] = pydantic.Field(None, description='The authorizer name.\n')
    enable_caching_for_http: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="When ``true`` , the result from the authorizer's Lambda function is cached for clients that use persistent HTTP connections. The results are cached for the time specified by the Lambda function in ``refreshAfterInSeconds`` . This value doesn't affect authorization of clients that use MQTT connections.\n")
    signing_disabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether AWS IoT validates the token signature in an authorization request.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='The status of the authorizer. Valid values: ``ACTIVE`` | ``INACTIVE``\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata which can be used to manage the custom authorizer. .. epigraph:: For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."\n')
    token_key_name: typing.Optional[str] = pydantic.Field(None, description='The key used to extract the token from the HTTP headers.\n')
    token_signing_public_keys: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='The public keys used to validate the token signature returned by your custom authentication service.')
    _init_params: typing.ClassVar[list[str]] = ['authorizer_function_arn', 'authorizer_name', 'enable_caching_for_http', 'signing_disabled', 'status', 'tags', 'token_key_name', 'token_signing_public_keys']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnAuthorizer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnAuthorizerDefConfig] = pydantic.Field(None)


class CfnAuthorizerDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnAuthorizerDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnAuthorizerDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnAuthorizerDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnAuthorizerDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnAuthorizerDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnAuthorizerDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnAuthorizerDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnAuthorizerDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnAuthorizerDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnAuthorizerDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnAuthorizerDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnAuthorizerDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnAuthorizerDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnAuthorizerDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAuthorizerDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAuthorizerDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAuthorizerDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAuthorizerDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAuthorizerDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAuthorizerDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAuthorizerDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAuthorizerDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAuthorizerDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAuthorizerDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnAuthorizerDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAuthorizerDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAuthorizerDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnBillingGroup
class CfnBillingGroupDef(BaseCfnResource):
    billing_group_name: typing.Optional[str] = pydantic.Field(None, description='The name of the billing group.\n')
    billing_group_properties: typing.Union[models.UnsupportedResource, models.aws_iot.CfnBillingGroup_BillingGroupPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties of the billing group.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata which can be used to manage the billing group.')
    _init_params: typing.ClassVar[list[str]] = ['billing_group_name', 'billing_group_properties', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['BillingGroupPropertiesProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnBillingGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnBillingGroupDefConfig] = pydantic.Field(None)


class CfnBillingGroupDefConfig(pydantic.BaseModel):
    BillingGroupPropertiesProperty: typing.Optional[list[CfnBillingGroupDefBillinggrouppropertiespropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnBillingGroupDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnBillingGroupDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnBillingGroupDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnBillingGroupDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnBillingGroupDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnBillingGroupDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnBillingGroupDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnBillingGroupDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnBillingGroupDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnBillingGroupDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnBillingGroupDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnBillingGroupDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnBillingGroupDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnBillingGroupDefBillinggrouppropertiespropertyParams(pydantic.BaseModel):
    billing_group_description: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnBillingGroupDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnBillingGroupDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnBillingGroupDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnBillingGroupDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnBillingGroupDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnBillingGroupDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnBillingGroupDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnBillingGroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnBillingGroupDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnBillingGroupDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnBillingGroupDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnBillingGroupDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnBillingGroupDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnBillingGroupDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnCACertificate
class CfnCACertificateDef(BaseCfnResource):
    ca_certificate_pem: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The certificate data in PEM format.\n')
    status: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The status of the CA certificate. Valid values are "ACTIVE" and "INACTIVE".\n')
    auto_registration_status: typing.Optional[str] = pydantic.Field(None, description='Whether the CA certificate is configured for auto registration of device certificates. Valid values are "ENABLE" and "DISABLE".\n')
    certificate_mode: typing.Optional[str] = pydantic.Field(None, description='The mode of the CA. All the device certificates that are registered using this CA will be registered in the same mode as the CA. For more information about certificate mode for device certificates, see `certificate mode <https://docs.aws.amazon.com//iot/latest/apireference/API_CertificateDescription.html#iot-Type-CertificateDescription-certificateMode>`_ . Valid values are "DEFAULT" and "SNI_ONLY".\n')
    registration_config: typing.Union[models.UnsupportedResource, models.aws_iot.CfnCACertificate_RegistrationConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about the registration configuration.\n')
    remove_auto_registration: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='If true, removes auto registration.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .\n')
    verification_certificate_pem: typing.Optional[str] = pydantic.Field(None, description='The private key verification certificate.')
    _init_params: typing.ClassVar[list[str]] = ['ca_certificate_pem', 'status', 'auto_registration_status', 'certificate_mode', 'registration_config', 'remove_auto_registration', 'tags', 'verification_certificate_pem']
    _method_names: typing.ClassVar[list[str]] = ['RegistrationConfigProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnCACertificate'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnCACertificateDefConfig] = pydantic.Field(None)


class CfnCACertificateDefConfig(pydantic.BaseModel):
    RegistrationConfigProperty: typing.Optional[list[CfnCACertificateDefRegistrationconfigpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnCACertificateDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnCACertificateDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnCACertificateDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnCACertificateDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnCACertificateDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnCACertificateDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnCACertificateDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnCACertificateDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnCACertificateDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnCACertificateDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnCACertificateDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnCACertificateDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnCACertificateDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnCACertificateDefRegistrationconfigpropertyParams(pydantic.BaseModel):
    role_arn: typing.Optional[str] = pydantic.Field(None, description='')
    template_body: typing.Optional[str] = pydantic.Field(None, description='')
    template_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnCACertificateDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnCACertificateDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCACertificateDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnCACertificateDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCACertificateDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnCACertificateDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnCACertificateDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnCACertificateDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnCACertificateDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnCACertificateDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCACertificateDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnCACertificateDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnCACertificateDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCACertificateDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnCertificate
class CfnCertificateDef(BaseCfnResource):
    status: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The status of the certificate. Valid values are ACTIVE, INACTIVE, REVOKED, PENDING_TRANSFER, and PENDING_ACTIVATION. The status value REGISTER_INACTIVE is deprecated and should not be used.\n')
    ca_certificate_pem: typing.Optional[str] = pydantic.Field(None, description='The CA certificate used to sign the device certificate being registered, not available when CertificateMode is SNI_ONLY.\n')
    certificate_mode: typing.Optional[str] = pydantic.Field(None, description="Specifies which mode of certificate registration to use with this resource. Valid options are DEFAULT with CaCertificatePem and CertificatePem, SNI_ONLY with CertificatePem, and Default with CertificateSigningRequest. ``DEFAULT`` : A certificate in ``DEFAULT`` mode is either generated by AWS IoT Core or registered with an issuer certificate authority (CA). Devices with certificates in ``DEFAULT`` mode aren't required to send the Server Name Indication (SNI) extension when connecting to AWS IoT Core . However, to use features such as custom domains and VPC endpoints, we recommend that you use the SNI extension when connecting to AWS IoT Core . ``SNI_ONLY`` : A certificate in ``SNI_ONLY`` mode is registered without an issuer CA. Devices with certificates in ``SNI_ONLY`` mode must send the SNI extension when connecting to AWS IoT Core .\n")
    certificate_pem: typing.Optional[str] = pydantic.Field(None, description='The certificate data in PEM format. Requires SNI_ONLY for the certificate mode or the accompanying CACertificatePem for registration.\n')
    certificate_signing_request: typing.Optional[str] = pydantic.Field(None, description='The certificate signing request (CSR).')
    _init_params: typing.ClassVar[list[str]] = ['status', 'ca_certificate_pem', 'certificate_mode', 'certificate_pem', 'certificate_signing_request']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnCertificate'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnCertificateDefConfig] = pydantic.Field(None)


class CfnCertificateDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnCertificateDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnCertificateDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnCertificateDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnCertificateDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnCertificateDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnCertificateDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnCertificateDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnCertificateDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnCertificateDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnCertificateDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnCertificateDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnCertificateDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnCertificateDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnCertificateDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnCertificateDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCertificateDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnCertificateDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCertificateDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnCertificateDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnCertificateDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnCertificateDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnCertificateDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnCertificateDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCertificateDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnCertificateDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnCertificateDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCertificateDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnCustomMetric
class CfnCustomMetricDef(BaseCfnResource):
    metric_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of the custom metric. Types include ``string-list`` , ``ip-address-list`` , ``number-list`` , and ``number`` . .. epigraph:: The type ``number`` only takes a single metric value as an input, but when you submit the metrics value in the DeviceMetrics report, you must pass it as an array with a single value.\n')
    display_name: typing.Optional[str] = pydantic.Field(None, description="The friendly name in the console for the custom metric. This name doesn't have to be unique. Don't use this name as the metric identifier in the device metric report. You can update the friendly name after you define it.\n")
    metric_name: typing.Optional[str] = pydantic.Field(None, description="The name of the custom metric. This will be used in the metric report submitted from the device/thing. The name can't begin with ``aws:`` . You cant change the name after you define it.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata that can be used to manage the custom metric.')
    _init_params: typing.ClassVar[list[str]] = ['metric_type', 'display_name', 'metric_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnCustomMetric'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnCustomMetricDefConfig] = pydantic.Field(None)


class CfnCustomMetricDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnCustomMetricDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnCustomMetricDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnCustomMetricDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnCustomMetricDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnCustomMetricDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnCustomMetricDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnCustomMetricDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnCustomMetricDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnCustomMetricDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnCustomMetricDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnCustomMetricDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnCustomMetricDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnCustomMetricDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnCustomMetricDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnCustomMetricDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCustomMetricDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnCustomMetricDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCustomMetricDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnCustomMetricDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnCustomMetricDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnCustomMetricDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnCustomMetricDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnCustomMetricDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCustomMetricDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnCustomMetricDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnCustomMetricDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCustomMetricDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnDimension
class CfnDimensionDef(BaseCfnResource):
    string_values: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the value or list of values for the dimension. For ``TOPIC_FILTER`` dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the type of dimension. Supported types: ``TOPIC_FILTER.``\n')
    name: typing.Optional[str] = pydantic.Field(None, description='A unique identifier for the dimension.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata that can be used to manage the dimension.')
    _init_params: typing.ClassVar[list[str]] = ['string_values', 'type', 'name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnDimension'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnDimensionDefConfig] = pydantic.Field(None)


class CfnDimensionDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnDimensionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnDimensionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnDimensionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnDimensionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnDimensionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnDimensionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnDimensionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnDimensionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnDimensionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnDimensionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnDimensionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnDimensionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnDimensionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDimensionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDimensionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDimensionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDimensionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDimensionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDimensionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDimensionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDimensionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDimensionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDimensionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDimensionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDimensionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDimensionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDimensionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnDomainConfiguration
class CfnDomainConfigurationDef(BaseCfnResource):
    authorizer_config: typing.Union[models.UnsupportedResource, models.aws_iot.CfnDomainConfiguration_AuthorizerConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that specifies the authorization service for a domain.\n')
    domain_configuration_name: typing.Optional[str] = pydantic.Field(None, description='The name of the domain configuration. This value must be unique to a region.\n')
    domain_configuration_status: typing.Optional[str] = pydantic.Field(None, description='The status to which the domain configuration should be updated. Valid values: ``ENABLED`` | ``DISABLED``\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='The name of the domain.\n')
    server_certificate_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The ARNs of the certificates that AWS IoT passes to the device during the TLS handshake. Currently you can specify only one certificate ARN. This value is not required for AWS -managed domains.\n')
    service_type: typing.Optional[str] = pydantic.Field(None, description='The type of service delivered by the endpoint. .. epigraph:: AWS IoT Core currently supports only the ``DATA`` service type.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata which can be used to manage the domain configuration. .. epigraph:: For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."\n')
    tls_config: typing.Union[models.UnsupportedResource, models.aws_iot.CfnDomainConfiguration_TlsConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that specifies the TLS configuration for a domain.\n')
    validation_certificate_arn: typing.Optional[str] = pydantic.Field(None, description='The certificate used to validate the server certificate and prove domain name ownership. This certificate must be signed by a public certificate authority. This value is not required for AWS -managed domains.')
    _init_params: typing.ClassVar[list[str]] = ['authorizer_config', 'domain_configuration_name', 'domain_configuration_status', 'domain_name', 'server_certificate_arns', 'service_type', 'tags', 'tls_config', 'validation_certificate_arn']
    _method_names: typing.ClassVar[list[str]] = ['AuthorizerConfigProperty', 'ServerCertificateSummaryProperty', 'TlsConfigProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnDomainConfiguration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnDomainConfigurationDefConfig] = pydantic.Field(None)


class CfnDomainConfigurationDefConfig(pydantic.BaseModel):
    AuthorizerConfigProperty: typing.Optional[list[CfnDomainConfigurationDefAuthorizerconfigpropertyParams]] = pydantic.Field(None, description='')
    ServerCertificateSummaryProperty: typing.Optional[list[CfnDomainConfigurationDefServercertificatesummarypropertyParams]] = pydantic.Field(None, description='')
    TlsConfigProperty: typing.Optional[list[CfnDomainConfigurationDefTlsconfigpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnDomainConfigurationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnDomainConfigurationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnDomainConfigurationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnDomainConfigurationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnDomainConfigurationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnDomainConfigurationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnDomainConfigurationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnDomainConfigurationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnDomainConfigurationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnDomainConfigurationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnDomainConfigurationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnDomainConfigurationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnDomainConfigurationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_server_certificates_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDomainConfigurationDefAuthorizerconfigpropertyParams(pydantic.BaseModel):
    allow_authorizer_override: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    default_authorizer_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDomainConfigurationDefServercertificatesummarypropertyParams(pydantic.BaseModel):
    server_certificate_arn: typing.Optional[str] = pydantic.Field(None, description='')
    server_certificate_status: typing.Optional[str] = pydantic.Field(None, description='')
    server_certificate_status_detail: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDomainConfigurationDefTlsconfigpropertyParams(pydantic.BaseModel):
    security_policy: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDomainConfigurationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDomainConfigurationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDomainConfigurationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDomainConfigurationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDomainConfigurationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDomainConfigurationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDomainConfigurationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDomainConfigurationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDomainConfigurationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDomainConfigurationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDomainConfigurationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDomainConfigurationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDomainConfigurationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDomainConfigurationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnFleetMetric
class CfnFleetMetricDef(BaseCfnResource):
    metric_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the fleet metric to create.\n')
    aggregation_field: typing.Optional[str] = pydantic.Field(None, description='The field to aggregate.\n')
    aggregation_type: typing.Union[models.UnsupportedResource, models.aws_iot.CfnFleetMetric_AggregationTypePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of the aggregation query.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The fleet metric description.\n')
    index_name: typing.Optional[str] = pydantic.Field(None, description='The name of the index to search.\n')
    period: typing.Union[int, float, None] = pydantic.Field(None, description='The time in seconds between fleet metric emissions. Range [60(1 min), 86400(1 day)] and must be multiple of 60.\n')
    query_string: typing.Optional[str] = pydantic.Field(None, description='The search query string.\n')
    query_version: typing.Optional[str] = pydantic.Field(None, description='The query version.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata which can be used to manage the fleet metric.\n')
    unit: typing.Optional[str] = pydantic.Field(None, description='Used to support unit transformation such as milliseconds to seconds. Must be a unit supported by CW metric. Default to null.')
    _init_params: typing.ClassVar[list[str]] = ['metric_name', 'aggregation_field', 'aggregation_type', 'description', 'index_name', 'period', 'query_string', 'query_version', 'tags', 'unit']
    _method_names: typing.ClassVar[list[str]] = ['AggregationTypeProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnFleetMetric'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnFleetMetricDefConfig] = pydantic.Field(None)


class CfnFleetMetricDefConfig(pydantic.BaseModel):
    AggregationTypeProperty: typing.Optional[list[CfnFleetMetricDefAggregationtypepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnFleetMetricDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnFleetMetricDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnFleetMetricDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnFleetMetricDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnFleetMetricDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnFleetMetricDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnFleetMetricDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnFleetMetricDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnFleetMetricDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnFleetMetricDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnFleetMetricDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnFleetMetricDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnFleetMetricDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_creation_date_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_last_modified_date_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_version_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnFleetMetricDefAggregationtypepropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    values: typing.Sequence[str] = pydantic.Field(..., description='')
    ...

class CfnFleetMetricDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnFleetMetricDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFleetMetricDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnFleetMetricDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFleetMetricDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnFleetMetricDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnFleetMetricDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnFleetMetricDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnFleetMetricDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnFleetMetricDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFleetMetricDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnFleetMetricDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnFleetMetricDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFleetMetricDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnJobTemplate
class CfnJobTemplateDef(BaseCfnResource):
    description: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A description of the job template.\n')
    job_template_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A unique identifier for the job template. We recommend using a UUID. Alpha-numeric characters, "-", and "_" are valid for use here.\n')
    abort_config: typing.Any = pydantic.Field(None, description='The criteria that determine when and how a job abort takes place.\n')
    destination_package_versions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The package version Amazon Resource Names (ARNs) that are installed on the devices reserved named shadow ( ``$package`` ) when the job successfully completes. *Note:* Up to 25 package version ARNS are allowed. .. epigraph:: The CloudFormation ``DestinationPackageVersions`` parameter is available in the Beijing (cn-north-1) Region and other Regions where Service Package Catalog has been deployed except for the the Ningxia (cn-northest-1) Region. We will launch to Ningxia region as quickly as possible.\n')
    document: typing.Optional[str] = pydantic.Field(None, description="The job document. Required if you don't specify a value for ``documentSource`` .\n")
    document_source: typing.Optional[str] = pydantic.Field(None, description="An S3 link, or S3 object URL, to the job document. The link is an Amazon S3 object URL and is required if you don't specify a value for ``document`` . For example, ``--document-source https://s3. *region-code* .amazonaws.com/example-firmware/device-firmware.1.0`` For more information, see `Methods for accessing a bucket <https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-bucket-intro.html>`_ .\n")
    job_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the job to use as the basis for the job template.\n')
    job_executions_retry_config: typing.Union[models.UnsupportedResource, models.aws_iot.CfnJobTemplate_JobExecutionsRetryConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Allows you to create the criteria to retry a job.\n')
    job_executions_rollout_config: typing.Any = pydantic.Field(None, description='Allows you to create a staged rollout of a job.\n')
    maintenance_windows: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnJobTemplate_MaintenanceWindowPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An optional configuration within the SchedulingConfig to setup a recurring maintenance window with a predetermined start time and duration for the rollout of a job document to all devices in a target group for a job.\n')
    presigned_url_config: typing.Any = pydantic.Field(None, description='Configuration for pre-signed S3 URLs.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata that can be used to manage the job template.\n')
    timeout_config: typing.Any = pydantic.Field(None, description='Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to ``IN_PROGRESS`` . If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to ``TIMED_OUT`` .')
    _init_params: typing.ClassVar[list[str]] = ['description', 'job_template_id', 'abort_config', 'destination_package_versions', 'document', 'document_source', 'job_arn', 'job_executions_retry_config', 'job_executions_rollout_config', 'maintenance_windows', 'presigned_url_config', 'tags', 'timeout_config']
    _method_names: typing.ClassVar[list[str]] = ['AbortConfigProperty', 'AbortCriteriaProperty', 'ExponentialRolloutRateProperty', 'JobExecutionsRetryConfigProperty', 'JobExecutionsRolloutConfigProperty', 'MaintenanceWindowProperty', 'PresignedUrlConfigProperty', 'RateIncreaseCriteriaProperty', 'RetryCriteriaProperty', 'TimeoutConfigProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnJobTemplate'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnJobTemplateDefConfig] = pydantic.Field(None)


class CfnJobTemplateDefConfig(pydantic.BaseModel):
    AbortConfigProperty: typing.Optional[list[CfnJobTemplateDefAbortconfigpropertyParams]] = pydantic.Field(None, description='')
    AbortCriteriaProperty: typing.Optional[list[CfnJobTemplateDefAbortcriteriapropertyParams]] = pydantic.Field(None, description='')
    ExponentialRolloutRateProperty: typing.Optional[list[CfnJobTemplateDefExponentialrolloutratepropertyParams]] = pydantic.Field(None, description='')
    JobExecutionsRetryConfigProperty: typing.Optional[list[CfnJobTemplateDefJobexecutionsretryconfigpropertyParams]] = pydantic.Field(None, description='')
    JobExecutionsRolloutConfigProperty: typing.Optional[list[CfnJobTemplateDefJobexecutionsrolloutconfigpropertyParams]] = pydantic.Field(None, description='')
    MaintenanceWindowProperty: typing.Optional[list[CfnJobTemplateDefMaintenancewindowpropertyParams]] = pydantic.Field(None, description='')
    PresignedUrlConfigProperty: typing.Optional[list[CfnJobTemplateDefPresignedurlconfigpropertyParams]] = pydantic.Field(None, description='')
    RateIncreaseCriteriaProperty: typing.Optional[list[CfnJobTemplateDefRateincreasecriteriapropertyParams]] = pydantic.Field(None, description='')
    RetryCriteriaProperty: typing.Optional[list[CfnJobTemplateDefRetrycriteriapropertyParams]] = pydantic.Field(None, description='')
    TimeoutConfigProperty: typing.Optional[list[CfnJobTemplateDefTimeoutconfigpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnJobTemplateDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnJobTemplateDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnJobTemplateDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnJobTemplateDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnJobTemplateDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnJobTemplateDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnJobTemplateDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnJobTemplateDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnJobTemplateDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnJobTemplateDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnJobTemplateDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnJobTemplateDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnJobTemplateDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnJobTemplateDefAbortconfigpropertyParams(pydantic.BaseModel):
    criteria_list: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnJobTemplate_AbortCriteriaPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnJobTemplateDefAbortcriteriapropertyParams(pydantic.BaseModel):
    action: str = pydantic.Field(..., description='')
    failure_type: str = pydantic.Field(..., description='')
    min_number_of_executed_things: typing.Union[int, float] = pydantic.Field(..., description='')
    threshold_percentage: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnJobTemplateDefExponentialrolloutratepropertyParams(pydantic.BaseModel):
    base_rate_per_minute: typing.Union[int, float] = pydantic.Field(..., description='')
    increment_factor: typing.Union[int, float] = pydantic.Field(..., description='')
    rate_increase_criteria: typing.Union[models.UnsupportedResource, models.aws_iot.CfnJobTemplate_RateIncreaseCriteriaPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnJobTemplateDefJobexecutionsretryconfigpropertyParams(pydantic.BaseModel):
    retry_criteria_list: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnJobTemplate_RetryCriteriaPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnJobTemplateDefJobexecutionsrolloutconfigpropertyParams(pydantic.BaseModel):
    exponential_rollout_rate: typing.Union[models.UnsupportedResource, models.aws_iot.CfnJobTemplate_ExponentialRolloutRatePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    maximum_per_minute: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnJobTemplateDefMaintenancewindowpropertyParams(pydantic.BaseModel):
    duration_in_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='')
    start_time: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnJobTemplateDefPresignedurlconfigpropertyParams(pydantic.BaseModel):
    role_arn: str = pydantic.Field(..., description='')
    expires_in_sec: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnJobTemplateDefRateincreasecriteriapropertyParams(pydantic.BaseModel):
    number_of_notified_things: typing.Union[int, float, None] = pydantic.Field(None, description='')
    number_of_succeeded_things: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnJobTemplateDefRetrycriteriapropertyParams(pydantic.BaseModel):
    failure_type: typing.Optional[str] = pydantic.Field(None, description='')
    number_of_retries: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnJobTemplateDefTimeoutconfigpropertyParams(pydantic.BaseModel):
    in_progress_timeout_in_minutes: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnJobTemplateDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnJobTemplateDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnJobTemplateDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnJobTemplateDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnJobTemplateDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnJobTemplateDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnJobTemplateDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnJobTemplateDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnJobTemplateDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnJobTemplateDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnJobTemplateDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnJobTemplateDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnJobTemplateDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnJobTemplateDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnLogging
class CfnLoggingDef(BaseCfnResource):
    account_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The account ID.\n')
    default_log_level: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The default log level. Valid Values: ``DEBUG | INFO | ERROR | WARN | DISABLED``\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The role ARN used for the log.')
    _init_params: typing.ClassVar[list[str]] = ['account_id', 'default_log_level', 'role_arn']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnLogging'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnLoggingDefConfig] = pydantic.Field(None)


class CfnLoggingDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnLoggingDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnLoggingDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnLoggingDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnLoggingDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnLoggingDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnLoggingDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnLoggingDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnLoggingDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnLoggingDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnLoggingDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnLoggingDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnLoggingDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnLoggingDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnLoggingDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnLoggingDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLoggingDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnLoggingDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLoggingDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnLoggingDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnLoggingDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnLoggingDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnLoggingDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnLoggingDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLoggingDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnLoggingDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnLoggingDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLoggingDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnMitigationAction
class CfnMitigationActionDef(BaseCfnResource):
    action_params: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_iot.CfnMitigationAction_ActionParamsPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The set of parameters for this mitigation action. The parameters vary, depending on the kind of action you apply.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The IAM role ARN used to apply this mitigation action.\n')
    action_name: typing.Optional[str] = pydantic.Field(None, description='The friendly name of the mitigation action.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata that can be used to manage the mitigation action.')
    _init_params: typing.ClassVar[list[str]] = ['action_params', 'role_arn', 'action_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['ActionParamsProperty', 'AddThingsToThingGroupParamsProperty', 'EnableIoTLoggingParamsProperty', 'PublishFindingToSnsParamsProperty', 'ReplaceDefaultPolicyVersionParamsProperty', 'UpdateCACertificateParamsProperty', 'UpdateDeviceCertificateParamsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnMitigationAction'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnMitigationActionDefConfig] = pydantic.Field(None)


class CfnMitigationActionDefConfig(pydantic.BaseModel):
    ActionParamsProperty: typing.Optional[list[CfnMitigationActionDefActionparamspropertyParams]] = pydantic.Field(None, description='')
    AddThingsToThingGroupParamsProperty: typing.Optional[list[CfnMitigationActionDefAddthingstothinggroupparamspropertyParams]] = pydantic.Field(None, description='')
    EnableIoTLoggingParamsProperty: typing.Optional[list[CfnMitigationActionDefEnableiotloggingparamspropertyParams]] = pydantic.Field(None, description='')
    PublishFindingToSnsParamsProperty: typing.Optional[list[CfnMitigationActionDefPublishfindingtosnsparamspropertyParams]] = pydantic.Field(None, description='')
    ReplaceDefaultPolicyVersionParamsProperty: typing.Optional[list[CfnMitigationActionDefReplacedefaultpolicyversionparamspropertyParams]] = pydantic.Field(None, description='')
    UpdateCACertificateParamsProperty: typing.Optional[list[CfnMitigationActionDefUpdatecacertificateparamspropertyParams]] = pydantic.Field(None, description='')
    UpdateDeviceCertificateParamsProperty: typing.Optional[list[CfnMitigationActionDefUpdatedevicecertificateparamspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnMitigationActionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnMitigationActionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnMitigationActionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnMitigationActionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnMitigationActionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnMitigationActionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnMitigationActionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnMitigationActionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnMitigationActionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnMitigationActionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnMitigationActionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnMitigationActionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnMitigationActionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnMitigationActionDefActionparamspropertyParams(pydantic.BaseModel):
    add_things_to_thing_group_params: typing.Union[models.UnsupportedResource, models.aws_iot.CfnMitigationAction_AddThingsToThingGroupParamsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    enable_io_t_logging_params: typing.Union[models.UnsupportedResource, models.aws_iot.CfnMitigationAction_EnableIoTLoggingParamsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    publish_finding_to_sns_params: typing.Union[models.UnsupportedResource, models.aws_iot.CfnMitigationAction_PublishFindingToSnsParamsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    replace_default_policy_version_params: typing.Union[models.UnsupportedResource, models.aws_iot.CfnMitigationAction_ReplaceDefaultPolicyVersionParamsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    update_ca_certificate_params: typing.Union[models.UnsupportedResource, models.aws_iot.CfnMitigationAction_UpdateCACertificateParamsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    update_device_certificate_params: typing.Union[models.UnsupportedResource, models.aws_iot.CfnMitigationAction_UpdateDeviceCertificateParamsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnMitigationActionDefAddthingstothinggroupparamspropertyParams(pydantic.BaseModel):
    thing_group_names: typing.Sequence[str] = pydantic.Field(..., description='')
    override_dynamic_groups: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnMitigationActionDefEnableiotloggingparamspropertyParams(pydantic.BaseModel):
    log_level: str = pydantic.Field(..., description='')
    role_arn_for_logging: str = pydantic.Field(..., description='')
    ...

class CfnMitigationActionDefPublishfindingtosnsparamspropertyParams(pydantic.BaseModel):
    topic_arn: str = pydantic.Field(..., description='')
    ...

class CfnMitigationActionDefReplacedefaultpolicyversionparamspropertyParams(pydantic.BaseModel):
    template_name: str = pydantic.Field(..., description='')
    ...

class CfnMitigationActionDefUpdatecacertificateparamspropertyParams(pydantic.BaseModel):
    action: str = pydantic.Field(..., description='')
    ...

class CfnMitigationActionDefUpdatedevicecertificateparamspropertyParams(pydantic.BaseModel):
    action: str = pydantic.Field(..., description='')
    ...

class CfnMitigationActionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnMitigationActionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMitigationActionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnMitigationActionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMitigationActionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnMitigationActionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnMitigationActionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnMitigationActionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnMitigationActionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnMitigationActionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMitigationActionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnMitigationActionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnMitigationActionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMitigationActionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnPolicy
class CfnPolicyDef(BaseCfnResource):
    policy_document: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The JSON document that describes the policy.\n')
    policy_name: typing.Optional[str] = pydantic.Field(None, description='The policy name.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='')
    _init_params: typing.ClassVar[list[str]] = ['policy_document', 'policy_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnPolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnPolicyDefConfig] = pydantic.Field(None)


class CfnPolicyDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnPolicyDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnPolicyDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnPolicyDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnPolicyDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnPolicyDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnPolicyDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnPolicyDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnPolicyDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnPolicyDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnPolicyDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnPolicyDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnPolicyDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnPolicyDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnPolicyDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPolicyDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPolicyDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPolicyDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPolicyDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPolicyDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPolicyDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPolicyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPolicyDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPolicyDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPolicyDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnPolicyDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPolicyDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPolicyDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnPolicyPrincipalAttachment
class CfnPolicyPrincipalAttachmentDef(BaseCfnResource):
    policy_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the AWS IoT policy.\n')
    principal: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The principal, which can be a certificate ARN (as returned from the ``CreateCertificate`` operation) or an Amazon Cognito ID.')
    _init_params: typing.ClassVar[list[str]] = ['policy_name', 'principal']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnPolicyPrincipalAttachment'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnPolicyPrincipalAttachmentDefConfig] = pydantic.Field(None)


class CfnPolicyPrincipalAttachmentDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnPolicyPrincipalAttachmentDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnPolicyPrincipalAttachmentDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnPolicyPrincipalAttachmentDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnPolicyPrincipalAttachmentDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnPolicyPrincipalAttachmentDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnPolicyPrincipalAttachmentDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnPolicyPrincipalAttachmentDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnPolicyPrincipalAttachmentDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnPolicyPrincipalAttachmentDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnPolicyPrincipalAttachmentDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnPolicyPrincipalAttachmentDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnPolicyPrincipalAttachmentDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnPolicyPrincipalAttachmentDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnPolicyPrincipalAttachmentDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPolicyPrincipalAttachmentDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPolicyPrincipalAttachmentDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPolicyPrincipalAttachmentDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPolicyPrincipalAttachmentDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPolicyPrincipalAttachmentDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPolicyPrincipalAttachmentDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPolicyPrincipalAttachmentDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPolicyPrincipalAttachmentDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPolicyPrincipalAttachmentDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPolicyPrincipalAttachmentDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnPolicyPrincipalAttachmentDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPolicyPrincipalAttachmentDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPolicyPrincipalAttachmentDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnProvisioningTemplate
class CfnProvisioningTemplateDef(BaseCfnResource):
    provisioning_role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The role ARN for the role associated with the fleet provisioning template. This IoT role grants permission to provision a device.\n')
    template_body: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The JSON formatted contents of the fleet provisioning template version.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the fleet provisioning template.\n')
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='True to enable the fleet provisioning template, otherwise false.\n')
    pre_provisioning_hook: typing.Union[models.UnsupportedResource, models.aws_iot.CfnProvisioningTemplate_ProvisioningHookPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Creates a pre-provisioning hook template.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata that can be used to manage the fleet provisioning template.\n')
    template_name: typing.Optional[str] = pydantic.Field(None, description='The name of the fleet provisioning template.\n')
    template_type: typing.Optional[str] = pydantic.Field(None, description='The type of the provisioning template.')
    _init_params: typing.ClassVar[list[str]] = ['provisioning_role_arn', 'template_body', 'description', 'enabled', 'pre_provisioning_hook', 'tags', 'template_name', 'template_type']
    _method_names: typing.ClassVar[list[str]] = ['ProvisioningHookProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnProvisioningTemplate'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnProvisioningTemplateDefConfig] = pydantic.Field(None)


class CfnProvisioningTemplateDefConfig(pydantic.BaseModel):
    ProvisioningHookProperty: typing.Optional[list[CfnProvisioningTemplateDefProvisioninghookpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnProvisioningTemplateDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnProvisioningTemplateDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnProvisioningTemplateDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnProvisioningTemplateDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnProvisioningTemplateDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnProvisioningTemplateDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnProvisioningTemplateDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnProvisioningTemplateDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnProvisioningTemplateDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnProvisioningTemplateDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnProvisioningTemplateDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnProvisioningTemplateDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnProvisioningTemplateDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnProvisioningTemplateDefProvisioninghookpropertyParams(pydantic.BaseModel):
    payload_version: typing.Optional[str] = pydantic.Field(None, description='')
    target_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnProvisioningTemplateDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnProvisioningTemplateDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnProvisioningTemplateDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnProvisioningTemplateDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnProvisioningTemplateDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnProvisioningTemplateDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnProvisioningTemplateDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnProvisioningTemplateDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnProvisioningTemplateDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnProvisioningTemplateDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnProvisioningTemplateDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnProvisioningTemplateDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnProvisioningTemplateDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnProvisioningTemplateDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnResourceSpecificLogging
class CfnResourceSpecificLoggingDef(BaseCfnResource):
    log_level: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The default log level.Valid Values: ``DEBUG | INFO | ERROR | WARN | DISABLED``.\n')
    target_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The target name.\n')
    target_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The target type. Valid Values: ``DEFAULT | THING_GROUP``')
    _init_params: typing.ClassVar[list[str]] = ['log_level', 'target_name', 'target_type']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnResourceSpecificLogging'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnResourceSpecificLoggingDefConfig] = pydantic.Field(None)


class CfnResourceSpecificLoggingDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnResourceSpecificLoggingDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnResourceSpecificLoggingDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnResourceSpecificLoggingDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnResourceSpecificLoggingDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnResourceSpecificLoggingDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnResourceSpecificLoggingDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnResourceSpecificLoggingDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnResourceSpecificLoggingDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnResourceSpecificLoggingDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnResourceSpecificLoggingDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnResourceSpecificLoggingDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnResourceSpecificLoggingDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnResourceSpecificLoggingDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnResourceSpecificLoggingDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnResourceSpecificLoggingDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnResourceSpecificLoggingDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnResourceSpecificLoggingDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnResourceSpecificLoggingDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnResourceSpecificLoggingDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnResourceSpecificLoggingDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnResourceSpecificLoggingDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnResourceSpecificLoggingDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnResourceSpecificLoggingDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnResourceSpecificLoggingDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnResourceSpecificLoggingDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnResourceSpecificLoggingDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnResourceSpecificLoggingDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnRoleAlias
class CfnRoleAliasDef(BaseCfnResource):
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The role ARN.\n')
    credential_duration_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The number of seconds for which the credential is valid. Default: - 3600\n')
    role_alias: typing.Optional[str] = pydantic.Field(None, description='The role alias.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .')
    _init_params: typing.ClassVar[list[str]] = ['role_arn', 'credential_duration_seconds', 'role_alias', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnRoleAlias'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnRoleAliasDefConfig] = pydantic.Field(None)


class CfnRoleAliasDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnRoleAliasDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnRoleAliasDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnRoleAliasDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnRoleAliasDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnRoleAliasDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnRoleAliasDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnRoleAliasDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnRoleAliasDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnRoleAliasDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnRoleAliasDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnRoleAliasDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnRoleAliasDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnRoleAliasDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnRoleAliasDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnRoleAliasDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRoleAliasDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnRoleAliasDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRoleAliasDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnRoleAliasDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnRoleAliasDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnRoleAliasDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnRoleAliasDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnRoleAliasDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRoleAliasDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnRoleAliasDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnRoleAliasDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRoleAliasDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnScheduledAudit
class CfnScheduledAuditDef(BaseCfnResource):
    frequency: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='How often the scheduled audit occurs.\n')
    target_check_names: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use ``DescribeAccountAuditConfiguration`` to see the list of all checks, including those that are enabled or use ``UpdateAccountAuditConfiguration`` to select which checks are enabled.) The following checks are currently aviable: - ``AUTHENTICATED_COGNITO_ROLE_OVERLY_PERMISSIVE_CHECK`` - ``CA_CERTIFICATE_EXPIRING_CHECK`` - ``CA_CERTIFICATE_KEY_QUALITY_CHECK`` - ``CONFLICTING_CLIENT_IDS_CHECK`` - ``DEVICE_CERTIFICATE_EXPIRING_CHECK`` - ``DEVICE_CERTIFICATE_KEY_QUALITY_CHECK`` - ``DEVICE_CERTIFICATE_SHARED_CHECK`` - ``IOT_POLICY_OVERLY_PERMISSIVE_CHECK`` - ``IOT_ROLE_ALIAS_ALLOWS_ACCESS_TO_UNUSED_SERVICES_CHECK`` - ``IOT_ROLE_ALIAS_OVERLY_PERMISSIVE_CHECK`` - ``LOGGING_DISABLED_CHECK`` - ``REVOKED_CA_CERTIFICATE_STILL_ACTIVE_CHECK`` - ``REVOKED_DEVICE_CERTIFICATE_STILL_ACTIVE_CHECK`` - ``UNAUTHENTICATED_COGNITO_ROLE_OVERLY_PERMISSIVE_CHECK``\n')
    day_of_month: typing.Optional[str] = pydantic.Field(None, description='The day of the month on which the scheduled audit is run (if the ``frequency`` is "MONTHLY"). If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.\n')
    day_of_week: typing.Optional[str] = pydantic.Field(None, description='The day of the week on which the scheduled audit is run (if the ``frequency`` is "WEEKLY" or "BIWEEKLY").\n')
    scheduled_audit_name: typing.Optional[str] = pydantic.Field(None, description='The name of the scheduled audit.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata that can be used to manage the scheduled audit.')
    _init_params: typing.ClassVar[list[str]] = ['frequency', 'target_check_names', 'day_of_month', 'day_of_week', 'scheduled_audit_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnScheduledAudit'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnScheduledAuditDefConfig] = pydantic.Field(None)


class CfnScheduledAuditDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnScheduledAuditDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnScheduledAuditDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnScheduledAuditDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnScheduledAuditDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnScheduledAuditDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnScheduledAuditDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnScheduledAuditDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnScheduledAuditDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnScheduledAuditDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnScheduledAuditDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnScheduledAuditDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnScheduledAuditDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnScheduledAuditDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnScheduledAuditDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnScheduledAuditDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnScheduledAuditDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnScheduledAuditDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnScheduledAuditDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnScheduledAuditDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnScheduledAuditDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnScheduledAuditDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnScheduledAuditDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnScheduledAuditDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnScheduledAuditDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnScheduledAuditDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnScheduledAuditDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnScheduledAuditDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnSecurityProfile
class CfnSecurityProfileDef(BaseCfnResource):
    additional_metrics_to_retain_v2: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnSecurityProfile_MetricToRetainPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's ``behaviors`` , but it's also retained for any metric specified here. Can be used with custom metrics; can't be used with dimensions.\n")
    alert_targets: typing.Union[models.UnsupportedResource, typing.Mapping[str, typing.Union[models.UnsupportedResource, models.aws_iot.CfnSecurityProfile_AlertTargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Specifies the destinations to which alerts are sent. (Alerts are always sent to the console.) Alerts are generated when a device (thing) violates a behavior.\n')
    behaviors: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnSecurityProfile_BehaviorPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Specifies the behaviors that, when violated by a device (thing), cause an alert.\n')
    security_profile_description: typing.Optional[str] = pydantic.Field(None, description='A description of the security profile.\n')
    security_profile_name: typing.Optional[str] = pydantic.Field(None, description='The name you gave to the security profile.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata that can be used to manage the security profile.\n')
    target_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The ARN of the target (thing group) to which the security profile is attached.')
    _init_params: typing.ClassVar[list[str]] = ['additional_metrics_to_retain_v2', 'alert_targets', 'behaviors', 'security_profile_description', 'security_profile_name', 'tags', 'target_arns']
    _method_names: typing.ClassVar[list[str]] = ['AlertTargetProperty', 'BehaviorCriteriaProperty', 'BehaviorProperty', 'MachineLearningDetectionConfigProperty', 'MetricDimensionProperty', 'MetricToRetainProperty', 'MetricValueProperty', 'StatisticalThresholdProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnSecurityProfile'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnSecurityProfileDefConfig] = pydantic.Field(None)


class CfnSecurityProfileDefConfig(pydantic.BaseModel):
    AlertTargetProperty: typing.Optional[list[CfnSecurityProfileDefAlerttargetpropertyParams]] = pydantic.Field(None, description='')
    BehaviorCriteriaProperty: typing.Optional[list[CfnSecurityProfileDefBehaviorcriteriapropertyParams]] = pydantic.Field(None, description='')
    BehaviorProperty: typing.Optional[list[CfnSecurityProfileDefBehaviorpropertyParams]] = pydantic.Field(None, description='')
    MachineLearningDetectionConfigProperty: typing.Optional[list[CfnSecurityProfileDefMachinelearningdetectionconfigpropertyParams]] = pydantic.Field(None, description='')
    MetricDimensionProperty: typing.Optional[list[CfnSecurityProfileDefMetricdimensionpropertyParams]] = pydantic.Field(None, description='')
    MetricToRetainProperty: typing.Optional[list[CfnSecurityProfileDefMetrictoretainpropertyParams]] = pydantic.Field(None, description='')
    MetricValueProperty: typing.Optional[list[CfnSecurityProfileDefMetricvaluepropertyParams]] = pydantic.Field(None, description='')
    StatisticalThresholdProperty: typing.Optional[list[CfnSecurityProfileDefStatisticalthresholdpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnSecurityProfileDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnSecurityProfileDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnSecurityProfileDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnSecurityProfileDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnSecurityProfileDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnSecurityProfileDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnSecurityProfileDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnSecurityProfileDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnSecurityProfileDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnSecurityProfileDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnSecurityProfileDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnSecurityProfileDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnSecurityProfileDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnSecurityProfileDefAlerttargetpropertyParams(pydantic.BaseModel):
    alert_target_arn: str = pydantic.Field(..., description='')
    role_arn: str = pydantic.Field(..., description='')
    ...

class CfnSecurityProfileDefBehaviorcriteriapropertyParams(pydantic.BaseModel):
    comparison_operator: typing.Optional[str] = pydantic.Field(None, description='')
    consecutive_datapoints_to_alarm: typing.Union[int, float, None] = pydantic.Field(None, description='')
    consecutive_datapoints_to_clear: typing.Union[int, float, None] = pydantic.Field(None, description='')
    duration_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ml_detection_config: typing.Union[models.UnsupportedResource, models.aws_iot.CfnSecurityProfile_MachineLearningDetectionConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    statistical_threshold: typing.Union[models.UnsupportedResource, models.aws_iot.CfnSecurityProfile_StatisticalThresholdPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    value: typing.Union[models.UnsupportedResource, models.aws_iot.CfnSecurityProfile_MetricValuePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnSecurityProfileDefBehaviorpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    criteria: typing.Union[models.UnsupportedResource, models.aws_iot.CfnSecurityProfile_BehaviorCriteriaPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    metric: typing.Optional[str] = pydantic.Field(None, description='')
    metric_dimension: typing.Union[models.UnsupportedResource, models.aws_iot.CfnSecurityProfile_MetricDimensionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    suppress_alerts: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnSecurityProfileDefMachinelearningdetectionconfigpropertyParams(pydantic.BaseModel):
    confidence_level: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSecurityProfileDefMetricdimensionpropertyParams(pydantic.BaseModel):
    dimension_name: str = pydantic.Field(..., description='')
    operator: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSecurityProfileDefMetrictoretainpropertyParams(pydantic.BaseModel):
    metric: str = pydantic.Field(..., description='')
    metric_dimension: typing.Union[models.UnsupportedResource, models.aws_iot.CfnSecurityProfile_MetricDimensionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnSecurityProfileDefMetricvaluepropertyParams(pydantic.BaseModel):
    cidrs: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    count: typing.Optional[str] = pydantic.Field(None, description='')
    number: typing.Union[int, float, None] = pydantic.Field(None, description='')
    numbers: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[int, float]], None] = pydantic.Field(None, description='')
    ports: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[int, float]], None] = pydantic.Field(None, description='')
    strings: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnSecurityProfileDefStatisticalthresholdpropertyParams(pydantic.BaseModel):
    statistic: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSecurityProfileDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSecurityProfileDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSecurityProfileDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSecurityProfileDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSecurityProfileDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSecurityProfileDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSecurityProfileDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSecurityProfileDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSecurityProfileDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSecurityProfileDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSecurityProfileDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnSecurityProfileDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSecurityProfileDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSecurityProfileDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnSoftwarePackage
class CfnSoftwarePackageDef(BaseCfnResource):
    description: typing.Optional[str] = pydantic.Field(None, description="A summary of the package being created. This can be used to outline the package's contents or purpose.\n")
    package_name: typing.Optional[str] = pydantic.Field(None, description='The name of the new software package.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata that can be used to manage the package.')
    _init_params: typing.ClassVar[list[str]] = ['description', 'package_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnSoftwarePackage'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnSoftwarePackageDefConfig] = pydantic.Field(None)


class CfnSoftwarePackageDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnSoftwarePackageDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnSoftwarePackageDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnSoftwarePackageDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnSoftwarePackageDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnSoftwarePackageDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnSoftwarePackageDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnSoftwarePackageDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnSoftwarePackageDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnSoftwarePackageDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnSoftwarePackageDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnSoftwarePackageDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnSoftwarePackageDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnSoftwarePackageDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnSoftwarePackageDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSoftwarePackageDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSoftwarePackageDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSoftwarePackageDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSoftwarePackageDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSoftwarePackageDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSoftwarePackageDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSoftwarePackageDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSoftwarePackageDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSoftwarePackageDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSoftwarePackageDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnSoftwarePackageDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSoftwarePackageDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSoftwarePackageDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnSoftwarePackageVersion
class CfnSoftwarePackageVersionDef(BaseCfnResource):
    package_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the associated software package.\n')
    attributes: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='Metadata that can be used to define a package versions configuration. For example, the S3 file location, configuration options that are being sent to the device or fleet. The combined size of all the attributes on a package version is limited to 3KB.\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A summary of the package version being created. This can be used to outline the package's contents or purpose.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata that can be used to manage the package version.\n')
    version_name: typing.Optional[str] = pydantic.Field(None, description='The name of the new package version.')
    _init_params: typing.ClassVar[list[str]] = ['package_name', 'attributes', 'description', 'tags', 'version_name']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnSoftwarePackageVersion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnSoftwarePackageVersionDefConfig] = pydantic.Field(None)


class CfnSoftwarePackageVersionDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnSoftwarePackageVersionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnSoftwarePackageVersionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnSoftwarePackageVersionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnSoftwarePackageVersionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnSoftwarePackageVersionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnSoftwarePackageVersionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnSoftwarePackageVersionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnSoftwarePackageVersionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnSoftwarePackageVersionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnSoftwarePackageVersionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnSoftwarePackageVersionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnSoftwarePackageVersionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnSoftwarePackageVersionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnSoftwarePackageVersionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSoftwarePackageVersionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSoftwarePackageVersionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSoftwarePackageVersionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSoftwarePackageVersionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSoftwarePackageVersionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSoftwarePackageVersionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSoftwarePackageVersionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSoftwarePackageVersionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSoftwarePackageVersionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSoftwarePackageVersionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnSoftwarePackageVersionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSoftwarePackageVersionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSoftwarePackageVersionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnThing
class CfnThingDef(BaseCfnResource):
    attribute_payload: typing.Union[models.UnsupportedResource, models.aws_iot.CfnThing_AttributePayloadPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A string that contains up to three key value pairs. Maximum length of 800. Duplicates not allowed.\n')
    thing_name: typing.Optional[str] = pydantic.Field(None, description="The name of the thing to update. You can't change a thing's name. To change a thing's name, you must create a new thing, give it the new name, and then delete the old thing.")
    _init_params: typing.ClassVar[list[str]] = ['attribute_payload', 'thing_name']
    _method_names: typing.ClassVar[list[str]] = ['AttributePayloadProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnThing'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnThingDefConfig] = pydantic.Field(None)


class CfnThingDefConfig(pydantic.BaseModel):
    AttributePayloadProperty: typing.Optional[list[CfnThingDefAttributepayloadpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnThingDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnThingDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnThingDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnThingDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnThingDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnThingDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnThingDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnThingDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnThingDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnThingDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnThingDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnThingDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnThingDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnThingDefAttributepayloadpropertyParams(pydantic.BaseModel):
    attributes: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    ...

class CfnThingDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnThingDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnThingDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnThingDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnThingDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnThingDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnThingDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnThingDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnThingDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnThingDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnThingDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnThingDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnThingDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnThingDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnThingGroup
class CfnThingGroupDef(BaseCfnResource):
    parent_group_name: typing.Optional[str] = pydantic.Field(None, description='The parent thing group name. A Dynamic Thing Group does not have ``parentGroupName`` defined.\n')
    query_string: typing.Optional[str] = pydantic.Field(None, description='The dynamic thing group search query string. The ``queryString`` attribute *is* required for ``CreateDynamicThingGroup`` . The ``queryString`` attribute *is not* required for ``CreateThingGroup`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata which can be used to manage the thing group or dynamic thing group.\n')
    thing_group_name: typing.Optional[str] = pydantic.Field(None, description='The thing group name.\n')
    thing_group_properties: typing.Union[models.UnsupportedResource, models.aws_iot.CfnThingGroup_ThingGroupPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Thing group properties.')
    _init_params: typing.ClassVar[list[str]] = ['parent_group_name', 'query_string', 'tags', 'thing_group_name', 'thing_group_properties']
    _method_names: typing.ClassVar[list[str]] = ['AttributePayloadProperty', 'ThingGroupPropertiesProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnThingGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnThingGroupDefConfig] = pydantic.Field(None)


class CfnThingGroupDefConfig(pydantic.BaseModel):
    AttributePayloadProperty: typing.Optional[list[CfnThingGroupDefAttributepayloadpropertyParams]] = pydantic.Field(None, description='')
    ThingGroupPropertiesProperty: typing.Optional[list[CfnThingGroupDefThinggrouppropertiespropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnThingGroupDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnThingGroupDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnThingGroupDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnThingGroupDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnThingGroupDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnThingGroupDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnThingGroupDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnThingGroupDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnThingGroupDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnThingGroupDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnThingGroupDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnThingGroupDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnThingGroupDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnThingGroupDefAttributepayloadpropertyParams(pydantic.BaseModel):
    attributes: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    ...

class CfnThingGroupDefThinggrouppropertiespropertyParams(pydantic.BaseModel):
    attribute_payload: typing.Union[models.UnsupportedResource, models.aws_iot.CfnThingGroup_AttributePayloadPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    thing_group_description: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnThingGroupDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnThingGroupDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnThingGroupDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnThingGroupDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnThingGroupDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnThingGroupDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnThingGroupDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnThingGroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnThingGroupDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnThingGroupDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnThingGroupDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnThingGroupDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnThingGroupDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnThingGroupDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnThingPrincipalAttachment
class CfnThingPrincipalAttachmentDef(BaseCfnResource):
    principal: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The principal, which can be a certificate ARN (as returned from the ``CreateCertificate`` operation) or an Amazon Cognito ID.\n')
    thing_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the AWS IoT thing.')
    _init_params: typing.ClassVar[list[str]] = ['principal', 'thing_name']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnThingPrincipalAttachment'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnThingPrincipalAttachmentDefConfig] = pydantic.Field(None)


class CfnThingPrincipalAttachmentDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnThingPrincipalAttachmentDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnThingPrincipalAttachmentDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnThingPrincipalAttachmentDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnThingPrincipalAttachmentDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnThingPrincipalAttachmentDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnThingPrincipalAttachmentDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnThingPrincipalAttachmentDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnThingPrincipalAttachmentDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnThingPrincipalAttachmentDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnThingPrincipalAttachmentDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnThingPrincipalAttachmentDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnThingPrincipalAttachmentDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnThingPrincipalAttachmentDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnThingPrincipalAttachmentDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnThingPrincipalAttachmentDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnThingPrincipalAttachmentDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnThingPrincipalAttachmentDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnThingPrincipalAttachmentDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnThingPrincipalAttachmentDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnThingPrincipalAttachmentDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnThingPrincipalAttachmentDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnThingPrincipalAttachmentDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnThingPrincipalAttachmentDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnThingPrincipalAttachmentDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnThingPrincipalAttachmentDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnThingPrincipalAttachmentDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnThingPrincipalAttachmentDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnThingType
class CfnThingTypeDef(BaseCfnResource):
    deprecate_thing_type: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Deprecates a thing type. You can not associate new things with deprecated thing type. Requires permission to access the `DeprecateThingType <https://docs.aws.amazon.com//service-authorization/latest/reference/list_awsiot.html#awsiot-actions-as-permissions>`_ action.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata which can be used to manage the thing type.\n')
    thing_type_name: typing.Optional[str] = pydantic.Field(None, description='The name of the thing type.\n')
    thing_type_properties: typing.Union[models.UnsupportedResource, models.aws_iot.CfnThingType_ThingTypePropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The thing type properties for the thing type to create. It contains information about the new thing type including a description, and a list of searchable thing attribute names. ``ThingTypeProperties`` can't be updated after the initial creation of the ``ThingType`` .")
    _init_params: typing.ClassVar[list[str]] = ['deprecate_thing_type', 'tags', 'thing_type_name', 'thing_type_properties']
    _method_names: typing.ClassVar[list[str]] = ['ThingTypePropertiesProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnThingType'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnThingTypeDefConfig] = pydantic.Field(None)


class CfnThingTypeDefConfig(pydantic.BaseModel):
    ThingTypePropertiesProperty: typing.Optional[list[CfnThingTypeDefThingtypepropertiespropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnThingTypeDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnThingTypeDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnThingTypeDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnThingTypeDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnThingTypeDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnThingTypeDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnThingTypeDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnThingTypeDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnThingTypeDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnThingTypeDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnThingTypeDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnThingTypeDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnThingTypeDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnThingTypeDefThingtypepropertiespropertyParams(pydantic.BaseModel):
    searchable_attributes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    thing_type_description: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnThingTypeDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnThingTypeDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnThingTypeDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnThingTypeDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnThingTypeDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnThingTypeDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnThingTypeDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnThingTypeDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnThingTypeDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnThingTypeDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnThingTypeDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnThingTypeDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnThingTypeDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnThingTypeDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnTopicRule
class CfnTopicRuleDef(BaseCfnResource):
    topic_rule_payload: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_iot.CfnTopicRule_TopicRulePayloadPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The rule payload.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='The name of the rule.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata which can be used to manage the topic rule. .. epigraph:: For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: --tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."')
    _init_params: typing.ClassVar[list[str]] = ['topic_rule_payload', 'rule_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['ActionProperty', 'AssetPropertyTimestampProperty', 'AssetPropertyValueProperty', 'AssetPropertyVariantProperty', 'CloudwatchAlarmActionProperty', 'CloudwatchLogsActionProperty', 'CloudwatchMetricActionProperty', 'DynamoDBActionProperty', 'DynamoDBv2ActionProperty', 'ElasticsearchActionProperty', 'FirehoseActionProperty', 'HttpActionHeaderProperty', 'HttpActionProperty', 'HttpAuthorizationProperty', 'IotAnalyticsActionProperty', 'IotEventsActionProperty', 'IotSiteWiseActionProperty', 'KafkaActionHeaderProperty', 'KafkaActionProperty', 'KinesisActionProperty', 'LambdaActionProperty', 'LocationActionProperty', 'OpenSearchActionProperty', 'PutAssetPropertyValueEntryProperty', 'PutItemInputProperty', 'RepublishActionHeadersProperty', 'RepublishActionProperty', 'S3ActionProperty', 'SigV4AuthorizationProperty', 'SnsActionProperty', 'SqsActionProperty', 'StepFunctionsActionProperty', 'TimestampProperty', 'TimestreamActionProperty', 'TimestreamDimensionProperty', 'TimestreamTimestampProperty', 'TopicRulePayloadProperty', 'UserPropertyProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRule'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTopicRuleDefConfig] = pydantic.Field(None)


class CfnTopicRuleDefConfig(pydantic.BaseModel):
    ActionProperty: typing.Optional[list[CfnTopicRuleDefActionpropertyParams]] = pydantic.Field(None, description='')
    AssetPropertyTimestampProperty: typing.Optional[list[CfnTopicRuleDefAssetpropertytimestamppropertyParams]] = pydantic.Field(None, description='')
    AssetPropertyValueProperty: typing.Optional[list[CfnTopicRuleDefAssetpropertyvaluepropertyParams]] = pydantic.Field(None, description='')
    AssetPropertyVariantProperty: typing.Optional[list[CfnTopicRuleDefAssetpropertyvariantpropertyParams]] = pydantic.Field(None, description='')
    CloudwatchAlarmActionProperty: typing.Optional[list[CfnTopicRuleDefCloudwatchalarmactionpropertyParams]] = pydantic.Field(None, description='')
    CloudwatchLogsActionProperty: typing.Optional[list[CfnTopicRuleDefCloudwatchlogsactionpropertyParams]] = pydantic.Field(None, description='')
    CloudwatchMetricActionProperty: typing.Optional[list[CfnTopicRuleDefCloudwatchmetricactionpropertyParams]] = pydantic.Field(None, description='')
    DynamoDBActionProperty: typing.Optional[list[CfnTopicRuleDefDynamodbactionpropertyParams]] = pydantic.Field(None, description='')
    DynamoDBv2ActionProperty: typing.Optional[list[CfnTopicRuleDefDynamodbv2ActionpropertyParams]] = pydantic.Field(None, description='')
    ElasticsearchActionProperty: typing.Optional[list[CfnTopicRuleDefElasticsearchactionpropertyParams]] = pydantic.Field(None, description='')
    FirehoseActionProperty: typing.Optional[list[CfnTopicRuleDefFirehoseactionpropertyParams]] = pydantic.Field(None, description='')
    HttpActionHeaderProperty: typing.Optional[list[CfnTopicRuleDefHttpactionheaderpropertyParams]] = pydantic.Field(None, description='')
    HttpActionProperty: typing.Optional[list[CfnTopicRuleDefHttpactionpropertyParams]] = pydantic.Field(None, description='')
    HttpAuthorizationProperty: typing.Optional[list[CfnTopicRuleDefHttpauthorizationpropertyParams]] = pydantic.Field(None, description='')
    IotAnalyticsActionProperty: typing.Optional[list[CfnTopicRuleDefIotanalyticsactionpropertyParams]] = pydantic.Field(None, description='')
    IotEventsActionProperty: typing.Optional[list[CfnTopicRuleDefIoteventsactionpropertyParams]] = pydantic.Field(None, description='')
    IotSiteWiseActionProperty: typing.Optional[list[CfnTopicRuleDefIotsitewiseactionpropertyParams]] = pydantic.Field(None, description='')
    KafkaActionHeaderProperty: typing.Optional[list[CfnTopicRuleDefKafkaactionheaderpropertyParams]] = pydantic.Field(None, description='')
    KafkaActionProperty: typing.Optional[list[CfnTopicRuleDefKafkaactionpropertyParams]] = pydantic.Field(None, description='')
    KinesisActionProperty: typing.Optional[list[CfnTopicRuleDefKinesisactionpropertyParams]] = pydantic.Field(None, description='')
    LambdaActionProperty: typing.Optional[list[CfnTopicRuleDefLambdaactionpropertyParams]] = pydantic.Field(None, description='')
    LocationActionProperty: typing.Optional[list[CfnTopicRuleDefLocationactionpropertyParams]] = pydantic.Field(None, description='')
    OpenSearchActionProperty: typing.Optional[list[CfnTopicRuleDefOpensearchactionpropertyParams]] = pydantic.Field(None, description='')
    PutAssetPropertyValueEntryProperty: typing.Optional[list[CfnTopicRuleDefPutassetpropertyvalueentrypropertyParams]] = pydantic.Field(None, description='')
    PutItemInputProperty: typing.Optional[list[CfnTopicRuleDefPutiteminputpropertyParams]] = pydantic.Field(None, description='')
    RepublishActionHeadersProperty: typing.Optional[list[CfnTopicRuleDefRepublishactionheaderspropertyParams]] = pydantic.Field(None, description='')
    RepublishActionProperty: typing.Optional[list[CfnTopicRuleDefRepublishactionpropertyParams]] = pydantic.Field(None, description='')
    S3ActionProperty: typing.Optional[list[CfnTopicRuleDefS3ActionpropertyParams]] = pydantic.Field(None, description='')
    SigV4AuthorizationProperty: typing.Optional[list[CfnTopicRuleDefSigv4AuthorizationpropertyParams]] = pydantic.Field(None, description='')
    SnsActionProperty: typing.Optional[list[CfnTopicRuleDefSnsactionpropertyParams]] = pydantic.Field(None, description='')
    SqsActionProperty: typing.Optional[list[CfnTopicRuleDefSqsactionpropertyParams]] = pydantic.Field(None, description='')
    StepFunctionsActionProperty: typing.Optional[list[CfnTopicRuleDefStepfunctionsactionpropertyParams]] = pydantic.Field(None, description='')
    TimestampProperty: typing.Optional[list[CfnTopicRuleDefTimestamppropertyParams]] = pydantic.Field(None, description='')
    TimestreamActionProperty: typing.Optional[list[CfnTopicRuleDefTimestreamactionpropertyParams]] = pydantic.Field(None, description='')
    TimestreamDimensionProperty: typing.Optional[list[CfnTopicRuleDefTimestreamdimensionpropertyParams]] = pydantic.Field(None, description='')
    TimestreamTimestampProperty: typing.Optional[list[CfnTopicRuleDefTimestreamtimestamppropertyParams]] = pydantic.Field(None, description='')
    TopicRulePayloadProperty: typing.Optional[list[CfnTopicRuleDefTopicrulepayloadpropertyParams]] = pydantic.Field(None, description='')
    UserPropertyProperty: typing.Optional[list[CfnTopicRuleDefUserpropertypropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnTopicRuleDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTopicRuleDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTopicRuleDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTopicRuleDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTopicRuleDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTopicRuleDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTopicRuleDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTopicRuleDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTopicRuleDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTopicRuleDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTopicRuleDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTopicRuleDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTopicRuleDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnTopicRuleDefActionpropertyParams(pydantic.BaseModel):
    cloudwatch_alarm: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_CloudwatchAlarmActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    cloudwatch_logs: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_CloudwatchLogsActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    cloudwatch_metric: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_CloudwatchMetricActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    dynamo_db: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_DynamoDBActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    dynamo_d_bv2: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_DynamoDBv2ActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    elasticsearch: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_ElasticsearchActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    firehose: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_FirehoseActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    http: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_HttpActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    iot_analytics: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_IotAnalyticsActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    iot_events: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_IotEventsActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    iot_site_wise: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_IotSiteWiseActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    kafka: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_KafkaActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    kinesis: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_KinesisActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    lambda_: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_LambdaActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    location: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_LocationActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    open_search: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_OpenSearchActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    republish: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_RepublishActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    s3: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_S3ActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    sns: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_SnsActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    sqs: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_SqsActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    step_functions: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_StepFunctionsActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    timestream: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_TimestreamActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefAssetpropertytimestamppropertyParams(pydantic.BaseModel):
    time_in_seconds: str = pydantic.Field(..., description='')
    offset_in_nanos: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefAssetpropertyvaluepropertyParams(pydantic.BaseModel):
    timestamp: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_AssetPropertyTimestampPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    value: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_AssetPropertyVariantPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    quality: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefAssetpropertyvariantpropertyParams(pydantic.BaseModel):
    boolean_value: typing.Optional[str] = pydantic.Field(None, description='')
    double_value: typing.Optional[str] = pydantic.Field(None, description='')
    integer_value: typing.Optional[str] = pydantic.Field(None, description='')
    string_value: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefCloudwatchalarmactionpropertyParams(pydantic.BaseModel):
    alarm_name: str = pydantic.Field(..., description='')
    role_arn: str = pydantic.Field(..., description='')
    state_reason: str = pydantic.Field(..., description='')
    state_value: str = pydantic.Field(..., description='')
    ...

class CfnTopicRuleDefCloudwatchlogsactionpropertyParams(pydantic.BaseModel):
    log_group_name: str = pydantic.Field(..., description='')
    role_arn: str = pydantic.Field(..., description='')
    batch_mode: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefCloudwatchmetricactionpropertyParams(pydantic.BaseModel):
    metric_name: str = pydantic.Field(..., description='')
    metric_namespace: str = pydantic.Field(..., description='')
    metric_unit: str = pydantic.Field(..., description='')
    metric_value: str = pydantic.Field(..., description='')
    role_arn: str = pydantic.Field(..., description='')
    metric_timestamp: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefDynamodbactionpropertyParams(pydantic.BaseModel):
    hash_key_field: str = pydantic.Field(..., description='')
    hash_key_value: str = pydantic.Field(..., description='')
    role_arn: str = pydantic.Field(..., description='')
    table_name: str = pydantic.Field(..., description='')
    hash_key_type: typing.Optional[str] = pydantic.Field(None, description='')
    payload_field: typing.Optional[str] = pydantic.Field(None, description='')
    range_key_field: typing.Optional[str] = pydantic.Field(None, description='')
    range_key_type: typing.Optional[str] = pydantic.Field(None, description='')
    range_key_value: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefDynamodbv2ActionpropertyParams(pydantic.BaseModel):
    put_item: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_PutItemInputPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefElasticsearchactionpropertyParams(pydantic.BaseModel):
    endpoint: str = pydantic.Field(..., description='')
    id: str = pydantic.Field(..., description='')
    index: str = pydantic.Field(..., description='')
    role_arn: str = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    ...

class CfnTopicRuleDefFirehoseactionpropertyParams(pydantic.BaseModel):
    delivery_stream_name: str = pydantic.Field(..., description='')
    role_arn: str = pydantic.Field(..., description='')
    batch_mode: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    separator: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefHttpactionheaderpropertyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnTopicRuleDefHttpactionpropertyParams(pydantic.BaseModel):
    url: str = pydantic.Field(..., description='')
    auth: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_HttpAuthorizationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    confirmation_url: typing.Optional[str] = pydantic.Field(None, description='')
    headers: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_HttpActionHeaderPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefHttpauthorizationpropertyParams(pydantic.BaseModel):
    sigv4: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_SigV4AuthorizationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefIotanalyticsactionpropertyParams(pydantic.BaseModel):
    channel_name: str = pydantic.Field(..., description='')
    role_arn: str = pydantic.Field(..., description='')
    batch_mode: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefIoteventsactionpropertyParams(pydantic.BaseModel):
    input_name: str = pydantic.Field(..., description='')
    role_arn: str = pydantic.Field(..., description='')
    batch_mode: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    message_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefIotsitewiseactionpropertyParams(pydantic.BaseModel):
    put_asset_property_value_entries: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_PutAssetPropertyValueEntryPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    role_arn: str = pydantic.Field(..., description='')
    ...

class CfnTopicRuleDefKafkaactionheaderpropertyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnTopicRuleDefKafkaactionpropertyParams(pydantic.BaseModel):
    client_properties: typing.Union[models.UnsupportedResource, typing.Mapping[str, str]] = pydantic.Field(..., description='')
    destination_arn: str = pydantic.Field(..., description='')
    topic: str = pydantic.Field(..., description='')
    headers: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_KafkaActionHeaderPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    key: typing.Optional[str] = pydantic.Field(None, description='')
    partition: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefKinesisactionpropertyParams(pydantic.BaseModel):
    role_arn: str = pydantic.Field(..., description='')
    stream_name: str = pydantic.Field(..., description='')
    partition_key: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefLambdaactionpropertyParams(pydantic.BaseModel):
    function_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefLocationactionpropertyParams(pydantic.BaseModel):
    device_id: str = pydantic.Field(..., description='')
    latitude: str = pydantic.Field(..., description='')
    longitude: str = pydantic.Field(..., description='')
    role_arn: str = pydantic.Field(..., description='')
    tracker_name: str = pydantic.Field(..., description='')
    timestamp: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_TimestampPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefOpensearchactionpropertyParams(pydantic.BaseModel):
    endpoint: str = pydantic.Field(..., description='')
    id: str = pydantic.Field(..., description='')
    index: str = pydantic.Field(..., description='')
    role_arn: str = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    ...

class CfnTopicRuleDefPutassetpropertyvalueentrypropertyParams(pydantic.BaseModel):
    property_values: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_AssetPropertyValuePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    asset_id: typing.Optional[str] = pydantic.Field(None, description='')
    entry_id: typing.Optional[str] = pydantic.Field(None, description='')
    property_alias: typing.Optional[str] = pydantic.Field(None, description='')
    property_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefPutiteminputpropertyParams(pydantic.BaseModel):
    table_name: str = pydantic.Field(..., description='')
    ...

class CfnTopicRuleDefRepublishactionheaderspropertyParams(pydantic.BaseModel):
    content_type: typing.Optional[str] = pydantic.Field(None, description='')
    correlation_data: typing.Optional[str] = pydantic.Field(None, description='')
    message_expiry: typing.Optional[str] = pydantic.Field(None, description='')
    payload_format_indicator: typing.Optional[str] = pydantic.Field(None, description='')
    response_topic: typing.Optional[str] = pydantic.Field(None, description='')
    user_properties: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_UserPropertyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefRepublishactionpropertyParams(pydantic.BaseModel):
    role_arn: str = pydantic.Field(..., description='')
    topic: str = pydantic.Field(..., description='')
    headers: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_RepublishActionHeadersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    qos: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefS3ActionpropertyParams(pydantic.BaseModel):
    bucket_name: str = pydantic.Field(..., description='')
    key: str = pydantic.Field(..., description='')
    role_arn: str = pydantic.Field(..., description='')
    canned_acl: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefSigv4AuthorizationpropertyParams(pydantic.BaseModel):
    role_arn: str = pydantic.Field(..., description='')
    service_name: str = pydantic.Field(..., description='')
    signing_region: str = pydantic.Field(..., description='')
    ...

class CfnTopicRuleDefSnsactionpropertyParams(pydantic.BaseModel):
    role_arn: str = pydantic.Field(..., description='')
    target_arn: str = pydantic.Field(..., description='')
    message_format: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefSqsactionpropertyParams(pydantic.BaseModel):
    queue_url: str = pydantic.Field(..., description='')
    role_arn: str = pydantic.Field(..., description='')
    use_base64: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefStepfunctionsactionpropertyParams(pydantic.BaseModel):
    role_arn: str = pydantic.Field(..., description='')
    state_machine_name: str = pydantic.Field(..., description='')
    execution_name_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefTimestamppropertyParams(pydantic.BaseModel):
    value: str = pydantic.Field(..., description='')
    unit: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefTimestreamactionpropertyParams(pydantic.BaseModel):
    database_name: str = pydantic.Field(..., description='')
    dimensions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_TimestreamDimensionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    role_arn: str = pydantic.Field(..., description='')
    table_name: str = pydantic.Field(..., description='')
    timestamp: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_TimestreamTimestampPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefTimestreamdimensionpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnTopicRuleDefTimestreamtimestamppropertyParams(pydantic.BaseModel):
    unit: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnTopicRuleDefTopicrulepayloadpropertyParams(pydantic.BaseModel):
    actions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_ActionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    sql: str = pydantic.Field(..., description='')
    aws_iot_sql_version: typing.Optional[str] = pydantic.Field(None, description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    error_action: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRule_ActionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    rule_disabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDefUserpropertypropertyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnTopicRuleDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTopicRuleDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTopicRuleDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTopicRuleDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTopicRuleDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTopicRuleDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTopicRuleDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTopicRuleDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTopicRuleDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTopicRuleDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTopicRuleDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnTopicRuleDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTopicRuleDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTopicRuleDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnTopicRuleDestination
class CfnTopicRuleDestinationDef(BaseCfnResource):
    http_url_properties: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRuleDestination_HttpUrlDestinationSummaryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Properties of the HTTP URL.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='- **IN_PROGRESS** - A topic rule destination was created but has not been confirmed. You can set status to ``IN_PROGRESS`` by calling ``UpdateTopicRuleDestination`` . Calling ``UpdateTopicRuleDestination`` causes a new confirmation challenge to be sent to your confirmation endpoint. - **ENABLED** - Confirmation was completed, and traffic to this destination is allowed. You can set status to ``DISABLED`` by calling ``UpdateTopicRuleDestination`` . - **DISABLED** - Confirmation was completed, and traffic to this destination is not allowed. You can set status to ``ENABLED`` by calling ``UpdateTopicRuleDestination`` . - **ERROR** - Confirmation could not be completed; for example, if the confirmation timed out. You can call ``GetTopicRuleDestination`` for details about the error. You can set status to ``IN_PROGRESS`` by calling ``UpdateTopicRuleDestination`` . Calling ``UpdateTopicRuleDestination`` causes a new confirmation challenge to be sent to your confirmation endpoint.\n')
    vpc_properties: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRuleDestination_VpcDestinationPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Properties of the virtual private cloud (VPC) connection.')
    _init_params: typing.ClassVar[list[str]] = ['http_url_properties', 'status', 'vpc_properties']
    _method_names: typing.ClassVar[list[str]] = ['HttpUrlDestinationSummaryProperty', 'VpcDestinationPropertiesProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRuleDestination'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTopicRuleDestinationDefConfig] = pydantic.Field(None)


class CfnTopicRuleDestinationDefConfig(pydantic.BaseModel):
    HttpUrlDestinationSummaryProperty: typing.Optional[list[CfnTopicRuleDestinationDefHttpurldestinationsummarypropertyParams]] = pydantic.Field(None, description='')
    VpcDestinationPropertiesProperty: typing.Optional[list[CfnTopicRuleDestinationDefVpcdestinationpropertiespropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnTopicRuleDestinationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTopicRuleDestinationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTopicRuleDestinationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTopicRuleDestinationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTopicRuleDestinationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTopicRuleDestinationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTopicRuleDestinationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTopicRuleDestinationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTopicRuleDestinationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTopicRuleDestinationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTopicRuleDestinationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTopicRuleDestinationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTopicRuleDestinationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnTopicRuleDestinationDefHttpurldestinationsummarypropertyParams(pydantic.BaseModel):
    confirmation_url: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDestinationDefVpcdestinationpropertiespropertyParams(pydantic.BaseModel):
    role_arn: typing.Optional[str] = pydantic.Field(None, description='')
    security_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    vpc_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTopicRuleDestinationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTopicRuleDestinationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTopicRuleDestinationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTopicRuleDestinationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTopicRuleDestinationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTopicRuleDestinationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTopicRuleDestinationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTopicRuleDestinationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTopicRuleDestinationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTopicRuleDestinationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTopicRuleDestinationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnTopicRuleDestinationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTopicRuleDestinationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTopicRuleDestinationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iot.CfnAccountAuditConfigurationProps
class CfnAccountAuditConfigurationPropsDef(BaseCfnProperty):
    account_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the account. You can use the expression ``!Sub "${AWS::AccountId}"`` to use your account ID.\n')
    audit_check_configurations: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditCheckConfigurationsPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description="Specifies which audit checks are enabled and disabled for this account. Some data collection might start immediately when certain checks are enabled. When a check is disabled, any data collected so far in relation to the check is deleted. To disable a check, set the value of the ``Enabled:`` key to ``false`` . If an enabled check is removed from the template, it will also be disabled. You can't disable a check if it's used by any scheduled audit. You must delete the check from the scheduled audit or delete the scheduled audit itself to disable the check. For more information on avialbe auidt checks see `AWS::IoT::AccountAuditConfiguration AuditCheckConfigurations <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot-accountauditconfiguration-auditcheckconfigurations.html>`_\n")
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the role that grants permission to AWS IoT to access information about your devices, policies, certificates, and other items as required when performing an audit.\n')
    audit_notification_target_configurations: typing.Union[models.UnsupportedResource, models.aws_iot.CfnAccountAuditConfiguration_AuditNotificationTargetConfigurationsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about the targets to which audit notifications are sent.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-accountauditconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_account_audit_configuration_props = iot.CfnAccountAuditConfigurationProps(\n        account_id="accountId",\n        audit_check_configurations=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationsProperty(\n            authenticated_cognito_role_overly_permissive_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n                enabled=False\n            ),\n            ca_certificate_expiring_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n                enabled=False\n            ),\n            ca_certificate_key_quality_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n                enabled=False\n            ),\n            conflicting_client_ids_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n                enabled=False\n            ),\n            device_certificate_expiring_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n                enabled=False\n            ),\n            device_certificate_key_quality_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n                enabled=False\n            ),\n            device_certificate_shared_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n                enabled=False\n            ),\n            intermediate_ca_revoked_for_active_device_certificates_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n                enabled=False\n            ),\n            iot_policy_overly_permissive_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n                enabled=False\n            ),\n            io_tPolicy_potential_mis_configuration_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n                enabled=False\n            ),\n            iot_role_alias_allows_access_to_unused_services_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n                enabled=False\n            ),\n            iot_role_alias_overly_permissive_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n                enabled=False\n            ),\n            logging_disabled_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n                enabled=False\n            ),\n            revoked_ca_certificate_still_active_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n                enabled=False\n            ),\n            revoked_device_certificate_still_active_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n                enabled=False\n            ),\n            unauthenticated_cognito_role_overly_permissive_check=iot.CfnAccountAuditConfiguration.AuditCheckConfigurationProperty(\n                enabled=False\n            )\n        ),\n        role_arn="roleArn",\n\n        # the properties below are optional\n        audit_notification_target_configurations=iot.CfnAccountAuditConfiguration.AuditNotificationTargetConfigurationsProperty(\n            sns=iot.CfnAccountAuditConfiguration.AuditNotificationTargetProperty(\n                enabled=False,\n                role_arn="roleArn",\n                target_arn="targetArn"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account_id', 'audit_check_configurations', 'role_arn', 'audit_notification_target_configurations']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnAccountAuditConfigurationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnAuthorizerProps
class CfnAuthorizerPropsDef(BaseCfnProperty):
    authorizer_function_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The authorizer's Lambda function ARN.\n")
    authorizer_name: typing.Optional[str] = pydantic.Field(None, description='The authorizer name.\n')
    enable_caching_for_http: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="When ``true`` , the result from the authorizer's Lambda function is cached for clients that use persistent HTTP connections. The results are cached for the time specified by the Lambda function in ``refreshAfterInSeconds`` . This value doesn't affect authorization of clients that use MQTT connections.\n")
    signing_disabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether AWS IoT validates the token signature in an authorization request.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='The status of the authorizer. Valid values: ``ACTIVE`` | ``INACTIVE``\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata which can be used to manage the custom authorizer. .. epigraph:: For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."\n')
    token_key_name: typing.Optional[str] = pydantic.Field(None, description='The key used to extract the token from the HTTP headers.\n')
    token_signing_public_keys: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='The public keys used to validate the token signature returned by your custom authentication service.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-authorizer.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_authorizer_props = iot.CfnAuthorizerProps(\n        authorizer_function_arn="authorizerFunctionArn",\n\n        # the properties below are optional\n        authorizer_name="authorizerName",\n        enable_caching_for_http=False,\n        signing_disabled=False,\n        status="status",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        token_key_name="tokenKeyName",\n        token_signing_public_keys={\n            "token_signing_public_keys_key": "tokenSigningPublicKeys"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['authorizer_function_arn', 'authorizer_name', 'enable_caching_for_http', 'signing_disabled', 'status', 'tags', 'token_key_name', 'token_signing_public_keys']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnAuthorizerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnBillingGroupProps
class CfnBillingGroupPropsDef(BaseCfnProperty):
    billing_group_name: typing.Optional[str] = pydantic.Field(None, description='The name of the billing group.\n')
    billing_group_properties: typing.Union[models.UnsupportedResource, models.aws_iot.CfnBillingGroup_BillingGroupPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties of the billing group.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata which can be used to manage the billing group.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-billinggroup.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_billing_group_props = iot.CfnBillingGroupProps(\n        billing_group_name="billingGroupName",\n        billing_group_properties=iot.CfnBillingGroup.BillingGroupPropertiesProperty(\n            billing_group_description="billingGroupDescription"\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['billing_group_name', 'billing_group_properties', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnBillingGroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnCACertificateProps
class CfnCACertificatePropsDef(BaseCfnProperty):
    ca_certificate_pem: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The certificate data in PEM format.\n')
    status: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The status of the CA certificate. Valid values are "ACTIVE" and "INACTIVE".\n')
    auto_registration_status: typing.Optional[str] = pydantic.Field(None, description='Whether the CA certificate is configured for auto registration of device certificates. Valid values are "ENABLE" and "DISABLE".\n')
    certificate_mode: typing.Optional[str] = pydantic.Field(None, description='The mode of the CA. All the device certificates that are registered using this CA will be registered in the same mode as the CA. For more information about certificate mode for device certificates, see `certificate mode <https://docs.aws.amazon.com//iot/latest/apireference/API_CertificateDescription.html#iot-Type-CertificateDescription-certificateMode>`_ . Valid values are "DEFAULT" and "SNI_ONLY".\n')
    registration_config: typing.Union[models.UnsupportedResource, models.aws_iot.CfnCACertificate_RegistrationConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about the registration configuration.\n')
    remove_auto_registration: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='If true, removes auto registration.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .\n')
    verification_certificate_pem: typing.Optional[str] = pydantic.Field(None, description='The private key verification certificate.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-cacertificate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_cACertificate_props = iot.CfnCACertificateProps(\n        ca_certificate_pem="caCertificatePem",\n        status="status",\n\n        # the properties below are optional\n        auto_registration_status="autoRegistrationStatus",\n        certificate_mode="certificateMode",\n        registration_config=iot.CfnCACertificate.RegistrationConfigProperty(\n            role_arn="roleArn",\n            template_body="templateBody",\n            template_name="templateName"\n        ),\n        remove_auto_registration=False,\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        verification_certificate_pem="verificationCertificatePem"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ca_certificate_pem', 'status', 'auto_registration_status', 'certificate_mode', 'registration_config', 'remove_auto_registration', 'tags', 'verification_certificate_pem']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnCACertificateProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnCertificateProps
class CfnCertificatePropsDef(BaseCfnProperty):
    status: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The status of the certificate. Valid values are ACTIVE, INACTIVE, REVOKED, PENDING_TRANSFER, and PENDING_ACTIVATION. The status value REGISTER_INACTIVE is deprecated and should not be used.\n')
    ca_certificate_pem: typing.Optional[str] = pydantic.Field(None, description='The CA certificate used to sign the device certificate being registered, not available when CertificateMode is SNI_ONLY.\n')
    certificate_mode: typing.Optional[str] = pydantic.Field(None, description="Specifies which mode of certificate registration to use with this resource. Valid options are DEFAULT with CaCertificatePem and CertificatePem, SNI_ONLY with CertificatePem, and Default with CertificateSigningRequest. ``DEFAULT`` : A certificate in ``DEFAULT`` mode is either generated by AWS IoT Core or registered with an issuer certificate authority (CA). Devices with certificates in ``DEFAULT`` mode aren't required to send the Server Name Indication (SNI) extension when connecting to AWS IoT Core . However, to use features such as custom domains and VPC endpoints, we recommend that you use the SNI extension when connecting to AWS IoT Core . ``SNI_ONLY`` : A certificate in ``SNI_ONLY`` mode is registered without an issuer CA. Devices with certificates in ``SNI_ONLY`` mode must send the SNI extension when connecting to AWS IoT Core .\n")
    certificate_pem: typing.Optional[str] = pydantic.Field(None, description='The certificate data in PEM format. Requires SNI_ONLY for the certificate mode or the accompanying CACertificatePem for registration.\n')
    certificate_signing_request: typing.Optional[str] = pydantic.Field(None, description='The certificate signing request (CSR).\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-certificate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_certificate_props = iot.CfnCertificateProps(\n        status="status",\n\n        # the properties below are optional\n        ca_certificate_pem="caCertificatePem",\n        certificate_mode="certificateMode",\n        certificate_pem="certificatePem",\n        certificate_signing_request="certificateSigningRequest"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['status', 'ca_certificate_pem', 'certificate_mode', 'certificate_pem', 'certificate_signing_request']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnCertificateProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnCustomMetricProps
class CfnCustomMetricPropsDef(BaseCfnProperty):
    metric_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of the custom metric. Types include ``string-list`` , ``ip-address-list`` , ``number-list`` , and ``number`` . .. epigraph:: The type ``number`` only takes a single metric value as an input, but when you submit the metrics value in the DeviceMetrics report, you must pass it as an array with a single value.\n')
    display_name: typing.Optional[str] = pydantic.Field(None, description="The friendly name in the console for the custom metric. This name doesn't have to be unique. Don't use this name as the metric identifier in the device metric report. You can update the friendly name after you define it.\n")
    metric_name: typing.Optional[str] = pydantic.Field(None, description="The name of the custom metric. This will be used in the metric report submitted from the device/thing. The name can't begin with ``aws:`` . You cant change the name after you define it.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata that can be used to manage the custom metric.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-custommetric.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_custom_metric_props = iot.CfnCustomMetricProps(\n        metric_type="metricType",\n\n        # the properties below are optional\n        display_name="displayName",\n        metric_name="metricName",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['metric_type', 'display_name', 'metric_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnCustomMetricProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnDimensionProps
class CfnDimensionPropsDef(BaseCfnProperty):
    string_values: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the value or list of values for the dimension. For ``TOPIC_FILTER`` dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the type of dimension. Supported types: ``TOPIC_FILTER.``\n')
    name: typing.Optional[str] = pydantic.Field(None, description='A unique identifier for the dimension.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata that can be used to manage the dimension.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-dimension.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_dimension_props = iot.CfnDimensionProps(\n        string_values=["stringValues"],\n        type="type",\n\n        # the properties below are optional\n        name="name",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['string_values', 'type', 'name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnDimensionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnDomainConfigurationProps
class CfnDomainConfigurationPropsDef(BaseCfnProperty):
    authorizer_config: typing.Union[models.UnsupportedResource, models.aws_iot.CfnDomainConfiguration_AuthorizerConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that specifies the authorization service for a domain.\n')
    domain_configuration_name: typing.Optional[str] = pydantic.Field(None, description='The name of the domain configuration. This value must be unique to a region.\n')
    domain_configuration_status: typing.Optional[str] = pydantic.Field(None, description='The status to which the domain configuration should be updated. Valid values: ``ENABLED`` | ``DISABLED``\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='The name of the domain.\n')
    server_certificate_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The ARNs of the certificates that AWS IoT passes to the device during the TLS handshake. Currently you can specify only one certificate ARN. This value is not required for AWS -managed domains.\n')
    service_type: typing.Optional[str] = pydantic.Field(None, description='The type of service delivered by the endpoint. .. epigraph:: AWS IoT Core currently supports only the ``DATA`` service type.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata which can be used to manage the domain configuration. .. epigraph:: For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."\n')
    tls_config: typing.Union[models.UnsupportedResource, models.aws_iot.CfnDomainConfiguration_TlsConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that specifies the TLS configuration for a domain.\n')
    validation_certificate_arn: typing.Optional[str] = pydantic.Field(None, description='The certificate used to validate the server certificate and prove domain name ownership. This certificate must be signed by a public certificate authority. This value is not required for AWS -managed domains.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-domainconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_domain_configuration_props = iot.CfnDomainConfigurationProps(\n        authorizer_config=iot.CfnDomainConfiguration.AuthorizerConfigProperty(\n            allow_authorizer_override=False,\n            default_authorizer_name="defaultAuthorizerName"\n        ),\n        domain_configuration_name="domainConfigurationName",\n        domain_configuration_status="domainConfigurationStatus",\n        domain_name="domainName",\n        server_certificate_arns=["serverCertificateArns"],\n        service_type="serviceType",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        tls_config=iot.CfnDomainConfiguration.TlsConfigProperty(\n            security_policy="securityPolicy"\n        ),\n        validation_certificate_arn="validationCertificateArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['authorizer_config', 'domain_configuration_name', 'domain_configuration_status', 'domain_name', 'server_certificate_arns', 'service_type', 'tags', 'tls_config', 'validation_certificate_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnDomainConfigurationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnFleetMetricProps
class CfnFleetMetricPropsDef(BaseCfnProperty):
    metric_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the fleet metric to create.\n')
    aggregation_field: typing.Optional[str] = pydantic.Field(None, description='The field to aggregate.\n')
    aggregation_type: typing.Union[models.UnsupportedResource, models.aws_iot.CfnFleetMetric_AggregationTypePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of the aggregation query.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The fleet metric description.\n')
    index_name: typing.Optional[str] = pydantic.Field(None, description='The name of the index to search.\n')
    period: typing.Union[int, float, None] = pydantic.Field(None, description='The time in seconds between fleet metric emissions. Range [60(1 min), 86400(1 day)] and must be multiple of 60.\n')
    query_string: typing.Optional[str] = pydantic.Field(None, description='The search query string.\n')
    query_version: typing.Optional[str] = pydantic.Field(None, description='The query version.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata which can be used to manage the fleet metric.\n')
    unit: typing.Optional[str] = pydantic.Field(None, description='Used to support unit transformation such as milliseconds to seconds. Must be a unit supported by CW metric. Default to null.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-fleetmetric.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_fleet_metric_props = iot.CfnFleetMetricProps(\n        metric_name="metricName",\n\n        # the properties below are optional\n        aggregation_field="aggregationField",\n        aggregation_type=iot.CfnFleetMetric.AggregationTypeProperty(\n            name="name",\n            values=["values"]\n        ),\n        description="description",\n        index_name="indexName",\n        period=123,\n        query_string="queryString",\n        query_version="queryVersion",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        unit="unit"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['metric_name', 'aggregation_field', 'aggregation_type', 'description', 'index_name', 'period', 'query_string', 'query_version', 'tags', 'unit']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnFleetMetricProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnJobTemplateProps
class CfnJobTemplatePropsDef(BaseCfnProperty):
    description: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A description of the job template.\n')
    job_template_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A unique identifier for the job template. We recommend using a UUID. Alpha-numeric characters, "-", and "_" are valid for use here.\n')
    abort_config: typing.Any = pydantic.Field(None, description='The criteria that determine when and how a job abort takes place.\n')
    destination_package_versions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The package version Amazon Resource Names (ARNs) that are installed on the devices reserved named shadow ( ``$package`` ) when the job successfully completes. *Note:* Up to 25 package version ARNS are allowed. .. epigraph:: The CloudFormation ``DestinationPackageVersions`` parameter is available in the Beijing (cn-north-1) Region and other Regions where Service Package Catalog has been deployed except for the the Ningxia (cn-northest-1) Region. We will launch to Ningxia region as quickly as possible.\n')
    document: typing.Optional[str] = pydantic.Field(None, description="The job document. Required if you don't specify a value for ``documentSource`` .\n")
    document_source: typing.Optional[str] = pydantic.Field(None, description="An S3 link, or S3 object URL, to the job document. The link is an Amazon S3 object URL and is required if you don't specify a value for ``document`` . For example, ``--document-source https://s3. *region-code* .amazonaws.com/example-firmware/device-firmware.1.0`` For more information, see `Methods for accessing a bucket <https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-bucket-intro.html>`_ .\n")
    job_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the job to use as the basis for the job template.\n')
    job_executions_retry_config: typing.Union[models.UnsupportedResource, models.aws_iot.CfnJobTemplate_JobExecutionsRetryConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Allows you to create the criteria to retry a job.\n')
    job_executions_rollout_config: typing.Any = pydantic.Field(None, description='Allows you to create a staged rollout of a job.\n')
    maintenance_windows: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnJobTemplate_MaintenanceWindowPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An optional configuration within the SchedulingConfig to setup a recurring maintenance window with a predetermined start time and duration for the rollout of a job document to all devices in a target group for a job.\n')
    presigned_url_config: typing.Any = pydantic.Field(None, description='Configuration for pre-signed S3 URLs.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata that can be used to manage the job template.\n')
    timeout_config: typing.Any = pydantic.Field(None, description='Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to ``IN_PROGRESS`` . If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to ``TIMED_OUT`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-jobtemplate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    # abort_config: Any\n    # job_executions_rollout_config: Any\n    # presigned_url_config: Any\n    # timeout_config: Any\n\n    cfn_job_template_props = iot.CfnJobTemplateProps(\n        description="description",\n        job_template_id="jobTemplateId",\n\n        # the properties below are optional\n        abort_config=abort_config,\n        destination_package_versions=["destinationPackageVersions"],\n        document="document",\n        document_source="documentSource",\n        job_arn="jobArn",\n        job_executions_retry_config=iot.CfnJobTemplate.JobExecutionsRetryConfigProperty(\n            retry_criteria_list=[iot.CfnJobTemplate.RetryCriteriaProperty(\n                failure_type="failureType",\n                number_of_retries=123\n            )]\n        ),\n        job_executions_rollout_config=job_executions_rollout_config,\n        maintenance_windows=[iot.CfnJobTemplate.MaintenanceWindowProperty(\n            duration_in_minutes=123,\n            start_time="startTime"\n        )],\n        presigned_url_config=presigned_url_config,\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        timeout_config=timeout_config\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'job_template_id', 'abort_config', 'destination_package_versions', 'document', 'document_source', 'job_arn', 'job_executions_retry_config', 'job_executions_rollout_config', 'maintenance_windows', 'presigned_url_config', 'tags', 'timeout_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnJobTemplateProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnLoggingProps
class CfnLoggingPropsDef(BaseCfnProperty):
    account_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The account ID.\n')
    default_log_level: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The default log level. Valid Values: ``DEBUG | INFO | ERROR | WARN | DISABLED``\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The role ARN used for the log.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-logging.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_logging_props = iot.CfnLoggingProps(\n        account_id="accountId",\n        default_log_level="defaultLogLevel",\n        role_arn="roleArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account_id', 'default_log_level', 'role_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnLoggingProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnMitigationActionProps
class CfnMitigationActionPropsDef(BaseCfnProperty):
    action_params: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_iot.CfnMitigationAction_ActionParamsPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The set of parameters for this mitigation action. The parameters vary, depending on the kind of action you apply.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The IAM role ARN used to apply this mitigation action.\n')
    action_name: typing.Optional[str] = pydantic.Field(None, description='The friendly name of the mitigation action.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata that can be used to manage the mitigation action.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-mitigationaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_mitigation_action_props = iot.CfnMitigationActionProps(\n        action_params=iot.CfnMitigationAction.ActionParamsProperty(\n            add_things_to_thing_group_params=iot.CfnMitigationAction.AddThingsToThingGroupParamsProperty(\n                thing_group_names=["thingGroupNames"],\n\n                # the properties below are optional\n                override_dynamic_groups=False\n            ),\n            enable_io_tLogging_params=iot.CfnMitigationAction.EnableIoTLoggingParamsProperty(\n                log_level="logLevel",\n                role_arn_for_logging="roleArnForLogging"\n            ),\n            publish_finding_to_sns_params=iot.CfnMitigationAction.PublishFindingToSnsParamsProperty(\n                topic_arn="topicArn"\n            ),\n            replace_default_policy_version_params=iot.CfnMitigationAction.ReplaceDefaultPolicyVersionParamsProperty(\n                template_name="templateName"\n            ),\n            update_ca_certificate_params=iot.CfnMitigationAction.UpdateCACertificateParamsProperty(\n                action="action"\n            ),\n            update_device_certificate_params=iot.CfnMitigationAction.UpdateDeviceCertificateParamsProperty(\n                action="action"\n            )\n        ),\n        role_arn="roleArn",\n\n        # the properties below are optional\n        action_name="actionName",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action_params', 'role_arn', 'action_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnMitigationActionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnPolicyPrincipalAttachmentProps
class CfnPolicyPrincipalAttachmentPropsDef(BaseCfnProperty):
    policy_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the AWS IoT policy.\n')
    principal: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The principal, which can be a certificate ARN (as returned from the ``CreateCertificate`` operation) or an Amazon Cognito ID.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-policyprincipalattachment.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_policy_principal_attachment_props = iot.CfnPolicyPrincipalAttachmentProps(\n        policy_name="policyName",\n        principal="principal"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['policy_name', 'principal']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnPolicyPrincipalAttachmentProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnPolicyProps
class CfnPolicyPropsDef(BaseCfnProperty):
    policy_document: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The JSON document that describes the policy.\n')
    policy_name: typing.Optional[str] = pydantic.Field(None, description='The policy name.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='')
    _init_params: typing.ClassVar[list[str]] = ['policy_document', 'policy_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnPolicyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnProvisioningTemplateProps
class CfnProvisioningTemplatePropsDef(BaseCfnProperty):
    provisioning_role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The role ARN for the role associated with the fleet provisioning template. This IoT role grants permission to provision a device.\n')
    template_body: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The JSON formatted contents of the fleet provisioning template version.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the fleet provisioning template.\n')
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='True to enable the fleet provisioning template, otherwise false.\n')
    pre_provisioning_hook: typing.Union[models.UnsupportedResource, models.aws_iot.CfnProvisioningTemplate_ProvisioningHookPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Creates a pre-provisioning hook template.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata that can be used to manage the fleet provisioning template.\n')
    template_name: typing.Optional[str] = pydantic.Field(None, description='The name of the fleet provisioning template.\n')
    template_type: typing.Optional[str] = pydantic.Field(None, description='The type of the provisioning template.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-provisioningtemplate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_provisioning_template_props = iot.CfnProvisioningTemplateProps(\n        provisioning_role_arn="provisioningRoleArn",\n        template_body="templateBody",\n\n        # the properties below are optional\n        description="description",\n        enabled=False,\n        pre_provisioning_hook=iot.CfnProvisioningTemplate.ProvisioningHookProperty(\n            payload_version="payloadVersion",\n            target_arn="targetArn"\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        template_name="templateName",\n        template_type="templateType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['provisioning_role_arn', 'template_body', 'description', 'enabled', 'pre_provisioning_hook', 'tags', 'template_name', 'template_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnProvisioningTemplateProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnResourceSpecificLoggingProps
class CfnResourceSpecificLoggingPropsDef(BaseCfnProperty):
    log_level: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The default log level.Valid Values: ``DEBUG | INFO | ERROR | WARN | DISABLED``.\n')
    target_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The target name.\n')
    target_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The target type. Valid Values: ``DEFAULT | THING_GROUP``\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-resourcespecificlogging.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_resource_specific_logging_props = iot.CfnResourceSpecificLoggingProps(\n        log_level="logLevel",\n        target_name="targetName",\n        target_type="targetType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['log_level', 'target_name', 'target_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnResourceSpecificLoggingProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnRoleAliasProps
class CfnRoleAliasPropsDef(BaseCfnProperty):
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The role ARN.\n')
    credential_duration_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The number of seconds for which the credential is valid. Default: - 3600\n')
    role_alias: typing.Optional[str] = pydantic.Field(None, description='The role alias.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-rolealias.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_role_alias_props = iot.CfnRoleAliasProps(\n        role_arn="roleArn",\n\n        # the properties below are optional\n        credential_duration_seconds=123,\n        role_alias="roleAlias",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['role_arn', 'credential_duration_seconds', 'role_alias', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnRoleAliasProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnScheduledAuditProps
class CfnScheduledAuditPropsDef(BaseCfnProperty):
    frequency: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='How often the scheduled audit occurs.\n')
    target_check_names: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use ``DescribeAccountAuditConfiguration`` to see the list of all checks, including those that are enabled or use ``UpdateAccountAuditConfiguration`` to select which checks are enabled.) The following checks are currently aviable: - ``AUTHENTICATED_COGNITO_ROLE_OVERLY_PERMISSIVE_CHECK`` - ``CA_CERTIFICATE_EXPIRING_CHECK`` - ``CA_CERTIFICATE_KEY_QUALITY_CHECK`` - ``CONFLICTING_CLIENT_IDS_CHECK`` - ``DEVICE_CERTIFICATE_EXPIRING_CHECK`` - ``DEVICE_CERTIFICATE_KEY_QUALITY_CHECK`` - ``DEVICE_CERTIFICATE_SHARED_CHECK`` - ``IOT_POLICY_OVERLY_PERMISSIVE_CHECK`` - ``IOT_ROLE_ALIAS_ALLOWS_ACCESS_TO_UNUSED_SERVICES_CHECK`` - ``IOT_ROLE_ALIAS_OVERLY_PERMISSIVE_CHECK`` - ``LOGGING_DISABLED_CHECK`` - ``REVOKED_CA_CERTIFICATE_STILL_ACTIVE_CHECK`` - ``REVOKED_DEVICE_CERTIFICATE_STILL_ACTIVE_CHECK`` - ``UNAUTHENTICATED_COGNITO_ROLE_OVERLY_PERMISSIVE_CHECK``\n')
    day_of_month: typing.Optional[str] = pydantic.Field(None, description='The day of the month on which the scheduled audit is run (if the ``frequency`` is "MONTHLY"). If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.\n')
    day_of_week: typing.Optional[str] = pydantic.Field(None, description='The day of the week on which the scheduled audit is run (if the ``frequency`` is "WEEKLY" or "BIWEEKLY").\n')
    scheduled_audit_name: typing.Optional[str] = pydantic.Field(None, description='The name of the scheduled audit.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata that can be used to manage the scheduled audit.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-scheduledaudit.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_scheduled_audit_props = iot.CfnScheduledAuditProps(\n        frequency="frequency",\n        target_check_names=["targetCheckNames"],\n\n        # the properties below are optional\n        day_of_month="dayOfMonth",\n        day_of_week="dayOfWeek",\n        scheduled_audit_name="scheduledAuditName",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['frequency', 'target_check_names', 'day_of_month', 'day_of_week', 'scheduled_audit_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnScheduledAuditProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnSecurityProfileProps
class CfnSecurityProfilePropsDef(BaseCfnProperty):
    additional_metrics_to_retain_v2: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnSecurityProfile_MetricToRetainPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's ``behaviors`` , but it's also retained for any metric specified here. Can be used with custom metrics; can't be used with dimensions.\n")
    alert_targets: typing.Union[models.UnsupportedResource, typing.Mapping[str, typing.Union[models.UnsupportedResource, models.aws_iot.CfnSecurityProfile_AlertTargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Specifies the destinations to which alerts are sent. (Alerts are always sent to the console.) Alerts are generated when a device (thing) violates a behavior.\n')
    behaviors: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iot.CfnSecurityProfile_BehaviorPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Specifies the behaviors that, when violated by a device (thing), cause an alert.\n')
    security_profile_description: typing.Optional[str] = pydantic.Field(None, description='A description of the security profile.\n')
    security_profile_name: typing.Optional[str] = pydantic.Field(None, description='The name you gave to the security profile.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata that can be used to manage the security profile.\n')
    target_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The ARN of the target (thing group) to which the security profile is attached.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-securityprofile.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_security_profile_props = iot.CfnSecurityProfileProps(\n        additional_metrics_to_retain_v2=[iot.CfnSecurityProfile.MetricToRetainProperty(\n            metric="metric",\n\n            # the properties below are optional\n            metric_dimension=iot.CfnSecurityProfile.MetricDimensionProperty(\n                dimension_name="dimensionName",\n\n                # the properties below are optional\n                operator="operator"\n            )\n        )],\n        alert_targets={\n            "alert_targets_key": iot.CfnSecurityProfile.AlertTargetProperty(\n                alert_target_arn="alertTargetArn",\n                role_arn="roleArn"\n            )\n        },\n        behaviors=[iot.CfnSecurityProfile.BehaviorProperty(\n            name="name",\n\n            # the properties below are optional\n            criteria=iot.CfnSecurityProfile.BehaviorCriteriaProperty(\n                comparison_operator="comparisonOperator",\n                consecutive_datapoints_to_alarm=123,\n                consecutive_datapoints_to_clear=123,\n                duration_seconds=123,\n                ml_detection_config=iot.CfnSecurityProfile.MachineLearningDetectionConfigProperty(\n                    confidence_level="confidenceLevel"\n                ),\n                statistical_threshold=iot.CfnSecurityProfile.StatisticalThresholdProperty(\n                    statistic="statistic"\n                ),\n                value=iot.CfnSecurityProfile.MetricValueProperty(\n                    cidrs=["cidrs"],\n                    count="count",\n                    number=123,\n                    numbers=[123],\n                    ports=[123],\n                    strings=["strings"]\n                )\n            ),\n            metric="metric",\n            metric_dimension=iot.CfnSecurityProfile.MetricDimensionProperty(\n                dimension_name="dimensionName",\n\n                # the properties below are optional\n                operator="operator"\n            ),\n            suppress_alerts=False\n        )],\n        security_profile_description="securityProfileDescription",\n        security_profile_name="securityProfileName",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        target_arns=["targetArns"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['additional_metrics_to_retain_v2', 'alert_targets', 'behaviors', 'security_profile_description', 'security_profile_name', 'tags', 'target_arns']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnSecurityProfileProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnSoftwarePackageProps
class CfnSoftwarePackagePropsDef(BaseCfnProperty):
    description: typing.Optional[str] = pydantic.Field(None, description="A summary of the package being created. This can be used to outline the package's contents or purpose.\n")
    package_name: typing.Optional[str] = pydantic.Field(None, description='The name of the new software package.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata that can be used to manage the package.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-softwarepackage.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_software_package_props = iot.CfnSoftwarePackageProps(\n        description="description",\n        package_name="packageName",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'package_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnSoftwarePackageProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnSoftwarePackageVersionProps
class CfnSoftwarePackageVersionPropsDef(BaseCfnProperty):
    package_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the associated software package.\n')
    attributes: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='Metadata that can be used to define a package versions configuration. For example, the S3 file location, configuration options that are being sent to the device or fleet. The combined size of all the attributes on a package version is limited to 3KB.\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A summary of the package version being created. This can be used to outline the package's contents or purpose.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata that can be used to manage the package version.\n')
    version_name: typing.Optional[str] = pydantic.Field(None, description='The name of the new package version.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-softwarepackageversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_software_package_version_props = iot.CfnSoftwarePackageVersionProps(\n        package_name="packageName",\n\n        # the properties below are optional\n        attributes={\n            "attributes_key": "attributes"\n        },\n        description="description",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        version_name="versionName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['package_name', 'attributes', 'description', 'tags', 'version_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnSoftwarePackageVersionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnThingGroupProps
class CfnThingGroupPropsDef(BaseCfnProperty):
    parent_group_name: typing.Optional[str] = pydantic.Field(None, description='The parent thing group name. A Dynamic Thing Group does not have ``parentGroupName`` defined.\n')
    query_string: typing.Optional[str] = pydantic.Field(None, description='The dynamic thing group search query string. The ``queryString`` attribute *is* required for ``CreateDynamicThingGroup`` . The ``queryString`` attribute *is not* required for ``CreateThingGroup`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata which can be used to manage the thing group or dynamic thing group.\n')
    thing_group_name: typing.Optional[str] = pydantic.Field(None, description='The thing group name.\n')
    thing_group_properties: typing.Union[models.UnsupportedResource, models.aws_iot.CfnThingGroup_ThingGroupPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Thing group properties.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thinggroup.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_thing_group_props = iot.CfnThingGroupProps(\n        parent_group_name="parentGroupName",\n        query_string="queryString",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        thing_group_name="thingGroupName",\n        thing_group_properties=iot.CfnThingGroup.ThingGroupPropertiesProperty(\n            attribute_payload=iot.CfnThingGroup.AttributePayloadProperty(\n                attributes={\n                    "attributes_key": "attributes"\n                }\n            ),\n            thing_group_description="thingGroupDescription"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['parent_group_name', 'query_string', 'tags', 'thing_group_name', 'thing_group_properties']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnThingGroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnThingPrincipalAttachmentProps
class CfnThingPrincipalAttachmentPropsDef(BaseCfnProperty):
    principal: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The principal, which can be a certificate ARN (as returned from the ``CreateCertificate`` operation) or an Amazon Cognito ID.\n')
    thing_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the AWS IoT thing.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thingprincipalattachment.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_thing_principal_attachment_props = iot.CfnThingPrincipalAttachmentProps(\n        principal="principal",\n        thing_name="thingName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['principal', 'thing_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnThingPrincipalAttachmentProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnThingProps
class CfnThingPropsDef(BaseCfnProperty):
    attribute_payload: typing.Union[models.UnsupportedResource, models.aws_iot.CfnThing_AttributePayloadPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A string that contains up to three key value pairs. Maximum length of 800. Duplicates not allowed.\n')
    thing_name: typing.Optional[str] = pydantic.Field(None, description='The name of the thing to update. You can\'t change a thing\'s name. To change a thing\'s name, you must create a new thing, give it the new name, and then delete the old thing.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thing.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_thing_props = iot.CfnThingProps(\n        attribute_payload=iot.CfnThing.AttributePayloadProperty(\n            attributes={\n                "attributes_key": "attributes"\n            }\n        ),\n        thing_name="thingName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['attribute_payload', 'thing_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnThingProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnThingTypeProps
class CfnThingTypePropsDef(BaseCfnProperty):
    deprecate_thing_type: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Deprecates a thing type. You can not associate new things with deprecated thing type. Requires permission to access the `DeprecateThingType <https://docs.aws.amazon.com//service-authorization/latest/reference/list_awsiot.html#awsiot-actions-as-permissions>`_ action.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata which can be used to manage the thing type.\n')
    thing_type_name: typing.Optional[str] = pydantic.Field(None, description='The name of the thing type.\n')
    thing_type_properties: typing.Union[models.UnsupportedResource, models.aws_iot.CfnThingType_ThingTypePropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The thing type properties for the thing type to create. It contains information about the new thing type including a description, and a list of searchable thing attribute names. ``ThingTypeProperties`` can\'t be updated after the initial creation of the ``ThingType`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-thingtype.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_thing_type_props = iot.CfnThingTypeProps(\n        deprecate_thing_type=False,\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        thing_type_name="thingTypeName",\n        thing_type_properties=iot.CfnThingType.ThingTypePropertiesProperty(\n            searchable_attributes=["searchableAttributes"],\n            thing_type_description="thingTypeDescription"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['deprecate_thing_type', 'tags', 'thing_type_name', 'thing_type_properties']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnThingTypeProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRuleDestinationProps
class CfnTopicRuleDestinationPropsDef(BaseCfnProperty):
    http_url_properties: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRuleDestination_HttpUrlDestinationSummaryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Properties of the HTTP URL.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='- **IN_PROGRESS** - A topic rule destination was created but has not been confirmed. You can set status to ``IN_PROGRESS`` by calling ``UpdateTopicRuleDestination`` . Calling ``UpdateTopicRuleDestination`` causes a new confirmation challenge to be sent to your confirmation endpoint. - **ENABLED** - Confirmation was completed, and traffic to this destination is allowed. You can set status to ``DISABLED`` by calling ``UpdateTopicRuleDestination`` . - **DISABLED** - Confirmation was completed, and traffic to this destination is not allowed. You can set status to ``ENABLED`` by calling ``UpdateTopicRuleDestination`` . - **ERROR** - Confirmation could not be completed; for example, if the confirmation timed out. You can call ``GetTopicRuleDestination`` for details about the error. You can set status to ``IN_PROGRESS`` by calling ``UpdateTopicRuleDestination`` . Calling ``UpdateTopicRuleDestination`` causes a new confirmation challenge to be sent to your confirmation endpoint.\n')
    vpc_properties: typing.Union[models.UnsupportedResource, models.aws_iot.CfnTopicRuleDestination_VpcDestinationPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Properties of the virtual private cloud (VPC) connection.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-topicruledestination.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_topic_rule_destination_props = iot.CfnTopicRuleDestinationProps(\n        http_url_properties=iot.CfnTopicRuleDestination.HttpUrlDestinationSummaryProperty(\n            confirmation_url="confirmationUrl"\n        ),\n        status="status",\n        vpc_properties=iot.CfnTopicRuleDestination.VpcDestinationPropertiesProperty(\n            role_arn="roleArn",\n            security_groups=["securityGroups"],\n            subnet_ids=["subnetIds"],\n            vpc_id="vpcId"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['http_url_properties', 'status', 'vpc_properties']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRuleDestinationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iot.CfnTopicRuleProps
class CfnTopicRulePropsDef(BaseCfnProperty):
    topic_rule_payload: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_iot.CfnTopicRule_TopicRulePayloadPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The rule payload.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='The name of the rule.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Metadata which can be used to manage the topic rule. .. epigraph:: For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: --tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iot-topicrule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iot as iot\n\n    cfn_topic_rule_props = iot.CfnTopicRuleProps(\n        topic_rule_payload=iot.CfnTopicRule.TopicRulePayloadProperty(\n            actions=[iot.CfnTopicRule.ActionProperty(\n                cloudwatch_alarm=iot.CfnTopicRule.CloudwatchAlarmActionProperty(\n                    alarm_name="alarmName",\n                    role_arn="roleArn",\n                    state_reason="stateReason",\n                    state_value="stateValue"\n                ),\n                cloudwatch_logs=iot.CfnTopicRule.CloudwatchLogsActionProperty(\n                    log_group_name="logGroupName",\n                    role_arn="roleArn",\n\n                    # the properties below are optional\n                    batch_mode=False\n                ),\n                cloudwatch_metric=iot.CfnTopicRule.CloudwatchMetricActionProperty(\n                    metric_name="metricName",\n                    metric_namespace="metricNamespace",\n                    metric_unit="metricUnit",\n                    metric_value="metricValue",\n                    role_arn="roleArn",\n\n                    # the properties below are optional\n                    metric_timestamp="metricTimestamp"\n                ),\n                dynamo_db=iot.CfnTopicRule.DynamoDBActionProperty(\n                    hash_key_field="hashKeyField",\n                    hash_key_value="hashKeyValue",\n                    role_arn="roleArn",\n                    table_name="tableName",\n\n                    # the properties below are optional\n                    hash_key_type="hashKeyType",\n                    payload_field="payloadField",\n                    range_key_field="rangeKeyField",\n                    range_key_type="rangeKeyType",\n                    range_key_value="rangeKeyValue"\n                ),\n                dynamo_dBv2=iot.CfnTopicRule.DynamoDBv2ActionProperty(\n                    put_item=iot.CfnTopicRule.PutItemInputProperty(\n                        table_name="tableName"\n                    ),\n                    role_arn="roleArn"\n                ),\n                elasticsearch=iot.CfnTopicRule.ElasticsearchActionProperty(\n                    endpoint="endpoint",\n                    id="id",\n                    index="index",\n                    role_arn="roleArn",\n                    type="type"\n                ),\n                firehose=iot.CfnTopicRule.FirehoseActionProperty(\n                    delivery_stream_name="deliveryStreamName",\n                    role_arn="roleArn",\n\n                    # the properties below are optional\n                    batch_mode=False,\n                    separator="separator"\n                ),\n                http=iot.CfnTopicRule.HttpActionProperty(\n                    url="url",\n\n                    # the properties below are optional\n                    auth=iot.CfnTopicRule.HttpAuthorizationProperty(\n                        sigv4=iot.CfnTopicRule.SigV4AuthorizationProperty(\n                            role_arn="roleArn",\n                            service_name="serviceName",\n                            signing_region="signingRegion"\n                        )\n                    ),\n                    confirmation_url="confirmationUrl",\n                    headers=[iot.CfnTopicRule.HttpActionHeaderProperty(\n                        key="key",\n                        value="value"\n                    )]\n                ),\n                iot_analytics=iot.CfnTopicRule.IotAnalyticsActionProperty(\n                    channel_name="channelName",\n                    role_arn="roleArn",\n\n                    # the properties below are optional\n                    batch_mode=False\n                ),\n                iot_events=iot.CfnTopicRule.IotEventsActionProperty(\n                    input_name="inputName",\n                    role_arn="roleArn",\n\n                    # the properties below are optional\n                    batch_mode=False,\n                    message_id="messageId"\n                ),\n                iot_site_wise=iot.CfnTopicRule.IotSiteWiseActionProperty(\n                    put_asset_property_value_entries=[iot.CfnTopicRule.PutAssetPropertyValueEntryProperty(\n                        property_values=[iot.CfnTopicRule.AssetPropertyValueProperty(\n                            timestamp=iot.CfnTopicRule.AssetPropertyTimestampProperty(\n                                time_in_seconds="timeInSeconds",\n\n                                # the properties below are optional\n                                offset_in_nanos="offsetInNanos"\n                            ),\n                            value=iot.CfnTopicRule.AssetPropertyVariantProperty(\n                                boolean_value="booleanValue",\n                                double_value="doubleValue",\n                                integer_value="integerValue",\n                                string_value="stringValue"\n                            ),\n\n                            # the properties below are optional\n                            quality="quality"\n                        )],\n\n                        # the properties below are optional\n                        asset_id="assetId",\n                        entry_id="entryId",\n                        property_alias="propertyAlias",\n                        property_id="propertyId"\n                    )],\n                    role_arn="roleArn"\n                ),\n                kafka=iot.CfnTopicRule.KafkaActionProperty(\n                    client_properties={\n                        "client_properties_key": "clientProperties"\n                    },\n                    destination_arn="destinationArn",\n                    topic="topic",\n\n                    # the properties below are optional\n                    headers=[iot.CfnTopicRule.KafkaActionHeaderProperty(\n                        key="key",\n                        value="value"\n                    )],\n                    key="key",\n                    partition="partition"\n                ),\n                kinesis=iot.CfnTopicRule.KinesisActionProperty(\n                    role_arn="roleArn",\n                    stream_name="streamName",\n\n                    # the properties below are optional\n                    partition_key="partitionKey"\n                ),\n                lambda_=iot.CfnTopicRule.LambdaActionProperty(\n                    function_arn="functionArn"\n                ),\n                location=iot.CfnTopicRule.LocationActionProperty(\n                    device_id="deviceId",\n                    latitude="latitude",\n                    longitude="longitude",\n                    role_arn="roleArn",\n                    tracker_name="trackerName",\n\n                    # the properties below are optional\n                    timestamp=iot.CfnTopicRule.TimestampProperty(\n                        value="value",\n\n                        # the properties below are optional\n                        unit="unit"\n                    )\n                ),\n                open_search=iot.CfnTopicRule.OpenSearchActionProperty(\n                    endpoint="endpoint",\n                    id="id",\n                    index="index",\n                    role_arn="roleArn",\n                    type="type"\n                ),\n                republish=iot.CfnTopicRule.RepublishActionProperty(\n                    role_arn="roleArn",\n                    topic="topic",\n\n                    # the properties below are optional\n                    headers=iot.CfnTopicRule.RepublishActionHeadersProperty(\n                        content_type="contentType",\n                        correlation_data="correlationData",\n                        message_expiry="messageExpiry",\n                        payload_format_indicator="payloadFormatIndicator",\n                        response_topic="responseTopic",\n                        user_properties=[iot.CfnTopicRule.UserPropertyProperty(\n                            key="key",\n                            value="value"\n                        )]\n                    ),\n                    qos=123\n                ),\n                s3=iot.CfnTopicRule.S3ActionProperty(\n                    bucket_name="bucketName",\n                    key="key",\n                    role_arn="roleArn",\n\n                    # the properties below are optional\n                    canned_acl="cannedAcl"\n                ),\n                sns=iot.CfnTopicRule.SnsActionProperty(\n                    role_arn="roleArn",\n                    target_arn="targetArn",\n\n                    # the properties below are optional\n                    message_format="messageFormat"\n                ),\n                sqs=iot.CfnTopicRule.SqsActionProperty(\n                    queue_url="queueUrl",\n                    role_arn="roleArn",\n\n                    # the properties below are optional\n                    use_base64=False\n                ),\n                step_functions=iot.CfnTopicRule.StepFunctionsActionProperty(\n                    role_arn="roleArn",\n                    state_machine_name="stateMachineName",\n\n                    # the properties below are optional\n                    execution_name_prefix="executionNamePrefix"\n                ),\n                timestream=iot.CfnTopicRule.TimestreamActionProperty(\n                    database_name="databaseName",\n                    dimensions=[iot.CfnTopicRule.TimestreamDimensionProperty(\n                        name="name",\n                        value="value"\n                    )],\n                    role_arn="roleArn",\n                    table_name="tableName",\n\n                    # the properties below are optional\n                    timestamp=iot.CfnTopicRule.TimestreamTimestampProperty(\n                        unit="unit",\n                        value="value"\n                    )\n                )\n            )],\n            sql="sql",\n\n            # the properties below are optional\n            aws_iot_sql_version="awsIotSqlVersion",\n            description="description",\n            error_action=iot.CfnTopicRule.ActionProperty(\n                cloudwatch_alarm=iot.CfnTopicRule.CloudwatchAlarmActionProperty(\n                    alarm_name="alarmName",\n                    role_arn="roleArn",\n                    state_reason="stateReason",\n                    state_value="stateValue"\n                ),\n                cloudwatch_logs=iot.CfnTopicRule.CloudwatchLogsActionProperty(\n                    log_group_name="logGroupName",\n                    role_arn="roleArn",\n\n                    # the properties below are optional\n                    batch_mode=False\n                ),\n                cloudwatch_metric=iot.CfnTopicRule.CloudwatchMetricActionProperty(\n                    metric_name="metricName",\n                    metric_namespace="metricNamespace",\n                    metric_unit="metricUnit",\n                    metric_value="metricValue",\n                    role_arn="roleArn",\n\n                    # the properties below are optional\n                    metric_timestamp="metricTimestamp"\n                ),\n                dynamo_db=iot.CfnTopicRule.DynamoDBActionProperty(\n                    hash_key_field="hashKeyField",\n                    hash_key_value="hashKeyValue",\n                    role_arn="roleArn",\n                    table_name="tableName",\n\n                    # the properties below are optional\n                    hash_key_type="hashKeyType",\n                    payload_field="payloadField",\n                    range_key_field="rangeKeyField",\n                    range_key_type="rangeKeyType",\n                    range_key_value="rangeKeyValue"\n                ),\n                dynamo_dBv2=iot.CfnTopicRule.DynamoDBv2ActionProperty(\n                    put_item=iot.CfnTopicRule.PutItemInputProperty(\n                        table_name="tableName"\n                    ),\n                    role_arn="roleArn"\n                ),\n                elasticsearch=iot.CfnTopicRule.ElasticsearchActionProperty(\n                    endpoint="endpoint",\n                    id="id",\n                    index="index",\n                    role_arn="roleArn",\n                    type="type"\n                ),\n                firehose=iot.CfnTopicRule.FirehoseActionProperty(\n                    delivery_stream_name="deliveryStreamName",\n                    role_arn="roleArn",\n\n                    # the properties below are optional\n                    batch_mode=False,\n                    separator="separator"\n                ),\n                http=iot.CfnTopicRule.HttpActionProperty(\n                    url="url",\n\n                    # the properties below are optional\n                    auth=iot.CfnTopicRule.HttpAuthorizationProperty(\n                        sigv4=iot.CfnTopicRule.SigV4AuthorizationProperty(\n                            role_arn="roleArn",\n                            service_name="serviceName",\n                            signing_region="signingRegion"\n                        )\n                    ),\n                    confirmation_url="confirmationUrl",\n                    headers=[iot.CfnTopicRule.HttpActionHeaderProperty(\n                        key="key",\n                        value="value"\n                    )]\n                ),\n                iot_analytics=iot.CfnTopicRule.IotAnalyticsActionProperty(\n                    channel_name="channelName",\n                    role_arn="roleArn",\n\n                    # the properties below are optional\n                    batch_mode=False\n                ),\n                iot_events=iot.CfnTopicRule.IotEventsActionProperty(\n                    input_name="inputName",\n                    role_arn="roleArn",\n\n                    # the properties below are optional\n                    batch_mode=False,\n                    message_id="messageId"\n                ),\n                iot_site_wise=iot.CfnTopicRule.IotSiteWiseActionProperty(\n                    put_asset_property_value_entries=[iot.CfnTopicRule.PutAssetPropertyValueEntryProperty(\n                        property_values=[iot.CfnTopicRule.AssetPropertyValueProperty(\n                            timestamp=iot.CfnTopicRule.AssetPropertyTimestampProperty(\n                                time_in_seconds="timeInSeconds",\n\n                                # the properties below are optional\n                                offset_in_nanos="offsetInNanos"\n                            ),\n                            value=iot.CfnTopicRule.AssetPropertyVariantProperty(\n                                boolean_value="booleanValue",\n                                double_value="doubleValue",\n                                integer_value="integerValue",\n                                string_value="stringValue"\n                            ),\n\n                            # the properties below are optional\n                            quality="quality"\n                        )],\n\n                        # the properties below are optional\n                        asset_id="assetId",\n                        entry_id="entryId",\n                        property_alias="propertyAlias",\n                        property_id="propertyId"\n                    )],\n                    role_arn="roleArn"\n                ),\n                kafka=iot.CfnTopicRule.KafkaActionProperty(\n                    client_properties={\n                        "client_properties_key": "clientProperties"\n                    },\n                    destination_arn="destinationArn",\n                    topic="topic",\n\n                    # the properties below are optional\n                    headers=[iot.CfnTopicRule.KafkaActionHeaderProperty(\n                        key="key",\n                        value="value"\n                    )],\n                    key="key",\n                    partition="partition"\n                ),\n                kinesis=iot.CfnTopicRule.KinesisActionProperty(\n                    role_arn="roleArn",\n                    stream_name="streamName",\n\n                    # the properties below are optional\n                    partition_key="partitionKey"\n                ),\n                lambda_=iot.CfnTopicRule.LambdaActionProperty(\n                    function_arn="functionArn"\n                ),\n                location=iot.CfnTopicRule.LocationActionProperty(\n                    device_id="deviceId",\n                    latitude="latitude",\n                    longitude="longitude",\n                    role_arn="roleArn",\n                    tracker_name="trackerName",\n\n                    # the properties below are optional\n                    timestamp=iot.CfnTopicRule.TimestampProperty(\n                        value="value",\n\n                        # the properties below are optional\n                        unit="unit"\n                    )\n                ),\n                open_search=iot.CfnTopicRule.OpenSearchActionProperty(\n                    endpoint="endpoint",\n                    id="id",\n                    index="index",\n                    role_arn="roleArn",\n                    type="type"\n                ),\n                republish=iot.CfnTopicRule.RepublishActionProperty(\n                    role_arn="roleArn",\n                    topic="topic",\n\n                    # the properties below are optional\n                    headers=iot.CfnTopicRule.RepublishActionHeadersProperty(\n                        content_type="contentType",\n                        correlation_data="correlationData",\n                        message_expiry="messageExpiry",\n                        payload_format_indicator="payloadFormatIndicator",\n                        response_topic="responseTopic",\n                        user_properties=[iot.CfnTopicRule.UserPropertyProperty(\n                            key="key",\n                            value="value"\n                        )]\n                    ),\n                    qos=123\n                ),\n                s3=iot.CfnTopicRule.S3ActionProperty(\n                    bucket_name="bucketName",\n                    key="key",\n                    role_arn="roleArn",\n\n                    # the properties below are optional\n                    canned_acl="cannedAcl"\n                ),\n                sns=iot.CfnTopicRule.SnsActionProperty(\n                    role_arn="roleArn",\n                    target_arn="targetArn",\n\n                    # the properties below are optional\n                    message_format="messageFormat"\n                ),\n                sqs=iot.CfnTopicRule.SqsActionProperty(\n                    queue_url="queueUrl",\n                    role_arn="roleArn",\n\n                    # the properties below are optional\n                    use_base64=False\n                ),\n                step_functions=iot.CfnTopicRule.StepFunctionsActionProperty(\n                    role_arn="roleArn",\n                    state_machine_name="stateMachineName",\n\n                    # the properties below are optional\n                    execution_name_prefix="executionNamePrefix"\n                ),\n                timestream=iot.CfnTopicRule.TimestreamActionProperty(\n                    database_name="databaseName",\n                    dimensions=[iot.CfnTopicRule.TimestreamDimensionProperty(\n                        name="name",\n                        value="value"\n                    )],\n                    role_arn="roleArn",\n                    table_name="tableName",\n\n                    # the properties below are optional\n                    timestamp=iot.CfnTopicRule.TimestreamTimestampProperty(\n                        unit="unit",\n                        value="value"\n                    )\n                )\n            ),\n            rule_disabled=False\n        ),\n\n        # the properties below are optional\n        rule_name="ruleName",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['topic_rule_payload', 'rule_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iot.CfnTopicRuleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    CfnAccountAuditConfiguration_AuditCheckConfigurationProperty: typing.Optional[dict[str, CfnAccountAuditConfiguration_AuditCheckConfigurationPropertyDef]] = pydantic.Field(None)
    CfnAccountAuditConfiguration_AuditCheckConfigurationsProperty: typing.Optional[dict[str, CfnAccountAuditConfiguration_AuditCheckConfigurationsPropertyDef]] = pydantic.Field(None)
    CfnAccountAuditConfiguration_AuditNotificationTargetConfigurationsProperty: typing.Optional[dict[str, CfnAccountAuditConfiguration_AuditNotificationTargetConfigurationsPropertyDef]] = pydantic.Field(None)
    CfnAccountAuditConfiguration_AuditNotificationTargetProperty: typing.Optional[dict[str, CfnAccountAuditConfiguration_AuditNotificationTargetPropertyDef]] = pydantic.Field(None)
    CfnBillingGroup_BillingGroupPropertiesProperty: typing.Optional[dict[str, CfnBillingGroup_BillingGroupPropertiesPropertyDef]] = pydantic.Field(None)
    CfnCACertificate_RegistrationConfigProperty: typing.Optional[dict[str, CfnCACertificate_RegistrationConfigPropertyDef]] = pydantic.Field(None)
    CfnDomainConfiguration_AuthorizerConfigProperty: typing.Optional[dict[str, CfnDomainConfiguration_AuthorizerConfigPropertyDef]] = pydantic.Field(None)
    CfnDomainConfiguration_ServerCertificateSummaryProperty: typing.Optional[dict[str, CfnDomainConfiguration_ServerCertificateSummaryPropertyDef]] = pydantic.Field(None)
    CfnDomainConfiguration_TlsConfigProperty: typing.Optional[dict[str, CfnDomainConfiguration_TlsConfigPropertyDef]] = pydantic.Field(None)
    CfnFleetMetric_AggregationTypeProperty: typing.Optional[dict[str, CfnFleetMetric_AggregationTypePropertyDef]] = pydantic.Field(None)
    CfnJobTemplate_AbortConfigProperty: typing.Optional[dict[str, CfnJobTemplate_AbortConfigPropertyDef]] = pydantic.Field(None)
    CfnJobTemplate_AbortCriteriaProperty: typing.Optional[dict[str, CfnJobTemplate_AbortCriteriaPropertyDef]] = pydantic.Field(None)
    CfnJobTemplate_ExponentialRolloutRateProperty: typing.Optional[dict[str, CfnJobTemplate_ExponentialRolloutRatePropertyDef]] = pydantic.Field(None)
    CfnJobTemplate_JobExecutionsRetryConfigProperty: typing.Optional[dict[str, CfnJobTemplate_JobExecutionsRetryConfigPropertyDef]] = pydantic.Field(None)
    CfnJobTemplate_JobExecutionsRolloutConfigProperty: typing.Optional[dict[str, CfnJobTemplate_JobExecutionsRolloutConfigPropertyDef]] = pydantic.Field(None)
    CfnJobTemplate_MaintenanceWindowProperty: typing.Optional[dict[str, CfnJobTemplate_MaintenanceWindowPropertyDef]] = pydantic.Field(None)
    CfnJobTemplate_PresignedUrlConfigProperty: typing.Optional[dict[str, CfnJobTemplate_PresignedUrlConfigPropertyDef]] = pydantic.Field(None)
    CfnJobTemplate_RateIncreaseCriteriaProperty: typing.Optional[dict[str, CfnJobTemplate_RateIncreaseCriteriaPropertyDef]] = pydantic.Field(None)
    CfnJobTemplate_RetryCriteriaProperty: typing.Optional[dict[str, CfnJobTemplate_RetryCriteriaPropertyDef]] = pydantic.Field(None)
    CfnJobTemplate_TimeoutConfigProperty: typing.Optional[dict[str, CfnJobTemplate_TimeoutConfigPropertyDef]] = pydantic.Field(None)
    CfnMitigationAction_ActionParamsProperty: typing.Optional[dict[str, CfnMitigationAction_ActionParamsPropertyDef]] = pydantic.Field(None)
    CfnMitigationAction_AddThingsToThingGroupParamsProperty: typing.Optional[dict[str, CfnMitigationAction_AddThingsToThingGroupParamsPropertyDef]] = pydantic.Field(None)
    CfnMitigationAction_EnableIoTLoggingParamsProperty: typing.Optional[dict[str, CfnMitigationAction_EnableIoTLoggingParamsPropertyDef]] = pydantic.Field(None)
    CfnMitigationAction_PublishFindingToSnsParamsProperty: typing.Optional[dict[str, CfnMitigationAction_PublishFindingToSnsParamsPropertyDef]] = pydantic.Field(None)
    CfnMitigationAction_ReplaceDefaultPolicyVersionParamsProperty: typing.Optional[dict[str, CfnMitigationAction_ReplaceDefaultPolicyVersionParamsPropertyDef]] = pydantic.Field(None)
    CfnMitigationAction_UpdateCACertificateParamsProperty: typing.Optional[dict[str, CfnMitigationAction_UpdateCACertificateParamsPropertyDef]] = pydantic.Field(None)
    CfnMitigationAction_UpdateDeviceCertificateParamsProperty: typing.Optional[dict[str, CfnMitigationAction_UpdateDeviceCertificateParamsPropertyDef]] = pydantic.Field(None)
    CfnProvisioningTemplate_ProvisioningHookProperty: typing.Optional[dict[str, CfnProvisioningTemplate_ProvisioningHookPropertyDef]] = pydantic.Field(None)
    CfnSecurityProfile_AlertTargetProperty: typing.Optional[dict[str, CfnSecurityProfile_AlertTargetPropertyDef]] = pydantic.Field(None)
    CfnSecurityProfile_BehaviorCriteriaProperty: typing.Optional[dict[str, CfnSecurityProfile_BehaviorCriteriaPropertyDef]] = pydantic.Field(None)
    CfnSecurityProfile_BehaviorProperty: typing.Optional[dict[str, CfnSecurityProfile_BehaviorPropertyDef]] = pydantic.Field(None)
    CfnSecurityProfile_MachineLearningDetectionConfigProperty: typing.Optional[dict[str, CfnSecurityProfile_MachineLearningDetectionConfigPropertyDef]] = pydantic.Field(None)
    CfnSecurityProfile_MetricDimensionProperty: typing.Optional[dict[str, CfnSecurityProfile_MetricDimensionPropertyDef]] = pydantic.Field(None)
    CfnSecurityProfile_MetricToRetainProperty: typing.Optional[dict[str, CfnSecurityProfile_MetricToRetainPropertyDef]] = pydantic.Field(None)
    CfnSecurityProfile_MetricValueProperty: typing.Optional[dict[str, CfnSecurityProfile_MetricValuePropertyDef]] = pydantic.Field(None)
    CfnSecurityProfile_StatisticalThresholdProperty: typing.Optional[dict[str, CfnSecurityProfile_StatisticalThresholdPropertyDef]] = pydantic.Field(None)
    CfnThing_AttributePayloadProperty: typing.Optional[dict[str, CfnThing_AttributePayloadPropertyDef]] = pydantic.Field(None)
    CfnThingGroup_AttributePayloadProperty: typing.Optional[dict[str, CfnThingGroup_AttributePayloadPropertyDef]] = pydantic.Field(None)
    CfnThingGroup_ThingGroupPropertiesProperty: typing.Optional[dict[str, CfnThingGroup_ThingGroupPropertiesPropertyDef]] = pydantic.Field(None)
    CfnThingType_ThingTypePropertiesProperty: typing.Optional[dict[str, CfnThingType_ThingTypePropertiesPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_ActionProperty: typing.Optional[dict[str, CfnTopicRule_ActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_AssetPropertyTimestampProperty: typing.Optional[dict[str, CfnTopicRule_AssetPropertyTimestampPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_AssetPropertyValueProperty: typing.Optional[dict[str, CfnTopicRule_AssetPropertyValuePropertyDef]] = pydantic.Field(None)
    CfnTopicRule_AssetPropertyVariantProperty: typing.Optional[dict[str, CfnTopicRule_AssetPropertyVariantPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_CloudwatchAlarmActionProperty: typing.Optional[dict[str, CfnTopicRule_CloudwatchAlarmActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_CloudwatchLogsActionProperty: typing.Optional[dict[str, CfnTopicRule_CloudwatchLogsActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_CloudwatchMetricActionProperty: typing.Optional[dict[str, CfnTopicRule_CloudwatchMetricActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_DynamoDBActionProperty: typing.Optional[dict[str, CfnTopicRule_DynamoDBActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_DynamoDBv2ActionProperty: typing.Optional[dict[str, CfnTopicRule_DynamoDBv2ActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_ElasticsearchActionProperty: typing.Optional[dict[str, CfnTopicRule_ElasticsearchActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_FirehoseActionProperty: typing.Optional[dict[str, CfnTopicRule_FirehoseActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_HttpActionHeaderProperty: typing.Optional[dict[str, CfnTopicRule_HttpActionHeaderPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_HttpActionProperty: typing.Optional[dict[str, CfnTopicRule_HttpActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_HttpAuthorizationProperty: typing.Optional[dict[str, CfnTopicRule_HttpAuthorizationPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_IotAnalyticsActionProperty: typing.Optional[dict[str, CfnTopicRule_IotAnalyticsActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_IotEventsActionProperty: typing.Optional[dict[str, CfnTopicRule_IotEventsActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_IotSiteWiseActionProperty: typing.Optional[dict[str, CfnTopicRule_IotSiteWiseActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_KafkaActionHeaderProperty: typing.Optional[dict[str, CfnTopicRule_KafkaActionHeaderPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_KafkaActionProperty: typing.Optional[dict[str, CfnTopicRule_KafkaActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_KinesisActionProperty: typing.Optional[dict[str, CfnTopicRule_KinesisActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_LambdaActionProperty: typing.Optional[dict[str, CfnTopicRule_LambdaActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_LocationActionProperty: typing.Optional[dict[str, CfnTopicRule_LocationActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_OpenSearchActionProperty: typing.Optional[dict[str, CfnTopicRule_OpenSearchActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_PutAssetPropertyValueEntryProperty: typing.Optional[dict[str, CfnTopicRule_PutAssetPropertyValueEntryPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_PutItemInputProperty: typing.Optional[dict[str, CfnTopicRule_PutItemInputPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_RepublishActionHeadersProperty: typing.Optional[dict[str, CfnTopicRule_RepublishActionHeadersPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_RepublishActionProperty: typing.Optional[dict[str, CfnTopicRule_RepublishActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_S3ActionProperty: typing.Optional[dict[str, CfnTopicRule_S3ActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_SigV4AuthorizationProperty: typing.Optional[dict[str, CfnTopicRule_SigV4AuthorizationPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_SnsActionProperty: typing.Optional[dict[str, CfnTopicRule_SnsActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_SqsActionProperty: typing.Optional[dict[str, CfnTopicRule_SqsActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_StepFunctionsActionProperty: typing.Optional[dict[str, CfnTopicRule_StepFunctionsActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_TimestampProperty: typing.Optional[dict[str, CfnTopicRule_TimestampPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_TimestreamActionProperty: typing.Optional[dict[str, CfnTopicRule_TimestreamActionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_TimestreamDimensionProperty: typing.Optional[dict[str, CfnTopicRule_TimestreamDimensionPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_TimestreamTimestampProperty: typing.Optional[dict[str, CfnTopicRule_TimestreamTimestampPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_TopicRulePayloadProperty: typing.Optional[dict[str, CfnTopicRule_TopicRulePayloadPropertyDef]] = pydantic.Field(None)
    CfnTopicRule_UserPropertyProperty: typing.Optional[dict[str, CfnTopicRule_UserPropertyPropertyDef]] = pydantic.Field(None)
    CfnTopicRuleDestination_HttpUrlDestinationSummaryProperty: typing.Optional[dict[str, CfnTopicRuleDestination_HttpUrlDestinationSummaryPropertyDef]] = pydantic.Field(None)
    CfnTopicRuleDestination_VpcDestinationPropertiesProperty: typing.Optional[dict[str, CfnTopicRuleDestination_VpcDestinationPropertiesPropertyDef]] = pydantic.Field(None)
    CfnAccountAuditConfiguration: typing.Optional[dict[str, CfnAccountAuditConfigurationDef]] = pydantic.Field(None)
    CfnAuthorizer: typing.Optional[dict[str, CfnAuthorizerDef]] = pydantic.Field(None)
    CfnBillingGroup: typing.Optional[dict[str, CfnBillingGroupDef]] = pydantic.Field(None)
    CfnCACertificate: typing.Optional[dict[str, CfnCACertificateDef]] = pydantic.Field(None)
    CfnCertificate: typing.Optional[dict[str, CfnCertificateDef]] = pydantic.Field(None)
    CfnCustomMetric: typing.Optional[dict[str, CfnCustomMetricDef]] = pydantic.Field(None)
    CfnDimension: typing.Optional[dict[str, CfnDimensionDef]] = pydantic.Field(None)
    CfnDomainConfiguration: typing.Optional[dict[str, CfnDomainConfigurationDef]] = pydantic.Field(None)
    CfnFleetMetric: typing.Optional[dict[str, CfnFleetMetricDef]] = pydantic.Field(None)
    CfnJobTemplate: typing.Optional[dict[str, CfnJobTemplateDef]] = pydantic.Field(None)
    CfnLogging: typing.Optional[dict[str, CfnLoggingDef]] = pydantic.Field(None)
    CfnMitigationAction: typing.Optional[dict[str, CfnMitigationActionDef]] = pydantic.Field(None)
    CfnPolicy: typing.Optional[dict[str, CfnPolicyDef]] = pydantic.Field(None)
    CfnPolicyPrincipalAttachment: typing.Optional[dict[str, CfnPolicyPrincipalAttachmentDef]] = pydantic.Field(None)
    CfnProvisioningTemplate: typing.Optional[dict[str, CfnProvisioningTemplateDef]] = pydantic.Field(None)
    CfnResourceSpecificLogging: typing.Optional[dict[str, CfnResourceSpecificLoggingDef]] = pydantic.Field(None)
    CfnRoleAlias: typing.Optional[dict[str, CfnRoleAliasDef]] = pydantic.Field(None)
    CfnScheduledAudit: typing.Optional[dict[str, CfnScheduledAuditDef]] = pydantic.Field(None)
    CfnSecurityProfile: typing.Optional[dict[str, CfnSecurityProfileDef]] = pydantic.Field(None)
    CfnSoftwarePackage: typing.Optional[dict[str, CfnSoftwarePackageDef]] = pydantic.Field(None)
    CfnSoftwarePackageVersion: typing.Optional[dict[str, CfnSoftwarePackageVersionDef]] = pydantic.Field(None)
    CfnThing: typing.Optional[dict[str, CfnThingDef]] = pydantic.Field(None)
    CfnThingGroup: typing.Optional[dict[str, CfnThingGroupDef]] = pydantic.Field(None)
    CfnThingPrincipalAttachment: typing.Optional[dict[str, CfnThingPrincipalAttachmentDef]] = pydantic.Field(None)
    CfnThingType: typing.Optional[dict[str, CfnThingTypeDef]] = pydantic.Field(None)
    CfnTopicRule: typing.Optional[dict[str, CfnTopicRuleDef]] = pydantic.Field(None)
    CfnTopicRuleDestination: typing.Optional[dict[str, CfnTopicRuleDestinationDef]] = pydantic.Field(None)
    CfnAccountAuditConfigurationProps: typing.Optional[dict[str, CfnAccountAuditConfigurationPropsDef]] = pydantic.Field(None)
    CfnAuthorizerProps: typing.Optional[dict[str, CfnAuthorizerPropsDef]] = pydantic.Field(None)
    CfnBillingGroupProps: typing.Optional[dict[str, CfnBillingGroupPropsDef]] = pydantic.Field(None)
    CfnCACertificateProps: typing.Optional[dict[str, CfnCACertificatePropsDef]] = pydantic.Field(None)
    CfnCertificateProps: typing.Optional[dict[str, CfnCertificatePropsDef]] = pydantic.Field(None)
    CfnCustomMetricProps: typing.Optional[dict[str, CfnCustomMetricPropsDef]] = pydantic.Field(None)
    CfnDimensionProps: typing.Optional[dict[str, CfnDimensionPropsDef]] = pydantic.Field(None)
    CfnDomainConfigurationProps: typing.Optional[dict[str, CfnDomainConfigurationPropsDef]] = pydantic.Field(None)
    CfnFleetMetricProps: typing.Optional[dict[str, CfnFleetMetricPropsDef]] = pydantic.Field(None)
    CfnJobTemplateProps: typing.Optional[dict[str, CfnJobTemplatePropsDef]] = pydantic.Field(None)
    CfnLoggingProps: typing.Optional[dict[str, CfnLoggingPropsDef]] = pydantic.Field(None)
    CfnMitigationActionProps: typing.Optional[dict[str, CfnMitigationActionPropsDef]] = pydantic.Field(None)
    CfnPolicyPrincipalAttachmentProps: typing.Optional[dict[str, CfnPolicyPrincipalAttachmentPropsDef]] = pydantic.Field(None)
    CfnPolicyProps: typing.Optional[dict[str, CfnPolicyPropsDef]] = pydantic.Field(None)
    CfnProvisioningTemplateProps: typing.Optional[dict[str, CfnProvisioningTemplatePropsDef]] = pydantic.Field(None)
    CfnResourceSpecificLoggingProps: typing.Optional[dict[str, CfnResourceSpecificLoggingPropsDef]] = pydantic.Field(None)
    CfnRoleAliasProps: typing.Optional[dict[str, CfnRoleAliasPropsDef]] = pydantic.Field(None)
    CfnScheduledAuditProps: typing.Optional[dict[str, CfnScheduledAuditPropsDef]] = pydantic.Field(None)
    CfnSecurityProfileProps: typing.Optional[dict[str, CfnSecurityProfilePropsDef]] = pydantic.Field(None)
    CfnSoftwarePackageProps: typing.Optional[dict[str, CfnSoftwarePackagePropsDef]] = pydantic.Field(None)
    CfnSoftwarePackageVersionProps: typing.Optional[dict[str, CfnSoftwarePackageVersionPropsDef]] = pydantic.Field(None)
    CfnThingGroupProps: typing.Optional[dict[str, CfnThingGroupPropsDef]] = pydantic.Field(None)
    CfnThingPrincipalAttachmentProps: typing.Optional[dict[str, CfnThingPrincipalAttachmentPropsDef]] = pydantic.Field(None)
    CfnThingProps: typing.Optional[dict[str, CfnThingPropsDef]] = pydantic.Field(None)
    CfnThingTypeProps: typing.Optional[dict[str, CfnThingTypePropsDef]] = pydantic.Field(None)
    CfnTopicRuleDestinationProps: typing.Optional[dict[str, CfnTopicRuleDestinationPropsDef]] = pydantic.Field(None)
    CfnTopicRuleProps: typing.Optional[dict[str, CfnTopicRulePropsDef]] = pydantic.Field(None)
    ...
