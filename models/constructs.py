from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from constructs.Construct
class ConstructDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'constructs.Construct'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from constructs.Dependable
class DependableDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['get', 'implement', 'of']
    _cdk_class_fqn: typing.ClassVar[str] = 'constructs.Dependable'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[DependableDefConfig] = pydantic.Field(None)


class DependableDefConfig(pydantic.BaseModel):
    get: typing.Optional[list[DependableDefGetParams]] = pydantic.Field(None, description='(deprecated) Return the matching Dependable for the given class instance.')
    implement: typing.Optional[list[DependableDefImplementParams]] = pydantic.Field(None, description='(experimental) Turn any object into an IDependable.')
    of: typing.Optional[list[DependableDefOfParams]] = pydantic.Field(None, description='(experimental) Return the matching Dependable for the given class instance.')

class DependableDefGetParams(pydantic.BaseModel):
    instance: models.UnsupportedResource = pydantic.Field(..., description='-\n\n:deprecated: use ``of``\n\n:stability: deprecated\n')
    ...

class DependableDefImplementParams(pydantic.BaseModel):
    instance: models.UnsupportedResource = pydantic.Field(..., description='-\n')
    trait: models.constructs.DependableDef = pydantic.Field(..., description='-\n\n:stability: experimental\n')
    ...

class DependableDefOfParams(pydantic.BaseModel):
    instance: models.UnsupportedResource = pydantic.Field(..., description='-\n\n:stability: experimental\n')
    ...


#  autogenerated from constructs.DependencyGroup
class DependencyGroupDef(BaseClass):
    deps: list[models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM)
    _init_params: typing.ClassVar[list[str]] = ['deps']
    _method_names: typing.ClassVar[list[str]] = ['add']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'constructs.DependencyGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[DependencyGroupDefConfig] = pydantic.Field(None)


class DependencyGroupDefConfig(pydantic.BaseModel):
    add: typing.Optional[list[DependencyGroupDefAddParams]] = pydantic.Field(None, description='(experimental) Add a construct to the dependency roots.')

class DependencyGroupDefAddParams(pydantic.BaseModel):
    scopes: list[models.UnsupportedResource] = pydantic.Field(...)
    ...


#  autogenerated from constructs.Node
class NodeDef(BaseClass):
    host: typing.Union[models.constructs.ConstructDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='-')
    _init_params: typing.ClassVar[list[str]] = ['host']
    _method_names: typing.ClassVar[list[str]] = ['add_dependency', 'add_metadata', 'add_validation', 'find_all', 'find_child', 'get_context', 'lock', 'set_context', 'try_find_child', 'try_get_context', 'try_remove_child', 'validate']
    _classmethod_names: typing.ClassVar[list[str]] = ['of']
    _cdk_class_fqn: typing.ClassVar[str] = 'constructs.Node'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[NodeDefConfig] = pydantic.Field(None)


class NodeDefConfig(pydantic.BaseModel):
    add_dependency: typing.Optional[list[NodeDefAddDependencyParams]] = pydantic.Field(None, description='Add an ordering dependency on another construct.\nAn ``IDependable``')
    add_metadata: typing.Optional[list[NodeDefAddMetadataParams]] = pydantic.Field(None, description='Adds a metadata entry to this construct.\nEntries are arbitrary values and will also include a stack trace to allow tracing back to\nthe code location for when the entry was added. It can be used, for example, to include source\nmapping in CloudFormation templates to improve diagnostics.')
    add_validation: typing.Optional[list[NodeDefAddValidationParams]] = pydantic.Field(None, description='Adds a validation to this construct.\nWhen ``node.validate()`` is called, the ``validate()`` method will be called on\nall validations and all errors will be returned.')
    find_all: typing.Optional[list[NodeDefFindAllParams]] = pydantic.Field(None, description='Return this construct and all of its children in the given order.')
    find_child: typing.Optional[list[NodeDefFindChildParams]] = pydantic.Field(None, description='Return a direct child by id.\nThrows an error if the child is not found.')
    get_context: typing.Optional[list[NodeDefGetContextParams]] = pydantic.Field(None, description='Retrieves a value from tree context if present. Otherwise, would throw an error.\nContext is usually initialized at the root, but can be overridden at any point in the tree.')
    lock: typing.Optional[bool] = pydantic.Field(None, description='Locks this construct from allowing more children to be added.\nAfter this\ncall, no more children can be added to this construct or to any children.')
    of: typing.Optional[list[NodeDefOfParams]] = pydantic.Field(None, description='(deprecated) Returns the node associated with a construct.')
    set_context: typing.Optional[list[NodeDefSetContextParams]] = pydantic.Field(None, description='This can be used to set contextual values.\nContext must be set before any children are added, since children may consult context info during construction.\nIf the key already exists, it will be overridden.')
    try_find_child: typing.Optional[list[NodeDefTryFindChildParams]] = pydantic.Field(None, description='Return a direct child by id, or undefined.')
    try_get_context: typing.Optional[list[NodeDefTryGetContextParams]] = pydantic.Field(None, description='Retrieves a value from tree context.\nContext is usually initialized at the root, but can be overridden at any point in the tree.')
    try_remove_child: typing.Optional[list[NodeDefTryRemoveChildParams]] = pydantic.Field(None, description='(experimental) Remove the child with the given name, if present.')
    validate_: typing.Optional[bool] = pydantic.Field(None, description='Validates this construct.\nInvokes the ``validate()`` method on all validations added through\n``addValidation()``.\n\n:return:\n\nan array of validation error messages associated with this\nconstruct.', alias='validate')

class NodeDefAddDependencyParams(pydantic.BaseModel):
    deps: list[models.UnsupportedResource] = pydantic.Field(...)
    ...

class NodeDefAddMetadataParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='a string denoting the type of metadata.\n')
    data: typing.Any = pydantic.Field(..., description='the value of the metadata (can be a Token). If null/undefined, metadata will not be added.\n')
    stack_trace: typing.Optional[bool] = pydantic.Field(None, description='Include stack trace with metadata entry. Default: false\n')
    trace_from_function: typing.Any = pydantic.Field(None, description='A JavaScript function to begin tracing from. This option is ignored unless ``stackTrace`` is ``true``. Default: addMetadata()')
    ...

class NodeDefAddValidationParams(pydantic.BaseModel):
    validation: models.UnsupportedResource = pydantic.Field(..., description='The validation object.')
    ...

class NodeDefFindAllParams(pydantic.BaseModel):
    order: typing.Optional[constructs.ConstructOrder] = pydantic.Field(None, description='-')
    ...

class NodeDefFindChildParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='Identifier of direct child.\n')
    ...

class NodeDefGetContextParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='The context key.\n')
    ...

class NodeDefOfParams(pydantic.BaseModel):
    construct_: models.AnyResource = pydantic.Field(..., description='the construct.\n\n:deprecated: use ``construct.node`` instead\n\n:stability: deprecated\n', alias='construct')
    ...

class NodeDefSetContextParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='The context key.\n')
    value: typing.Any = pydantic.Field(..., description='The context value.')
    ...

class NodeDefTryFindChildParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='Identifier of direct child.\n')
    ...

class NodeDefTryGetContextParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='The context key.\n')
    ...

class NodeDefTryRemoveChildParams(pydantic.BaseModel):
    child_name: str = pydantic.Field(..., description='-\n')
    ...


#  autogenerated from constructs.MetadataEntry
class MetadataEntryDef(BaseStruct):
    data: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The data.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The metadata entry type.\n')
    trace: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Stack trace at the point of adding the metadata. Only available if ``addMetadata()`` is called with ``stackTrace: true``. Default: - no trace information')
    _init_params: typing.ClassVar[list[str]] = ['data', 'type', 'trace']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'constructs.MetadataEntry'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from constructs.MetadataOptions
class MetadataOptionsDef(BaseStruct):
    stack_trace: typing.Optional[bool] = pydantic.Field(None, description='Include stack trace with metadata entry. Default: false\n')
    trace_from_function: typing.Any = pydantic.Field(None, description='A JavaScript function to begin tracing from. This option is ignored unless ``stackTrace`` is ``true``. Default: addMetadata()')
    _init_params: typing.ClassVar[list[str]] = ['stack_trace', 'trace_from_function']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'constructs.MetadataOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from constructs.ConstructOrder
# skipping emum

#  autogenerated from constructs.IConstruct
#  skipping Interface

#  autogenerated from constructs.IDependable
#  skipping Interface

#  autogenerated from constructs.IValidation
#  skipping Interface

import models

class ModuleModel(pydantic.BaseModel):
    Construct: typing.Optional[dict[str, ConstructDef]] = pydantic.Field(None)
    Dependable: typing.Optional[dict[str, DependableDef]] = pydantic.Field(None)
    DependencyGroup: typing.Optional[dict[str, DependencyGroupDef]] = pydantic.Field(None)
    Node: typing.Optional[dict[str, NodeDef]] = pydantic.Field(None)
    MetadataEntry: typing.Optional[dict[str, MetadataEntryDef]] = pydantic.Field(None)
    MetadataOptions: typing.Optional[dict[str, MetadataOptionsDef]] = pydantic.Field(None)
    ...
