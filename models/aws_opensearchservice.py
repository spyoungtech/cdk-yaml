from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_opensearchservice.EngineVersion
class EngineVersionDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['elasticsearch', 'open_search']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.EngineVersion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_opensearchservice.EngineVersionDefConfig] = pydantic.Field(None)


class EngineVersionDefConfig(pydantic.BaseModel):
    elasticsearch: typing.Optional[list[models.aws_opensearchservice.EngineVersionDefElasticsearchParams]] = pydantic.Field(None, description='Custom ElasticSearch version.')
    open_search: typing.Optional[list[models.aws_opensearchservice.EngineVersionDefOpenSearchParams]] = pydantic.Field(None, description='Custom OpenSearch version.')

class EngineVersionDefElasticsearchParams(pydantic.BaseModel):
    version: str = pydantic.Field(..., description='custom version number.')
    return_config: typing.Optional[list[models.aws_opensearchservice.EngineVersionDefConfig]] = pydantic.Field(None)
    ...

class EngineVersionDefOpenSearchParams(pydantic.BaseModel):
    version: str = pydantic.Field(..., description='custom version number.')
    return_config: typing.Optional[list[models.aws_opensearchservice.EngineVersionDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_opensearchservice.Domain
class DomainDef(BaseConstruct, ConnectableMixin):
    version: typing.Union[models.aws_opensearchservice.EngineVersionDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Elasticsearch/OpenSearch version that your domain will leverage.\n')
    access_policies: typing.Optional[typing.Sequence[models.aws_iam.PolicyStatementDef]] = pydantic.Field(None, description='Domain access policies. Default: - No access policies.\n')
    advanced_options: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Additional options to specify for the Amazon OpenSearch Service domain. Default: - no advanced options are specified\n')
    automated_snapshot_start_hour: typing.Union[int, float, None] = pydantic.Field(None, description='The hour in UTC during which the service takes an automated daily snapshot of the indices in the Amazon OpenSearch Service domain. Only applies for Elasticsearch versions below 5.3. Default: - Hourly automated snapshots not used\n')
    capacity: typing.Union[models.aws_opensearchservice.CapacityConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The cluster capacity configuration for the Amazon OpenSearch Service domain. Default: - 1 r5.large.search data node; no dedicated master nodes.\n')
    cognito_dashboards_auth: typing.Union[models.aws_opensearchservice.CognitoOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configures Amazon OpenSearch Service to use Amazon Cognito authentication for OpenSearch Dashboards. Default: - Cognito not used for authentication to OpenSearch Dashboards.\n')
    custom_endpoint: typing.Union[models.aws_opensearchservice.CustomEndpointOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='To configure a custom domain configure these options. If you specify a Route53 hosted zone it will create a CNAME record and use DNS validation for the certificate Default: - no custom domain endpoint will be configured\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='Enforces a particular physical domain name. Default: - A name will be auto-generated.\n')
    ebs: typing.Union[models.aws_opensearchservice.EbsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configurations of Amazon Elastic Block Store (Amazon EBS) volumes that are attached to data nodes in the Amazon OpenSearch Service domain. Default: - 10 GiB General Purpose (SSD) volumes per node.\n')
    enable_auto_software_update: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether automatic service software updates are enabled for the domain. Default: - false\n')
    enable_version_upgrade: typing.Optional[bool] = pydantic.Field(None, description='To upgrade an Amazon OpenSearch Service domain to a new version, rather than replacing the entire domain resource, use the EnableVersionUpgrade update policy. Default: - false\n')
    encryption_at_rest: typing.Union[models.aws_opensearchservice.EncryptionAtRestOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Encryption at rest options for the cluster. Default: - No encryption at rest\n')
    enforce_https: typing.Optional[bool] = pydantic.Field(None, description='True to require that all traffic to the domain arrive over HTTPS. Default: - false\n')
    fine_grained_access_control: typing.Union[models.aws_opensearchservice.AdvancedSecurityOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies options for fine-grained access control. Requires Elasticsearch version 6.7 or later or OpenSearch version 1.0 or later. Enabling fine-grained access control also requires encryption of data at rest and node-to-node encryption, along with enforced HTTPS. Default: - fine-grained access control is disabled\n')
    logging: typing.Union[models.aws_opensearchservice.LoggingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configuration log publishing configuration options. Default: - No logs are published\n')
    node_to_node_encryption: typing.Optional[bool] = pydantic.Field(None, description='Specify true to enable node to node encryption. Requires Elasticsearch version 6.0 or later or OpenSearch version 1.0 or later. Default: - Node to node encryption is not enabled.\n')
    off_peak_window_enabled: typing.Optional[bool] = pydantic.Field(None, description="Options for enabling a domain's off-peak window, during which OpenSearch Service can perform mandatory configuration changes on the domain. Off-peak windows were introduced on February 16, 2023. All domains created before this date have the off-peak window disabled by default. You must manually enable and configure the off-peak window for these domains. All domains created after this date will have the off-peak window enabled by default. You can't disable the off-peak window for a domain after it's enabled. Default: - Disabled for domains created before February 16, 2023. Enabled for domains created after. Enabled if ``offPeakWindowStart`` is set.\n")
    off_peak_window_start: typing.Union[models.aws_opensearchservice.WindowStartTimeDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Start time for the off-peak window, in Coordinated Universal Time (UTC). The window length will always be 10 hours, so you can't specify an end time. For example, if you specify 11:00 P.M. UTC as a start time, the end time will automatically be set to 9:00 A.M. Default: - 10:00 P.M. local time\n")
    removal_policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='Policy to apply when the domain is removed from the stack. Default: RemovalPolicy.RETAIN\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='The list of security groups that are associated with the VPC endpoints for the domain. Only used if ``vpc`` is specified. Default: - One new security group is created.\n')
    tls_security_policy: typing.Optional[aws_cdk.aws_opensearchservice.TLSSecurityPolicy] = pydantic.Field(None, description='The minimum TLS version required for traffic to the domain. Default: - TLSSecurityPolicy.TLS_1_0\n')
    use_unsigned_basic_auth: typing.Optional[bool] = pydantic.Field(None, description='Configures the domain so that unsigned basic auth is enabled. If no master user is provided a default master user with username ``admin`` and a dynamically generated password stored in KMS is created. The password can be retrieved by getting ``masterUserPassword`` from the domain instance. Setting this to true will also add an access policy that allows unsigned access, enable node to node encryption, encryption at rest. If conflicting settings are encountered (like disabling encryption at rest) enabling this setting will cause a failure. Default: - false\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='Place the domain inside this VPC. Default: - Domain is not placed in a VPC.\n')
    vpc_subnets: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The specific vpc subnets the domain will be placed in. You must provide one subnet for each Availability Zone that your domain uses. For example, you must specify three subnet IDs for a three Availability Zone domain. Only used if ``vpc`` is specified. Default: - All private subnets.\n')
    zone_awareness: typing.Union[models.aws_opensearchservice.ZoneAwarenessConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The cluster zone awareness configuration for the Amazon OpenSearch Service domain. Default: - no zone awareness (1 AZ)')
    _init_params: typing.ClassVar[list[str]] = ['version', 'access_policies', 'advanced_options', 'automated_snapshot_start_hour', 'capacity', 'cognito_dashboards_auth', 'custom_endpoint', 'domain_name', 'ebs', 'enable_auto_software_update', 'enable_version_upgrade', 'encryption_at_rest', 'enforce_https', 'fine_grained_access_control', 'logging', 'node_to_node_encryption', 'off_peak_window_enabled', 'off_peak_window_start', 'removal_policy', 'security_groups', 'tls_security_policy', 'use_unsigned_basic_auth', 'vpc', 'vpc_subnets', 'zone_awareness']
    _method_names: typing.ClassVar[list[str]] = ['add_access_policies', 'apply_removal_policy', 'grant_index_read', 'grant_index_read_write', 'grant_index_write', 'grant_path_read', 'grant_path_read_write', 'grant_path_write', 'grant_read', 'grant_read_write', 'grant_write', 'metric', 'metric_automated_snapshot_failure', 'metric_cluster_index_writes_blocked', 'metric_cluster_status_red', 'metric_cluster_status_yellow', 'metric_cpu_utilization', 'metric_free_storage_space', 'metric_indexing_latency', 'metric_jvm_memory_pressure', 'metric_kms_key_error', 'metric_kms_key_inaccessible', 'metric_master_cpu_utilization', 'metric_master_jvm_memory_pressure', 'metric_nodes', 'metric_search_latency', 'metric_searchable_documents']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_domain_attributes', 'from_domain_endpoint']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.Domain'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_domain_attributes', 'from_domain_endpoint']
    ...


    from_domain_attributes: typing.Optional[models.aws_opensearchservice.DomainDefFromDomainAttributesParams] = pydantic.Field(None, description='Creates a domain construct that represents an external domain.')
    from_domain_endpoint: typing.Optional[models.aws_opensearchservice.DomainDefFromDomainEndpointParams] = pydantic.Field(None, description='Creates a domain construct that represents an external domain via domain endpoint.')
    resource_config: typing.Optional[models.aws_opensearchservice.DomainDefConfig] = pydantic.Field(None)


class DomainDefConfig(pydantic.BaseModel):
    add_access_policies: typing.Optional[list[models.aws_opensearchservice.DomainDefAddAccessPoliciesParams]] = pydantic.Field(None, description='Add policy statements to the domain access policy.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    grant_index_read: typing.Optional[list[models.aws_opensearchservice.DomainDefGrantIndexReadParams]] = pydantic.Field(None, description='Grant read permissions for an index in this domain to an IAM principal (Role/Group/User).')
    grant_index_read_write: typing.Optional[list[models.aws_opensearchservice.DomainDefGrantIndexReadWriteParams]] = pydantic.Field(None, description='Grant read/write permissions for an index in this domain to an IAM principal (Role/Group/User).')
    grant_index_write: typing.Optional[list[models.aws_opensearchservice.DomainDefGrantIndexWriteParams]] = pydantic.Field(None, description='Grant write permissions for an index in this domain to an IAM principal (Role/Group/User).')
    grant_path_read: typing.Optional[list[models.aws_opensearchservice.DomainDefGrantPathReadParams]] = pydantic.Field(None, description='Grant read permissions for a specific path in this domain to an IAM principal (Role/Group/User).')
    grant_path_read_write: typing.Optional[list[models.aws_opensearchservice.DomainDefGrantPathReadWriteParams]] = pydantic.Field(None, description='Grant read/write permissions for a specific path in this domain to an IAM principal (Role/Group/User).')
    grant_path_write: typing.Optional[list[models.aws_opensearchservice.DomainDefGrantPathWriteParams]] = pydantic.Field(None, description='Grant write permissions for a specific path in this domain to an IAM principal (Role/Group/User).')
    grant_read: typing.Optional[list[models.aws_opensearchservice.DomainDefGrantReadParams]] = pydantic.Field(None, description='Grant read permissions for this domain and its contents to an IAM principal (Role/Group/User).')
    grant_read_write: typing.Optional[list[models.aws_opensearchservice.DomainDefGrantReadWriteParams]] = pydantic.Field(None, description='Grant read/write permissions for this domain and its contents to an IAM principal (Role/Group/User).')
    grant_write: typing.Optional[list[models.aws_opensearchservice.DomainDefGrantWriteParams]] = pydantic.Field(None, description='Grant write permissions for this domain and its contents to an IAM principal (Role/Group/User).')
    metric: typing.Optional[list[models.aws_opensearchservice.DomainDefMetricParams]] = pydantic.Field(None, description='Return the given named metric for this domain.')
    metric_automated_snapshot_failure: typing.Optional[list[models.aws_opensearchservice.DomainDefMetricAutomatedSnapshotFailureParams]] = pydantic.Field(None, description='Metric for automated snapshot failures.')
    metric_cluster_index_writes_blocked: typing.Optional[list[models.aws_opensearchservice.DomainDefMetricClusterIndexWritesBlockedParams]] = pydantic.Field(None, description='Metric for the cluster blocking index writes.')
    metric_cluster_status_red: typing.Optional[list[models.aws_opensearchservice.DomainDefMetricClusterStatusRedParams]] = pydantic.Field(None, description='Metric for the time the cluster status is red.')
    metric_cluster_status_yellow: typing.Optional[list[models.aws_opensearchservice.DomainDefMetricClusterStatusYellowParams]] = pydantic.Field(None, description='Metric for the time the cluster status is yellow.')
    metric_cpu_utilization: typing.Optional[list[models.aws_opensearchservice.DomainDefMetricCpuUtilizationParams]] = pydantic.Field(None, description='Metric for CPU utilization.')
    metric_free_storage_space: typing.Optional[list[models.aws_opensearchservice.DomainDefMetricFreeStorageSpaceParams]] = pydantic.Field(None, description='Metric for the storage space of nodes in the cluster.')
    metric_indexing_latency: typing.Optional[list[models.aws_opensearchservice.DomainDefMetricIndexingLatencyParams]] = pydantic.Field(None, description='Metric for indexing latency.')
    metric_jvm_memory_pressure: typing.Optional[list[models.aws_opensearchservice.DomainDefMetricJvmMemoryPressureParams]] = pydantic.Field(None, description='Metric for JVM memory pressure.')
    metric_kms_key_error: typing.Optional[list[models.aws_opensearchservice.DomainDefMetricKmsKeyErrorParams]] = pydantic.Field(None, description='Metric for KMS key errors.')
    metric_kms_key_inaccessible: typing.Optional[list[models.aws_opensearchservice.DomainDefMetricKmsKeyInaccessibleParams]] = pydantic.Field(None, description='Metric for KMS key being inaccessible.')
    metric_master_cpu_utilization: typing.Optional[list[models.aws_opensearchservice.DomainDefMetricMasterCpuUtilizationParams]] = pydantic.Field(None, description='Metric for master CPU utilization.')
    metric_master_jvm_memory_pressure: typing.Optional[list[models.aws_opensearchservice.DomainDefMetricMasterJvmMemoryPressureParams]] = pydantic.Field(None, description='Metric for master JVM memory pressure.')
    metric_nodes: typing.Optional[list[models.aws_opensearchservice.DomainDefMetricNodesParams]] = pydantic.Field(None, description='Metric for the number of nodes.')
    metric_search_latency: typing.Optional[list[models.aws_opensearchservice.DomainDefMetricSearchLatencyParams]] = pydantic.Field(None, description='Metric for search latency.')
    metric_searchable_documents: typing.Optional[list[models.aws_opensearchservice.DomainDefMetricSearchableDocumentsParams]] = pydantic.Field(None, description='Metric for number of searchable documents.')
    connections_config: typing.Optional[models.aws_ec2.ConnectionsDefConfig] = pydantic.Field(None)

class DomainDefAddAccessPoliciesParams(pydantic.BaseModel):
    access_policy_statements: list[models.aws_iam.PolicyStatementDef] = pydantic.Field(...)
    ...

class DomainDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class DomainDefFromDomainAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The parent creating construct (usually ``this``).\n')
    id: str = pydantic.Field(..., description="The construct's name.\n")
    domain_arn: str = pydantic.Field(..., description='The ARN of the Amazon OpenSearch Service domain.\n')
    domain_endpoint: str = pydantic.Field(..., description='The domain endpoint of the Amazon OpenSearch Service domain.')
    ...

class DomainDefFromDomainEndpointParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The parent creating construct (usually ``this``).\n')
    id: str = pydantic.Field(..., description="The construct's name.\n")
    domain_endpoint: str = pydantic.Field(..., description="The domain's endpoint.")
    ...

class DomainDefGrantIndexReadParams(pydantic.BaseModel):
    index: str = pydantic.Field(..., description='The index to grant permissions for.\n')
    identity: models.AnyResource = pydantic.Field(..., description='The principal.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class DomainDefGrantIndexReadWriteParams(pydantic.BaseModel):
    index: str = pydantic.Field(..., description='The index to grant permissions for.\n')
    identity: models.AnyResource = pydantic.Field(..., description='The principal.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class DomainDefGrantIndexWriteParams(pydantic.BaseModel):
    index: str = pydantic.Field(..., description='The index to grant permissions for.\n')
    identity: models.AnyResource = pydantic.Field(..., description='The principal.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class DomainDefGrantPathReadParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path to grant permissions for.\n')
    identity: models.AnyResource = pydantic.Field(..., description='The principal.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class DomainDefGrantPathReadWriteParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path to grant permissions for.\n')
    identity: models.AnyResource = pydantic.Field(..., description='The principal.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class DomainDefGrantPathWriteParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path to grant permissions for.\n')
    identity: models.AnyResource = pydantic.Field(..., description='The principal.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class DomainDefGrantReadParams(pydantic.BaseModel):
    identity: models.AnyResource = pydantic.Field(..., description='The principal.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class DomainDefGrantReadWriteParams(pydantic.BaseModel):
    identity: models.AnyResource = pydantic.Field(..., description='The principal.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class DomainDefGrantWriteParams(pydantic.BaseModel):
    identity: models.AnyResource = pydantic.Field(..., description='The principal.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricParams(pydantic.BaseModel):
    metric_name: str = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricAutomatedSnapshotFailureParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricClusterIndexWritesBlockedParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 1 minute\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricClusterStatusRedParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricClusterStatusYellowParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricCpuUtilizationParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricFreeStorageSpaceParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: minimum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricIndexingLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: p99 over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricJvmMemoryPressureParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricKmsKeyErrorParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricKmsKeyInaccessibleParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricMasterCpuUtilizationParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricMasterJvmMemoryPressureParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricNodesParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: minimum over 1 hour\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricSearchLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: p99 over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class DomainDefMetricSearchableDocumentsParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: maximum over 5 minutes\n')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_opensearchservice.AdvancedSecurityOptions
class AdvancedSecurityOptionsDef(BaseStruct):
    master_user_arn: typing.Optional[str] = pydantic.Field(None, description='ARN for the master user. Only specify this or masterUserName, but not both. Default: - fine-grained access control is disabled\n')
    master_user_name: typing.Optional[str] = pydantic.Field(None, description='Username for the master user. Only specify this or masterUserArn, but not both. Default: - fine-grained access control is disabled\n')
    master_user_password: typing.Optional[models.SecretValueDef] = pydantic.Field(None, description='Password for the master user. You can use ``SecretValue.unsafePlainText`` to specify a password in plain text or use ``secretsmanager.Secret.fromSecretAttributes`` to reference a secret in Secrets Manager. Default: - A Secrets Manager generated password\n')
    saml_authentication_enabled: typing.Optional[bool] = pydantic.Field(None, description='True to enable SAML authentication for a domain. Default: - SAML authentication is disabled. Enabled if ``samlAuthenticationOptions`` is set.\n')
    saml_authentication_options: typing.Union[models.aws_opensearchservice.SAMLOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Container for information about the SAML configuration for OpenSearch Dashboards. If set, ``samlAuthenticationEnabled`` will be enabled. Default: - no SAML authentication options\n\n:exampleMetadata: infused\n\nExample::\n\n    domain = Domain(self, "Domain",\n        version=EngineVersion.OPENSEARCH_1_0,\n        enforce_https=True,\n        node_to_node_encryption=True,\n        encryption_at_rest=EncryptionAtRestOptions(\n            enabled=True\n        ),\n        fine_grained_access_control=AdvancedSecurityOptions(\n            master_user_name="master-user",\n            saml_authentication_enabled=True,\n            saml_authentication_options=SAMLOptionsProperty(\n                idp_entity_id="entity-id",\n                idp_metadata_content="metadata-content-with-quotes-escaped"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['master_user_arn', 'master_user_name', 'master_user_password', 'saml_authentication_enabled', 'saml_authentication_options']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.AdvancedSecurityOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.CapacityConfig
class CapacityConfigDef(BaseStruct):
    data_node_instance_type: typing.Optional[str] = pydantic.Field(None, description='The instance type for your data nodes, such as ``m3.medium.search``. For valid values, see `Supported Instance Types <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/supported-instance-types.html>`_ in the Amazon OpenSearch Service Developer Guide. Default: - r5.large.search\n')
    data_nodes: typing.Union[int, float, None] = pydantic.Field(None, description='The number of data nodes (instances) to use in the Amazon OpenSearch Service domain. Default: - 1\n')
    master_node_instance_type: typing.Optional[str] = pydantic.Field(None, description='The hardware configuration of the computer that hosts the dedicated master node, such as ``m3.medium.search``. For valid values, see [Supported Instance Types] (https://docs.aws.amazon.com/opensearch-service/latest/developerguide/supported-instance-types.html) in the Amazon OpenSearch Service Developer Guide. Default: - r5.large.search\n')
    master_nodes: typing.Union[int, float, None] = pydantic.Field(None, description='The number of instances to use for the master node. Default: - no dedicated master nodes\n')
    multi_az_with_standby_enabled: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether Multi-AZ with Standby deployment option is enabled. For more information, see [Multi-AZ with Standby] (https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html#managedomains-za-standby) Default: - no multi-az with standby\n')
    warm_instance_type: typing.Optional[str] = pydantic.Field(None, description='The instance type for your UltraWarm node, such as ``ultrawarm1.medium.search``. For valid values, see [UltraWarm Storage Limits] (https://docs.aws.amazon.com/opensearch-service/latest/developerguide/limits.html#limits-ultrawarm) in the Amazon OpenSearch Service Developer Guide. Default: - ultrawarm1.medium.search\n')
    warm_nodes: typing.Union[int, float, None] = pydantic.Field(None, description='The number of UltraWarm nodes (instances) to use in the Amazon OpenSearch Service domain. Default: - no UltraWarm nodes\n\n:exampleMetadata: infused\n\nExample::\n\n    domain = Domain(self, "Domain",\n        version=EngineVersion.OPENSEARCH_1_0,\n        capacity=CapacityConfig(\n            master_nodes=2,\n            warm_nodes=2,\n            warm_instance_type="ultrawarm1.medium.search"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['data_node_instance_type', 'data_nodes', 'master_node_instance_type', 'master_nodes', 'multi_az_with_standby_enabled', 'warm_instance_type', 'warm_nodes']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CapacityConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.CfnDomain.AdvancedSecurityOptionsInputProperty
class CfnDomain_AdvancedSecurityOptionsInputPropertyDef(BaseStruct):
    anonymous_auth_disable_date: typing.Optional[str] = pydantic.Field(None, description='Date and time when the migration period will be disabled. Only necessary when `enabling fine-grained access control on an existing domain <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html#fgac-enabling-existing>`_ .\n')
    anonymous_auth_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='True to enable a 30-day migration period during which administrators can create role mappings. Only necessary when `enabling fine-grained access control on an existing domain <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html#fgac-enabling-existing>`_ .\n')
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='True to enable fine-grained access control. You must also enable encryption of data at rest and node-to-node encryption. See `Fine-grained access control in Amazon OpenSearch Service <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html>`_ .\n')
    internal_user_database_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='True to enable the internal user database.\n')
    master_user_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_MasterUserOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies information about the master user.\n')
    saml_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_SAMLOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Container for information about the SAML configuration for OpenSearch Dashboards.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-advancedsecurityoptionsinput.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_opensearchservice as opensearchservice\n\n    advanced_security_options_input_property = opensearchservice.CfnDomain.AdvancedSecurityOptionsInputProperty(\n        anonymous_auth_disable_date="anonymousAuthDisableDate",\n        anonymous_auth_enabled=False,\n        enabled=False,\n        internal_user_database_enabled=False,\n        master_user_options=opensearchservice.CfnDomain.MasterUserOptionsProperty(\n            master_user_arn="masterUserArn",\n            master_user_name="masterUserName",\n            master_user_password="masterUserPassword"\n        ),\n        saml_options=opensearchservice.CfnDomain.SAMLOptionsProperty(\n            enabled=False,\n            idp=opensearchservice.CfnDomain.IdpProperty(\n                entity_id="entityId",\n                metadata_content="metadataContent"\n            ),\n            master_backend_role="masterBackendRole",\n            master_user_name="masterUserName",\n            roles_key="rolesKey",\n            session_timeout_minutes=123,\n            subject_key="subjectKey"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['anonymous_auth_disable_date', 'anonymous_auth_enabled', 'enabled', 'internal_user_database_enabled', 'master_user_options', 'saml_options']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CfnDomain.AdvancedSecurityOptionsInputProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.CfnDomain.ClusterConfigProperty
class CfnDomain_ClusterConfigPropertyDef(BaseStruct):
    dedicated_master_count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of instances to use for the master node. If you specify this property, you must specify ``true`` for the ``DedicatedMasterEnabled`` property.\n')
    dedicated_master_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="Indicates whether to use a dedicated master node for the OpenSearch Service domain. A dedicated master node is a cluster node that performs cluster management tasks, but doesn't hold data or respond to data upload requests. Dedicated master nodes offload cluster management tasks to increase the stability of your search clusters. See `Dedicated master nodes in Amazon OpenSearch Service <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-dedicatedmasternodes.html>`_ .\n")
    dedicated_master_type: typing.Optional[str] = pydantic.Field(None, description='The hardware configuration of the computer that hosts the dedicated master node, such as ``m3.medium.search`` . If you specify this property, you must specify ``true`` for the ``DedicatedMasterEnabled`` property. For valid values, see `Supported instance types in Amazon OpenSearch Service <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/supported-instance-types.html>`_ .\n')
    instance_count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of data nodes (instances) to use in the OpenSearch Service domain.\n')
    instance_type: typing.Optional[str] = pydantic.Field(None, description='The instance type for your data nodes, such as ``m3.medium.search`` . For valid values, see `Supported instance types in Amazon OpenSearch Service <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/supported-instance-types.html>`_ .\n')
    multi_az_with_standby_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether Multi-AZ with Standby deployment option is enabled. For more information, see `Multi-AZ with Standby <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html#managedomains-za-standby>`_ .\n')
    warm_count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of warm nodes in the cluster.\n')
    warm_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Whether to enable UltraWarm storage for the cluster. See `UltraWarm storage for Amazon OpenSearch Service <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/ultrawarm.html>`_ .\n')
    warm_type: typing.Optional[str] = pydantic.Field(None, description="The instance type for the cluster's warm nodes.\n")
    zone_awareness_config: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_ZoneAwarenessConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies zone awareness configuration options. Only use if ``ZoneAwarenessEnabled`` is ``true`` .\n')
    zone_awareness_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether to enable zone awareness for the OpenSearch Service domain. When you enable zone awareness, OpenSearch Service allocates the nodes and replica index shards that belong to a cluster across two Availability Zones (AZs) in the same region to prevent data loss and minimize downtime in the event of node or data center failure. Don\'t enable zone awareness if your cluster has no replica index shards or is a single-node cluster. For more information, see `Configuring a multi-AZ domain in Amazon OpenSearch Service <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-clusterconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_opensearchservice as opensearchservice\n\n    cluster_config_property = opensearchservice.CfnDomain.ClusterConfigProperty(\n        dedicated_master_count=123,\n        dedicated_master_enabled=False,\n        dedicated_master_type="dedicatedMasterType",\n        instance_count=123,\n        instance_type="instanceType",\n        multi_az_with_standby_enabled=False,\n        warm_count=123,\n        warm_enabled=False,\n        warm_type="warmType",\n        zone_awareness_config=opensearchservice.CfnDomain.ZoneAwarenessConfigProperty(\n            availability_zone_count=123\n        ),\n        zone_awareness_enabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['dedicated_master_count', 'dedicated_master_enabled', 'dedicated_master_type', 'instance_count', 'instance_type', 'multi_az_with_standby_enabled', 'warm_count', 'warm_enabled', 'warm_type', 'zone_awareness_config', 'zone_awareness_enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CfnDomain.ClusterConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.CfnDomain.CognitoOptionsProperty
class CfnDomain_CognitoOptionsPropertyDef(BaseStruct):
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Whether to enable or disable Amazon Cognito authentication for OpenSearch Dashboards. See `Amazon Cognito authentication for OpenSearch Dashboards <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html>`_ .\n')
    identity_pool_id: typing.Optional[str] = pydantic.Field(None, description='The Amazon Cognito identity pool ID that you want OpenSearch Service to use for OpenSearch Dashboards authentication. Required if you enabled Cognito Authentication for OpenSearch Dashboards.\n')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='The ``AmazonOpenSearchServiceCognitoAccess`` role that allows OpenSearch Service to configure your user pool and identity pool. Required if you enabled Cognito Authentication for OpenSearch Dashboards.\n')
    user_pool_id: typing.Optional[str] = pydantic.Field(None, description='The Amazon Cognito user pool ID that you want OpenSearch Service to use for OpenSearch Dashboards authentication. Required if you enabled Cognito Authentication for OpenSearch Dashboards.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-cognitooptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_opensearchservice as opensearchservice\n\n    cognito_options_property = opensearchservice.CfnDomain.CognitoOptionsProperty(\n        enabled=False,\n        identity_pool_id="identityPoolId",\n        role_arn="roleArn",\n        user_pool_id="userPoolId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'identity_pool_id', 'role_arn', 'user_pool_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CfnDomain.CognitoOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.CfnDomain.DomainEndpointOptionsProperty
class CfnDomain_DomainEndpointOptionsPropertyDef(BaseStruct):
    custom_endpoint: typing.Optional[str] = pydantic.Field(None, description='The fully qualified URL for your custom endpoint. Required if you enabled a custom endpoint for the domain.\n')
    custom_endpoint_certificate_arn: typing.Optional[str] = pydantic.Field(None, description="The AWS Certificate Manager ARN for your domain's SSL/TLS certificate. Required if you enabled a custom endpoint for the domain.\n")
    custom_endpoint_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='True to enable a custom endpoint for the domain. If enabled, you must also provide values for ``CustomEndpoint`` and ``CustomEndpointCertificateArn`` .\n')
    enforce_https: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='True to require that all traffic to the domain arrive over HTTPS. Required if you enable fine-grained access control in `AdvancedSecurityOptions <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-advancedsecurityoptionsinput.html>`_ .\n')
    tls_security_policy: typing.Optional[str] = pydantic.Field(None, description='The minimum TLS version required for traffic to the domain. Valid values are TLS 1.3 (recommended) or 1.2:. - ``Policy-Min-TLS-1-0-2019-07`` - ``Policy-Min-TLS-1-2-2019-07``\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-domainendpointoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_opensearchservice as opensearchservice\n\n    domain_endpoint_options_property = opensearchservice.CfnDomain.DomainEndpointOptionsProperty(\n        custom_endpoint="customEndpoint",\n        custom_endpoint_certificate_arn="customEndpointCertificateArn",\n        custom_endpoint_enabled=False,\n        enforce_https=False,\n        tls_security_policy="tlsSecurityPolicy"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['custom_endpoint', 'custom_endpoint_certificate_arn', 'custom_endpoint_enabled', 'enforce_https', 'tls_security_policy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CfnDomain.DomainEndpointOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.CfnDomain.EBSOptionsProperty
class CfnDomain_EBSOptionsPropertyDef(BaseStruct):
    ebs_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether Amazon EBS volumes are attached to data nodes in the OpenSearch Service domain.\n')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='The number of I/O operations per second (IOPS) that the volume supports. This property applies only to the ``gp3`` and provisioned IOPS EBS volume types.\n')
    throughput: typing.Union[int, float, None] = pydantic.Field(None, description='The throughput (in MiB/s) of the EBS volumes attached to data nodes. Applies only to the ``gp3`` volume type.\n')
    volume_size: typing.Union[int, float, None] = pydantic.Field(None, description='The size (in GiB) of the EBS volume for each data node. The minimum and maximum size of an EBS volume depends on the EBS volume type and the instance type to which it is attached. For more information, see `EBS volume size limits <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/limits.html#ebsresource>`_ in the *Amazon OpenSearch Service Developer Guide* .\n')
    volume_type: typing.Optional[str] = pydantic.Field(None, description='The EBS volume type to use with the OpenSearch Service domain. If you choose ``gp3`` , you must also specify values for ``Iops`` and ``Throughput`` . For more information about each type, see `Amazon EBS volume types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>`_ in the *Amazon EC2 User Guide for Linux Instances* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-ebsoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_opensearchservice as opensearchservice\n\n    e_bSOptions_property = opensearchservice.CfnDomain.EBSOptionsProperty(\n        ebs_enabled=False,\n        iops=123,\n        throughput=123,\n        volume_size=123,\n        volume_type="volumeType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ebs_enabled', 'iops', 'throughput', 'volume_size', 'volume_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CfnDomain.EBSOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.CfnDomain.EncryptionAtRestOptionsProperty
class CfnDomain_EncryptionAtRestOptionsPropertyDef(BaseStruct):
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specify ``true`` to enable encryption at rest. Required if you enable fine-grained access control in `AdvancedSecurityOptionsInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-advancedsecurityoptionsinput.html>`_ .\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The KMS key ID. Takes the form ``1a2a3a4-1a2a-3a4a-5a6a-1a2a3a4a5a6a`` . Required if you enable encryption at rest. You can also use ``keyAlias`` as a value.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-encryptionatrestoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_opensearchservice as opensearchservice\n\n    encryption_at_rest_options_property = opensearchservice.CfnDomain.EncryptionAtRestOptionsProperty(\n        enabled=False,\n        kms_key_id="kmsKeyId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'kms_key_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CfnDomain.EncryptionAtRestOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.CfnDomain.IdpProperty
class CfnDomain_IdpPropertyDef(BaseStruct):
    entity_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique entity ID of the application in the SAML identity provider.\n')
    metadata_content: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The metadata of the SAML application, in XML format.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-idp.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_opensearchservice as opensearchservice\n\n    idp_property = opensearchservice.CfnDomain.IdpProperty(\n        entity_id="entityId",\n        metadata_content="metadataContent"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['entity_id', 'metadata_content']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CfnDomain.IdpProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.CfnDomain.LogPublishingOptionProperty
class CfnDomain_LogPublishingOptionPropertyDef(BaseStruct):
    cloud_watch_logs_log_group_arn: typing.Optional[str] = pydantic.Field(None, description='Specifies the CloudWatch log group to publish to. Required if you enable log publishing.\n')
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='If ``true`` , enables the publishing of logs to CloudWatch. Default: ``false`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-logpublishingoption.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_opensearchservice as opensearchservice\n\n    log_publishing_option_property = opensearchservice.CfnDomain.LogPublishingOptionProperty(\n        cloud_watch_logs_log_group_arn="cloudWatchLogsLogGroupArn",\n        enabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cloud_watch_logs_log_group_arn', 'enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CfnDomain.LogPublishingOptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.CfnDomain.MasterUserOptionsProperty
class CfnDomain_MasterUserOptionsPropertyDef(BaseStruct):
    master_user_arn: typing.Optional[str] = pydantic.Field(None, description='Amazon Resource Name (ARN) for the master user. The ARN can point to an IAM user or role. This property is required for Amazon Cognito to work, and it must match the role configured for Cognito. Only specify if ``InternalUserDatabaseEnabled`` is false in `AdvancedSecurityOptionsInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-advancedsecurityoptionsinput.html>`_ .\n')
    master_user_name: typing.Optional[str] = pydantic.Field(None, description="Username for the master user. Only specify if ``InternalUserDatabaseEnabled`` is true in `AdvancedSecurityOptionsInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-advancedsecurityoptionsinput.html>`_ . If you don't want to specify this value directly within the template, you can use a `dynamic reference <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/dynamic-references.html>`_ instead.\n")
    master_user_password: typing.Optional[str] = pydantic.Field(None, description='Password for the master user. Only specify if ``InternalUserDatabaseEnabled`` is true in `AdvancedSecurityOptionsInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-advancedsecurityoptionsinput.html>`_ . If you don\'t want to specify this value directly within the template, you can use a `dynamic reference <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/dynamic-references.html>`_ instead.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-masteruseroptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_opensearchservice as opensearchservice\n\n    master_user_options_property = opensearchservice.CfnDomain.MasterUserOptionsProperty(\n        master_user_arn="masterUserArn",\n        master_user_name="masterUserName",\n        master_user_password="masterUserPassword"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['master_user_arn', 'master_user_name', 'master_user_password']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CfnDomain.MasterUserOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.CfnDomain.NodeToNodeEncryptionOptionsProperty
class CfnDomain_NodeToNodeEncryptionOptionsPropertyDef(BaseStruct):
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies to enable or disable node-to-node encryption on the domain. Required if you enable fine-grained access control in `AdvancedSecurityOptionsInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-advancedsecurityoptionsinput.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-nodetonodeencryptionoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_opensearchservice as opensearchservice\n\n    node_to_node_encryption_options_property = opensearchservice.CfnDomain.NodeToNodeEncryptionOptionsProperty(\n        enabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CfnDomain.NodeToNodeEncryptionOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.CfnDomain.OffPeakWindowOptionsProperty
class CfnDomain_OffPeakWindowOptionsPropertyDef(BaseStruct):
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether off-peak window settings are enabled for the domain.\n')
    off_peak_window: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_OffPeakWindowPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Off-peak window settings for the domain.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-offpeakwindowoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_opensearchservice as opensearchservice\n\n    off_peak_window_options_property = opensearchservice.CfnDomain.OffPeakWindowOptionsProperty(\n        enabled=False,\n        off_peak_window=opensearchservice.CfnDomain.OffPeakWindowProperty(\n            window_start_time=opensearchservice.CfnDomain.WindowStartTimeProperty(\n                hours=123,\n                minutes=123\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'off_peak_window']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CfnDomain.OffPeakWindowOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.CfnDomain.OffPeakWindowProperty
class CfnDomain_OffPeakWindowPropertyDef(BaseStruct):
    window_start_time: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_WindowStartTimePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The desired start time for an off-peak maintenance window.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-offpeakwindow.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_opensearchservice as opensearchservice\n\n    off_peak_window_property = opensearchservice.CfnDomain.OffPeakWindowProperty(\n        window_start_time=opensearchservice.CfnDomain.WindowStartTimeProperty(\n            hours=123,\n            minutes=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['window_start_time']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CfnDomain.OffPeakWindowProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.CfnDomain.SAMLOptionsProperty
class CfnDomain_SAMLOptionsPropertyDef(BaseStruct):
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='True to enable SAML authentication for a domain.\n')
    idp: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_IdpPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The SAML Identity Provider's information.\n")
    master_backend_role: typing.Optional[str] = pydantic.Field(None, description='The backend role that the SAML master user is mapped to.\n')
    master_user_name: typing.Optional[str] = pydantic.Field(None, description="The SAML master user name, which is stored in the domain's internal user database.\n")
    roles_key: typing.Optional[str] = pydantic.Field(None, description='Element of the SAML assertion to use for backend roles. Default is ``roles`` .\n')
    session_timeout_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='The duration, in minutes, after which a user session becomes inactive. Acceptable values are between 1 and 1440, and the default value is 60.\n')
    subject_key: typing.Optional[str] = pydantic.Field(None, description='Element of the SAML assertion to use for the user name. Default is ``NameID`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-samloptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_opensearchservice as opensearchservice\n\n    s_aMLOptions_property = opensearchservice.CfnDomain.SAMLOptionsProperty(\n        enabled=False,\n        idp=opensearchservice.CfnDomain.IdpProperty(\n            entity_id="entityId",\n            metadata_content="metadataContent"\n        ),\n        master_backend_role="masterBackendRole",\n        master_user_name="masterUserName",\n        roles_key="rolesKey",\n        session_timeout_minutes=123,\n        subject_key="subjectKey"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'idp', 'master_backend_role', 'master_user_name', 'roles_key', 'session_timeout_minutes', 'subject_key']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CfnDomain.SAMLOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.CfnDomain.ServiceSoftwareOptionsProperty
class CfnDomain_ServiceSoftwareOptionsPropertyDef(BaseStruct):
    automated_update_date: typing.Optional[str] = pydantic.Field(None, description='The timestamp, in Epoch time, until which you can manually request a service software update. After this date, we automatically update your service software.\n')
    cancellable: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="True if you're able to cancel your service software version update. False if you can't cancel your service software update.\n")
    current_version: typing.Optional[str] = pydantic.Field(None, description='The current service software version present on the domain.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the service software update status.\n')
    new_version: typing.Optional[str] = pydantic.Field(None, description='The new service software version, if one is available.\n')
    optional_deployment: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='True if a service software is never automatically updated. False if a service software is automatically updated after the automated update date.\n')
    update_available: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="True if you're able to update your service software version. False if you can't update your service software version.\n")
    update_status: typing.Optional[str] = pydantic.Field(None, description='The status of your service software update.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-servicesoftwareoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_opensearchservice as opensearchservice\n\n    service_software_options_property = opensearchservice.CfnDomain.ServiceSoftwareOptionsProperty(\n        automated_update_date="automatedUpdateDate",\n        cancellable=False,\n        current_version="currentVersion",\n        description="description",\n        new_version="newVersion",\n        optional_deployment=False,\n        update_available=False,\n        update_status="updateStatus"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['automated_update_date', 'cancellable', 'current_version', 'description', 'new_version', 'optional_deployment', 'update_available', 'update_status']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CfnDomain.ServiceSoftwareOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.CfnDomain.SnapshotOptionsProperty
class CfnDomain_SnapshotOptionsPropertyDef(BaseStruct):
    automated_snapshot_start_hour: typing.Union[int, float, None] = pydantic.Field(None, description='The hour in UTC during which the service takes an automated daily snapshot of the indexes in the OpenSearch Service domain. For example, if you specify 0, OpenSearch Service takes an automated snapshot everyday between midnight and 1 am. You can specify a value between 0 and 23.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-snapshotoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_opensearchservice as opensearchservice\n\n    snapshot_options_property = opensearchservice.CfnDomain.SnapshotOptionsProperty(\n        automated_snapshot_start_hour=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['automated_snapshot_start_hour']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CfnDomain.SnapshotOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.CfnDomain.SoftwareUpdateOptionsProperty
class CfnDomain_SoftwareUpdateOptionsPropertyDef(BaseStruct):
    auto_software_update_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether automatic service software updates are enabled for the domain.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-softwareupdateoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_opensearchservice as opensearchservice\n\n    software_update_options_property = opensearchservice.CfnDomain.SoftwareUpdateOptionsProperty(\n        auto_software_update_enabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['auto_software_update_enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CfnDomain.SoftwareUpdateOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.CfnDomain.VPCOptionsProperty
class CfnDomain_VPCOptionsPropertyDef(BaseStruct):
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The list of security group IDs that are associated with the VPC endpoints for the domain. If you don't provide a security group ID, OpenSearch Service uses the default security group for the VPC. To learn more, see `Security groups for your VPC <https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html>`_ in the *Amazon VPC User Guide* .\n")
    subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Provide one subnet ID for each Availability Zone that your domain uses. For example, you must specify three subnet IDs for a three-AZ domain. To learn more, see `VPCs and subnets <https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html>`_ in the *Amazon VPC User Guide* . If you specify more than one subnet, you must also configure ``ZoneAwarenessEnabled`` and ``ZoneAwarenessConfig`` within `ClusterConfig <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-clusterconfig.html>`_ , otherwise you\'ll see the error "You must specify exactly one subnet" during template creation.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-vpcoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_opensearchservice as opensearchservice\n\n    v_pCOptions_property = opensearchservice.CfnDomain.VPCOptionsProperty(\n        security_group_ids=["securityGroupIds"],\n        subnet_ids=["subnetIds"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['security_group_ids', 'subnet_ids']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CfnDomain.VPCOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.CfnDomain.WindowStartTimeProperty
class CfnDomain_WindowStartTimePropertyDef(BaseStruct):
    hours: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The start hour of the window in Coordinated Universal Time (UTC), using 24-hour time. For example, 17 refers to 5:00 P.M. UTC. The minimum value is 0 and the maximum value is 23.\n')
    minutes: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The start minute of the window, in UTC. The minimum value is 0 and the maximum value is 59.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-windowstarttime.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_opensearchservice as opensearchservice\n\n    window_start_time_property = opensearchservice.CfnDomain.WindowStartTimeProperty(\n        hours=123,\n        minutes=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['hours', 'minutes']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CfnDomain.WindowStartTimeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.CfnDomain.ZoneAwarenessConfigProperty
class CfnDomain_ZoneAwarenessConfigPropertyDef(BaseStruct):
    availability_zone_count: typing.Union[int, float, None] = pydantic.Field(None, description='If you enabled multiple Availability Zones (AZs), the number of AZs that you want the domain to use. Valid values are ``2`` and ``3`` . Default is 2.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-zoneawarenessconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_opensearchservice as opensearchservice\n\n    zone_awareness_config_property = opensearchservice.CfnDomain.ZoneAwarenessConfigProperty(\n        availability_zone_count=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone_count']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CfnDomain.ZoneAwarenessConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.CognitoOptions
class CognitoOptionsDef(BaseStruct):
    identity_pool_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Cognito identity pool ID that you want Amazon OpenSearch Service to use for OpenSearch Dashboards authentication.\n')
    role: typing.Union[_REQUIRED_INIT_PARAM, models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='A role that allows Amazon OpenSearch Service to configure your user pool and identity pool. It must have the ``AmazonESCognitoAccess`` policy attached to it.\n')
    user_pool_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Cognito user pool ID that you want Amazon OpenSearch Service to use for OpenSearch Dashboards authentication.\n\n:see: https://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html\n:exampleMetadata: fixture=migrate-opensearch infused\n\nExample::\n\n    opensearch.Domain(self, "Domain",\n        cognito_dashboards_auth=opensearch.CognitoOptions(\n            identity_pool_id="test-identity-pool-id",\n            user_pool_id="test-user-pool-id",\n            role=role\n        ),\n        version=open_search_version\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['identity_pool_id', 'role', 'user_pool_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CognitoOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_opensearchservice.CognitoOptionsDefConfig] = pydantic.Field(None)


class CognitoOptionsDefConfig(pydantic.BaseModel):
    role_config: typing.Optional[models._interface_methods.AwsIamIRoleDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_opensearchservice.CustomEndpointOptions
class CustomEndpointOptionsDef(BaseStruct):
    domain_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The custom domain name to assign.\n')
    certificate: typing.Optional[typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef]] = pydantic.Field(None, description='The certificate to use. Default: - create a new one\n')
    hosted_zone: typing.Optional[typing.Union[models.aws_route53.HostedZoneDef, models.aws_route53.PrivateHostedZoneDef, models.aws_route53.PublicHostedZoneDef]] = pydantic.Field(None, description='The hosted zone in Route53 to create the CNAME record in. Default: - do not create a CNAME\n\n:exampleMetadata: infused\n\nExample::\n\n    Domain(self, "Domain",\n        version=EngineVersion.OPENSEARCH_1_0,\n        custom_endpoint=CustomEndpointOptions(\n            domain_name="search.example.com"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'certificate', 'hosted_zone']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CustomEndpointOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.DomainAttributes
class DomainAttributesDef(BaseStruct):
    domain_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the Amazon OpenSearch Service domain.\n')
    domain_endpoint: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The domain endpoint of the Amazon OpenSearch Service domain.\n\n:exampleMetadata: infused\n\nExample::\n\n    domain_arn = Fn.import_value("another-cf-stack-export-domain-arn")\n    domain_endpoint = Fn.import_value("another-cf-stack-export-domain-endpoint")\n    domain = Domain.from_domain_attributes(self, "ImportedDomain",\n        domain_arn=domain_arn,\n        domain_endpoint=domain_endpoint\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['domain_arn', 'domain_endpoint']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.DomainAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.DomainProps
class DomainPropsDef(BaseStruct):
    version: typing.Union[models.aws_opensearchservice.EngineVersionDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Elasticsearch/OpenSearch version that your domain will leverage.\n')
    access_policies: typing.Optional[typing.Sequence[models.aws_iam.PolicyStatementDef]] = pydantic.Field(None, description='Domain access policies. Default: - No access policies.\n')
    advanced_options: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Additional options to specify for the Amazon OpenSearch Service domain. Default: - no advanced options are specified\n')
    automated_snapshot_start_hour: typing.Union[int, float, None] = pydantic.Field(None, description='The hour in UTC during which the service takes an automated daily snapshot of the indices in the Amazon OpenSearch Service domain. Only applies for Elasticsearch versions below 5.3. Default: - Hourly automated snapshots not used\n')
    capacity: typing.Union[models.aws_opensearchservice.CapacityConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The cluster capacity configuration for the Amazon OpenSearch Service domain. Default: - 1 r5.large.search data node; no dedicated master nodes.\n')
    cognito_dashboards_auth: typing.Union[models.aws_opensearchservice.CognitoOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configures Amazon OpenSearch Service to use Amazon Cognito authentication for OpenSearch Dashboards. Default: - Cognito not used for authentication to OpenSearch Dashboards.\n')
    custom_endpoint: typing.Union[models.aws_opensearchservice.CustomEndpointOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='To configure a custom domain configure these options. If you specify a Route53 hosted zone it will create a CNAME record and use DNS validation for the certificate Default: - no custom domain endpoint will be configured\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description='Enforces a particular physical domain name. Default: - A name will be auto-generated.\n')
    ebs: typing.Union[models.aws_opensearchservice.EbsOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configurations of Amazon Elastic Block Store (Amazon EBS) volumes that are attached to data nodes in the Amazon OpenSearch Service domain. Default: - 10 GiB General Purpose (SSD) volumes per node.\n')
    enable_auto_software_update: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether automatic service software updates are enabled for the domain. Default: - false\n')
    enable_version_upgrade: typing.Optional[bool] = pydantic.Field(None, description='To upgrade an Amazon OpenSearch Service domain to a new version, rather than replacing the entire domain resource, use the EnableVersionUpgrade update policy. Default: - false\n')
    encryption_at_rest: typing.Union[models.aws_opensearchservice.EncryptionAtRestOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Encryption at rest options for the cluster. Default: - No encryption at rest\n')
    enforce_https: typing.Optional[bool] = pydantic.Field(None, description='True to require that all traffic to the domain arrive over HTTPS. Default: - false\n')
    fine_grained_access_control: typing.Union[models.aws_opensearchservice.AdvancedSecurityOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies options for fine-grained access control. Requires Elasticsearch version 6.7 or later or OpenSearch version 1.0 or later. Enabling fine-grained access control also requires encryption of data at rest and node-to-node encryption, along with enforced HTTPS. Default: - fine-grained access control is disabled\n')
    logging: typing.Union[models.aws_opensearchservice.LoggingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configuration log publishing configuration options. Default: - No logs are published\n')
    node_to_node_encryption: typing.Optional[bool] = pydantic.Field(None, description='Specify true to enable node to node encryption. Requires Elasticsearch version 6.0 or later or OpenSearch version 1.0 or later. Default: - Node to node encryption is not enabled.\n')
    off_peak_window_enabled: typing.Optional[bool] = pydantic.Field(None, description="Options for enabling a domain's off-peak window, during which OpenSearch Service can perform mandatory configuration changes on the domain. Off-peak windows were introduced on February 16, 2023. All domains created before this date have the off-peak window disabled by default. You must manually enable and configure the off-peak window for these domains. All domains created after this date will have the off-peak window enabled by default. You can't disable the off-peak window for a domain after it's enabled. Default: - Disabled for domains created before February 16, 2023. Enabled for domains created after. Enabled if ``offPeakWindowStart`` is set.\n")
    off_peak_window_start: typing.Union[models.aws_opensearchservice.WindowStartTimeDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Start time for the off-peak window, in Coordinated Universal Time (UTC). The window length will always be 10 hours, so you can't specify an end time. For example, if you specify 11:00 P.M. UTC as a start time, the end time will automatically be set to 9:00 A.M. Default: - 10:00 P.M. local time\n")
    removal_policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='Policy to apply when the domain is removed from the stack. Default: RemovalPolicy.RETAIN\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='The list of security groups that are associated with the VPC endpoints for the domain. Only used if ``vpc`` is specified. Default: - One new security group is created.\n')
    tls_security_policy: typing.Optional[aws_cdk.aws_opensearchservice.TLSSecurityPolicy] = pydantic.Field(None, description='The minimum TLS version required for traffic to the domain. Default: - TLSSecurityPolicy.TLS_1_0\n')
    use_unsigned_basic_auth: typing.Optional[bool] = pydantic.Field(None, description='Configures the domain so that unsigned basic auth is enabled. If no master user is provided a default master user with username ``admin`` and a dynamically generated password stored in KMS is created. The password can be retrieved by getting ``masterUserPassword`` from the domain instance. Setting this to true will also add an access policy that allows unsigned access, enable node to node encryption, encryption at rest. If conflicting settings are encountered (like disabling encryption at rest) enabling this setting will cause a failure. Default: - false\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='Place the domain inside this VPC. Default: - Domain is not placed in a VPC.\n')
    vpc_subnets: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The specific vpc subnets the domain will be placed in. You must provide one subnet for each Availability Zone that your domain uses. For example, you must specify three subnet IDs for a three Availability Zone domain. Only used if ``vpc`` is specified. Default: - All private subnets.\n')
    zone_awareness: typing.Union[models.aws_opensearchservice.ZoneAwarenessConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The cluster zone awareness configuration for the Amazon OpenSearch Service domain. Default: - no zone awareness (1 AZ)\n\n:exampleMetadata: infused\n\nExample::\n\n    domain = Domain(self, "Domain",\n        version=EngineVersion.OPENSEARCH_1_0,\n        ebs=EbsOptions(\n            volume_size=100,\n            volume_type=ec2.EbsDeviceVolumeType.GENERAL_PURPOSE_SSD\n        ),\n        node_to_node_encryption=True,\n        encryption_at_rest=EncryptionAtRestOptions(\n            enabled=True\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['version', 'access_policies', 'advanced_options', 'automated_snapshot_start_hour', 'capacity', 'cognito_dashboards_auth', 'custom_endpoint', 'domain_name', 'ebs', 'enable_auto_software_update', 'enable_version_upgrade', 'encryption_at_rest', 'enforce_https', 'fine_grained_access_control', 'logging', 'node_to_node_encryption', 'off_peak_window_enabled', 'off_peak_window_start', 'removal_policy', 'security_groups', 'tls_security_policy', 'use_unsigned_basic_auth', 'vpc', 'vpc_subnets', 'zone_awareness']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.DomainProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.EbsOptions
class EbsOptionsDef(BaseStruct):
    enabled: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether Amazon EBS volumes are attached to data nodes in the Amazon OpenSearch Service domain. Default: - true\n')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='The number of I/O operations per second (IOPS) that the volume supports. This property applies only to the gp3 and Provisioned IOPS (SSD) EBS volume type. Default: - iops are not set.\n')
    throughput: typing.Union[int, float, None] = pydantic.Field(None, description='The throughput (in MiB/s) of the EBS volumes attached to data nodes. This property applies only to the gp3 volume type. Default: - throughput is not set.\n')
    volume_size: typing.Union[int, float, None] = pydantic.Field(None, description='The size (in GiB) of the EBS volume for each data node. The minimum and maximum size of an EBS volume depends on the EBS volume type and the instance type to which it is attached. For valid values, see [EBS volume size limits] (https://docs.aws.amazon.com/opensearch-service/latest/developerguide/limits.html#ebsresource) in the Amazon OpenSearch Service Developer Guide. Default: 10\n')
    volume_type: typing.Optional[aws_cdk.aws_ec2.EbsDeviceVolumeType] = pydantic.Field(None, description='The EBS volume type to use with the Amazon OpenSearch Service domain, such as standard, gp2, io1. Default: gp2\n\n:exampleMetadata: infused\n\nExample::\n\n    domain = Domain(self, "Domain",\n        version=EngineVersion.OPENSEARCH_1_0,\n        ebs=EbsOptions(\n            volume_size=100,\n            volume_type=ec2.EbsDeviceVolumeType.GENERAL_PURPOSE_SSD\n        ),\n        node_to_node_encryption=True,\n        encryption_at_rest=EncryptionAtRestOptions(\n            enabled=True\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'iops', 'throughput', 'volume_size', 'volume_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.EbsOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.EncryptionAtRestOptions
class EncryptionAtRestOptionsDef(BaseStruct):
    enabled: typing.Optional[bool] = pydantic.Field(None, description='Specify true to enable encryption at rest. Default: - encryption at rest is disabled.\n')
    kms_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='Supply if using KMS key for encryption at rest. Default: - uses default aws/es KMS key.\n\n:exampleMetadata: infused\n\nExample::\n\n    domain = Domain(self, "Domain",\n        version=EngineVersion.OPENSEARCH_1_0,\n        enforce_https=True,\n        node_to_node_encryption=True,\n        encryption_at_rest=EncryptionAtRestOptions(\n            enabled=True\n        ),\n        fine_grained_access_control=AdvancedSecurityOptions(\n            master_user_name="master-user",\n            saml_authentication_enabled=True,\n            saml_authentication_options=SAMLOptionsProperty(\n                idp_entity_id="entity-id",\n                idp_metadata_content="metadata-content-with-quotes-escaped"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'kms_key']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.EncryptionAtRestOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.LoggingOptions
class LoggingOptionsDef(BaseStruct):
    app_log_enabled: typing.Optional[bool] = pydantic.Field(None, description='Specify if Amazon OpenSearch Service application logging should be set up. Requires Elasticsearch version 5.1 or later or OpenSearch version 1.0 or later. Default: - false\n')
    app_log_group: typing.Optional[typing.Union[models.aws_logs.LogGroupDef]] = pydantic.Field(None, description='Log Amazon OpenSearch Service application logs to this log group. Default: - a new log group is created if app logging is enabled\n')
    audit_log_enabled: typing.Optional[bool] = pydantic.Field(None, description='Specify if Amazon OpenSearch Service audit logging should be set up. Requires Elasticsearch version 6.7 or later or OpenSearch version 1.0 or later and fine grained access control to be enabled. Default: - false\n')
    audit_log_group: typing.Optional[typing.Union[models.aws_logs.LogGroupDef]] = pydantic.Field(None, description='Log Amazon OpenSearch Service audit logs to this log group. Default: - a new log group is created if audit logging is enabled\n')
    slow_index_log_enabled: typing.Optional[bool] = pydantic.Field(None, description='Specify if slow index logging should be set up. Requires Elasticsearch version 5.1 or later or OpenSearch version 1.0 or later. Default: - false\n')
    slow_index_log_group: typing.Optional[typing.Union[models.aws_logs.LogGroupDef]] = pydantic.Field(None, description='Log slow indices to this log group. Default: - a new log group is created if slow index logging is enabled\n')
    slow_search_log_enabled: typing.Optional[bool] = pydantic.Field(None, description='Specify if slow search logging should be set up. Requires Elasticsearch version 5.1 or later or OpenSearch version 1.0 or later. Default: - false\n')
    slow_search_log_group: typing.Optional[typing.Union[models.aws_logs.LogGroupDef]] = pydantic.Field(None, description='Log slow searches to this log group. Default: - a new log group is created if slow search logging is enabled\n\n:exampleMetadata: infused\n\nExample::\n\n    prod_domain = Domain(self, "Domain",\n        version=EngineVersion.OPENSEARCH_1_0,\n        capacity=CapacityConfig(\n            master_nodes=5,\n            data_nodes=20\n        ),\n        ebs=EbsOptions(\n            volume_size=20\n        ),\n        zone_awareness=ZoneAwarenessConfig(\n            availability_zone_count=3\n        ),\n        logging=LoggingOptions(\n            slow_search_log_enabled=True,\n            app_log_enabled=True,\n            slow_index_log_enabled=True\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['app_log_enabled', 'app_log_group', 'audit_log_enabled', 'audit_log_group', 'slow_index_log_enabled', 'slow_index_log_group', 'slow_search_log_enabled', 'slow_search_log_group']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.LoggingOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.SAMLOptionsProperty
class SAMLOptionsPropertyDef(BaseStruct):
    idp_entity_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique entity ID of the application in the SAML identity provider.\n')
    idp_metadata_content: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The metadata of the SAML application, in XML format.\n')
    master_backend_role: typing.Optional[str] = pydantic.Field(None, description='The backend role that the SAML master user is mapped to. Any users with this backend role receives full permission in OpenSearch Dashboards/Kibana. To use a SAML master backend role, configure the ``rolesKey`` property. Default: - The master user is not mapped to a backend role\n')
    master_user_name: typing.Optional[str] = pydantic.Field(None, description="The SAML master username, which is stored in the domain's internal user database. This SAML user receives full permission in OpenSearch Dashboards/Kibana. Creating a new master username does not delete any existing master usernames. Default: - No master user name is configured\n")
    roles_key: typing.Optional[str] = pydantic.Field(None, description='Element of the SAML assertion to use for backend roles. Default: - roles\n')
    session_timeout_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='The duration, in minutes, after which a user session becomes inactive. Default: - 60\n')
    subject_key: typing.Optional[str] = pydantic.Field(None, description='Element of the SAML assertion to use for the user name. Default: - NameID element of the SAML assertion fot the user name\n\n:exampleMetadata: infused\n\nExample::\n\n    domain = Domain(self, "Domain",\n        version=EngineVersion.OPENSEARCH_1_0,\n        enforce_https=True,\n        node_to_node_encryption=True,\n        encryption_at_rest=EncryptionAtRestOptions(\n            enabled=True\n        ),\n        fine_grained_access_control=AdvancedSecurityOptions(\n            master_user_name="master-user",\n            saml_authentication_enabled=True,\n            saml_authentication_options=SAMLOptionsProperty(\n                idp_entity_id="entity-id",\n                idp_metadata_content="metadata-content-with-quotes-escaped"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['idp_entity_id', 'idp_metadata_content', 'master_backend_role', 'master_user_name', 'roles_key', 'session_timeout_minutes', 'subject_key']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.SAMLOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.WindowStartTime
class WindowStartTimeDef(BaseStruct):
    hours: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The start hour of the window in Coordinated Universal Time (UTC), using 24-hour time. For example, 17 refers to 5:00 P.M. UTC. Default: - 22')
    minutes: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The start minute of the window, in UTC. Default: - 0\n\n:exampleMetadata: infused\n\nExample::\n\n    domain = Domain(self, "Domain",\n        version=EngineVersion.OPENSEARCH_1_3,\n        off_peak_window_enabled=True,  # can be omitted if offPeakWindowStart is set\n        off_peak_window_start=WindowStartTime(\n            hours=20,\n            minutes=0\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['hours', 'minutes']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.WindowStartTime'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.ZoneAwarenessConfig
class ZoneAwarenessConfigDef(BaseStruct):
    availability_zone_count: typing.Union[int, float, None] = pydantic.Field(None, description='If you enabled multiple Availability Zones (AZs), the number of AZs that you want the domain to use. Valid values are 2 and 3. Default: - 2 if zone awareness is enabled.\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to enable zone awareness for the Amazon OpenSearch Service domain. When you enable zone awareness, Amazon OpenSearch Service allocates the nodes and replica index shards that belong to a cluster across two Availability Zones (AZs) in the same region to prevent data loss and minimize downtime in the event of node or data center failure. Don\'t enable zone awareness if your cluster has no replica index shards or is a single-node cluster. For more information, see [Configuring a Multi-AZ Domain] (https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html) in the Amazon OpenSearch Service Developer Guide. Default: - false\n\n:exampleMetadata: infused\n\nExample::\n\n    domain = Domain(self, "Domain",\n        version=EngineVersion.OPENSEARCH_1_3,\n        ebs=EbsOptions(\n            volume_size=10,\n            volume_type=ec2.EbsDeviceVolumeType.GENERAL_PURPOSE_SSD_GP3\n        ),\n        zone_awareness=ZoneAwarenessConfig(\n            enabled=True,\n            availability_zone_count=3\n        ),\n        capacity=CapacityConfig(\n            multi_az_with_standby_enabled=True,\n            master_nodes=3,\n            data_nodes=3\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone_count', 'enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.ZoneAwarenessConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_opensearchservice.TLSSecurityPolicy
# skipping emum

#  autogenerated from aws_cdk.aws_opensearchservice.IDomain
#  skipping Interface

#  autogenerated from aws_cdk.aws_opensearchservice.CfnDomain
class CfnDomainDef(BaseCfnResource):
    access_policies: typing.Any = pydantic.Field(None, description='An AWS Identity and Access Management ( IAM ) policy document that specifies who can access the OpenSearch Service domain and their permissions. For more information, see `Configuring access policies <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/ac.html#ac-creating>`_ in the *Amazon OpenSearch Service Developer Guide* .\n')
    advanced_options: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='Additional options to specify for the OpenSearch Service domain. For more information, see `AdvancedOptions <https://docs.aws.amazon.com/opensearch-service/latest/APIReference/API_CreateDomain.html#API_CreateDomain_RequestBody>`_ in the OpenSearch Service API reference.\n')
    advanced_security_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_AdvancedSecurityOptionsInputPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies options for fine-grained access control and SAML authentication. If you specify advanced security options, you must also enable node-to-node encryption ( `NodeToNodeEncryptionOptions <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-nodetonodeencryptionoptions.html>`_ ) and encryption at rest ( `EncryptionAtRestOptions <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-encryptionatrestoptions.html>`_ ). You must also enable ``EnforceHTTPS`` within `DomainEndpointOptions <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-domainendpointoptions.html>`_ , which requires HTTPS for all traffic to the domain.\n')
    cluster_config: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_ClusterConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Container for the cluster configuration of a domain.\n')
    cognito_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_CognitoOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configures OpenSearch Service to use Amazon Cognito authentication for OpenSearch Dashboards.\n')
    domain_arn: typing.Optional[str] = pydantic.Field(None, description='')
    domain_endpoint_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_DomainEndpointOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies additional options for the domain endpoint, such as whether to require HTTPS for all traffic or whether to use a custom endpoint rather than the default endpoint.\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description="A name for the OpenSearch Service domain. The name must have a minimum length of 3 and a maximum length of 28. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the domain name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ . Required when creating a new domain. .. epigraph:: If you specify a name, you can't perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.\n")
    ebs_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_EBSOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configurations of Amazon Elastic Block Store (Amazon EBS) volumes that are attached to data nodes in the OpenSearch Service domain. For more information, see `EBS volume size limits <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/limits.html#ebsresource>`_ in the *Amazon OpenSearch Service Developer Guide* .\n')
    encryption_at_rest_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_EncryptionAtRestOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether the domain should encrypt data at rest, and if so, the AWS KMS key to use. See `Encryption of data at rest for Amazon OpenSearch Service <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/encryption-at-rest.html>`_ .\n')
    engine_version: typing.Optional[str] = pydantic.Field(None, description='The version of OpenSearch to use. The value must be in the format ``OpenSearch_X.Y`` or ``Elasticsearch_X.Y`` . If not specified, the latest version of OpenSearch is used. For information about the versions that OpenSearch Service supports, see `Supported versions of OpenSearch and Elasticsearch <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/what-is.html#choosing-version>`_ in the *Amazon OpenSearch Service Developer Guide* . If you set the `EnableVersionUpgrade <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-updatepolicy.html#cfn-attributes-updatepolicy-upgradeopensearchdomain>`_ update policy to ``true`` , you can update ``EngineVersion`` without interruption. When ``EnableVersionUpgrade`` is set to ``false`` , or is not specified, updating ``EngineVersion`` results in `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .\n')
    log_publishing_options: typing.Union[models.UnsupportedResource, typing.Mapping[str, typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_LogPublishingOptionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An object with one or more of the following keys: ``SEARCH_SLOW_LOGS`` , ``ES_APPLICATION_LOGS`` , ``INDEX_SLOW_LOGS`` , ``AUDIT_LOGS`` , depending on the types of logs you want to publish. Each key needs a valid ``LogPublishingOption`` value. For the full syntax, see the `examples <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-opensearchservice-domain.html#aws-resource-opensearchservice-domain--examples>`_ .\n')
    node_to_node_encryption_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_NodeToNodeEncryptionOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies whether node-to-node encryption is enabled. See `Node-to-node encryption for Amazon OpenSearch Service <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/ntn.html>`_ .\n')
    off_peak_window_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_OffPeakWindowOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Options for a domain's off-peak window, during which OpenSearch Service can perform mandatory configuration changes on the domain.\n")
    snapshot_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_SnapshotOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='*DEPRECATED* . The automated snapshot configuration for the OpenSearch Service domain indexes.\n')
    software_update_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_SoftwareUpdateOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Options for configuring service software updates for a domain.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An arbitrary set of tags (keyvalue pairs) to associate with the OpenSearch Service domain.\n')
    vpc_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_VPCOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The virtual private cloud (VPC) configuration for the OpenSearch Service domain. For more information, see `Launching your Amazon OpenSearch Service domains within a VPC <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html>`_ in the *Amazon OpenSearch Service Developer Guide* . If you remove this entity altogether, along with its associated properties, it causes a replacement. You might encounter this scenario if you're updating your security configuration from a VPC to a public endpoint.")
    _init_params: typing.ClassVar[list[str]] = ['access_policies', 'advanced_options', 'advanced_security_options', 'cluster_config', 'cognito_options', 'domain_arn', 'domain_endpoint_options', 'domain_name', 'ebs_options', 'encryption_at_rest_options', 'engine_version', 'log_publishing_options', 'node_to_node_encryption_options', 'off_peak_window_options', 'snapshot_options', 'software_update_options', 'tags', 'vpc_options']
    _method_names: typing.ClassVar[list[str]] = ['AdvancedSecurityOptionsInputProperty', 'ClusterConfigProperty', 'CognitoOptionsProperty', 'DomainEndpointOptionsProperty', 'EBSOptionsProperty', 'EncryptionAtRestOptionsProperty', 'IdpProperty', 'LogPublishingOptionProperty', 'MasterUserOptionsProperty', 'NodeToNodeEncryptionOptionsProperty', 'OffPeakWindowOptionsProperty', 'OffPeakWindowProperty', 'SAMLOptionsProperty', 'ServiceSoftwareOptionsProperty', 'SnapshotOptionsProperty', 'SoftwareUpdateOptionsProperty', 'VPCOptionsProperty', 'WindowStartTimeProperty', 'ZoneAwarenessConfigProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CfnDomain'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_opensearchservice.CfnDomainDefConfig] = pydantic.Field(None)


class CfnDomainDefConfig(pydantic.BaseModel):
    AdvancedSecurityOptionsInputProperty: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefAdvancedsecurityoptionsinputpropertyParams]] = pydantic.Field(None, description='')
    ClusterConfigProperty: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefClusterconfigpropertyParams]] = pydantic.Field(None, description='')
    CognitoOptionsProperty: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefCognitooptionspropertyParams]] = pydantic.Field(None, description='')
    DomainEndpointOptionsProperty: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefDomainendpointoptionspropertyParams]] = pydantic.Field(None, description='')
    EBSOptionsProperty: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefEbsoptionspropertyParams]] = pydantic.Field(None, description='')
    EncryptionAtRestOptionsProperty: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefEncryptionatrestoptionspropertyParams]] = pydantic.Field(None, description='')
    IdpProperty: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefIdppropertyParams]] = pydantic.Field(None, description='')
    LogPublishingOptionProperty: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefLogpublishingoptionpropertyParams]] = pydantic.Field(None, description='')
    MasterUserOptionsProperty: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefMasteruseroptionspropertyParams]] = pydantic.Field(None, description='')
    NodeToNodeEncryptionOptionsProperty: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefNodetonodeencryptionoptionspropertyParams]] = pydantic.Field(None, description='')
    OffPeakWindowOptionsProperty: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefOffpeakwindowoptionspropertyParams]] = pydantic.Field(None, description='')
    OffPeakWindowProperty: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefOffpeakwindowpropertyParams]] = pydantic.Field(None, description='')
    SAMLOptionsProperty: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefSamloptionspropertyParams]] = pydantic.Field(None, description='')
    ServiceSoftwareOptionsProperty: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefServicesoftwareoptionspropertyParams]] = pydantic.Field(None, description='')
    SnapshotOptionsProperty: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefSnapshotoptionspropertyParams]] = pydantic.Field(None, description='')
    SoftwareUpdateOptionsProperty: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefSoftwareupdateoptionspropertyParams]] = pydantic.Field(None, description='')
    VPCOptionsProperty: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefVpcoptionspropertyParams]] = pydantic.Field(None, description='')
    WindowStartTimeProperty: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefWindowstarttimepropertyParams]] = pydantic.Field(None, description='')
    ZoneAwarenessConfigProperty: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefZoneawarenessconfigpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_opensearchservice.CfnDomainDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_domain_endpoints_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_service_software_options_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_service_software_options_cancellable_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_service_software_options_optional_deployment_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_service_software_options_update_available_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDomainDefAdvancedsecurityoptionsinputpropertyParams(pydantic.BaseModel):
    anonymous_auth_disable_date: typing.Optional[str] = pydantic.Field(None, description='')
    anonymous_auth_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    internal_user_database_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    master_user_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_MasterUserOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    saml_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_SAMLOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnDomainDefClusterconfigpropertyParams(pydantic.BaseModel):
    dedicated_master_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    dedicated_master_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    dedicated_master_type: typing.Optional[str] = pydantic.Field(None, description='')
    instance_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    instance_type: typing.Optional[str] = pydantic.Field(None, description='')
    multi_az_with_standby_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    warm_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    warm_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    warm_type: typing.Optional[str] = pydantic.Field(None, description='')
    zone_awareness_config: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_ZoneAwarenessConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    zone_awareness_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnDomainDefCognitooptionspropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    identity_pool_id: typing.Optional[str] = pydantic.Field(None, description='')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='')
    user_pool_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDomainDefDomainendpointoptionspropertyParams(pydantic.BaseModel):
    custom_endpoint: typing.Optional[str] = pydantic.Field(None, description='')
    custom_endpoint_certificate_arn: typing.Optional[str] = pydantic.Field(None, description='')
    custom_endpoint_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    enforce_https: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    tls_security_policy: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDomainDefEbsoptionspropertyParams(pydantic.BaseModel):
    ebs_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='')
    throughput: typing.Union[int, float, None] = pydantic.Field(None, description='')
    volume_size: typing.Union[int, float, None] = pydantic.Field(None, description='')
    volume_type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDomainDefEncryptionatrestoptionspropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDomainDefIdppropertyParams(pydantic.BaseModel):
    entity_id: str = pydantic.Field(..., description='')
    metadata_content: str = pydantic.Field(..., description='')
    ...

class CfnDomainDefLogpublishingoptionpropertyParams(pydantic.BaseModel):
    cloud_watch_logs_log_group_arn: typing.Optional[str] = pydantic.Field(None, description='')
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnDomainDefMasteruseroptionspropertyParams(pydantic.BaseModel):
    master_user_arn: typing.Optional[str] = pydantic.Field(None, description='')
    master_user_name: typing.Optional[str] = pydantic.Field(None, description='')
    master_user_password: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDomainDefNodetonodeencryptionoptionspropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnDomainDefOffpeakwindowoptionspropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    off_peak_window: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_OffPeakWindowPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnDomainDefOffpeakwindowpropertyParams(pydantic.BaseModel):
    window_start_time: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_WindowStartTimePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnDomainDefSamloptionspropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    idp: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_IdpPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    master_backend_role: typing.Optional[str] = pydantic.Field(None, description='')
    master_user_name: typing.Optional[str] = pydantic.Field(None, description='')
    roles_key: typing.Optional[str] = pydantic.Field(None, description='')
    session_timeout_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='')
    subject_key: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDomainDefServicesoftwareoptionspropertyParams(pydantic.BaseModel):
    automated_update_date: typing.Optional[str] = pydantic.Field(None, description='')
    cancellable: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    current_version: typing.Optional[str] = pydantic.Field(None, description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    new_version: typing.Optional[str] = pydantic.Field(None, description='')
    optional_deployment: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    update_available: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    update_status: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDomainDefSnapshotoptionspropertyParams(pydantic.BaseModel):
    automated_snapshot_start_hour: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnDomainDefSoftwareupdateoptionspropertyParams(pydantic.BaseModel):
    auto_software_update_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnDomainDefVpcoptionspropertyParams(pydantic.BaseModel):
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnDomainDefWindowstarttimepropertyParams(pydantic.BaseModel):
    hours: typing.Union[int, float] = pydantic.Field(..., description='')
    minutes: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnDomainDefZoneawarenessconfigpropertyParams(pydantic.BaseModel):
    availability_zone_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnDomainDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDomainDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDomainDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDomainDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDomainDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDomainDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDomainDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDomainDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDomainDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDomainDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDomainDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDomainDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDomainDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDomainDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_opensearchservice.CfnDomainProps
class CfnDomainPropsDef(BaseCfnProperty):
    access_policies: typing.Any = pydantic.Field(None, description='An AWS Identity and Access Management ( IAM ) policy document that specifies who can access the OpenSearch Service domain and their permissions. For more information, see `Configuring access policies <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/ac.html#ac-creating>`_ in the *Amazon OpenSearch Service Developer Guide* .\n')
    advanced_options: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='Additional options to specify for the OpenSearch Service domain. For more information, see `AdvancedOptions <https://docs.aws.amazon.com/opensearch-service/latest/APIReference/API_CreateDomain.html#API_CreateDomain_RequestBody>`_ in the OpenSearch Service API reference.\n')
    advanced_security_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_AdvancedSecurityOptionsInputPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies options for fine-grained access control and SAML authentication. If you specify advanced security options, you must also enable node-to-node encryption ( `NodeToNodeEncryptionOptions <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-nodetonodeencryptionoptions.html>`_ ) and encryption at rest ( `EncryptionAtRestOptions <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-encryptionatrestoptions.html>`_ ). You must also enable ``EnforceHTTPS`` within `DomainEndpointOptions <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-opensearchservice-domain-domainendpointoptions.html>`_ , which requires HTTPS for all traffic to the domain.\n')
    cluster_config: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_ClusterConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Container for the cluster configuration of a domain.\n')
    cognito_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_CognitoOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configures OpenSearch Service to use Amazon Cognito authentication for OpenSearch Dashboards.\n')
    domain_arn: typing.Optional[str] = pydantic.Field(None, description='')
    domain_endpoint_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_DomainEndpointOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies additional options for the domain endpoint, such as whether to require HTTPS for all traffic or whether to use a custom endpoint rather than the default endpoint.\n')
    domain_name: typing.Optional[str] = pydantic.Field(None, description="A name for the OpenSearch Service domain. The name must have a minimum length of 3 and a maximum length of 28. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the domain name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ . Required when creating a new domain. .. epigraph:: If you specify a name, you can't perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.\n")
    ebs_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_EBSOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configurations of Amazon Elastic Block Store (Amazon EBS) volumes that are attached to data nodes in the OpenSearch Service domain. For more information, see `EBS volume size limits <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/limits.html#ebsresource>`_ in the *Amazon OpenSearch Service Developer Guide* .\n')
    encryption_at_rest_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_EncryptionAtRestOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Whether the domain should encrypt data at rest, and if so, the AWS KMS key to use. See `Encryption of data at rest for Amazon OpenSearch Service <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/encryption-at-rest.html>`_ .\n')
    engine_version: typing.Optional[str] = pydantic.Field(None, description='The version of OpenSearch to use. The value must be in the format ``OpenSearch_X.Y`` or ``Elasticsearch_X.Y`` . If not specified, the latest version of OpenSearch is used. For information about the versions that OpenSearch Service supports, see `Supported versions of OpenSearch and Elasticsearch <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/what-is.html#choosing-version>`_ in the *Amazon OpenSearch Service Developer Guide* . If you set the `EnableVersionUpgrade <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-updatepolicy.html#cfn-attributes-updatepolicy-upgradeopensearchdomain>`_ update policy to ``true`` , you can update ``EngineVersion`` without interruption. When ``EnableVersionUpgrade`` is set to ``false`` , or is not specified, updating ``EngineVersion`` results in `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .\n')
    log_publishing_options: typing.Union[models.UnsupportedResource, typing.Mapping[str, typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_LogPublishingOptionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An object with one or more of the following keys: ``SEARCH_SLOW_LOGS`` , ``ES_APPLICATION_LOGS`` , ``INDEX_SLOW_LOGS`` , ``AUDIT_LOGS`` , depending on the types of logs you want to publish. Each key needs a valid ``LogPublishingOption`` value. For the full syntax, see the `examples <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-opensearchservice-domain.html#aws-resource-opensearchservice-domain--examples>`_ .\n')
    node_to_node_encryption_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_NodeToNodeEncryptionOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies whether node-to-node encryption is enabled. See `Node-to-node encryption for Amazon OpenSearch Service <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/ntn.html>`_ .\n')
    off_peak_window_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_OffPeakWindowOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Options for a domain's off-peak window, during which OpenSearch Service can perform mandatory configuration changes on the domain.\n")
    snapshot_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_SnapshotOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='*DEPRECATED* . The automated snapshot configuration for the OpenSearch Service domain indexes.\n')
    software_update_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_SoftwareUpdateOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Options for configuring service software updates for a domain.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An arbitrary set of tags (keyvalue pairs) to associate with the OpenSearch Service domain.\n')
    vpc_options: typing.Union[models.UnsupportedResource, models.aws_opensearchservice.CfnDomain_VPCOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The virtual private cloud (VPC) configuration for the OpenSearch Service domain. For more information, see `Launching your Amazon OpenSearch Service domains within a VPC <https://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html>`_ in the *Amazon OpenSearch Service Developer Guide* . If you remove this entity altogether, along with its associated properties, it causes a replacement. You might encounter this scenario if you\'re updating your security configuration from a VPC to a public endpoint.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-opensearchservice-domain.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_opensearchservice as opensearchservice\n\n    # access_policies: Any\n\n    cfn_domain_props = opensearchservice.CfnDomainProps(\n        access_policies=access_policies,\n        advanced_options={\n            "advanced_options_key": "advancedOptions"\n        },\n        advanced_security_options=opensearchservice.CfnDomain.AdvancedSecurityOptionsInputProperty(\n            anonymous_auth_disable_date="anonymousAuthDisableDate",\n            anonymous_auth_enabled=False,\n            enabled=False,\n            internal_user_database_enabled=False,\n            master_user_options=opensearchservice.CfnDomain.MasterUserOptionsProperty(\n                master_user_arn="masterUserArn",\n                master_user_name="masterUserName",\n                master_user_password="masterUserPassword"\n            ),\n            saml_options=opensearchservice.CfnDomain.SAMLOptionsProperty(\n                enabled=False,\n                idp=opensearchservice.CfnDomain.IdpProperty(\n                    entity_id="entityId",\n                    metadata_content="metadataContent"\n                ),\n                master_backend_role="masterBackendRole",\n                master_user_name="masterUserName",\n                roles_key="rolesKey",\n                session_timeout_minutes=123,\n                subject_key="subjectKey"\n            )\n        ),\n        cluster_config=opensearchservice.CfnDomain.ClusterConfigProperty(\n            dedicated_master_count=123,\n            dedicated_master_enabled=False,\n            dedicated_master_type="dedicatedMasterType",\n            instance_count=123,\n            instance_type="instanceType",\n            multi_az_with_standby_enabled=False,\n            warm_count=123,\n            warm_enabled=False,\n            warm_type="warmType",\n            zone_awareness_config=opensearchservice.CfnDomain.ZoneAwarenessConfigProperty(\n                availability_zone_count=123\n            ),\n            zone_awareness_enabled=False\n        ),\n        cognito_options=opensearchservice.CfnDomain.CognitoOptionsProperty(\n            enabled=False,\n            identity_pool_id="identityPoolId",\n            role_arn="roleArn",\n            user_pool_id="userPoolId"\n        ),\n        domain_arn="domainArn",\n        domain_endpoint_options=opensearchservice.CfnDomain.DomainEndpointOptionsProperty(\n            custom_endpoint="customEndpoint",\n            custom_endpoint_certificate_arn="customEndpointCertificateArn",\n            custom_endpoint_enabled=False,\n            enforce_https=False,\n            tls_security_policy="tlsSecurityPolicy"\n        ),\n        domain_name="domainName",\n        ebs_options=opensearchservice.CfnDomain.EBSOptionsProperty(\n            ebs_enabled=False,\n            iops=123,\n            throughput=123,\n            volume_size=123,\n            volume_type="volumeType"\n        ),\n        encryption_at_rest_options=opensearchservice.CfnDomain.EncryptionAtRestOptionsProperty(\n            enabled=False,\n            kms_key_id="kmsKeyId"\n        ),\n        engine_version="engineVersion",\n        log_publishing_options={\n            "log_publishing_options_key": opensearchservice.CfnDomain.LogPublishingOptionProperty(\n                cloud_watch_logs_log_group_arn="cloudWatchLogsLogGroupArn",\n                enabled=False\n            )\n        },\n        node_to_node_encryption_options=opensearchservice.CfnDomain.NodeToNodeEncryptionOptionsProperty(\n            enabled=False\n        ),\n        off_peak_window_options=opensearchservice.CfnDomain.OffPeakWindowOptionsProperty(\n            enabled=False,\n            off_peak_window=opensearchservice.CfnDomain.OffPeakWindowProperty(\n                window_start_time=opensearchservice.CfnDomain.WindowStartTimeProperty(\n                    hours=123,\n                    minutes=123\n                )\n            )\n        ),\n        snapshot_options=opensearchservice.CfnDomain.SnapshotOptionsProperty(\n            automated_snapshot_start_hour=123\n        ),\n        software_update_options=opensearchservice.CfnDomain.SoftwareUpdateOptionsProperty(\n            auto_software_update_enabled=False\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        vpc_options=opensearchservice.CfnDomain.VPCOptionsProperty(\n            security_group_ids=["securityGroupIds"],\n            subnet_ids=["subnetIds"]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['access_policies', 'advanced_options', 'advanced_security_options', 'cluster_config', 'cognito_options', 'domain_arn', 'domain_endpoint_options', 'domain_name', 'ebs_options', 'encryption_at_rest_options', 'engine_version', 'log_publishing_options', 'node_to_node_encryption_options', 'off_peak_window_options', 'snapshot_options', 'software_update_options', 'tags', 'vpc_options']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_opensearchservice.CfnDomainProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    EngineVersion: typing.Optional[dict[str, models.aws_opensearchservice.EngineVersionDef]] = pydantic.Field(None)
    Domain: typing.Optional[dict[str, models.aws_opensearchservice.DomainDef]] = pydantic.Field(None)
    AdvancedSecurityOptions: typing.Optional[dict[str, models.aws_opensearchservice.AdvancedSecurityOptionsDef]] = pydantic.Field(None)
    CapacityConfig: typing.Optional[dict[str, models.aws_opensearchservice.CapacityConfigDef]] = pydantic.Field(None)
    CfnDomain_AdvancedSecurityOptionsInputProperty: typing.Optional[dict[str, models.aws_opensearchservice.CfnDomain_AdvancedSecurityOptionsInputPropertyDef]] = pydantic.Field(None)
    CfnDomain_ClusterConfigProperty: typing.Optional[dict[str, models.aws_opensearchservice.CfnDomain_ClusterConfigPropertyDef]] = pydantic.Field(None)
    CfnDomain_CognitoOptionsProperty: typing.Optional[dict[str, models.aws_opensearchservice.CfnDomain_CognitoOptionsPropertyDef]] = pydantic.Field(None)
    CfnDomain_DomainEndpointOptionsProperty: typing.Optional[dict[str, models.aws_opensearchservice.CfnDomain_DomainEndpointOptionsPropertyDef]] = pydantic.Field(None)
    CfnDomain_EBSOptionsProperty: typing.Optional[dict[str, models.aws_opensearchservice.CfnDomain_EBSOptionsPropertyDef]] = pydantic.Field(None)
    CfnDomain_EncryptionAtRestOptionsProperty: typing.Optional[dict[str, models.aws_opensearchservice.CfnDomain_EncryptionAtRestOptionsPropertyDef]] = pydantic.Field(None)
    CfnDomain_IdpProperty: typing.Optional[dict[str, models.aws_opensearchservice.CfnDomain_IdpPropertyDef]] = pydantic.Field(None)
    CfnDomain_LogPublishingOptionProperty: typing.Optional[dict[str, models.aws_opensearchservice.CfnDomain_LogPublishingOptionPropertyDef]] = pydantic.Field(None)
    CfnDomain_MasterUserOptionsProperty: typing.Optional[dict[str, models.aws_opensearchservice.CfnDomain_MasterUserOptionsPropertyDef]] = pydantic.Field(None)
    CfnDomain_NodeToNodeEncryptionOptionsProperty: typing.Optional[dict[str, models.aws_opensearchservice.CfnDomain_NodeToNodeEncryptionOptionsPropertyDef]] = pydantic.Field(None)
    CfnDomain_OffPeakWindowOptionsProperty: typing.Optional[dict[str, models.aws_opensearchservice.CfnDomain_OffPeakWindowOptionsPropertyDef]] = pydantic.Field(None)
    CfnDomain_OffPeakWindowProperty: typing.Optional[dict[str, models.aws_opensearchservice.CfnDomain_OffPeakWindowPropertyDef]] = pydantic.Field(None)
    CfnDomain_SAMLOptionsProperty: typing.Optional[dict[str, models.aws_opensearchservice.CfnDomain_SAMLOptionsPropertyDef]] = pydantic.Field(None)
    CfnDomain_ServiceSoftwareOptionsProperty: typing.Optional[dict[str, models.aws_opensearchservice.CfnDomain_ServiceSoftwareOptionsPropertyDef]] = pydantic.Field(None)
    CfnDomain_SnapshotOptionsProperty: typing.Optional[dict[str, models.aws_opensearchservice.CfnDomain_SnapshotOptionsPropertyDef]] = pydantic.Field(None)
    CfnDomain_SoftwareUpdateOptionsProperty: typing.Optional[dict[str, models.aws_opensearchservice.CfnDomain_SoftwareUpdateOptionsPropertyDef]] = pydantic.Field(None)
    CfnDomain_VPCOptionsProperty: typing.Optional[dict[str, models.aws_opensearchservice.CfnDomain_VPCOptionsPropertyDef]] = pydantic.Field(None)
    CfnDomain_WindowStartTimeProperty: typing.Optional[dict[str, models.aws_opensearchservice.CfnDomain_WindowStartTimePropertyDef]] = pydantic.Field(None)
    CfnDomain_ZoneAwarenessConfigProperty: typing.Optional[dict[str, models.aws_opensearchservice.CfnDomain_ZoneAwarenessConfigPropertyDef]] = pydantic.Field(None)
    CognitoOptions: typing.Optional[dict[str, models.aws_opensearchservice.CognitoOptionsDef]] = pydantic.Field(None)
    CustomEndpointOptions: typing.Optional[dict[str, models.aws_opensearchservice.CustomEndpointOptionsDef]] = pydantic.Field(None)
    DomainAttributes: typing.Optional[dict[str, models.aws_opensearchservice.DomainAttributesDef]] = pydantic.Field(None)
    DomainProps: typing.Optional[dict[str, models.aws_opensearchservice.DomainPropsDef]] = pydantic.Field(None)
    EbsOptions: typing.Optional[dict[str, models.aws_opensearchservice.EbsOptionsDef]] = pydantic.Field(None)
    EncryptionAtRestOptions: typing.Optional[dict[str, models.aws_opensearchservice.EncryptionAtRestOptionsDef]] = pydantic.Field(None)
    LoggingOptions: typing.Optional[dict[str, models.aws_opensearchservice.LoggingOptionsDef]] = pydantic.Field(None)
    SAMLOptionsProperty: typing.Optional[dict[str, models.aws_opensearchservice.SAMLOptionsPropertyDef]] = pydantic.Field(None)
    WindowStartTime: typing.Optional[dict[str, models.aws_opensearchservice.WindowStartTimeDef]] = pydantic.Field(None)
    ZoneAwarenessConfig: typing.Optional[dict[str, models.aws_opensearchservice.ZoneAwarenessConfigDef]] = pydantic.Field(None)
    CfnDomain: typing.Optional[dict[str, models.aws_opensearchservice.CfnDomainDef]] = pydantic.Field(None)
    CfnDomainProps: typing.Optional[dict[str, models.aws_opensearchservice.CfnDomainPropsDef]] = pydantic.Field(None)
    ...

import models
