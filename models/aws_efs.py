from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_efs.ReplicationConfiguration
class ReplicationConfigurationDef(BaseClass):
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The availability zone name of the destination file system. One zone file system is used as the destination file system when this property is set. Default: - no availability zone is set')
    destination_file_system: typing.Optional[typing.Union[models.aws_efs.FileSystemDef]] = pydantic.Field(None, description='The existing destination file system for the replication. Default: - None\n')
    kms_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='AWS KMS key used to protect the encrypted file system. Default: - use service-managed KMS key for Amazon EFS\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The AWS Region in which the destination file system is located. Default: - the region of the stack')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'destination_file_system', 'kms_key', 'region']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['existing_file_system', 'one_zone_file_system', 'regional_file_system']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.ReplicationConfiguration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_efs.ReplicationConfigurationDefConfig] = pydantic.Field(None)


class ReplicationConfigurationDefConfig(pydantic.BaseModel):
    existing_file_system: typing.Optional[list[models.aws_efs.ReplicationConfigurationDefExistingFileSystemParams]] = pydantic.Field(None, description='Specify the existing destination file system for the replication.')
    one_zone_file_system: typing.Optional[list[models.aws_efs.ReplicationConfigurationDefOneZoneFileSystemParams]] = pydantic.Field(None, description='Create a new one zone destination file system for the replication.')
    regional_file_system: typing.Optional[list[models.aws_efs.ReplicationConfigurationDefRegionalFileSystemParams]] = pydantic.Field(None, description='Create a new regional destination file system for the replication.')

class ReplicationConfigurationDefExistingFileSystemParams(pydantic.BaseModel):
    destination_file_system: typing.Union[models.aws_efs.FileSystemDef] = pydantic.Field(..., description='The existing destination file system for the replication.')
    return_config: typing.Optional[list[models.aws_efs.ReplicationConfigurationDefConfig]] = pydantic.Field(None)
    ...

class ReplicationConfigurationDefOneZoneFileSystemParams(pydantic.BaseModel):
    region: str = pydantic.Field(..., description='The AWS Region in which the specified availability zone belongs to.\n')
    availability_zone: str = pydantic.Field(..., description='The availability zone name of the destination file system.\n')
    kms_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='AWS KMS key used to protect the encrypted file system. Default is service-managed KMS key for Amazon EFS.')
    return_config: typing.Optional[list[models.aws_efs.ReplicationConfigurationDefConfig]] = pydantic.Field(None)
    ...

class ReplicationConfigurationDefRegionalFileSystemParams(pydantic.BaseModel):
    region: typing.Optional[str] = pydantic.Field(None, description='The AWS Region in which the destination file system is located. Default is the region of the stack.\n')
    kms_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='AWS KMS key used to protect the encrypted file system. Default is service-managed KMS key for Amazon EFS.')
    return_config: typing.Optional[list[models.aws_efs.ReplicationConfigurationDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_efs.AccessPoint
class AccessPointDef(BaseConstruct):
    file_system: typing.Union[_REQUIRED_INIT_PARAM, models.aws_efs.FileSystemDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The efs filesystem.\n')
    create_acl: typing.Union[models.aws_efs.AclDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Specifies the POSIX IDs and permissions to apply when creating the access point's root directory. If the root directory specified by ``path`` does not exist, EFS creates the root directory and applies the permissions specified here. If the specified ``path`` does not exist, you must specify ``createAcl``. Default: - None. The directory specified by ``path`` must exist.\n")
    path: typing.Optional[str] = pydantic.Field(None, description="Specifies the path on the EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system. Default: '/'\n")
    posix_user: typing.Union[models.aws_efs.PosixUserDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The full POSIX identity, including the user ID, group ID, and any secondary group IDs, on the access point that is used for all file system operations performed by NFS clients using the access point. Specify this to enforce a user identity using an access point. Default: - user identity not enforced')
    _init_params: typing.ClassVar[list[str]] = ['file_system', 'create_acl', 'path', 'posix_user']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_access_point_attributes', 'from_access_point_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.AccessPoint'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_access_point_attributes', 'from_access_point_id']
    ...


    from_access_point_attributes: typing.Optional[models.aws_efs.AccessPointDefFromAccessPointAttributesParams] = pydantic.Field(None, description='Import an existing Access Point by attributes.')
    from_access_point_id: typing.Optional[models.aws_efs.AccessPointDefFromAccessPointIdParams] = pydantic.Field(None, description='Import an existing Access Point by id.')
    resource_config: typing.Optional[models.aws_efs.AccessPointDefConfig] = pydantic.Field(None)


class AccessPointDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    file_system_config: typing.Optional[models._interface_methods.AwsEfsIFileSystemDefConfig] = pydantic.Field(None)

class AccessPointDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class AccessPointDefFromAccessPointAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    access_point_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the AccessPoint One of this, or ``accessPointId`` is required. Default: - determined based on accessPointId\n')
    access_point_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the AccessPoint One of this, or ``accessPointArn`` is required. Default: - determined based on accessPointArn\n')
    file_system: typing.Optional[typing.Union[models.aws_efs.FileSystemDef]] = pydantic.Field(None, description='The EFS file system. Default: - no EFS file system')
    ...

class AccessPointDefFromAccessPointIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    access_point_id: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_efs.FileSystem
class FileSystemDef(BaseConstruct):
    vpc: typing.Union[_REQUIRED_INIT_PARAM, models.aws_ec2.VpcDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='VPC to launch the file system in.\n')
    allow_anonymous_access: typing.Optional[bool] = pydantic.Field(None, description="Allow access from anonymous client that doesn't use IAM authentication. Default: false when using ``grantRead``, ``grantWrite``, ``grantRootAccess`` or set ``@aws-cdk/aws-efs:denyAnonymousAccess`` feature flag, otherwise true\n")
    enable_automatic_backups: typing.Optional[bool] = pydantic.Field(None, description='Whether to enable automatic backups for the file system. Default: false\n')
    encrypted: typing.Optional[bool] = pydantic.Field(None, description="Defines if the data at rest in the file system is encrypted or not. Default: - If your application has the '@aws-cdk/aws-efs:defaultEncryptionAtRest' feature flag set, the default is true, otherwise, the default is false.\n")
    file_system_name: typing.Optional[str] = pydantic.Field(None, description="The file system's name. Default: - CDK generated name\n")
    file_system_policy: typing.Optional[models.aws_iam.PolicyDocumentDef] = pydantic.Field(None, description='File system policy is an IAM resource policy used to control NFS access to an EFS file system. Default: none\n')
    kms_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description="The KMS key used for encryption. This is required to encrypt the data at rest if Default: - if 'encrypted' is true, the default key for EFS (/aws/elasticfilesystem) is used\n")
    lifecycle_policy: typing.Optional[aws_cdk.aws_efs.LifecyclePolicy] = pydantic.Field(None, description='A policy used by EFS lifecycle management to transition files to the Infrequent Access (IA) storage class. Default: - None. EFS will not transition files to the IA storage class.\n')
    one_zone: typing.Optional[bool] = pydantic.Field(None, description='Whether this is a One Zone file system. If enabled, ``performanceMode`` must be set to ``GENERAL_PURPOSE`` and ``vpcSubnets`` cannot be set. Default: false\n')
    out_of_infrequent_access_policy: typing.Optional[aws_cdk.aws_efs.OutOfInfrequentAccessPolicy] = pydantic.Field(None, description='A policy used by EFS lifecycle management to transition files from Infrequent Access (IA) storage class to primary storage class. Default: - None. EFS will not transition files from IA storage to primary storage.\n')
    performance_mode: typing.Optional[aws_cdk.aws_efs.PerformanceMode] = pydantic.Field(None, description="The performance mode that the file system will operate under. An Amazon EFS file system's performance mode can't be changed after the file system has been created. Updating this property will replace the file system. Default: PerformanceMode.GENERAL_PURPOSE\n")
    provisioned_throughput_per_second: typing.Optional[models.SizeDef] = pydantic.Field(None, description='Provisioned throughput for the file system. This is a required property if the throughput mode is set to PROVISIONED. Must be at least 1MiB/s. Default: - none, errors out\n')
    removal_policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='The removal policy to apply to the file system. Default: RemovalPolicy.RETAIN\n')
    replication_configuration: typing.Optional[models.aws_efs.ReplicationConfigurationDef] = pydantic.Field(None, description='Replication configuration for the file system. Default: - no replication\n')
    replication_overwrite_protection: typing.Optional[aws_cdk.aws_efs.ReplicationOverwriteProtection] = pydantic.Field(None, description="Whether to enable the filesystem's replication overwrite protection or not. Set false if you want to create a read-only filesystem for use as a replication destination. Default: ReplicationOverwriteProtection.ENABLED\n")
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='Security Group to assign to this file system. Default: - creates new security group which allows all outbound traffic\n')
    throughput_mode: typing.Optional[aws_cdk.aws_efs.ThroughputMode] = pydantic.Field(None, description='Enum to mention the throughput mode of the file system. Default: ThroughputMode.BURSTING\n')
    transition_to_archive_policy: typing.Optional[aws_cdk.aws_efs.LifecyclePolicy] = pydantic.Field(None, description="The number of days after files were last accessed in primary storage (the Standard storage class) at which to move them to Archive storage. Metadata operations such as listing the contents of a directory don't count as file access events. Default: - None. EFS will not transition files to Archive storage class.\n")
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Which subnets to place the mount target in the VPC. Default: - the Vpc default strategy if not specified')
    _init_params: typing.ClassVar[list[str]] = ['vpc', 'allow_anonymous_access', 'enable_automatic_backups', 'encrypted', 'file_system_name', 'file_system_policy', 'kms_key', 'lifecycle_policy', 'one_zone', 'out_of_infrequent_access_policy', 'performance_mode', 'provisioned_throughput_per_second', 'removal_policy', 'replication_configuration', 'replication_overwrite_protection', 'security_group', 'throughput_mode', 'transition_to_archive_policy', 'vpc_subnets']
    _method_names: typing.ClassVar[list[str]] = ['add_access_point', 'add_to_resource_policy', 'apply_removal_policy', 'grant', 'grant_read', 'grant_read_write', 'grant_root_access']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_file_system_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.FileSystem'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_file_system_attributes']
    ...


    from_file_system_attributes: typing.Optional[models.aws_efs.FileSystemDefFromFileSystemAttributesParams] = pydantic.Field(None, description='Import an existing File System from the given properties.')
    resource_config: typing.Optional[models.aws_efs.FileSystemDefConfig] = pydantic.Field(None)


class FileSystemDefConfig(pydantic.BaseModel):
    add_access_point: typing.Optional[list[models.aws_efs.FileSystemDefAddAccessPointParams]] = pydantic.Field(None, description='create access point from this filesystem.')
    add_to_resource_policy: typing.Optional[list[models.aws_efs.FileSystemDefAddToResourcePolicyParams]] = pydantic.Field(None, description='Adds a statement to the resource policy associated with this file system.\nA resource policy will be automatically created upon the first call to ``addToResourcePolicy``.\n\nNote that this does not work with imported file systems.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    grant: typing.Optional[list[models.aws_efs.FileSystemDefGrantParams]] = pydantic.Field(None, description='Grant the actions defined in actions to the given grantee on this File System resource.')
    grant_read: typing.Optional[list[models.aws_efs.FileSystemDefGrantReadParams]] = pydantic.Field(None, description='Grant read permissions for this file system to an IAM principal.')
    grant_read_write: typing.Optional[list[models.aws_efs.FileSystemDefGrantReadWriteParams]] = pydantic.Field(None, description='Grant read and write permissions for this file system to an IAM principal.')
    grant_root_access: typing.Optional[list[models.aws_efs.FileSystemDefGrantRootAccessParams]] = pydantic.Field(None, description='As root user, grant read and write permissions for this file system to an IAM principal.')
    connections_config: typing.Optional[models.aws_ec2.ConnectionsDefConfig] = pydantic.Field(None)

class FileSystemDefAddAccessPointParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    create_acl: typing.Union[models.aws_efs.AclDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Specifies the POSIX IDs and permissions to apply when creating the access point's root directory. If the root directory specified by ``path`` does not exist, EFS creates the root directory and applies the permissions specified here. If the specified ``path`` does not exist, you must specify ``createAcl``. Default: - None. The directory specified by ``path`` must exist.\n")
    path: typing.Optional[str] = pydantic.Field(None, description="Specifies the path on the EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system. Default: '/'\n")
    posix_user: typing.Union[models.aws_efs.PosixUserDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The full POSIX identity, including the user ID, group ID, and any secondary group IDs, on the access point that is used for all file system operations performed by NFS clients using the access point. Specify this to enforce a user identity using an access point. Default: - user identity not enforced')
    return_config: typing.Optional[list[models.aws_efs.AccessPointDefConfig]] = pydantic.Field(None)
    ...

class FileSystemDefAddToResourcePolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='The policy statement to add.')
    ...

class FileSystemDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class FileSystemDefFromFileSystemAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    security_group: typing.Union[models.aws_ec2.SecurityGroupDef] = pydantic.Field(..., description='The security group of the file system.\n')
    file_system_arn: typing.Optional[str] = pydantic.Field(None, description="The File System's Arn. Default: - determined based on fileSystemId\n")
    file_system_id: typing.Optional[str] = pydantic.Field(None, description="The File System's ID. Default: - determined based on fileSystemArn")
    ...

class FileSystemDefGrantParams(pydantic.BaseModel):
    grantee: models.AnyResource = pydantic.Field(..., description='Principal to grant right to.\n')
    actions: list[str] = pydantic.Field(...)
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class FileSystemDefGrantReadParams(pydantic.BaseModel):
    grantee: models.AnyResource = pydantic.Field(..., description='The principal to grant read to.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class FileSystemDefGrantReadWriteParams(pydantic.BaseModel):
    grantee: models.AnyResource = pydantic.Field(..., description='The principal to grant read and write to.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class FileSystemDefGrantRootAccessParams(pydantic.BaseModel):
    grantee: models.AnyResource = pydantic.Field(..., description='The principal to grant root access to.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_efs.AccessPointAttributes
class AccessPointAttributesDef(BaseStruct):
    access_point_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the AccessPoint One of this, or ``accessPointId`` is required. Default: - determined based on accessPointId\n')
    access_point_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the AccessPoint One of this, or ``accessPointArn`` is required. Default: - determined based on accessPointArn\n')
    file_system: typing.Optional[typing.Union[models.aws_efs.FileSystemDef]] = pydantic.Field(None, description='The EFS file system. Default: - no EFS file system\n\n:exampleMetadata: infused\n\nExample::\n\n    efs.AccessPoint.from_access_point_attributes(self, "ap",\n        access_point_id="fsap-1293c4d9832fo0912",\n        file_system=efs.FileSystem.from_file_system_attributes(self, "efs",\n            file_system_id="fs-099d3e2f",\n            security_group=ec2.SecurityGroup.from_security_group_id(self, "sg", "sg-51530134")\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['access_point_arn', 'access_point_id', 'file_system']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.AccessPointAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_efs.AccessPointOptions
class AccessPointOptionsDef(BaseStruct):
    create_acl: typing.Union[models.aws_efs.AclDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Specifies the POSIX IDs and permissions to apply when creating the access point's root directory. If the root directory specified by ``path`` does not exist, EFS creates the root directory and applies the permissions specified here. If the specified ``path`` does not exist, you must specify ``createAcl``. Default: - None. The directory specified by ``path`` must exist.\n")
    path: typing.Optional[str] = pydantic.Field(None, description="Specifies the path on the EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system. Default: '/'\n")
    posix_user: typing.Union[models.aws_efs.PosixUserDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The full POSIX identity, including the user ID, group ID, and any secondary group IDs, on the access point that is used for all file system operations performed by NFS clients using the access point. Specify this to enforce a user identity using an access point. Default: - user identity not enforced\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_ec2 as ec2\n    import aws_cdk.aws_efs as efs\n\n\n    # create a new VPC\n    vpc = ec2.Vpc(self, "VPC")\n\n    # create a new Amazon EFS filesystem\n    file_system = efs.FileSystem(self, "Efs", vpc=vpc)\n\n    # create a new access point from the filesystem\n    access_point = file_system.add_access_point("AccessPoint",\n        # set /export/lambda as the root of the access point\n        path="/export/lambda",\n        # as /export/lambda does not exist in a new efs filesystem, the efs will create the directory with the following createAcl\n        create_acl=efs.Acl(\n            owner_uid="1001",\n            owner_gid="1001",\n            permissions="750"\n        ),\n        # enforce the POSIX identity so lambda function will access with this identity\n        posix_user=efs.PosixUser(\n            uid="1001",\n            gid="1001"\n        )\n    )\n\n    fn = lambda_.Function(self, "MyLambda",\n        # mount the access point to /mnt/msg in the lambda runtime environment\n        filesystem=lambda_.FileSystem.from_efs_access_point(access_point, "/mnt/msg"),\n        runtime=lambda_.Runtime.NODEJS_18_X,\n        handler="index.handler",\n        code=lambda_.Code.from_asset(path.join(__dirname, "lambda-handler")),\n        vpc=vpc\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['create_acl', 'path', 'posix_user']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.AccessPointOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_efs.AccessPointProps
class AccessPointPropsDef(BaseStruct):
    create_acl: typing.Union[models.aws_efs.AclDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Specifies the POSIX IDs and permissions to apply when creating the access point's root directory. If the root directory specified by ``path`` does not exist, EFS creates the root directory and applies the permissions specified here. If the specified ``path`` does not exist, you must specify ``createAcl``. Default: - None. The directory specified by ``path`` must exist.\n")
    path: typing.Optional[str] = pydantic.Field(None, description="Specifies the path on the EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system. Default: '/'\n")
    posix_user: typing.Union[models.aws_efs.PosixUserDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The full POSIX identity, including the user ID, group ID, and any secondary group IDs, on the access point that is used for all file system operations performed by NFS clients using the access point. Specify this to enforce a user identity using an access point. Default: - user identity not enforced\n')
    file_system: typing.Union[_REQUIRED_INIT_PARAM, models.aws_efs.FileSystemDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The efs filesystem.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_efs as efs\n\n    # file_system: efs.FileSystem\n\n    access_point_props = efs.AccessPointProps(\n        file_system=file_system,\n\n        # the properties below are optional\n        create_acl=efs.Acl(\n            owner_gid="ownerGid",\n            owner_uid="ownerUid",\n            permissions="permissions"\n        ),\n        path="path",\n        posix_user=efs.PosixUser(\n            gid="gid",\n            uid="uid",\n\n            # the properties below are optional\n            secondary_gids=["secondaryGids"]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['create_acl', 'path', 'posix_user', 'file_system']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.AccessPointProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_efs.Acl
class AclDef(BaseStruct):
    owner_gid: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the POSIX group ID to apply to the RootDirectory. Accepts values from 0 to 2^32 (4294967295).\n')
    owner_uid: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the POSIX user ID to apply to the RootDirectory. Accepts values from 0 to 2^32 (4294967295).\n')
    permissions: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the POSIX permissions to apply to the RootDirectory, in the format of an octal number representing the file\'s mode bits.\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_ec2 as ec2\n    import aws_cdk.aws_efs as efs\n\n\n    # create a new VPC\n    vpc = ec2.Vpc(self, "VPC")\n\n    # create a new Amazon EFS filesystem\n    file_system = efs.FileSystem(self, "Efs", vpc=vpc)\n\n    # create a new access point from the filesystem\n    access_point = file_system.add_access_point("AccessPoint",\n        # set /export/lambda as the root of the access point\n        path="/export/lambda",\n        # as /export/lambda does not exist in a new efs filesystem, the efs will create the directory with the following createAcl\n        create_acl=efs.Acl(\n            owner_uid="1001",\n            owner_gid="1001",\n            permissions="750"\n        ),\n        # enforce the POSIX identity so lambda function will access with this identity\n        posix_user=efs.PosixUser(\n            uid="1001",\n            gid="1001"\n        )\n    )\n\n    fn = lambda_.Function(self, "MyLambda",\n        # mount the access point to /mnt/msg in the lambda runtime environment\n        filesystem=lambda_.FileSystem.from_efs_access_point(access_point, "/mnt/msg"),\n        runtime=lambda_.Runtime.NODEJS_18_X,\n        handler="index.handler",\n        code=lambda_.Code.from_asset(path.join(__dirname, "lambda-handler")),\n        vpc=vpc\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['owner_gid', 'owner_uid', 'permissions']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.Acl'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_efs.CfnAccessPoint.AccessPointTagProperty
class CfnAccessPoint_AccessPointTagPropertyDef(BaseStruct):
    key: typing.Optional[str] = pydantic.Field(None, description="The tag key (String). The key can't start with ``aws:`` .\n")
    value: typing.Optional[str] = pydantic.Field(None, description='The value of the tag key.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-efs-accesspoint-accesspointtag.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_efs as efs\n\n    access_point_tag_property = efs.CfnAccessPoint.AccessPointTagProperty(\n        key="key",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.CfnAccessPoint.AccessPointTagProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_efs.CfnAccessPoint.CreationInfoProperty
class CfnAccessPoint_CreationInfoPropertyDef(BaseStruct):
    owner_gid: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the POSIX group ID to apply to the ``RootDirectory`` . Accepts values from 0 to 2^32 (4294967295).\n')
    owner_uid: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the POSIX user ID to apply to the ``RootDirectory`` . Accepts values from 0 to 2^32 (4294967295).\n')
    permissions: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the POSIX permissions to apply to the ``RootDirectory`` , in the format of an octal number representing the file\'s mode bits.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-efs-accesspoint-creationinfo.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_efs as efs\n\n    creation_info_property = efs.CfnAccessPoint.CreationInfoProperty(\n        owner_gid="ownerGid",\n        owner_uid="ownerUid",\n        permissions="permissions"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['owner_gid', 'owner_uid', 'permissions']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.CfnAccessPoint.CreationInfoProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_efs.CfnAccessPoint.PosixUserProperty
class CfnAccessPoint_PosixUserPropertyDef(BaseStruct):
    gid: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The POSIX group ID used for all file system operations using this access point.\n')
    uid: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The POSIX user ID used for all file system operations using this access point.\n')
    secondary_gids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Secondary POSIX group IDs used for all file system operations using this access point.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-efs-accesspoint-posixuser.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_efs as efs\n\n    posix_user_property = efs.CfnAccessPoint.PosixUserProperty(\n        gid="gid",\n        uid="uid",\n\n        # the properties below are optional\n        secondary_gids=["secondaryGids"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['gid', 'uid', 'secondary_gids']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.CfnAccessPoint.PosixUserProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_efs.CfnAccessPoint.RootDirectoryProperty
class CfnAccessPoint_RootDirectoryPropertyDef(BaseStruct):
    creation_info: typing.Union[models.UnsupportedResource, models.aws_efs.CfnAccessPoint_CreationInfoPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="(Optional) Specifies the POSIX IDs and permissions to apply to the access point's ``RootDirectory`` . If the ``RootDirectory`` > ``Path`` specified does not exist, EFS creates the root directory using the ``CreationInfo`` settings when a client connects to an access point. When specifying the ``CreationInfo`` , you must provide values for all properties. .. epigraph:: If you do not provide ``CreationInfo`` and the specified ``RootDirectory`` > ``Path`` does not exist, attempts to mount the file system using the access point will fail.\n")
    path: typing.Optional[str] = pydantic.Field(None, description='Specifies the path on the EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system. A path can have up to four subdirectories. If the specified path does not exist, you are required to provide the ``CreationInfo`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-efs-accesspoint-rootdirectory.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_efs as efs\n\n    root_directory_property = efs.CfnAccessPoint.RootDirectoryProperty(\n        creation_info=efs.CfnAccessPoint.CreationInfoProperty(\n            owner_gid="ownerGid",\n            owner_uid="ownerUid",\n            permissions="permissions"\n        ),\n        path="path"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['creation_info', 'path']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.CfnAccessPoint.RootDirectoryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_efs.CfnFileSystem.BackupPolicyProperty
class CfnFileSystem_BackupPolicyPropertyDef(BaseStruct):
    status: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Set the backup policy status for the file system. - *``ENABLED``* - Turns automatic backups on for the file system. - *``DISABLED``* - Turns automatic backups off for the file system.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-efs-filesystem-backuppolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_efs as efs\n\n    backup_policy_property = efs.CfnFileSystem.BackupPolicyProperty(\n        status="status"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['status']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.CfnFileSystem.BackupPolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_efs.CfnFileSystem.ElasticFileSystemTagProperty
class CfnFileSystem_ElasticFileSystemTagPropertyDef(BaseStruct):
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The tag key (String). The key can't start with ``aws:`` .\n")
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The value of the tag key.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-efs-filesystem-elasticfilesystemtag.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_efs as efs\n\n    elastic_file_system_tag_property = efs.CfnFileSystem.ElasticFileSystemTagProperty(\n        key="key",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.CfnFileSystem.ElasticFileSystemTagProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_efs.CfnFileSystem.FileSystemProtectionProperty
class CfnFileSystem_FileSystemProtectionPropertyDef(BaseStruct):
    replication_overwrite_protection: typing.Optional[str] = pydantic.Field(None, description='The status of the file system\'s replication overwrite protection. - ``ENABLED`` – The file system cannot be used as the destination file system in a replication configuration. The file system is writeable. Replication overwrite protection is ``ENABLED`` by default. - ``DISABLED`` – The file system can be used as the destination file system in a replication configuration. The file system is read-only and can only be modified by EFS replication. - ``REPLICATING`` – The file system is being used as the destination file system in a replication configuration. The file system is read-only and is only modified only by EFS replication. If the replication configuration is deleted, the file system\'s replication overwrite protection is re-enabled, the file system becomes writeable.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-efs-filesystem-filesystemprotection.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_efs as efs\n\n    file_system_protection_property = efs.CfnFileSystem.FileSystemProtectionProperty(\n        replication_overwrite_protection="replicationOverwriteProtection"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['replication_overwrite_protection']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.CfnFileSystem.FileSystemProtectionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_efs.CfnFileSystem.LifecyclePolicyProperty
class CfnFileSystem_LifecyclePolicyPropertyDef(BaseStruct):
    transition_to_archive: typing.Optional[str] = pydantic.Field(None, description="The number of days after files were last accessed in primary storage (the Standard storage class) at which to move them to Archive storage. Metadata operations such as listing the contents of a directory don't count as file access events.\n")
    transition_to_ia: typing.Optional[str] = pydantic.Field(None, description="The number of days after files were last accessed in primary storage (the Standard storage class) at which to move them to Infrequent Access (IA) storage. Metadata operations such as listing the contents of a directory don't count as file access events.\n")
    transition_to_primary_storage_class: typing.Optional[str] = pydantic.Field(None, description='Whether to move files back to primary (Standard) storage after they are accessed in IA or Archive storage. Metadata operations such as listing the contents of a directory don\'t count as file access events.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-efs-filesystem-lifecyclepolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_efs as efs\n\n    lifecycle_policy_property = efs.CfnFileSystem.LifecyclePolicyProperty(\n        transition_to_archive="transitionToArchive",\n        transition_to_ia="transitionToIa",\n        transition_to_primary_storage_class="transitionToPrimaryStorageClass"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['transition_to_archive', 'transition_to_ia', 'transition_to_primary_storage_class']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.CfnFileSystem.LifecyclePolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_efs.CfnFileSystem.ReplicationConfigurationProperty
class CfnFileSystem_ReplicationConfigurationPropertyDef(BaseStruct):
    destinations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_efs.CfnFileSystem_ReplicationDestinationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An array of destination objects. Only one destination object is supported.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-efs-filesystem-replicationconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_efs as efs\n\n    replication_configuration_property = efs.CfnFileSystem.ReplicationConfigurationProperty(\n        destinations=[efs.CfnFileSystem.ReplicationDestinationProperty(\n            availability_zone_name="availabilityZoneName",\n            file_system_id="fileSystemId",\n            kms_key_id="kmsKeyId",\n            region="region"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destinations']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.CfnFileSystem.ReplicationConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_efs.CfnFileSystem.ReplicationDestinationProperty
class CfnFileSystem_ReplicationDestinationPropertyDef(BaseStruct):
    availability_zone_name: typing.Optional[str] = pydantic.Field(None, description='For One Zone file systems, the replication configuration must specify the Availability Zone in which the destination file system is located. Use the format ``us-east-1a`` to specify the Availability Zone. For more information about One Zone file systems, see `EFS file system types <https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html>`_ in the *Amazon EFS User Guide* . .. epigraph:: One Zone file system type is not available in all Availability Zones in AWS Regions where Amazon EFS is available.\n')
    file_system_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the destination Amazon EFS file system.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The ID of an AWS KMS key used to protect the encrypted file system.\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The AWS Region in which the destination file system is located. .. epigraph:: For One Zone file systems, the replication configuration must specify the AWS Region in which the destination file system is located.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-efs-filesystem-replicationdestination.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_efs as efs\n\n    replication_destination_property = efs.CfnFileSystem.ReplicationDestinationProperty(\n        availability_zone_name="availabilityZoneName",\n        file_system_id="fileSystemId",\n        kms_key_id="kmsKeyId",\n        region="region"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone_name', 'file_system_id', 'kms_key_id', 'region']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.CfnFileSystem.ReplicationDestinationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_efs.ExistingFileSystemProps
class ExistingFileSystemPropsDef(BaseStruct):
    destination_file_system: typing.Union[_REQUIRED_INIT_PARAM, models.aws_efs.FileSystemDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The existing destination file system for the replication.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_efs as efs\n\n    # file_system: efs.FileSystem\n\n    existing_file_system_props = efs.ExistingFileSystemProps(\n        destination_file_system=file_system\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_file_system']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.ExistingFileSystemProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_efs.FileSystemAttributes
class FileSystemAttributesDef(BaseStruct):
    security_group: typing.Union[_REQUIRED_INIT_PARAM, models.aws_ec2.SecurityGroupDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The security group of the file system.\n')
    file_system_arn: typing.Optional[str] = pydantic.Field(None, description="The File System's Arn. Default: - determined based on fileSystemId\n")
    file_system_id: typing.Optional[str] = pydantic.Field(None, description='The File System\'s ID. Default: - determined based on fileSystemArn\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_iam as iam\n\n\n    imported_file_system = efs.FileSystem.from_file_system_attributes(self, "existingFS",\n        file_system_id="fs-12345678",  # You can also use fileSystemArn instead of fileSystemId.\n        security_group=ec2.SecurityGroup.from_security_group_id(self, "SG", "sg-123456789",\n            allow_all_outbound=False\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['security_group', 'file_system_arn', 'file_system_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.FileSystemAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_efs.FileSystemAttributesDefConfig] = pydantic.Field(None)


class FileSystemAttributesDefConfig(pydantic.BaseModel):
    security_group_config: typing.Optional[models._interface_methods.AwsEc2ISecurityGroupDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_efs.FileSystemProps
class FileSystemPropsDef(BaseStruct):
    vpc: typing.Union[_REQUIRED_INIT_PARAM, models.aws_ec2.VpcDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='VPC to launch the file system in.\n')
    allow_anonymous_access: typing.Optional[bool] = pydantic.Field(None, description="Allow access from anonymous client that doesn't use IAM authentication. Default: false when using ``grantRead``, ``grantWrite``, ``grantRootAccess`` or set ``@aws-cdk/aws-efs:denyAnonymousAccess`` feature flag, otherwise true\n")
    enable_automatic_backups: typing.Optional[bool] = pydantic.Field(None, description='Whether to enable automatic backups for the file system. Default: false\n')
    encrypted: typing.Optional[bool] = pydantic.Field(None, description="Defines if the data at rest in the file system is encrypted or not. Default: - If your application has the '@aws-cdk/aws-efs:defaultEncryptionAtRest' feature flag set, the default is true, otherwise, the default is false.\n")
    file_system_name: typing.Optional[str] = pydantic.Field(None, description="The file system's name. Default: - CDK generated name\n")
    file_system_policy: typing.Optional[models.aws_iam.PolicyDocumentDef] = pydantic.Field(None, description='File system policy is an IAM resource policy used to control NFS access to an EFS file system. Default: none\n')
    kms_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description="The KMS key used for encryption. This is required to encrypt the data at rest if Default: - if 'encrypted' is true, the default key for EFS (/aws/elasticfilesystem) is used\n")
    lifecycle_policy: typing.Optional[aws_cdk.aws_efs.LifecyclePolicy] = pydantic.Field(None, description='A policy used by EFS lifecycle management to transition files to the Infrequent Access (IA) storage class. Default: - None. EFS will not transition files to the IA storage class.\n')
    one_zone: typing.Optional[bool] = pydantic.Field(None, description='Whether this is a One Zone file system. If enabled, ``performanceMode`` must be set to ``GENERAL_PURPOSE`` and ``vpcSubnets`` cannot be set. Default: false\n')
    out_of_infrequent_access_policy: typing.Optional[aws_cdk.aws_efs.OutOfInfrequentAccessPolicy] = pydantic.Field(None, description='A policy used by EFS lifecycle management to transition files from Infrequent Access (IA) storage class to primary storage class. Default: - None. EFS will not transition files from IA storage to primary storage.\n')
    performance_mode: typing.Optional[aws_cdk.aws_efs.PerformanceMode] = pydantic.Field(None, description="The performance mode that the file system will operate under. An Amazon EFS file system's performance mode can't be changed after the file system has been created. Updating this property will replace the file system. Default: PerformanceMode.GENERAL_PURPOSE\n")
    provisioned_throughput_per_second: typing.Optional[models.SizeDef] = pydantic.Field(None, description='Provisioned throughput for the file system. This is a required property if the throughput mode is set to PROVISIONED. Must be at least 1MiB/s. Default: - none, errors out\n')
    removal_policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='The removal policy to apply to the file system. Default: RemovalPolicy.RETAIN\n')
    replication_configuration: typing.Optional[models.aws_efs.ReplicationConfigurationDef] = pydantic.Field(None, description='Replication configuration for the file system. Default: - no replication\n')
    replication_overwrite_protection: typing.Optional[aws_cdk.aws_efs.ReplicationOverwriteProtection] = pydantic.Field(None, description="Whether to enable the filesystem's replication overwrite protection or not. Set false if you want to create a read-only filesystem for use as a replication destination. Default: ReplicationOverwriteProtection.ENABLED\n")
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='Security Group to assign to this file system. Default: - creates new security group which allows all outbound traffic\n')
    throughput_mode: typing.Optional[aws_cdk.aws_efs.ThroughputMode] = pydantic.Field(None, description='Enum to mention the throughput mode of the file system. Default: ThroughputMode.BURSTING\n')
    transition_to_archive_policy: typing.Optional[aws_cdk.aws_efs.LifecyclePolicy] = pydantic.Field(None, description="The number of days after files were last accessed in primary storage (the Standard storage class) at which to move them to Archive storage. Metadata operations such as listing the contents of a directory don't count as file access events. Default: - None. EFS will not transition files to Archive storage class.\n")
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Which subnets to place the mount target in the VPC. Default: - the Vpc default strategy if not specified\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_iam as iam\n\n\n    role = iam.Role(self, "ClientRole",\n        assumed_by=iam.AnyPrincipal()\n    )\n    file_system = efs.FileSystem(self, "MyEfsFileSystem",\n        vpc=ec2.Vpc(self, "VPC"),\n        allow_anonymous_access=True\n    )\n\n    file_system.grant_read(role)\n')
    _init_params: typing.ClassVar[list[str]] = ['vpc', 'allow_anonymous_access', 'enable_automatic_backups', 'encrypted', 'file_system_name', 'file_system_policy', 'kms_key', 'lifecycle_policy', 'one_zone', 'out_of_infrequent_access_policy', 'performance_mode', 'provisioned_throughput_per_second', 'removal_policy', 'replication_configuration', 'replication_overwrite_protection', 'security_group', 'throughput_mode', 'transition_to_archive_policy', 'vpc_subnets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.FileSystemProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_efs.FileSystemPropsDefConfig] = pydantic.Field(None)


class FileSystemPropsDefConfig(pydantic.BaseModel):
    vpc_config: typing.Optional[models._interface_methods.AwsEc2IVpcDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_efs.OneZoneFileSystemProps
class OneZoneFileSystemPropsDef(BaseStruct):
    availability_zone: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The availability zone name of the destination file system. One zone file system is used as the destination file system when this property is set.\n')
    region: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The AWS Region in which the destination file system is located.\n')
    kms_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='AWS KMS key used to protect the encrypted file system. Default: - use service-managed KMS key for Amazon EFS\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_efs as efs\n    from aws_cdk import aws_kms as kms\n\n    # key: kms.Key\n\n    one_zone_file_system_props = efs.OneZoneFileSystemProps(\n        availability_zone="availabilityZone",\n        region="region",\n\n        # the properties below are optional\n        kms_key=key\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'region', 'kms_key']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.OneZoneFileSystemProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_efs.PosixUser
class PosixUserDef(BaseStruct):
    gid: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The POSIX group ID used for all file system operations using this access point.\n')
    uid: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The POSIX user ID used for all file system operations using this access point.\n')
    secondary_gids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Secondary POSIX group IDs used for all file system operations using this access point. Default: - None\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_ec2 as ec2\n    import aws_cdk.aws_efs as efs\n\n\n    # create a new VPC\n    vpc = ec2.Vpc(self, "VPC")\n\n    # create a new Amazon EFS filesystem\n    file_system = efs.FileSystem(self, "Efs", vpc=vpc)\n\n    # create a new access point from the filesystem\n    access_point = file_system.add_access_point("AccessPoint",\n        # set /export/lambda as the root of the access point\n        path="/export/lambda",\n        # as /export/lambda does not exist in a new efs filesystem, the efs will create the directory with the following createAcl\n        create_acl=efs.Acl(\n            owner_uid="1001",\n            owner_gid="1001",\n            permissions="750"\n        ),\n        # enforce the POSIX identity so lambda function will access with this identity\n        posix_user=efs.PosixUser(\n            uid="1001",\n            gid="1001"\n        )\n    )\n\n    fn = lambda_.Function(self, "MyLambda",\n        # mount the access point to /mnt/msg in the lambda runtime environment\n        filesystem=lambda_.FileSystem.from_efs_access_point(access_point, "/mnt/msg"),\n        runtime=lambda_.Runtime.NODEJS_18_X,\n        handler="index.handler",\n        code=lambda_.Code.from_asset(path.join(__dirname, "lambda-handler")),\n        vpc=vpc\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['gid', 'uid', 'secondary_gids']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.PosixUser'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_efs.RegionalFileSystemProps
class RegionalFileSystemPropsDef(BaseStruct):
    kms_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='AWS KMS key used to protect the encrypted file system. Default: - use service-managed KMS key for Amazon EFS\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The AWS Region in which the destination file system is located. Default: - the region of the stack\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_efs as efs\n    from aws_cdk import aws_kms as kms\n\n    # key: kms.Key\n\n    regional_file_system_props = efs.RegionalFileSystemProps(\n        kms_key=key,\n        region="region"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['kms_key', 'region']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.RegionalFileSystemProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_efs.ReplicationConfigurationProps
class ReplicationConfigurationPropsDef(BaseStruct):
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The availability zone name of the destination file system. One zone file system is used as the destination file system when this property is set. Default: - no availability zone is set\n')
    destination_file_system: typing.Optional[typing.Union[models.aws_efs.FileSystemDef]] = pydantic.Field(None, description='The existing destination file system for the replication. Default: - None\n')
    kms_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='AWS KMS key used to protect the encrypted file system. Default: - use service-managed KMS key for Amazon EFS\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The AWS Region in which the destination file system is located. Default: - the region of the stack\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_efs as efs\n    from aws_cdk import aws_kms as kms\n\n    # file_system: efs.FileSystem\n    # key: kms.Key\n\n    replication_configuration_props = efs.ReplicationConfigurationProps(\n        availability_zone="availabilityZone",\n        destination_file_system=file_system,\n        kms_key=key,\n        region="region"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'destination_file_system', 'kms_key', 'region']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.ReplicationConfigurationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_efs.LifecyclePolicy
# skipping emum

#  autogenerated from aws_cdk.aws_efs.OutOfInfrequentAccessPolicy
# skipping emum

#  autogenerated from aws_cdk.aws_efs.PerformanceMode
# skipping emum

#  autogenerated from aws_cdk.aws_efs.ReplicationOverwriteProtection
# skipping emum

#  autogenerated from aws_cdk.aws_efs.ThroughputMode
# skipping emum

#  autogenerated from aws_cdk.aws_efs.IAccessPoint
#  skipping Interface

#  autogenerated from aws_cdk.aws_efs.IFileSystem
#  skipping Interface

#  autogenerated from aws_cdk.aws_efs.CfnAccessPoint
class CfnAccessPointDef(BaseCfnResource):
    file_system_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the EFS file system that the access point applies to. Accepts only the ID format for input when specifying a file system, for example ``fs-0123456789abcedf2`` .\n')
    access_point_tags: typing.Optional[typing.Sequence[typing.Union[models.aws_efs.CfnAccessPoint_AccessPointTagPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .\n')
    client_token: typing.Optional[str] = pydantic.Field(None, description='The opaque string specified in the request to ensure idempotent creation.\n')
    posix_user: typing.Union[models.UnsupportedResource, models.aws_efs.CfnAccessPoint_PosixUserPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The full POSIX identity, including the user ID, group ID, and secondary group IDs on the access point that is used for all file operations by NFS clients using the access point.\n')
    root_directory: typing.Union[models.UnsupportedResource, models.aws_efs.CfnAccessPoint_RootDirectoryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The directory on the EFS file system that the access point exposes as the root directory to NFS clients using the access point.')
    _init_params: typing.ClassVar[list[str]] = ['file_system_id', 'access_point_tags', 'client_token', 'posix_user', 'root_directory']
    _method_names: typing.ClassVar[list[str]] = ['AccessPointTagProperty', 'CreationInfoProperty', 'PosixUserProperty', 'RootDirectoryProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.CfnAccessPoint'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_efs.CfnAccessPointDefConfig] = pydantic.Field(None)


class CfnAccessPointDefConfig(pydantic.BaseModel):
    AccessPointTagProperty: typing.Optional[list[models.aws_efs.CfnAccessPointDefAccesspointtagpropertyParams]] = pydantic.Field(None, description='')
    CreationInfoProperty: typing.Optional[list[models.aws_efs.CfnAccessPointDefCreationinfopropertyParams]] = pydantic.Field(None, description='')
    PosixUserProperty: typing.Optional[list[models.aws_efs.CfnAccessPointDefPosixuserpropertyParams]] = pydantic.Field(None, description='')
    RootDirectoryProperty: typing.Optional[list[models.aws_efs.CfnAccessPointDefRootdirectorypropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_efs.CfnAccessPointDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_efs.CfnAccessPointDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_efs.CfnAccessPointDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_efs.CfnAccessPointDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_efs.CfnAccessPointDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_efs.CfnAccessPointDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_efs.CfnAccessPointDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_efs.CfnAccessPointDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_efs.CfnAccessPointDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_efs.CfnAccessPointDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_efs.CfnAccessPointDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_efs.CfnAccessPointDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_efs.CfnAccessPointDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnAccessPointDefAccesspointtagpropertyParams(pydantic.BaseModel):
    key: typing.Optional[str] = pydantic.Field(None, description='')
    value: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAccessPointDefCreationinfopropertyParams(pydantic.BaseModel):
    owner_gid: str = pydantic.Field(..., description='')
    owner_uid: str = pydantic.Field(..., description='')
    permissions: str = pydantic.Field(..., description='')
    ...

class CfnAccessPointDefPosixuserpropertyParams(pydantic.BaseModel):
    gid: str = pydantic.Field(..., description='')
    uid: str = pydantic.Field(..., description='')
    secondary_gids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnAccessPointDefRootdirectorypropertyParams(pydantic.BaseModel):
    creation_info: typing.Union[models.UnsupportedResource, models.aws_efs.CfnAccessPoint_CreationInfoPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    path: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAccessPointDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAccessPointDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAccessPointDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAccessPointDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAccessPointDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAccessPointDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAccessPointDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAccessPointDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAccessPointDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAccessPointDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAccessPointDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnAccessPointDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAccessPointDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAccessPointDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_efs.CfnFileSystem
class CfnFileSystemDef(BaseCfnResource):
    availability_zone_name: typing.Optional[str] = pydantic.Field(None, description='For One Zone file systems, specify the AWS Availability Zone in which to create the file system. Use the format ``us-east-1a`` to specify the Availability Zone. For more information about One Zone file systems, see `EFS file system types <https://docs.aws.amazon.com/efs/latest/ug/availability-durability.html#file-system-type>`_ in the *Amazon EFS User Guide* . .. epigraph:: One Zone file systems are not available in all Availability Zones in AWS Regions where Amazon EFS is available.\n')
    backup_policy: typing.Union[models.UnsupportedResource, models.aws_efs.CfnFileSystem_BackupPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Use the ``BackupPolicy`` to turn automatic backups on or off for the file system.\n')
    bypass_policy_lockout_safety_check: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='(Optional) A boolean that specifies whether or not to bypass the ``FileSystemPolicy`` lockout safety check. The lockout safety check determines whether the policy in the request will lock out, or prevent, the IAM principal that is making the request from making future ``PutFileSystemPolicy`` requests on this file system. Set ``BypassPolicyLockoutSafetyCheck`` to ``True`` only when you intend to prevent the IAM principal that is making the request from making subsequent ``PutFileSystemPolicy`` requests on this file system. The default value is ``False`` .\n')
    encrypted: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="A Boolean value that, if true, creates an encrypted file system. When creating an encrypted file system, you have the option of specifying a KmsKeyId for an existing AWS KMS key . If you don't specify a KMS key , then the default KMS key for Amazon EFS , ``/aws/elasticfilesystem`` , is used to protect the encrypted file system.\n")
    file_system_policy: typing.Any = pydantic.Field(None, description='The ``FileSystemPolicy`` for the EFS file system. A file system policy is an IAM resource policy used to control NFS access to an EFS file system. For more information, see `Using IAM to control NFS access to Amazon EFS <https://docs.aws.amazon.com/efs/latest/ug/iam-access-control-nfs-efs.html>`_ in the *Amazon EFS User Guide* .\n')
    file_system_protection: typing.Union[models.UnsupportedResource, models.aws_efs.CfnFileSystem_FileSystemProtectionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Describes the protection on the file system.\n')
    file_system_tags: typing.Optional[typing.Sequence[typing.Union[models.aws_efs.CfnFileSystem_ElasticFileSystemTagPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Use to create one or more tags associated with the file system. Each tag is a user-defined key-value pair. Name your file system on creation by including a ``"Key":"Name","Value":"{value}"`` key-value pair. Each key must be unique. For more information, see `Tagging AWS resources <https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html>`_ in the *AWS General Reference Guide* .\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the AWS KMS key to be used to protect the encrypted file system. This parameter is only required if you want to use a nondefault KMS key . If this parameter is not specified, the default KMS key for Amazon EFS is used. This ID can be in one of the following formats: - Key ID - A unique identifier of the key, for example ``1234abcd-12ab-34cd-56ef-1234567890ab`` . - ARN - An Amazon Resource Name (ARN) for the key, for example ``arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab`` . - Key alias - A previously created display name for a key, for example ``alias/projectKey1`` . - Key alias ARN - An ARN for a key alias, for example ``arn:aws:kms:us-west-2:444455556666:alias/projectKey1`` . If ``KmsKeyId`` is specified, the ``Encrypted`` parameter must be set to true.\n')
    lifecycle_policies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_efs.CfnFileSystem_LifecyclePolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="An array of ``LifecyclePolicy`` objects that define the file system's ``LifecycleConfiguration`` object. A ``LifecycleConfiguration`` object informs Lifecycle management of the following: - When to move files in the file system from primary storage to IA storage. - When to move files in the file system from primary storage or IA storage to Archive storage. - When to move files that are in IA or Archive storage to primary storage. .. epigraph:: Amazon EFS requires that each ``LifecyclePolicy`` object have only a single transition. This means that in a request body, ``LifecyclePolicies`` needs to be structured as an array of ``LifecyclePolicy`` objects, one object for each transition, ``TransitionToIA`` , ``TransitionToArchive`` ``TransitionToPrimaryStorageClass`` . See the example requests in the following section for more information.\n")
    performance_mode: typing.Optional[str] = pydantic.Field(None, description="The performance mode of the file system. We recommend ``generalPurpose`` performance mode for all file systems. File systems using the ``maxIO`` performance mode can scale to higher levels of aggregate throughput and operations per second with a tradeoff of slightly higher latencies for most file operations. The performance mode can't be changed after the file system has been created. The ``maxIO`` mode is not supported on One Zone file systems. .. epigraph:: Due to the higher per-operation latencies with Max I/O, we recommend using General Purpose performance mode for all file systems. Default is ``generalPurpose`` .\n")
    provisioned_throughput_in_mibps: typing.Union[int, float, None] = pydantic.Field(None, description="The throughput, measured in mebibytes per second (MiBps), that you want to provision for a file system that you're creating. Required if ``ThroughputMode`` is set to ``provisioned`` . Valid values are 1-3414 MiBps, with the upper limit depending on Region. To increase this limit, contact AWS Support . For more information, see `Amazon EFS quotas that you can increase <https://docs.aws.amazon.com/efs/latest/ug/limits.html#soft-limits>`_ in the *Amazon EFS User Guide* .\n")
    replication_configuration: typing.Union[models.UnsupportedResource, models.aws_efs.CfnFileSystem_ReplicationConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Describes the replication configuration for a specific file system.\n')
    throughput_mode: typing.Optional[str] = pydantic.Field(None, description="Specifies the throughput mode for the file system. The mode can be ``bursting`` , ``provisioned`` , or ``elastic`` . If you set ``ThroughputMode`` to ``provisioned`` , you must also set a value for ``ProvisionedThroughputInMibps`` . After you create the file system, you can decrease your file system's Provisioned throughput or change between the throughput modes, with certain time restrictions. For more information, see `Specifying throughput with provisioned mode <https://docs.aws.amazon.com/efs/latest/ug/performance.html#provisioned-throughput>`_ in the *Amazon EFS User Guide* . Default is ``bursting`` .")
    _init_params: typing.ClassVar[list[str]] = ['availability_zone_name', 'backup_policy', 'bypass_policy_lockout_safety_check', 'encrypted', 'file_system_policy', 'file_system_protection', 'file_system_tags', 'kms_key_id', 'lifecycle_policies', 'performance_mode', 'provisioned_throughput_in_mibps', 'replication_configuration', 'throughput_mode']
    _method_names: typing.ClassVar[list[str]] = ['BackupPolicyProperty', 'ElasticFileSystemTagProperty', 'FileSystemProtectionProperty', 'LifecyclePolicyProperty', 'ReplicationConfigurationProperty', 'ReplicationDestinationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.CfnFileSystem'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_efs.CfnFileSystemDefConfig] = pydantic.Field(None)


class CfnFileSystemDefConfig(pydantic.BaseModel):
    BackupPolicyProperty: typing.Optional[list[models.aws_efs.CfnFileSystemDefBackuppolicypropertyParams]] = pydantic.Field(None, description='')
    ElasticFileSystemTagProperty: typing.Optional[list[models.aws_efs.CfnFileSystemDefElasticfilesystemtagpropertyParams]] = pydantic.Field(None, description='')
    FileSystemProtectionProperty: typing.Optional[list[models.aws_efs.CfnFileSystemDefFilesystemprotectionpropertyParams]] = pydantic.Field(None, description='')
    LifecyclePolicyProperty: typing.Optional[list[models.aws_efs.CfnFileSystemDefLifecyclepolicypropertyParams]] = pydantic.Field(None, description='')
    ReplicationConfigurationProperty: typing.Optional[list[models.aws_efs.CfnFileSystemDefReplicationconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ReplicationDestinationProperty: typing.Optional[list[models.aws_efs.CfnFileSystemDefReplicationdestinationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_efs.CfnFileSystemDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_efs.CfnFileSystemDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_efs.CfnFileSystemDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_efs.CfnFileSystemDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_efs.CfnFileSystemDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_efs.CfnFileSystemDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_efs.CfnFileSystemDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_efs.CfnFileSystemDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_efs.CfnFileSystemDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_efs.CfnFileSystemDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_efs.CfnFileSystemDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_efs.CfnFileSystemDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_efs.CfnFileSystemDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnFileSystemDefBackuppolicypropertyParams(pydantic.BaseModel):
    status: str = pydantic.Field(..., description='')
    ...

class CfnFileSystemDefElasticfilesystemtagpropertyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnFileSystemDefFilesystemprotectionpropertyParams(pydantic.BaseModel):
    replication_overwrite_protection: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnFileSystemDefLifecyclepolicypropertyParams(pydantic.BaseModel):
    transition_to_archive: typing.Optional[str] = pydantic.Field(None, description='')
    transition_to_ia: typing.Optional[str] = pydantic.Field(None, description='')
    transition_to_primary_storage_class: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnFileSystemDefReplicationconfigurationpropertyParams(pydantic.BaseModel):
    destinations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_efs.CfnFileSystem_ReplicationDestinationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnFileSystemDefReplicationdestinationpropertyParams(pydantic.BaseModel):
    availability_zone_name: typing.Optional[str] = pydantic.Field(None, description='')
    file_system_id: typing.Optional[str] = pydantic.Field(None, description='')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='')
    region: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnFileSystemDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnFileSystemDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFileSystemDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnFileSystemDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFileSystemDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnFileSystemDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnFileSystemDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnFileSystemDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnFileSystemDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnFileSystemDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFileSystemDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnFileSystemDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnFileSystemDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFileSystemDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_efs.CfnMountTarget
class CfnMountTargetDef(BaseCfnResource):
    file_system_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the file system for which to create the mount target.\n')
    security_groups: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Up to five VPC security group IDs, of the form ``sg-xxxxxxxx`` . These must be for the same VPC as subnet specified.\n')
    subnet_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The ID of the subnet to add the mount target in. For One Zone file systems, use the subnet that is associated with the file system's Availability Zone.\n")
    ip_address: typing.Optional[str] = pydantic.Field(None, description='Valid IPv4 address within the address range of the specified subnet.')
    _init_params: typing.ClassVar[list[str]] = ['file_system_id', 'security_groups', 'subnet_id', 'ip_address']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.CfnMountTarget'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_efs.CfnMountTargetDefConfig] = pydantic.Field(None)


class CfnMountTargetDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_efs.CfnMountTargetDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_efs.CfnMountTargetDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_efs.CfnMountTargetDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_efs.CfnMountTargetDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_efs.CfnMountTargetDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_efs.CfnMountTargetDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_efs.CfnMountTargetDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_efs.CfnMountTargetDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_efs.CfnMountTargetDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_efs.CfnMountTargetDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_efs.CfnMountTargetDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_efs.CfnMountTargetDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_efs.CfnMountTargetDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnMountTargetDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnMountTargetDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMountTargetDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnMountTargetDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMountTargetDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnMountTargetDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnMountTargetDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnMountTargetDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnMountTargetDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnMountTargetDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMountTargetDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnMountTargetDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnMountTargetDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMountTargetDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_efs.CfnAccessPointProps
class CfnAccessPointPropsDef(BaseCfnProperty):
    file_system_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the EFS file system that the access point applies to. Accepts only the ID format for input when specifying a file system, for example ``fs-0123456789abcedf2`` .\n')
    access_point_tags: typing.Optional[typing.Sequence[typing.Union[models.aws_efs.CfnAccessPoint_AccessPointTagPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .\n')
    client_token: typing.Optional[str] = pydantic.Field(None, description='The opaque string specified in the request to ensure idempotent creation.\n')
    posix_user: typing.Union[models.UnsupportedResource, models.aws_efs.CfnAccessPoint_PosixUserPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The full POSIX identity, including the user ID, group ID, and secondary group IDs on the access point that is used for all file operations by NFS clients using the access point.\n')
    root_directory: typing.Union[models.UnsupportedResource, models.aws_efs.CfnAccessPoint_RootDirectoryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The directory on the EFS file system that the access point exposes as the root directory to NFS clients using the access point.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-efs-accesspoint.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_efs as efs\n\n    cfn_access_point_props = efs.CfnAccessPointProps(\n        file_system_id="fileSystemId",\n\n        # the properties below are optional\n        access_point_tags=[efs.CfnAccessPoint.AccessPointTagProperty(\n            key="key",\n            value="value"\n        )],\n        client_token="clientToken",\n        posix_user=efs.CfnAccessPoint.PosixUserProperty(\n            gid="gid",\n            uid="uid",\n\n            # the properties below are optional\n            secondary_gids=["secondaryGids"]\n        ),\n        root_directory=efs.CfnAccessPoint.RootDirectoryProperty(\n            creation_info=efs.CfnAccessPoint.CreationInfoProperty(\n                owner_gid="ownerGid",\n                owner_uid="ownerUid",\n                permissions="permissions"\n            ),\n            path="path"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['file_system_id', 'access_point_tags', 'client_token', 'posix_user', 'root_directory']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.CfnAccessPointProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_efs.CfnFileSystemProps
class CfnFileSystemPropsDef(BaseCfnProperty):
    availability_zone_name: typing.Optional[str] = pydantic.Field(None, description='For One Zone file systems, specify the AWS Availability Zone in which to create the file system. Use the format ``us-east-1a`` to specify the Availability Zone. For more information about One Zone file systems, see `EFS file system types <https://docs.aws.amazon.com/efs/latest/ug/availability-durability.html#file-system-type>`_ in the *Amazon EFS User Guide* . .. epigraph:: One Zone file systems are not available in all Availability Zones in AWS Regions where Amazon EFS is available.\n')
    backup_policy: typing.Union[models.UnsupportedResource, models.aws_efs.CfnFileSystem_BackupPolicyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Use the ``BackupPolicy`` to turn automatic backups on or off for the file system.\n')
    bypass_policy_lockout_safety_check: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='(Optional) A boolean that specifies whether or not to bypass the ``FileSystemPolicy`` lockout safety check. The lockout safety check determines whether the policy in the request will lock out, or prevent, the IAM principal that is making the request from making future ``PutFileSystemPolicy`` requests on this file system. Set ``BypassPolicyLockoutSafetyCheck`` to ``True`` only when you intend to prevent the IAM principal that is making the request from making subsequent ``PutFileSystemPolicy`` requests on this file system. The default value is ``False`` .\n')
    encrypted: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="A Boolean value that, if true, creates an encrypted file system. When creating an encrypted file system, you have the option of specifying a KmsKeyId for an existing AWS KMS key . If you don't specify a KMS key , then the default KMS key for Amazon EFS , ``/aws/elasticfilesystem`` , is used to protect the encrypted file system.\n")
    file_system_policy: typing.Any = pydantic.Field(None, description='The ``FileSystemPolicy`` for the EFS file system. A file system policy is an IAM resource policy used to control NFS access to an EFS file system. For more information, see `Using IAM to control NFS access to Amazon EFS <https://docs.aws.amazon.com/efs/latest/ug/iam-access-control-nfs-efs.html>`_ in the *Amazon EFS User Guide* .\n')
    file_system_protection: typing.Union[models.UnsupportedResource, models.aws_efs.CfnFileSystem_FileSystemProtectionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Describes the protection on the file system.\n')
    file_system_tags: typing.Optional[typing.Sequence[typing.Union[models.aws_efs.CfnFileSystem_ElasticFileSystemTagPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Use to create one or more tags associated with the file system. Each tag is a user-defined key-value pair. Name your file system on creation by including a ``"Key":"Name","Value":"{value}"`` key-value pair. Each key must be unique. For more information, see `Tagging AWS resources <https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html>`_ in the *AWS General Reference Guide* .\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the AWS KMS key to be used to protect the encrypted file system. This parameter is only required if you want to use a nondefault KMS key . If this parameter is not specified, the default KMS key for Amazon EFS is used. This ID can be in one of the following formats: - Key ID - A unique identifier of the key, for example ``1234abcd-12ab-34cd-56ef-1234567890ab`` . - ARN - An Amazon Resource Name (ARN) for the key, for example ``arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab`` . - Key alias - A previously created display name for a key, for example ``alias/projectKey1`` . - Key alias ARN - An ARN for a key alias, for example ``arn:aws:kms:us-west-2:444455556666:alias/projectKey1`` . If ``KmsKeyId`` is specified, the ``Encrypted`` parameter must be set to true.\n')
    lifecycle_policies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_efs.CfnFileSystem_LifecyclePolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="An array of ``LifecyclePolicy`` objects that define the file system's ``LifecycleConfiguration`` object. A ``LifecycleConfiguration`` object informs Lifecycle management of the following: - When to move files in the file system from primary storage to IA storage. - When to move files in the file system from primary storage or IA storage to Archive storage. - When to move files that are in IA or Archive storage to primary storage. .. epigraph:: Amazon EFS requires that each ``LifecyclePolicy`` object have only a single transition. This means that in a request body, ``LifecyclePolicies`` needs to be structured as an array of ``LifecyclePolicy`` objects, one object for each transition, ``TransitionToIA`` , ``TransitionToArchive`` ``TransitionToPrimaryStorageClass`` . See the example requests in the following section for more information.\n")
    performance_mode: typing.Optional[str] = pydantic.Field(None, description="The performance mode of the file system. We recommend ``generalPurpose`` performance mode for all file systems. File systems using the ``maxIO`` performance mode can scale to higher levels of aggregate throughput and operations per second with a tradeoff of slightly higher latencies for most file operations. The performance mode can't be changed after the file system has been created. The ``maxIO`` mode is not supported on One Zone file systems. .. epigraph:: Due to the higher per-operation latencies with Max I/O, we recommend using General Purpose performance mode for all file systems. Default is ``generalPurpose`` .\n")
    provisioned_throughput_in_mibps: typing.Union[int, float, None] = pydantic.Field(None, description="The throughput, measured in mebibytes per second (MiBps), that you want to provision for a file system that you're creating. Required if ``ThroughputMode`` is set to ``provisioned`` . Valid values are 1-3414 MiBps, with the upper limit depending on Region. To increase this limit, contact AWS Support . For more information, see `Amazon EFS quotas that you can increase <https://docs.aws.amazon.com/efs/latest/ug/limits.html#soft-limits>`_ in the *Amazon EFS User Guide* .\n")
    replication_configuration: typing.Union[models.UnsupportedResource, models.aws_efs.CfnFileSystem_ReplicationConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Describes the replication configuration for a specific file system.\n')
    throughput_mode: typing.Optional[str] = pydantic.Field(None, description='Specifies the throughput mode for the file system. The mode can be ``bursting`` , ``provisioned`` , or ``elastic`` . If you set ``ThroughputMode`` to ``provisioned`` , you must also set a value for ``ProvisionedThroughputInMibps`` . After you create the file system, you can decrease your file system\'s Provisioned throughput or change between the throughput modes, with certain time restrictions. For more information, see `Specifying throughput with provisioned mode <https://docs.aws.amazon.com/efs/latest/ug/performance.html#provisioned-throughput>`_ in the *Amazon EFS User Guide* . Default is ``bursting`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-efs-filesystem.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_efs as efs\n\n    # file_system_policy: Any\n\n    cfn_file_system_props = efs.CfnFileSystemProps(\n        availability_zone_name="availabilityZoneName",\n        backup_policy=efs.CfnFileSystem.BackupPolicyProperty(\n            status="status"\n        ),\n        bypass_policy_lockout_safety_check=False,\n        encrypted=False,\n        file_system_policy=file_system_policy,\n        file_system_protection=efs.CfnFileSystem.FileSystemProtectionProperty(\n            replication_overwrite_protection="replicationOverwriteProtection"\n        ),\n        file_system_tags=[efs.CfnFileSystem.ElasticFileSystemTagProperty(\n            key="key",\n            value="value"\n        )],\n        kms_key_id="kmsKeyId",\n        lifecycle_policies=[efs.CfnFileSystem.LifecyclePolicyProperty(\n            transition_to_archive="transitionToArchive",\n            transition_to_ia="transitionToIa",\n            transition_to_primary_storage_class="transitionToPrimaryStorageClass"\n        )],\n        performance_mode="performanceMode",\n        provisioned_throughput_in_mibps=123,\n        replication_configuration=efs.CfnFileSystem.ReplicationConfigurationProperty(\n            destinations=[efs.CfnFileSystem.ReplicationDestinationProperty(\n                availability_zone_name="availabilityZoneName",\n                file_system_id="fileSystemId",\n                kms_key_id="kmsKeyId",\n                region="region"\n            )]\n        ),\n        throughput_mode="throughputMode"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone_name', 'backup_policy', 'bypass_policy_lockout_safety_check', 'encrypted', 'file_system_policy', 'file_system_protection', 'file_system_tags', 'kms_key_id', 'lifecycle_policies', 'performance_mode', 'provisioned_throughput_in_mibps', 'replication_configuration', 'throughput_mode']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.CfnFileSystemProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_efs.CfnMountTargetProps
class CfnMountTargetPropsDef(BaseCfnProperty):
    file_system_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the file system for which to create the mount target.\n')
    security_groups: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Up to five VPC security group IDs, of the form ``sg-xxxxxxxx`` . These must be for the same VPC as subnet specified.\n')
    subnet_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The ID of the subnet to add the mount target in. For One Zone file systems, use the subnet that is associated with the file system's Availability Zone.\n")
    ip_address: typing.Optional[str] = pydantic.Field(None, description='Valid IPv4 address within the address range of the specified subnet.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-efs-mounttarget.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_efs as efs\n\n    cfn_mount_target_props = efs.CfnMountTargetProps(\n        file_system_id="fileSystemId",\n        security_groups=["securityGroups"],\n        subnet_id="subnetId",\n\n        # the properties below are optional\n        ip_address="ipAddress"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['file_system_id', 'security_groups', 'subnet_id', 'ip_address']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_efs.CfnMountTargetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    ReplicationConfiguration: typing.Optional[dict[str, models.aws_efs.ReplicationConfigurationDef]] = pydantic.Field(None)
    AccessPoint: typing.Optional[dict[str, models.aws_efs.AccessPointDef]] = pydantic.Field(None)
    FileSystem: typing.Optional[dict[str, models.aws_efs.FileSystemDef]] = pydantic.Field(None)
    AccessPointAttributes: typing.Optional[dict[str, models.aws_efs.AccessPointAttributesDef]] = pydantic.Field(None)
    AccessPointOptions: typing.Optional[dict[str, models.aws_efs.AccessPointOptionsDef]] = pydantic.Field(None)
    AccessPointProps: typing.Optional[dict[str, models.aws_efs.AccessPointPropsDef]] = pydantic.Field(None)
    Acl: typing.Optional[dict[str, models.aws_efs.AclDef]] = pydantic.Field(None)
    CfnAccessPoint_AccessPointTagProperty: typing.Optional[dict[str, models.aws_efs.CfnAccessPoint_AccessPointTagPropertyDef]] = pydantic.Field(None)
    CfnAccessPoint_CreationInfoProperty: typing.Optional[dict[str, models.aws_efs.CfnAccessPoint_CreationInfoPropertyDef]] = pydantic.Field(None)
    CfnAccessPoint_PosixUserProperty: typing.Optional[dict[str, models.aws_efs.CfnAccessPoint_PosixUserPropertyDef]] = pydantic.Field(None)
    CfnAccessPoint_RootDirectoryProperty: typing.Optional[dict[str, models.aws_efs.CfnAccessPoint_RootDirectoryPropertyDef]] = pydantic.Field(None)
    CfnFileSystem_BackupPolicyProperty: typing.Optional[dict[str, models.aws_efs.CfnFileSystem_BackupPolicyPropertyDef]] = pydantic.Field(None)
    CfnFileSystem_ElasticFileSystemTagProperty: typing.Optional[dict[str, models.aws_efs.CfnFileSystem_ElasticFileSystemTagPropertyDef]] = pydantic.Field(None)
    CfnFileSystem_FileSystemProtectionProperty: typing.Optional[dict[str, models.aws_efs.CfnFileSystem_FileSystemProtectionPropertyDef]] = pydantic.Field(None)
    CfnFileSystem_LifecyclePolicyProperty: typing.Optional[dict[str, models.aws_efs.CfnFileSystem_LifecyclePolicyPropertyDef]] = pydantic.Field(None)
    CfnFileSystem_ReplicationConfigurationProperty: typing.Optional[dict[str, models.aws_efs.CfnFileSystem_ReplicationConfigurationPropertyDef]] = pydantic.Field(None)
    CfnFileSystem_ReplicationDestinationProperty: typing.Optional[dict[str, models.aws_efs.CfnFileSystem_ReplicationDestinationPropertyDef]] = pydantic.Field(None)
    ExistingFileSystemProps: typing.Optional[dict[str, models.aws_efs.ExistingFileSystemPropsDef]] = pydantic.Field(None)
    FileSystemAttributes: typing.Optional[dict[str, models.aws_efs.FileSystemAttributesDef]] = pydantic.Field(None)
    FileSystemProps: typing.Optional[dict[str, models.aws_efs.FileSystemPropsDef]] = pydantic.Field(None)
    OneZoneFileSystemProps: typing.Optional[dict[str, models.aws_efs.OneZoneFileSystemPropsDef]] = pydantic.Field(None)
    PosixUser: typing.Optional[dict[str, models.aws_efs.PosixUserDef]] = pydantic.Field(None)
    RegionalFileSystemProps: typing.Optional[dict[str, models.aws_efs.RegionalFileSystemPropsDef]] = pydantic.Field(None)
    ReplicationConfigurationProps: typing.Optional[dict[str, models.aws_efs.ReplicationConfigurationPropsDef]] = pydantic.Field(None)
    CfnAccessPoint: typing.Optional[dict[str, models.aws_efs.CfnAccessPointDef]] = pydantic.Field(None)
    CfnFileSystem: typing.Optional[dict[str, models.aws_efs.CfnFileSystemDef]] = pydantic.Field(None)
    CfnMountTarget: typing.Optional[dict[str, models.aws_efs.CfnMountTargetDef]] = pydantic.Field(None)
    CfnAccessPointProps: typing.Optional[dict[str, models.aws_efs.CfnAccessPointPropsDef]] = pydantic.Field(None)
    CfnFileSystemProps: typing.Optional[dict[str, models.aws_efs.CfnFileSystemPropsDef]] = pydantic.Field(None)
    CfnMountTargetProps: typing.Optional[dict[str, models.aws_efs.CfnMountTargetPropsDef]] = pydantic.Field(None)
    ...

import models
