from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_bedrock.FoundationModel
class FoundationModelDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_foundation_model_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.FoundationModel'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_foundation_model_id']
    ...


    from_foundation_model_id: typing.Optional[models.aws_bedrock.FoundationModelDefFromFoundationModelIdParams] = pydantic.Field(None, description='Construct a Bedrock base foundation model given the model identifier.')

class FoundationModelDefFromFoundationModelIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The parent construct.\n')
    foundation_model_id: models.aws_bedrock.FoundationModelIdentifierDef = pydantic.Field(..., description="The model identifier such as 'amazon.titan-text-express-v1'.\n")
    ...


#  autogenerated from aws_cdk.aws_bedrock.FoundationModelIdentifier
class FoundationModelIdentifierDef(BaseClass):
    model_config = pydantic.ConfigDict(protected_namespaces=())
    model_id_: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='the model identifier.', alias='model_id')
    _init_params: typing.ClassVar[list[str]] = ['model_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.FoundationModelIdentifier'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.ProvisionedModel
class ProvisionedModelDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_provisioned_model_arn']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.ProvisionedModel'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_provisioned_model_arn']
    ...


    from_provisioned_model_arn: typing.Optional[models.aws_bedrock.ProvisionedModelDefFromProvisionedModelArnParams] = pydantic.Field(None, description='Import an provisioned model given an ARN.')

class ProvisionedModelDefFromProvisionedModelArnParams(pydantic.BaseModel):
    provisioned_model_arn: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_bedrock.CfnAgent.ActionGroupExecutorProperty
class CfnAgent_ActionGroupExecutorPropertyDef(BaseStruct):
    custom_control: typing.Optional[str] = pydantic.Field(None, description='To return the action group invocation results directly in the ``InvokeAgent`` response, specify ``RETURN_CONTROL`` .\n')
    lambda_: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-actiongroupexecutor.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    action_group_executor_property = bedrock.CfnAgent.ActionGroupExecutorProperty(\n        custom_control="customControl",\n        lambda_="lambda"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['custom_control', 'lambda_']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnAgent.ActionGroupExecutorProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnAgent.AgentActionGroupProperty
class CfnAgent_AgentActionGroupPropertyDef(BaseStruct):
    action_group_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the action group.\n')
    action_group_executor: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_ActionGroupExecutorPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.\n')
    action_group_state: typing.Optional[str] = pydantic.Field(None, description='Specifies whether the action group is available for the agent to invoke or not when sending an `InvokeAgent <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html>`_ request.\n')
    api_schema: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_APISchemaPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see `Action group OpenAPI schemas <https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html>`_ .\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the action group.\n')
    function_schema: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_FunctionSchemaPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Defines functions that each define parameters that the agent needs to invoke from the user. Each function represents an action in an action group.\n')
    parent_action_group_signature: typing.Optional[str] = pydantic.Field(None, description="If this field is set as ``AMAZON.UserInput`` , the agent can request the user for additional information when trying to complete a task. The ``description`` , ``apiSchema`` , and ``actionGroupExecutor`` fields must be blank for this action group. During orchestration, if the agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an `Observation <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Observation.html>`_ reprompting the user for more information.\n")
    skip_resource_in_use_check_on_delete: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether to delete the resource even if it\'s in use. By default, this value is ``false`` . Default: - false\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentactiongroup.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    agent_action_group_property = bedrock.CfnAgent.AgentActionGroupProperty(\n        action_group_name="actionGroupName",\n\n        # the properties below are optional\n        action_group_executor=bedrock.CfnAgent.ActionGroupExecutorProperty(\n            custom_control="customControl",\n            lambda_="lambda"\n        ),\n        action_group_state="actionGroupState",\n        api_schema=bedrock.CfnAgent.APISchemaProperty(\n            payload="payload",\n            s3=bedrock.CfnAgent.S3IdentifierProperty(\n                s3_bucket_name="s3BucketName",\n                s3_object_key="s3ObjectKey"\n            )\n        ),\n        description="description",\n        function_schema=bedrock.CfnAgent.FunctionSchemaProperty(\n            functions=[bedrock.CfnAgent.FunctionProperty(\n                name="name",\n\n                # the properties below are optional\n                description="description",\n                parameters={\n                    "parameters_key": bedrock.CfnAgent.ParameterDetailProperty(\n                        type="type",\n\n                        # the properties below are optional\n                        description="description",\n                        required=False\n                    )\n                }\n            )]\n        ),\n        parent_action_group_signature="parentActionGroupSignature",\n        skip_resource_in_use_check_on_delete=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action_group_name', 'action_group_executor', 'action_group_state', 'api_schema', 'description', 'function_schema', 'parent_action_group_signature', 'skip_resource_in_use_check_on_delete']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnAgent.AgentActionGroupProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnAgent.AgentKnowledgeBaseProperty
class CfnAgent_AgentKnowledgeBasePropertyDef(BaseStruct):
    description: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The description of the association between the agent and the knowledge base.\n')
    knowledge_base_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique identifier of the association between the agent and the knowledge base.\n')
    knowledge_base_state: typing.Optional[str] = pydantic.Field(None, description='Specifies whether to use the knowledge base or not when sending an `InvokeAgent <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html>`_ request.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-agentknowledgebase.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    agent_knowledge_base_property = bedrock.CfnAgent.AgentKnowledgeBaseProperty(\n        description="description",\n        knowledge_base_id="knowledgeBaseId",\n\n        # the properties below are optional\n        knowledge_base_state="knowledgeBaseState"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'knowledge_base_id', 'knowledge_base_state']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnAgent.AgentKnowledgeBaseProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnAgent.APISchemaProperty
class CfnAgent_APISchemaPropertyDef(BaseStruct):
    payload: typing.Optional[str] = pydantic.Field(None, description='The JSON or YAML-formatted payload defining the OpenAPI schema for the action group. For more information, see `Action group OpenAPI schemas <https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html>`_ .\n')
    s3: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_S3IdentifierPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains details about the S3 object containing the OpenAPI schema for the action group. For more information, see `Action group OpenAPI schemas <https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-apischema.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    a_pISchema_property = bedrock.CfnAgent.APISchemaProperty(\n        payload="payload",\n        s3=bedrock.CfnAgent.S3IdentifierProperty(\n            s3_bucket_name="s3BucketName",\n            s3_object_key="s3ObjectKey"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['payload', 's3']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnAgent.APISchemaProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnAgent.FunctionProperty
class CfnAgent_FunctionPropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A name for the function.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the function and its purpose.\n')
    parameters: typing.Union[models.UnsupportedResource, typing.Mapping[str, typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_ParameterDetailPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The parameters that the agent elicits from the user to fulfill the function.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-function.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    function_property = bedrock.CfnAgent.FunctionProperty(\n        name="name",\n\n        # the properties below are optional\n        description="description",\n        parameters={\n            "parameters_key": bedrock.CfnAgent.ParameterDetailProperty(\n                type="type",\n\n                # the properties below are optional\n                description="description",\n                required=False\n            )\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'description', 'parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnAgent.FunctionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnAgent.FunctionSchemaProperty
class CfnAgent_FunctionSchemaPropertyDef(BaseStruct):
    functions: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_FunctionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of functions that each define an action in the action group.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-functionschema.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    function_schema_property = bedrock.CfnAgent.FunctionSchemaProperty(\n        functions=[bedrock.CfnAgent.FunctionProperty(\n            name="name",\n\n            # the properties below are optional\n            description="description",\n            parameters={\n                "parameters_key": bedrock.CfnAgent.ParameterDetailProperty(\n                    type="type",\n\n                    # the properties below are optional\n                    description="description",\n                    required=False\n                )\n            }\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['functions']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnAgent.FunctionSchemaProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnAgent.InferenceConfigurationProperty
class CfnAgent_InferenceConfigurationPropertyDef(BaseStruct):
    maximum_length: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of tokens allowed in the generated response.\n')
    stop_sequences: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.\n')
    temperature: typing.Union[int, float, None] = pydantic.Field(None, description='The likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options. The default value is the default value for the model that you are using. For more information, see `Inference parameters for foundation models <https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html>`_ .\n')
    top_k: typing.Union[int, float, None] = pydantic.Field(None, description='While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for ``topK`` is the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set ``topK`` to 50, the model selects the next token from among the top 50 most likely choices.\n')
    top_p: typing.Union[int, float, None] = pydantic.Field(None, description='The percentage of most-likely candidates that the model considers for the next token. For example, if you choose a value of 0.8 for ``topP`` , the model selects from the top 80% of the probability distribution of tokens that could be next in the sequence. The default value is the default value for the model that you are using. For more information, see `Inference parameters for foundation models <https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-inferenceconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    inference_configuration_property = bedrock.CfnAgent.InferenceConfigurationProperty(\n        maximum_length=123,\n        stop_sequences=["stopSequences"],\n        temperature=123,\n        top_k=123,\n        top_p=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['maximum_length', 'stop_sequences', 'temperature', 'top_k', 'top_p']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnAgent.InferenceConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnAgent.ParameterDetailProperty
class CfnAgent_ParameterDetailPropertyDef(BaseStruct):
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The data type of the parameter.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.\n')
    required: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Whether the parameter is required for the agent to complete the function for action group invocation.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-parameterdetail.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    parameter_detail_property = bedrock.CfnAgent.ParameterDetailProperty(\n        type="type",\n\n        # the properties below are optional\n        description="description",\n        required=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'description', 'required']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnAgent.ParameterDetailProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnAgent.PromptConfigurationProperty
class CfnAgent_PromptConfigurationPropertyDef(BaseStruct):
    base_prompt_template: typing.Optional[str] = pydantic.Field(None, description='Defines the prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see `Prompt template placeholder variables <https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html>`_ . For more information, see `Configure the prompt templates <https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts-configure.html>`_ .\n')
    inference_configuration: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_InferenceConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the ``promptType`` . For more information, see `Inference parameters for foundation models <https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html>`_ .\n')
    parser_mode: typing.Optional[str] = pydantic.Field(None, description='Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the ``promptType`` . If you set the field as ``OVERRIDEN`` , the ``overrideLambda`` field in the `PromptOverrideConfiguration <https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html>`_ must be specified with the ARN of a Lambda function.\n')
    prompt_creation_mode: typing.Optional[str] = pydantic.Field(None, description='Specifies whether to override the default prompt template for this ``promptType`` . Set this value to ``OVERRIDDEN`` to use the prompt that you provide in the ``basePromptTemplate`` . If you leave it as ``DEFAULT`` , the agent uses a default prompt template.\n')
    prompt_state: typing.Optional[str] = pydantic.Field(None, description='Specifies whether to allow the agent to carry out the step specified in the ``promptType`` . If you set this value to ``DISABLED`` , the agent skips that step. The default state for each ``promptType`` is as follows. - ``PRE_PROCESSING`` – ``ENABLED`` - ``ORCHESTRATION`` – ``ENABLED`` - ``KNOWLEDGE_BASE_RESPONSE_GENERATION`` – ``ENABLED`` - ``POST_PROCESSING`` – ``DISABLED``\n')
    prompt_type: typing.Optional[str] = pydantic.Field(None, description='The step in the agent sequence that this prompt configuration applies to.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-promptconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    prompt_configuration_property = bedrock.CfnAgent.PromptConfigurationProperty(\n        base_prompt_template="basePromptTemplate",\n        inference_configuration=bedrock.CfnAgent.InferenceConfigurationProperty(\n            maximum_length=123,\n            stop_sequences=["stopSequences"],\n            temperature=123,\n            top_k=123,\n            top_p=123\n        ),\n        parser_mode="parserMode",\n        prompt_creation_mode="promptCreationMode",\n        prompt_state="promptState",\n        prompt_type="promptType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['base_prompt_template', 'inference_configuration', 'parser_mode', 'prompt_creation_mode', 'prompt_state', 'prompt_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnAgent.PromptConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnAgent.PromptOverrideConfigurationProperty
class CfnAgent_PromptOverrideConfigurationPropertyDef(BaseStruct):
    prompt_configurations: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_PromptConfigurationPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Contains configurations to override a prompt template in one part of an agent sequence. For more information, see `Advanced prompts <https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html>`_ .\n')
    override_lambda: typing.Optional[str] = pydantic.Field(None, description='The ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the ``promptConfigurations`` must contain a ``parserMode`` value that is set to ``OVERRIDDEN`` . For more information, see `Parser Lambda function in Agents for Amazon Bedrock <https://docs.aws.amazon.com/bedrock/latest/userguide/lambda-parser.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-promptoverrideconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    prompt_override_configuration_property = bedrock.CfnAgent.PromptOverrideConfigurationProperty(\n        prompt_configurations=[bedrock.CfnAgent.PromptConfigurationProperty(\n            base_prompt_template="basePromptTemplate",\n            inference_configuration=bedrock.CfnAgent.InferenceConfigurationProperty(\n                maximum_length=123,\n                stop_sequences=["stopSequences"],\n                temperature=123,\n                top_k=123,\n                top_p=123\n            ),\n            parser_mode="parserMode",\n            prompt_creation_mode="promptCreationMode",\n            prompt_state="promptState",\n            prompt_type="promptType"\n        )],\n\n        # the properties below are optional\n        override_lambda="overrideLambda"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['prompt_configurations', 'override_lambda']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnAgent.PromptOverrideConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnAgent.S3IdentifierProperty
class CfnAgent_S3IdentifierPropertyDef(BaseStruct):
    s3_bucket_name: typing.Optional[str] = pydantic.Field(None, description='The name of the S3 bucket.\n')
    s3_object_key: typing.Optional[str] = pydantic.Field(None, description='The S3 object key containing the resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agent-s3identifier.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    s3_identifier_property = bedrock.CfnAgent.S3IdentifierProperty(\n        s3_bucket_name="s3BucketName",\n        s3_object_key="s3ObjectKey"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['s3_bucket_name', 's3_object_key']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnAgent.S3IdentifierProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnAgentAlias.AgentAliasHistoryEventProperty
class CfnAgentAlias_AgentAliasHistoryEventPropertyDef(BaseStruct):
    end_date: typing.Optional[str] = pydantic.Field(None, description='The date that the alias stopped being associated to the version in the ``routingConfiguration`` object.\n')
    routing_configuration: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgentAlias_AgentAliasRoutingConfigurationListItemPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Contains details about the version of the agent with which the alias is associated.\n')
    start_date: typing.Optional[str] = pydantic.Field(None, description='The date that the alias began being associated to the version in the ``routingConfiguration`` object.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agentalias-agentaliashistoryevent.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    agent_alias_history_event_property = bedrock.CfnAgentAlias.AgentAliasHistoryEventProperty(\n        end_date="endDate",\n        routing_configuration=[bedrock.CfnAgentAlias.AgentAliasRoutingConfigurationListItemProperty(\n            agent_version="agentVersion"\n        )],\n        start_date="startDate"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['end_date', 'routing_configuration', 'start_date']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnAgentAlias.AgentAliasHistoryEventProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnAgentAlias.AgentAliasRoutingConfigurationListItemProperty
class CfnAgentAlias_AgentAliasRoutingConfigurationListItemPropertyDef(BaseStruct):
    agent_version: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The version of the agent with which the alias is associated.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-agentalias-agentaliasroutingconfigurationlistitem.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    agent_alias_routing_configuration_list_item_property = bedrock.CfnAgentAlias.AgentAliasRoutingConfigurationListItemProperty(\n        agent_version="agentVersion"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['agent_version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnAgentAlias.AgentAliasRoutingConfigurationListItemProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnDataSource.ChunkingConfigurationProperty
class CfnDataSource_ChunkingConfigurationPropertyDef(BaseStruct):
    chunking_strategy: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Knowledge base can split your source data into chunks. A *chunk* refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for ``NONE`` , then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk. - ``FIXED_SIZE`` – Amazon Bedrock splits your source data into chunks of the approximate size that you set in the ``fixedSizeChunkingConfiguration`` . - ``NONE`` – Amazon Bedrock treats each file as one chunk. If you choose this option, you may want to pre-process your documents by splitting them into separate files.\n')
    fixed_size_chunking_configuration: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnDataSource_FixedSizeChunkingConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configurations for when you choose fixed-size chunking. If you set the ``chunkingStrategy`` as ``NONE`` , exclude this field.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-chunkingconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    chunking_configuration_property = bedrock.CfnDataSource.ChunkingConfigurationProperty(\n        chunking_strategy="chunkingStrategy",\n\n        # the properties below are optional\n        fixed_size_chunking_configuration=bedrock.CfnDataSource.FixedSizeChunkingConfigurationProperty(\n            max_tokens=123,\n            overlap_percentage=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['chunking_strategy', 'fixed_size_chunking_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnDataSource.ChunkingConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnDataSource.DataSourceConfigurationProperty
class CfnDataSource_DataSourceConfigurationPropertyDef(BaseStruct):
    s3_configuration: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_bedrock.CfnDataSource_S3DataSourceConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Contains details about the configuration of the S3 object containing the data source.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of storage for the data source.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-datasourceconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    data_source_configuration_property = bedrock.CfnDataSource.DataSourceConfigurationProperty(\n        s3_configuration=bedrock.CfnDataSource.S3DataSourceConfigurationProperty(\n            bucket_arn="bucketArn",\n\n            # the properties below are optional\n            bucket_owner_account_id="bucketOwnerAccountId",\n            inclusion_prefixes=["inclusionPrefixes"]\n        ),\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['s3_configuration', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnDataSource.DataSourceConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnDataSource.FixedSizeChunkingConfigurationProperty
class CfnDataSource_FixedSizeChunkingConfigurationPropertyDef(BaseStruct):
    max_tokens: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The maximum number of tokens to include in a chunk.\n')
    overlap_percentage: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The percentage of overlap between adjacent chunks of a data source.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-fixedsizechunkingconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    fixed_size_chunking_configuration_property = bedrock.CfnDataSource.FixedSizeChunkingConfigurationProperty(\n        max_tokens=123,\n        overlap_percentage=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max_tokens', 'overlap_percentage']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnDataSource.FixedSizeChunkingConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnDataSource.S3DataSourceConfigurationProperty
class CfnDataSource_S3DataSourceConfigurationPropertyDef(BaseStruct):
    bucket_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the bucket that contains the data source.\n')
    bucket_owner_account_id: typing.Optional[str] = pydantic.Field(None, description='The bucket account owner ID for the S3 bucket.\n')
    inclusion_prefixes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of S3 prefixes that define the object containing the data sources. For more information, see `Organizing objects using prefixes <https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-s3datasourceconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    s3_data_source_configuration_property = bedrock.CfnDataSource.S3DataSourceConfigurationProperty(\n        bucket_arn="bucketArn",\n\n        # the properties below are optional\n        bucket_owner_account_id="bucketOwnerAccountId",\n        inclusion_prefixes=["inclusionPrefixes"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket_arn', 'bucket_owner_account_id', 'inclusion_prefixes']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnDataSource.S3DataSourceConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnDataSource.ServerSideEncryptionConfigurationProperty
class CfnDataSource_ServerSideEncryptionConfigurationPropertyDef(BaseStruct):
    kms_key_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the AWS KMS key used to encrypt the resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-serversideencryptionconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    server_side_encryption_configuration_property = bedrock.CfnDataSource.ServerSideEncryptionConfigurationProperty(\n        kms_key_arn="kmsKeyArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['kms_key_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnDataSource.ServerSideEncryptionConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnDataSource.VectorIngestionConfigurationProperty
class CfnDataSource_VectorIngestionConfigurationPropertyDef(BaseStruct):
    chunking_configuration: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnDataSource_ChunkingConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Details about how to chunk the documents in the data source. A *chunk* refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-datasource-vectoringestionconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    vector_ingestion_configuration_property = bedrock.CfnDataSource.VectorIngestionConfigurationProperty(\n        chunking_configuration=bedrock.CfnDataSource.ChunkingConfigurationProperty(\n            chunking_strategy="chunkingStrategy",\n\n            # the properties below are optional\n            fixed_size_chunking_configuration=bedrock.CfnDataSource.FixedSizeChunkingConfigurationProperty(\n                max_tokens=123,\n                overlap_percentage=123\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['chunking_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnDataSource.VectorIngestionConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnGuardrail.ContentFilterConfigProperty
class CfnGuardrail_ContentFilterConfigPropertyDef(BaseStruct):
    input_strength: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The strength of the content filter to apply to prompts. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.\n')
    output_strength: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The strength of the content filter to apply to model responses. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The harmful category that the content filter is applied to.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contentfilterconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    content_filter_config_property = bedrock.CfnGuardrail.ContentFilterConfigProperty(\n        input_strength="inputStrength",\n        output_strength="outputStrength",\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['input_strength', 'output_strength', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnGuardrail.ContentFilterConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnGuardrail.ContentPolicyConfigProperty
class CfnGuardrail_ContentPolicyConfigPropertyDef(BaseStruct):
    filters_config: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnGuardrail_ContentFilterConfigPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Contains the type of the content filter and how strongly it should apply to prompts and model responses.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-contentpolicyconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    content_policy_config_property = bedrock.CfnGuardrail.ContentPolicyConfigProperty(\n        filters_config=[bedrock.CfnGuardrail.ContentFilterConfigProperty(\n            input_strength="inputStrength",\n            output_strength="outputStrength",\n            type="type"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['filters_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnGuardrail.ContentPolicyConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnGuardrail.ManagedWordsConfigProperty
class CfnGuardrail_ManagedWordsConfigPropertyDef(BaseStruct):
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The managed word type to configure for the guardrail.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-managedwordsconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    managed_words_config_property = bedrock.CfnGuardrail.ManagedWordsConfigProperty(\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnGuardrail.ManagedWordsConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnGuardrail.PiiEntityConfigProperty
class CfnGuardrail_PiiEntityConfigPropertyDef(BaseStruct):
    action: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Configure guardrail action when the PII entity is detected.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Configure guardrail type when the PII entity is detected. The following PIIs are used to block or mask sensitive information: - *General* - *ADDRESS* A physical address, such as "100 Main Street, Anytown, USA" or "Suite #12, Building 123". An address can include information such as the street, building, location, city, state, country, county, zip code, precinct, and neighborhood. - *AGE* An individual\'s age, including the quantity and unit of time. For example, in the phrase "I am 40 years old," Guarrails recognizes "40 years" as an age. - *NAME* An individual\'s name. This entity type does not include titles, such as Dr., Mr., Mrs., or Miss. guardrails doesn\'t apply this entity type to names that are part of organizations or addresses. For example, guardrails recognizes the "John Doe Organization" as an organization, and it recognizes "Jane Doe Street" as an address. - *EMAIL* An email address, such as *marymajor@email.com* . - *PHONE* A phone number. This entity type also includes fax and pager numbers. - *USERNAME* A user name that identifies an account, such as a login name, screen name, nick name, or handle. - *PASSWORD* An alphanumeric string that is used as a password, such as "* *very20special#pass** ". - *DRIVER_ID* The number assigned to a driver\'s license, which is an official document permitting an individual to operate one or more motorized vehicles on a public road. A driver\'s license number consists of alphanumeric characters. - *LICENSE_PLATE* A license plate for a vehicle is issued by the state or country where the vehicle is registered. The format for passenger vehicles is typically five to eight digits, consisting of upper-case letters and numbers. The format varies depending on the location of the issuing state or country. - *VEHICLE_IDENTIFICATION_NUMBER* A Vehicle Identification Number (VIN) uniquely identifies a vehicle. VIN content and format are defined in the *ISO 3779* specification. Each country has specific codes and formats for VINs. - *Finance* - *REDIT_DEBIT_CARD_CVV* A three-digit card verification code (CVV) that is present on VISA, MasterCard, and Discover credit and debit cards. For American Express credit or debit cards, the CVV is a four-digit numeric code. - *CREDIT_DEBIT_CARD_EXPIRY* The expiration date for a credit or debit card. This number is usually four digits long and is often formatted as *month/year* or *MM/YY* . Guardrails recognizes expiration dates such as *01/21* , *01/2021* , and *Jan 2021* . - *CREDIT_DEBIT_CARD_NUMBER* The number for a credit or debit card. These numbers can vary from 13 to 16 digits in length. However, Amazon Comprehend also recognizes credit or debit card numbers when only the last four digits are present. - *PIN* A four-digit personal identification number (PIN) with which you can access your bank account. - *INTERNATIONAL_BANK_ACCOUNT_NUMBER* An International Bank Account Number has specific formats in each country. For more information, see `www.iban.com/structure <https://docs.aws.amazon.com/https://www.iban.com/structure>`_ . - *SWIFT_CODE* A SWIFT code is a standard format of Bank Identifier Code (BIC) used to specify a particular bank or branch. Banks use these codes for money transfers such as international wire transfers. SWIFT codes consist of eight or 11 characters. The 11-digit codes refer to specific branches, while eight-digit codes (or 11-digit codes ending in \'XXX\') refer to the head or primary office. - *IT* - *IP_ADDRESS* An IPv4 address, such as *198.51.100.0* . - *MAC_ADDRESS* A *media access control* (MAC) address is a unique identifier assigned to a network interface controller (NIC). - *URL* A web address, such as *www.example.com* . - *AWS_ACCESS_KEY* A unique identifier that\'s associated with a secret access key; you use the access key ID and secret access key to sign programmatic AWS requests cryptographically. - *AWS_SECRET_KEY* A unique identifier that\'s associated with an access key. You use the access key ID and secret access key to sign programmatic AWS requests cryptographically. - *USA specific* - *US_BANK_ACCOUNT_NUMBER* A US bank account number, which is typically 10 to 12 digits long. - *US_BANK_ROUTING_NUMBER* A US bank account routing number. These are typically nine digits long, - *US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER* A US Individual Taxpayer Identification Number (ITIN) is a nine-digit number that starts with a "9" and contain a "7" or "8" as the fourth digit. An ITIN can be formatted with a space or a dash after the third and forth digits. - *US_PASSPORT_NUMBER* A US passport number. Passport numbers range from six to nine alphanumeric characters. - *US_SOCIAL_SECURITY_NUMBER* A US Social Security Number (SSN) is a nine-digit number that is issued to US citizens, permanent residents, and temporary working residents. - *Canada specific* - *CA_HEALTH_NUMBER* A Canadian Health Service Number is a 10-digit unique identifier, required for individuals to access healthcare benefits. - *CA_SOCIAL_INSURANCE_NUMBER* A Canadian Social Insurance Number (SIN) is a nine-digit unique identifier, required for individuals to access government programs and benefits. The SIN is formatted as three groups of three digits, such as *123-456-789* . A SIN can be validated through a simple check-digit process called the `Luhn algorithm <https://docs.aws.amazon.com/https://www.wikipedia.org/wiki/Luhn_algorithm>`_ . - *UK Specific* - *UK_NATIONAL_HEALTH_SERVICE_NUMBER* A UK National Health Service Number is a 10-17 digit number, such as *485 777 3456* . The current system formats the 10-digit number with spaces after the third and sixth digits. The final digit is an error-detecting checksum. - *UK_NATIONAL_INSURANCE_NUMBER* A UK National Insurance Number (NINO) provides individuals with access to National Insurance (social security) benefits. It is also used for some purposes in the UK tax system. The number is nine digits long and starts with two letters, followed by six numbers and one letter. A NINO can be formatted with a space or a dash after the two letters and after the second, forth, and sixth digits. - *UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER* A UK Unique Taxpayer Reference (UTR) is a 10-digit number that identifies a taxpayer or a business. - *Custom* - *Regex filter* - You can use a regular expressions to define patterns for a guardrail to recognize and act upon such as serial number, booking ID etc..\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-piientityconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    pii_entity_config_property = bedrock.CfnGuardrail.PiiEntityConfigProperty(\n        action="action",\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnGuardrail.PiiEntityConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnGuardrail.RegexConfigProperty
class CfnGuardrail_RegexConfigPropertyDef(BaseStruct):
    action: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The guardrail action to configure when matching regular expression is detected.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the regular expression to configure for the guardrail.\n')
    pattern: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The regular expression pattern to configure for the guardrail.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the regular expression to configure for the guardrail.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-regexconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    regex_config_property = bedrock.CfnGuardrail.RegexConfigProperty(\n        action="action",\n        name="name",\n        pattern="pattern",\n\n        # the properties below are optional\n        description="description"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action', 'name', 'pattern', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnGuardrail.RegexConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnGuardrail.SensitiveInformationPolicyConfigProperty
class CfnGuardrail_SensitiveInformationPolicyConfigPropertyDef(BaseStruct):
    pii_entities_config: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnGuardrail_PiiEntityConfigPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of PII entities to configure to the guardrail.\n')
    regexes_config: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnGuardrail_RegexConfigPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of regular expressions to configure to the guardrail.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-sensitiveinformationpolicyconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    sensitive_information_policy_config_property = bedrock.CfnGuardrail.SensitiveInformationPolicyConfigProperty(\n        pii_entities_config=[bedrock.CfnGuardrail.PiiEntityConfigProperty(\n            action="action",\n            type="type"\n        )],\n        regexes_config=[bedrock.CfnGuardrail.RegexConfigProperty(\n            action="action",\n            name="name",\n            pattern="pattern",\n\n            # the properties below are optional\n            description="description"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['pii_entities_config', 'regexes_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnGuardrail.SensitiveInformationPolicyConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnGuardrail.TopicConfigProperty
class CfnGuardrail_TopicConfigPropertyDef(BaseStruct):
    definition: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A definition of the topic to deny.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the topic to deny.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies to deny the topic.\n')
    examples: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of prompts, each of which is an example of a prompt that can be categorized as belonging to the topic.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-topicconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    topic_config_property = bedrock.CfnGuardrail.TopicConfigProperty(\n        definition="definition",\n        name="name",\n        type="type",\n\n        # the properties below are optional\n        examples=["examples"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['definition', 'name', 'type', 'examples']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnGuardrail.TopicConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnGuardrail.TopicPolicyConfigProperty
class CfnGuardrail_TopicPolicyConfigPropertyDef(BaseStruct):
    topics_config: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnGuardrail_TopicConfigPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of policies related to topics that the guardrail should deny.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-topicpolicyconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    topic_policy_config_property = bedrock.CfnGuardrail.TopicPolicyConfigProperty(\n        topics_config=[bedrock.CfnGuardrail.TopicConfigProperty(\n            definition="definition",\n            name="name",\n            type="type",\n\n            # the properties below are optional\n            examples=["examples"]\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['topics_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnGuardrail.TopicPolicyConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnGuardrail.WordConfigProperty
class CfnGuardrail_WordConfigPropertyDef(BaseStruct):
    text: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Text of the word configured for the guardrail to block.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-wordconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    word_config_property = bedrock.CfnGuardrail.WordConfigProperty(\n        text="text"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['text']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnGuardrail.WordConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnGuardrail.WordPolicyConfigProperty
class CfnGuardrail_WordPolicyConfigPropertyDef(BaseStruct):
    managed_word_lists_config: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnGuardrail_ManagedWordsConfigPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of managed words to configure for the guardrail.\n')
    words_config: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnGuardrail_WordConfigPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of words to configure for the guardrail.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-guardrail-wordpolicyconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    word_policy_config_property = bedrock.CfnGuardrail.WordPolicyConfigProperty(\n        managed_word_lists_config=[bedrock.CfnGuardrail.ManagedWordsConfigProperty(\n            type="type"\n        )],\n        words_config=[bedrock.CfnGuardrail.WordConfigProperty(\n            text="text"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['managed_word_lists_config', 'words_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnGuardrail.WordPolicyConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnKnowledgeBase.KnowledgeBaseConfigurationProperty
class CfnKnowledgeBase_KnowledgeBaseConfigurationPropertyDef(BaseStruct):
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of data that the data source is converted into for the knowledge base.\n')
    vector_knowledge_base_configuration: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_bedrock.CfnKnowledgeBase_VectorKnowledgeBaseConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Contains details about the embeddings model that\'sused to convert the data source.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-knowledgebaseconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    knowledge_base_configuration_property = bedrock.CfnKnowledgeBase.KnowledgeBaseConfigurationProperty(\n        type="type",\n        vector_knowledge_base_configuration=bedrock.CfnKnowledgeBase.VectorKnowledgeBaseConfigurationProperty(\n            embedding_model_arn="embeddingModelArn"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'vector_knowledge_base_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnKnowledgeBase.KnowledgeBaseConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnKnowledgeBase.OpenSearchServerlessConfigurationProperty
class CfnKnowledgeBase_OpenSearchServerlessConfigurationPropertyDef(BaseStruct):
    collection_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the OpenSearch Service vector store.\n')
    field_mapping: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_bedrock.CfnKnowledgeBase_OpenSearchServerlessFieldMappingPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Contains the names of the fields to which to map information about the vector store.\n')
    vector_index_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the vector store.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-opensearchserverlessconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    open_search_serverless_configuration_property = bedrock.CfnKnowledgeBase.OpenSearchServerlessConfigurationProperty(\n        collection_arn="collectionArn",\n        field_mapping=bedrock.CfnKnowledgeBase.OpenSearchServerlessFieldMappingProperty(\n            metadata_field="metadataField",\n            text_field="textField",\n            vector_field="vectorField"\n        ),\n        vector_index_name="vectorIndexName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['collection_arn', 'field_mapping', 'vector_index_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnKnowledgeBase.OpenSearchServerlessConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnKnowledgeBase.OpenSearchServerlessFieldMappingProperty
class CfnKnowledgeBase_OpenSearchServerlessFieldMappingPropertyDef(BaseStruct):
    metadata_field: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the field in which Amazon Bedrock stores metadata about the vector store.\n')
    text_field: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.\n')
    vector_field: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-opensearchserverlessfieldmapping.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    open_search_serverless_field_mapping_property = bedrock.CfnKnowledgeBase.OpenSearchServerlessFieldMappingProperty(\n        metadata_field="metadataField",\n        text_field="textField",\n        vector_field="vectorField"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['metadata_field', 'text_field', 'vector_field']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnKnowledgeBase.OpenSearchServerlessFieldMappingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnKnowledgeBase.PineconeConfigurationProperty
class CfnKnowledgeBase_PineconeConfigurationPropertyDef(BaseStruct):
    connection_string: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The endpoint URL for your index management page.\n')
    credentials_secret_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.\n')
    field_mapping: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_bedrock.CfnKnowledgeBase_PineconeFieldMappingPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Contains the names of the fields to which to map information about the vector store.\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description='The namespace to be used to write new data to your database.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-pineconeconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    pinecone_configuration_property = bedrock.CfnKnowledgeBase.PineconeConfigurationProperty(\n        connection_string="connectionString",\n        credentials_secret_arn="credentialsSecretArn",\n        field_mapping=bedrock.CfnKnowledgeBase.PineconeFieldMappingProperty(\n            metadata_field="metadataField",\n            text_field="textField"\n        ),\n\n        # the properties below are optional\n        namespace="namespace"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_string', 'credentials_secret_arn', 'field_mapping', 'namespace']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnKnowledgeBase.PineconeConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnKnowledgeBase.PineconeFieldMappingProperty
class CfnKnowledgeBase_PineconeFieldMappingPropertyDef(BaseStruct):
    metadata_field: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the field in which Amazon Bedrock stores metadata about the vector store.\n')
    text_field: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-pineconefieldmapping.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    pinecone_field_mapping_property = bedrock.CfnKnowledgeBase.PineconeFieldMappingProperty(\n        metadata_field="metadataField",\n        text_field="textField"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['metadata_field', 'text_field']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnKnowledgeBase.PineconeFieldMappingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnKnowledgeBase.RdsConfigurationProperty
class CfnKnowledgeBase_RdsConfigurationPropertyDef(BaseStruct):
    credentials_secret_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.\n')
    database_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of your Amazon RDS database.\n')
    field_mapping: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_bedrock.CfnKnowledgeBase_RdsFieldMappingPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Contains the names of the fields to which to map information about the vector store.\n')
    resource_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the vector store.\n')
    table_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the table in the database.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-rdsconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    rds_configuration_property = bedrock.CfnKnowledgeBase.RdsConfigurationProperty(\n        credentials_secret_arn="credentialsSecretArn",\n        database_name="databaseName",\n        field_mapping=bedrock.CfnKnowledgeBase.RdsFieldMappingProperty(\n            metadata_field="metadataField",\n            primary_key_field="primaryKeyField",\n            text_field="textField",\n            vector_field="vectorField"\n        ),\n        resource_arn="resourceArn",\n        table_name="tableName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['credentials_secret_arn', 'database_name', 'field_mapping', 'resource_arn', 'table_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnKnowledgeBase.RdsConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnKnowledgeBase.RdsFieldMappingProperty
class CfnKnowledgeBase_RdsFieldMappingPropertyDef(BaseStruct):
    metadata_field: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the field in which Amazon Bedrock stores metadata about the vector store.\n')
    primary_key_field: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the field in which Amazon Bedrock stores the ID for each entry.\n')
    text_field: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.\n')
    vector_field: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-rdsfieldmapping.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    rds_field_mapping_property = bedrock.CfnKnowledgeBase.RdsFieldMappingProperty(\n        metadata_field="metadataField",\n        primary_key_field="primaryKeyField",\n        text_field="textField",\n        vector_field="vectorField"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['metadata_field', 'primary_key_field', 'text_field', 'vector_field']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnKnowledgeBase.RdsFieldMappingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnKnowledgeBase.StorageConfigurationProperty
class CfnKnowledgeBase_StorageConfigurationPropertyDef(BaseStruct):
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The vector store service in which the knowledge base is stored.\n')
    opensearch_serverless_configuration: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnKnowledgeBase_OpenSearchServerlessConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.\n')
    pinecone_configuration: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnKnowledgeBase_PineconeConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains the storage configuration of the knowledge base in Pinecone.\n')
    rds_configuration: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnKnowledgeBase_RdsConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see `Create a vector index in Amazon RDS <https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-rds.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-storageconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    storage_configuration_property = bedrock.CfnKnowledgeBase.StorageConfigurationProperty(\n        type="type",\n\n        # the properties below are optional\n        opensearch_serverless_configuration=bedrock.CfnKnowledgeBase.OpenSearchServerlessConfigurationProperty(\n            collection_arn="collectionArn",\n            field_mapping=bedrock.CfnKnowledgeBase.OpenSearchServerlessFieldMappingProperty(\n                metadata_field="metadataField",\n                text_field="textField",\n                vector_field="vectorField"\n            ),\n            vector_index_name="vectorIndexName"\n        ),\n        pinecone_configuration=bedrock.CfnKnowledgeBase.PineconeConfigurationProperty(\n            connection_string="connectionString",\n            credentials_secret_arn="credentialsSecretArn",\n            field_mapping=bedrock.CfnKnowledgeBase.PineconeFieldMappingProperty(\n                metadata_field="metadataField",\n                text_field="textField"\n            ),\n\n            # the properties below are optional\n            namespace="namespace"\n        ),\n        rds_configuration=bedrock.CfnKnowledgeBase.RdsConfigurationProperty(\n            credentials_secret_arn="credentialsSecretArn",\n            database_name="databaseName",\n            field_mapping=bedrock.CfnKnowledgeBase.RdsFieldMappingProperty(\n                metadata_field="metadataField",\n                primary_key_field="primaryKeyField",\n                text_field="textField",\n                vector_field="vectorField"\n            ),\n            resource_arn="resourceArn",\n            table_name="tableName"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'opensearch_serverless_configuration', 'pinecone_configuration', 'rds_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnKnowledgeBase.StorageConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnKnowledgeBase.VectorKnowledgeBaseConfigurationProperty
class CfnKnowledgeBase_VectorKnowledgeBaseConfigurationPropertyDef(BaseStruct):
    embedding_model_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the model used to create vector embeddings for the knowledge base.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-bedrock-knowledgebase-vectorknowledgebaseconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    vector_knowledge_base_configuration_property = bedrock.CfnKnowledgeBase.VectorKnowledgeBaseConfigurationProperty(\n        embedding_model_arn="embeddingModelArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['embedding_model_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnKnowledgeBase.VectorKnowledgeBaseConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.IModel
#  skipping Interface

#  autogenerated from aws_cdk.aws_bedrock.CfnAgent
class CfnAgentDef(BaseCfnResource):
    agent_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the agent.\n')
    action_groups: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_AgentActionGroupPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The action groups that belong to an agent.\n')
    agent_resource_role_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.\n')
    auto_prepare: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether to automatically update the ``DRAFT`` version of the agent after making changes to the agent. The ``DRAFT`` version can be continually iterated upon during internal development. By default, this value is ``false`` . Default: - false\n')
    customer_encryption_key_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the AWS KMS key that encrypts the agent.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the agent.\n')
    foundation_model: typing.Optional[str] = pydantic.Field(None, description='The foundation model used for orchestration by the agent.\n')
    guardrail_configuration: typing.Union[models.UnsupportedResource, aws_cdk.aws_bedrock.CfnAgent.GuardrailConfigurationProperty, dict[str, typing.Any], None] = pydantic.Field(None, description='Details about the guardrail associated with the agent.\n')
    idle_session_ttl_in_seconds: typing.Union[int, float, None] = pydantic.Field(None, description="The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.\n")
    instruction: typing.Optional[str] = pydantic.Field(None, description='Instructions that tell the agent what it should do and how it should interact with users.\n')
    knowledge_bases: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_AgentKnowledgeBasePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The knowledge bases associated with the agent.\n')
    prompt_override_configuration: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_PromptOverrideConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains configurations to override prompt templates in different parts of an agent sequence. For more information, see `Advanced prompts <https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html>`_ .\n')
    skip_resource_in_use_check_on_delete: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="Specifies whether to delete the resource even if it's in use. By default, this value is ``false`` . Default: - false\n")
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:. - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_ - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_\n')
    test_alias_tags: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:. - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_ - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_')
    _init_params: typing.ClassVar[list[str]] = ['agent_name', 'action_groups', 'agent_resource_role_arn', 'auto_prepare', 'customer_encryption_key_arn', 'description', 'foundation_model', 'guardrail_configuration', 'idle_session_ttl_in_seconds', 'instruction', 'knowledge_bases', 'prompt_override_configuration', 'skip_resource_in_use_check_on_delete', 'tags', 'test_alias_tags']
    _method_names: typing.ClassVar[list[str]] = ['APISchemaProperty', 'ActionGroupExecutorProperty', 'AgentActionGroupProperty', 'AgentKnowledgeBaseProperty', 'FunctionProperty', 'FunctionSchemaProperty', 'GuardrailConfigurationProperty', 'InferenceConfigurationProperty', 'ParameterDetailProperty', 'PromptConfigurationProperty', 'PromptOverrideConfigurationProperty', 'S3IdentifierProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnAgent'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_bedrock.CfnAgentDefConfig] = pydantic.Field(None)


class CfnAgentDefConfig(pydantic.BaseModel):
    APISchemaProperty: typing.Optional[list[models.aws_bedrock.CfnAgentDefApischemapropertyParams]] = pydantic.Field(None, description='')
    ActionGroupExecutorProperty: typing.Optional[list[models.aws_bedrock.CfnAgentDefActiongroupexecutorpropertyParams]] = pydantic.Field(None, description='')
    AgentActionGroupProperty: typing.Optional[list[models.aws_bedrock.CfnAgentDefAgentactiongrouppropertyParams]] = pydantic.Field(None, description='')
    AgentKnowledgeBaseProperty: typing.Optional[list[models.aws_bedrock.CfnAgentDefAgentknowledgebasepropertyParams]] = pydantic.Field(None, description='')
    FunctionProperty: typing.Optional[list[models.aws_bedrock.CfnAgentDefFunctionpropertyParams]] = pydantic.Field(None, description='')
    FunctionSchemaProperty: typing.Optional[list[models.aws_bedrock.CfnAgentDefFunctionschemapropertyParams]] = pydantic.Field(None, description='')
    GuardrailConfigurationProperty: typing.Optional[list[models.aws_bedrock.CfnAgentDefGuardrailconfigurationpropertyParams]] = pydantic.Field(None, description='')
    InferenceConfigurationProperty: typing.Optional[list[models.aws_bedrock.CfnAgentDefInferenceconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ParameterDetailProperty: typing.Optional[list[models.aws_bedrock.CfnAgentDefParameterdetailpropertyParams]] = pydantic.Field(None, description='')
    PromptConfigurationProperty: typing.Optional[list[models.aws_bedrock.CfnAgentDefPromptconfigurationpropertyParams]] = pydantic.Field(None, description='')
    PromptOverrideConfigurationProperty: typing.Optional[list[models.aws_bedrock.CfnAgentDefPromptoverrideconfigurationpropertyParams]] = pydantic.Field(None, description='')
    S3IdentifierProperty: typing.Optional[list[models.aws_bedrock.CfnAgentDefS3IdentifierpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_bedrock.CfnAgentDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_bedrock.CfnAgentDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_bedrock.CfnAgentDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_bedrock.CfnAgentDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_bedrock.CfnAgentDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_bedrock.CfnAgentDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_bedrock.CfnAgentDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_bedrock.CfnAgentDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_bedrock.CfnAgentDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_bedrock.CfnAgentDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_bedrock.CfnAgentDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_bedrock.CfnAgentDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_bedrock.CfnAgentDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnAgentDefApischemapropertyParams(pydantic.BaseModel):
    payload: typing.Optional[str] = pydantic.Field(None, description='')
    s3: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_S3IdentifierPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnAgentDefActiongroupexecutorpropertyParams(pydantic.BaseModel):
    custom_control: typing.Optional[str] = pydantic.Field(None, description='')
    lambda_: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAgentDefAgentactiongrouppropertyParams(pydantic.BaseModel):
    action_group_name: str = pydantic.Field(..., description='')
    action_group_executor: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_ActionGroupExecutorPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    action_group_state: typing.Optional[str] = pydantic.Field(None, description='')
    api_schema: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_APISchemaPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    function_schema: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_FunctionSchemaPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    parent_action_group_signature: typing.Optional[str] = pydantic.Field(None, description='')
    skip_resource_in_use_check_on_delete: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnAgentDefAgentknowledgebasepropertyParams(pydantic.BaseModel):
    description: str = pydantic.Field(..., description='')
    knowledge_base_id: str = pydantic.Field(..., description='')
    knowledge_base_state: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAgentDefFunctionpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    parameters: typing.Union[models.UnsupportedResource, typing.Mapping[str, typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_ParameterDetailPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnAgentDefFunctionschemapropertyParams(pydantic.BaseModel):
    functions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_FunctionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnAgentDefGuardrailconfigurationpropertyParams(pydantic.BaseModel):
    guardrail_identifier: typing.Optional[str] = pydantic.Field(None, description='')
    guardrail_version: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAgentDefInferenceconfigurationpropertyParams(pydantic.BaseModel):
    maximum_length: typing.Union[int, float, None] = pydantic.Field(None, description='')
    stop_sequences: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    temperature: typing.Union[int, float, None] = pydantic.Field(None, description='')
    top_k: typing.Union[int, float, None] = pydantic.Field(None, description='')
    top_p: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnAgentDefParameterdetailpropertyParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    required: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnAgentDefPromptconfigurationpropertyParams(pydantic.BaseModel):
    base_prompt_template: typing.Optional[str] = pydantic.Field(None, description='')
    inference_configuration: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_InferenceConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    parser_mode: typing.Optional[str] = pydantic.Field(None, description='')
    prompt_creation_mode: typing.Optional[str] = pydantic.Field(None, description='')
    prompt_state: typing.Optional[str] = pydantic.Field(None, description='')
    prompt_type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAgentDefPromptoverrideconfigurationpropertyParams(pydantic.BaseModel):
    prompt_configurations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_PromptConfigurationPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    override_lambda: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAgentDefS3IdentifierpropertyParams(pydantic.BaseModel):
    s3_bucket_name: typing.Optional[str] = pydantic.Field(None, description='')
    s3_object_key: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAgentDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAgentDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAgentDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAgentDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAgentDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAgentDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAgentDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAgentDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAgentDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAgentDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAgentDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnAgentDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAgentDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAgentDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_bedrock.CfnAgentAlias
class CfnAgentAliasDef(BaseCfnResource):
    agent_alias_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the alias of the agent.\n')
    agent_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique identifier of the agent.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the alias of the agent.\n')
    routing_configuration: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgentAlias_AgentAliasRoutingConfigurationListItemPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Contains details about the routing configuration of the alias.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:. - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_ - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_')
    _init_params: typing.ClassVar[list[str]] = ['agent_alias_name', 'agent_id', 'description', 'routing_configuration', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['AgentAliasHistoryEventProperty', 'AgentAliasRoutingConfigurationListItemProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnAgentAlias'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_bedrock.CfnAgentAliasDefConfig] = pydantic.Field(None)


class CfnAgentAliasDefConfig(pydantic.BaseModel):
    AgentAliasHistoryEventProperty: typing.Optional[list[models.aws_bedrock.CfnAgentAliasDefAgentaliashistoryeventpropertyParams]] = pydantic.Field(None, description='')
    AgentAliasRoutingConfigurationListItemProperty: typing.Optional[list[models.aws_bedrock.CfnAgentAliasDefAgentaliasroutingconfigurationlistitempropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_bedrock.CfnAgentAliasDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_bedrock.CfnAgentAliasDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_bedrock.CfnAgentAliasDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_bedrock.CfnAgentAliasDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_bedrock.CfnAgentAliasDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_bedrock.CfnAgentAliasDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_bedrock.CfnAgentAliasDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_bedrock.CfnAgentAliasDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_bedrock.CfnAgentAliasDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_bedrock.CfnAgentAliasDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_bedrock.CfnAgentAliasDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_bedrock.CfnAgentAliasDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_bedrock.CfnAgentAliasDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_agent_alias_history_events_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnAgentAliasDefAgentaliashistoryeventpropertyParams(pydantic.BaseModel):
    end_date: typing.Optional[str] = pydantic.Field(None, description='')
    routing_configuration: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgentAlias_AgentAliasRoutingConfigurationListItemPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    start_date: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAgentAliasDefAgentaliasroutingconfigurationlistitempropertyParams(pydantic.BaseModel):
    agent_version: str = pydantic.Field(..., description='')
    ...

class CfnAgentAliasDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAgentAliasDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAgentAliasDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAgentAliasDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAgentAliasDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAgentAliasDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAgentAliasDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAgentAliasDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAgentAliasDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAgentAliasDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAgentAliasDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnAgentAliasDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAgentAliasDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAgentAliasDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_bedrock.CfnDataSource
class CfnDataSourceDef(BaseCfnResource):
    data_source_configuration: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_bedrock.CfnDataSource_DataSourceConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Contains details about how the data source is stored.\n')
    knowledge_base_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique identifier of the knowledge base to which the data source belongs.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the data source.\n')
    data_deletion_policy: typing.Optional[str] = pydantic.Field(None, description='The data deletion policy for a data source.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the data source.\n')
    server_side_encryption_configuration: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnDataSource_ServerSideEncryptionConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains details about the configuration of the server-side encryption.\n')
    vector_ingestion_configuration: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnDataSource_VectorIngestionConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains details about how to ingest the documents in the data source.')
    _init_params: typing.ClassVar[list[str]] = ['data_source_configuration', 'knowledge_base_id', 'name', 'data_deletion_policy', 'description', 'server_side_encryption_configuration', 'vector_ingestion_configuration']
    _method_names: typing.ClassVar[list[str]] = ['ChunkingConfigurationProperty', 'DataSourceConfigurationProperty', 'FixedSizeChunkingConfigurationProperty', 'S3DataSourceConfigurationProperty', 'ServerSideEncryptionConfigurationProperty', 'VectorIngestionConfigurationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnDataSource'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_bedrock.CfnDataSourceDefConfig] = pydantic.Field(None)


class CfnDataSourceDefConfig(pydantic.BaseModel):
    ChunkingConfigurationProperty: typing.Optional[list[models.aws_bedrock.CfnDataSourceDefChunkingconfigurationpropertyParams]] = pydantic.Field(None, description='')
    DataSourceConfigurationProperty: typing.Optional[list[models.aws_bedrock.CfnDataSourceDefDatasourceconfigurationpropertyParams]] = pydantic.Field(None, description='')
    FixedSizeChunkingConfigurationProperty: typing.Optional[list[models.aws_bedrock.CfnDataSourceDefFixedsizechunkingconfigurationpropertyParams]] = pydantic.Field(None, description='')
    S3DataSourceConfigurationProperty: typing.Optional[list[models.aws_bedrock.CfnDataSourceDefS3DatasourceconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ServerSideEncryptionConfigurationProperty: typing.Optional[list[models.aws_bedrock.CfnDataSourceDefServersideencryptionconfigurationpropertyParams]] = pydantic.Field(None, description='')
    VectorIngestionConfigurationProperty: typing.Optional[list[models.aws_bedrock.CfnDataSourceDefVectoringestionconfigurationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_bedrock.CfnDataSourceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_bedrock.CfnDataSourceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_bedrock.CfnDataSourceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_bedrock.CfnDataSourceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_bedrock.CfnDataSourceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_bedrock.CfnDataSourceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_bedrock.CfnDataSourceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_bedrock.CfnDataSourceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_bedrock.CfnDataSourceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_bedrock.CfnDataSourceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_bedrock.CfnDataSourceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_bedrock.CfnDataSourceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_bedrock.CfnDataSourceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnDataSourceDefChunkingconfigurationpropertyParams(pydantic.BaseModel):
    chunking_strategy: str = pydantic.Field(..., description='')
    fixed_size_chunking_configuration: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnDataSource_FixedSizeChunkingConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnDataSourceDefDatasourceconfigurationpropertyParams(pydantic.BaseModel):
    s3_configuration: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnDataSource_S3DataSourceConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    ...

class CfnDataSourceDefFixedsizechunkingconfigurationpropertyParams(pydantic.BaseModel):
    max_tokens: typing.Union[int, float] = pydantic.Field(..., description='')
    overlap_percentage: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnDataSourceDefS3DatasourceconfigurationpropertyParams(pydantic.BaseModel):
    bucket_arn: str = pydantic.Field(..., description='')
    bucket_owner_account_id: typing.Optional[str] = pydantic.Field(None, description='')
    inclusion_prefixes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnDataSourceDefServersideencryptionconfigurationpropertyParams(pydantic.BaseModel):
    kms_key_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDataSourceDefVectoringestionconfigurationpropertyParams(pydantic.BaseModel):
    chunking_configuration: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnDataSource_ChunkingConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnDataSourceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDataSourceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDataSourceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDataSourceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDataSourceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDataSourceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDataSourceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDataSourceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDataSourceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDataSourceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDataSourceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDataSourceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDataSourceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDataSourceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_bedrock.CfnGuardrail
class CfnGuardrailDef(BaseCfnResource):
    blocked_input_messaging: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The message to return when the guardrail blocks a prompt.\n')
    blocked_outputs_messaging: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The message to return when the guardrail blocks a model response.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the guardrail.\n')
    content_policy_config: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnGuardrail_ContentPolicyConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The content filter policies to configure for the guardrail.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the guardrail.\n')
    kms_key_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the AWS KMS key that you use to encrypt the guardrail.\n')
    sensitive_information_policy_config: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnGuardrail_SensitiveInformationPolicyConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The sensitive information policy to configure for the guardrail.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags that you want to attach to the guardrail.\n')
    topic_policy_config: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnGuardrail_TopicPolicyConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The topic policies to configure for the guardrail.\n')
    word_policy_config: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnGuardrail_WordPolicyConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The word policy you configure for the guardrail.')
    _init_params: typing.ClassVar[list[str]] = ['blocked_input_messaging', 'blocked_outputs_messaging', 'name', 'content_policy_config', 'description', 'kms_key_arn', 'sensitive_information_policy_config', 'tags', 'topic_policy_config', 'word_policy_config']
    _method_names: typing.ClassVar[list[str]] = ['ContentFilterConfigProperty', 'ContentPolicyConfigProperty', 'ManagedWordsConfigProperty', 'PiiEntityConfigProperty', 'RegexConfigProperty', 'SensitiveInformationPolicyConfigProperty', 'TopicConfigProperty', 'TopicPolicyConfigProperty', 'WordConfigProperty', 'WordPolicyConfigProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnGuardrail'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_bedrock.CfnGuardrailDefConfig] = pydantic.Field(None)


class CfnGuardrailDefConfig(pydantic.BaseModel):
    ContentFilterConfigProperty: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefContentfilterconfigpropertyParams]] = pydantic.Field(None, description='')
    ContentPolicyConfigProperty: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefContentpolicyconfigpropertyParams]] = pydantic.Field(None, description='')
    ManagedWordsConfigProperty: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefManagedwordsconfigpropertyParams]] = pydantic.Field(None, description='')
    PiiEntityConfigProperty: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefPiientityconfigpropertyParams]] = pydantic.Field(None, description='')
    RegexConfigProperty: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefRegexconfigpropertyParams]] = pydantic.Field(None, description='')
    SensitiveInformationPolicyConfigProperty: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefSensitiveinformationpolicyconfigpropertyParams]] = pydantic.Field(None, description='')
    TopicConfigProperty: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefTopicconfigpropertyParams]] = pydantic.Field(None, description='')
    TopicPolicyConfigProperty: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefTopicpolicyconfigpropertyParams]] = pydantic.Field(None, description='')
    WordConfigProperty: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefWordconfigpropertyParams]] = pydantic.Field(None, description='')
    WordPolicyConfigProperty: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefWordpolicyconfigpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_bedrock.CfnGuardrailDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnGuardrailDefContentfilterconfigpropertyParams(pydantic.BaseModel):
    input_strength: str = pydantic.Field(..., description='')
    output_strength: str = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    ...

class CfnGuardrailDefContentpolicyconfigpropertyParams(pydantic.BaseModel):
    filters_config: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnGuardrail_ContentFilterConfigPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnGuardrailDefManagedwordsconfigpropertyParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='')
    ...

class CfnGuardrailDefPiientityconfigpropertyParams(pydantic.BaseModel):
    action: str = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    ...

class CfnGuardrailDefRegexconfigpropertyParams(pydantic.BaseModel):
    action: str = pydantic.Field(..., description='')
    name: str = pydantic.Field(..., description='')
    pattern: str = pydantic.Field(..., description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnGuardrailDefSensitiveinformationpolicyconfigpropertyParams(pydantic.BaseModel):
    pii_entities_config: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnGuardrail_PiiEntityConfigPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    regexes_config: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnGuardrail_RegexConfigPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnGuardrailDefTopicconfigpropertyParams(pydantic.BaseModel):
    definition: str = pydantic.Field(..., description='')
    name: str = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    examples: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnGuardrailDefTopicpolicyconfigpropertyParams(pydantic.BaseModel):
    topics_config: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnGuardrail_TopicConfigPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnGuardrailDefWordconfigpropertyParams(pydantic.BaseModel):
    text: str = pydantic.Field(..., description='')
    ...

class CfnGuardrailDefWordpolicyconfigpropertyParams(pydantic.BaseModel):
    managed_word_lists_config: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnGuardrail_ManagedWordsConfigPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    words_config: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnGuardrail_WordConfigPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnGuardrailDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnGuardrailDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGuardrailDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnGuardrailDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGuardrailDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnGuardrailDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnGuardrailDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnGuardrailDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnGuardrailDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnGuardrailDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGuardrailDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnGuardrailDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnGuardrailDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGuardrailDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_bedrock.CfnGuardrailVersion
class CfnGuardrailVersionDef(BaseCfnResource):
    guardrail_identifier: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique identifier of the guardrail. This can be an ID or the ARN.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the guardrail version.')
    _init_params: typing.ClassVar[list[str]] = ['guardrail_identifier', 'description']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnGuardrailVersion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_bedrock.CfnGuardrailVersionDefConfig] = pydantic.Field(None)


class CfnGuardrailVersionDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_bedrock.CfnGuardrailVersionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_bedrock.CfnGuardrailVersionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_bedrock.CfnGuardrailVersionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_bedrock.CfnGuardrailVersionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_bedrock.CfnGuardrailVersionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_bedrock.CfnGuardrailVersionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_bedrock.CfnGuardrailVersionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_bedrock.CfnGuardrailVersionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_bedrock.CfnGuardrailVersionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_bedrock.CfnGuardrailVersionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_bedrock.CfnGuardrailVersionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_bedrock.CfnGuardrailVersionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_bedrock.CfnGuardrailVersionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnGuardrailVersionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnGuardrailVersionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGuardrailVersionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnGuardrailVersionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGuardrailVersionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnGuardrailVersionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnGuardrailVersionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnGuardrailVersionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnGuardrailVersionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnGuardrailVersionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGuardrailVersionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnGuardrailVersionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnGuardrailVersionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGuardrailVersionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_bedrock.CfnKnowledgeBase
class CfnKnowledgeBaseDef(BaseCfnResource):
    knowledge_base_configuration: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_bedrock.CfnKnowledgeBase_KnowledgeBaseConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Contains details about the embeddings configuration of the knowledge base.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the knowledge base.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base.\n')
    storage_configuration: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_bedrock.CfnKnowledgeBase_StorageConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Contains details about the storage configuration of the knowledge base.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the knowledge base.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:. - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_ - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_')
    _init_params: typing.ClassVar[list[str]] = ['knowledge_base_configuration', 'name', 'role_arn', 'storage_configuration', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['KnowledgeBaseConfigurationProperty', 'OpenSearchServerlessConfigurationProperty', 'OpenSearchServerlessFieldMappingProperty', 'PineconeConfigurationProperty', 'PineconeFieldMappingProperty', 'RdsConfigurationProperty', 'RdsFieldMappingProperty', 'StorageConfigurationProperty', 'VectorKnowledgeBaseConfigurationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnKnowledgeBase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_bedrock.CfnKnowledgeBaseDefConfig] = pydantic.Field(None)


class CfnKnowledgeBaseDefConfig(pydantic.BaseModel):
    KnowledgeBaseConfigurationProperty: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefKnowledgebaseconfigurationpropertyParams]] = pydantic.Field(None, description='')
    OpenSearchServerlessConfigurationProperty: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefOpensearchserverlessconfigurationpropertyParams]] = pydantic.Field(None, description='')
    OpenSearchServerlessFieldMappingProperty: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefOpensearchserverlessfieldmappingpropertyParams]] = pydantic.Field(None, description='')
    PineconeConfigurationProperty: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefPineconeconfigurationpropertyParams]] = pydantic.Field(None, description='')
    PineconeFieldMappingProperty: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefPineconefieldmappingpropertyParams]] = pydantic.Field(None, description='')
    RdsConfigurationProperty: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefRdsconfigurationpropertyParams]] = pydantic.Field(None, description='')
    RdsFieldMappingProperty: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefRdsfieldmappingpropertyParams]] = pydantic.Field(None, description='')
    StorageConfigurationProperty: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefStorageconfigurationpropertyParams]] = pydantic.Field(None, description='')
    VectorKnowledgeBaseConfigurationProperty: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefVectorknowledgebaseconfigurationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_bedrock.CfnKnowledgeBaseDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnKnowledgeBaseDefKnowledgebaseconfigurationpropertyParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='')
    vector_knowledge_base_configuration: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnKnowledgeBase_VectorKnowledgeBaseConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnKnowledgeBaseDefOpensearchserverlessconfigurationpropertyParams(pydantic.BaseModel):
    collection_arn: str = pydantic.Field(..., description='')
    field_mapping: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnKnowledgeBase_OpenSearchServerlessFieldMappingPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    vector_index_name: str = pydantic.Field(..., description='')
    ...

class CfnKnowledgeBaseDefOpensearchserverlessfieldmappingpropertyParams(pydantic.BaseModel):
    metadata_field: str = pydantic.Field(..., description='')
    text_field: str = pydantic.Field(..., description='')
    vector_field: str = pydantic.Field(..., description='')
    ...

class CfnKnowledgeBaseDefPineconeconfigurationpropertyParams(pydantic.BaseModel):
    connection_string: str = pydantic.Field(..., description='')
    credentials_secret_arn: str = pydantic.Field(..., description='')
    field_mapping: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnKnowledgeBase_PineconeFieldMappingPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    namespace: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnKnowledgeBaseDefPineconefieldmappingpropertyParams(pydantic.BaseModel):
    metadata_field: str = pydantic.Field(..., description='')
    text_field: str = pydantic.Field(..., description='')
    ...

class CfnKnowledgeBaseDefRdsconfigurationpropertyParams(pydantic.BaseModel):
    credentials_secret_arn: str = pydantic.Field(..., description='')
    database_name: str = pydantic.Field(..., description='')
    field_mapping: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnKnowledgeBase_RdsFieldMappingPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    resource_arn: str = pydantic.Field(..., description='')
    table_name: str = pydantic.Field(..., description='')
    ...

class CfnKnowledgeBaseDefRdsfieldmappingpropertyParams(pydantic.BaseModel):
    metadata_field: str = pydantic.Field(..., description='')
    primary_key_field: str = pydantic.Field(..., description='')
    text_field: str = pydantic.Field(..., description='')
    vector_field: str = pydantic.Field(..., description='')
    ...

class CfnKnowledgeBaseDefStorageconfigurationpropertyParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='')
    opensearch_serverless_configuration: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnKnowledgeBase_OpenSearchServerlessConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    pinecone_configuration: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnKnowledgeBase_PineconeConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    rds_configuration: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnKnowledgeBase_RdsConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnKnowledgeBaseDefVectorknowledgebaseconfigurationpropertyParams(pydantic.BaseModel):
    embedding_model_arn: str = pydantic.Field(..., description='')
    ...

class CfnKnowledgeBaseDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnKnowledgeBaseDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnKnowledgeBaseDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnKnowledgeBaseDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnKnowledgeBaseDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnKnowledgeBaseDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnKnowledgeBaseDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnKnowledgeBaseDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnKnowledgeBaseDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnKnowledgeBaseDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnKnowledgeBaseDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnKnowledgeBaseDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnKnowledgeBaseDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnKnowledgeBaseDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_bedrock.CfnAgentAliasProps
class CfnAgentAliasPropsDef(BaseCfnProperty):
    agent_alias_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the alias of the agent.\n')
    agent_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique identifier of the agent.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the alias of the agent.\n')
    routing_configuration: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgentAlias_AgentAliasRoutingConfigurationListItemPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Contains details about the routing configuration of the alias.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:. - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_ - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agentalias.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    cfn_agent_alias_props = bedrock.CfnAgentAliasProps(\n        agent_alias_name="agentAliasName",\n        agent_id="agentId",\n\n        # the properties below are optional\n        description="description",\n        routing_configuration=[bedrock.CfnAgentAlias.AgentAliasRoutingConfigurationListItemProperty(\n            agent_version="agentVersion"\n        )],\n        tags={\n            "tags_key": "tags"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['agent_alias_name', 'agent_id', 'description', 'routing_configuration', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnAgentAliasProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnAgentProps
class CfnAgentPropsDef(BaseCfnProperty):
    agent_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the agent.\n')
    action_groups: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_AgentActionGroupPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The action groups that belong to an agent.\n')
    agent_resource_role_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.\n')
    auto_prepare: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether to automatically update the ``DRAFT`` version of the agent after making changes to the agent. The ``DRAFT`` version can be continually iterated upon during internal development. By default, this value is ``false`` . Default: - false\n')
    customer_encryption_key_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the AWS KMS key that encrypts the agent.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the agent.\n')
    foundation_model: typing.Optional[str] = pydantic.Field(None, description='The foundation model used for orchestration by the agent.\n')
    guardrail_configuration: typing.Union[models.UnsupportedResource, aws_cdk.aws_bedrock.CfnAgent.GuardrailConfigurationProperty, dict[str, typing.Any], None] = pydantic.Field(None, description='Details about the guardrail associated with the agent.\n')
    idle_session_ttl_in_seconds: typing.Union[int, float, None] = pydantic.Field(None, description="The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.\n")
    instruction: typing.Optional[str] = pydantic.Field(None, description='Instructions that tell the agent what it should do and how it should interact with users.\n')
    knowledge_bases: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_AgentKnowledgeBasePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The knowledge bases associated with the agent.\n')
    prompt_override_configuration: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnAgent_PromptOverrideConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains configurations to override prompt templates in different parts of an agent sequence. For more information, see `Advanced prompts <https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html>`_ .\n')
    skip_resource_in_use_check_on_delete: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="Specifies whether to delete the resource even if it's in use. By default, this value is ``false`` . Default: - false\n")
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:. - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_ - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_\n')
    test_alias_tags: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:. - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_ - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-agent.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    cfn_agent_props = bedrock.CfnAgentProps(\n        agent_name="agentName",\n\n        # the properties below are optional\n        action_groups=[bedrock.CfnAgent.AgentActionGroupProperty(\n            action_group_name="actionGroupName",\n\n            # the properties below are optional\n            action_group_executor=bedrock.CfnAgent.ActionGroupExecutorProperty(\n                custom_control="customControl",\n                lambda_="lambda"\n            ),\n            action_group_state="actionGroupState",\n            api_schema=bedrock.CfnAgent.APISchemaProperty(\n                payload="payload",\n                s3=bedrock.CfnAgent.S3IdentifierProperty(\n                    s3_bucket_name="s3BucketName",\n                    s3_object_key="s3ObjectKey"\n                )\n            ),\n            description="description",\n            function_schema=bedrock.CfnAgent.FunctionSchemaProperty(\n                functions=[bedrock.CfnAgent.FunctionProperty(\n                    name="name",\n\n                    # the properties below are optional\n                    description="description",\n                    parameters={\n                        "parameters_key": bedrock.CfnAgent.ParameterDetailProperty(\n                            type="type",\n\n                            # the properties below are optional\n                            description="description",\n                            required=False\n                        )\n                    }\n                )]\n            ),\n            parent_action_group_signature="parentActionGroupSignature",\n            skip_resource_in_use_check_on_delete=False\n        )],\n        agent_resource_role_arn="agentResourceRoleArn",\n        auto_prepare=False,\n        customer_encryption_key_arn="customerEncryptionKeyArn",\n        description="description",\n        foundation_model="foundationModel",\n        guardrail_configuration=bedrock.CfnAgent.GuardrailConfigurationProperty(\n            guardrail_identifier="guardrailIdentifier",\n            guardrail_version="guardrailVersion"\n        ),\n        idle_session_ttl_in_seconds=123,\n        instruction="instruction",\n        knowledge_bases=[bedrock.CfnAgent.AgentKnowledgeBaseProperty(\n            description="description",\n            knowledge_base_id="knowledgeBaseId",\n\n            # the properties below are optional\n            knowledge_base_state="knowledgeBaseState"\n        )],\n        prompt_override_configuration=bedrock.CfnAgent.PromptOverrideConfigurationProperty(\n            prompt_configurations=[bedrock.CfnAgent.PromptConfigurationProperty(\n                base_prompt_template="basePromptTemplate",\n                inference_configuration=bedrock.CfnAgent.InferenceConfigurationProperty(\n                    maximum_length=123,\n                    stop_sequences=["stopSequences"],\n                    temperature=123,\n                    top_k=123,\n                    top_p=123\n                ),\n                parser_mode="parserMode",\n                prompt_creation_mode="promptCreationMode",\n                prompt_state="promptState",\n                prompt_type="promptType"\n            )],\n\n            # the properties below are optional\n            override_lambda="overrideLambda"\n        ),\n        skip_resource_in_use_check_on_delete=False,\n        tags={\n            "tags_key": "tags"\n        },\n        test_alias_tags={\n            "test_alias_tags_key": "testAliasTags"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['agent_name', 'action_groups', 'agent_resource_role_arn', 'auto_prepare', 'customer_encryption_key_arn', 'description', 'foundation_model', 'guardrail_configuration', 'idle_session_ttl_in_seconds', 'instruction', 'knowledge_bases', 'prompt_override_configuration', 'skip_resource_in_use_check_on_delete', 'tags', 'test_alias_tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnAgentProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnDataSourceProps
class CfnDataSourcePropsDef(BaseCfnProperty):
    data_source_configuration: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_bedrock.CfnDataSource_DataSourceConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Contains details about how the data source is stored.\n')
    knowledge_base_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique identifier of the knowledge base to which the data source belongs.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the data source.\n')
    data_deletion_policy: typing.Optional[str] = pydantic.Field(None, description='The data deletion policy for a data source.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the data source.\n')
    server_side_encryption_configuration: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnDataSource_ServerSideEncryptionConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains details about the configuration of the server-side encryption.\n')
    vector_ingestion_configuration: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnDataSource_VectorIngestionConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Contains details about how to ingest the documents in the data source.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-datasource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    cfn_data_source_props = bedrock.CfnDataSourceProps(\n        data_source_configuration=bedrock.CfnDataSource.DataSourceConfigurationProperty(\n            s3_configuration=bedrock.CfnDataSource.S3DataSourceConfigurationProperty(\n                bucket_arn="bucketArn",\n\n                # the properties below are optional\n                bucket_owner_account_id="bucketOwnerAccountId",\n                inclusion_prefixes=["inclusionPrefixes"]\n            ),\n            type="type"\n        ),\n        knowledge_base_id="knowledgeBaseId",\n        name="name",\n\n        # the properties below are optional\n        data_deletion_policy="dataDeletionPolicy",\n        description="description",\n        server_side_encryption_configuration=bedrock.CfnDataSource.ServerSideEncryptionConfigurationProperty(\n            kms_key_arn="kmsKeyArn"\n        ),\n        vector_ingestion_configuration=bedrock.CfnDataSource.VectorIngestionConfigurationProperty(\n            chunking_configuration=bedrock.CfnDataSource.ChunkingConfigurationProperty(\n                chunking_strategy="chunkingStrategy",\n\n                # the properties below are optional\n                fixed_size_chunking_configuration=bedrock.CfnDataSource.FixedSizeChunkingConfigurationProperty(\n                    max_tokens=123,\n                    overlap_percentage=123\n                )\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['data_source_configuration', 'knowledge_base_id', 'name', 'data_deletion_policy', 'description', 'server_side_encryption_configuration', 'vector_ingestion_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnDataSourceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnGuardrailProps
class CfnGuardrailPropsDef(BaseCfnProperty):
    blocked_input_messaging: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The message to return when the guardrail blocks a prompt.\n')
    blocked_outputs_messaging: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The message to return when the guardrail blocks a model response.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the guardrail.\n')
    content_policy_config: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnGuardrail_ContentPolicyConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The content filter policies to configure for the guardrail.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the guardrail.\n')
    kms_key_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the AWS KMS key that you use to encrypt the guardrail.\n')
    sensitive_information_policy_config: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnGuardrail_SensitiveInformationPolicyConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The sensitive information policy to configure for the guardrail.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags that you want to attach to the guardrail.\n')
    topic_policy_config: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnGuardrail_TopicPolicyConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The topic policies to configure for the guardrail.\n')
    word_policy_config: typing.Union[models.UnsupportedResource, models.aws_bedrock.CfnGuardrail_WordPolicyConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The word policy you configure for the guardrail.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-guardrail.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    cfn_guardrail_props = bedrock.CfnGuardrailProps(\n        blocked_input_messaging="blockedInputMessaging",\n        blocked_outputs_messaging="blockedOutputsMessaging",\n        name="name",\n\n        # the properties below are optional\n        content_policy_config=bedrock.CfnGuardrail.ContentPolicyConfigProperty(\n            filters_config=[bedrock.CfnGuardrail.ContentFilterConfigProperty(\n                input_strength="inputStrength",\n                output_strength="outputStrength",\n                type="type"\n            )]\n        ),\n        description="description",\n        kms_key_arn="kmsKeyArn",\n        sensitive_information_policy_config=bedrock.CfnGuardrail.SensitiveInformationPolicyConfigProperty(\n            pii_entities_config=[bedrock.CfnGuardrail.PiiEntityConfigProperty(\n                action="action",\n                type="type"\n            )],\n            regexes_config=[bedrock.CfnGuardrail.RegexConfigProperty(\n                action="action",\n                name="name",\n                pattern="pattern",\n\n                # the properties below are optional\n                description="description"\n            )]\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        topic_policy_config=bedrock.CfnGuardrail.TopicPolicyConfigProperty(\n            topics_config=[bedrock.CfnGuardrail.TopicConfigProperty(\n                definition="definition",\n                name="name",\n                type="type",\n\n                # the properties below are optional\n                examples=["examples"]\n            )]\n        ),\n        word_policy_config=bedrock.CfnGuardrail.WordPolicyConfigProperty(\n            managed_word_lists_config=[bedrock.CfnGuardrail.ManagedWordsConfigProperty(\n                type="type"\n            )],\n            words_config=[bedrock.CfnGuardrail.WordConfigProperty(\n                text="text"\n            )]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['blocked_input_messaging', 'blocked_outputs_messaging', 'name', 'content_policy_config', 'description', 'kms_key_arn', 'sensitive_information_policy_config', 'tags', 'topic_policy_config', 'word_policy_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnGuardrailProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnGuardrailVersionProps
class CfnGuardrailVersionPropsDef(BaseCfnProperty):
    guardrail_identifier: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique identifier of the guardrail. This can be an ID or the ARN.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the guardrail version.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-guardrailversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    cfn_guardrail_version_props = bedrock.CfnGuardrailVersionProps(\n        guardrail_identifier="guardrailIdentifier",\n\n        # the properties below are optional\n        description="description"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['guardrail_identifier', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnGuardrailVersionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_bedrock.CfnKnowledgeBaseProps
class CfnKnowledgeBasePropsDef(BaseCfnProperty):
    knowledge_base_configuration: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_bedrock.CfnKnowledgeBase_KnowledgeBaseConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Contains details about the embeddings configuration of the knowledge base.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the knowledge base.\n')
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base.\n')
    storage_configuration: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_bedrock.CfnKnowledgeBase_StorageConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Contains details about the storage configuration of the knowledge base.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the knowledge base.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Metadata that you can assign to a resource as key-value pairs. For more information, see the following resources:. - `Tag naming limits and requirements <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions>`_ - `Tagging best practices <https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-best-practices>`_\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-knowledgebase.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_bedrock as bedrock\n\n    cfn_knowledge_base_props = bedrock.CfnKnowledgeBaseProps(\n        knowledge_base_configuration=bedrock.CfnKnowledgeBase.KnowledgeBaseConfigurationProperty(\n            type="type",\n            vector_knowledge_base_configuration=bedrock.CfnKnowledgeBase.VectorKnowledgeBaseConfigurationProperty(\n                embedding_model_arn="embeddingModelArn"\n            )\n        ),\n        name="name",\n        role_arn="roleArn",\n        storage_configuration=bedrock.CfnKnowledgeBase.StorageConfigurationProperty(\n            type="type",\n\n            # the properties below are optional\n            opensearch_serverless_configuration=bedrock.CfnKnowledgeBase.OpenSearchServerlessConfigurationProperty(\n                collection_arn="collectionArn",\n                field_mapping=bedrock.CfnKnowledgeBase.OpenSearchServerlessFieldMappingProperty(\n                    metadata_field="metadataField",\n                    text_field="textField",\n                    vector_field="vectorField"\n                ),\n                vector_index_name="vectorIndexName"\n            ),\n            pinecone_configuration=bedrock.CfnKnowledgeBase.PineconeConfigurationProperty(\n                connection_string="connectionString",\n                credentials_secret_arn="credentialsSecretArn",\n                field_mapping=bedrock.CfnKnowledgeBase.PineconeFieldMappingProperty(\n                    metadata_field="metadataField",\n                    text_field="textField"\n                ),\n\n                # the properties below are optional\n                namespace="namespace"\n            ),\n            rds_configuration=bedrock.CfnKnowledgeBase.RdsConfigurationProperty(\n                credentials_secret_arn="credentialsSecretArn",\n                database_name="databaseName",\n                field_mapping=bedrock.CfnKnowledgeBase.RdsFieldMappingProperty(\n                    metadata_field="metadataField",\n                    primary_key_field="primaryKeyField",\n                    text_field="textField",\n                    vector_field="vectorField"\n                ),\n                resource_arn="resourceArn",\n                table_name="tableName"\n            )\n        ),\n\n        # the properties below are optional\n        description="description",\n        tags={\n            "tags_key": "tags"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['knowledge_base_configuration', 'name', 'role_arn', 'storage_configuration', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_bedrock.CfnKnowledgeBaseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    FoundationModel: typing.Optional[dict[str, models.aws_bedrock.FoundationModelDef]] = pydantic.Field(None)
    FoundationModelIdentifier: typing.Optional[dict[str, models.aws_bedrock.FoundationModelIdentifierDef]] = pydantic.Field(None)
    ProvisionedModel: typing.Optional[dict[str, models.aws_bedrock.ProvisionedModelDef]] = pydantic.Field(None)
    CfnAgent_ActionGroupExecutorProperty: typing.Optional[dict[str, models.aws_bedrock.CfnAgent_ActionGroupExecutorPropertyDef]] = pydantic.Field(None)
    CfnAgent_AgentActionGroupProperty: typing.Optional[dict[str, models.aws_bedrock.CfnAgent_AgentActionGroupPropertyDef]] = pydantic.Field(None)
    CfnAgent_AgentKnowledgeBaseProperty: typing.Optional[dict[str, models.aws_bedrock.CfnAgent_AgentKnowledgeBasePropertyDef]] = pydantic.Field(None)
    CfnAgent_APISchemaProperty: typing.Optional[dict[str, models.aws_bedrock.CfnAgent_APISchemaPropertyDef]] = pydantic.Field(None)
    CfnAgent_FunctionProperty: typing.Optional[dict[str, models.aws_bedrock.CfnAgent_FunctionPropertyDef]] = pydantic.Field(None)
    CfnAgent_FunctionSchemaProperty: typing.Optional[dict[str, models.aws_bedrock.CfnAgent_FunctionSchemaPropertyDef]] = pydantic.Field(None)
    CfnAgent_InferenceConfigurationProperty: typing.Optional[dict[str, models.aws_bedrock.CfnAgent_InferenceConfigurationPropertyDef]] = pydantic.Field(None)
    CfnAgent_ParameterDetailProperty: typing.Optional[dict[str, models.aws_bedrock.CfnAgent_ParameterDetailPropertyDef]] = pydantic.Field(None)
    CfnAgent_PromptConfigurationProperty: typing.Optional[dict[str, models.aws_bedrock.CfnAgent_PromptConfigurationPropertyDef]] = pydantic.Field(None)
    CfnAgent_PromptOverrideConfigurationProperty: typing.Optional[dict[str, models.aws_bedrock.CfnAgent_PromptOverrideConfigurationPropertyDef]] = pydantic.Field(None)
    CfnAgent_S3IdentifierProperty: typing.Optional[dict[str, models.aws_bedrock.CfnAgent_S3IdentifierPropertyDef]] = pydantic.Field(None)
    CfnAgentAlias_AgentAliasHistoryEventProperty: typing.Optional[dict[str, models.aws_bedrock.CfnAgentAlias_AgentAliasHistoryEventPropertyDef]] = pydantic.Field(None)
    CfnAgentAlias_AgentAliasRoutingConfigurationListItemProperty: typing.Optional[dict[str, models.aws_bedrock.CfnAgentAlias_AgentAliasRoutingConfigurationListItemPropertyDef]] = pydantic.Field(None)
    CfnDataSource_ChunkingConfigurationProperty: typing.Optional[dict[str, models.aws_bedrock.CfnDataSource_ChunkingConfigurationPropertyDef]] = pydantic.Field(None)
    CfnDataSource_DataSourceConfigurationProperty: typing.Optional[dict[str, models.aws_bedrock.CfnDataSource_DataSourceConfigurationPropertyDef]] = pydantic.Field(None)
    CfnDataSource_FixedSizeChunkingConfigurationProperty: typing.Optional[dict[str, models.aws_bedrock.CfnDataSource_FixedSizeChunkingConfigurationPropertyDef]] = pydantic.Field(None)
    CfnDataSource_S3DataSourceConfigurationProperty: typing.Optional[dict[str, models.aws_bedrock.CfnDataSource_S3DataSourceConfigurationPropertyDef]] = pydantic.Field(None)
    CfnDataSource_ServerSideEncryptionConfigurationProperty: typing.Optional[dict[str, models.aws_bedrock.CfnDataSource_ServerSideEncryptionConfigurationPropertyDef]] = pydantic.Field(None)
    CfnDataSource_VectorIngestionConfigurationProperty: typing.Optional[dict[str, models.aws_bedrock.CfnDataSource_VectorIngestionConfigurationPropertyDef]] = pydantic.Field(None)
    CfnGuardrail_ContentFilterConfigProperty: typing.Optional[dict[str, models.aws_bedrock.CfnGuardrail_ContentFilterConfigPropertyDef]] = pydantic.Field(None)
    CfnGuardrail_ContentPolicyConfigProperty: typing.Optional[dict[str, models.aws_bedrock.CfnGuardrail_ContentPolicyConfigPropertyDef]] = pydantic.Field(None)
    CfnGuardrail_ManagedWordsConfigProperty: typing.Optional[dict[str, models.aws_bedrock.CfnGuardrail_ManagedWordsConfigPropertyDef]] = pydantic.Field(None)
    CfnGuardrail_PiiEntityConfigProperty: typing.Optional[dict[str, models.aws_bedrock.CfnGuardrail_PiiEntityConfigPropertyDef]] = pydantic.Field(None)
    CfnGuardrail_RegexConfigProperty: typing.Optional[dict[str, models.aws_bedrock.CfnGuardrail_RegexConfigPropertyDef]] = pydantic.Field(None)
    CfnGuardrail_SensitiveInformationPolicyConfigProperty: typing.Optional[dict[str, models.aws_bedrock.CfnGuardrail_SensitiveInformationPolicyConfigPropertyDef]] = pydantic.Field(None)
    CfnGuardrail_TopicConfigProperty: typing.Optional[dict[str, models.aws_bedrock.CfnGuardrail_TopicConfigPropertyDef]] = pydantic.Field(None)
    CfnGuardrail_TopicPolicyConfigProperty: typing.Optional[dict[str, models.aws_bedrock.CfnGuardrail_TopicPolicyConfigPropertyDef]] = pydantic.Field(None)
    CfnGuardrail_WordConfigProperty: typing.Optional[dict[str, models.aws_bedrock.CfnGuardrail_WordConfigPropertyDef]] = pydantic.Field(None)
    CfnGuardrail_WordPolicyConfigProperty: typing.Optional[dict[str, models.aws_bedrock.CfnGuardrail_WordPolicyConfigPropertyDef]] = pydantic.Field(None)
    CfnKnowledgeBase_KnowledgeBaseConfigurationProperty: typing.Optional[dict[str, models.aws_bedrock.CfnKnowledgeBase_KnowledgeBaseConfigurationPropertyDef]] = pydantic.Field(None)
    CfnKnowledgeBase_OpenSearchServerlessConfigurationProperty: typing.Optional[dict[str, models.aws_bedrock.CfnKnowledgeBase_OpenSearchServerlessConfigurationPropertyDef]] = pydantic.Field(None)
    CfnKnowledgeBase_OpenSearchServerlessFieldMappingProperty: typing.Optional[dict[str, models.aws_bedrock.CfnKnowledgeBase_OpenSearchServerlessFieldMappingPropertyDef]] = pydantic.Field(None)
    CfnKnowledgeBase_PineconeConfigurationProperty: typing.Optional[dict[str, models.aws_bedrock.CfnKnowledgeBase_PineconeConfigurationPropertyDef]] = pydantic.Field(None)
    CfnKnowledgeBase_PineconeFieldMappingProperty: typing.Optional[dict[str, models.aws_bedrock.CfnKnowledgeBase_PineconeFieldMappingPropertyDef]] = pydantic.Field(None)
    CfnKnowledgeBase_RdsConfigurationProperty: typing.Optional[dict[str, models.aws_bedrock.CfnKnowledgeBase_RdsConfigurationPropertyDef]] = pydantic.Field(None)
    CfnKnowledgeBase_RdsFieldMappingProperty: typing.Optional[dict[str, models.aws_bedrock.CfnKnowledgeBase_RdsFieldMappingPropertyDef]] = pydantic.Field(None)
    CfnKnowledgeBase_StorageConfigurationProperty: typing.Optional[dict[str, models.aws_bedrock.CfnKnowledgeBase_StorageConfigurationPropertyDef]] = pydantic.Field(None)
    CfnKnowledgeBase_VectorKnowledgeBaseConfigurationProperty: typing.Optional[dict[str, models.aws_bedrock.CfnKnowledgeBase_VectorKnowledgeBaseConfigurationPropertyDef]] = pydantic.Field(None)
    CfnAgent: typing.Optional[dict[str, models.aws_bedrock.CfnAgentDef]] = pydantic.Field(None)
    CfnAgentAlias: typing.Optional[dict[str, models.aws_bedrock.CfnAgentAliasDef]] = pydantic.Field(None)
    CfnDataSource: typing.Optional[dict[str, models.aws_bedrock.CfnDataSourceDef]] = pydantic.Field(None)
    CfnGuardrail: typing.Optional[dict[str, models.aws_bedrock.CfnGuardrailDef]] = pydantic.Field(None)
    CfnGuardrailVersion: typing.Optional[dict[str, models.aws_bedrock.CfnGuardrailVersionDef]] = pydantic.Field(None)
    CfnKnowledgeBase: typing.Optional[dict[str, models.aws_bedrock.CfnKnowledgeBaseDef]] = pydantic.Field(None)
    CfnAgentAliasProps: typing.Optional[dict[str, models.aws_bedrock.CfnAgentAliasPropsDef]] = pydantic.Field(None)
    CfnAgentProps: typing.Optional[dict[str, models.aws_bedrock.CfnAgentPropsDef]] = pydantic.Field(None)
    CfnDataSourceProps: typing.Optional[dict[str, models.aws_bedrock.CfnDataSourcePropsDef]] = pydantic.Field(None)
    CfnGuardrailProps: typing.Optional[dict[str, models.aws_bedrock.CfnGuardrailPropsDef]] = pydantic.Field(None)
    CfnGuardrailVersionProps: typing.Optional[dict[str, models.aws_bedrock.CfnGuardrailVersionPropsDef]] = pydantic.Field(None)
    CfnKnowledgeBaseProps: typing.Optional[dict[str, models.aws_bedrock.CfnKnowledgeBasePropsDef]] = pydantic.Field(None)
    ...

import models
