from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_elasticloadbalancingv2_actions.AuthenticateCognitoAction
class AuthenticateCognitoActionDef(BaseClass):
    next: typing.Union[models.aws_elasticloadbalancingv2.ListenerActionDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='What action to execute next. Multiple actions form a linked chain; the chain must always terminate in a (weighted)forward, fixedResponse or redirect action.\n')
    user_pool: typing.Union[_REQUIRED_INIT_PARAM, models.aws_cognito.UserPoolDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Cognito user pool.\n')
    user_pool_client: typing.Union[_REQUIRED_INIT_PARAM, models.aws_cognito.UserPoolClientDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Cognito user pool client.\n')
    user_pool_domain: typing.Union[_REQUIRED_INIT_PARAM, models.aws_cognito.UserPoolDomainDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The domain prefix or fully-qualified domain name of the Amazon Cognito user pool.\n')
    allow_https_outbound: typing.Optional[bool] = pydantic.Field(None, description="Allow HTTPS outbound traffic to communicate with the IdP. Set this property to false if the IP address used for the IdP endpoint is identifiable and you want to control outbound traffic. Then allow HTTPS outbound traffic to the IdP's IP address using the listener's ``connections`` property. Default: true\n")
    authentication_request_extra_params: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The query parameters (up to 10) to include in the redirect request to the authorization endpoint. Default: - No extra parameters\n')
    on_unauthenticated_request: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.UnauthenticatedAction] = pydantic.Field(None, description='The behavior if the user is not authenticated. Default: UnauthenticatedAction.AUTHENTICATE\n')
    session_cookie_name: typing.Optional[str] = pydantic.Field(None, description='The name of the cookie used to maintain session information. Default: "AWSELBAuthSessionCookie"\n')
    session_timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum duration of the authentication session. Default: Duration.days(7)')
    _init_params: typing.ClassVar[list[str]] = ['next', 'user_pool', 'user_pool_client', 'user_pool_domain', 'allow_https_outbound', 'authentication_request_extra_params', 'on_unauthenticated_request', 'session_cookie_name', 'session_timeout']
    _method_names: typing.ClassVar[list[str]] = ['bind', 'render_actions', 'render_rule_actions']
    _classmethod_names: typing.ClassVar[list[str]] = ['authenticate_oidc', 'fixed_response', 'forward', 'redirect', 'weighted_forward']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticloadbalancingv2_actions.AuthenticateCognitoAction'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AuthenticateCognitoActionDefConfig] = pydantic.Field(None)


class AuthenticateCognitoActionDefConfig(pydantic.BaseModel):
    authenticate_oidc: typing.Optional[list[AuthenticateCognitoActionDefAuthenticateOidcParams]] = pydantic.Field(None, description='Authenticate using an identity provider (IdP) that is compliant with OpenID Connect (OIDC).')
    bind: typing.Optional[list[AuthenticateCognitoActionDefBindParams]] = pydantic.Field(None, description='Called when the action is being used in a listener.')
    fixed_response: typing.Optional[list[AuthenticateCognitoActionDefFixedResponseParams]] = pydantic.Field(None, description='Return a fixed response.')
    forward: typing.Optional[list[AuthenticateCognitoActionDefForwardParams]] = pydantic.Field(None, description='Forward to one or more Target Groups.')
    redirect: typing.Optional[list[AuthenticateCognitoActionDefRedirectParams]] = pydantic.Field(None, description='Redirect to a different URI.\nA URI consists of the following components:\nprotocol://hostname:port/path?query. You must modify at least one of the\nfollowing components to avoid a redirect loop: protocol, hostname, port, or\npath. Any components that you do not modify retain their original values.\n\nYou can reuse URI components using the following reserved keywords:\n\n- ``#{protocol}``\n- ``#{host}``\n- ``#{port}``\n- ``#{path}`` (the leading "/" is removed)\n- ``#{query}``\n\nFor example, you can change the path to "/new/#{path}", the hostname to\n"example.#{host}", or the query to "#{query}&value=xyz".')
    render_actions: typing.Optional[bool] = pydantic.Field(None, description='Render the listener default actions in this chain.')
    render_rule_actions: typing.Optional[bool] = pydantic.Field(None, description='Render the listener rule actions in this chain.')
    weighted_forward: typing.Optional[list[AuthenticateCognitoActionDefWeightedForwardParams]] = pydantic.Field(None, description='Forward to one or more Target Groups which are weighted differently.')

class AuthenticateCognitoActionDefAuthenticateOidcParams(pydantic.BaseModel):
    authorization_endpoint: str = pydantic.Field(..., description='The authorization endpoint of the IdP. This must be a full URL, including the HTTPS protocol, the domain, and the path.\n')
    client_id: str = pydantic.Field(..., description='The OAuth 2.0 client identifier.\n')
    client_secret: models.SecretValueDef = pydantic.Field(..., description='The OAuth 2.0 client secret.\n')
    issuer: str = pydantic.Field(..., description='The OIDC issuer identifier of the IdP. This must be a full URL, including the HTTPS protocol, the domain, and the path.\n')
    next: models.aws_elasticloadbalancingv2.ListenerActionDef = pydantic.Field(..., description='What action to execute next.\n')
    token_endpoint: str = pydantic.Field(..., description='The token endpoint of the IdP. This must be a full URL, including the HTTPS protocol, the domain, and the path.\n')
    user_info_endpoint: str = pydantic.Field(..., description='The user info endpoint of the IdP. This must be a full URL, including the HTTPS protocol, the domain, and the path.\n')
    allow_https_outbound: typing.Optional[bool] = pydantic.Field(None, description="Allow HTTPS outbound traffic to communicate with the IdP. Set this property to false if the IP address used for the IdP endpoint is identifiable and you want to control outbound traffic. Then allow HTTPS outbound traffic to the IdP's IP address using the listener's ``connections`` property. Default: true\n")
    authentication_request_extra_params: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The query parameters (up to 10) to include in the redirect request to the authorization endpoint. Default: - No extra parameters\n')
    on_unauthenticated_request: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.UnauthenticatedAction] = pydantic.Field(None, description='The behavior if the user is not authenticated. Default: UnauthenticatedAction.AUTHENTICATE\n')
    scope: typing.Optional[str] = pydantic.Field(None, description='The set of user claims to be requested from the IdP. To verify which scope values your IdP supports and how to separate multiple values, see the documentation for your IdP. Default: "openid"\n')
    session_cookie_name: typing.Optional[str] = pydantic.Field(None, description='The name of the cookie used to maintain session information. Default: "AWSELBAuthSessionCookie"\n')
    session_timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum duration of the authentication session. Default: Duration.days(7)\n\n:see: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/listener-authenticate-users.html#oidc-requirements\n')
    return_config: typing.Optional[list[models.aws_elasticloadbalancingv2.ListenerActionDefConfig]] = pydantic.Field(None)
    ...

class AuthenticateCognitoActionDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    listener: typing.Union[models.aws_elasticloadbalancingv2.ApplicationListenerDef] = pydantic.Field(..., description='-\n')
    associating_construct: typing.Optional[models.AnyResource] = pydantic.Field(None, description='-')
    ...

class AuthenticateCognitoActionDefFixedResponseParams(pydantic.BaseModel):
    status_code: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    content_type: typing.Optional[str] = pydantic.Field(None, description='Content Type of the response. Valid Values: text/plain | text/css | text/html | application/javascript | application/json Default: - Automatically determined\n')
    message_body: typing.Optional[str] = pydantic.Field(None, description='The response body. Default: - No body\n\n:see: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-listeners.html#fixed-response-actions\n')
    return_config: typing.Optional[list[models.aws_elasticloadbalancingv2.ListenerActionDefConfig]] = pydantic.Field(None)
    ...

class AuthenticateCognitoActionDefForwardParams(pydantic.BaseModel):
    target_groups: typing.Sequence[typing.Union[models.aws_elasticloadbalancingv2.ApplicationTargetGroupDef]] = pydantic.Field(..., description='-\n')
    stickiness_duration: typing.Optional[models.DurationDef] = pydantic.Field(None, description='For how long clients should be directed to the same target group. Range between 1 second and 7 days. Default: - No stickiness\n\n:see: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-listeners.html#forward-actions\n')
    return_config: typing.Optional[list[models.aws_elasticloadbalancingv2.ListenerActionDefConfig]] = pydantic.Field(None)
    ...

class AuthenticateCognitoActionDefRedirectParams(pydantic.BaseModel):
    host: typing.Optional[str] = pydantic.Field(None, description='The hostname. This component is not percent-encoded. The hostname can contain #{host}. Default: - No change\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The absolute path, starting with the leading "/". This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}. Default: - No change\n')
    permanent: typing.Optional[bool] = pydantic.Field(None, description='The HTTP redirect code. The redirect is either permanent (HTTP 301) or temporary (HTTP 302). Default: false\n')
    port: typing.Optional[str] = pydantic.Field(None, description='The port. You can specify a value from 1 to 65535 or #{port}. Default: - No change\n')
    protocol: typing.Optional[str] = pydantic.Field(None, description='The protocol. You can specify HTTP, HTTPS, or #{protocol}. You can redirect HTTP to HTTP, HTTP to HTTPS, and HTTPS to HTTPS. You cannot redirect HTTPS to HTTP. Default: - No change\n')
    query: typing.Optional[str] = pydantic.Field(None, description='The query parameters, URL-encoded when necessary, but not percent-encoded. Do not include the leading "?", as it is automatically added. You can specify any of the reserved keywords. Default: - No change\n\n:see: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-listeners.html#redirect-actions\n')
    return_config: typing.Optional[list[models.aws_elasticloadbalancingv2.ListenerActionDefConfig]] = pydantic.Field(None)
    ...

class AuthenticateCognitoActionDefWeightedForwardParams(pydantic.BaseModel):
    target_groups: typing.Sequence[typing.Union[models.aws_elasticloadbalancingv2.WeightedTargetGroupDef, dict[str, typing.Any]]] = pydantic.Field(..., description='-\n')
    stickiness_duration: typing.Optional[models.DurationDef] = pydantic.Field(None, description='For how long clients should be directed to the same target group. Range between 1 second and 7 days. Default: - No stickiness\n\n:see: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-listeners.html#forward-actions\n')
    return_config: typing.Optional[list[models.aws_elasticloadbalancingv2.ListenerActionDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_elasticloadbalancingv2_actions.AuthenticateCognitoActionProps
class AuthenticateCognitoActionPropsDef(BaseStruct):
    next: typing.Union[models.aws_elasticloadbalancingv2.ListenerActionDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='What action to execute next. Multiple actions form a linked chain; the chain must always terminate in a (weighted)forward, fixedResponse or redirect action.\n')
    user_pool: typing.Union[_REQUIRED_INIT_PARAM, models.aws_cognito.UserPoolDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Cognito user pool.\n')
    user_pool_client: typing.Union[_REQUIRED_INIT_PARAM, models.aws_cognito.UserPoolClientDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Cognito user pool client.\n')
    user_pool_domain: typing.Union[_REQUIRED_INIT_PARAM, models.aws_cognito.UserPoolDomainDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The domain prefix or fully-qualified domain name of the Amazon Cognito user pool.\n')
    allow_https_outbound: typing.Optional[bool] = pydantic.Field(None, description="Allow HTTPS outbound traffic to communicate with the IdP. Set this property to false if the IP address used for the IdP endpoint is identifiable and you want to control outbound traffic. Then allow HTTPS outbound traffic to the IdP's IP address using the listener's ``connections`` property. Default: true\n")
    authentication_request_extra_params: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The query parameters (up to 10) to include in the redirect request to the authorization endpoint. Default: - No extra parameters\n')
    on_unauthenticated_request: typing.Optional[aws_cdk.aws_elasticloadbalancingv2.UnauthenticatedAction] = pydantic.Field(None, description='The behavior if the user is not authenticated. Default: UnauthenticatedAction.AUTHENTICATE\n')
    session_cookie_name: typing.Optional[str] = pydantic.Field(None, description='The name of the cookie used to maintain session information. Default: "AWSELBAuthSessionCookie"\n')
    session_timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum duration of the authentication session. Default: Duration.days(7)\n\n:exampleMetadata: infused\n\nExample::\n\n    from aws_cdk import aws_certificatemanager as acm\n\n    # vpc: ec2.Vpc\n    # certificate: acm.Certificate\n\n\n    lb = elbv2.ApplicationLoadBalancer(self, "LB",\n        vpc=vpc,\n        internet_facing=True\n    )\n\n    user_pool = cognito.UserPool(self, "UserPool")\n    user_pool_client = cognito.UserPoolClient(self, "Client",\n        user_pool=user_pool,\n\n        # Required minimal configuration for use with an ELB\n        generate_secret=True,\n        auth_flows=cognito.AuthFlow(\n            user_password=True\n        ),\n        o_auth=cognito.OAuthSettings(\n            flows=cognito.OAuthFlows(\n                authorization_code_grant=True\n            ),\n            scopes=[cognito.OAuthScope.EMAIL],\n            callback_urls=[f"https://{lb.loadBalancerDnsName}/oauth2/idpresponse"\n            ]\n        )\n    )\n    cfn_client = user_pool_client.node.default_child\n    cfn_client.add_property_override("RefreshTokenValidity", 1)\n    cfn_client.add_property_override("SupportedIdentityProviders", ["COGNITO"])\n\n    user_pool_domain = cognito.UserPoolDomain(self, "Domain",\n        user_pool=user_pool,\n        cognito_domain=cognito.CognitoDomainOptions(\n            domain_prefix="test-cdk-prefix"\n        )\n    )\n\n    lb.add_listener("Listener",\n        port=443,\n        certificates=[certificate],\n        default_action=actions.AuthenticateCognitoAction(\n            user_pool=user_pool,\n            user_pool_client=user_pool_client,\n            user_pool_domain=user_pool_domain,\n            next=elbv2.ListenerAction.fixed_response(200,\n                content_type="text/plain",\n                message_body="Authenticated"\n            )\n        )\n    )\n\n    CfnOutput(self, "DNS",\n        value=lb.load_balancer_dns_name\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['next', 'user_pool', 'user_pool_client', 'user_pool_domain', 'allow_https_outbound', 'authentication_request_extra_params', 'on_unauthenticated_request', 'session_cookie_name', 'session_timeout']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_elasticloadbalancingv2_actions.AuthenticateCognitoActionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AuthenticateCognitoActionPropsDefConfig] = pydantic.Field(None)


class AuthenticateCognitoActionPropsDefConfig(pydantic.BaseModel):
    next_config: typing.Optional[models.aws_elasticloadbalancingv2.ListenerActionDefConfig] = pydantic.Field(None)
    user_pool_config: typing.Optional[models._interface_methods.AwsCognitoIUserPoolDefConfig] = pydantic.Field(None)
    user_pool_client_config: typing.Optional[models._interface_methods.AwsCognitoIUserPoolClientDefConfig] = pydantic.Field(None)
    user_pool_domain_config: typing.Optional[models._interface_methods.AwsCognitoIUserPoolDomainDefConfig] = pydantic.Field(None)


import models

class ModuleModel(pydantic.BaseModel):
    AuthenticateCognitoAction: typing.Optional[dict[str, AuthenticateCognitoActionDef]] = pydantic.Field(None)
    AuthenticateCognitoActionProps: typing.Optional[dict[str, AuthenticateCognitoActionPropsDef]] = pydantic.Field(None)
    ...
