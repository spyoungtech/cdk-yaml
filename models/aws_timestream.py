from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams

#  autogenerated from aws_cdk.aws_timestream.CfnScheduledQuery.DimensionMappingProperty
class CfnScheduledQuery_DimensionMappingPropertyDef(BaseStruct):
    dimension_value_type: str = pydantic.Field(..., description='Type for the dimension: VARCHAR.\n')
    name: str = pydantic.Field(..., description='Column name from query result.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-timestream-scheduledquery-dimensionmapping.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_timestream as timestream\n\n    dimension_mapping_property = timestream.CfnScheduledQuery.DimensionMappingProperty(\n        dimension_value_type="dimensionValueType",\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['dimension_value_type', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_timestream.CfnScheduledQuery.DimensionMappingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_timestream.CfnScheduledQuery.ErrorReportConfigurationProperty
class CfnScheduledQuery_ErrorReportConfigurationPropertyDef(BaseStruct):
    s3_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_S3ConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The S3 configuration for the error reports.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-timestream-scheduledquery-errorreportconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_timestream as timestream\n\n    error_report_configuration_property = timestream.CfnScheduledQuery.ErrorReportConfigurationProperty(\n        s3_configuration=timestream.CfnScheduledQuery.S3ConfigurationProperty(\n            bucket_name="bucketName",\n\n            # the properties below are optional\n            encryption_option="encryptionOption",\n            object_key_prefix="objectKeyPrefix"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['s3_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_timestream.CfnScheduledQuery.ErrorReportConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_timestream.CfnScheduledQuery.MixedMeasureMappingProperty
class CfnScheduledQuery_MixedMeasureMappingPropertyDef(BaseStruct):
    measure_value_type: str = pydantic.Field(..., description='Type of the value that is to be read from sourceColumn. If the mapping is for MULTI, use MeasureValueType.MULTI.\n')
    measure_name: typing.Optional[str] = pydantic.Field(None, description='Refers to the value of measure_name in a result row. This field is required if MeasureNameColumn is provided.\n')
    multi_measure_attribute_mappings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_MultiMeasureAttributeMappingPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Required when measureValueType is MULTI. Attribute mappings for MULTI value measures.\n')
    source_column: typing.Optional[str] = pydantic.Field(None, description='This field refers to the source column from which measure-value is to be read for result materialization.\n')
    target_measure_name: typing.Optional[str] = pydantic.Field(None, description='Target measure name to be used. If not provided, the target measure name by default would be measure-name if provided, or sourceColumn otherwise.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-timestream-scheduledquery-mixedmeasuremapping.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_timestream as timestream\n\n    mixed_measure_mapping_property = timestream.CfnScheduledQuery.MixedMeasureMappingProperty(\n        measure_value_type="measureValueType",\n\n        # the properties below are optional\n        measure_name="measureName",\n        multi_measure_attribute_mappings=[timestream.CfnScheduledQuery.MultiMeasureAttributeMappingProperty(\n            measure_value_type="measureValueType",\n            source_column="sourceColumn",\n\n            # the properties below are optional\n            target_multi_measure_attribute_name="targetMultiMeasureAttributeName"\n        )],\n        source_column="sourceColumn",\n        target_measure_name="targetMeasureName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['measure_value_type', 'measure_name', 'multi_measure_attribute_mappings', 'source_column', 'target_measure_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_timestream.CfnScheduledQuery.MixedMeasureMappingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_timestream.CfnScheduledQuery.MultiMeasureAttributeMappingProperty
class CfnScheduledQuery_MultiMeasureAttributeMappingPropertyDef(BaseStruct):
    measure_value_type: str = pydantic.Field(..., description='Type of the attribute to be read from the source column.\n')
    source_column: str = pydantic.Field(..., description='Source column from where the attribute value is to be read.\n')
    target_multi_measure_attribute_name: typing.Optional[str] = pydantic.Field(None, description='Custom name to be used for attribute name in derived table. If not provided, source column name would be used.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-timestream-scheduledquery-multimeasureattributemapping.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_timestream as timestream\n\n    multi_measure_attribute_mapping_property = timestream.CfnScheduledQuery.MultiMeasureAttributeMappingProperty(\n        measure_value_type="measureValueType",\n        source_column="sourceColumn",\n\n        # the properties below are optional\n        target_multi_measure_attribute_name="targetMultiMeasureAttributeName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['measure_value_type', 'source_column', 'target_multi_measure_attribute_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_timestream.CfnScheduledQuery.MultiMeasureAttributeMappingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_timestream.CfnScheduledQuery.MultiMeasureMappingsProperty
class CfnScheduledQuery_MultiMeasureMappingsPropertyDef(BaseStruct):
    multi_measure_attribute_mappings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_MultiMeasureAttributeMappingPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='Required. Attribute mappings to be used for mapping query results to ingest data for multi-measure attributes.\n')
    target_multi_measure_name: typing.Optional[str] = pydantic.Field(None, description='The name of the target multi-measure name in the derived table. This input is required when measureNameColumn is not provided. If MeasureNameColumn is provided, then value from that column will be used as multi-measure name.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-timestream-scheduledquery-multimeasuremappings.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_timestream as timestream\n\n    multi_measure_mappings_property = timestream.CfnScheduledQuery.MultiMeasureMappingsProperty(\n        multi_measure_attribute_mappings=[timestream.CfnScheduledQuery.MultiMeasureAttributeMappingProperty(\n            measure_value_type="measureValueType",\n            source_column="sourceColumn",\n\n            # the properties below are optional\n            target_multi_measure_attribute_name="targetMultiMeasureAttributeName"\n        )],\n\n        # the properties below are optional\n        target_multi_measure_name="targetMultiMeasureName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['multi_measure_attribute_mappings', 'target_multi_measure_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_timestream.CfnScheduledQuery.MultiMeasureMappingsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_timestream.CfnScheduledQuery.NotificationConfigurationProperty
class CfnScheduledQuery_NotificationConfigurationPropertyDef(BaseStruct):
    sns_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_SnsConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Details on SNS configuration.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-timestream-scheduledquery-notificationconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_timestream as timestream\n\n    notification_configuration_property = timestream.CfnScheduledQuery.NotificationConfigurationProperty(\n        sns_configuration=timestream.CfnScheduledQuery.SnsConfigurationProperty(\n            topic_arn="topicArn"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['sns_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_timestream.CfnScheduledQuery.NotificationConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_timestream.CfnScheduledQuery.S3ConfigurationProperty
class CfnScheduledQuery_S3ConfigurationPropertyDef(BaseStruct):
    bucket_name: str = pydantic.Field(..., description='Name of the S3 bucket under which error reports will be created.\n')
    encryption_option: typing.Optional[str] = pydantic.Field(None, description='Encryption at rest options for the error reports. If no encryption option is specified, Timestream will choose SSE_S3 as default.\n')
    object_key_prefix: typing.Optional[str] = pydantic.Field(None, description='Prefix for the error report key. Timestream by default adds the following prefix to the error report path.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-timestream-scheduledquery-s3configuration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_timestream as timestream\n\n    s3_configuration_property = timestream.CfnScheduledQuery.S3ConfigurationProperty(\n        bucket_name="bucketName",\n\n        # the properties below are optional\n        encryption_option="encryptionOption",\n        object_key_prefix="objectKeyPrefix"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket_name', 'encryption_option', 'object_key_prefix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_timestream.CfnScheduledQuery.S3ConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_timestream.CfnScheduledQuery.ScheduleConfigurationProperty
class CfnScheduledQuery_ScheduleConfigurationPropertyDef(BaseStruct):
    schedule_expression: str = pydantic.Field(..., description='An expression that denotes when to trigger the scheduled query run. This can be a cron expression or a rate expression.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-timestream-scheduledquery-scheduleconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_timestream as timestream\n\n    schedule_configuration_property = timestream.CfnScheduledQuery.ScheduleConfigurationProperty(\n        schedule_expression="scheduleExpression"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['schedule_expression']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_timestream.CfnScheduledQuery.ScheduleConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_timestream.CfnScheduledQuery.SnsConfigurationProperty
class CfnScheduledQuery_SnsConfigurationPropertyDef(BaseStruct):
    topic_arn: str = pydantic.Field(..., description='SNS topic ARN that the scheduled query status notifications will be sent to.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-timestream-scheduledquery-snsconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_timestream as timestream\n\n    sns_configuration_property = timestream.CfnScheduledQuery.SnsConfigurationProperty(\n        topic_arn="topicArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['topic_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_timestream.CfnScheduledQuery.SnsConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_timestream.CfnScheduledQuery.TargetConfigurationProperty
class CfnScheduledQuery_TargetConfigurationPropertyDef(BaseStruct):
    timestream_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_TimestreamConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Configuration needed to write data into the Timestream database and table.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-timestream-scheduledquery-targetconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_timestream as timestream\n\n    target_configuration_property = timestream.CfnScheduledQuery.TargetConfigurationProperty(\n        timestream_configuration=timestream.CfnScheduledQuery.TimestreamConfigurationProperty(\n            database_name="databaseName",\n            dimension_mappings=[timestream.CfnScheduledQuery.DimensionMappingProperty(\n                dimension_value_type="dimensionValueType",\n                name="name"\n            )],\n            table_name="tableName",\n            time_column="timeColumn",\n\n            # the properties below are optional\n            measure_name_column="measureNameColumn",\n            mixed_measure_mappings=[timestream.CfnScheduledQuery.MixedMeasureMappingProperty(\n                measure_value_type="measureValueType",\n\n                # the properties below are optional\n                measure_name="measureName",\n                multi_measure_attribute_mappings=[timestream.CfnScheduledQuery.MultiMeasureAttributeMappingProperty(\n                    measure_value_type="measureValueType",\n                    source_column="sourceColumn",\n\n                    # the properties below are optional\n                    target_multi_measure_attribute_name="targetMultiMeasureAttributeName"\n                )],\n                source_column="sourceColumn",\n                target_measure_name="targetMeasureName"\n            )],\n            multi_measure_mappings=timestream.CfnScheduledQuery.MultiMeasureMappingsProperty(\n                multi_measure_attribute_mappings=[timestream.CfnScheduledQuery.MultiMeasureAttributeMappingProperty(\n                    measure_value_type="measureValueType",\n                    source_column="sourceColumn",\n\n                    # the properties below are optional\n                    target_multi_measure_attribute_name="targetMultiMeasureAttributeName"\n                )],\n\n                # the properties below are optional\n                target_multi_measure_name="targetMultiMeasureName"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['timestream_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_timestream.CfnScheduledQuery.TargetConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_timestream.CfnScheduledQuery.TimestreamConfigurationProperty
class CfnScheduledQuery_TimestreamConfigurationPropertyDef(BaseStruct):
    database_name: str = pydantic.Field(..., description='Name of Timestream database to which the query result will be written.\n')
    dimension_mappings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_DimensionMappingPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='This is to allow mapping column(s) from the query result to the dimension in the destination table.\n')
    table_name: str = pydantic.Field(..., description='Name of Timestream table that the query result will be written to. The table should be within the same database that is provided in Timestream configuration.\n')
    time_column: str = pydantic.Field(..., description='Column from query result that should be used as the time column in destination table. Column type for this should be TIMESTAMP.\n')
    measure_name_column: typing.Optional[str] = pydantic.Field(None, description='Name of the measure column. Also see ``MultiMeasureMappings`` and ``MixedMeasureMappings`` for how measure name properties on those relate to ``MeasureNameColumn`` .\n')
    mixed_measure_mappings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_MixedMeasureMappingPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Specifies how to map measures to multi-measure records.\n')
    multi_measure_mappings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_MultiMeasureMappingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Multi-measure mappings.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-timestream-scheduledquery-timestreamconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_timestream as timestream\n\n    timestream_configuration_property = timestream.CfnScheduledQuery.TimestreamConfigurationProperty(\n        database_name="databaseName",\n        dimension_mappings=[timestream.CfnScheduledQuery.DimensionMappingProperty(\n            dimension_value_type="dimensionValueType",\n            name="name"\n        )],\n        table_name="tableName",\n        time_column="timeColumn",\n\n        # the properties below are optional\n        measure_name_column="measureNameColumn",\n        mixed_measure_mappings=[timestream.CfnScheduledQuery.MixedMeasureMappingProperty(\n            measure_value_type="measureValueType",\n\n            # the properties below are optional\n            measure_name="measureName",\n            multi_measure_attribute_mappings=[timestream.CfnScheduledQuery.MultiMeasureAttributeMappingProperty(\n                measure_value_type="measureValueType",\n                source_column="sourceColumn",\n\n                # the properties below are optional\n                target_multi_measure_attribute_name="targetMultiMeasureAttributeName"\n            )],\n            source_column="sourceColumn",\n            target_measure_name="targetMeasureName"\n        )],\n        multi_measure_mappings=timestream.CfnScheduledQuery.MultiMeasureMappingsProperty(\n            multi_measure_attribute_mappings=[timestream.CfnScheduledQuery.MultiMeasureAttributeMappingProperty(\n                measure_value_type="measureValueType",\n                source_column="sourceColumn",\n\n                # the properties below are optional\n                target_multi_measure_attribute_name="targetMultiMeasureAttributeName"\n            )],\n\n            # the properties below are optional\n            target_multi_measure_name="targetMultiMeasureName"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['database_name', 'dimension_mappings', 'table_name', 'time_column', 'measure_name_column', 'mixed_measure_mappings', 'multi_measure_mappings']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_timestream.CfnScheduledQuery.TimestreamConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_timestream.CfnTable.MagneticStoreRejectedDataLocationProperty
class CfnTable_MagneticStoreRejectedDataLocationPropertyDef(BaseStruct):
    s3_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnTable_S3ConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configuration of an S3 location to write error reports for records rejected, asynchronously, during magnetic store writes.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-timestream-table-magneticstorerejecteddatalocation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_timestream as timestream\n\n    magnetic_store_rejected_data_location_property = timestream.CfnTable.MagneticStoreRejectedDataLocationProperty(\n        s3_configuration=timestream.CfnTable.S3ConfigurationProperty(\n            bucket_name="bucketName",\n            encryption_option="encryptionOption",\n\n            # the properties below are optional\n            kms_key_id="kmsKeyId",\n            object_key_prefix="objectKeyPrefix"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['s3_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_timestream.CfnTable.MagneticStoreRejectedDataLocationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_timestream.CfnTable.MagneticStoreWritePropertiesProperty
class CfnTable_MagneticStoreWritePropertiesPropertyDef(BaseStruct):
    enable_magnetic_store_writes: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='A flag to enable magnetic store writes.\n')
    magnetic_store_rejected_data_location: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnTable_MagneticStoreRejectedDataLocationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The location to write error reports for records rejected asynchronously during magnetic store writes.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-timestream-table-magneticstorewriteproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_timestream as timestream\n\n    magnetic_store_write_properties_property = timestream.CfnTable.MagneticStoreWritePropertiesProperty(\n        enable_magnetic_store_writes=False,\n\n        # the properties below are optional\n        magnetic_store_rejected_data_location=timestream.CfnTable.MagneticStoreRejectedDataLocationProperty(\n            s3_configuration=timestream.CfnTable.S3ConfigurationProperty(\n                bucket_name="bucketName",\n                encryption_option="encryptionOption",\n\n                # the properties below are optional\n                kms_key_id="kmsKeyId",\n                object_key_prefix="objectKeyPrefix"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enable_magnetic_store_writes', 'magnetic_store_rejected_data_location']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_timestream.CfnTable.MagneticStoreWritePropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_timestream.CfnTable.RetentionPropertiesProperty
class CfnTable_RetentionPropertiesPropertyDef(BaseStruct):
    magnetic_store_retention_period_in_days: typing.Optional[str] = pydantic.Field(None, description='The duration for which data must be stored in the magnetic store.\n')
    memory_store_retention_period_in_hours: typing.Optional[str] = pydantic.Field(None, description='The duration for which data must be stored in the memory store.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-timestream-table-retentionproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_timestream as timestream\n\n    retention_properties_property = timestream.CfnTable.RetentionPropertiesProperty(\n        magnetic_store_retention_period_in_days="magneticStoreRetentionPeriodInDays",\n        memory_store_retention_period_in_hours="memoryStoreRetentionPeriodInHours"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['magnetic_store_retention_period_in_days', 'memory_store_retention_period_in_hours']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_timestream.CfnTable.RetentionPropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_timestream.CfnTable.S3ConfigurationProperty
class CfnTable_S3ConfigurationPropertyDef(BaseStruct):
    bucket_name: str = pydantic.Field(..., description='The bucket name of the customer S3 bucket.\n')
    encryption_option: str = pydantic.Field(..., description='The encryption option for the customer S3 location. Options are S3 server-side encryption with an S3 managed key or AWS managed key.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The AWS KMS key ID for the customer S3 location when encrypting with an AWS managed key.\n')
    object_key_prefix: typing.Optional[str] = pydantic.Field(None, description='The object key preview for the customer S3 location.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-timestream-table-s3configuration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_timestream as timestream\n\n    s3_configuration_property = timestream.CfnTable.S3ConfigurationProperty(\n        bucket_name="bucketName",\n        encryption_option="encryptionOption",\n\n        # the properties below are optional\n        kms_key_id="kmsKeyId",\n        object_key_prefix="objectKeyPrefix"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket_name', 'encryption_option', 'kms_key_id', 'object_key_prefix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_timestream.CfnTable.S3ConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_timestream.CfnDatabase
class CfnDatabaseDef(BaseCfnResource):
    database_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Timestream database. *Length Constraints* : Minimum length of 3 bytes. Maximum length of 256 bytes.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the AWS KMS key used to encrypt the data stored in the database.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to add to the database.')
    _init_params: typing.ClassVar[list[str]] = ['database_name', 'kms_key_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_timestream.CfnDatabase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnDatabaseDefConfig] = pydantic.Field(None)


class CfnDatabaseDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnDatabaseDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnDatabaseDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnDatabaseDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnDatabaseDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnDatabaseDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnDatabaseDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnDatabaseDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnDatabaseDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnDatabaseDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnDatabaseDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnDatabaseDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnDatabaseDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnDatabaseDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDatabaseDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDatabaseDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDatabaseDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDatabaseDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDatabaseDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDatabaseDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDatabaseDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDatabaseDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDatabaseDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDatabaseDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDatabaseDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnDatabaseDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDatabaseDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDatabaseDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_timestream.CfnScheduledQuery
class CfnScheduledQueryDef(BaseCfnResource):
    error_report_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_ErrorReportConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Configuration for error reporting. Error reports will be generated when a problem is encountered when writing the query results.\n')
    notification_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_NotificationConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Notification configuration for the scheduled query. A notification is sent by Timestream when a query run finishes, when the state is updated or when you delete it.\n')
    query_string: str = pydantic.Field(..., description='The query string to run. Parameter names can be specified in the query string ``@`` character followed by an identifier. The named Parameter ``@scheduled_runtime`` is reserved and can be used in the query to get the time at which the query is scheduled to run. The timestamp calculated according to the ScheduleConfiguration parameter, will be the value of ``@scheduled_runtime`` paramater for each query run. For example, consider an instance of a scheduled query executing on 2021-12-01 00:00:00. For this instance, the ``@scheduled_runtime`` parameter is initialized to the timestamp 2021-12-01 00:00:00 when invoking the query.\n')
    schedule_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_ScheduleConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Schedule configuration.\n')
    scheduled_query_execution_role_arn: str = pydantic.Field(..., description='The ARN for the IAM role that Timestream will assume when running the scheduled query.\n')
    client_token: typing.Optional[str] = pydantic.Field(None, description='Using a ClientToken makes the call to CreateScheduledQuery idempotent, in other words, making the same request repeatedly will produce the same result. Making multiple identical CreateScheduledQuery requests has the same effect as making a single request. - If CreateScheduledQuery is called without a ``ClientToken`` , the Query SDK generates a ``ClientToken`` on your behalf. - After 8 hours, any request with the same ``ClientToken`` is treated as a new request.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The Amazon KMS key used to encrypt the scheduled query resource, at-rest. If the Amazon KMS key is not specified, the scheduled query resource will be encrypted with a Timestream owned Amazon KMS key. To specify a KMS key, use the key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix the name with *alias/* If ErrorReportConfiguration uses ``SSE_KMS`` as encryption type, the same KmsKeyId is used to encrypt the error report at rest.\n')
    scheduled_query_name: typing.Optional[str] = pydantic.Field(None, description='A name for the query. Scheduled query names must be unique within each Region.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of key-value pairs to label the scheduled query.\n')
    target_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_TargetConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Scheduled query target store configuration.')
    _init_params: typing.ClassVar[list[str]] = ['error_report_configuration', 'notification_configuration', 'query_string', 'schedule_configuration', 'scheduled_query_execution_role_arn', 'client_token', 'kms_key_id', 'scheduled_query_name', 'tags', 'target_configuration']
    _method_names: typing.ClassVar[list[str]] = ['DimensionMappingProperty', 'ErrorReportConfigurationProperty', 'MixedMeasureMappingProperty', 'MultiMeasureAttributeMappingProperty', 'MultiMeasureMappingsProperty', 'NotificationConfigurationProperty', 'S3ConfigurationProperty', 'ScheduleConfigurationProperty', 'SnsConfigurationProperty', 'TargetConfigurationProperty', 'TimestreamConfigurationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_timestream.CfnScheduledQuery'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnScheduledQueryDefConfig] = pydantic.Field(None)


class CfnScheduledQueryDefConfig(pydantic.BaseModel):
    DimensionMappingProperty: typing.Optional[list[CfnScheduledQueryDefDimensionmappingpropertyParams]] = pydantic.Field(None, description='')
    ErrorReportConfigurationProperty: typing.Optional[list[CfnScheduledQueryDefErrorreportconfigurationpropertyParams]] = pydantic.Field(None, description='')
    MixedMeasureMappingProperty: typing.Optional[list[CfnScheduledQueryDefMixedmeasuremappingpropertyParams]] = pydantic.Field(None, description='')
    MultiMeasureAttributeMappingProperty: typing.Optional[list[CfnScheduledQueryDefMultimeasureattributemappingpropertyParams]] = pydantic.Field(None, description='')
    MultiMeasureMappingsProperty: typing.Optional[list[CfnScheduledQueryDefMultimeasuremappingspropertyParams]] = pydantic.Field(None, description='')
    NotificationConfigurationProperty: typing.Optional[list[CfnScheduledQueryDefNotificationconfigurationpropertyParams]] = pydantic.Field(None, description='')
    S3ConfigurationProperty: typing.Optional[list[CfnScheduledQueryDefS3ConfigurationpropertyParams]] = pydantic.Field(None, description='')
    ScheduleConfigurationProperty: typing.Optional[list[CfnScheduledQueryDefScheduleconfigurationpropertyParams]] = pydantic.Field(None, description='')
    SnsConfigurationProperty: typing.Optional[list[CfnScheduledQueryDefSnsconfigurationpropertyParams]] = pydantic.Field(None, description='')
    TargetConfigurationProperty: typing.Optional[list[CfnScheduledQueryDefTargetconfigurationpropertyParams]] = pydantic.Field(None, description='')
    TimestreamConfigurationProperty: typing.Optional[list[CfnScheduledQueryDefTimestreamconfigurationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnScheduledQueryDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnScheduledQueryDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnScheduledQueryDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnScheduledQueryDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnScheduledQueryDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnScheduledQueryDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnScheduledQueryDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnScheduledQueryDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnScheduledQueryDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnScheduledQueryDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnScheduledQueryDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnScheduledQueryDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnScheduledQueryDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnScheduledQueryDefDimensionmappingpropertyParams(pydantic.BaseModel):
    dimension_value_type: str = pydantic.Field(..., description='')
    name: str = pydantic.Field(..., description='')
    ...

class CfnScheduledQueryDefErrorreportconfigurationpropertyParams(pydantic.BaseModel):
    s3_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_S3ConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnScheduledQueryDefMixedmeasuremappingpropertyParams(pydantic.BaseModel):
    measure_value_type: str = pydantic.Field(..., description='')
    measure_name: typing.Optional[str] = pydantic.Field(None, description='')
    multi_measure_attribute_mappings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_MultiMeasureAttributeMappingPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    source_column: typing.Optional[str] = pydantic.Field(None, description='')
    target_measure_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnScheduledQueryDefMultimeasureattributemappingpropertyParams(pydantic.BaseModel):
    measure_value_type: str = pydantic.Field(..., description='')
    source_column: str = pydantic.Field(..., description='')
    target_multi_measure_attribute_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnScheduledQueryDefMultimeasuremappingspropertyParams(pydantic.BaseModel):
    multi_measure_attribute_mappings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_MultiMeasureAttributeMappingPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    target_multi_measure_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnScheduledQueryDefNotificationconfigurationpropertyParams(pydantic.BaseModel):
    sns_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_SnsConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnScheduledQueryDefS3ConfigurationpropertyParams(pydantic.BaseModel):
    bucket_name: str = pydantic.Field(..., description='')
    encryption_option: typing.Optional[str] = pydantic.Field(None, description='')
    object_key_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnScheduledQueryDefScheduleconfigurationpropertyParams(pydantic.BaseModel):
    schedule_expression: str = pydantic.Field(..., description='')
    ...

class CfnScheduledQueryDefSnsconfigurationpropertyParams(pydantic.BaseModel):
    topic_arn: str = pydantic.Field(..., description='')
    ...

class CfnScheduledQueryDefTargetconfigurationpropertyParams(pydantic.BaseModel):
    timestream_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_TimestreamConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnScheduledQueryDefTimestreamconfigurationpropertyParams(pydantic.BaseModel):
    database_name: str = pydantic.Field(..., description='')
    dimension_mappings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_DimensionMappingPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    table_name: str = pydantic.Field(..., description='')
    time_column: str = pydantic.Field(..., description='')
    measure_name_column: typing.Optional[str] = pydantic.Field(None, description='')
    mixed_measure_mappings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_MixedMeasureMappingPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    multi_measure_mappings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_MultiMeasureMappingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnScheduledQueryDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnScheduledQueryDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnScheduledQueryDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnScheduledQueryDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnScheduledQueryDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnScheduledQueryDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnScheduledQueryDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnScheduledQueryDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnScheduledQueryDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnScheduledQueryDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnScheduledQueryDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnScheduledQueryDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnScheduledQueryDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnScheduledQueryDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_timestream.CfnTable
class CfnTableDef(BaseCfnResource):
    database_name: str = pydantic.Field(..., description='The name of the Timestream database that contains this table. *Length Constraints* : Minimum length of 3 bytes. Maximum length of 256 bytes.\n')
    magnetic_store_write_properties: typing.Any = pydantic.Field(None, description='Contains properties to set on the table when enabling magnetic store writes. This object has the following attributes: - *EnableMagneticStoreWrites* : A ``boolean`` flag to enable magnetic store writes. - *MagneticStoreRejectedDataLocation* : The location to write error reports for records rejected, asynchronously, during magnetic store writes. Only ``S3Configuration`` objects are allowed. The ``S3Configuration`` object has the following attributes: - *BucketName* : The name of the S3 bucket. - *EncryptionOption* : The encryption option for the S3 location. Valid values are S3 server-side encryption with an S3 managed key ( ``SSE_S3`` ) or AWS managed key ( ``SSE_KMS`` ). - *KmsKeyId* : The AWS KMS key ID to use when encrypting with an AWS managed key. - *ObjectKeyPrefix* : The prefix to use option for the objects stored in S3. Both ``BucketName`` and ``EncryptionOption`` are *required* when ``S3Configuration`` is specified. If you specify ``SSE_KMS`` as your ``EncryptionOption`` then ``KmsKeyId`` is *required* . ``EnableMagneticStoreWrites`` attribute is *required* when ``MagneticStoreWriteProperties`` is specified. ``MagneticStoreRejectedDataLocation`` attribute is *required* when ``EnableMagneticStoreWrites`` is set to ``true`` . See the following examples: *JSON:: { "Type" : AWS::Timestream::Table", "Properties":{ "DatabaseName":"TestDatabase", "TableName":"TestTable", "MagneticStoreWriteProperties":{ "EnableMagneticStoreWrites":true, "MagneticStoreRejectedDataLocation":{ "S3Configuration":{ "BucketName":"testbucket", "EncryptionOption":"SSE_KMS", "KmsKeyId":"1234abcd-12ab-34cd-56ef-1234567890ab", "ObjectKeyPrefix":"prefix" } } } } } *YAML:: Type: AWS::Timestream::Table DependsOn: TestDatabase Properties: TableName: "TestTable" DatabaseName: "TestDatabase" MagneticStoreWriteProperties: EnableMagneticStoreWrites: true MagneticStoreRejectedDataLocation: S3Configuration: BucketName: "testbucket" EncryptionOption: "SSE_KMS" KmsKeyId: "1234abcd-12ab-34cd-56ef-1234567890ab" ObjectKeyPrefix: "prefix"\n')
    retention_properties: typing.Any = pydantic.Field(None, description='The retention duration for the memory store and magnetic store. This object has the following attributes:. - *MemoryStoreRetentionPeriodInHours* : Retention duration for memory store, in hours. - *MagneticStoreRetentionPeriodInDays* : Retention duration for magnetic store, in days. Both attributes are of type ``string`` . Both attributes are *required* when ``RetentionProperties`` is specified. See the following examples: *JSON* ``{ "Type" : AWS::Timestream::Table", "Properties" : { "DatabaseName" : "TestDatabase", "TableName" : "TestTable", "RetentionProperties" : { "MemoryStoreRetentionPeriodInHours": "24", "MagneticStoreRetentionPeriodInDays": "7" } } }`` *YAML:: Type: AWS::Timestream::Table DependsOn: TestDatabase Properties: TableName: "TestTable" DatabaseName: "TestDatabase" RetentionProperties: MemoryStoreRetentionPeriodInHours: "24" MagneticStoreRetentionPeriodInDays: "7"\n')
    table_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Timestream table. *Length Constraints* : Minimum length of 3 bytes. Maximum length of 256 bytes.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to add to the table.')
    _init_params: typing.ClassVar[list[str]] = ['database_name', 'magnetic_store_write_properties', 'retention_properties', 'table_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['MagneticStoreRejectedDataLocationProperty', 'MagneticStoreWritePropertiesProperty', 'RetentionPropertiesProperty', 'S3ConfigurationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_timestream.CfnTable'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTableDefConfig] = pydantic.Field(None)


class CfnTableDefConfig(pydantic.BaseModel):
    MagneticStoreRejectedDataLocationProperty: typing.Optional[list[CfnTableDefMagneticstorerejecteddatalocationpropertyParams]] = pydantic.Field(None, description='')
    MagneticStoreWritePropertiesProperty: typing.Optional[list[CfnTableDefMagneticstorewritepropertiespropertyParams]] = pydantic.Field(None, description='')
    RetentionPropertiesProperty: typing.Optional[list[CfnTableDefRetentionpropertiespropertyParams]] = pydantic.Field(None, description='')
    S3ConfigurationProperty: typing.Optional[list[CfnTableDefS3ConfigurationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnTableDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTableDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTableDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTableDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTableDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTableDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTableDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTableDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTableDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTableDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTableDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTableDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTableDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnTableDefMagneticstorerejecteddatalocationpropertyParams(pydantic.BaseModel):
    s3_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnTable_S3ConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnTableDefMagneticstorewritepropertiespropertyParams(pydantic.BaseModel):
    enable_magnetic_store_writes: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='')
    magnetic_store_rejected_data_location: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnTable_MagneticStoreRejectedDataLocationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnTableDefRetentionpropertiespropertyParams(pydantic.BaseModel):
    magnetic_store_retention_period_in_days: typing.Optional[str] = pydantic.Field(None, description='')
    memory_store_retention_period_in_hours: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTableDefS3ConfigurationpropertyParams(pydantic.BaseModel):
    bucket_name: str = pydantic.Field(..., description='')
    encryption_option: str = pydantic.Field(..., description='')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='')
    object_key_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTableDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTableDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTableDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTableDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTableDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTableDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTableDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTableDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTableDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTableDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTableDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnTableDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTableDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTableDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_timestream.CfnDatabaseProps
class CfnDatabasePropsDef(BaseCfnProperty):
    database_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Timestream database. *Length Constraints* : Minimum length of 3 bytes. Maximum length of 256 bytes.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the AWS KMS key used to encrypt the data stored in the database.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to add to the database.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-timestream-database.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_timestream as timestream\n\n    cfn_database_props = timestream.CfnDatabaseProps(\n        database_name="databaseName",\n        kms_key_id="kmsKeyId",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['database_name', 'kms_key_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_timestream.CfnDatabaseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_timestream.CfnScheduledQueryProps
class CfnScheduledQueryPropsDef(BaseCfnProperty):
    error_report_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_ErrorReportConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Configuration for error reporting. Error reports will be generated when a problem is encountered when writing the query results.\n')
    notification_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_NotificationConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Notification configuration for the scheduled query. A notification is sent by Timestream when a query run finishes, when the state is updated or when you delete it.\n')
    query_string: str = pydantic.Field(..., description='The query string to run. Parameter names can be specified in the query string ``@`` character followed by an identifier. The named Parameter ``@scheduled_runtime`` is reserved and can be used in the query to get the time at which the query is scheduled to run. The timestamp calculated according to the ScheduleConfiguration parameter, will be the value of ``@scheduled_runtime`` paramater for each query run. For example, consider an instance of a scheduled query executing on 2021-12-01 00:00:00. For this instance, the ``@scheduled_runtime`` parameter is initialized to the timestamp 2021-12-01 00:00:00 when invoking the query.\n')
    schedule_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_ScheduleConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Schedule configuration.\n')
    scheduled_query_execution_role_arn: str = pydantic.Field(..., description='The ARN for the IAM role that Timestream will assume when running the scheduled query.\n')
    client_token: typing.Optional[str] = pydantic.Field(None, description='Using a ClientToken makes the call to CreateScheduledQuery idempotent, in other words, making the same request repeatedly will produce the same result. Making multiple identical CreateScheduledQuery requests has the same effect as making a single request. - If CreateScheduledQuery is called without a ``ClientToken`` , the Query SDK generates a ``ClientToken`` on your behalf. - After 8 hours, any request with the same ``ClientToken`` is treated as a new request.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The Amazon KMS key used to encrypt the scheduled query resource, at-rest. If the Amazon KMS key is not specified, the scheduled query resource will be encrypted with a Timestream owned Amazon KMS key. To specify a KMS key, use the key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix the name with *alias/* If ErrorReportConfiguration uses ``SSE_KMS`` as encryption type, the same KmsKeyId is used to encrypt the error report at rest.\n')
    scheduled_query_name: typing.Optional[str] = pydantic.Field(None, description='A name for the query. Scheduled query names must be unique within each Region.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of key-value pairs to label the scheduled query.\n')
    target_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_timestream.CfnScheduledQuery_TargetConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Scheduled query target store configuration.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-timestream-scheduledquery.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_timestream as timestream\n\n    cfn_scheduled_query_props = timestream.CfnScheduledQueryProps(\n        error_report_configuration=timestream.CfnScheduledQuery.ErrorReportConfigurationProperty(\n            s3_configuration=timestream.CfnScheduledQuery.S3ConfigurationProperty(\n                bucket_name="bucketName",\n\n                # the properties below are optional\n                encryption_option="encryptionOption",\n                object_key_prefix="objectKeyPrefix"\n            )\n        ),\n        notification_configuration=timestream.CfnScheduledQuery.NotificationConfigurationProperty(\n            sns_configuration=timestream.CfnScheduledQuery.SnsConfigurationProperty(\n                topic_arn="topicArn"\n            )\n        ),\n        query_string="queryString",\n        schedule_configuration=timestream.CfnScheduledQuery.ScheduleConfigurationProperty(\n            schedule_expression="scheduleExpression"\n        ),\n        scheduled_query_execution_role_arn="scheduledQueryExecutionRoleArn",\n\n        # the properties below are optional\n        client_token="clientToken",\n        kms_key_id="kmsKeyId",\n        scheduled_query_name="scheduledQueryName",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        target_configuration=timestream.CfnScheduledQuery.TargetConfigurationProperty(\n            timestream_configuration=timestream.CfnScheduledQuery.TimestreamConfigurationProperty(\n                database_name="databaseName",\n                dimension_mappings=[timestream.CfnScheduledQuery.DimensionMappingProperty(\n                    dimension_value_type="dimensionValueType",\n                    name="name"\n                )],\n                table_name="tableName",\n                time_column="timeColumn",\n\n                # the properties below are optional\n                measure_name_column="measureNameColumn",\n                mixed_measure_mappings=[timestream.CfnScheduledQuery.MixedMeasureMappingProperty(\n                    measure_value_type="measureValueType",\n\n                    # the properties below are optional\n                    measure_name="measureName",\n                    multi_measure_attribute_mappings=[timestream.CfnScheduledQuery.MultiMeasureAttributeMappingProperty(\n                        measure_value_type="measureValueType",\n                        source_column="sourceColumn",\n\n                        # the properties below are optional\n                        target_multi_measure_attribute_name="targetMultiMeasureAttributeName"\n                    )],\n                    source_column="sourceColumn",\n                    target_measure_name="targetMeasureName"\n                )],\n                multi_measure_mappings=timestream.CfnScheduledQuery.MultiMeasureMappingsProperty(\n                    multi_measure_attribute_mappings=[timestream.CfnScheduledQuery.MultiMeasureAttributeMappingProperty(\n                        measure_value_type="measureValueType",\n                        source_column="sourceColumn",\n\n                        # the properties below are optional\n                        target_multi_measure_attribute_name="targetMultiMeasureAttributeName"\n                    )],\n\n                    # the properties below are optional\n                    target_multi_measure_name="targetMultiMeasureName"\n                )\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['error_report_configuration', 'notification_configuration', 'query_string', 'schedule_configuration', 'scheduled_query_execution_role_arn', 'client_token', 'kms_key_id', 'scheduled_query_name', 'tags', 'target_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_timestream.CfnScheduledQueryProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_timestream.CfnTableProps
class CfnTablePropsDef(BaseCfnProperty):
    database_name: str = pydantic.Field(..., description='The name of the Timestream database that contains this table. *Length Constraints* : Minimum length of 3 bytes. Maximum length of 256 bytes.\n')
    magnetic_store_write_properties: typing.Any = pydantic.Field(None, description='Contains properties to set on the table when enabling magnetic store writes. This object has the following attributes: - *EnableMagneticStoreWrites* : A ``boolean`` flag to enable magnetic store writes. - *MagneticStoreRejectedDataLocation* : The location to write error reports for records rejected, asynchronously, during magnetic store writes. Only ``S3Configuration`` objects are allowed. The ``S3Configuration`` object has the following attributes: - *BucketName* : The name of the S3 bucket. - *EncryptionOption* : The encryption option for the S3 location. Valid values are S3 server-side encryption with an S3 managed key ( ``SSE_S3`` ) or AWS managed key ( ``SSE_KMS`` ). - *KmsKeyId* : The AWS KMS key ID to use when encrypting with an AWS managed key. - *ObjectKeyPrefix* : The prefix to use option for the objects stored in S3. Both ``BucketName`` and ``EncryptionOption`` are *required* when ``S3Configuration`` is specified. If you specify ``SSE_KMS`` as your ``EncryptionOption`` then ``KmsKeyId`` is *required* . ``EnableMagneticStoreWrites`` attribute is *required* when ``MagneticStoreWriteProperties`` is specified. ``MagneticStoreRejectedDataLocation`` attribute is *required* when ``EnableMagneticStoreWrites`` is set to ``true`` . See the following examples: *JSON:: { "Type" : AWS::Timestream::Table", "Properties":{ "DatabaseName":"TestDatabase", "TableName":"TestTable", "MagneticStoreWriteProperties":{ "EnableMagneticStoreWrites":true, "MagneticStoreRejectedDataLocation":{ "S3Configuration":{ "BucketName":"testbucket", "EncryptionOption":"SSE_KMS", "KmsKeyId":"1234abcd-12ab-34cd-56ef-1234567890ab", "ObjectKeyPrefix":"prefix" } } } } } *YAML:: Type: AWS::Timestream::Table DependsOn: TestDatabase Properties: TableName: "TestTable" DatabaseName: "TestDatabase" MagneticStoreWriteProperties: EnableMagneticStoreWrites: true MagneticStoreRejectedDataLocation: S3Configuration: BucketName: "testbucket" EncryptionOption: "SSE_KMS" KmsKeyId: "1234abcd-12ab-34cd-56ef-1234567890ab" ObjectKeyPrefix: "prefix"\n')
    retention_properties: typing.Any = pydantic.Field(None, description='The retention duration for the memory store and magnetic store. This object has the following attributes:. - *MemoryStoreRetentionPeriodInHours* : Retention duration for memory store, in hours. - *MagneticStoreRetentionPeriodInDays* : Retention duration for magnetic store, in days. Both attributes are of type ``string`` . Both attributes are *required* when ``RetentionProperties`` is specified. See the following examples: *JSON* ``{ "Type" : AWS::Timestream::Table", "Properties" : { "DatabaseName" : "TestDatabase", "TableName" : "TestTable", "RetentionProperties" : { "MemoryStoreRetentionPeriodInHours": "24", "MagneticStoreRetentionPeriodInDays": "7" } } }`` *YAML:: Type: AWS::Timestream::Table DependsOn: TestDatabase Properties: TableName: "TestTable" DatabaseName: "TestDatabase" RetentionProperties: MemoryStoreRetentionPeriodInHours: "24" MagneticStoreRetentionPeriodInDays: "7"\n')
    table_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Timestream table. *Length Constraints* : Minimum length of 3 bytes. Maximum length of 256 bytes.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to add to the table.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-timestream-table.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_timestream as timestream\n\n    # magnetic_store_write_properties: Any\n    # retention_properties: Any\n\n    cfn_table_props = timestream.CfnTableProps(\n        database_name="databaseName",\n\n        # the properties below are optional\n        magnetic_store_write_properties=magnetic_store_write_properties,\n        retention_properties=retention_properties,\n        table_name="tableName",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['database_name', 'magnetic_store_write_properties', 'retention_properties', 'table_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_timestream.CfnTableProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    CfnScheduledQuery_DimensionMappingProperty: typing.Optional[dict[str, CfnScheduledQuery_DimensionMappingPropertyDef]] = pydantic.Field(None)
    CfnScheduledQuery_ErrorReportConfigurationProperty: typing.Optional[dict[str, CfnScheduledQuery_ErrorReportConfigurationPropertyDef]] = pydantic.Field(None)
    CfnScheduledQuery_MixedMeasureMappingProperty: typing.Optional[dict[str, CfnScheduledQuery_MixedMeasureMappingPropertyDef]] = pydantic.Field(None)
    CfnScheduledQuery_MultiMeasureAttributeMappingProperty: typing.Optional[dict[str, CfnScheduledQuery_MultiMeasureAttributeMappingPropertyDef]] = pydantic.Field(None)
    CfnScheduledQuery_MultiMeasureMappingsProperty: typing.Optional[dict[str, CfnScheduledQuery_MultiMeasureMappingsPropertyDef]] = pydantic.Field(None)
    CfnScheduledQuery_NotificationConfigurationProperty: typing.Optional[dict[str, CfnScheduledQuery_NotificationConfigurationPropertyDef]] = pydantic.Field(None)
    CfnScheduledQuery_S3ConfigurationProperty: typing.Optional[dict[str, CfnScheduledQuery_S3ConfigurationPropertyDef]] = pydantic.Field(None)
    CfnScheduledQuery_ScheduleConfigurationProperty: typing.Optional[dict[str, CfnScheduledQuery_ScheduleConfigurationPropertyDef]] = pydantic.Field(None)
    CfnScheduledQuery_SnsConfigurationProperty: typing.Optional[dict[str, CfnScheduledQuery_SnsConfigurationPropertyDef]] = pydantic.Field(None)
    CfnScheduledQuery_TargetConfigurationProperty: typing.Optional[dict[str, CfnScheduledQuery_TargetConfigurationPropertyDef]] = pydantic.Field(None)
    CfnScheduledQuery_TimestreamConfigurationProperty: typing.Optional[dict[str, CfnScheduledQuery_TimestreamConfigurationPropertyDef]] = pydantic.Field(None)
    CfnTable_MagneticStoreRejectedDataLocationProperty: typing.Optional[dict[str, CfnTable_MagneticStoreRejectedDataLocationPropertyDef]] = pydantic.Field(None)
    CfnTable_MagneticStoreWritePropertiesProperty: typing.Optional[dict[str, CfnTable_MagneticStoreWritePropertiesPropertyDef]] = pydantic.Field(None)
    CfnTable_RetentionPropertiesProperty: typing.Optional[dict[str, CfnTable_RetentionPropertiesPropertyDef]] = pydantic.Field(None)
    CfnTable_S3ConfigurationProperty: typing.Optional[dict[str, CfnTable_S3ConfigurationPropertyDef]] = pydantic.Field(None)
    CfnDatabase: typing.Optional[dict[str, CfnDatabaseDef]] = pydantic.Field(None)
    CfnScheduledQuery: typing.Optional[dict[str, CfnScheduledQueryDef]] = pydantic.Field(None)
    CfnTable: typing.Optional[dict[str, CfnTableDef]] = pydantic.Field(None)
    CfnDatabaseProps: typing.Optional[dict[str, CfnDatabasePropsDef]] = pydantic.Field(None)
    CfnScheduledQueryProps: typing.Optional[dict[str, CfnScheduledQueryPropsDef]] = pydantic.Field(None)
    CfnTableProps: typing.Optional[dict[str, CfnTablePropsDef]] = pydantic.Field(None)
    ...
