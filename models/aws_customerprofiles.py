from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_customerprofiles.CfnCalculatedAttributeDefinition.AttributeDetailsProperty
class CfnCalculatedAttributeDefinition_AttributeDetailsPropertyDef(BaseStruct):
    attributes: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnCalculatedAttributeDefinition_AttributeItemPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Mathematical expression and a list of attribute items specified in that expression.\n')
    expression: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Mathematical expression that is performed on attribute items provided in the attribute list. Each element in the expression should follow the structure of "{ObjectTypeName.AttributeName}".\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-calculatedattributedefinition-attributedetails.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    attribute_details_property = customerprofiles.CfnCalculatedAttributeDefinition.AttributeDetailsProperty(\n        attributes=[customerprofiles.CfnCalculatedAttributeDefinition.AttributeItemProperty(\n            name="name"\n        )],\n        expression="expression"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['attributes', 'expression']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnCalculatedAttributeDefinition.AttributeDetailsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnCalculatedAttributeDefinition.AttributeItemProperty
class CfnCalculatedAttributeDefinition_AttributeItemPropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique name of the calculated attribute.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-calculatedattributedefinition-attributeitem.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    attribute_item_property = customerprofiles.CfnCalculatedAttributeDefinition.AttributeItemProperty(\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnCalculatedAttributeDefinition.AttributeItemProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnCalculatedAttributeDefinition.ConditionsProperty
class CfnCalculatedAttributeDefinition_ConditionsPropertyDef(BaseStruct):
    object_count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of profile objects used for the calculated attribute.\n')
    range: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnCalculatedAttributeDefinition_RangePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The relative time period over which data is included in the aggregation.\n')
    threshold: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnCalculatedAttributeDefinition_ThresholdPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The threshold for the calculated attribute.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-calculatedattributedefinition-conditions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    conditions_property = customerprofiles.CfnCalculatedAttributeDefinition.ConditionsProperty(\n        object_count=123,\n        range=customerprofiles.CfnCalculatedAttributeDefinition.RangeProperty(\n            unit="unit",\n            value=123\n        ),\n        threshold=customerprofiles.CfnCalculatedAttributeDefinition.ThresholdProperty(\n            operator="operator",\n            value="value"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['object_count', 'range', 'threshold']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnCalculatedAttributeDefinition.ConditionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnCalculatedAttributeDefinition.RangeProperty
class CfnCalculatedAttributeDefinition_RangePropertyDef(BaseStruct):
    unit: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unit of time.\n')
    value: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The amount of time of the specified unit.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-calculatedattributedefinition-range.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    range_property = customerprofiles.CfnCalculatedAttributeDefinition.RangeProperty(\n        unit="unit",\n        value=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['unit', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnCalculatedAttributeDefinition.RangeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnCalculatedAttributeDefinition.ThresholdProperty
class CfnCalculatedAttributeDefinition_ThresholdPropertyDef(BaseStruct):
    operator: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The operator of the threshold.\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The value of the threshold.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-calculatedattributedefinition-threshold.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    threshold_property = customerprofiles.CfnCalculatedAttributeDefinition.ThresholdProperty(\n        operator="operator",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['operator', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnCalculatedAttributeDefinition.ThresholdProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnDomain.AttributeTypesSelectorProperty
class CfnDomain_AttributeTypesSelectorPropertyDef(BaseStruct):
    attribute_matching_model: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Configures the ``AttributeMatchingModel`` , you can either choose ``ONE_TO_ONE`` or ``MANY_TO_MANY`` .\n')
    address: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The ``Address`` type. You can choose from ``Address`` , ``BusinessAddress`` , ``MaillingAddress`` , and ``ShippingAddress`` . You only can use the ``Address`` type in the ``MatchingRule`` . For example, if you want to match a profile based on ``BusinessAddress.City`` or ``MaillingAddress.City`` , you can choose the ``BusinessAddress`` and the ``MaillingAddress`` to represent the ``Address`` type and specify the ``Address.City`` on the matching rule.\n')
    email_address: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Email type. You can choose from ``EmailAddress`` , ``BusinessEmailAddress`` and ``PersonalEmailAddress`` . You only can use the ``EmailAddress`` type in the ``MatchingRule`` . For example, if you want to match profile based on ``PersonalEmailAddress`` or ``BusinessEmailAddress`` , you can choose the ``PersonalEmailAddress`` and the ``BusinessEmailAddress`` to represent the ``EmailAddress`` type and only specify the ``EmailAddress`` on the matching rule.\n')
    phone_number: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The ``PhoneNumber`` type. You can choose from ``PhoneNumber`` , ``HomePhoneNumber`` , and ``MobilePhoneNumber`` . You only can use the ``PhoneNumber`` type in the ``MatchingRule`` . For example, if you want to match a profile based on ``Phone`` or ``HomePhone`` , you can choose the ``Phone`` and the ``HomePhone`` to represent the ``PhoneNumber`` type and only specify the ``PhoneNumber`` on the matching rule.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-domain-attributetypesselector.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    attribute_types_selector_property = customerprofiles.CfnDomain.AttributeTypesSelectorProperty(\n        attribute_matching_model="attributeMatchingModel",\n\n        # the properties below are optional\n        address=["address"],\n        email_address=["emailAddress"],\n        phone_number=["phoneNumber"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['attribute_matching_model', 'address', 'email_address', 'phone_number']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnDomain.AttributeTypesSelectorProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnDomain.AutoMergingProperty
class CfnDomain_AutoMergingPropertyDef(BaseStruct):
    enabled: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='The flag that enables the auto-merging of duplicate profiles.\n')
    conflict_resolution: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_ConflictResolutionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Determines how the auto-merging process should resolve conflicts between different profiles. For example, if Profile A and Profile B have the same ``FirstName`` and ``LastName`` , ``ConflictResolution`` specifies which ``EmailAddress`` should be used.\n')
    consolidation: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_ConsolidationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A list of matching attributes that represent matching criteria. If two profiles meet at least one of the requirements in the matching attributes list, they will be merged.\n')
    min_allowed_confidence_score_for_merging: typing.Union[int, float, None] = pydantic.Field(None, description='A number between 0 and 1 that represents the minimum confidence score required for profiles within a matching group to be merged during the auto-merge process. A higher score means that a higher similarity is required to merge profiles.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-domain-automerging.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    auto_merging_property = customerprofiles.CfnDomain.AutoMergingProperty(\n        enabled=False,\n\n        # the properties below are optional\n        conflict_resolution=customerprofiles.CfnDomain.ConflictResolutionProperty(\n            conflict_resolving_model="conflictResolvingModel",\n\n            # the properties below are optional\n            source_name="sourceName"\n        ),\n        consolidation=customerprofiles.CfnDomain.ConsolidationProperty(\n            matching_attributes_list=[["matchingAttributesList"]]\n        ),\n        min_allowed_confidence_score_for_merging=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'conflict_resolution', 'consolidation', 'min_allowed_confidence_score_for_merging']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnDomain.AutoMergingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnDomain.ConflictResolutionProperty
class CfnDomain_ConflictResolutionPropertyDef(BaseStruct):
    conflict_resolving_model: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='How the auto-merging process should resolve conflicts between different profiles.\n')
    source_name: typing.Optional[str] = pydantic.Field(None, description='The ``ObjectType`` name that is used to resolve profile merging conflicts when choosing ``SOURCE`` as the ``ConflictResolvingModel`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-domain-conflictresolution.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    conflict_resolution_property = customerprofiles.CfnDomain.ConflictResolutionProperty(\n        conflict_resolving_model="conflictResolvingModel",\n\n        # the properties below are optional\n        source_name="sourceName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['conflict_resolving_model', 'source_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnDomain.ConflictResolutionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnDomain.ConsolidationProperty
class CfnDomain_ConsolidationPropertyDef(BaseStruct):
    matching_attributes_list: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Sequence[str]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of matching criteria.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-domain-consolidation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    consolidation_property = customerprofiles.CfnDomain.ConsolidationProperty(\n        matching_attributes_list=[["matchingAttributesList"]]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['matching_attributes_list']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnDomain.ConsolidationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnDomain.DomainStatsProperty
class CfnDomain_DomainStatsPropertyDef(BaseStruct):
    metering_profile_count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of profiles that you are currently paying for in the domain. If you have more than 100 objects associated with a single profile, that profile counts as two profiles. If you have more than 200 objects, that profile counts as three, and so on.\n')
    object_count: typing.Union[int, float, None] = pydantic.Field(None, description='The total number of objects in domain.\n')
    profile_count: typing.Union[int, float, None] = pydantic.Field(None, description='The total number of profiles currently in the domain.\n')
    total_size: typing.Union[int, float, None] = pydantic.Field(None, description='The total size, in bytes, of all objects in the domain.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-domain-domainstats.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    domain_stats_property = customerprofiles.CfnDomain.DomainStatsProperty(\n        metering_profile_count=123,\n        object_count=123,\n        profile_count=123,\n        total_size=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['metering_profile_count', 'object_count', 'profile_count', 'total_size']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnDomain.DomainStatsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnDomain.ExportingConfigProperty
class CfnDomain_ExportingConfigPropertyDef(BaseStruct):
    s3_exporting: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_S3ExportingConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The S3 location where Identity Resolution Jobs write result files.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-domain-exportingconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    exporting_config_property = customerprofiles.CfnDomain.ExportingConfigProperty(\n        s3_exporting=customerprofiles.CfnDomain.S3ExportingConfigProperty(\n            s3_bucket_name="s3BucketName",\n\n            # the properties below are optional\n            s3_key_name="s3KeyName"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['s3_exporting']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnDomain.ExportingConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnDomain.JobScheduleProperty
class CfnDomain_JobSchedulePropertyDef(BaseStruct):
    day_of_the_week: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The day when the Identity Resolution Job should run every week.\n')
    time: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The time when the Identity Resolution Job should run every week.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-domain-jobschedule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    job_schedule_property = customerprofiles.CfnDomain.JobScheduleProperty(\n        day_of_the_week="dayOfTheWeek",\n        time="time"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['day_of_the_week', 'time']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnDomain.JobScheduleProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnDomain.MatchingProperty
class CfnDomain_MatchingPropertyDef(BaseStruct):
    enabled: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='The flag that enables the matching process of duplicate profiles.\n')
    auto_merging: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_AutoMergingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configuration information about the auto-merging process.\n')
    exporting_config: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_ExportingConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The S3 location where Identity Resolution Jobs write result files.\n')
    job_schedule: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_JobSchedulePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The day and time when do you want to start the Identity Resolution Job every week.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-domain-matching.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    matching_property = customerprofiles.CfnDomain.MatchingProperty(\n        enabled=False,\n\n        # the properties below are optional\n        auto_merging=customerprofiles.CfnDomain.AutoMergingProperty(\n            enabled=False,\n\n            # the properties below are optional\n            conflict_resolution=customerprofiles.CfnDomain.ConflictResolutionProperty(\n                conflict_resolving_model="conflictResolvingModel",\n\n                # the properties below are optional\n                source_name="sourceName"\n            ),\n            consolidation=customerprofiles.CfnDomain.ConsolidationProperty(\n                matching_attributes_list=[["matchingAttributesList"]]\n            ),\n            min_allowed_confidence_score_for_merging=123\n        ),\n        exporting_config=customerprofiles.CfnDomain.ExportingConfigProperty(\n            s3_exporting=customerprofiles.CfnDomain.S3ExportingConfigProperty(\n                s3_bucket_name="s3BucketName",\n\n                # the properties below are optional\n                s3_key_name="s3KeyName"\n            )\n        ),\n        job_schedule=customerprofiles.CfnDomain.JobScheduleProperty(\n            day_of_the_week="dayOfTheWeek",\n            time="time"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'auto_merging', 'exporting_config', 'job_schedule']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnDomain.MatchingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnDomain.MatchingRuleProperty
class CfnDomain_MatchingRulePropertyDef(BaseStruct):
    rule: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A single rule level of the ``MatchRules`` . Configures how the rule-based matching process should match profiles.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-domain-matchingrule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    matching_rule_property = customerprofiles.CfnDomain.MatchingRuleProperty(\n        rule=["rule"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['rule']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnDomain.MatchingRuleProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnDomain.RuleBasedMatchingProperty
class CfnDomain_RuleBasedMatchingPropertyDef(BaseStruct):
    enabled: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='The flag that enables the matching process of duplicate profiles.\n')
    attribute_types_selector: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_AttributeTypesSelectorPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configures information about the ``AttributeTypesSelector`` where the rule-based identity resolution uses to match profiles.\n')
    conflict_resolution: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_ConflictResolutionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Determines how the auto-merging process should resolve conflicts between different profiles. For example, if Profile A and Profile B have the same ``FirstName`` and ``LastName`` , ``ConflictResolution`` specifies which ``EmailAddress`` should be used.\n')
    exporting_config: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_ExportingConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The S3 location where Identity Resolution Jobs write result files.\n')
    matching_rules: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_MatchingRulePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Configures how the rule-based matching process should match profiles. You can have up to 15 ``MatchingRule`` in the ``MatchingRules`` .\n')
    max_allowed_rule_level_for_matching: typing.Union[int, float, None] = pydantic.Field(None, description='Indicates the maximum allowed rule level for matching.\n')
    max_allowed_rule_level_for_merging: typing.Union[int, float, None] = pydantic.Field(None, description='Indicates the maximum allowed rule level for merging.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='The status of rule-based matching rule.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-domain-rulebasedmatching.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    rule_based_matching_property = customerprofiles.CfnDomain.RuleBasedMatchingProperty(\n        enabled=False,\n\n        # the properties below are optional\n        attribute_types_selector=customerprofiles.CfnDomain.AttributeTypesSelectorProperty(\n            attribute_matching_model="attributeMatchingModel",\n\n            # the properties below are optional\n            address=["address"],\n            email_address=["emailAddress"],\n            phone_number=["phoneNumber"]\n        ),\n        conflict_resolution=customerprofiles.CfnDomain.ConflictResolutionProperty(\n            conflict_resolving_model="conflictResolvingModel",\n\n            # the properties below are optional\n            source_name="sourceName"\n        ),\n        exporting_config=customerprofiles.CfnDomain.ExportingConfigProperty(\n            s3_exporting=customerprofiles.CfnDomain.S3ExportingConfigProperty(\n                s3_bucket_name="s3BucketName",\n\n                # the properties below are optional\n                s3_key_name="s3KeyName"\n            )\n        ),\n        matching_rules=[customerprofiles.CfnDomain.MatchingRuleProperty(\n            rule=["rule"]\n        )],\n        max_allowed_rule_level_for_matching=123,\n        max_allowed_rule_level_for_merging=123,\n        status="status"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'attribute_types_selector', 'conflict_resolution', 'exporting_config', 'matching_rules', 'max_allowed_rule_level_for_matching', 'max_allowed_rule_level_for_merging', 'status']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnDomain.RuleBasedMatchingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnDomain.S3ExportingConfigProperty
class CfnDomain_S3ExportingConfigPropertyDef(BaseStruct):
    s3_bucket_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the S3 bucket where Identity Resolution Jobs write result files.\n')
    s3_key_name: typing.Optional[str] = pydantic.Field(None, description='The S3 key name of the location where Identity Resolution Jobs write result files.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-domain-s3exportingconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    s3_exporting_config_property = customerprofiles.CfnDomain.S3ExportingConfigProperty(\n        s3_bucket_name="s3BucketName",\n\n        # the properties below are optional\n        s3_key_name="s3KeyName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['s3_bucket_name', 's3_key_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnDomain.S3ExportingConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnEventStream.DestinationDetailsProperty
class CfnEventStream_DestinationDetailsPropertyDef(BaseStruct):
    status: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The status of enabling the Kinesis stream as a destination for export.\n')
    uri: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The StreamARN of the destination to deliver profile events to. For example, arn:aws:kinesis:region:account-id:stream/stream-name.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-eventstream-destinationdetails.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    destination_details_property = customerprofiles.CfnEventStream.DestinationDetailsProperty(\n        status="status",\n        uri="uri"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['status', 'uri']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnEventStream.DestinationDetailsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnIntegration.ConnectorOperatorProperty
class CfnIntegration_ConnectorOperatorPropertyDef(BaseStruct):
    marketo: typing.Optional[str] = pydantic.Field(None, description='The operation to be performed on the provided Marketo source fields.\n')
    s3: typing.Optional[str] = pydantic.Field(None, description='The operation to be performed on the provided Amazon S3 source fields.\n')
    salesforce: typing.Optional[str] = pydantic.Field(None, description='The operation to be performed on the provided Salesforce source fields.\n')
    service_now: typing.Optional[str] = pydantic.Field(None, description='The operation to be performed on the provided ServiceNow source fields.\n')
    zendesk: typing.Optional[str] = pydantic.Field(None, description='The operation to be performed on the provided Zendesk source fields.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-integration-connectoroperator.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    connector_operator_property = customerprofiles.CfnIntegration.ConnectorOperatorProperty(\n        marketo="marketo",\n        s3="s3",\n        salesforce="salesforce",\n        service_now="serviceNow",\n        zendesk="zendesk"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['marketo', 's3', 'salesforce', 'service_now', 'zendesk']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnIntegration.ConnectorOperatorProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnIntegration.FlowDefinitionProperty
class CfnIntegration_FlowDefinitionPropertyDef(BaseStruct):
    flow_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The specified name of the flow. Use underscores (_) or hyphens (-) only. Spaces are not allowed.\n')
    kms_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the AWS Key Management Service (KMS) key you provide for encryption.\n')
    source_flow_config: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_SourceFlowConfigPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The configuration that controls how Customer Profiles retrieves data from the source.\n')
    tasks: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_TaskPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of tasks that Customer Profiles performs while transferring the data in the flow run.\n')
    trigger_config: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_TriggerConfigPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The trigger settings that determine how and when the flow runs.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the flow you want to create.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-integration-flowdefinition.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    flow_definition_property = customerprofiles.CfnIntegration.FlowDefinitionProperty(\n        flow_name="flowName",\n        kms_arn="kmsArn",\n        source_flow_config=customerprofiles.CfnIntegration.SourceFlowConfigProperty(\n            connector_type="connectorType",\n            source_connector_properties=customerprofiles.CfnIntegration.SourceConnectorPropertiesProperty(\n                marketo=customerprofiles.CfnIntegration.MarketoSourcePropertiesProperty(\n                    object="object"\n                ),\n                s3=customerprofiles.CfnIntegration.S3SourcePropertiesProperty(\n                    bucket_name="bucketName",\n\n                    # the properties below are optional\n                    bucket_prefix="bucketPrefix"\n                ),\n                salesforce=customerprofiles.CfnIntegration.SalesforceSourcePropertiesProperty(\n                    object="object",\n\n                    # the properties below are optional\n                    enable_dynamic_field_update=False,\n                    include_deleted_records=False\n                ),\n                service_now=customerprofiles.CfnIntegration.ServiceNowSourcePropertiesProperty(\n                    object="object"\n                ),\n                zendesk=customerprofiles.CfnIntegration.ZendeskSourcePropertiesProperty(\n                    object="object"\n                )\n            ),\n\n            # the properties below are optional\n            connector_profile_name="connectorProfileName",\n            incremental_pull_config=customerprofiles.CfnIntegration.IncrementalPullConfigProperty(\n                datetime_type_field_name="datetimeTypeFieldName"\n            )\n        ),\n        tasks=[customerprofiles.CfnIntegration.TaskProperty(\n            source_fields=["sourceFields"],\n            task_type="taskType",\n\n            # the properties below are optional\n            connector_operator=customerprofiles.CfnIntegration.ConnectorOperatorProperty(\n                marketo="marketo",\n                s3="s3",\n                salesforce="salesforce",\n                service_now="serviceNow",\n                zendesk="zendesk"\n            ),\n            destination_field="destinationField",\n            task_properties=[customerprofiles.CfnIntegration.TaskPropertiesMapProperty(\n                operator_property_key="operatorPropertyKey",\n                property="property"\n            )]\n        )],\n        trigger_config=customerprofiles.CfnIntegration.TriggerConfigProperty(\n            trigger_type="triggerType",\n\n            # the properties below are optional\n            trigger_properties=customerprofiles.CfnIntegration.TriggerPropertiesProperty(\n                scheduled=customerprofiles.CfnIntegration.ScheduledTriggerPropertiesProperty(\n                    schedule_expression="scheduleExpression",\n\n                    # the properties below are optional\n                    data_pull_mode="dataPullMode",\n                    first_execution_from=123,\n                    schedule_end_time=123,\n                    schedule_offset=123,\n                    schedule_start_time=123,\n                    timezone="timezone"\n                )\n            )\n        ),\n\n        # the properties below are optional\n        description="description"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['flow_name', 'kms_arn', 'source_flow_config', 'tasks', 'trigger_config', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnIntegration.FlowDefinitionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnIntegration.IncrementalPullConfigProperty
class CfnIntegration_IncrementalPullConfigPropertyDef(BaseStruct):
    datetime_type_field_name: typing.Optional[str] = pydantic.Field(None, description='A field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-integration-incrementalpullconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    incremental_pull_config_property = customerprofiles.CfnIntegration.IncrementalPullConfigProperty(\n        datetime_type_field_name="datetimeTypeFieldName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['datetime_type_field_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnIntegration.IncrementalPullConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnIntegration.MarketoSourcePropertiesProperty
class CfnIntegration_MarketoSourcePropertiesPropertyDef(BaseStruct):
    object: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The object specified in the Marketo flow source.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-integration-marketosourceproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    marketo_source_properties_property = customerprofiles.CfnIntegration.MarketoSourcePropertiesProperty(\n        object="object"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['object']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnIntegration.MarketoSourcePropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnIntegration.ObjectTypeMappingProperty
class CfnIntegration_ObjectTypeMappingPropertyDef(BaseStruct):
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The key.\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The value.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-integration-objecttypemapping.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    object_type_mapping_property = customerprofiles.CfnIntegration.ObjectTypeMappingProperty(\n        key="key",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnIntegration.ObjectTypeMappingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnIntegration.S3SourcePropertiesProperty
class CfnIntegration_S3SourcePropertiesPropertyDef(BaseStruct):
    bucket_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon S3 bucket name where the source files are stored.\n')
    bucket_prefix: typing.Optional[str] = pydantic.Field(None, description='The object key for the Amazon S3 bucket in which the source files are stored.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-integration-s3sourceproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    s3_source_properties_property = customerprofiles.CfnIntegration.S3SourcePropertiesProperty(\n        bucket_name="bucketName",\n\n        # the properties below are optional\n        bucket_prefix="bucketPrefix"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket_name', 'bucket_prefix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnIntegration.S3SourcePropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnIntegration.SalesforceSourcePropertiesProperty
class CfnIntegration_SalesforceSourcePropertiesPropertyDef(BaseStruct):
    object: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The object specified in the Salesforce flow source.\n')
    enable_dynamic_field_update: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='The flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow.\n')
    include_deleted_records: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether Amazon AppFlow includes deleted files in the flow run.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-integration-salesforcesourceproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    salesforce_source_properties_property = customerprofiles.CfnIntegration.SalesforceSourcePropertiesProperty(\n        object="object",\n\n        # the properties below are optional\n        enable_dynamic_field_update=False,\n        include_deleted_records=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['object', 'enable_dynamic_field_update', 'include_deleted_records']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnIntegration.SalesforceSourcePropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnIntegration.ScheduledTriggerPropertiesProperty
class CfnIntegration_ScheduledTriggerPropertiesPropertyDef(BaseStruct):
    schedule_expression: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The scheduling expression that determines the rate at which the schedule will run, for example rate (5 minutes).\n')
    data_pull_mode: typing.Optional[str] = pydantic.Field(None, description='Specifies whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run.\n')
    first_execution_from: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the date range for the records to import from the connector in the first flow run.\n')
    schedule_end_time: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the scheduled end time for a scheduled-trigger flow.\n')
    schedule_offset: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the optional offset that is added to the time interval for a schedule-triggered flow.\n')
    schedule_start_time: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the scheduled start time for a scheduled-trigger flow.\n')
    timezone: typing.Optional[str] = pydantic.Field(None, description='Specifies the time zone used when referring to the date and time of a scheduled-triggered flow, such as America/New_York.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-integration-scheduledtriggerproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    scheduled_trigger_properties_property = customerprofiles.CfnIntegration.ScheduledTriggerPropertiesProperty(\n        schedule_expression="scheduleExpression",\n\n        # the properties below are optional\n        data_pull_mode="dataPullMode",\n        first_execution_from=123,\n        schedule_end_time=123,\n        schedule_offset=123,\n        schedule_start_time=123,\n        timezone="timezone"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['schedule_expression', 'data_pull_mode', 'first_execution_from', 'schedule_end_time', 'schedule_offset', 'schedule_start_time', 'timezone']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnIntegration.ScheduledTriggerPropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnIntegration.ServiceNowSourcePropertiesProperty
class CfnIntegration_ServiceNowSourcePropertiesPropertyDef(BaseStruct):
    object: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The object specified in the ServiceNow flow source.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-integration-servicenowsourceproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    service_now_source_properties_property = customerprofiles.CfnIntegration.ServiceNowSourcePropertiesProperty(\n        object="object"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['object']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnIntegration.ServiceNowSourcePropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnIntegration.SourceConnectorPropertiesProperty
class CfnIntegration_SourceConnectorPropertiesPropertyDef(BaseStruct):
    marketo: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_MarketoSourcePropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties that are applied when Marketo is being used as a source.\n')
    s3: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_S3SourcePropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties that are applied when Amazon S3 is being used as the flow source.\n')
    salesforce: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_SalesforceSourcePropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties that are applied when Salesforce is being used as a source.\n')
    service_now: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_ServiceNowSourcePropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties that are applied when ServiceNow is being used as a source.\n')
    zendesk: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_ZendeskSourcePropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties that are applied when using Zendesk as a flow source.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-integration-sourceconnectorproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    source_connector_properties_property = customerprofiles.CfnIntegration.SourceConnectorPropertiesProperty(\n        marketo=customerprofiles.CfnIntegration.MarketoSourcePropertiesProperty(\n            object="object"\n        ),\n        s3=customerprofiles.CfnIntegration.S3SourcePropertiesProperty(\n            bucket_name="bucketName",\n\n            # the properties below are optional\n            bucket_prefix="bucketPrefix"\n        ),\n        salesforce=customerprofiles.CfnIntegration.SalesforceSourcePropertiesProperty(\n            object="object",\n\n            # the properties below are optional\n            enable_dynamic_field_update=False,\n            include_deleted_records=False\n        ),\n        service_now=customerprofiles.CfnIntegration.ServiceNowSourcePropertiesProperty(\n            object="object"\n        ),\n        zendesk=customerprofiles.CfnIntegration.ZendeskSourcePropertiesProperty(\n            object="object"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['marketo', 's3', 'salesforce', 'service_now', 'zendesk']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnIntegration.SourceConnectorPropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnIntegration.SourceFlowConfigProperty
class CfnIntegration_SourceFlowConfigPropertyDef(BaseStruct):
    connector_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of connector, such as Salesforce, Marketo, and so on.\n')
    source_connector_properties: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_SourceConnectorPropertiesPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the information that is required to query a particular source connector.\n')
    connector_profile_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Amazon AppFlow connector profile. This name must be unique for each connector profile in the AWS account .\n')
    incremental_pull_config: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_IncrementalPullConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-integration-sourceflowconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    source_flow_config_property = customerprofiles.CfnIntegration.SourceFlowConfigProperty(\n        connector_type="connectorType",\n        source_connector_properties=customerprofiles.CfnIntegration.SourceConnectorPropertiesProperty(\n            marketo=customerprofiles.CfnIntegration.MarketoSourcePropertiesProperty(\n                object="object"\n            ),\n            s3=customerprofiles.CfnIntegration.S3SourcePropertiesProperty(\n                bucket_name="bucketName",\n\n                # the properties below are optional\n                bucket_prefix="bucketPrefix"\n            ),\n            salesforce=customerprofiles.CfnIntegration.SalesforceSourcePropertiesProperty(\n                object="object",\n\n                # the properties below are optional\n                enable_dynamic_field_update=False,\n                include_deleted_records=False\n            ),\n            service_now=customerprofiles.CfnIntegration.ServiceNowSourcePropertiesProperty(\n                object="object"\n            ),\n            zendesk=customerprofiles.CfnIntegration.ZendeskSourcePropertiesProperty(\n                object="object"\n            )\n        ),\n\n        # the properties below are optional\n        connector_profile_name="connectorProfileName",\n        incremental_pull_config=customerprofiles.CfnIntegration.IncrementalPullConfigProperty(\n            datetime_type_field_name="datetimeTypeFieldName"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connector_type', 'source_connector_properties', 'connector_profile_name', 'incremental_pull_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnIntegration.SourceFlowConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnIntegration.TaskPropertiesMapProperty
class CfnIntegration_TaskPropertiesMapPropertyDef(BaseStruct):
    operator_property_key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The task property key.\n')
    property: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The task property value.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-integration-taskpropertiesmap.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    task_properties_map_property = customerprofiles.CfnIntegration.TaskPropertiesMapProperty(\n        operator_property_key="operatorPropertyKey",\n        property="property"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['operator_property_key', 'property']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnIntegration.TaskPropertiesMapProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnIntegration.TaskProperty
class CfnIntegration_TaskPropertyDef(BaseStruct):
    source_fields: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The source fields to which a particular task is applied.\n')
    task_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the particular task implementation that Amazon AppFlow performs.\n')
    connector_operator: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_ConnectorOperatorPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The operation to be performed on the provided source fields.\n')
    destination_field: typing.Optional[str] = pydantic.Field(None, description='A field in a destination connector, or a field value against which Amazon AppFlow validates a source field.\n')
    task_properties: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_TaskPropertiesMapPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A map used to store task-related information. The service looks for particular information based on the TaskType.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-integration-task.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    task_property = customerprofiles.CfnIntegration.TaskProperty(\n        source_fields=["sourceFields"],\n        task_type="taskType",\n\n        # the properties below are optional\n        connector_operator=customerprofiles.CfnIntegration.ConnectorOperatorProperty(\n            marketo="marketo",\n            s3="s3",\n            salesforce="salesforce",\n            service_now="serviceNow",\n            zendesk="zendesk"\n        ),\n        destination_field="destinationField",\n        task_properties=[customerprofiles.CfnIntegration.TaskPropertiesMapProperty(\n            operator_property_key="operatorPropertyKey",\n            property="property"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['source_fields', 'task_type', 'connector_operator', 'destination_field', 'task_properties']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnIntegration.TaskProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnIntegration.TriggerConfigProperty
class CfnIntegration_TriggerConfigPropertyDef(BaseStruct):
    trigger_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the type of flow trigger. It can be OnDemand, Scheduled, or Event.\n')
    trigger_properties: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_TriggerPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies the configuration details of a schedule-triggered flow that you define. Currently, these settings only apply to the Scheduled trigger type.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-integration-triggerconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    trigger_config_property = customerprofiles.CfnIntegration.TriggerConfigProperty(\n        trigger_type="triggerType",\n\n        # the properties below are optional\n        trigger_properties=customerprofiles.CfnIntegration.TriggerPropertiesProperty(\n            scheduled=customerprofiles.CfnIntegration.ScheduledTriggerPropertiesProperty(\n                schedule_expression="scheduleExpression",\n\n                # the properties below are optional\n                data_pull_mode="dataPullMode",\n                first_execution_from=123,\n                schedule_end_time=123,\n                schedule_offset=123,\n                schedule_start_time=123,\n                timezone="timezone"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['trigger_type', 'trigger_properties']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnIntegration.TriggerConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnIntegration.TriggerPropertiesProperty
class CfnIntegration_TriggerPropertiesPropertyDef(BaseStruct):
    scheduled: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_ScheduledTriggerPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies the configuration details of a schedule-triggered flow that you define.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-integration-triggerproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    trigger_properties_property = customerprofiles.CfnIntegration.TriggerPropertiesProperty(\n        scheduled=customerprofiles.CfnIntegration.ScheduledTriggerPropertiesProperty(\n            schedule_expression="scheduleExpression",\n\n            # the properties below are optional\n            data_pull_mode="dataPullMode",\n            first_execution_from=123,\n            schedule_end_time=123,\n            schedule_offset=123,\n            schedule_start_time=123,\n            timezone="timezone"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['scheduled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnIntegration.TriggerPropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnIntegration.ZendeskSourcePropertiesProperty
class CfnIntegration_ZendeskSourcePropertiesPropertyDef(BaseStruct):
    object: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The object specified in the Zendesk flow source.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-integration-zendesksourceproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    zendesk_source_properties_property = customerprofiles.CfnIntegration.ZendeskSourcePropertiesProperty(\n        object="object"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['object']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnIntegration.ZendeskSourcePropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnObjectType.FieldMapProperty
class CfnObjectType_FieldMapPropertyDef(BaseStruct):
    name: typing.Optional[str] = pydantic.Field(None, description='Name of the field.\n')
    object_type_field: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnObjectType_ObjectTypeFieldPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Represents a field in a ProfileObjectType.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-objecttype-fieldmap.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    field_map_property = customerprofiles.CfnObjectType.FieldMapProperty(\n        name="name",\n        object_type_field=customerprofiles.CfnObjectType.ObjectTypeFieldProperty(\n            content_type="contentType",\n            source="source",\n            target="target"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'object_type_field']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnObjectType.FieldMapProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnObjectType.KeyMapProperty
class CfnObjectType_KeyMapPropertyDef(BaseStruct):
    name: typing.Optional[str] = pydantic.Field(None, description='Name of the key.\n')
    object_type_key_list: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnObjectType_ObjectTypeKeyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of ObjectTypeKey.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-objecttype-keymap.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    key_map_property = customerprofiles.CfnObjectType.KeyMapProperty(\n        name="name",\n        object_type_key_list=[customerprofiles.CfnObjectType.ObjectTypeKeyProperty(\n            field_names=["fieldNames"],\n            standard_identifiers=["standardIdentifiers"]\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'object_type_key_list']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnObjectType.KeyMapProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnObjectType.ObjectTypeFieldProperty
class CfnObjectType_ObjectTypeFieldPropertyDef(BaseStruct):
    content_type: typing.Optional[str] = pydantic.Field(None, description='The content type of the field. Used for determining equality when searching.\n')
    source: typing.Optional[str] = pydantic.Field(None, description='A field of a ProfileObject. For example: _source.FirstName, where “_source” is a ProfileObjectType of a Zendesk user and “FirstName” is a field in that ObjectType.\n')
    target: typing.Optional[str] = pydantic.Field(None, description='The location of the data in the standard ProfileObject model. For example: _profile.Address.PostalCode.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-objecttype-objecttypefield.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    object_type_field_property = customerprofiles.CfnObjectType.ObjectTypeFieldProperty(\n        content_type="contentType",\n        source="source",\n        target="target"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['content_type', 'source', 'target']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnObjectType.ObjectTypeFieldProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnObjectType.ObjectTypeKeyProperty
class CfnObjectType_ObjectTypeKeyPropertyDef(BaseStruct):
    field_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The reference for the key name of the fields map.\n')
    standard_identifiers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The types of keys that a ProfileObject can have. Each ProfileObject can have only 1 UNIQUE key but multiple PROFILE keys. PROFILE means that this key can be used to tie an object to a PROFILE. UNIQUE means that it can be used to uniquely identify an object. If a key a is marked as SECONDARY, it will be used to search for profiles after all other PROFILE keys have been searched. A LOOKUP_ONLY key is only used to match a profile but is not persisted to be used for searching of the profile. A NEW_ONLY key is only used if the profile does not already exist before the object is ingested, otherwise it is only used for matching objects to profiles.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-customerprofiles-objecttype-objecttypekey.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    object_type_key_property = customerprofiles.CfnObjectType.ObjectTypeKeyProperty(\n        field_names=["fieldNames"],\n        standard_identifiers=["standardIdentifiers"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['field_names', 'standard_identifiers']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnObjectType.ObjectTypeKeyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnCalculatedAttributeDefinition
class CfnCalculatedAttributeDefinitionDef(BaseCfnResource):
    attribute_details: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_customerprofiles.CfnCalculatedAttributeDefinition_AttributeDetailsPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Mathematical expression and a list of attribute items specified in that expression.\n')
    calculated_attribute_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of an attribute defined in a profile object type.\n')
    domain_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique name of the domain.\n')
    statistic: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The aggregation operation to perform for the calculated attribute.\n')
    conditions: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnCalculatedAttributeDefinition_ConditionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The conditions including range, object count, and threshold for the calculated attribute.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the calculated attribute.\n')
    display_name: typing.Optional[str] = pydantic.Field(None, description='The display name of the calculated attribute.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource.')
    _init_params: typing.ClassVar[list[str]] = ['attribute_details', 'calculated_attribute_name', 'domain_name', 'statistic', 'conditions', 'description', 'display_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['AttributeDetailsProperty', 'AttributeItemProperty', 'ConditionsProperty', 'RangeProperty', 'ThresholdProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnCalculatedAttributeDefinition'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_customerprofiles.CfnCalculatedAttributeDefinitionDefConfig] = pydantic.Field(None)


class CfnCalculatedAttributeDefinitionDefConfig(pydantic.BaseModel):
    AttributeDetailsProperty: typing.Optional[list[models.aws_customerprofiles.CfnCalculatedAttributeDefinitionDefAttributedetailspropertyParams]] = pydantic.Field(None, description='')
    AttributeItemProperty: typing.Optional[list[models.aws_customerprofiles.CfnCalculatedAttributeDefinitionDefAttributeitempropertyParams]] = pydantic.Field(None, description='')
    ConditionsProperty: typing.Optional[list[models.aws_customerprofiles.CfnCalculatedAttributeDefinitionDefConditionspropertyParams]] = pydantic.Field(None, description='')
    RangeProperty: typing.Optional[list[models.aws_customerprofiles.CfnCalculatedAttributeDefinitionDefRangepropertyParams]] = pydantic.Field(None, description='')
    ThresholdProperty: typing.Optional[list[models.aws_customerprofiles.CfnCalculatedAttributeDefinitionDefThresholdpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_customerprofiles.CfnCalculatedAttributeDefinitionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_customerprofiles.CfnCalculatedAttributeDefinitionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_customerprofiles.CfnCalculatedAttributeDefinitionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_customerprofiles.CfnCalculatedAttributeDefinitionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_customerprofiles.CfnCalculatedAttributeDefinitionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_customerprofiles.CfnCalculatedAttributeDefinitionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_customerprofiles.CfnCalculatedAttributeDefinitionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_customerprofiles.CfnCalculatedAttributeDefinitionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_customerprofiles.CfnCalculatedAttributeDefinitionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_customerprofiles.CfnCalculatedAttributeDefinitionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_customerprofiles.CfnCalculatedAttributeDefinitionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_customerprofiles.CfnCalculatedAttributeDefinitionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_customerprofiles.CfnCalculatedAttributeDefinitionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnCalculatedAttributeDefinitionDefAttributedetailspropertyParams(pydantic.BaseModel):
    attributes: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnCalculatedAttributeDefinition_AttributeItemPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    expression: str = pydantic.Field(..., description='')
    ...

class CfnCalculatedAttributeDefinitionDefAttributeitempropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    ...

class CfnCalculatedAttributeDefinitionDefConditionspropertyParams(pydantic.BaseModel):
    object_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    range: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnCalculatedAttributeDefinition_RangePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    threshold: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnCalculatedAttributeDefinition_ThresholdPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnCalculatedAttributeDefinitionDefRangepropertyParams(pydantic.BaseModel):
    unit: str = pydantic.Field(..., description='')
    value: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnCalculatedAttributeDefinitionDefThresholdpropertyParams(pydantic.BaseModel):
    operator: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnCalculatedAttributeDefinitionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnCalculatedAttributeDefinitionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCalculatedAttributeDefinitionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnCalculatedAttributeDefinitionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCalculatedAttributeDefinitionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnCalculatedAttributeDefinitionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnCalculatedAttributeDefinitionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnCalculatedAttributeDefinitionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnCalculatedAttributeDefinitionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnCalculatedAttributeDefinitionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCalculatedAttributeDefinitionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnCalculatedAttributeDefinitionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnCalculatedAttributeDefinitionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCalculatedAttributeDefinitionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_customerprofiles.CfnDomain
class CfnDomainDef(BaseCfnResource):
    domain_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique name of the domain.\n')
    dead_letter_queue_url: typing.Optional[str] = pydantic.Field(None, description='The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications. You must set up a policy on the ``DeadLetterQueue`` for the ``SendMessage`` operation to enable Amazon Connect Customer Profiles to send messages to the ``DeadLetterQueue`` .\n')
    default_encryption_key: typing.Optional[str] = pydantic.Field(None, description='The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.\n')
    default_expiration_days: typing.Union[int, float, None] = pydantic.Field(None, description='The default number of days until the data within the domain expires.\n')
    matching: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_MatchingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The process of matching duplicate profiles.\n')
    rule_based_matching: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_RuleBasedMatchingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The process of matching duplicate profiles using Rule-Based matching.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource.')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'dead_letter_queue_url', 'default_encryption_key', 'default_expiration_days', 'matching', 'rule_based_matching', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['AttributeTypesSelectorProperty', 'AutoMergingProperty', 'ConflictResolutionProperty', 'ConsolidationProperty', 'DomainStatsProperty', 'ExportingConfigProperty', 'JobScheduleProperty', 'MatchingProperty', 'MatchingRuleProperty', 'RuleBasedMatchingProperty', 'S3ExportingConfigProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnDomain'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_customerprofiles.CfnDomainDefConfig] = pydantic.Field(None)


class CfnDomainDefConfig(pydantic.BaseModel):
    AttributeTypesSelectorProperty: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefAttributetypesselectorpropertyParams]] = pydantic.Field(None, description='')
    AutoMergingProperty: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefAutomergingpropertyParams]] = pydantic.Field(None, description='')
    ConflictResolutionProperty: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefConflictresolutionpropertyParams]] = pydantic.Field(None, description='')
    ConsolidationProperty: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefConsolidationpropertyParams]] = pydantic.Field(None, description='')
    DomainStatsProperty: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefDomainstatspropertyParams]] = pydantic.Field(None, description='')
    ExportingConfigProperty: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefExportingconfigpropertyParams]] = pydantic.Field(None, description='')
    JobScheduleProperty: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefJobschedulepropertyParams]] = pydantic.Field(None, description='')
    MatchingProperty: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefMatchingpropertyParams]] = pydantic.Field(None, description='')
    MatchingRuleProperty: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefMatchingrulepropertyParams]] = pydantic.Field(None, description='')
    RuleBasedMatchingProperty: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefRulebasedmatchingpropertyParams]] = pydantic.Field(None, description='')
    S3ExportingConfigProperty: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefS3ExportingconfigpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_customerprofiles.CfnDomainDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_stats_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDomainDefAttributetypesselectorpropertyParams(pydantic.BaseModel):
    attribute_matching_model: str = pydantic.Field(..., description='')
    address: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    email_address: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    phone_number: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnDomainDefAutomergingpropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, models.UnsupportedResource] = pydantic.Field(..., description='')
    conflict_resolution: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_ConflictResolutionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    consolidation: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_ConsolidationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    min_allowed_confidence_score_for_merging: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnDomainDefConflictresolutionpropertyParams(pydantic.BaseModel):
    conflict_resolving_model: str = pydantic.Field(..., description='')
    source_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDomainDefConsolidationpropertyParams(pydantic.BaseModel):
    matching_attributes_list: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Sequence[str]]] = pydantic.Field(..., description='')
    ...

class CfnDomainDefDomainstatspropertyParams(pydantic.BaseModel):
    metering_profile_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    object_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    profile_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    total_size: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnDomainDefExportingconfigpropertyParams(pydantic.BaseModel):
    s3_exporting: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_S3ExportingConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnDomainDefJobschedulepropertyParams(pydantic.BaseModel):
    day_of_the_week: str = pydantic.Field(..., description='')
    time: str = pydantic.Field(..., description='')
    ...

class CfnDomainDefMatchingpropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, models.UnsupportedResource] = pydantic.Field(..., description='')
    auto_merging: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_AutoMergingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    exporting_config: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_ExportingConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    job_schedule: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_JobSchedulePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnDomainDefMatchingrulepropertyParams(pydantic.BaseModel):
    rule: typing.Sequence[str] = pydantic.Field(..., description='')
    ...

class CfnDomainDefRulebasedmatchingpropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, models.UnsupportedResource] = pydantic.Field(..., description='')
    attribute_types_selector: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_AttributeTypesSelectorPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    conflict_resolution: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_ConflictResolutionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    exporting_config: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_ExportingConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    matching_rules: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_MatchingRulePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    max_allowed_rule_level_for_matching: typing.Union[int, float, None] = pydantic.Field(None, description='')
    max_allowed_rule_level_for_merging: typing.Union[int, float, None] = pydantic.Field(None, description='')
    status: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDomainDefS3ExportingconfigpropertyParams(pydantic.BaseModel):
    s3_bucket_name: str = pydantic.Field(..., description='')
    s3_key_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDomainDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDomainDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDomainDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDomainDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDomainDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDomainDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDomainDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDomainDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDomainDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDomainDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDomainDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDomainDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDomainDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDomainDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_customerprofiles.CfnEventStream
class CfnEventStreamDef(BaseCfnResource):
    domain_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique name of the domain.\n')
    event_stream_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the event stream.\n')
    uri: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The StreamARN of the destination to deliver profile events to. For example, arn:aws:kinesis:region:account-id:stream/stream-name.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource.')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'event_stream_name', 'uri', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['DestinationDetailsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnEventStream'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_customerprofiles.CfnEventStreamDefConfig] = pydantic.Field(None)


class CfnEventStreamDefConfig(pydantic.BaseModel):
    DestinationDetailsProperty: typing.Optional[list[models.aws_customerprofiles.CfnEventStreamDefDestinationdetailspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_customerprofiles.CfnEventStreamDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_customerprofiles.CfnEventStreamDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_customerprofiles.CfnEventStreamDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_customerprofiles.CfnEventStreamDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_customerprofiles.CfnEventStreamDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_customerprofiles.CfnEventStreamDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_customerprofiles.CfnEventStreamDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_customerprofiles.CfnEventStreamDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_customerprofiles.CfnEventStreamDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_customerprofiles.CfnEventStreamDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_customerprofiles.CfnEventStreamDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_customerprofiles.CfnEventStreamDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_customerprofiles.CfnEventStreamDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_destination_details_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)

class CfnEventStreamDefDestinationdetailspropertyParams(pydantic.BaseModel):
    status: str = pydantic.Field(..., description='')
    uri: str = pydantic.Field(..., description='')
    ...

class CfnEventStreamDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnEventStreamDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEventStreamDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnEventStreamDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEventStreamDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnEventStreamDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnEventStreamDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnEventStreamDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnEventStreamDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnEventStreamDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEventStreamDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnEventStreamDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnEventStreamDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEventStreamDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_customerprofiles.CfnIntegration
class CfnIntegrationDef(BaseCfnResource):
    domain_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique name of the domain.\n')
    flow_definition: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_FlowDefinitionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration that controls how Customer Profiles retrieves data from the source.\n')
    object_type_name: typing.Optional[str] = pydantic.Field(None, description='The name of the profile object type mapping to use.\n')
    object_type_names: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_ObjectTypeMappingPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The object type mapping.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource.\n')
    uri: typing.Optional[str] = pydantic.Field(None, description='The URI of the S3 bucket or any other type of data source.')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'flow_definition', 'object_type_name', 'object_type_names', 'tags', 'uri']
    _method_names: typing.ClassVar[list[str]] = ['ConnectorOperatorProperty', 'FlowDefinitionProperty', 'IncrementalPullConfigProperty', 'MarketoSourcePropertiesProperty', 'ObjectTypeMappingProperty', 'S3SourcePropertiesProperty', 'SalesforceSourcePropertiesProperty', 'ScheduledTriggerPropertiesProperty', 'ServiceNowSourcePropertiesProperty', 'SourceConnectorPropertiesProperty', 'SourceFlowConfigProperty', 'TaskPropertiesMapProperty', 'TaskProperty', 'TriggerConfigProperty', 'TriggerPropertiesProperty', 'ZendeskSourcePropertiesProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnIntegration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_customerprofiles.CfnIntegrationDefConfig] = pydantic.Field(None)


class CfnIntegrationDefConfig(pydantic.BaseModel):
    ConnectorOperatorProperty: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefConnectoroperatorpropertyParams]] = pydantic.Field(None, description='')
    FlowDefinitionProperty: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefFlowdefinitionpropertyParams]] = pydantic.Field(None, description='')
    IncrementalPullConfigProperty: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefIncrementalpullconfigpropertyParams]] = pydantic.Field(None, description='')
    MarketoSourcePropertiesProperty: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefMarketosourcepropertiespropertyParams]] = pydantic.Field(None, description='')
    ObjectTypeMappingProperty: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefObjecttypemappingpropertyParams]] = pydantic.Field(None, description='')
    S3SourcePropertiesProperty: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefS3SourcepropertiespropertyParams]] = pydantic.Field(None, description='')
    SalesforceSourcePropertiesProperty: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefSalesforcesourcepropertiespropertyParams]] = pydantic.Field(None, description='')
    ScheduledTriggerPropertiesProperty: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefScheduledtriggerpropertiespropertyParams]] = pydantic.Field(None, description='')
    ServiceNowSourcePropertiesProperty: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefServicenowsourcepropertiespropertyParams]] = pydantic.Field(None, description='')
    SourceConnectorPropertiesProperty: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefSourceconnectorpropertiespropertyParams]] = pydantic.Field(None, description='')
    SourceFlowConfigProperty: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefSourceflowconfigpropertyParams]] = pydantic.Field(None, description='')
    TaskPropertiesMapProperty: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefTaskpropertiesmappropertyParams]] = pydantic.Field(None, description='')
    TaskProperty: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefTaskpropertyParams]] = pydantic.Field(None, description='')
    TriggerConfigProperty: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefTriggerconfigpropertyParams]] = pydantic.Field(None, description='')
    TriggerPropertiesProperty: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefTriggerpropertiespropertyParams]] = pydantic.Field(None, description='')
    ZendeskSourcePropertiesProperty: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefZendesksourcepropertiespropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_customerprofiles.CfnIntegrationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnIntegrationDefConnectoroperatorpropertyParams(pydantic.BaseModel):
    marketo: typing.Optional[str] = pydantic.Field(None, description='')
    s3: typing.Optional[str] = pydantic.Field(None, description='')
    salesforce: typing.Optional[str] = pydantic.Field(None, description='')
    service_now: typing.Optional[str] = pydantic.Field(None, description='')
    zendesk: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnIntegrationDefFlowdefinitionpropertyParams(pydantic.BaseModel):
    flow_name: str = pydantic.Field(..., description='')
    kms_arn: str = pydantic.Field(..., description='')
    source_flow_config: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_SourceFlowConfigPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    tasks: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_TaskPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    trigger_config: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_TriggerConfigPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnIntegrationDefIncrementalpullconfigpropertyParams(pydantic.BaseModel):
    datetime_type_field_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnIntegrationDefMarketosourcepropertiespropertyParams(pydantic.BaseModel):
    object: str = pydantic.Field(..., description='')
    ...

class CfnIntegrationDefObjecttypemappingpropertyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnIntegrationDefS3SourcepropertiespropertyParams(pydantic.BaseModel):
    bucket_name: str = pydantic.Field(..., description='')
    bucket_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnIntegrationDefSalesforcesourcepropertiespropertyParams(pydantic.BaseModel):
    object: str = pydantic.Field(..., description='')
    enable_dynamic_field_update: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    include_deleted_records: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnIntegrationDefScheduledtriggerpropertiespropertyParams(pydantic.BaseModel):
    schedule_expression: str = pydantic.Field(..., description='')
    data_pull_mode: typing.Optional[str] = pydantic.Field(None, description='')
    first_execution_from: typing.Union[int, float, None] = pydantic.Field(None, description='')
    schedule_end_time: typing.Union[int, float, None] = pydantic.Field(None, description='')
    schedule_offset: typing.Union[int, float, None] = pydantic.Field(None, description='')
    schedule_start_time: typing.Union[int, float, None] = pydantic.Field(None, description='')
    timezone: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnIntegrationDefServicenowsourcepropertiespropertyParams(pydantic.BaseModel):
    object: str = pydantic.Field(..., description='')
    ...

class CfnIntegrationDefSourceconnectorpropertiespropertyParams(pydantic.BaseModel):
    marketo: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_MarketoSourcePropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    s3: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_S3SourcePropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    salesforce: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_SalesforceSourcePropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    service_now: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_ServiceNowSourcePropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    zendesk: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_ZendeskSourcePropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnIntegrationDefSourceflowconfigpropertyParams(pydantic.BaseModel):
    connector_type: str = pydantic.Field(..., description='')
    source_connector_properties: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_SourceConnectorPropertiesPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    connector_profile_name: typing.Optional[str] = pydantic.Field(None, description='')
    incremental_pull_config: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_IncrementalPullConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnIntegrationDefTaskpropertiesmappropertyParams(pydantic.BaseModel):
    operator_property_key: str = pydantic.Field(..., description='')
    property: str = pydantic.Field(..., description='')
    ...

class CfnIntegrationDefTaskpropertyParams(pydantic.BaseModel):
    source_fields: typing.Sequence[str] = pydantic.Field(..., description='')
    task_type: str = pydantic.Field(..., description='')
    connector_operator: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_ConnectorOperatorPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    destination_field: typing.Optional[str] = pydantic.Field(None, description='')
    task_properties: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_TaskPropertiesMapPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnIntegrationDefTriggerconfigpropertyParams(pydantic.BaseModel):
    trigger_type: str = pydantic.Field(..., description='')
    trigger_properties: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_TriggerPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnIntegrationDefTriggerpropertiespropertyParams(pydantic.BaseModel):
    scheduled: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_ScheduledTriggerPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnIntegrationDefZendesksourcepropertiespropertyParams(pydantic.BaseModel):
    object: str = pydantic.Field(..., description='')
    ...

class CfnIntegrationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnIntegrationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIntegrationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnIntegrationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIntegrationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnIntegrationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnIntegrationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnIntegrationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnIntegrationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnIntegrationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIntegrationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnIntegrationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnIntegrationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIntegrationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_customerprofiles.CfnObjectType
class CfnObjectTypeDef(BaseCfnResource):
    domain_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique name of the domain.\n')
    allow_profile_creation: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether a profile should be created when data is received if one doesn’t exist for an object of this type. The default is ``FALSE`` . If the AllowProfileCreation flag is set to ``FALSE`` , then the service tries to fetch a standard profile and associate this object with the profile. If it is set to ``TRUE`` , and if no match is found, then the service creates a new standard profile.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the profile object type mapping.\n')
    encryption_key: typing.Optional[str] = pydantic.Field(None, description='The customer-provided key to encrypt the profile object that will be created in this profile object type mapping. If not specified the system will use the encryption key of the domain.\n')
    expiration_days: typing.Union[int, float, None] = pydantic.Field(None, description='The number of days until the data of this type expires.\n')
    fields: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnObjectType_FieldMapPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of field definitions for the object type mapping.\n')
    keys: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnObjectType_KeyMapPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of keys that can be used to map data to the profile or search for the profile.\n')
    object_type_name: typing.Optional[str] = pydantic.Field(None, description='The name of the profile object type.\n')
    source_last_updated_timestamp_format: typing.Optional[str] = pydantic.Field(None, description='The format of your sourceLastUpdatedTimestamp that was previously set up.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource.\n')
    template_id: typing.Optional[str] = pydantic.Field(None, description='A unique identifier for the template mapping. This can be used instead of specifying the Keys and Fields properties directly.')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'allow_profile_creation', 'description', 'encryption_key', 'expiration_days', 'fields', 'keys', 'object_type_name', 'source_last_updated_timestamp_format', 'tags', 'template_id']
    _method_names: typing.ClassVar[list[str]] = ['FieldMapProperty', 'KeyMapProperty', 'ObjectTypeFieldProperty', 'ObjectTypeKeyProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnObjectType'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_customerprofiles.CfnObjectTypeDefConfig] = pydantic.Field(None)


class CfnObjectTypeDefConfig(pydantic.BaseModel):
    FieldMapProperty: typing.Optional[list[models.aws_customerprofiles.CfnObjectTypeDefFieldmappropertyParams]] = pydantic.Field(None, description='')
    KeyMapProperty: typing.Optional[list[models.aws_customerprofiles.CfnObjectTypeDefKeymappropertyParams]] = pydantic.Field(None, description='')
    ObjectTypeFieldProperty: typing.Optional[list[models.aws_customerprofiles.CfnObjectTypeDefObjecttypefieldpropertyParams]] = pydantic.Field(None, description='')
    ObjectTypeKeyProperty: typing.Optional[list[models.aws_customerprofiles.CfnObjectTypeDefObjecttypekeypropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_customerprofiles.CfnObjectTypeDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_customerprofiles.CfnObjectTypeDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_customerprofiles.CfnObjectTypeDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_customerprofiles.CfnObjectTypeDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_customerprofiles.CfnObjectTypeDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_customerprofiles.CfnObjectTypeDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_customerprofiles.CfnObjectTypeDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_customerprofiles.CfnObjectTypeDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_customerprofiles.CfnObjectTypeDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_customerprofiles.CfnObjectTypeDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_customerprofiles.CfnObjectTypeDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_customerprofiles.CfnObjectTypeDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_customerprofiles.CfnObjectTypeDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnObjectTypeDefFieldmappropertyParams(pydantic.BaseModel):
    name: typing.Optional[str] = pydantic.Field(None, description='')
    object_type_field: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnObjectType_ObjectTypeFieldPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnObjectTypeDefKeymappropertyParams(pydantic.BaseModel):
    name: typing.Optional[str] = pydantic.Field(None, description='')
    object_type_key_list: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnObjectType_ObjectTypeKeyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnObjectTypeDefObjecttypefieldpropertyParams(pydantic.BaseModel):
    content_type: typing.Optional[str] = pydantic.Field(None, description='')
    source: typing.Optional[str] = pydantic.Field(None, description='')
    target: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnObjectTypeDefObjecttypekeypropertyParams(pydantic.BaseModel):
    field_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    standard_identifiers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnObjectTypeDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnObjectTypeDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnObjectTypeDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnObjectTypeDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnObjectTypeDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnObjectTypeDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnObjectTypeDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnObjectTypeDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnObjectTypeDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnObjectTypeDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnObjectTypeDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnObjectTypeDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnObjectTypeDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnObjectTypeDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_customerprofiles.CfnCalculatedAttributeDefinitionProps
class CfnCalculatedAttributeDefinitionPropsDef(BaseCfnProperty):
    attribute_details: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_customerprofiles.CfnCalculatedAttributeDefinition_AttributeDetailsPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Mathematical expression and a list of attribute items specified in that expression.\n')
    calculated_attribute_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of an attribute defined in a profile object type.\n')
    domain_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique name of the domain.\n')
    statistic: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The aggregation operation to perform for the calculated attribute.\n')
    conditions: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnCalculatedAttributeDefinition_ConditionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The conditions including range, object count, and threshold for the calculated attribute.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the calculated attribute.\n')
    display_name: typing.Optional[str] = pydantic.Field(None, description='The display name of the calculated attribute.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-customerprofiles-calculatedattributedefinition.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    cfn_calculated_attribute_definition_props = customerprofiles.CfnCalculatedAttributeDefinitionProps(\n        attribute_details=customerprofiles.CfnCalculatedAttributeDefinition.AttributeDetailsProperty(\n            attributes=[customerprofiles.CfnCalculatedAttributeDefinition.AttributeItemProperty(\n                name="name"\n            )],\n            expression="expression"\n        ),\n        calculated_attribute_name="calculatedAttributeName",\n        domain_name="domainName",\n        statistic="statistic",\n\n        # the properties below are optional\n        conditions=customerprofiles.CfnCalculatedAttributeDefinition.ConditionsProperty(\n            object_count=123,\n            range=customerprofiles.CfnCalculatedAttributeDefinition.RangeProperty(\n                unit="unit",\n                value=123\n            ),\n            threshold=customerprofiles.CfnCalculatedAttributeDefinition.ThresholdProperty(\n                operator="operator",\n                value="value"\n            )\n        ),\n        description="description",\n        display_name="displayName",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['attribute_details', 'calculated_attribute_name', 'domain_name', 'statistic', 'conditions', 'description', 'display_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnCalculatedAttributeDefinitionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnDomainProps
class CfnDomainPropsDef(BaseCfnProperty):
    domain_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique name of the domain.\n')
    dead_letter_queue_url: typing.Optional[str] = pydantic.Field(None, description='The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications. You must set up a policy on the ``DeadLetterQueue`` for the ``SendMessage`` operation to enable Amazon Connect Customer Profiles to send messages to the ``DeadLetterQueue`` .\n')
    default_encryption_key: typing.Optional[str] = pydantic.Field(None, description='The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.\n')
    default_expiration_days: typing.Union[int, float, None] = pydantic.Field(None, description='The default number of days until the data within the domain expires.\n')
    matching: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_MatchingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The process of matching duplicate profiles.\n')
    rule_based_matching: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnDomain_RuleBasedMatchingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The process of matching duplicate profiles using Rule-Based matching.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-customerprofiles-domain.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    cfn_domain_props = customerprofiles.CfnDomainProps(\n        domain_name="domainName",\n\n        # the properties below are optional\n        dead_letter_queue_url="deadLetterQueueUrl",\n        default_encryption_key="defaultEncryptionKey",\n        default_expiration_days=123,\n        matching=customerprofiles.CfnDomain.MatchingProperty(\n            enabled=False,\n\n            # the properties below are optional\n            auto_merging=customerprofiles.CfnDomain.AutoMergingProperty(\n                enabled=False,\n\n                # the properties below are optional\n                conflict_resolution=customerprofiles.CfnDomain.ConflictResolutionProperty(\n                    conflict_resolving_model="conflictResolvingModel",\n\n                    # the properties below are optional\n                    source_name="sourceName"\n                ),\n                consolidation=customerprofiles.CfnDomain.ConsolidationProperty(\n                    matching_attributes_list=[["matchingAttributesList"]]\n                ),\n                min_allowed_confidence_score_for_merging=123\n            ),\n            exporting_config=customerprofiles.CfnDomain.ExportingConfigProperty(\n                s3_exporting=customerprofiles.CfnDomain.S3ExportingConfigProperty(\n                    s3_bucket_name="s3BucketName",\n\n                    # the properties below are optional\n                    s3_key_name="s3KeyName"\n                )\n            ),\n            job_schedule=customerprofiles.CfnDomain.JobScheduleProperty(\n                day_of_the_week="dayOfTheWeek",\n                time="time"\n            )\n        ),\n        rule_based_matching=customerprofiles.CfnDomain.RuleBasedMatchingProperty(\n            enabled=False,\n\n            # the properties below are optional\n            attribute_types_selector=customerprofiles.CfnDomain.AttributeTypesSelectorProperty(\n                attribute_matching_model="attributeMatchingModel",\n\n                # the properties below are optional\n                address=["address"],\n                email_address=["emailAddress"],\n                phone_number=["phoneNumber"]\n            ),\n            conflict_resolution=customerprofiles.CfnDomain.ConflictResolutionProperty(\n                conflict_resolving_model="conflictResolvingModel",\n\n                # the properties below are optional\n                source_name="sourceName"\n            ),\n            exporting_config=customerprofiles.CfnDomain.ExportingConfigProperty(\n                s3_exporting=customerprofiles.CfnDomain.S3ExportingConfigProperty(\n                    s3_bucket_name="s3BucketName",\n\n                    # the properties below are optional\n                    s3_key_name="s3KeyName"\n                )\n            ),\n            matching_rules=[customerprofiles.CfnDomain.MatchingRuleProperty(\n                rule=["rule"]\n            )],\n            max_allowed_rule_level_for_matching=123,\n            max_allowed_rule_level_for_merging=123,\n            status="status"\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'dead_letter_queue_url', 'default_encryption_key', 'default_expiration_days', 'matching', 'rule_based_matching', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnDomainProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnEventStreamProps
class CfnEventStreamPropsDef(BaseCfnProperty):
    domain_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique name of the domain.\n')
    event_stream_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the event stream.\n')
    uri: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The StreamARN of the destination to deliver profile events to. For example, arn:aws:kinesis:region:account-id:stream/stream-name.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-customerprofiles-eventstream.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    cfn_event_stream_props = customerprofiles.CfnEventStreamProps(\n        domain_name="domainName",\n        event_stream_name="eventStreamName",\n        uri="uri",\n\n        # the properties below are optional\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'event_stream_name', 'uri', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnEventStreamProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnIntegrationProps
class CfnIntegrationPropsDef(BaseCfnProperty):
    domain_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique name of the domain.\n')
    flow_definition: typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_FlowDefinitionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration that controls how Customer Profiles retrieves data from the source.\n')
    object_type_name: typing.Optional[str] = pydantic.Field(None, description='The name of the profile object type mapping to use.\n')
    object_type_names: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnIntegration_ObjectTypeMappingPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The object type mapping.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource.\n')
    uri: typing.Optional[str] = pydantic.Field(None, description='The URI of the S3 bucket or any other type of data source.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-customerprofiles-integration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    cfn_integration_props = customerprofiles.CfnIntegrationProps(\n        domain_name="domainName",\n\n        # the properties below are optional\n        flow_definition=customerprofiles.CfnIntegration.FlowDefinitionProperty(\n            flow_name="flowName",\n            kms_arn="kmsArn",\n            source_flow_config=customerprofiles.CfnIntegration.SourceFlowConfigProperty(\n                connector_type="connectorType",\n                source_connector_properties=customerprofiles.CfnIntegration.SourceConnectorPropertiesProperty(\n                    marketo=customerprofiles.CfnIntegration.MarketoSourcePropertiesProperty(\n                        object="object"\n                    ),\n                    s3=customerprofiles.CfnIntegration.S3SourcePropertiesProperty(\n                        bucket_name="bucketName",\n\n                        # the properties below are optional\n                        bucket_prefix="bucketPrefix"\n                    ),\n                    salesforce=customerprofiles.CfnIntegration.SalesforceSourcePropertiesProperty(\n                        object="object",\n\n                        # the properties below are optional\n                        enable_dynamic_field_update=False,\n                        include_deleted_records=False\n                    ),\n                    service_now=customerprofiles.CfnIntegration.ServiceNowSourcePropertiesProperty(\n                        object="object"\n                    ),\n                    zendesk=customerprofiles.CfnIntegration.ZendeskSourcePropertiesProperty(\n                        object="object"\n                    )\n                ),\n\n                # the properties below are optional\n                connector_profile_name="connectorProfileName",\n                incremental_pull_config=customerprofiles.CfnIntegration.IncrementalPullConfigProperty(\n                    datetime_type_field_name="datetimeTypeFieldName"\n                )\n            ),\n            tasks=[customerprofiles.CfnIntegration.TaskProperty(\n                source_fields=["sourceFields"],\n                task_type="taskType",\n\n                # the properties below are optional\n                connector_operator=customerprofiles.CfnIntegration.ConnectorOperatorProperty(\n                    marketo="marketo",\n                    s3="s3",\n                    salesforce="salesforce",\n                    service_now="serviceNow",\n                    zendesk="zendesk"\n                ),\n                destination_field="destinationField",\n                task_properties=[customerprofiles.CfnIntegration.TaskPropertiesMapProperty(\n                    operator_property_key="operatorPropertyKey",\n                    property="property"\n                )]\n            )],\n            trigger_config=customerprofiles.CfnIntegration.TriggerConfigProperty(\n                trigger_type="triggerType",\n\n                # the properties below are optional\n                trigger_properties=customerprofiles.CfnIntegration.TriggerPropertiesProperty(\n                    scheduled=customerprofiles.CfnIntegration.ScheduledTriggerPropertiesProperty(\n                        schedule_expression="scheduleExpression",\n\n                        # the properties below are optional\n                        data_pull_mode="dataPullMode",\n                        first_execution_from=123,\n                        schedule_end_time=123,\n                        schedule_offset=123,\n                        schedule_start_time=123,\n                        timezone="timezone"\n                    )\n                )\n            ),\n\n            # the properties below are optional\n            description="description"\n        ),\n        object_type_name="objectTypeName",\n        object_type_names=[customerprofiles.CfnIntegration.ObjectTypeMappingProperty(\n            key="key",\n            value="value"\n        )],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        uri="uri"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'flow_definition', 'object_type_name', 'object_type_names', 'tags', 'uri']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnIntegrationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_customerprofiles.CfnObjectTypeProps
class CfnObjectTypePropsDef(BaseCfnProperty):
    domain_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique name of the domain.\n')
    allow_profile_creation: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether a profile should be created when data is received if one doesn’t exist for an object of this type. The default is ``FALSE`` . If the AllowProfileCreation flag is set to ``FALSE`` , then the service tries to fetch a standard profile and associate this object with the profile. If it is set to ``TRUE`` , and if no match is found, then the service creates a new standard profile.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the profile object type mapping.\n')
    encryption_key: typing.Optional[str] = pydantic.Field(None, description='The customer-provided key to encrypt the profile object that will be created in this profile object type mapping. If not specified the system will use the encryption key of the domain.\n')
    expiration_days: typing.Union[int, float, None] = pydantic.Field(None, description='The number of days until the data of this type expires.\n')
    fields: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnObjectType_FieldMapPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of field definitions for the object type mapping.\n')
    keys: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_customerprofiles.CfnObjectType_KeyMapPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of keys that can be used to map data to the profile or search for the profile.\n')
    object_type_name: typing.Optional[str] = pydantic.Field(None, description='The name of the profile object type.\n')
    source_last_updated_timestamp_format: typing.Optional[str] = pydantic.Field(None, description='The format of your sourceLastUpdatedTimestamp that was previously set up.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource.\n')
    template_id: typing.Optional[str] = pydantic.Field(None, description='A unique identifier for the template mapping. This can be used instead of specifying the Keys and Fields properties directly.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-customerprofiles-objecttype.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_customerprofiles as customerprofiles\n\n    cfn_object_type_props = customerprofiles.CfnObjectTypeProps(\n        domain_name="domainName",\n\n        # the properties below are optional\n        allow_profile_creation=False,\n        description="description",\n        encryption_key="encryptionKey",\n        expiration_days=123,\n        fields=[customerprofiles.CfnObjectType.FieldMapProperty(\n            name="name",\n            object_type_field=customerprofiles.CfnObjectType.ObjectTypeFieldProperty(\n                content_type="contentType",\n                source="source",\n                target="target"\n            )\n        )],\n        keys=[customerprofiles.CfnObjectType.KeyMapProperty(\n            name="name",\n            object_type_key_list=[customerprofiles.CfnObjectType.ObjectTypeKeyProperty(\n                field_names=["fieldNames"],\n                standard_identifiers=["standardIdentifiers"]\n            )]\n        )],\n        object_type_name="objectTypeName",\n        source_last_updated_timestamp_format="sourceLastUpdatedTimestampFormat",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        template_id="templateId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'allow_profile_creation', 'description', 'encryption_key', 'expiration_days', 'fields', 'keys', 'object_type_name', 'source_last_updated_timestamp_format', 'tags', 'template_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_customerprofiles.CfnObjectTypeProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    CfnCalculatedAttributeDefinition_AttributeDetailsProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnCalculatedAttributeDefinition_AttributeDetailsPropertyDef]] = pydantic.Field(None)
    CfnCalculatedAttributeDefinition_AttributeItemProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnCalculatedAttributeDefinition_AttributeItemPropertyDef]] = pydantic.Field(None)
    CfnCalculatedAttributeDefinition_ConditionsProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnCalculatedAttributeDefinition_ConditionsPropertyDef]] = pydantic.Field(None)
    CfnCalculatedAttributeDefinition_RangeProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnCalculatedAttributeDefinition_RangePropertyDef]] = pydantic.Field(None)
    CfnCalculatedAttributeDefinition_ThresholdProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnCalculatedAttributeDefinition_ThresholdPropertyDef]] = pydantic.Field(None)
    CfnDomain_AttributeTypesSelectorProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnDomain_AttributeTypesSelectorPropertyDef]] = pydantic.Field(None)
    CfnDomain_AutoMergingProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnDomain_AutoMergingPropertyDef]] = pydantic.Field(None)
    CfnDomain_ConflictResolutionProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnDomain_ConflictResolutionPropertyDef]] = pydantic.Field(None)
    CfnDomain_ConsolidationProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnDomain_ConsolidationPropertyDef]] = pydantic.Field(None)
    CfnDomain_DomainStatsProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnDomain_DomainStatsPropertyDef]] = pydantic.Field(None)
    CfnDomain_ExportingConfigProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnDomain_ExportingConfigPropertyDef]] = pydantic.Field(None)
    CfnDomain_JobScheduleProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnDomain_JobSchedulePropertyDef]] = pydantic.Field(None)
    CfnDomain_MatchingProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnDomain_MatchingPropertyDef]] = pydantic.Field(None)
    CfnDomain_MatchingRuleProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnDomain_MatchingRulePropertyDef]] = pydantic.Field(None)
    CfnDomain_RuleBasedMatchingProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnDomain_RuleBasedMatchingPropertyDef]] = pydantic.Field(None)
    CfnDomain_S3ExportingConfigProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnDomain_S3ExportingConfigPropertyDef]] = pydantic.Field(None)
    CfnEventStream_DestinationDetailsProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnEventStream_DestinationDetailsPropertyDef]] = pydantic.Field(None)
    CfnIntegration_ConnectorOperatorProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnIntegration_ConnectorOperatorPropertyDef]] = pydantic.Field(None)
    CfnIntegration_FlowDefinitionProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnIntegration_FlowDefinitionPropertyDef]] = pydantic.Field(None)
    CfnIntegration_IncrementalPullConfigProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnIntegration_IncrementalPullConfigPropertyDef]] = pydantic.Field(None)
    CfnIntegration_MarketoSourcePropertiesProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnIntegration_MarketoSourcePropertiesPropertyDef]] = pydantic.Field(None)
    CfnIntegration_ObjectTypeMappingProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnIntegration_ObjectTypeMappingPropertyDef]] = pydantic.Field(None)
    CfnIntegration_S3SourcePropertiesProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnIntegration_S3SourcePropertiesPropertyDef]] = pydantic.Field(None)
    CfnIntegration_SalesforceSourcePropertiesProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnIntegration_SalesforceSourcePropertiesPropertyDef]] = pydantic.Field(None)
    CfnIntegration_ScheduledTriggerPropertiesProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnIntegration_ScheduledTriggerPropertiesPropertyDef]] = pydantic.Field(None)
    CfnIntegration_ServiceNowSourcePropertiesProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnIntegration_ServiceNowSourcePropertiesPropertyDef]] = pydantic.Field(None)
    CfnIntegration_SourceConnectorPropertiesProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnIntegration_SourceConnectorPropertiesPropertyDef]] = pydantic.Field(None)
    CfnIntegration_SourceFlowConfigProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnIntegration_SourceFlowConfigPropertyDef]] = pydantic.Field(None)
    CfnIntegration_TaskPropertiesMapProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnIntegration_TaskPropertiesMapPropertyDef]] = pydantic.Field(None)
    CfnIntegration_TaskProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnIntegration_TaskPropertyDef]] = pydantic.Field(None)
    CfnIntegration_TriggerConfigProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnIntegration_TriggerConfigPropertyDef]] = pydantic.Field(None)
    CfnIntegration_TriggerPropertiesProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnIntegration_TriggerPropertiesPropertyDef]] = pydantic.Field(None)
    CfnIntegration_ZendeskSourcePropertiesProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnIntegration_ZendeskSourcePropertiesPropertyDef]] = pydantic.Field(None)
    CfnObjectType_FieldMapProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnObjectType_FieldMapPropertyDef]] = pydantic.Field(None)
    CfnObjectType_KeyMapProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnObjectType_KeyMapPropertyDef]] = pydantic.Field(None)
    CfnObjectType_ObjectTypeFieldProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnObjectType_ObjectTypeFieldPropertyDef]] = pydantic.Field(None)
    CfnObjectType_ObjectTypeKeyProperty: typing.Optional[dict[str, models.aws_customerprofiles.CfnObjectType_ObjectTypeKeyPropertyDef]] = pydantic.Field(None)
    CfnCalculatedAttributeDefinition: typing.Optional[dict[str, models.aws_customerprofiles.CfnCalculatedAttributeDefinitionDef]] = pydantic.Field(None)
    CfnDomain: typing.Optional[dict[str, models.aws_customerprofiles.CfnDomainDef]] = pydantic.Field(None)
    CfnEventStream: typing.Optional[dict[str, models.aws_customerprofiles.CfnEventStreamDef]] = pydantic.Field(None)
    CfnIntegration: typing.Optional[dict[str, models.aws_customerprofiles.CfnIntegrationDef]] = pydantic.Field(None)
    CfnObjectType: typing.Optional[dict[str, models.aws_customerprofiles.CfnObjectTypeDef]] = pydantic.Field(None)
    CfnCalculatedAttributeDefinitionProps: typing.Optional[dict[str, models.aws_customerprofiles.CfnCalculatedAttributeDefinitionPropsDef]] = pydantic.Field(None)
    CfnDomainProps: typing.Optional[dict[str, models.aws_customerprofiles.CfnDomainPropsDef]] = pydantic.Field(None)
    CfnEventStreamProps: typing.Optional[dict[str, models.aws_customerprofiles.CfnEventStreamPropsDef]] = pydantic.Field(None)
    CfnIntegrationProps: typing.Optional[dict[str, models.aws_customerprofiles.CfnIntegrationPropsDef]] = pydantic.Field(None)
    CfnObjectTypeProps: typing.Optional[dict[str, models.aws_customerprofiles.CfnObjectTypePropsDef]] = pydantic.Field(None)
    ...

import models
