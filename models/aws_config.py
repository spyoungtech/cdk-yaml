from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_config.ManagedRuleIdentifiers
class ManagedRuleIdentifiersDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.ManagedRuleIdentifiers'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.ResourceType
class ResourceTypeDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['of']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.ResourceType'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_config.ResourceTypeDefConfig] = pydantic.Field(None)


class ResourceTypeDefConfig(pydantic.BaseModel):
    of: typing.Optional[list[models.aws_config.ResourceTypeDefOfParams]] = pydantic.Field(None, description='A custom resource type to support future cases.')

class ResourceTypeDefOfParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_config.ResourceTypeDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_config.RuleScope
class RuleScopeDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_resource', 'from_resources', 'from_tag']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.RuleScope'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_resource', 'from_resources', 'from_tag']
    ...


    from_resource: typing.Optional[models.aws_config.RuleScopeDefFromResourceParams] = pydantic.Field(None, description='restricts scope of changes to a specific resource type or resource identifier.')
    from_resources: typing.Optional[models.aws_config.RuleScopeDefFromResourcesParams] = pydantic.Field(None, description='restricts scope of changes to specific resource types.')
    from_tag: typing.Optional[models.aws_config.RuleScopeDefFromTagParams] = pydantic.Field(None, description='restricts scope of changes to a specific tag.')

class RuleScopeDefFromResourceParams(pydantic.BaseModel):
    resource_type: models.aws_config.ResourceTypeDef = pydantic.Field(..., description='-\n')
    resource_id: typing.Optional[str] = pydantic.Field(None, description='-')
    ...

class RuleScopeDefFromResourcesParams(pydantic.BaseModel):
    resource_types: typing.Sequence[models.aws_config.ResourceTypeDef] = pydantic.Field(..., description='-')
    ...

class RuleScopeDefFromTagParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Optional[str] = pydantic.Field(None, description='-')
    ...


#  autogenerated from aws_cdk.aws_config.AccessKeysRotated
class AccessKeysRotatedDef(BaseConstruct):
    max_age: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum number of days within which the access keys must be rotated. Default: Duration.days(90)\n')
    config_rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the AWS Config rule. Default: - CloudFormation generated name\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description about this AWS Config rule. Default: - No description\n')
    input_parameters: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='Input parameter values that are passed to the AWS Config rule. Default: - No input parameters\n')
    maximum_execution_frequency: typing.Optional[aws_cdk.aws_config.MaximumExecutionFrequency] = pydantic.Field(None, description='The maximum frequency at which the AWS Config rule runs evaluations. Default: MaximumExecutionFrequency.TWENTY_FOUR_HOURS\n')
    rule_scope: typing.Optional[models.aws_config.RuleScopeDef] = pydantic.Field(None, description='Defines which resources trigger an evaluation for an AWS Config rule. Default: - evaluations for the rule are triggered when any resource in the recording group changes.')
    _init_params: typing.ClassVar[list[str]] = ['max_age', 'config_rule_name', 'description', 'input_parameters', 'maximum_execution_frequency', 'rule_scope']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'on_compliance_change', 'on_event', 'on_re_evaluation_status']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_config_rule_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.AccessKeysRotated'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_config_rule_name']
    ...


    from_config_rule_name: typing.Optional[models.aws_config.AccessKeysRotatedDefFromConfigRuleNameParams] = pydantic.Field(None, description='Imports an existing rule.')
    resource_config: typing.Optional[models.aws_config.AccessKeysRotatedDefConfig] = pydantic.Field(None)


class AccessKeysRotatedDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    on_compliance_change: typing.Optional[list[models.aws_config.AccessKeysRotatedDefOnComplianceChangeParams]] = pydantic.Field(None, description='Defines an EventBridge event rule which triggers for rule compliance events.')
    on_event: typing.Optional[list[models.aws_config.AccessKeysRotatedDefOnEventParams]] = pydantic.Field(None, description='Defines an EventBridge event rule which triggers for rule events.\nUse\n``rule.addEventPattern(pattern)`` to specify a filter.')
    on_re_evaluation_status: typing.Optional[list[models.aws_config.AccessKeysRotatedDefOnReEvaluationStatusParams]] = pydantic.Field(None, description='Defines an EventBridge event rule which triggers for rule re-evaluation status events.')

class AccessKeysRotatedDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class AccessKeysRotatedDefFromConfigRuleNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    config_rule_name: str = pydantic.Field(..., description='the name of the rule.')
    ...

class AccessKeysRotatedDefOnComplianceChangeParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class AccessKeysRotatedDefOnEventParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class AccessKeysRotatedDefOnReEvaluationStatusParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_config.CloudFormationStackDriftDetectionCheck
class CloudFormationStackDriftDetectionCheckDef(BaseConstruct):
    own_stack_only: typing.Optional[bool] = pydantic.Field(None, description='Whether to check only the stack where this rule is deployed. Default: false\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The IAM role to use for this rule. It must have permissions to detect drift for AWS CloudFormation stacks. Ensure to attach ``config.amazonaws.com`` trusted permissions and ``ReadOnlyAccess`` policy permissions. For specific policy permissions, refer to https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html. Default: - A role will be created\n')
    config_rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the AWS Config rule. Default: - CloudFormation generated name\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description about this AWS Config rule. Default: - No description\n')
    input_parameters: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='Input parameter values that are passed to the AWS Config rule. Default: - No input parameters\n')
    maximum_execution_frequency: typing.Optional[aws_cdk.aws_config.MaximumExecutionFrequency] = pydantic.Field(None, description='The maximum frequency at which the AWS Config rule runs evaluations. Default: MaximumExecutionFrequency.TWENTY_FOUR_HOURS\n')
    rule_scope: typing.Optional[models.aws_config.RuleScopeDef] = pydantic.Field(None, description='Defines which resources trigger an evaluation for an AWS Config rule. Default: - evaluations for the rule are triggered when any resource in the recording group changes.')
    _init_params: typing.ClassVar[list[str]] = ['own_stack_only', 'role', 'config_rule_name', 'description', 'input_parameters', 'maximum_execution_frequency', 'rule_scope']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'on_compliance_change', 'on_event', 'on_re_evaluation_status']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_config_rule_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CloudFormationStackDriftDetectionCheck'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_config_rule_name']
    ...


    from_config_rule_name: typing.Optional[models.aws_config.CloudFormationStackDriftDetectionCheckDefFromConfigRuleNameParams] = pydantic.Field(None, description='Imports an existing rule.')
    resource_config: typing.Optional[models.aws_config.CloudFormationStackDriftDetectionCheckDefConfig] = pydantic.Field(None)


class CloudFormationStackDriftDetectionCheckDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    on_compliance_change: typing.Optional[list[models.aws_config.CloudFormationStackDriftDetectionCheckDefOnComplianceChangeParams]] = pydantic.Field(None, description='Defines an EventBridge event rule which triggers for rule compliance events.')
    on_event: typing.Optional[list[models.aws_config.CloudFormationStackDriftDetectionCheckDefOnEventParams]] = pydantic.Field(None, description='Defines an EventBridge event rule which triggers for rule events.\nUse\n``rule.addEventPattern(pattern)`` to specify a filter.')
    on_re_evaluation_status: typing.Optional[list[models.aws_config.CloudFormationStackDriftDetectionCheckDefOnReEvaluationStatusParams]] = pydantic.Field(None, description='Defines an EventBridge event rule which triggers for rule re-evaluation status events.')

class CloudFormationStackDriftDetectionCheckDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class CloudFormationStackDriftDetectionCheckDefFromConfigRuleNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    config_rule_name: str = pydantic.Field(..., description='the name of the rule.')
    ...

class CloudFormationStackDriftDetectionCheckDefOnComplianceChangeParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class CloudFormationStackDriftDetectionCheckDefOnEventParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class CloudFormationStackDriftDetectionCheckDefOnReEvaluationStatusParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_config.CloudFormationStackNotificationCheck
class CloudFormationStackNotificationCheckDef(BaseConstruct):
    topics: typing.Optional[typing.Sequence[typing.Union[models.aws_sns.TopicBaseDef, models.aws_sns.TopicDef]]] = pydantic.Field(None, description='A list of allowed topics. At most 5 topics. Default: - No topics.\n')
    config_rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the AWS Config rule. Default: - CloudFormation generated name\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description about this AWS Config rule. Default: - No description\n')
    input_parameters: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='Input parameter values that are passed to the AWS Config rule. Default: - No input parameters\n')
    maximum_execution_frequency: typing.Optional[aws_cdk.aws_config.MaximumExecutionFrequency] = pydantic.Field(None, description='The maximum frequency at which the AWS Config rule runs evaluations. Default: MaximumExecutionFrequency.TWENTY_FOUR_HOURS\n')
    rule_scope: typing.Optional[models.aws_config.RuleScopeDef] = pydantic.Field(None, description='Defines which resources trigger an evaluation for an AWS Config rule. Default: - evaluations for the rule are triggered when any resource in the recording group changes.')
    _init_params: typing.ClassVar[list[str]] = ['topics', 'config_rule_name', 'description', 'input_parameters', 'maximum_execution_frequency', 'rule_scope']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'on_compliance_change', 'on_event', 'on_re_evaluation_status']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_config_rule_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CloudFormationStackNotificationCheck'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_config_rule_name']
    ...


    from_config_rule_name: typing.Optional[models.aws_config.CloudFormationStackNotificationCheckDefFromConfigRuleNameParams] = pydantic.Field(None, description='Imports an existing rule.')
    resource_config: typing.Optional[models.aws_config.CloudFormationStackNotificationCheckDefConfig] = pydantic.Field(None)


class CloudFormationStackNotificationCheckDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    on_compliance_change: typing.Optional[list[models.aws_config.CloudFormationStackNotificationCheckDefOnComplianceChangeParams]] = pydantic.Field(None, description='Defines an EventBridge event rule which triggers for rule compliance events.')
    on_event: typing.Optional[list[models.aws_config.CloudFormationStackNotificationCheckDefOnEventParams]] = pydantic.Field(None, description='Defines an EventBridge event rule which triggers for rule events.\nUse\n``rule.addEventPattern(pattern)`` to specify a filter.')
    on_re_evaluation_status: typing.Optional[list[models.aws_config.CloudFormationStackNotificationCheckDefOnReEvaluationStatusParams]] = pydantic.Field(None, description='Defines an EventBridge event rule which triggers for rule re-evaluation status events.')

class CloudFormationStackNotificationCheckDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class CloudFormationStackNotificationCheckDefFromConfigRuleNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    config_rule_name: str = pydantic.Field(..., description='the name of the rule.')
    ...

class CloudFormationStackNotificationCheckDefOnComplianceChangeParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class CloudFormationStackNotificationCheckDefOnEventParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class CloudFormationStackNotificationCheckDefOnReEvaluationStatusParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_config.CustomPolicy
class CustomPolicyDef(BaseConstruct):
    policy_text: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The policy definition containing the logic for your AWS Config Custom Policy rule.\n')
    enable_debug_log: typing.Optional[bool] = pydantic.Field(None, description='The boolean expression for enabling debug logging for your AWS Config Custom Policy rule. Default: false\n')
    config_rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the AWS Config rule. Default: - CloudFormation generated name\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description about this AWS Config rule. Default: - No description\n')
    input_parameters: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='Input parameter values that are passed to the AWS Config rule. Default: - No input parameters\n')
    maximum_execution_frequency: typing.Optional[aws_cdk.aws_config.MaximumExecutionFrequency] = pydantic.Field(None, description='The maximum frequency at which the AWS Config rule runs evaluations. Default: MaximumExecutionFrequency.TWENTY_FOUR_HOURS\n')
    rule_scope: typing.Optional[models.aws_config.RuleScopeDef] = pydantic.Field(None, description='Defines which resources trigger an evaluation for an AWS Config rule. Default: - evaluations for the rule are triggered when any resource in the recording group changes.')
    _init_params: typing.ClassVar[list[str]] = ['policy_text', 'enable_debug_log', 'config_rule_name', 'description', 'input_parameters', 'maximum_execution_frequency', 'rule_scope']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'on_compliance_change', 'on_event', 'on_re_evaluation_status']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_config_rule_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CustomPolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_config_rule_name']
    ...


    from_config_rule_name: typing.Optional[models.aws_config.CustomPolicyDefFromConfigRuleNameParams] = pydantic.Field(None, description='Imports an existing rule.')
    resource_config: typing.Optional[models.aws_config.CustomPolicyDefConfig] = pydantic.Field(None)


class CustomPolicyDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    on_compliance_change: typing.Optional[list[models.aws_config.CustomPolicyDefOnComplianceChangeParams]] = pydantic.Field(None, description='Defines an EventBridge event rule which triggers for rule compliance events.')
    on_event: typing.Optional[list[models.aws_config.CustomPolicyDefOnEventParams]] = pydantic.Field(None, description='Defines an EventBridge event rule which triggers for rule events.\nUse\n``rule.addEventPattern(pattern)`` to specify a filter.')
    on_re_evaluation_status: typing.Optional[list[models.aws_config.CustomPolicyDefOnReEvaluationStatusParams]] = pydantic.Field(None, description='Defines an EventBridge event rule which triggers for rule re-evaluation status events.')

class CustomPolicyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class CustomPolicyDefFromConfigRuleNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    config_rule_name: str = pydantic.Field(..., description='the name of the rule.')
    ...

class CustomPolicyDefOnComplianceChangeParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class CustomPolicyDefOnEventParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class CustomPolicyDefOnReEvaluationStatusParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_config.CustomRule
class CustomRuleDef(BaseConstruct):
    lambda_function: typing.Union[_REQUIRED_INIT_PARAM, models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Lambda function to run.\n')
    configuration_changes: typing.Optional[bool] = pydantic.Field(None, description='Whether to run the rule on configuration changes. Default: false\n')
    periodic: typing.Optional[bool] = pydantic.Field(None, description='Whether to run the rule on a fixed frequency. Default: false\n')
    config_rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the AWS Config rule. Default: - CloudFormation generated name\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description about this AWS Config rule. Default: - No description\n')
    input_parameters: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='Input parameter values that are passed to the AWS Config rule. Default: - No input parameters\n')
    maximum_execution_frequency: typing.Optional[aws_cdk.aws_config.MaximumExecutionFrequency] = pydantic.Field(None, description='The maximum frequency at which the AWS Config rule runs evaluations. Default: MaximumExecutionFrequency.TWENTY_FOUR_HOURS\n')
    rule_scope: typing.Optional[models.aws_config.RuleScopeDef] = pydantic.Field(None, description='Defines which resources trigger an evaluation for an AWS Config rule. Default: - evaluations for the rule are triggered when any resource in the recording group changes.')
    _init_params: typing.ClassVar[list[str]] = ['lambda_function', 'configuration_changes', 'periodic', 'config_rule_name', 'description', 'input_parameters', 'maximum_execution_frequency', 'rule_scope']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'on_compliance_change', 'on_event', 'on_re_evaluation_status']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_config_rule_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CustomRule'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_config_rule_name']
    ...


    from_config_rule_name: typing.Optional[models.aws_config.CustomRuleDefFromConfigRuleNameParams] = pydantic.Field(None, description='Imports an existing rule.')
    resource_config: typing.Optional[models.aws_config.CustomRuleDefConfig] = pydantic.Field(None)


class CustomRuleDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    on_compliance_change: typing.Optional[list[models.aws_config.CustomRuleDefOnComplianceChangeParams]] = pydantic.Field(None, description='Defines an EventBridge event rule which triggers for rule compliance events.')
    on_event: typing.Optional[list[models.aws_config.CustomRuleDefOnEventParams]] = pydantic.Field(None, description='Defines an EventBridge event rule which triggers for rule events.\nUse\n``rule.addEventPattern(pattern)`` to specify a filter.')
    on_re_evaluation_status: typing.Optional[list[models.aws_config.CustomRuleDefOnReEvaluationStatusParams]] = pydantic.Field(None, description='Defines an EventBridge event rule which triggers for rule re-evaluation status events.')

class CustomRuleDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class CustomRuleDefFromConfigRuleNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    config_rule_name: str = pydantic.Field(..., description='the name of the rule.')
    ...

class CustomRuleDefOnComplianceChangeParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class CustomRuleDefOnEventParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class CustomRuleDefOnReEvaluationStatusParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_config.ManagedRule
class ManagedRuleDef(BaseConstruct):
    identifier: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the AWS managed rule.\n')
    config_rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the AWS Config rule. Default: - CloudFormation generated name\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description about this AWS Config rule. Default: - No description\n')
    input_parameters: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='Input parameter values that are passed to the AWS Config rule. Default: - No input parameters\n')
    maximum_execution_frequency: typing.Optional[aws_cdk.aws_config.MaximumExecutionFrequency] = pydantic.Field(None, description='The maximum frequency at which the AWS Config rule runs evaluations. Default: MaximumExecutionFrequency.TWENTY_FOUR_HOURS\n')
    rule_scope: typing.Optional[models.aws_config.RuleScopeDef] = pydantic.Field(None, description='Defines which resources trigger an evaluation for an AWS Config rule. Default: - evaluations for the rule are triggered when any resource in the recording group changes.')
    _init_params: typing.ClassVar[list[str]] = ['identifier', 'config_rule_name', 'description', 'input_parameters', 'maximum_execution_frequency', 'rule_scope']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'on_compliance_change', 'on_event', 'on_re_evaluation_status']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_config_rule_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.ManagedRule'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_config_rule_name']
    ...


    from_config_rule_name: typing.Optional[models.aws_config.ManagedRuleDefFromConfigRuleNameParams] = pydantic.Field(None, description='Imports an existing rule.')
    resource_config: typing.Optional[models.aws_config.ManagedRuleDefConfig] = pydantic.Field(None)


class ManagedRuleDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    on_compliance_change: typing.Optional[list[models.aws_config.ManagedRuleDefOnComplianceChangeParams]] = pydantic.Field(None, description='Defines an EventBridge event rule which triggers for rule compliance events.')
    on_event: typing.Optional[list[models.aws_config.ManagedRuleDefOnEventParams]] = pydantic.Field(None, description='Defines an EventBridge event rule which triggers for rule events.\nUse\n``rule.addEventPattern(pattern)`` to specify a filter.')
    on_re_evaluation_status: typing.Optional[list[models.aws_config.ManagedRuleDefOnReEvaluationStatusParams]] = pydantic.Field(None, description='Defines an EventBridge event rule which triggers for rule re-evaluation status events.')

class ManagedRuleDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class ManagedRuleDefFromConfigRuleNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    config_rule_name: str = pydantic.Field(..., description='the name of the rule.')
    ...

class ManagedRuleDefOnComplianceChangeParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class ManagedRuleDefOnEventParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class ManagedRuleDefOnReEvaluationStatusParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_config.AccessKeysRotatedProps
class AccessKeysRotatedPropsDef(BaseStruct):
    config_rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the AWS Config rule. Default: - CloudFormation generated name\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description about this AWS Config rule. Default: - No description\n')
    input_parameters: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='Input parameter values that are passed to the AWS Config rule. Default: - No input parameters\n')
    maximum_execution_frequency: typing.Optional[aws_cdk.aws_config.MaximumExecutionFrequency] = pydantic.Field(None, description='The maximum frequency at which the AWS Config rule runs evaluations. Default: MaximumExecutionFrequency.TWENTY_FOUR_HOURS\n')
    rule_scope: typing.Optional[models.aws_config.RuleScopeDef] = pydantic.Field(None, description='Defines which resources trigger an evaluation for an AWS Config rule. Default: - evaluations for the rule are triggered when any resource in the recording group changes.\n')
    max_age: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum number of days within which the access keys must be rotated. Default: Duration.days(90)\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_config as config\n\n    # input_parameters: Any\n    # rule_scope: config.RuleScope\n\n    access_keys_rotated_props = config.AccessKeysRotatedProps(\n        config_rule_name="configRuleName",\n        description="description",\n        input_parameters={\n            "input_parameters_key": input_parameters\n        },\n        max_age=cdk.Duration.minutes(30),\n        maximum_execution_frequency=config.MaximumExecutionFrequency.ONE_HOUR,\n        rule_scope=rule_scope\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['config_rule_name', 'description', 'input_parameters', 'maximum_execution_frequency', 'rule_scope', 'max_age']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.AccessKeysRotatedProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnConfigRule.ComplianceProperty
class CfnConfigRule_CompliancePropertyDef(BaseStruct):
    type: typing.Optional[str] = pydantic.Field(None, description='Indicates whether an AWS resource or AWS Config rule is compliant. A resource is compliant if it complies with all of the AWS Config rules that evaluate it. A resource is noncompliant if it does not comply with one or more of these rules. A rule is compliant if all of the resources that the rule evaluates comply with it. A rule is noncompliant if any of these resources do not comply. AWS Config returns the ``INSUFFICIENT_DATA`` value when no evaluation results are available for the AWS resource or AWS Config rule. For the ``Compliance`` data type, AWS Config supports only ``COMPLIANT`` , ``NON_COMPLIANT`` , and ``INSUFFICIENT_DATA`` values. AWS Config does not support the ``NOT_APPLICABLE`` value for the ``Compliance`` data type.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configrule-compliance.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    compliance_property = config.CfnConfigRule.ComplianceProperty(\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnConfigRule.ComplianceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnConfigRule.CustomPolicyDetailsProperty
class CfnConfigRule_CustomPolicyDetailsPropertyDef(BaseStruct):
    enable_debug_log_delivery: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='The boolean expression for enabling debug logging for your AWS Config Custom Policy rule. The default value is ``false`` .\n')
    policy_runtime: typing.Optional[str] = pydantic.Field(None, description='The runtime system for your AWS Config Custom Policy rule. Guard is a policy-as-code language that allows you to write policies that are enforced by AWS Config Custom Policy rules. For more information about Guard, see the `Guard GitHub Repository <https://docs.aws.amazon.com/https://github.com/aws-cloudformation/cloudformation-guard>`_ .\n')
    policy_text: typing.Optional[str] = pydantic.Field(None, description='The policy definition containing the logic for your AWS Config Custom Policy rule.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configrule-custompolicydetails.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    custom_policy_details_property = config.CfnConfigRule.CustomPolicyDetailsProperty(\n        enable_debug_log_delivery=False,\n        policy_runtime="policyRuntime",\n        policy_text="policyText"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enable_debug_log_delivery', 'policy_runtime', 'policy_text']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnConfigRule.CustomPolicyDetailsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnConfigRule.EvaluationModeConfigurationProperty
class CfnConfigRule_EvaluationModeConfigurationPropertyDef(BaseStruct):
    mode: typing.Optional[str] = pydantic.Field(None, description='The mode of an evaluation. The valid values are Detective or Proactive.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configrule-evaluationmodeconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    evaluation_mode_configuration_property = config.CfnConfigRule.EvaluationModeConfigurationProperty(\n        mode="mode"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['mode']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnConfigRule.EvaluationModeConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnConfigRule.ScopeProperty
class CfnConfigRule_ScopePropertyDef(BaseStruct):
    compliance_resource_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the only AWS resource that you want to trigger an evaluation for the rule. If you specify a resource ID, you must specify one resource type for ``ComplianceResourceTypes`` .\n')
    compliance_resource_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The resource types of only those AWS resources that you want to trigger an evaluation for the rule. You can only specify one type if you also specify a resource ID for ``ComplianceResourceId`` .\n')
    tag_key: typing.Optional[str] = pydantic.Field(None, description='The tag key that is applied to only those AWS resources that you want to trigger an evaluation for the rule.\n')
    tag_value: typing.Optional[str] = pydantic.Field(None, description='The tag value applied to only those AWS resources that you want to trigger an evaluation for the rule. If you specify a value for ``TagValue`` , you must also specify a value for ``TagKey`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configrule-scope.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    scope_property = config.CfnConfigRule.ScopeProperty(\n        compliance_resource_id="complianceResourceId",\n        compliance_resource_types=["complianceResourceTypes"],\n        tag_key="tagKey",\n        tag_value="tagValue"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['compliance_resource_id', 'compliance_resource_types', 'tag_key', 'tag_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnConfigRule.ScopeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnConfigRule.SourceDetailProperty
class CfnConfigRule_SourceDetailPropertyDef(BaseStruct):
    event_source: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The source of the event, such as an AWS service, that triggers AWS Config to evaluate your AWS resources.\n')
    message_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of notification that triggers AWS Config to run an evaluation for a rule. You can specify the following notification types: - ``ConfigurationItemChangeNotification`` - Triggers an evaluation when AWS Config delivers a configuration item as a result of a resource change. - ``OversizedConfigurationItemChangeNotification`` - Triggers an evaluation when AWS Config delivers an oversized configuration item. AWS Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS. - ``ScheduledNotification`` - Triggers a periodic evaluation at the frequency specified for ``MaximumExecutionFrequency`` . - ``ConfigurationSnapshotDeliveryCompleted`` - Triggers a periodic evaluation when AWS Config delivers a configuration snapshot. If you want your custom rule to be triggered by configuration changes, specify two SourceDetail objects, one for ``ConfigurationItemChangeNotification`` and one for ``OversizedConfigurationItemChangeNotification`` .\n')
    maximum_execution_frequency: typing.Optional[str] = pydantic.Field(None, description='The frequency at which you want AWS Config to run evaluations for a custom rule with a periodic trigger. If you specify a value for ``MaximumExecutionFrequency`` , then ``MessageType`` must use the ``ScheduledNotification`` value. .. epigraph:: By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the ``MaximumExecutionFrequency`` parameter. Based on the valid value you choose, AWS Config runs evaluations once for each valid value. For example, if you choose ``Three_Hours`` , AWS Config runs evaluations once every three hours. In this case, ``Three_Hours`` is the frequency of this rule.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configrule-sourcedetail.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    source_detail_property = config.CfnConfigRule.SourceDetailProperty(\n        event_source="eventSource",\n        message_type="messageType",\n\n        # the properties below are optional\n        maximum_execution_frequency="maximumExecutionFrequency"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['event_source', 'message_type', 'maximum_execution_frequency']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnConfigRule.SourceDetailProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnConfigRule.SourceProperty
class CfnConfigRule_SourcePropertyDef(BaseStruct):
    owner: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Indicates whether AWS or the customer owns and manages the AWS Config rule. AWS Config Managed Rules are predefined rules owned by AWS . For more information, see `AWS Config Managed Rules <https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html>`_ in the *AWS Config developer guide* . AWS Config Custom Rules are rules that you can develop either with Guard ( ``CUSTOM_POLICY`` ) or AWS Lambda ( ``CUSTOM_LAMBDA`` ). For more information, see `AWS Config Custom Rules <https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_develop-rules.html>`_ in the *AWS Config developer guide* .\n')
    custom_policy_details: typing.Union[models.UnsupportedResource, models.aws_config.CfnConfigRule_CustomPolicyDetailsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Provides the runtime system, policy definition, and whether debug logging is enabled. Required when owner is set to ``CUSTOM_POLICY`` .\n')
    source_details: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_config.CfnConfigRule_SourceDetailPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Provides the source and the message types that cause AWS Config to evaluate your AWS resources against a rule. It also provides the frequency with which you want AWS Config to run evaluations for the rule if the trigger type is periodic. If the owner is set to ``CUSTOM_POLICY`` , the only acceptable values for the AWS Config rule trigger message type are ``ConfigurationItemChangeNotification`` and ``OversizedConfigurationItemChangeNotification`` .\n')
    source_identifier: typing.Optional[str] = pydantic.Field(None, description='For AWS Config Managed rules, a predefined identifier from a list. For example, ``IAM_PASSWORD_POLICY`` is a managed rule. To reference a managed rule, see `List of AWS Config Managed Rules <https://docs.aws.amazon.com/config/latest/developerguide/managed-rules-by-aws-config.html>`_ . For AWS Config Custom Lambda rules, the identifier is the Amazon Resource Name (ARN) of the rule\'s AWS Lambda function, such as ``arn:aws:lambda:us-east-2:123456789012:function:custom_rule_name`` . For AWS Config Custom Policy rules, this field will be ignored.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configrule-source.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    source_property = config.CfnConfigRule.SourceProperty(\n        owner="owner",\n\n        # the properties below are optional\n        custom_policy_details=config.CfnConfigRule.CustomPolicyDetailsProperty(\n            enable_debug_log_delivery=False,\n            policy_runtime="policyRuntime",\n            policy_text="policyText"\n        ),\n        source_details=[config.CfnConfigRule.SourceDetailProperty(\n            event_source="eventSource",\n            message_type="messageType",\n\n            # the properties below are optional\n            maximum_execution_frequency="maximumExecutionFrequency"\n        )],\n        source_identifier="sourceIdentifier"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['owner', 'custom_policy_details', 'source_details', 'source_identifier']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnConfigRule.SourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnConfigurationAggregator.AccountAggregationSourceProperty
class CfnConfigurationAggregator_AccountAggregationSourcePropertyDef(BaseStruct):
    account_ids: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The 12-digit account ID of the account being aggregated.\n')
    all_aws_regions: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='If true, aggregate existing AWS Config regions and future regions.\n')
    aws_regions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The source regions being aggregated.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationaggregator-accountaggregationsource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    account_aggregation_source_property = config.CfnConfigurationAggregator.AccountAggregationSourceProperty(\n        account_ids=["accountIds"],\n\n        # the properties below are optional\n        all_aws_regions=False,\n        aws_regions=["awsRegions"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account_ids', 'all_aws_regions', 'aws_regions']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnConfigurationAggregator.AccountAggregationSourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnConfigurationAggregator.OrganizationAggregationSourceProperty
class CfnConfigurationAggregator_OrganizationAggregationSourcePropertyDef(BaseStruct):
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='ARN of the IAM role used to retrieve AWS Organizations details associated with the aggregator account.\n')
    all_aws_regions: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='If true, aggregate existing AWS Config regions and future regions.\n')
    aws_regions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The source regions being aggregated.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationaggregator-organizationaggregationsource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    organization_aggregation_source_property = config.CfnConfigurationAggregator.OrganizationAggregationSourceProperty(\n        role_arn="roleArn",\n\n        # the properties below are optional\n        all_aws_regions=False,\n        aws_regions=["awsRegions"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['role_arn', 'all_aws_regions', 'aws_regions']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnConfigurationAggregator.OrganizationAggregationSourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnConfigurationRecorder.ExclusionByResourceTypesProperty
class CfnConfigurationRecorder_ExclusionByResourceTypesPropertyDef(BaseStruct):
    resource_types: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A comma-separated list of resource types to exclude from recording by the configuration recorder.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-exclusionbyresourcetypes.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    exclusion_by_resource_types_property = config.CfnConfigurationRecorder.ExclusionByResourceTypesProperty(\n        resource_types=["resourceTypes"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resource_types']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnConfigurationRecorder.ExclusionByResourceTypesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnConfigurationRecorder.RecordingGroupProperty
class CfnConfigurationRecorder_RecordingGroupPropertyDef(BaseStruct):
    all_supported: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether AWS Config records configuration changes for all supported regionally recorded resource types. If you set this field to ``true`` , when AWS Config adds support for a new regionally recorded resource type, AWS Config starts recording resources of that type automatically. If you set this field to ``true`` , you cannot enumerate specific resource types to record in the ``resourceTypes`` field of `RecordingGroup <https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html>`_ , or to exclude in the ``resourceTypes`` field of `ExclusionByResourceTypes <https://docs.aws.amazon.com/config/latest/APIReference/API_ExclusionByResourceTypes.html>`_ . .. epigraph:: *Region Availability* Check `Resource Coverage by Region Availability <https://docs.aws.amazon.com/config/latest/developerguide/what-is-resource-config-coverage.html>`_ to see if a resource type is supported in the AWS Region where you set up AWS Config .\n')
    exclusion_by_resource_types: typing.Union[models.UnsupportedResource, models.aws_config.CfnConfigurationRecorder_ExclusionByResourceTypesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that specifies how AWS Config excludes resource types from being recorded by the configuration recorder. To use this option, you must set the ``useOnly`` field of `AWS::Config::ConfigurationRecorder RecordingStrategy <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-recordingstrategy.html>`_ to ``EXCLUSION_BY_RESOURCE_TYPES`` .\n')
    include_global_resource_types: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='A legacy field which *only applies to the globally recorded IAM resource types* : IAM users, groups, roles, and customer managed policies. If you select this option, these resource types will be recorded in all enabled AWS Config regions where AWS Config was available before February 2022. This list does not include the following Regions: - Asia Pacific (Hyderabad) - Asia Pacific (Melbourne) - Europe (Spain) - Europe (Zurich) - Israel (Tel Aviv) - Middle East (UAE) .. epigraph:: *Aurora global clusters are automatically globally recorded* The ``AWS::RDS::GlobalCluster`` resource type will be recorded in all supported AWS Config Regions where the configuration recorder is enabled, even if ``includeGlobalResourceTypes`` is not set to ``true`` . ``includeGlobalResourceTypes`` is a legacy field which only applies to IAM users, groups, roles, and customer managed policies. If you do not want to record ``AWS::RDS::GlobalCluster`` in all enabled Regions, use one of the following recording strategies: - *Record all current and future resource types with exclusions* ( ``EXCLUSION_BY_RESOURCE_TYPES`` ), or - *Record specific resource types* ( ``INCLUSION_BY_RESOURCE_TYPES`` ). For more information, see `Selecting Which Resources are Recorded <https://docs.aws.amazon.com/config/latest/developerguide/select-resources.html#select-resources-all>`_ in the *AWS Config developer guide* . > *Required and optional fields* Before you set this field to ``true`` , set the ``allSupported`` field of `AWS::Config::ConfigurationRecorder RecordingGroup <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-recordinggroup.html>`_ to ``true`` . Optionally, you can set the ``useOnly`` field of `AWS::Config::ConfigurationRecorder RecordingStrategy <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-recordingstrategy.html>`_ to ``ALL_SUPPORTED_RESOURCE_TYPES`` . > *Overriding fields* If you set this field to ``false`` but list globally recorded IAM resource types in the ``resourceTypes`` field of `AWS::Config::ConfigurationRecorder RecordingGroup <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-recordinggroup.html>`_ , AWS Config will still record configuration changes for those specified resource types *regardless* of if you set the ``includeGlobalResourceTypes`` field to false. If you do not want to record configuration changes to globally recorded IAM resource types, make sure to not list them in the ``resourceTypes`` field in addition to setting the ``includeGlobalResourceTypes`` field to false.\n')
    recording_strategy: typing.Union[models.UnsupportedResource, models.aws_config.CfnConfigurationRecorder_RecordingStrategyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An object that specifies the recording strategy for the configuration recorder. - If you set the ``useOnly`` field of `AWS::Config::ConfigurationRecorder RecordingStrategy <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-recordingstrategy.html>`_ to ``ALL_SUPPORTED_RESOURCE_TYPES`` , AWS Config records configuration changes for all supported regionally recorded resource types. You also must set the ``allSupported`` field of `AWS::Config::ConfigurationRecorder RecordingGroup <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-recordinggroup.html>`_ to ``true`` . When AWS Config adds support for a new regionally recorded resource, AWS Config automatically starts recording resources of that type. - If you set the ``useOnly`` field of `AWS::Config::ConfigurationRecorder RecordingStrategy <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-recordingstrategy.html>`_ to ``INCLUSION_BY_RESOURCE_TYPES`` , AWS Config records configuration changes for only the resource types you specify in the ``resourceTypes`` field of `AWS::Config::ConfigurationRecorder RecordingGroup <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-recordinggroup.html>`_ . - If you set the ``useOnly`` field of `AWS::Config::ConfigurationRecorder RecordingStrategy <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-recordingstrategy.html>`_ to ``EXCLUSION_BY_RESOURCE_TYPES`` , AWS Config records configuration changes for all supported resource types except the resource types that you specify to exclude from being recorded in the ``resourceTypes`` field of `AWS::Config::ConfigurationRecorder ExclusionByResourceTypes <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-exclusionbyresourcetypes.html>`_ . .. epigraph:: *Required and optional fields* The ``recordingStrategy`` field is optional when you set the ``allSupported`` field of `AWS::Config::ConfigurationRecorder RecordingGroup <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-recordinggroup.html>`_ to ``true`` . The ``recordingStrategy`` field is optional when you list resource types in the ``resourceTypes`` field of `AWS::Config::ConfigurationRecorder RecordingGroup <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-recordinggroup.html>`_ . The ``recordingStrategy`` field is required if you list resource types to exclude from recording in the ``resourceTypes`` field of `AWS::Config::ConfigurationRecorder ExclusionByResourceTypes <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-exclusionbyresourcetypes.html>`_ . > *Overriding fields* If you choose ``EXCLUSION_BY_RESOURCE_TYPES`` for the recording strategy, the ``exclusionByResourceTypes`` field will override other properties in the request. For example, even if you set ``includeGlobalResourceTypes`` to false, global resource types will still be automatically recorded in this option unless those resource types are specifically listed as exclusions in the ``resourceTypes`` field of ``exclusionByResourceTypes`` . > *Global resource types and the exclusion recording strategy* By default, if you choose the ``EXCLUSION_BY_RESOURCE_TYPES`` recording strategy, when AWS Config adds support for a new resource type in the Region where you set up the configuration recorder, including global resource types, AWS Config starts recording resources of that type automatically. In addition, unless specifically listed as exclusions, ``AWS::RDS::GlobalCluster`` will be recorded automatically in all supported AWS Config Regions were the configuration recorder is enabled. IAM users, groups, roles, and customer managed policies will be recorded automatically in all enabled AWS Config Regions where AWS Config was available before February 2022. This list does not include the following Regions: - Asia Pacific (Hyderabad) - Asia Pacific (Melbourne) - Europe (Spain) - Europe (Zurich) - Israel (Tel Aviv) - Middle East (UAE)\n')
    resource_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A comma-separated list that specifies which resource types AWS Config records. Optionally, you can set the ``useOnly`` field of `AWS::Config::ConfigurationRecorder RecordingStrategy <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-recordingstrategy.html>`_ to ``INCLUSION_BY_RESOURCE_TYPES`` . To record all configuration changes, set the ``allSupported`` field of `AWS::Config::ConfigurationRecorder RecordingGroup <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-recordinggroup.html>`_ to ``true`` , and either omit this field or don\'t specify any resource types in this field. If you set the ``allSupported`` field to ``false`` and specify values for ``resourceTypes`` , when AWS Config adds support for a new type of resource, it will not record resources of that type unless you manually add that type to your recording group. For a list of valid ``resourceTypes`` values, see the *Resource Type Value* column in `Supported AWS resource Types <https://docs.aws.amazon.com/config/latest/developerguide/resource-config-reference.html#supported-resources>`_ in the *AWS Config developer guide* . .. epigraph:: *Region Availability* Before specifying a resource type for AWS Config to track, check `Resource Coverage by Region Availability <https://docs.aws.amazon.com/config/latest/developerguide/what-is-resource-config-coverage.html>`_ to see if the resource type is supported in the AWS Region where you set up AWS Config . If a resource type is supported by AWS Config in at least one Region, you can enable the recording of that resource type in all Regions supported by AWS Config , even if the specified resource type is not supported in the AWS Region where you set up AWS Config .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-recordinggroup.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    recording_group_property = config.CfnConfigurationRecorder.RecordingGroupProperty(\n        all_supported=False,\n        exclusion_by_resource_types=config.CfnConfigurationRecorder.ExclusionByResourceTypesProperty(\n            resource_types=["resourceTypes"]\n        ),\n        include_global_resource_types=False,\n        recording_strategy=config.CfnConfigurationRecorder.RecordingStrategyProperty(\n            use_only="useOnly"\n        ),\n        resource_types=["resourceTypes"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['all_supported', 'exclusion_by_resource_types', 'include_global_resource_types', 'recording_strategy', 'resource_types']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnConfigurationRecorder.RecordingGroupProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnConfigurationRecorder.RecordingStrategyProperty
class CfnConfigurationRecorder_RecordingStrategyPropertyDef(BaseStruct):
    use_only: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The recording strategy for the configuration recorder. - If you set this option to ``ALL_SUPPORTED_RESOURCE_TYPES`` , AWS Config records configuration changes for all supported regionally recorded resource types. You also must set the ``allSupported`` field of `AWS::Config::ConfigurationRecorder RecordingGroup <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-recordinggroup.html>`_ to ``true`` . When AWS Config adds support for a new regionally recorded resource, AWS Config automatically starts recording resources of that type. For a list of supported resource types, see `Supported Resource Types <https://docs.aws.amazon.com/config/latest/developerguide/resource-config-reference.html#supported-resources>`_ in the *AWS Config developer guide* . - If you set this option to ``INCLUSION_BY_RESOURCE_TYPES`` , AWS Config records configuration changes for only the resource types that you specify in the ``resourceTypes`` field of [AWS::Config::ConfigurationRecorder RecordingGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-conew type of regional resourcenfigurationrecorder-recordinggroup.html) . - If you set this option to ``EXCLUSION_BY_RESOURCE_TYPES`` , AWS Config records configuration changes for all supported resource types, except the resource types that you specify to exclude from being recorded in the ``resourceTypes`` field of `AWS::Config::ConfigurationRecorder ExclusionByResourceTypes <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-exclusionbyresourcetypes.html>`_ . .. epigraph:: *Required and optional fields* The ``recordingStrategy`` field is optional when you set the ``allSupported`` field of `AWS::Config::ConfigurationRecorder RecordingGroup <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-recordinggroup.html>`_ to ``true`` . The ``recordingStrategy`` field is optional when you list resource types in the ``resourceTypes`` field of `AWS::Config::ConfigurationRecorder RecordingGroup <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-recordinggroup.html>`_ . The ``recordingStrategy`` field is required if you list resource types to exclude from recording in the ``resourceTypes`` field of `AWS::Config::ConfigurationRecorder ExclusionByResourceTypes <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-exclusionbyresourcetypes.html>`_ . > *Overriding fields* If you choose ``EXCLUSION_BY_RESOURCE_TYPES`` for the recording strategy, the ``exclusionByResourceTypes`` field will override other properties in the request. For example, even if you set ``includeGlobalResourceTypes`` to false, global resource types will still be automatically recorded in this option unless those resource types are specifically listed as exclusions in the ``resourceTypes`` field of ``exclusionByResourceTypes`` . > *Global resource types and the exclusion recording strategy* By default, if you choose the ``EXCLUSION_BY_RESOURCE_TYPES`` recording strategy, when AWS Config adds support for a new resource type in the Region where you set up the configuration recorder, including global resource types, AWS Config starts recording resources of that type automatically. In addition, unless specifically listed as exclusions, ``AWS::RDS::GlobalCluster`` will be recorded automatically in all supported AWS Config Regions were the configuration recorder is enabled. IAM users, groups, roles, and customer managed policies will be recorded automatically in all enabled AWS Config Regions where AWS Config was available before February 2022. This list does not include the following Regions: - Asia Pacific (Hyderabad) - Asia Pacific (Melbourne) - Europe (Spain) - Europe (Zurich) - Israel (Tel Aviv) - Middle East (UAE)\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-configurationrecorder-recordingstrategy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    recording_strategy_property = config.CfnConfigurationRecorder.RecordingStrategyProperty(\n        use_only="useOnly"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['use_only']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnConfigurationRecorder.RecordingStrategyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnConformancePack.ConformancePackInputParameterProperty
class CfnConformancePack_ConformancePackInputParameterPropertyDef(BaseStruct):
    parameter_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='One part of a key-value pair.\n')
    parameter_value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Another part of the key-value pair.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-conformancepack-conformancepackinputparameter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    conformance_pack_input_parameter_property = config.CfnConformancePack.ConformancePackInputParameterProperty(\n        parameter_name="parameterName",\n        parameter_value="parameterValue"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['parameter_name', 'parameter_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnConformancePack.ConformancePackInputParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnConformancePack.TemplateSSMDocumentDetailsProperty
class CfnConformancePack_TemplateSSMDocumentDetailsPropertyDef(BaseStruct):
    document_name: typing.Optional[str] = pydantic.Field(None, description='The name or Amazon Resource Name (ARN) of the SSM document to use to create a conformance pack. If you use the document name, AWS Config checks only your account and AWS Region for the SSM document. If you want to use an SSM document from another Region or account, you must provide the ARN.\n')
    document_version: typing.Optional[str] = pydantic.Field(None, description='The version of the SSM document to use to create a conformance pack. By default, AWS Config uses the latest version. .. epigraph:: This field is optional.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-conformancepack-templatessmdocumentdetails.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    template_sSMDocument_details_property = config.CfnConformancePack.TemplateSSMDocumentDetailsProperty(\n        document_name="documentName",\n        document_version="documentVersion"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['document_name', 'document_version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnConformancePack.TemplateSSMDocumentDetailsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnDeliveryChannel.ConfigSnapshotDeliveryPropertiesProperty
class CfnDeliveryChannel_ConfigSnapshotDeliveryPropertiesPropertyDef(BaseStruct):
    delivery_frequency: typing.Optional[str] = pydantic.Field(None, description='The frequency with which AWS Config delivers configuration snapshots.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-deliverychannel-configsnapshotdeliveryproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    config_snapshot_delivery_properties_property = config.CfnDeliveryChannel.ConfigSnapshotDeliveryPropertiesProperty(\n        delivery_frequency="deliveryFrequency"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['delivery_frequency']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnDeliveryChannel.ConfigSnapshotDeliveryPropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnOrganizationConfigRule.OrganizationCustomPolicyRuleMetadataProperty
class CfnOrganizationConfigRule_OrganizationCustomPolicyRuleMetadataPropertyDef(BaseStruct):
    policy_text: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The policy definition containing the logic for your organization AWS Config Custom Policy rule.\n')
    runtime: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The runtime system for your organization AWS Config Custom Policy rules. Guard is a policy-as-code language that allows you to write policies that are enforced by AWS Config Custom Policy rules. For more information about Guard, see the `Guard GitHub Repository <https://docs.aws.amazon.com/https://github.com/aws-cloudformation/cloudformation-guard>`_ .\n')
    debug_log_delivery_accounts: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of accounts that you can enable debug logging for your organization AWS Config Custom Policy rule. List is null when debug logging is enabled for all accounts.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description that you provide for your organization AWS Config Custom Policy rule.\n')
    input_parameters: typing.Optional[str] = pydantic.Field(None, description='A string, in JSON format, that is passed to your organization AWS Config Custom Policy rule.\n')
    maximum_execution_frequency: typing.Optional[str] = pydantic.Field(None, description='The maximum frequency with which AWS Config runs evaluations for a rule. Your AWS Config Custom Policy rule is triggered when AWS Config delivers the configuration snapshot. For more information, see ``ConfigSnapshotDeliveryProperties`` .\n')
    organization_config_rule_trigger_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The type of notification that initiates AWS Config to run an evaluation for a rule. For AWS Config Custom Policy rules, AWS Config supports change-initiated notification types: - ``ConfigurationItemChangeNotification`` - Initiates an evaluation when AWS Config delivers a configuration item as a result of a resource change. - ``OversizedConfigurationItemChangeNotification`` - Initiates an evaluation when AWS Config delivers an oversized configuration item. AWS Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.\n')
    resource_id_scope: typing.Optional[str] = pydantic.Field(None, description='The ID of the AWS resource that was evaluated.\n')
    resource_types_scope: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The type of the AWS resource that was evaluated.\n')
    tag_key_scope: typing.Optional[str] = pydantic.Field(None, description='One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.\n')
    tag_value_scope: typing.Optional[str] = pydantic.Field(None, description='The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-organizationconfigrule-organizationcustompolicyrulemetadata.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    organization_custom_policy_rule_metadata_property = config.CfnOrganizationConfigRule.OrganizationCustomPolicyRuleMetadataProperty(\n        policy_text="policyText",\n        runtime="runtime",\n\n        # the properties below are optional\n        debug_log_delivery_accounts=["debugLogDeliveryAccounts"],\n        description="description",\n        input_parameters="inputParameters",\n        maximum_execution_frequency="maximumExecutionFrequency",\n        organization_config_rule_trigger_types=["organizationConfigRuleTriggerTypes"],\n        resource_id_scope="resourceIdScope",\n        resource_types_scope=["resourceTypesScope"],\n        tag_key_scope="tagKeyScope",\n        tag_value_scope="tagValueScope"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['policy_text', 'runtime', 'debug_log_delivery_accounts', 'description', 'input_parameters', 'maximum_execution_frequency', 'organization_config_rule_trigger_types', 'resource_id_scope', 'resource_types_scope', 'tag_key_scope', 'tag_value_scope']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnOrganizationConfigRule.OrganizationCustomPolicyRuleMetadataProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnOrganizationConfigRule.OrganizationCustomRuleMetadataProperty
class CfnOrganizationConfigRule_OrganizationCustomRuleMetadataPropertyDef(BaseStruct):
    lambda_function_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The lambda function ARN.\n')
    organization_config_rule_trigger_types: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of notification that triggers AWS Config to run an evaluation for a rule. You can specify the following notification types: - ``ConfigurationItemChangeNotification`` - Triggers an evaluation when AWS Config delivers a configuration item as a result of a resource change. - ``OversizedConfigurationItemChangeNotification`` - Triggers an evaluation when AWS Config delivers an oversized configuration item. AWS Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS. - ``ScheduledNotification`` - Triggers a periodic evaluation at the frequency specified for ``MaximumExecutionFrequency`` .\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description that you provide for your organization AWS Config rule.\n')
    input_parameters: typing.Optional[str] = pydantic.Field(None, description='A string, in JSON format, that is passed to your organization AWS Config rule Lambda function.\n')
    maximum_execution_frequency: typing.Optional[str] = pydantic.Field(None, description='The maximum frequency with which AWS Config runs evaluations for a rule. Your custom rule is triggered when AWS Config delivers the configuration snapshot. For more information, see ``ConfigSnapshotDeliveryProperties`` . .. epigraph:: By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the ``MaximumExecutionFrequency`` parameter.\n')
    resource_id_scope: typing.Optional[str] = pydantic.Field(None, description='The ID of the AWS resource that was evaluated.\n')
    resource_types_scope: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The type of the AWS resource that was evaluated.\n')
    tag_key_scope: typing.Optional[str] = pydantic.Field(None, description='One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.\n')
    tag_value_scope: typing.Optional[str] = pydantic.Field(None, description='The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-organizationconfigrule-organizationcustomrulemetadata.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    organization_custom_rule_metadata_property = config.CfnOrganizationConfigRule.OrganizationCustomRuleMetadataProperty(\n        lambda_function_arn="lambdaFunctionArn",\n        organization_config_rule_trigger_types=["organizationConfigRuleTriggerTypes"],\n\n        # the properties below are optional\n        description="description",\n        input_parameters="inputParameters",\n        maximum_execution_frequency="maximumExecutionFrequency",\n        resource_id_scope="resourceIdScope",\n        resource_types_scope=["resourceTypesScope"],\n        tag_key_scope="tagKeyScope",\n        tag_value_scope="tagValueScope"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['lambda_function_arn', 'organization_config_rule_trigger_types', 'description', 'input_parameters', 'maximum_execution_frequency', 'resource_id_scope', 'resource_types_scope', 'tag_key_scope', 'tag_value_scope']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnOrganizationConfigRule.OrganizationCustomRuleMetadataProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnOrganizationConfigRule.OrganizationManagedRuleMetadataProperty
class CfnOrganizationConfigRule_OrganizationManagedRuleMetadataPropertyDef(BaseStruct):
    rule_identifier: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='For organization config managed rules, a predefined identifier from a list. For example, ``IAM_PASSWORD_POLICY`` is a managed rule. To reference a managed rule, see `Using AWS Config managed rules <https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html>`_ .\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description that you provide for your organization AWS Config rule.\n')
    input_parameters: typing.Optional[str] = pydantic.Field(None, description='A string, in JSON format, that is passed to your organization AWS Config rule Lambda function.\n')
    maximum_execution_frequency: typing.Optional[str] = pydantic.Field(None, description='The maximum frequency with which AWS Config runs evaluations for a rule. This is for an AWS Config managed rule that is triggered at a periodic frequency. .. epigraph:: By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the ``MaximumExecutionFrequency`` parameter.\n')
    resource_id_scope: typing.Optional[str] = pydantic.Field(None, description='The ID of the AWS resource that was evaluated.\n')
    resource_types_scope: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The type of the AWS resource that was evaluated.\n')
    tag_key_scope: typing.Optional[str] = pydantic.Field(None, description='One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.\n')
    tag_value_scope: typing.Optional[str] = pydantic.Field(None, description='The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-organizationconfigrule-organizationmanagedrulemetadata.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    organization_managed_rule_metadata_property = config.CfnOrganizationConfigRule.OrganizationManagedRuleMetadataProperty(\n        rule_identifier="ruleIdentifier",\n\n        # the properties below are optional\n        description="description",\n        input_parameters="inputParameters",\n        maximum_execution_frequency="maximumExecutionFrequency",\n        resource_id_scope="resourceIdScope",\n        resource_types_scope=["resourceTypesScope"],\n        tag_key_scope="tagKeyScope",\n        tag_value_scope="tagValueScope"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['rule_identifier', 'description', 'input_parameters', 'maximum_execution_frequency', 'resource_id_scope', 'resource_types_scope', 'tag_key_scope', 'tag_value_scope']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnOrganizationConfigRule.OrganizationManagedRuleMetadataProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnOrganizationConformancePack.ConformancePackInputParameterProperty
class CfnOrganizationConformancePack_ConformancePackInputParameterPropertyDef(BaseStruct):
    parameter_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='One part of a key-value pair.\n')
    parameter_value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='One part of a key-value pair.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-organizationconformancepack-conformancepackinputparameter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    conformance_pack_input_parameter_property = config.CfnOrganizationConformancePack.ConformancePackInputParameterProperty(\n        parameter_name="parameterName",\n        parameter_value="parameterValue"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['parameter_name', 'parameter_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnOrganizationConformancePack.ConformancePackInputParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnRemediationConfiguration.ExecutionControlsProperty
class CfnRemediationConfiguration_ExecutionControlsPropertyDef(BaseStruct):
    ssm_controls: typing.Union[models.UnsupportedResource, models.aws_config.CfnRemediationConfiguration_SsmControlsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A SsmControls object.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-remediationconfiguration-executioncontrols.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    execution_controls_property = config.CfnRemediationConfiguration.ExecutionControlsProperty(\n        ssm_controls=config.CfnRemediationConfiguration.SsmControlsProperty(\n            concurrent_execution_rate_percentage=123,\n            error_percentage=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ssm_controls']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnRemediationConfiguration.ExecutionControlsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnRemediationConfiguration.RemediationParameterValueProperty
class CfnRemediationConfiguration_RemediationParameterValuePropertyDef(BaseStruct):
    resource_value: typing.Union[models.UnsupportedResource, models.aws_config.CfnRemediationConfiguration_ResourceValuePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The value is dynamic and changes at run-time.\n')
    static_value: typing.Union[models.UnsupportedResource, models.aws_config.CfnRemediationConfiguration_StaticValuePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The value is static and does not change at run-time.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-remediationconfiguration-remediationparametervalue.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    remediation_parameter_value_property = config.CfnRemediationConfiguration.RemediationParameterValueProperty(\n        resource_value=config.CfnRemediationConfiguration.ResourceValueProperty(\n            value="value"\n        ),\n        static_value=config.CfnRemediationConfiguration.StaticValueProperty(\n            value=["value"],\n            values=["values"]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resource_value', 'static_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnRemediationConfiguration.RemediationParameterValueProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnRemediationConfiguration.ResourceValueProperty
class CfnRemediationConfiguration_ResourceValuePropertyDef(BaseStruct):
    value: typing.Optional[str] = pydantic.Field(None, description='')
    _init_params: typing.ClassVar[list[str]] = ['value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnRemediationConfiguration.ResourceValueProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnRemediationConfiguration.SsmControlsProperty
class CfnRemediationConfiguration_SsmControlsPropertyDef(BaseStruct):
    concurrent_execution_rate_percentage: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum percentage of remediation actions allowed to run in parallel on the non-compliant resources for that specific rule. You can specify a percentage, such as 10%. The default value is 10.\n')
    error_percentage: typing.Union[int, float, None] = pydantic.Field(None, description='The percentage of errors that are allowed before SSM stops running automations on non-compliant resources for that specific rule. You can specify a percentage of errors, for example 10%. If you do not specifiy a percentage, the default is 50%. For example, if you set the ErrorPercentage to 40% for 10 non-compliant resources, then SSM stops running the automations when the fifth error is received.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-config-remediationconfiguration-ssmcontrols.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    ssm_controls_property = config.CfnRemediationConfiguration.SsmControlsProperty(\n        concurrent_execution_rate_percentage=123,\n        error_percentage=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['concurrent_execution_rate_percentage', 'error_percentage']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnRemediationConfiguration.SsmControlsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnRemediationConfiguration.StaticValueProperty
class CfnRemediationConfiguration_StaticValuePropertyDef(BaseStruct):
    value: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    _init_params: typing.ClassVar[list[str]] = ['value', 'values']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnRemediationConfiguration.StaticValueProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CloudFormationStackDriftDetectionCheckProps
class CloudFormationStackDriftDetectionCheckPropsDef(BaseStruct):
    config_rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the AWS Config rule. Default: - CloudFormation generated name\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description about this AWS Config rule. Default: - No description\n')
    input_parameters: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='Input parameter values that are passed to the AWS Config rule. Default: - No input parameters\n')
    maximum_execution_frequency: typing.Optional[aws_cdk.aws_config.MaximumExecutionFrequency] = pydantic.Field(None, description='The maximum frequency at which the AWS Config rule runs evaluations. Default: MaximumExecutionFrequency.TWENTY_FOUR_HOURS\n')
    rule_scope: typing.Optional[models.aws_config.RuleScopeDef] = pydantic.Field(None, description='Defines which resources trigger an evaluation for an AWS Config rule. Default: - evaluations for the rule are triggered when any resource in the recording group changes.\n')
    own_stack_only: typing.Optional[bool] = pydantic.Field(None, description='Whether to check only the stack where this rule is deployed. Default: false\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The IAM role to use for this rule. It must have permissions to detect drift for AWS CloudFormation stacks. Ensure to attach ``config.amazonaws.com`` trusted permissions and ``ReadOnlyAccess`` policy permissions. For specific policy permissions, refer to https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html. Default: - A role will be created\n\n:exampleMetadata: infused\n\nExample::\n\n    # compliant if stack\'s status is \'IN_SYNC\'\n    # non-compliant if the stack\'s drift status is \'DRIFTED\'\n    config.CloudFormationStackDriftDetectionCheck(self, "Drift",\n        own_stack_only=True\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['config_rule_name', 'description', 'input_parameters', 'maximum_execution_frequency', 'rule_scope', 'own_stack_only', 'role']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CloudFormationStackDriftDetectionCheckProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CloudFormationStackNotificationCheckProps
class CloudFormationStackNotificationCheckPropsDef(BaseStruct):
    config_rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the AWS Config rule. Default: - CloudFormation generated name\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description about this AWS Config rule. Default: - No description\n')
    input_parameters: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='Input parameter values that are passed to the AWS Config rule. Default: - No input parameters\n')
    maximum_execution_frequency: typing.Optional[aws_cdk.aws_config.MaximumExecutionFrequency] = pydantic.Field(None, description='The maximum frequency at which the AWS Config rule runs evaluations. Default: MaximumExecutionFrequency.TWENTY_FOUR_HOURS\n')
    rule_scope: typing.Optional[models.aws_config.RuleScopeDef] = pydantic.Field(None, description='Defines which resources trigger an evaluation for an AWS Config rule. Default: - evaluations for the rule are triggered when any resource in the recording group changes.\n')
    topics: typing.Optional[typing.Sequence[typing.Union[models.aws_sns.TopicBaseDef, models.aws_sns.TopicDef]]] = pydantic.Field(None, description='A list of allowed topics. At most 5 topics. Default: - No topics.\n\n:exampleMetadata: infused\n\nExample::\n\n    # topics to which CloudFormation stacks may send event notifications\n    topic1 = sns.Topic(self, "AllowedTopic1")\n    topic2 = sns.Topic(self, "AllowedTopic2")\n\n    # non-compliant if CloudFormation stack does not send notifications to \'topic1\' or \'topic2\'\n    config.CloudFormationStackNotificationCheck(self, "NotificationCheck",\n        topics=[topic1, topic2]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['config_rule_name', 'description', 'input_parameters', 'maximum_execution_frequency', 'rule_scope', 'topics']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CloudFormationStackNotificationCheckProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CustomPolicyProps
class CustomPolicyPropsDef(BaseStruct):
    config_rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the AWS Config rule. Default: - CloudFormation generated name\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description about this AWS Config rule. Default: - No description\n')
    input_parameters: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='Input parameter values that are passed to the AWS Config rule. Default: - No input parameters\n')
    maximum_execution_frequency: typing.Optional[aws_cdk.aws_config.MaximumExecutionFrequency] = pydantic.Field(None, description='The maximum frequency at which the AWS Config rule runs evaluations. Default: MaximumExecutionFrequency.TWENTY_FOUR_HOURS\n')
    rule_scope: typing.Optional[models.aws_config.RuleScopeDef] = pydantic.Field(None, description='Defines which resources trigger an evaluation for an AWS Config rule. Default: - evaluations for the rule are triggered when any resource in the recording group changes.\n')
    policy_text: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The policy definition containing the logic for your AWS Config Custom Policy rule.\n')
    enable_debug_log: typing.Optional[bool] = pydantic.Field(None, description='The boolean expression for enabling debug logging for your AWS Config Custom Policy rule. Default: false\n\n:exampleMetadata: infused\n\nExample::\n\n    sample_policy_text = """\n    # This rule checks if point in time recovery (PITR) is enabled on active Amazon DynamoDB tables\n    let status = [\'ACTIVE\']\n\n    rule tableisactive when\n        resourceType == "AWS::DynamoDB::Table" {\n        configuration.tableStatus == %status\n    }\n\n    rule checkcompliance when\n        resourceType == "AWS::DynamoDB::Table"\n        tableisactive {\n            let pitr = supplementaryConfiguration.ContinuousBackupsDescription.pointInTimeRecoveryDescription.pointInTimeRecoveryStatus\n            %pitr == "ENABLED"\n    }\n    """\n\n    config.CustomPolicy(self, "Custom",\n        policy_text=sample_policy_text,\n        enable_debug_log=True,\n        rule_scope=config.RuleScope.from_resources([config.ResourceType.DYNAMODB_TABLE\n        ])\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['config_rule_name', 'description', 'input_parameters', 'maximum_execution_frequency', 'rule_scope', 'policy_text', 'enable_debug_log']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CustomPolicyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CustomRuleProps
class CustomRulePropsDef(BaseStruct):
    config_rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the AWS Config rule. Default: - CloudFormation generated name\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description about this AWS Config rule. Default: - No description\n')
    input_parameters: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='Input parameter values that are passed to the AWS Config rule. Default: - No input parameters\n')
    maximum_execution_frequency: typing.Optional[aws_cdk.aws_config.MaximumExecutionFrequency] = pydantic.Field(None, description='The maximum frequency at which the AWS Config rule runs evaluations. Default: MaximumExecutionFrequency.TWENTY_FOUR_HOURS\n')
    rule_scope: typing.Optional[models.aws_config.RuleScopeDef] = pydantic.Field(None, description='Defines which resources trigger an evaluation for an AWS Config rule. Default: - evaluations for the rule are triggered when any resource in the recording group changes.\n')
    lambda_function: typing.Union[_REQUIRED_INIT_PARAM, models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Lambda function to run.\n')
    configuration_changes: typing.Optional[bool] = pydantic.Field(None, description='Whether to run the rule on configuration changes. Default: false\n')
    periodic: typing.Optional[bool] = pydantic.Field(None, description='Whether to run the rule on a fixed frequency. Default: false\n\n:exampleMetadata: infused\n\nExample::\n\n    # Lambda function containing logic that evaluates compliance with the rule.\n    eval_compliance_fn = lambda_.Function(self, "CustomFunction",\n        code=lambda_.AssetCode.from_inline("exports.handler = (event) => console.log(event);"),\n        handler="index.handler",\n        runtime=lambda_.Runtime.NODEJS_18_X\n    )\n\n    # A custom rule that runs on configuration changes of EC2 instances\n    custom_rule = config.CustomRule(self, "Custom",\n        configuration_changes=True,\n        lambda_function=eval_compliance_fn,\n        rule_scope=config.RuleScope.from_resource(config.ResourceType.EC2_INSTANCE)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['config_rule_name', 'description', 'input_parameters', 'maximum_execution_frequency', 'rule_scope', 'lambda_function', 'configuration_changes', 'periodic']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CustomRuleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_config.CustomRulePropsDefConfig] = pydantic.Field(None)


class CustomRulePropsDefConfig(pydantic.BaseModel):
    lambda_function_config: typing.Optional[models._interface_methods.AwsLambdaIFunctionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_config.ManagedRuleProps
class ManagedRulePropsDef(BaseStruct):
    config_rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the AWS Config rule. Default: - CloudFormation generated name\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description about this AWS Config rule. Default: - No description\n')
    input_parameters: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='Input parameter values that are passed to the AWS Config rule. Default: - No input parameters\n')
    maximum_execution_frequency: typing.Optional[aws_cdk.aws_config.MaximumExecutionFrequency] = pydantic.Field(None, description='The maximum frequency at which the AWS Config rule runs evaluations. Default: MaximumExecutionFrequency.TWENTY_FOUR_HOURS\n')
    rule_scope: typing.Optional[models.aws_config.RuleScopeDef] = pydantic.Field(None, description='Defines which resources trigger an evaluation for an AWS Config rule. Default: - evaluations for the rule are triggered when any resource in the recording group changes.\n')
    identifier: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the AWS managed rule.\n\n:exampleMetadata: infused\n\nExample::\n\n    # https://docs.aws.amazon.com/config/latest/developerguide/access-keys-rotated.html\n    config.ManagedRule(self, "AccessKeysRotated",\n        identifier=config.ManagedRuleIdentifiers.ACCESS_KEYS_ROTATED,\n        input_parameters={\n            "max_access_key_age": 60\n        },\n\n        # default is 24 hours\n        maximum_execution_frequency=config.MaximumExecutionFrequency.TWELVE_HOURS\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['config_rule_name', 'description', 'input_parameters', 'maximum_execution_frequency', 'rule_scope', 'identifier']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.ManagedRuleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.RuleProps
class RulePropsDef(BaseStruct):
    config_rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the AWS Config rule. Default: - CloudFormation generated name\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description about this AWS Config rule. Default: - No description\n')
    input_parameters: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='Input parameter values that are passed to the AWS Config rule. Default: - No input parameters\n')
    maximum_execution_frequency: typing.Optional[aws_cdk.aws_config.MaximumExecutionFrequency] = pydantic.Field(None, description='The maximum frequency at which the AWS Config rule runs evaluations. Default: MaximumExecutionFrequency.TWENTY_FOUR_HOURS\n')
    rule_scope: typing.Optional[models.aws_config.RuleScopeDef] = pydantic.Field(None, description='Defines which resources trigger an evaluation for an AWS Config rule. Default: - evaluations for the rule are triggered when any resource in the recording group changes.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    # input_parameters: Any\n    # rule_scope: config.RuleScope\n\n    rule_props = config.RuleProps(\n        config_rule_name="configRuleName",\n        description="description",\n        input_parameters={\n            "input_parameters_key": input_parameters\n        },\n        maximum_execution_frequency=config.MaximumExecutionFrequency.ONE_HOUR,\n        rule_scope=rule_scope\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['config_rule_name', 'description', 'input_parameters', 'maximum_execution_frequency', 'rule_scope']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.RuleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.MaximumExecutionFrequency
# skipping emum

#  autogenerated from aws_cdk.aws_config.IRule
#  skipping Interface

#  autogenerated from aws_cdk.aws_config.CfnAggregationAuthorization
class CfnAggregationAuthorizationDef(BaseCfnResource):
    authorized_account_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The 12-digit account ID of the account authorized to aggregate data.\n')
    authorized_aws_region: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The region authorized to collect aggregated data.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of tag object.')
    _init_params: typing.ClassVar[list[str]] = ['authorized_account_id', 'authorized_aws_region', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnAggregationAuthorization'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_config.CfnAggregationAuthorizationDefConfig] = pydantic.Field(None)


class CfnAggregationAuthorizationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_config.CfnAggregationAuthorizationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_config.CfnAggregationAuthorizationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_config.CfnAggregationAuthorizationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_config.CfnAggregationAuthorizationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_config.CfnAggregationAuthorizationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_config.CfnAggregationAuthorizationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_config.CfnAggregationAuthorizationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_config.CfnAggregationAuthorizationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_config.CfnAggregationAuthorizationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_config.CfnAggregationAuthorizationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_config.CfnAggregationAuthorizationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_config.CfnAggregationAuthorizationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_config.CfnAggregationAuthorizationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnAggregationAuthorizationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAggregationAuthorizationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAggregationAuthorizationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAggregationAuthorizationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAggregationAuthorizationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAggregationAuthorizationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAggregationAuthorizationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAggregationAuthorizationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAggregationAuthorizationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAggregationAuthorizationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAggregationAuthorizationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnAggregationAuthorizationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAggregationAuthorizationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAggregationAuthorizationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_config.CfnConfigRule
class CfnConfigRuleDef(BaseCfnResource):
    scope_: typing.Union[models.constructs.ConstructDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Scope in which this resource is defined.')
    source: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_config.CfnConfigRule_SourcePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Provides the rule owner ( ``AWS`` for managed rules, ``CUSTOM_POLICY`` for Custom Policy rules, and ``CUSTOM_LAMBDA`` for Custom Lambda rules), the rule identifier, and the notifications that cause the function to evaluate your AWS resources.\n')
    compliance: typing.Union[models.UnsupportedResource, models.aws_config.CfnConfigRule_CompliancePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Indicates whether an AWS resource or AWS Config rule is compliant and provides the number of contributors that affect the compliance.\n')
    config_rule_name: typing.Optional[str] = pydantic.Field(None, description="A name for the AWS Config rule. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the rule name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ .\n")
    description: typing.Optional[str] = pydantic.Field(None, description='The description that you provide for the AWS Config rule.\n')
    evaluation_modes: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_config.CfnConfigRule_EvaluationModeConfigurationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The modes the AWS Config rule can be evaluated in. The valid values are distinct objects. By default, the value is Detective evaluation mode only.\n')
    input_parameters: typing.Any = pydantic.Field(None, description='A string, in JSON format, that is passed to the AWS Config rule Lambda function.\n')
    maximum_execution_frequency: typing.Optional[str] = pydantic.Field(None, description='The maximum frequency with which AWS Config runs evaluations for a rule. You can specify a value for ``MaximumExecutionFrequency`` when: - You are using an AWS managed rule that is triggered at a periodic frequency. - Your custom rule is triggered when AWS Config delivers the configuration snapshot. For more information, see `ConfigSnapshotDeliveryProperties <https://docs.aws.amazon.com/config/latest/APIReference/API_ConfigSnapshotDeliveryProperties.html>`_ . .. epigraph:: By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the ``MaximumExecutionFrequency`` parameter.\n')
    _init_params: typing.ClassVar[list[str]] = ['scope_', 'source', 'compliance', 'config_rule_name', 'description', 'evaluation_modes', 'input_parameters', 'maximum_execution_frequency']
    _method_names: typing.ClassVar[list[str]] = ['ComplianceProperty', 'CustomPolicyDetailsProperty', 'EvaluationModeConfigurationProperty', 'ScopeProperty', 'SourceDetailProperty', 'SourceProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnConfigRule'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_config.CfnConfigRuleDefConfig] = pydantic.Field(None)


class CfnConfigRuleDefConfig(pydantic.BaseModel):
    ComplianceProperty: typing.Optional[list[models.aws_config.CfnConfigRuleDefCompliancepropertyParams]] = pydantic.Field(None, description='')
    CustomPolicyDetailsProperty: typing.Optional[list[models.aws_config.CfnConfigRuleDefCustompolicydetailspropertyParams]] = pydantic.Field(None, description='')
    EvaluationModeConfigurationProperty: typing.Optional[list[models.aws_config.CfnConfigRuleDefEvaluationmodeconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ScopeProperty: typing.Optional[list[models.aws_config.CfnConfigRuleDefScopepropertyParams]] = pydantic.Field(None, description='')
    SourceDetailProperty: typing.Optional[list[models.aws_config.CfnConfigRuleDefSourcedetailpropertyParams]] = pydantic.Field(None, description='')
    SourceProperty: typing.Optional[list[models.aws_config.CfnConfigRuleDefSourcepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_config.CfnConfigRuleDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_config.CfnConfigRuleDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_config.CfnConfigRuleDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_config.CfnConfigRuleDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_config.CfnConfigRuleDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_config.CfnConfigRuleDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_config.CfnConfigRuleDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_config.CfnConfigRuleDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_config.CfnConfigRuleDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_config.CfnConfigRuleDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_config.CfnConfigRuleDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_config.CfnConfigRuleDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_config.CfnConfigRuleDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnConfigRuleDefCompliancepropertyParams(pydantic.BaseModel):
    type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnConfigRuleDefCustompolicydetailspropertyParams(pydantic.BaseModel):
    enable_debug_log_delivery: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    policy_runtime: typing.Optional[str] = pydantic.Field(None, description='')
    policy_text: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnConfigRuleDefEvaluationmodeconfigurationpropertyParams(pydantic.BaseModel):
    mode: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnConfigRuleDefScopepropertyParams(pydantic.BaseModel):
    compliance_resource_id: typing.Optional[str] = pydantic.Field(None, description='')
    compliance_resource_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    tag_key: typing.Optional[str] = pydantic.Field(None, description='')
    tag_value: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnConfigRuleDefSourcedetailpropertyParams(pydantic.BaseModel):
    event_source: str = pydantic.Field(..., description='')
    message_type: str = pydantic.Field(..., description='')
    maximum_execution_frequency: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnConfigRuleDefSourcepropertyParams(pydantic.BaseModel):
    owner: str = pydantic.Field(..., description='')
    custom_policy_details: typing.Union[models.UnsupportedResource, models.aws_config.CfnConfigRule_CustomPolicyDetailsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    source_details: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_config.CfnConfigRule_SourceDetailPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    source_identifier: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnConfigRuleDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnConfigRuleDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConfigRuleDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnConfigRuleDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConfigRuleDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnConfigRuleDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnConfigRuleDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnConfigRuleDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnConfigRuleDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnConfigRuleDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConfigRuleDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnConfigRuleDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnConfigRuleDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConfigRuleDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_config.CfnConfigurationAggregator
class CfnConfigurationAggregatorDef(BaseCfnResource):
    account_aggregation_sources: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_config.CfnConfigurationAggregator_AccountAggregationSourcePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Provides a list of source accounts and regions to be aggregated.\n')
    configuration_aggregator_name: typing.Optional[str] = pydantic.Field(None, description='The name of the aggregator.\n')
    organization_aggregation_source: typing.Union[models.UnsupportedResource, models.aws_config.CfnConfigurationAggregator_OrganizationAggregationSourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Provides an organization and list of regions to be aggregated.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of tag object.')
    _init_params: typing.ClassVar[list[str]] = ['account_aggregation_sources', 'configuration_aggregator_name', 'organization_aggregation_source', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['AccountAggregationSourceProperty', 'OrganizationAggregationSourceProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnConfigurationAggregator'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_config.CfnConfigurationAggregatorDefConfig] = pydantic.Field(None)


class CfnConfigurationAggregatorDefConfig(pydantic.BaseModel):
    AccountAggregationSourceProperty: typing.Optional[list[models.aws_config.CfnConfigurationAggregatorDefAccountaggregationsourcepropertyParams]] = pydantic.Field(None, description='')
    OrganizationAggregationSourceProperty: typing.Optional[list[models.aws_config.CfnConfigurationAggregatorDefOrganizationaggregationsourcepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_config.CfnConfigurationAggregatorDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_config.CfnConfigurationAggregatorDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_config.CfnConfigurationAggregatorDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_config.CfnConfigurationAggregatorDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_config.CfnConfigurationAggregatorDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_config.CfnConfigurationAggregatorDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_config.CfnConfigurationAggregatorDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_config.CfnConfigurationAggregatorDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_config.CfnConfigurationAggregatorDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_config.CfnConfigurationAggregatorDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_config.CfnConfigurationAggregatorDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_config.CfnConfigurationAggregatorDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_config.CfnConfigurationAggregatorDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnConfigurationAggregatorDefAccountaggregationsourcepropertyParams(pydantic.BaseModel):
    account_ids: typing.Sequence[str] = pydantic.Field(..., description='')
    all_aws_regions: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    aws_regions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnConfigurationAggregatorDefOrganizationaggregationsourcepropertyParams(pydantic.BaseModel):
    role_arn: str = pydantic.Field(..., description='')
    all_aws_regions: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    aws_regions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnConfigurationAggregatorDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnConfigurationAggregatorDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConfigurationAggregatorDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnConfigurationAggregatorDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConfigurationAggregatorDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnConfigurationAggregatorDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnConfigurationAggregatorDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnConfigurationAggregatorDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnConfigurationAggregatorDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnConfigurationAggregatorDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConfigurationAggregatorDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnConfigurationAggregatorDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnConfigurationAggregatorDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConfigurationAggregatorDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_config.CfnConfigurationRecorder
class CfnConfigurationRecorderDef(BaseCfnResource):
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Amazon Resource Name (ARN) of the IAM role assumed by AWS Config and used by the configuration recorder. For more information, see `Permissions for the IAM Role Assigned <https://docs.aws.amazon.com/config/latest/developerguide/iamrole-permissions.html>`_ to AWS Config in the AWS Config Developer Guide. .. epigraph:: *Pre-existing AWS Config role* If you have used an AWS service that uses AWS Config , such as AWS Security Hub or AWS Control Tower , and an AWS Config role has already been created, make sure that the IAM role that you use when setting up AWS Config keeps the same minimum permissions as the already created AWS Config role. You must do this so that the other AWS service continues to run as expected. For example, if AWS Control Tower has an IAM role that allows AWS Config to read Amazon Simple Storage Service ( Amazon S3 ) objects, make sure that the same permissions are granted within the IAM role you use when setting up AWS Config . Otherwise, it may interfere with how AWS Control Tower operates. For more information about IAM roles for AWS Config , see `*Identity and Access Management for AWS Config* <https://docs.aws.amazon.com/config/latest/developerguide/security-iam.html>`_ in the *AWS Config Developer Guide* .\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the configuration recorder. AWS Config automatically assigns the name of "default" when creating the configuration recorder. You cannot change the name of the configuration recorder after it has been created. To change the configuration recorder name, you must delete it and create a new configuration recorder with a new name.\n')
    recording_group: typing.Union[models.UnsupportedResource, models.aws_config.CfnConfigurationRecorder_RecordingGroupPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies which resource types AWS Config records for configuration changes. .. epigraph:: *High Number of AWS Config Evaluations* You may notice increased activity in your account during your initial month recording with AWS Config when compared to subsequent months. During the initial bootstrapping process, AWS Config runs evaluations on all the resources in your account that you have selected for AWS Config to record. If you are running ephemeral workloads, you may see increased activity from AWS Config as it records configuration changes associated with creating and deleting these temporary resources. An *ephemeral workload* is a temporary use of computing resources that are loaded and run when needed. Examples include Amazon Elastic Compute Cloud ( Amazon EC2 ) Spot Instances, Amazon EMR jobs, and AWS Auto Scaling . If you want to avoid the increased activity from running ephemeral workloads, you can run these types of workloads in a separate account with AWS Config turned off to avoid increased configuration recording and rule evaluations.')
    _init_params: typing.ClassVar[list[str]] = ['role_arn', 'name', 'recording_group']
    _method_names: typing.ClassVar[list[str]] = ['ExclusionByResourceTypesProperty', 'RecordingGroupProperty', 'RecordingStrategyProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnConfigurationRecorder'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_config.CfnConfigurationRecorderDefConfig] = pydantic.Field(None)


class CfnConfigurationRecorderDefConfig(pydantic.BaseModel):
    ExclusionByResourceTypesProperty: typing.Optional[list[models.aws_config.CfnConfigurationRecorderDefExclusionbyresourcetypespropertyParams]] = pydantic.Field(None, description='')
    RecordingGroupProperty: typing.Optional[list[models.aws_config.CfnConfigurationRecorderDefRecordinggrouppropertyParams]] = pydantic.Field(None, description='')
    RecordingStrategyProperty: typing.Optional[list[models.aws_config.CfnConfigurationRecorderDefRecordingstrategypropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_config.CfnConfigurationRecorderDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_config.CfnConfigurationRecorderDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_config.CfnConfigurationRecorderDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_config.CfnConfigurationRecorderDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_config.CfnConfigurationRecorderDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_config.CfnConfigurationRecorderDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_config.CfnConfigurationRecorderDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_config.CfnConfigurationRecorderDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_config.CfnConfigurationRecorderDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_config.CfnConfigurationRecorderDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_config.CfnConfigurationRecorderDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_config.CfnConfigurationRecorderDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_config.CfnConfigurationRecorderDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnConfigurationRecorderDefExclusionbyresourcetypespropertyParams(pydantic.BaseModel):
    resource_types: typing.Sequence[str] = pydantic.Field(..., description='')
    ...

class CfnConfigurationRecorderDefRecordinggrouppropertyParams(pydantic.BaseModel):
    all_supported: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    exclusion_by_resource_types: typing.Union[models.UnsupportedResource, models.aws_config.CfnConfigurationRecorder_ExclusionByResourceTypesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    include_global_resource_types: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    recording_strategy: typing.Union[models.UnsupportedResource, models.aws_config.CfnConfigurationRecorder_RecordingStrategyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    resource_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnConfigurationRecorderDefRecordingstrategypropertyParams(pydantic.BaseModel):
    use_only: str = pydantic.Field(..., description='')
    ...

class CfnConfigurationRecorderDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnConfigurationRecorderDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConfigurationRecorderDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnConfigurationRecorderDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConfigurationRecorderDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnConfigurationRecorderDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnConfigurationRecorderDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnConfigurationRecorderDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnConfigurationRecorderDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnConfigurationRecorderDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConfigurationRecorderDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnConfigurationRecorderDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnConfigurationRecorderDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConfigurationRecorderDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_config.CfnConformancePack
class CfnConformancePackDef(BaseCfnResource):
    conformance_pack_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Name of the conformance pack you want to create.\n')
    conformance_pack_input_parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_config.CfnConformancePack_ConformancePackInputParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of ConformancePackInputParameter objects.\n')
    delivery_s3_bucket: typing.Optional[str] = pydantic.Field(None, description='The name of the Amazon S3 bucket where AWS Config stores conformance pack templates.\n')
    delivery_s3_key_prefix: typing.Optional[str] = pydantic.Field(None, description='The prefix for the Amazon S3 bucket.\n')
    template_body: typing.Optional[str] = pydantic.Field(None, description='A string containing full conformance pack template body. Structure containing the template body with a minimum length of 1 byte and a maximum length of 51,200 bytes. .. epigraph:: You can only use a YAML template with two resource types: config rule ( ``AWS::Config::ConfigRule`` ) and a remediation action ( ``AWS::Config::RemediationConfiguration`` ).\n')
    template_s3_uri: typing.Optional[str] = pydantic.Field(None, description='Location of file containing the template body (s3://bucketname/prefix). The uri must point to the conformance pack template (max size: 300 KB) that is located in an Amazon S3 bucket. .. epigraph:: You must have access to read Amazon S3 bucket.\n')
    template_ssm_document_details: typing.Any = pydantic.Field(None, description='An object that contains the name or Amazon Resource Name (ARN) of the AWS Systems Manager document (SSM document) and the version of the SSM document that is used to create a conformance pack.')
    _init_params: typing.ClassVar[list[str]] = ['conformance_pack_name', 'conformance_pack_input_parameters', 'delivery_s3_bucket', 'delivery_s3_key_prefix', 'template_body', 'template_s3_uri', 'template_ssm_document_details']
    _method_names: typing.ClassVar[list[str]] = ['ConformancePackInputParameterProperty', 'TemplateSSMDocumentDetailsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnConformancePack'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_config.CfnConformancePackDefConfig] = pydantic.Field(None)


class CfnConformancePackDefConfig(pydantic.BaseModel):
    ConformancePackInputParameterProperty: typing.Optional[list[models.aws_config.CfnConformancePackDefConformancepackinputparameterpropertyParams]] = pydantic.Field(None, description='')
    TemplateSSMDocumentDetailsProperty: typing.Optional[list[models.aws_config.CfnConformancePackDefTemplatessmdocumentdetailspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_config.CfnConformancePackDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_config.CfnConformancePackDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_config.CfnConformancePackDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_config.CfnConformancePackDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_config.CfnConformancePackDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_config.CfnConformancePackDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_config.CfnConformancePackDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_config.CfnConformancePackDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_config.CfnConformancePackDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_config.CfnConformancePackDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_config.CfnConformancePackDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_config.CfnConformancePackDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_config.CfnConformancePackDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnConformancePackDefConformancepackinputparameterpropertyParams(pydantic.BaseModel):
    parameter_name: str = pydantic.Field(..., description='')
    parameter_value: str = pydantic.Field(..., description='')
    ...

class CfnConformancePackDefTemplatessmdocumentdetailspropertyParams(pydantic.BaseModel):
    document_name: typing.Optional[str] = pydantic.Field(None, description='')
    document_version: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnConformancePackDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnConformancePackDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConformancePackDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnConformancePackDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConformancePackDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnConformancePackDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnConformancePackDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnConformancePackDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnConformancePackDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnConformancePackDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConformancePackDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnConformancePackDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnConformancePackDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConformancePackDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_config.CfnDeliveryChannel
class CfnDeliveryChannelDef(BaseCfnResource):
    s3_bucket_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the Amazon S3 bucket to which AWS Config delivers configuration snapshots and configuration history files. If you specify a bucket that belongs to another AWS account , that bucket must have policies that grant access permissions to AWS Config . For more information, see `Permissions for the Amazon S3 Bucket <https://docs.aws.amazon.com/config/latest/developerguide/s3-bucket-policy.html>`_ in the *AWS Config Developer Guide* .\n')
    config_snapshot_delivery_properties: typing.Union[models.UnsupportedResource, models.aws_config.CfnDeliveryChannel_ConfigSnapshotDeliveryPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for how often AWS Config delivers configuration snapshots to the Amazon S3 bucket.\n')
    name: typing.Optional[str] = pydantic.Field(None, description="A name for the delivery channel. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the delivery channel name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ . Updates are not supported. To change the name, you must run two separate updates. In the first update, delete this resource, and then recreate it with a new name in the second update.\n")
    s3_key_prefix: typing.Optional[str] = pydantic.Field(None, description='The prefix for the specified Amazon S3 bucket.\n')
    s3_kms_key_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the AWS Key Management Service ( AWS KMS ) AWS KMS key (KMS key) used to encrypt objects delivered by AWS Config . Must belong to the same Region as the destination S3 bucket.\n')
    sns_topic_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the Amazon SNS topic to which AWS Config sends notifications about configuration changes. If you choose a topic from another account, the topic must have policies that grant access permissions to AWS Config . For more information, see `Permissions for the Amazon SNS Topic <https://docs.aws.amazon.com/config/latest/developerguide/sns-topic-policy.html>`_ in the *AWS Config Developer Guide* .')
    _init_params: typing.ClassVar[list[str]] = ['s3_bucket_name', 'config_snapshot_delivery_properties', 'name', 's3_key_prefix', 's3_kms_key_arn', 'sns_topic_arn']
    _method_names: typing.ClassVar[list[str]] = ['ConfigSnapshotDeliveryPropertiesProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnDeliveryChannel'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_config.CfnDeliveryChannelDefConfig] = pydantic.Field(None)


class CfnDeliveryChannelDefConfig(pydantic.BaseModel):
    ConfigSnapshotDeliveryPropertiesProperty: typing.Optional[list[models.aws_config.CfnDeliveryChannelDefConfigsnapshotdeliverypropertiespropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_config.CfnDeliveryChannelDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_config.CfnDeliveryChannelDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_config.CfnDeliveryChannelDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_config.CfnDeliveryChannelDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_config.CfnDeliveryChannelDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_config.CfnDeliveryChannelDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_config.CfnDeliveryChannelDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_config.CfnDeliveryChannelDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_config.CfnDeliveryChannelDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_config.CfnDeliveryChannelDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_config.CfnDeliveryChannelDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_config.CfnDeliveryChannelDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_config.CfnDeliveryChannelDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnDeliveryChannelDefConfigsnapshotdeliverypropertiespropertyParams(pydantic.BaseModel):
    delivery_frequency: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDeliveryChannelDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDeliveryChannelDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDeliveryChannelDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDeliveryChannelDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDeliveryChannelDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDeliveryChannelDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDeliveryChannelDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDeliveryChannelDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDeliveryChannelDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDeliveryChannelDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDeliveryChannelDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDeliveryChannelDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDeliveryChannelDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDeliveryChannelDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_config.CfnOrganizationConfigRule
class CfnOrganizationConfigRuleDef(BaseCfnResource):
    organization_config_rule_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name that you assign to organization AWS Config rule.\n')
    excluded_accounts: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A comma-separated list of accounts excluded from organization AWS Config rule.\n')
    organization_custom_policy_rule_metadata: typing.Union[models.UnsupportedResource, models.aws_config.CfnOrganizationConfigRule_OrganizationCustomPolicyRuleMetadataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="An object that specifies metadata for your organization's AWS Config Custom Policy rule. The metadata includes the runtime system in use, which accounts have debug logging enabled, and other custom rule metadata, such as resource type, resource ID of AWS resource, and organization trigger types that initiate AWS Config to evaluate AWS resources against a rule.\n")
    organization_custom_rule_metadata: typing.Union[models.UnsupportedResource, models.aws_config.CfnOrganizationConfigRule_OrganizationCustomRuleMetadataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An ``OrganizationCustomRuleMetadata`` object.\n')
    organization_managed_rule_metadata: typing.Union[models.UnsupportedResource, models.aws_config.CfnOrganizationConfigRule_OrganizationManagedRuleMetadataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An ``OrganizationManagedRuleMetadata`` object.')
    _init_params: typing.ClassVar[list[str]] = ['organization_config_rule_name', 'excluded_accounts', 'organization_custom_policy_rule_metadata', 'organization_custom_rule_metadata', 'organization_managed_rule_metadata']
    _method_names: typing.ClassVar[list[str]] = ['OrganizationCustomPolicyRuleMetadataProperty', 'OrganizationCustomRuleMetadataProperty', 'OrganizationManagedRuleMetadataProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnOrganizationConfigRule'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_config.CfnOrganizationConfigRuleDefConfig] = pydantic.Field(None)


class CfnOrganizationConfigRuleDefConfig(pydantic.BaseModel):
    OrganizationCustomPolicyRuleMetadataProperty: typing.Optional[list[models.aws_config.CfnOrganizationConfigRuleDefOrganizationcustompolicyrulemetadatapropertyParams]] = pydantic.Field(None, description='')
    OrganizationCustomRuleMetadataProperty: typing.Optional[list[models.aws_config.CfnOrganizationConfigRuleDefOrganizationcustomrulemetadatapropertyParams]] = pydantic.Field(None, description='')
    OrganizationManagedRuleMetadataProperty: typing.Optional[list[models.aws_config.CfnOrganizationConfigRuleDefOrganizationmanagedrulemetadatapropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_config.CfnOrganizationConfigRuleDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_config.CfnOrganizationConfigRuleDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_config.CfnOrganizationConfigRuleDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_config.CfnOrganizationConfigRuleDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_config.CfnOrganizationConfigRuleDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_config.CfnOrganizationConfigRuleDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_config.CfnOrganizationConfigRuleDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_config.CfnOrganizationConfigRuleDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_config.CfnOrganizationConfigRuleDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_config.CfnOrganizationConfigRuleDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_config.CfnOrganizationConfigRuleDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_config.CfnOrganizationConfigRuleDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_config.CfnOrganizationConfigRuleDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnOrganizationConfigRuleDefOrganizationcustompolicyrulemetadatapropertyParams(pydantic.BaseModel):
    policy_text: str = pydantic.Field(..., description='')
    runtime: str = pydantic.Field(..., description='')
    debug_log_delivery_accounts: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    input_parameters: typing.Optional[str] = pydantic.Field(None, description='')
    maximum_execution_frequency: typing.Optional[str] = pydantic.Field(None, description='')
    organization_config_rule_trigger_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    resource_id_scope: typing.Optional[str] = pydantic.Field(None, description='')
    resource_types_scope: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    tag_key_scope: typing.Optional[str] = pydantic.Field(None, description='')
    tag_value_scope: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnOrganizationConfigRuleDefOrganizationcustomrulemetadatapropertyParams(pydantic.BaseModel):
    lambda_function_arn: str = pydantic.Field(..., description='')
    organization_config_rule_trigger_types: typing.Sequence[str] = pydantic.Field(..., description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    input_parameters: typing.Optional[str] = pydantic.Field(None, description='')
    maximum_execution_frequency: typing.Optional[str] = pydantic.Field(None, description='')
    resource_id_scope: typing.Optional[str] = pydantic.Field(None, description='')
    resource_types_scope: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    tag_key_scope: typing.Optional[str] = pydantic.Field(None, description='')
    tag_value_scope: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnOrganizationConfigRuleDefOrganizationmanagedrulemetadatapropertyParams(pydantic.BaseModel):
    rule_identifier: str = pydantic.Field(..., description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    input_parameters: typing.Optional[str] = pydantic.Field(None, description='')
    maximum_execution_frequency: typing.Optional[str] = pydantic.Field(None, description='')
    resource_id_scope: typing.Optional[str] = pydantic.Field(None, description='')
    resource_types_scope: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    tag_key_scope: typing.Optional[str] = pydantic.Field(None, description='')
    tag_value_scope: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnOrganizationConfigRuleDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnOrganizationConfigRuleDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnOrganizationConfigRuleDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnOrganizationConfigRuleDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnOrganizationConfigRuleDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnOrganizationConfigRuleDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnOrganizationConfigRuleDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnOrganizationConfigRuleDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnOrganizationConfigRuleDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnOrganizationConfigRuleDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnOrganizationConfigRuleDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnOrganizationConfigRuleDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnOrganizationConfigRuleDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnOrganizationConfigRuleDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_config.CfnOrganizationConformancePack
class CfnOrganizationConformancePackDef(BaseCfnResource):
    organization_conformance_pack_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name you assign to an organization conformance pack.\n')
    conformance_pack_input_parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_config.CfnOrganizationConformancePack_ConformancePackInputParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of ``ConformancePackInputParameter`` objects.\n')
    delivery_s3_bucket: typing.Optional[str] = pydantic.Field(None, description='The name of the Amazon S3 bucket where AWS Config stores conformance pack templates. .. epigraph:: This field is optional.\n')
    delivery_s3_key_prefix: typing.Optional[str] = pydantic.Field(None, description='Any folder structure you want to add to an Amazon S3 bucket. .. epigraph:: This field is optional.\n')
    excluded_accounts: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A comma-separated list of accounts excluded from organization conformance pack.\n')
    template_body: typing.Optional[str] = pydantic.Field(None, description='A string containing full conformance pack template body. Structure containing the template body with a minimum length of 1 byte and a maximum length of 51,200 bytes.\n')
    template_s3_uri: typing.Optional[str] = pydantic.Field(None, description='Location of file containing the template body. The uri must point to the conformance pack template (max size: 300 KB).')
    _init_params: typing.ClassVar[list[str]] = ['organization_conformance_pack_name', 'conformance_pack_input_parameters', 'delivery_s3_bucket', 'delivery_s3_key_prefix', 'excluded_accounts', 'template_body', 'template_s3_uri']
    _method_names: typing.ClassVar[list[str]] = ['ConformancePackInputParameterProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnOrganizationConformancePack'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_config.CfnOrganizationConformancePackDefConfig] = pydantic.Field(None)


class CfnOrganizationConformancePackDefConfig(pydantic.BaseModel):
    ConformancePackInputParameterProperty: typing.Optional[list[models.aws_config.CfnOrganizationConformancePackDefConformancepackinputparameterpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_config.CfnOrganizationConformancePackDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_config.CfnOrganizationConformancePackDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_config.CfnOrganizationConformancePackDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_config.CfnOrganizationConformancePackDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_config.CfnOrganizationConformancePackDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_config.CfnOrganizationConformancePackDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_config.CfnOrganizationConformancePackDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_config.CfnOrganizationConformancePackDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_config.CfnOrganizationConformancePackDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_config.CfnOrganizationConformancePackDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_config.CfnOrganizationConformancePackDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_config.CfnOrganizationConformancePackDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_config.CfnOrganizationConformancePackDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnOrganizationConformancePackDefConformancepackinputparameterpropertyParams(pydantic.BaseModel):
    parameter_name: str = pydantic.Field(..., description='')
    parameter_value: str = pydantic.Field(..., description='')
    ...

class CfnOrganizationConformancePackDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnOrganizationConformancePackDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnOrganizationConformancePackDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnOrganizationConformancePackDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnOrganizationConformancePackDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnOrganizationConformancePackDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnOrganizationConformancePackDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnOrganizationConformancePackDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnOrganizationConformancePackDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnOrganizationConformancePackDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnOrganizationConformancePackDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnOrganizationConformancePackDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnOrganizationConformancePackDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnOrganizationConformancePackDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_config.CfnRemediationConfiguration
class CfnRemediationConfigurationDef(BaseCfnResource):
    config_rule_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the AWS Config rule.\n')
    target_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Target ID is the name of the SSM document.\n')
    target_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of the target. Target executes remediation. For example, SSM document.\n')
    automatic: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='The remediation is triggered automatically.\n')
    execution_controls: typing.Union[models.UnsupportedResource, models.aws_config.CfnRemediationConfiguration_ExecutionControlsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An ExecutionControls object.\n')
    maximum_automatic_attempts: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of failed attempts for auto-remediation. If you do not select a number, the default is 5. For example, if you specify MaximumAutomaticAttempts as 5 with RetryAttemptSeconds as 50 seconds, AWS Config will put a RemediationException on your behalf for the failing resource after the 5th failed attempt within 50 seconds.\n')
    parameters: typing.Any = pydantic.Field(None, description='An object of the RemediationParameterValue. For more information, see `RemediationParameterValue <https://docs.aws.amazon.com/config/latest/APIReference/API_RemediationParameterValue.html>`_ . .. epigraph:: The type is a map of strings to RemediationParameterValue.\n')
    resource_type: typing.Optional[str] = pydantic.Field(None, description='The type of a resource.\n')
    retry_attempt_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='Maximum time in seconds that AWS Config runs auto-remediation. If you do not select a number, the default is 60 seconds. For example, if you specify RetryAttemptSeconds as 50 seconds and MaximumAutomaticAttempts as 5, AWS Config will run auto-remediations 5 times within 50 seconds before throwing an exception.\n')
    target_version: typing.Optional[str] = pydantic.Field(None, description='Version of the target. For example, version of the SSM document. .. epigraph:: If you make backward incompatible changes to the SSM document, you must call PutRemediationConfiguration API again to ensure the remediations can run.')
    _init_params: typing.ClassVar[list[str]] = ['config_rule_name', 'target_id', 'target_type', 'automatic', 'execution_controls', 'maximum_automatic_attempts', 'parameters', 'resource_type', 'retry_attempt_seconds', 'target_version']
    _method_names: typing.ClassVar[list[str]] = ['ExecutionControlsProperty', 'RemediationParameterValueProperty', 'ResourceValueProperty', 'SsmControlsProperty', 'StaticValueProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnRemediationConfiguration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_config.CfnRemediationConfigurationDefConfig] = pydantic.Field(None)


class CfnRemediationConfigurationDefConfig(pydantic.BaseModel):
    ExecutionControlsProperty: typing.Optional[list[models.aws_config.CfnRemediationConfigurationDefExecutioncontrolspropertyParams]] = pydantic.Field(None, description='')
    RemediationParameterValueProperty: typing.Optional[list[models.aws_config.CfnRemediationConfigurationDefRemediationparametervaluepropertyParams]] = pydantic.Field(None, description='')
    ResourceValueProperty: typing.Optional[list[models.aws_config.CfnRemediationConfigurationDefResourcevaluepropertyParams]] = pydantic.Field(None, description='')
    SsmControlsProperty: typing.Optional[list[models.aws_config.CfnRemediationConfigurationDefSsmcontrolspropertyParams]] = pydantic.Field(None, description='')
    StaticValueProperty: typing.Optional[list[models.aws_config.CfnRemediationConfigurationDefStaticvaluepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_config.CfnRemediationConfigurationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_config.CfnRemediationConfigurationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_config.CfnRemediationConfigurationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_config.CfnRemediationConfigurationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_config.CfnRemediationConfigurationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_config.CfnRemediationConfigurationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_config.CfnRemediationConfigurationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_config.CfnRemediationConfigurationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_config.CfnRemediationConfigurationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_config.CfnRemediationConfigurationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_config.CfnRemediationConfigurationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_config.CfnRemediationConfigurationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_config.CfnRemediationConfigurationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnRemediationConfigurationDefExecutioncontrolspropertyParams(pydantic.BaseModel):
    ssm_controls: typing.Union[models.UnsupportedResource, models.aws_config.CfnRemediationConfiguration_SsmControlsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnRemediationConfigurationDefRemediationparametervaluepropertyParams(pydantic.BaseModel):
    resource_value: typing.Union[models.UnsupportedResource, models.aws_config.CfnRemediationConfiguration_ResourceValuePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    static_value: typing.Union[models.UnsupportedResource, models.aws_config.CfnRemediationConfiguration_StaticValuePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnRemediationConfigurationDefResourcevaluepropertyParams(pydantic.BaseModel):
    value: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnRemediationConfigurationDefSsmcontrolspropertyParams(pydantic.BaseModel):
    concurrent_execution_rate_percentage: typing.Union[int, float, None] = pydantic.Field(None, description='')
    error_percentage: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnRemediationConfigurationDefStaticvaluepropertyParams(pydantic.BaseModel):
    value: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnRemediationConfigurationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnRemediationConfigurationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRemediationConfigurationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnRemediationConfigurationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRemediationConfigurationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnRemediationConfigurationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnRemediationConfigurationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnRemediationConfigurationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnRemediationConfigurationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnRemediationConfigurationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRemediationConfigurationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnRemediationConfigurationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnRemediationConfigurationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRemediationConfigurationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_config.CfnStoredQuery
class CfnStoredQueryDef(BaseCfnResource):
    query_expression: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The expression of the query. For example, ``SELECT resourceId, resourceType, supplementaryConfiguration.BucketVersioningConfiguration.status WHERE resourceType = 'AWS::S3::Bucket' AND supplementaryConfiguration.BucketVersioningConfiguration.status = 'Off'.``\n")
    query_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the query.\n')
    query_description: typing.Optional[str] = pydantic.Field(None, description='A unique description for the query.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource.')
    _init_params: typing.ClassVar[list[str]] = ['query_expression', 'query_name', 'query_description', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnStoredQuery'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_config.CfnStoredQueryDefConfig] = pydantic.Field(None)


class CfnStoredQueryDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_config.CfnStoredQueryDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_config.CfnStoredQueryDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_config.CfnStoredQueryDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_config.CfnStoredQueryDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_config.CfnStoredQueryDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_config.CfnStoredQueryDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_config.CfnStoredQueryDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_config.CfnStoredQueryDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_config.CfnStoredQueryDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_config.CfnStoredQueryDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_config.CfnStoredQueryDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_config.CfnStoredQueryDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_config.CfnStoredQueryDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnStoredQueryDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnStoredQueryDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnStoredQueryDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnStoredQueryDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnStoredQueryDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnStoredQueryDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnStoredQueryDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnStoredQueryDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnStoredQueryDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnStoredQueryDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnStoredQueryDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnStoredQueryDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnStoredQueryDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnStoredQueryDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_config.CfnAggregationAuthorizationProps
class CfnAggregationAuthorizationPropsDef(BaseCfnProperty):
    authorized_account_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The 12-digit account ID of the account authorized to aggregate data.\n')
    authorized_aws_region: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The region authorized to collect aggregated data.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of tag object.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-config-aggregationauthorization.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    cfn_aggregation_authorization_props = config.CfnAggregationAuthorizationProps(\n        authorized_account_id="authorizedAccountId",\n        authorized_aws_region="authorizedAwsRegion",\n\n        # the properties below are optional\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['authorized_account_id', 'authorized_aws_region', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnAggregationAuthorizationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnConfigRuleProps
class CfnConfigRulePropsDef(BaseCfnProperty):
    source: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_config.CfnConfigRule_SourcePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Provides the rule owner ( ``AWS`` for managed rules, ``CUSTOM_POLICY`` for Custom Policy rules, and ``CUSTOM_LAMBDA`` for Custom Lambda rules), the rule identifier, and the notifications that cause the function to evaluate your AWS resources.\n')
    compliance: typing.Union[models.UnsupportedResource, models.aws_config.CfnConfigRule_CompliancePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Indicates whether an AWS resource or AWS Config rule is compliant and provides the number of contributors that affect the compliance.\n')
    config_rule_name: typing.Optional[str] = pydantic.Field(None, description="A name for the AWS Config rule. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the rule name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ .\n")
    description: typing.Optional[str] = pydantic.Field(None, description='The description that you provide for the AWS Config rule.\n')
    evaluation_modes: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_config.CfnConfigRule_EvaluationModeConfigurationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The modes the AWS Config rule can be evaluated in. The valid values are distinct objects. By default, the value is Detective evaluation mode only.\n')
    input_parameters: typing.Any = pydantic.Field(None, description='A string, in JSON format, that is passed to the AWS Config rule Lambda function.\n')
    maximum_execution_frequency: typing.Optional[str] = pydantic.Field(None, description='The maximum frequency with which AWS Config runs evaluations for a rule. You can specify a value for ``MaximumExecutionFrequency`` when: - You are using an AWS managed rule that is triggered at a periodic frequency. - Your custom rule is triggered when AWS Config delivers the configuration snapshot. For more information, see `ConfigSnapshotDeliveryProperties <https://docs.aws.amazon.com/config/latest/APIReference/API_ConfigSnapshotDeliveryProperties.html>`_ . .. epigraph:: By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the ``MaximumExecutionFrequency`` parameter.\n')
    _init_params: typing.ClassVar[list[str]] = ['source', 'compliance', 'config_rule_name', 'description', 'evaluation_modes', 'input_parameters', 'maximum_execution_frequency']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnConfigRuleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnConfigurationAggregatorProps
class CfnConfigurationAggregatorPropsDef(BaseCfnProperty):
    account_aggregation_sources: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_config.CfnConfigurationAggregator_AccountAggregationSourcePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Provides a list of source accounts and regions to be aggregated.\n')
    configuration_aggregator_name: typing.Optional[str] = pydantic.Field(None, description='The name of the aggregator.\n')
    organization_aggregation_source: typing.Union[models.UnsupportedResource, models.aws_config.CfnConfigurationAggregator_OrganizationAggregationSourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Provides an organization and list of regions to be aggregated.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of tag object.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-config-configurationaggregator.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    cfn_configuration_aggregator_props = config.CfnConfigurationAggregatorProps(\n        account_aggregation_sources=[config.CfnConfigurationAggregator.AccountAggregationSourceProperty(\n            account_ids=["accountIds"],\n\n            # the properties below are optional\n            all_aws_regions=False,\n            aws_regions=["awsRegions"]\n        )],\n        configuration_aggregator_name="configurationAggregatorName",\n        organization_aggregation_source=config.CfnConfigurationAggregator.OrganizationAggregationSourceProperty(\n            role_arn="roleArn",\n\n            # the properties below are optional\n            all_aws_regions=False,\n            aws_regions=["awsRegions"]\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account_aggregation_sources', 'configuration_aggregator_name', 'organization_aggregation_source', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnConfigurationAggregatorProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnConfigurationRecorderProps
class CfnConfigurationRecorderPropsDef(BaseCfnProperty):
    role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Amazon Resource Name (ARN) of the IAM role assumed by AWS Config and used by the configuration recorder. For more information, see `Permissions for the IAM Role Assigned <https://docs.aws.amazon.com/config/latest/developerguide/iamrole-permissions.html>`_ to AWS Config in the AWS Config Developer Guide. .. epigraph:: *Pre-existing AWS Config role* If you have used an AWS service that uses AWS Config , such as AWS Security Hub or AWS Control Tower , and an AWS Config role has already been created, make sure that the IAM role that you use when setting up AWS Config keeps the same minimum permissions as the already created AWS Config role. You must do this so that the other AWS service continues to run as expected. For example, if AWS Control Tower has an IAM role that allows AWS Config to read Amazon Simple Storage Service ( Amazon S3 ) objects, make sure that the same permissions are granted within the IAM role you use when setting up AWS Config . Otherwise, it may interfere with how AWS Control Tower operates. For more information about IAM roles for AWS Config , see `*Identity and Access Management for AWS Config* <https://docs.aws.amazon.com/config/latest/developerguide/security-iam.html>`_ in the *AWS Config Developer Guide* .\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the configuration recorder. AWS Config automatically assigns the name of "default" when creating the configuration recorder. You cannot change the name of the configuration recorder after it has been created. To change the configuration recorder name, you must delete it and create a new configuration recorder with a new name.\n')
    recording_group: typing.Union[models.UnsupportedResource, models.aws_config.CfnConfigurationRecorder_RecordingGroupPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies which resource types AWS Config records for configuration changes. .. epigraph:: *High Number of AWS Config Evaluations* You may notice increased activity in your account during your initial month recording with AWS Config when compared to subsequent months. During the initial bootstrapping process, AWS Config runs evaluations on all the resources in your account that you have selected for AWS Config to record. If you are running ephemeral workloads, you may see increased activity from AWS Config as it records configuration changes associated with creating and deleting these temporary resources. An *ephemeral workload* is a temporary use of computing resources that are loaded and run when needed. Examples include Amazon Elastic Compute Cloud ( Amazon EC2 ) Spot Instances, Amazon EMR jobs, and AWS Auto Scaling . If you want to avoid the increased activity from running ephemeral workloads, you can run these types of workloads in a separate account with AWS Config turned off to avoid increased configuration recording and rule evaluations.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-config-configurationrecorder.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    cfn_configuration_recorder_props = config.CfnConfigurationRecorderProps(\n        role_arn="roleArn",\n\n        # the properties below are optional\n        name="name",\n        recording_group=config.CfnConfigurationRecorder.RecordingGroupProperty(\n            all_supported=False,\n            exclusion_by_resource_types=config.CfnConfigurationRecorder.ExclusionByResourceTypesProperty(\n                resource_types=["resourceTypes"]\n            ),\n            include_global_resource_types=False,\n            recording_strategy=config.CfnConfigurationRecorder.RecordingStrategyProperty(\n                use_only="useOnly"\n            ),\n            resource_types=["resourceTypes"]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['role_arn', 'name', 'recording_group']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnConfigurationRecorderProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnConformancePackProps
class CfnConformancePackPropsDef(BaseCfnProperty):
    conformance_pack_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Name of the conformance pack you want to create.\n')
    conformance_pack_input_parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_config.CfnConformancePack_ConformancePackInputParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of ConformancePackInputParameter objects.\n')
    delivery_s3_bucket: typing.Optional[str] = pydantic.Field(None, description='The name of the Amazon S3 bucket where AWS Config stores conformance pack templates.\n')
    delivery_s3_key_prefix: typing.Optional[str] = pydantic.Field(None, description='The prefix for the Amazon S3 bucket.\n')
    template_body: typing.Optional[str] = pydantic.Field(None, description='A string containing full conformance pack template body. Structure containing the template body with a minimum length of 1 byte and a maximum length of 51,200 bytes. .. epigraph:: You can only use a YAML template with two resource types: config rule ( ``AWS::Config::ConfigRule`` ) and a remediation action ( ``AWS::Config::RemediationConfiguration`` ).\n')
    template_s3_uri: typing.Optional[str] = pydantic.Field(None, description='Location of file containing the template body (s3://bucketname/prefix). The uri must point to the conformance pack template (max size: 300 KB) that is located in an Amazon S3 bucket. .. epigraph:: You must have access to read Amazon S3 bucket.\n')
    template_ssm_document_details: typing.Any = pydantic.Field(None, description='An object that contains the name or Amazon Resource Name (ARN) of the AWS Systems Manager document (SSM document) and the version of the SSM document that is used to create a conformance pack.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-config-conformancepack.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    # template_ssm_document_details: Any\n\n    cfn_conformance_pack_props = config.CfnConformancePackProps(\n        conformance_pack_name="conformancePackName",\n\n        # the properties below are optional\n        conformance_pack_input_parameters=[config.CfnConformancePack.ConformancePackInputParameterProperty(\n            parameter_name="parameterName",\n            parameter_value="parameterValue"\n        )],\n        delivery_s3_bucket="deliveryS3Bucket",\n        delivery_s3_key_prefix="deliveryS3KeyPrefix",\n        template_body="templateBody",\n        template_s3_uri="templateS3Uri",\n        template_ssm_document_details=template_ssm_document_details\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['conformance_pack_name', 'conformance_pack_input_parameters', 'delivery_s3_bucket', 'delivery_s3_key_prefix', 'template_body', 'template_s3_uri', 'template_ssm_document_details']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnConformancePackProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnDeliveryChannelProps
class CfnDeliveryChannelPropsDef(BaseCfnProperty):
    s3_bucket_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the Amazon S3 bucket to which AWS Config delivers configuration snapshots and configuration history files. If you specify a bucket that belongs to another AWS account , that bucket must have policies that grant access permissions to AWS Config . For more information, see `Permissions for the Amazon S3 Bucket <https://docs.aws.amazon.com/config/latest/developerguide/s3-bucket-policy.html>`_ in the *AWS Config Developer Guide* .\n')
    config_snapshot_delivery_properties: typing.Union[models.UnsupportedResource, models.aws_config.CfnDeliveryChannel_ConfigSnapshotDeliveryPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for how often AWS Config delivers configuration snapshots to the Amazon S3 bucket.\n')
    name: typing.Optional[str] = pydantic.Field(None, description="A name for the delivery channel. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the delivery channel name. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ . Updates are not supported. To change the name, you must run two separate updates. In the first update, delete this resource, and then recreate it with a new name in the second update.\n")
    s3_key_prefix: typing.Optional[str] = pydantic.Field(None, description='The prefix for the specified Amazon S3 bucket.\n')
    s3_kms_key_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the AWS Key Management Service ( AWS KMS ) AWS KMS key (KMS key) used to encrypt objects delivered by AWS Config . Must belong to the same Region as the destination S3 bucket.\n')
    sns_topic_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the Amazon SNS topic to which AWS Config sends notifications about configuration changes. If you choose a topic from another account, the topic must have policies that grant access permissions to AWS Config . For more information, see `Permissions for the Amazon SNS Topic <https://docs.aws.amazon.com/config/latest/developerguide/sns-topic-policy.html>`_ in the *AWS Config Developer Guide* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-config-deliverychannel.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    cfn_delivery_channel_props = config.CfnDeliveryChannelProps(\n        s3_bucket_name="s3BucketName",\n\n        # the properties below are optional\n        config_snapshot_delivery_properties=config.CfnDeliveryChannel.ConfigSnapshotDeliveryPropertiesProperty(\n            delivery_frequency="deliveryFrequency"\n        ),\n        name="name",\n        s3_key_prefix="s3KeyPrefix",\n        s3_kms_key_arn="s3KmsKeyArn",\n        sns_topic_arn="snsTopicArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['s3_bucket_name', 'config_snapshot_delivery_properties', 'name', 's3_key_prefix', 's3_kms_key_arn', 'sns_topic_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnDeliveryChannelProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnOrganizationConfigRuleProps
class CfnOrganizationConfigRulePropsDef(BaseCfnProperty):
    organization_config_rule_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name that you assign to organization AWS Config rule.\n')
    excluded_accounts: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A comma-separated list of accounts excluded from organization AWS Config rule.\n')
    organization_custom_policy_rule_metadata: typing.Union[models.UnsupportedResource, models.aws_config.CfnOrganizationConfigRule_OrganizationCustomPolicyRuleMetadataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="An object that specifies metadata for your organization's AWS Config Custom Policy rule. The metadata includes the runtime system in use, which accounts have debug logging enabled, and other custom rule metadata, such as resource type, resource ID of AWS resource, and organization trigger types that initiate AWS Config to evaluate AWS resources against a rule.\n")
    organization_custom_rule_metadata: typing.Union[models.UnsupportedResource, models.aws_config.CfnOrganizationConfigRule_OrganizationCustomRuleMetadataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An ``OrganizationCustomRuleMetadata`` object.\n')
    organization_managed_rule_metadata: typing.Union[models.UnsupportedResource, models.aws_config.CfnOrganizationConfigRule_OrganizationManagedRuleMetadataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An ``OrganizationManagedRuleMetadata`` object.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-config-organizationconfigrule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    cfn_organization_config_rule_props = config.CfnOrganizationConfigRuleProps(\n        organization_config_rule_name="organizationConfigRuleName",\n\n        # the properties below are optional\n        excluded_accounts=["excludedAccounts"],\n        organization_custom_policy_rule_metadata=config.CfnOrganizationConfigRule.OrganizationCustomPolicyRuleMetadataProperty(\n            policy_text="policyText",\n            runtime="runtime",\n\n            # the properties below are optional\n            debug_log_delivery_accounts=["debugLogDeliveryAccounts"],\n            description="description",\n            input_parameters="inputParameters",\n            maximum_execution_frequency="maximumExecutionFrequency",\n            organization_config_rule_trigger_types=["organizationConfigRuleTriggerTypes"],\n            resource_id_scope="resourceIdScope",\n            resource_types_scope=["resourceTypesScope"],\n            tag_key_scope="tagKeyScope",\n            tag_value_scope="tagValueScope"\n        ),\n        organization_custom_rule_metadata=config.CfnOrganizationConfigRule.OrganizationCustomRuleMetadataProperty(\n            lambda_function_arn="lambdaFunctionArn",\n            organization_config_rule_trigger_types=["organizationConfigRuleTriggerTypes"],\n\n            # the properties below are optional\n            description="description",\n            input_parameters="inputParameters",\n            maximum_execution_frequency="maximumExecutionFrequency",\n            resource_id_scope="resourceIdScope",\n            resource_types_scope=["resourceTypesScope"],\n            tag_key_scope="tagKeyScope",\n            tag_value_scope="tagValueScope"\n        ),\n        organization_managed_rule_metadata=config.CfnOrganizationConfigRule.OrganizationManagedRuleMetadataProperty(\n            rule_identifier="ruleIdentifier",\n\n            # the properties below are optional\n            description="description",\n            input_parameters="inputParameters",\n            maximum_execution_frequency="maximumExecutionFrequency",\n            resource_id_scope="resourceIdScope",\n            resource_types_scope=["resourceTypesScope"],\n            tag_key_scope="tagKeyScope",\n            tag_value_scope="tagValueScope"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['organization_config_rule_name', 'excluded_accounts', 'organization_custom_policy_rule_metadata', 'organization_custom_rule_metadata', 'organization_managed_rule_metadata']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnOrganizationConfigRuleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnOrganizationConformancePackProps
class CfnOrganizationConformancePackPropsDef(BaseCfnProperty):
    organization_conformance_pack_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name you assign to an organization conformance pack.\n')
    conformance_pack_input_parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_config.CfnOrganizationConformancePack_ConformancePackInputParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of ``ConformancePackInputParameter`` objects.\n')
    delivery_s3_bucket: typing.Optional[str] = pydantic.Field(None, description='The name of the Amazon S3 bucket where AWS Config stores conformance pack templates. .. epigraph:: This field is optional.\n')
    delivery_s3_key_prefix: typing.Optional[str] = pydantic.Field(None, description='Any folder structure you want to add to an Amazon S3 bucket. .. epigraph:: This field is optional.\n')
    excluded_accounts: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A comma-separated list of accounts excluded from organization conformance pack.\n')
    template_body: typing.Optional[str] = pydantic.Field(None, description='A string containing full conformance pack template body. Structure containing the template body with a minimum length of 1 byte and a maximum length of 51,200 bytes.\n')
    template_s3_uri: typing.Optional[str] = pydantic.Field(None, description='Location of file containing the template body. The uri must point to the conformance pack template (max size: 300 KB).\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-config-organizationconformancepack.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    cfn_organization_conformance_pack_props = config.CfnOrganizationConformancePackProps(\n        organization_conformance_pack_name="organizationConformancePackName",\n\n        # the properties below are optional\n        conformance_pack_input_parameters=[config.CfnOrganizationConformancePack.ConformancePackInputParameterProperty(\n            parameter_name="parameterName",\n            parameter_value="parameterValue"\n        )],\n        delivery_s3_bucket="deliveryS3Bucket",\n        delivery_s3_key_prefix="deliveryS3KeyPrefix",\n        excluded_accounts=["excludedAccounts"],\n        template_body="templateBody",\n        template_s3_uri="templateS3Uri"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['organization_conformance_pack_name', 'conformance_pack_input_parameters', 'delivery_s3_bucket', 'delivery_s3_key_prefix', 'excluded_accounts', 'template_body', 'template_s3_uri']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnOrganizationConformancePackProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnRemediationConfigurationProps
class CfnRemediationConfigurationPropsDef(BaseCfnProperty):
    config_rule_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the AWS Config rule.\n')
    target_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Target ID is the name of the SSM document.\n')
    target_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of the target. Target executes remediation. For example, SSM document.\n')
    automatic: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='The remediation is triggered automatically.\n')
    execution_controls: typing.Union[models.UnsupportedResource, models.aws_config.CfnRemediationConfiguration_ExecutionControlsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An ExecutionControls object.\n')
    maximum_automatic_attempts: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of failed attempts for auto-remediation. If you do not select a number, the default is 5. For example, if you specify MaximumAutomaticAttempts as 5 with RetryAttemptSeconds as 50 seconds, AWS Config will put a RemediationException on your behalf for the failing resource after the 5th failed attempt within 50 seconds.\n')
    parameters: typing.Any = pydantic.Field(None, description='An object of the RemediationParameterValue. For more information, see `RemediationParameterValue <https://docs.aws.amazon.com/config/latest/APIReference/API_RemediationParameterValue.html>`_ . .. epigraph:: The type is a map of strings to RemediationParameterValue.\n')
    resource_type: typing.Optional[str] = pydantic.Field(None, description='The type of a resource.\n')
    retry_attempt_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='Maximum time in seconds that AWS Config runs auto-remediation. If you do not select a number, the default is 60 seconds. For example, if you specify RetryAttemptSeconds as 50 seconds and MaximumAutomaticAttempts as 5, AWS Config will run auto-remediations 5 times within 50 seconds before throwing an exception.\n')
    target_version: typing.Optional[str] = pydantic.Field(None, description='Version of the target. For example, version of the SSM document. .. epigraph:: If you make backward incompatible changes to the SSM document, you must call PutRemediationConfiguration API again to ensure the remediations can run.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-config-remediationconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    # parameters: Any\n\n    cfn_remediation_configuration_props = config.CfnRemediationConfigurationProps(\n        config_rule_name="configRuleName",\n        target_id="targetId",\n        target_type="targetType",\n\n        # the properties below are optional\n        automatic=False,\n        execution_controls=config.CfnRemediationConfiguration.ExecutionControlsProperty(\n            ssm_controls=config.CfnRemediationConfiguration.SsmControlsProperty(\n                concurrent_execution_rate_percentage=123,\n                error_percentage=123\n            )\n        ),\n        maximum_automatic_attempts=123,\n        parameters=parameters,\n        resource_type="resourceType",\n        retry_attempt_seconds=123,\n        target_version="targetVersion"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['config_rule_name', 'target_id', 'target_type', 'automatic', 'execution_controls', 'maximum_automatic_attempts', 'parameters', 'resource_type', 'retry_attempt_seconds', 'target_version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnRemediationConfigurationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_config.CfnStoredQueryProps
class CfnStoredQueryPropsDef(BaseCfnProperty):
    query_expression: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The expression of the query. For example, ``SELECT resourceId, resourceType, supplementaryConfiguration.BucketVersioningConfiguration.status WHERE resourceType = 'AWS::S3::Bucket' AND supplementaryConfiguration.BucketVersioningConfiguration.status = 'Off'.``\n")
    query_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the query.\n')
    query_description: typing.Optional[str] = pydantic.Field(None, description='A unique description for the query.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-config-storedquery.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_config as config\n\n    cfn_stored_query_props = config.CfnStoredQueryProps(\n        query_expression="queryExpression",\n        query_name="queryName",\n\n        # the properties below are optional\n        query_description="queryDescription",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['query_expression', 'query_name', 'query_description', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_config.CfnStoredQueryProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    ManagedRuleIdentifiers: typing.Optional[dict[str, models.aws_config.ManagedRuleIdentifiersDef]] = pydantic.Field(None)
    ResourceType: typing.Optional[dict[str, models.aws_config.ResourceTypeDef]] = pydantic.Field(None)
    RuleScope: typing.Optional[dict[str, models.aws_config.RuleScopeDef]] = pydantic.Field(None)
    AccessKeysRotated: typing.Optional[dict[str, models.aws_config.AccessKeysRotatedDef]] = pydantic.Field(None)
    CloudFormationStackDriftDetectionCheck: typing.Optional[dict[str, models.aws_config.CloudFormationStackDriftDetectionCheckDef]] = pydantic.Field(None)
    CloudFormationStackNotificationCheck: typing.Optional[dict[str, models.aws_config.CloudFormationStackNotificationCheckDef]] = pydantic.Field(None)
    CustomPolicy: typing.Optional[dict[str, models.aws_config.CustomPolicyDef]] = pydantic.Field(None)
    CustomRule: typing.Optional[dict[str, models.aws_config.CustomRuleDef]] = pydantic.Field(None)
    ManagedRule: typing.Optional[dict[str, models.aws_config.ManagedRuleDef]] = pydantic.Field(None)
    AccessKeysRotatedProps: typing.Optional[dict[str, models.aws_config.AccessKeysRotatedPropsDef]] = pydantic.Field(None)
    CfnConfigRule_ComplianceProperty: typing.Optional[dict[str, models.aws_config.CfnConfigRule_CompliancePropertyDef]] = pydantic.Field(None)
    CfnConfigRule_CustomPolicyDetailsProperty: typing.Optional[dict[str, models.aws_config.CfnConfigRule_CustomPolicyDetailsPropertyDef]] = pydantic.Field(None)
    CfnConfigRule_EvaluationModeConfigurationProperty: typing.Optional[dict[str, models.aws_config.CfnConfigRule_EvaluationModeConfigurationPropertyDef]] = pydantic.Field(None)
    CfnConfigRule_ScopeProperty: typing.Optional[dict[str, models.aws_config.CfnConfigRule_ScopePropertyDef]] = pydantic.Field(None)
    CfnConfigRule_SourceDetailProperty: typing.Optional[dict[str, models.aws_config.CfnConfigRule_SourceDetailPropertyDef]] = pydantic.Field(None)
    CfnConfigRule_SourceProperty: typing.Optional[dict[str, models.aws_config.CfnConfigRule_SourcePropertyDef]] = pydantic.Field(None)
    CfnConfigurationAggregator_AccountAggregationSourceProperty: typing.Optional[dict[str, models.aws_config.CfnConfigurationAggregator_AccountAggregationSourcePropertyDef]] = pydantic.Field(None)
    CfnConfigurationAggregator_OrganizationAggregationSourceProperty: typing.Optional[dict[str, models.aws_config.CfnConfigurationAggregator_OrganizationAggregationSourcePropertyDef]] = pydantic.Field(None)
    CfnConfigurationRecorder_ExclusionByResourceTypesProperty: typing.Optional[dict[str, models.aws_config.CfnConfigurationRecorder_ExclusionByResourceTypesPropertyDef]] = pydantic.Field(None)
    CfnConfigurationRecorder_RecordingGroupProperty: typing.Optional[dict[str, models.aws_config.CfnConfigurationRecorder_RecordingGroupPropertyDef]] = pydantic.Field(None)
    CfnConfigurationRecorder_RecordingStrategyProperty: typing.Optional[dict[str, models.aws_config.CfnConfigurationRecorder_RecordingStrategyPropertyDef]] = pydantic.Field(None)
    CfnConformancePack_ConformancePackInputParameterProperty: typing.Optional[dict[str, models.aws_config.CfnConformancePack_ConformancePackInputParameterPropertyDef]] = pydantic.Field(None)
    CfnConformancePack_TemplateSSMDocumentDetailsProperty: typing.Optional[dict[str, models.aws_config.CfnConformancePack_TemplateSSMDocumentDetailsPropertyDef]] = pydantic.Field(None)
    CfnDeliveryChannel_ConfigSnapshotDeliveryPropertiesProperty: typing.Optional[dict[str, models.aws_config.CfnDeliveryChannel_ConfigSnapshotDeliveryPropertiesPropertyDef]] = pydantic.Field(None)
    CfnOrganizationConfigRule_OrganizationCustomPolicyRuleMetadataProperty: typing.Optional[dict[str, models.aws_config.CfnOrganizationConfigRule_OrganizationCustomPolicyRuleMetadataPropertyDef]] = pydantic.Field(None)
    CfnOrganizationConfigRule_OrganizationCustomRuleMetadataProperty: typing.Optional[dict[str, models.aws_config.CfnOrganizationConfigRule_OrganizationCustomRuleMetadataPropertyDef]] = pydantic.Field(None)
    CfnOrganizationConfigRule_OrganizationManagedRuleMetadataProperty: typing.Optional[dict[str, models.aws_config.CfnOrganizationConfigRule_OrganizationManagedRuleMetadataPropertyDef]] = pydantic.Field(None)
    CfnOrganizationConformancePack_ConformancePackInputParameterProperty: typing.Optional[dict[str, models.aws_config.CfnOrganizationConformancePack_ConformancePackInputParameterPropertyDef]] = pydantic.Field(None)
    CfnRemediationConfiguration_ExecutionControlsProperty: typing.Optional[dict[str, models.aws_config.CfnRemediationConfiguration_ExecutionControlsPropertyDef]] = pydantic.Field(None)
    CfnRemediationConfiguration_RemediationParameterValueProperty: typing.Optional[dict[str, models.aws_config.CfnRemediationConfiguration_RemediationParameterValuePropertyDef]] = pydantic.Field(None)
    CfnRemediationConfiguration_ResourceValueProperty: typing.Optional[dict[str, models.aws_config.CfnRemediationConfiguration_ResourceValuePropertyDef]] = pydantic.Field(None)
    CfnRemediationConfiguration_SsmControlsProperty: typing.Optional[dict[str, models.aws_config.CfnRemediationConfiguration_SsmControlsPropertyDef]] = pydantic.Field(None)
    CfnRemediationConfiguration_StaticValueProperty: typing.Optional[dict[str, models.aws_config.CfnRemediationConfiguration_StaticValuePropertyDef]] = pydantic.Field(None)
    CloudFormationStackDriftDetectionCheckProps: typing.Optional[dict[str, models.aws_config.CloudFormationStackDriftDetectionCheckPropsDef]] = pydantic.Field(None)
    CloudFormationStackNotificationCheckProps: typing.Optional[dict[str, models.aws_config.CloudFormationStackNotificationCheckPropsDef]] = pydantic.Field(None)
    CustomPolicyProps: typing.Optional[dict[str, models.aws_config.CustomPolicyPropsDef]] = pydantic.Field(None)
    CustomRuleProps: typing.Optional[dict[str, models.aws_config.CustomRulePropsDef]] = pydantic.Field(None)
    ManagedRuleProps: typing.Optional[dict[str, models.aws_config.ManagedRulePropsDef]] = pydantic.Field(None)
    RuleProps: typing.Optional[dict[str, models.aws_config.RulePropsDef]] = pydantic.Field(None)
    CfnAggregationAuthorization: typing.Optional[dict[str, models.aws_config.CfnAggregationAuthorizationDef]] = pydantic.Field(None)
    CfnConfigRule: typing.Optional[dict[str, models.aws_config.CfnConfigRuleDef]] = pydantic.Field(None)
    CfnConfigurationAggregator: typing.Optional[dict[str, models.aws_config.CfnConfigurationAggregatorDef]] = pydantic.Field(None)
    CfnConfigurationRecorder: typing.Optional[dict[str, models.aws_config.CfnConfigurationRecorderDef]] = pydantic.Field(None)
    CfnConformancePack: typing.Optional[dict[str, models.aws_config.CfnConformancePackDef]] = pydantic.Field(None)
    CfnDeliveryChannel: typing.Optional[dict[str, models.aws_config.CfnDeliveryChannelDef]] = pydantic.Field(None)
    CfnOrganizationConfigRule: typing.Optional[dict[str, models.aws_config.CfnOrganizationConfigRuleDef]] = pydantic.Field(None)
    CfnOrganizationConformancePack: typing.Optional[dict[str, models.aws_config.CfnOrganizationConformancePackDef]] = pydantic.Field(None)
    CfnRemediationConfiguration: typing.Optional[dict[str, models.aws_config.CfnRemediationConfigurationDef]] = pydantic.Field(None)
    CfnStoredQuery: typing.Optional[dict[str, models.aws_config.CfnStoredQueryDef]] = pydantic.Field(None)
    CfnAggregationAuthorizationProps: typing.Optional[dict[str, models.aws_config.CfnAggregationAuthorizationPropsDef]] = pydantic.Field(None)
    CfnConfigRuleProps: typing.Optional[dict[str, models.aws_config.CfnConfigRulePropsDef]] = pydantic.Field(None)
    CfnConfigurationAggregatorProps: typing.Optional[dict[str, models.aws_config.CfnConfigurationAggregatorPropsDef]] = pydantic.Field(None)
    CfnConfigurationRecorderProps: typing.Optional[dict[str, models.aws_config.CfnConfigurationRecorderPropsDef]] = pydantic.Field(None)
    CfnConformancePackProps: typing.Optional[dict[str, models.aws_config.CfnConformancePackPropsDef]] = pydantic.Field(None)
    CfnDeliveryChannelProps: typing.Optional[dict[str, models.aws_config.CfnDeliveryChannelPropsDef]] = pydantic.Field(None)
    CfnOrganizationConfigRuleProps: typing.Optional[dict[str, models.aws_config.CfnOrganizationConfigRulePropsDef]] = pydantic.Field(None)
    CfnOrganizationConformancePackProps: typing.Optional[dict[str, models.aws_config.CfnOrganizationConformancePackPropsDef]] = pydantic.Field(None)
    CfnRemediationConfigurationProps: typing.Optional[dict[str, models.aws_config.CfnRemediationConfigurationPropsDef]] = pydantic.Field(None)
    CfnStoredQueryProps: typing.Optional[dict[str, models.aws_config.CfnStoredQueryPropsDef]] = pydantic.Field(None)
    ...

import models
