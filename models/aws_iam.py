from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_iam.AccountPrincipal
class AccountPrincipalDef(BaseClass):
    account_id: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="AWS account ID (i.e. '123456789012').")
    _init_params: typing.ClassVar[list[str]] = ['account_id']
    _method_names: typing.ClassVar[list[str]] = ['add_to_assume_role_policy', 'add_to_policy', 'add_to_principal_policy', 'dedupe_string', 'in_organization', 'with_conditions', 'with_session_tags']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.AccountPrincipal'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AccountPrincipalDefConfig] = pydantic.Field(None)


class AccountPrincipalDefConfig(pydantic.BaseModel):
    add_to_assume_role_policy: typing.Optional[list[AccountPrincipalDefAddToAssumeRolePolicyParams]] = pydantic.Field(None, description='Add the principal to the AssumeRolePolicyDocument.\nAdd the statements to the AssumeRolePolicyDocument necessary to give this principal\npermissions to assume the given role.')
    add_to_policy: typing.Optional[list[AccountPrincipalDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[AccountPrincipalDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    dedupe_string: typing.Optional[bool] = pydantic.Field(None, description='Return whether or not this principal is equal to the given principal.')
    in_organization: typing.Optional[list[AccountPrincipalDefInOrganizationParams]] = pydantic.Field(None, description='A convenience method for adding a condition that the principal is part of the specified AWS Organization.')
    with_conditions: typing.Optional[list[AccountPrincipalDefWithConditionsParams]] = pydantic.Field(None, description='Returns a new PrincipalWithConditions using this principal as the base, with the passed conditions added.\nWhen there is a value for the same operator and key in both the principal and the\nconditions parameter, the value from the conditions parameter will be used.')
    with_session_tags: typing.Optional[list[AccountPrincipalDefWithSessionTagsParams]] = pydantic.Field(None, description='Returns a new principal using this principal as the base, with session tags enabled.\n:return: a new SessionTagsPrincipal object.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class AccountPrincipalDefAddToAssumeRolePolicyParams(pydantic.BaseModel):
    document: models.aws_iam.PolicyDocumentDef = pydantic.Field(..., description='-')
    ...

class AccountPrincipalDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class AccountPrincipalDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    _statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class AccountPrincipalDefInOrganizationParams(pydantic.BaseModel):
    organization_id: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...

class AccountPrincipalDefWithConditionsParams(pydantic.BaseModel):
    conditions: typing.Mapping[str, typing.Any] = pydantic.Field(..., description='-\n')
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...

class AccountPrincipalDefWithSessionTagsParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_iam.AccountRootPrincipal
class AccountRootPrincipalDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['add_to_assume_role_policy', 'add_to_policy', 'add_to_principal_policy', 'dedupe_string', 'in_organization', 'with_conditions', 'with_session_tags']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.AccountRootPrincipal'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AccountRootPrincipalDefConfig] = pydantic.Field(None)


class AccountRootPrincipalDefConfig(pydantic.BaseModel):
    add_to_assume_role_policy: typing.Optional[list[AccountRootPrincipalDefAddToAssumeRolePolicyParams]] = pydantic.Field(None, description='Add the principal to the AssumeRolePolicyDocument.\nAdd the statements to the AssumeRolePolicyDocument necessary to give this principal\npermissions to assume the given role.')
    add_to_policy: typing.Optional[list[AccountRootPrincipalDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[AccountRootPrincipalDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    dedupe_string: typing.Optional[bool] = pydantic.Field(None, description='Return whether or not this principal is equal to the given principal.')
    in_organization: typing.Optional[list[AccountRootPrincipalDefInOrganizationParams]] = pydantic.Field(None, description='A convenience method for adding a condition that the principal is part of the specified AWS Organization.')
    with_conditions: typing.Optional[list[AccountRootPrincipalDefWithConditionsParams]] = pydantic.Field(None, description='Returns a new PrincipalWithConditions using this principal as the base, with the passed conditions added.\nWhen there is a value for the same operator and key in both the principal and the\nconditions parameter, the value from the conditions parameter will be used.')
    with_session_tags: typing.Optional[list[AccountRootPrincipalDefWithSessionTagsParams]] = pydantic.Field(None, description='Returns a new principal using this principal as the base, with session tags enabled.\n:return: a new SessionTagsPrincipal object.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class AccountRootPrincipalDefAddToAssumeRolePolicyParams(pydantic.BaseModel):
    document: models.aws_iam.PolicyDocumentDef = pydantic.Field(..., description='-')
    ...

class AccountRootPrincipalDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class AccountRootPrincipalDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    _statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class AccountRootPrincipalDefInOrganizationParams(pydantic.BaseModel):
    organization_id: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...

class AccountRootPrincipalDefWithConditionsParams(pydantic.BaseModel):
    conditions: typing.Mapping[str, typing.Any] = pydantic.Field(..., description='-\n')
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...

class AccountRootPrincipalDefWithSessionTagsParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_iam.AnyPrincipal
class AnyPrincipalDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['add_to_assume_role_policy', 'add_to_policy', 'add_to_principal_policy', 'dedupe_string', 'in_organization', 'with_conditions', 'with_session_tags']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.AnyPrincipal'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AnyPrincipalDefConfig] = pydantic.Field(None)


class AnyPrincipalDefConfig(pydantic.BaseModel):
    add_to_assume_role_policy: typing.Optional[list[AnyPrincipalDefAddToAssumeRolePolicyParams]] = pydantic.Field(None, description='Add the principal to the AssumeRolePolicyDocument.\nAdd the statements to the AssumeRolePolicyDocument necessary to give this principal\npermissions to assume the given role.')
    add_to_policy: typing.Optional[list[AnyPrincipalDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[AnyPrincipalDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    dedupe_string: typing.Optional[bool] = pydantic.Field(None, description='Return whether or not this principal is equal to the given principal.')
    in_organization: typing.Optional[list[AnyPrincipalDefInOrganizationParams]] = pydantic.Field(None, description='A convenience method for adding a condition that the principal is part of the specified AWS Organization.')
    with_conditions: typing.Optional[list[AnyPrincipalDefWithConditionsParams]] = pydantic.Field(None, description='Returns a new PrincipalWithConditions using this principal as the base, with the passed conditions added.\nWhen there is a value for the same operator and key in both the principal and the\nconditions parameter, the value from the conditions parameter will be used.')
    with_session_tags: typing.Optional[list[AnyPrincipalDefWithSessionTagsParams]] = pydantic.Field(None, description='Returns a new principal using this principal as the base, with session tags enabled.\n:return: a new SessionTagsPrincipal object.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class AnyPrincipalDefAddToAssumeRolePolicyParams(pydantic.BaseModel):
    document: models.aws_iam.PolicyDocumentDef = pydantic.Field(..., description='-')
    ...

class AnyPrincipalDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class AnyPrincipalDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    _statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class AnyPrincipalDefInOrganizationParams(pydantic.BaseModel):
    organization_id: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...

class AnyPrincipalDefWithConditionsParams(pydantic.BaseModel):
    conditions: typing.Mapping[str, typing.Any] = pydantic.Field(..., description='-\n')
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...

class AnyPrincipalDefWithSessionTagsParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_iam.ArnPrincipal
class ArnPrincipalDef(BaseClass):
    arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Amazon Resource Name (ARN) of the principal entity (i.e. arn:aws:iam::123456789012:user/user-name).')
    _init_params: typing.ClassVar[list[str]] = ['arn']
    _method_names: typing.ClassVar[list[str]] = ['add_to_assume_role_policy', 'add_to_policy', 'add_to_principal_policy', 'dedupe_string', 'in_organization', 'with_conditions', 'with_session_tags']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.ArnPrincipal'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ArnPrincipalDefConfig] = pydantic.Field(None)


class ArnPrincipalDefConfig(pydantic.BaseModel):
    add_to_assume_role_policy: typing.Optional[list[ArnPrincipalDefAddToAssumeRolePolicyParams]] = pydantic.Field(None, description='Add the principal to the AssumeRolePolicyDocument.\nAdd the statements to the AssumeRolePolicyDocument necessary to give this principal\npermissions to assume the given role.')
    add_to_policy: typing.Optional[list[ArnPrincipalDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[ArnPrincipalDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    dedupe_string: typing.Optional[bool] = pydantic.Field(None, description='Return whether or not this principal is equal to the given principal.')
    in_organization: typing.Optional[list[ArnPrincipalDefInOrganizationParams]] = pydantic.Field(None, description='A convenience method for adding a condition that the principal is part of the specified AWS Organization.')
    with_conditions: typing.Optional[list[ArnPrincipalDefWithConditionsParams]] = pydantic.Field(None, description='Returns a new PrincipalWithConditions using this principal as the base, with the passed conditions added.\nWhen there is a value for the same operator and key in both the principal and the\nconditions parameter, the value from the conditions parameter will be used.')
    with_session_tags: typing.Optional[list[ArnPrincipalDefWithSessionTagsParams]] = pydantic.Field(None, description='Returns a new principal using this principal as the base, with session tags enabled.\n:return: a new SessionTagsPrincipal object.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class ArnPrincipalDefAddToAssumeRolePolicyParams(pydantic.BaseModel):
    document: models.aws_iam.PolicyDocumentDef = pydantic.Field(..., description='-')
    ...

class ArnPrincipalDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class ArnPrincipalDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    _statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class ArnPrincipalDefInOrganizationParams(pydantic.BaseModel):
    organization_id: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...

class ArnPrincipalDefWithConditionsParams(pydantic.BaseModel):
    conditions: typing.Mapping[str, typing.Any] = pydantic.Field(..., description='-\n')
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...

class ArnPrincipalDefWithSessionTagsParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_iam.CanonicalUserPrincipal
class CanonicalUserPrincipalDef(BaseClass):
    canonical_user_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='unique identifier assigned by AWS for every account. root user and IAM users for an account all see the same ID. (i.e. 79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be)')
    _init_params: typing.ClassVar[list[str]] = ['canonical_user_id']
    _method_names: typing.ClassVar[list[str]] = ['add_to_assume_role_policy', 'add_to_policy', 'add_to_principal_policy', 'dedupe_string', 'with_conditions', 'with_session_tags']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CanonicalUserPrincipal'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CanonicalUserPrincipalDefConfig] = pydantic.Field(None)


class CanonicalUserPrincipalDefConfig(pydantic.BaseModel):
    add_to_assume_role_policy: typing.Optional[list[CanonicalUserPrincipalDefAddToAssumeRolePolicyParams]] = pydantic.Field(None, description='Add the principal to the AssumeRolePolicyDocument.\nAdd the statements to the AssumeRolePolicyDocument necessary to give this principal\npermissions to assume the given role.')
    add_to_policy: typing.Optional[list[CanonicalUserPrincipalDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[CanonicalUserPrincipalDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    dedupe_string: typing.Optional[bool] = pydantic.Field(None, description='Return whether or not this principal is equal to the given principal.')
    with_conditions: typing.Optional[list[CanonicalUserPrincipalDefWithConditionsParams]] = pydantic.Field(None, description='Returns a new PrincipalWithConditions using this principal as the base, with the passed conditions added.\nWhen there is a value for the same operator and key in both the principal and the\nconditions parameter, the value from the conditions parameter will be used.')
    with_session_tags: typing.Optional[list[CanonicalUserPrincipalDefWithSessionTagsParams]] = pydantic.Field(None, description='Returns a new principal using this principal as the base, with session tags enabled.\n:return: a new SessionTagsPrincipal object.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class CanonicalUserPrincipalDefAddToAssumeRolePolicyParams(pydantic.BaseModel):
    document: models.aws_iam.PolicyDocumentDef = pydantic.Field(..., description='-')
    ...

class CanonicalUserPrincipalDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class CanonicalUserPrincipalDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    _statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class CanonicalUserPrincipalDefWithConditionsParams(pydantic.BaseModel):
    conditions: typing.Mapping[str, typing.Any] = pydantic.Field(..., description='-\n')
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...

class CanonicalUserPrincipalDefWithSessionTagsParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_iam.ComparablePrincipal
class ComparablePrincipalDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['dedupe_string_for']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.ComparablePrincipal'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ComparablePrincipalDefConfig] = pydantic.Field(None)


class ComparablePrincipalDefConfig(pydantic.BaseModel):
    dedupe_string_for: typing.Optional[list[ComparablePrincipalDefDedupeStringForParams]] = pydantic.Field(None, description='Return the dedupeString of the given principal, if available.')

class ComparablePrincipalDefDedupeStringForParams(pydantic.BaseModel):
    x: typing.Union[models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef] = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_iam.CompositeDependable
class CompositeDependableDef(BaseClass):
    dependables: list[models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM)
    _init_params: typing.ClassVar[list[str]] = ['dependables']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CompositeDependable'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CompositePrincipal
class CompositePrincipalDef(BaseClass):
    principals: list[typing.Union[models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef]] = pydantic.Field(REQUIRED_INIT_PARAM)
    _init_params: typing.ClassVar[list[str]] = ['principals']
    _method_names: typing.ClassVar[list[str]] = ['add_principals', 'add_to_assume_role_policy', 'add_to_policy', 'add_to_principal_policy', 'dedupe_string', 'with_conditions', 'with_session_tags']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CompositePrincipal'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CompositePrincipalDefConfig] = pydantic.Field(None)


class CompositePrincipalDefConfig(pydantic.BaseModel):
    add_principals: typing.Optional[list[CompositePrincipalDefAddPrincipalsParams]] = pydantic.Field(None, description='Adds IAM principals to the composite principal.\nComposite principals cannot have\nconditions.')
    add_to_assume_role_policy: typing.Optional[list[CompositePrincipalDefAddToAssumeRolePolicyParams]] = pydantic.Field(None, description='Add the principal to the AssumeRolePolicyDocument.\nAdd the statements to the AssumeRolePolicyDocument necessary to give this principal\npermissions to assume the given role.')
    add_to_policy: typing.Optional[list[CompositePrincipalDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[CompositePrincipalDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    dedupe_string: typing.Optional[bool] = pydantic.Field(None, description='Return whether or not this principal is equal to the given principal.')
    with_conditions: typing.Optional[list[CompositePrincipalDefWithConditionsParams]] = pydantic.Field(None, description='Returns a new PrincipalWithConditions using this principal as the base, with the passed conditions added.\nWhen there is a value for the same operator and key in both the principal and the\nconditions parameter, the value from the conditions parameter will be used.')
    with_session_tags: typing.Optional[list[CompositePrincipalDefWithSessionTagsParams]] = pydantic.Field(None, description='Returns a new principal using this principal as the base, with session tags enabled.\n:return: a new SessionTagsPrincipal object.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class CompositePrincipalDefAddPrincipalsParams(pydantic.BaseModel):
    principals: list[typing.Union[models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef]] = pydantic.Field(...)
    ...

class CompositePrincipalDefAddToAssumeRolePolicyParams(pydantic.BaseModel):
    doc: models.aws_iam.PolicyDocumentDef = pydantic.Field(..., description='-')
    ...

class CompositePrincipalDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class CompositePrincipalDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    _statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class CompositePrincipalDefWithConditionsParams(pydantic.BaseModel):
    conditions: typing.Mapping[str, typing.Any] = pydantic.Field(..., description='-\n')
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...

class CompositePrincipalDefWithSessionTagsParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_iam.FederatedPrincipal
class FederatedPrincipalDef(BaseClass):
    federated: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="federated identity provider (i.e. 'cognito-identity.amazonaws.com' for users authenticated through Cognito).")
    conditions: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='-\n')
    assume_role_action: typing.Optional[str] = pydantic.Field(None, description='When this Principal is used in an AssumeRole policy, the action to use.')
    _init_params: typing.ClassVar[list[str]] = ['federated', 'conditions', 'assume_role_action']
    _method_names: typing.ClassVar[list[str]] = ['add_to_assume_role_policy', 'add_to_policy', 'add_to_principal_policy', 'dedupe_string', 'with_conditions', 'with_session_tags']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.FederatedPrincipal'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[FederatedPrincipalDefConfig] = pydantic.Field(None)


class FederatedPrincipalDefConfig(pydantic.BaseModel):
    add_to_assume_role_policy: typing.Optional[list[FederatedPrincipalDefAddToAssumeRolePolicyParams]] = pydantic.Field(None, description='Add the principal to the AssumeRolePolicyDocument.\nAdd the statements to the AssumeRolePolicyDocument necessary to give this principal\npermissions to assume the given role.')
    add_to_policy: typing.Optional[list[FederatedPrincipalDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[FederatedPrincipalDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    dedupe_string: typing.Optional[bool] = pydantic.Field(None, description='Return whether or not this principal is equal to the given principal.')
    with_conditions: typing.Optional[list[FederatedPrincipalDefWithConditionsParams]] = pydantic.Field(None, description='Returns a new PrincipalWithConditions using this principal as the base, with the passed conditions added.\nWhen there is a value for the same operator and key in both the principal and the\nconditions parameter, the value from the conditions parameter will be used.')
    with_session_tags: typing.Optional[list[FederatedPrincipalDefWithSessionTagsParams]] = pydantic.Field(None, description='Returns a new principal using this principal as the base, with session tags enabled.\n:return: a new SessionTagsPrincipal object.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class FederatedPrincipalDefAddToAssumeRolePolicyParams(pydantic.BaseModel):
    document: models.aws_iam.PolicyDocumentDef = pydantic.Field(..., description='-')
    ...

class FederatedPrincipalDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class FederatedPrincipalDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    _statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class FederatedPrincipalDefWithConditionsParams(pydantic.BaseModel):
    conditions: typing.Mapping[str, typing.Any] = pydantic.Field(..., description='-\n')
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...

class FederatedPrincipalDefWithSessionTagsParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_iam.Grant
class GrantDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['apply_before', 'assert_success', 'combine']
    _classmethod_names: typing.ClassVar[list[str]] = ['add_to_principal', 'add_to_principal_and_resource', 'add_to_principal_or_resource', 'drop']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.Grant'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[GrantDefConfig] = pydantic.Field(None)


class GrantDefConfig(pydantic.BaseModel):
    add_to_principal: typing.Optional[list[GrantDefAddToPrincipalParams]] = pydantic.Field(None, description='Try to grant the given permissions to the given principal.\nAbsence of a principal leads to a warning, but failing to add\nthe permissions to a present principal is not an error.')
    add_to_principal_and_resource: typing.Optional[list[GrantDefAddToPrincipalAndResourceParams]] = pydantic.Field(None, description='Add a grant both on the principal and on the resource.\nAs long as any principal is given, granting on the principal may fail (in\ncase of a non-identity principal), but granting on the resource will\nnever fail.\n\nStatement will be the resource statement.')
    add_to_principal_or_resource: typing.Optional[list[GrantDefAddToPrincipalOrResourceParams]] = pydantic.Field(None, description='Grant the given permissions to the principal.\nThe permissions will be added to the principal policy primarily, falling\nback to the resource policy if necessary. The permissions must be granted\nsomewhere.\n\n- Trying to grant permissions to a principal that does not admit adding to\n  the principal policy while not providing a resource with a resource policy\n  is an error.\n- Trying to grant permissions to an absent principal (possible in the\n  case of imported resources) leads to a warning being added to the\n  resource construct.')
    apply_before: typing.Optional[list[GrantDefApplyBeforeParams]] = pydantic.Field(None, description='Make sure this grant is applied before the given constructs are deployed.\nThe same as construct.node.addDependency(grant), but slightly nicer to read.')
    assert_success: typing.Optional[bool] = pydantic.Field(None, description="Throw an error if this grant wasn't successful.")
    combine: typing.Optional[list[GrantDefCombineParams]] = pydantic.Field(None, description='Combine two grants into a new one.')
    drop: typing.Optional[list[GrantDefDropParams]] = pydantic.Field(None, description='Returns a "no-op" ``Grant`` object which represents a "dropped grant".\nThis can be used for e.g. imported resources where you may not be able to modify\nthe resource\'s policy or some underlying policy which you don\'t know about.')

class GrantDefAddToPrincipalParams(pydantic.BaseModel):
    scope: typing.Optional[models.AnyResource] = pydantic.Field(None, description='Construct to report warnings on in case grant could not be registered. Default: - the construct in which this construct is defined\n')
    actions: typing.Sequence[str] = pydantic.Field(..., description='The actions to grant.\n')
    grantee: models.AnyResource = pydantic.Field(..., description='The principal to grant to. Default: if principal is undefined, no work is done.\n')
    resource_arns: typing.Sequence[str] = pydantic.Field(..., description='The resource ARNs to grant to.\n')
    conditions: typing.Optional[typing.Mapping[str, typing.Mapping[str, typing.Any]]] = pydantic.Field(None, description='Any conditions to attach to the grant. Default: - No conditions')
    ...

class GrantDefAddToPrincipalAndResourceParams(pydantic.BaseModel):
    resource: models.UnsupportedResource = pydantic.Field(..., description='The resource with a resource policy. The statement will always be added to the resource policy.\n')
    resource_policy_principal: typing.Optional[typing.Union[models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef]] = pydantic.Field(None, description='The principal to use in the statement for the resource policy. Default: - the principal of the grantee will be used\n')
    resource_self_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="When referring to the resource in a resource policy, use this as ARN. (Depending on the resource type, this needs to be '*' in a resource policy). Default: Same as regular resource ARNs\n")
    actions: typing.Sequence[str] = pydantic.Field(..., description='The actions to grant.\n')
    grantee: models.AnyResource = pydantic.Field(..., description='The principal to grant to. Default: if principal is undefined, no work is done.\n')
    resource_arns: typing.Sequence[str] = pydantic.Field(..., description='The resource ARNs to grant to.\n')
    conditions: typing.Optional[typing.Mapping[str, typing.Mapping[str, typing.Any]]] = pydantic.Field(None, description='Any conditions to attach to the grant. Default: - No conditions')
    ...

class GrantDefAddToPrincipalOrResourceParams(pydantic.BaseModel):
    resource: models.UnsupportedResource = pydantic.Field(..., description="The resource with a resource policy. The statement will be added to the resource policy if it couldn't be added to the principal policy.\n")
    resource_self_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="When referring to the resource in a resource policy, use this as ARN. (Depending on the resource type, this needs to be '*' in a resource policy). Default: Same as regular resource ARNs\n")
    actions: typing.Sequence[str] = pydantic.Field(..., description='The actions to grant.\n')
    grantee: models.AnyResource = pydantic.Field(..., description='The principal to grant to. Default: if principal is undefined, no work is done.\n')
    resource_arns: typing.Sequence[str] = pydantic.Field(..., description='The resource ARNs to grant to.\n')
    conditions: typing.Optional[typing.Mapping[str, typing.Mapping[str, typing.Any]]] = pydantic.Field(None, description='Any conditions to attach to the grant. Default: - No conditions')
    ...

class GrantDefApplyBeforeParams(pydantic.BaseModel):
    constructs: list[models.AnyResource] = pydantic.Field(...)
    ...

class GrantDefCombineParams(pydantic.BaseModel):
    rhs: models.aws_iam.GrantDef = pydantic.Field(..., description='-')
    ...

class GrantDefDropParams(pydantic.BaseModel):
    grantee: models.AnyResource = pydantic.Field(..., description='The intended grantee.\n')
    _intent: str = pydantic.Field(..., description="The user's intent (will be ignored at the moment).")
    ...


#  autogenerated from aws_cdk.aws_iam.OpenIdConnectPrincipal
class OpenIdConnectPrincipalDef(BaseClass):
    open_id_connect_provider: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.OpenIdConnectProviderDef, models.aws_iam.OpenIdConnectProviderDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='OpenID Connect provider.')
    conditions: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='The conditions under which the policy is in effect. See `the IAM documentation <https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition.html>`_.')
    _init_params: typing.ClassVar[list[str]] = ['open_id_connect_provider', 'conditions']
    _method_names: typing.ClassVar[list[str]] = ['add_to_assume_role_policy', 'add_to_policy', 'add_to_principal_policy', 'dedupe_string', 'with_conditions', 'with_session_tags']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.OpenIdConnectPrincipal'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[OpenIdConnectPrincipalDefConfig] = pydantic.Field(None)


class OpenIdConnectPrincipalDefConfig(pydantic.BaseModel):
    add_to_assume_role_policy: typing.Optional[list[OpenIdConnectPrincipalDefAddToAssumeRolePolicyParams]] = pydantic.Field(None, description='Add the principal to the AssumeRolePolicyDocument.\nAdd the statements to the AssumeRolePolicyDocument necessary to give this principal\npermissions to assume the given role.')
    add_to_policy: typing.Optional[list[OpenIdConnectPrincipalDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[OpenIdConnectPrincipalDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    dedupe_string: typing.Optional[bool] = pydantic.Field(None, description='Return whether or not this principal is equal to the given principal.')
    with_conditions: typing.Optional[list[OpenIdConnectPrincipalDefWithConditionsParams]] = pydantic.Field(None, description='Returns a new PrincipalWithConditions using this principal as the base, with the passed conditions added.\nWhen there is a value for the same operator and key in both the principal and the\nconditions parameter, the value from the conditions parameter will be used.')
    with_session_tags: typing.Optional[list[OpenIdConnectPrincipalDefWithSessionTagsParams]] = pydantic.Field(None, description='Returns a new principal using this principal as the base, with session tags enabled.\n:return: a new SessionTagsPrincipal object.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class OpenIdConnectPrincipalDefAddToAssumeRolePolicyParams(pydantic.BaseModel):
    document: models.aws_iam.PolicyDocumentDef = pydantic.Field(..., description='-')
    ...

class OpenIdConnectPrincipalDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class OpenIdConnectPrincipalDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    _statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class OpenIdConnectPrincipalDefWithConditionsParams(pydantic.BaseModel):
    conditions: typing.Mapping[str, typing.Any] = pydantic.Field(..., description='-\n')
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...

class OpenIdConnectPrincipalDefWithSessionTagsParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_iam.OrganizationPrincipal
class OrganizationPrincipalDef(BaseClass):
    organization_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique identifier (ID) of an organization (i.e. o-12345abcde).')
    _init_params: typing.ClassVar[list[str]] = ['organization_id']
    _method_names: typing.ClassVar[list[str]] = ['add_to_assume_role_policy', 'add_to_policy', 'add_to_principal_policy', 'dedupe_string', 'with_conditions', 'with_session_tags']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.OrganizationPrincipal'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[OrganizationPrincipalDefConfig] = pydantic.Field(None)


class OrganizationPrincipalDefConfig(pydantic.BaseModel):
    add_to_assume_role_policy: typing.Optional[list[OrganizationPrincipalDefAddToAssumeRolePolicyParams]] = pydantic.Field(None, description='Add the principal to the AssumeRolePolicyDocument.\nAdd the statements to the AssumeRolePolicyDocument necessary to give this principal\npermissions to assume the given role.')
    add_to_policy: typing.Optional[list[OrganizationPrincipalDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[OrganizationPrincipalDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    dedupe_string: typing.Optional[bool] = pydantic.Field(None, description='Return whether or not this principal is equal to the given principal.')
    with_conditions: typing.Optional[list[OrganizationPrincipalDefWithConditionsParams]] = pydantic.Field(None, description='Returns a new PrincipalWithConditions using this principal as the base, with the passed conditions added.\nWhen there is a value for the same operator and key in both the principal and the\nconditions parameter, the value from the conditions parameter will be used.')
    with_session_tags: typing.Optional[list[OrganizationPrincipalDefWithSessionTagsParams]] = pydantic.Field(None, description='Returns a new principal using this principal as the base, with session tags enabled.\n:return: a new SessionTagsPrincipal object.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class OrganizationPrincipalDefAddToAssumeRolePolicyParams(pydantic.BaseModel):
    document: models.aws_iam.PolicyDocumentDef = pydantic.Field(..., description='-')
    ...

class OrganizationPrincipalDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class OrganizationPrincipalDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    _statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class OrganizationPrincipalDefWithConditionsParams(pydantic.BaseModel):
    conditions: typing.Mapping[str, typing.Any] = pydantic.Field(..., description='-\n')
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...

class OrganizationPrincipalDefWithSessionTagsParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_iam.PermissionsBoundary
class PermissionsBoundaryDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['apply', 'clear']
    _classmethod_names: typing.ClassVar[list[str]] = ['of']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.PermissionsBoundary'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[PermissionsBoundaryDefConfig] = pydantic.Field(None)


class PermissionsBoundaryDefConfig(pydantic.BaseModel):
    apply: typing.Optional[list[PermissionsBoundaryDefApplyParams]] = pydantic.Field(None, description='Apply the given policy as Permissions Boundary to all Roles and Users in the scope.\nWill override any Permissions Boundaries configured previously; in case\na Permission Boundary is applied in multiple scopes, the Boundary applied\nclosest to the Role wins.')
    clear: typing.Optional[bool] = pydantic.Field(None, description='Remove previously applied Permissions Boundaries.')
    of: typing.Optional[list[PermissionsBoundaryDefOfParams]] = pydantic.Field(None, description='Access the Permissions Boundaries of a construct tree.')

class PermissionsBoundaryDefApplyParams(pydantic.BaseModel):
    boundary_policy: typing.Union[models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_iam.ManagedPolicyDef] = pydantic.Field(..., description='-')
    ...

class PermissionsBoundaryDefOfParams(pydantic.BaseModel):
    scope: models.AnyResource = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_iam.PolicyDocument
class PolicyDocumentDef(BaseClass):
    assign_sids: typing.Optional[bool] = pydantic.Field(None, description='Automatically assign Statement Ids to all statements. Default: false')
    minimize: typing.Optional[bool] = pydantic.Field(None, description="Try to minimize the policy by merging statements. To avoid overrunning the maximum policy size, combine statements if they produce the same result. Merging happens according to the following rules: - The Effect of both statements is the same - Neither of the statements have a 'Sid' - Combine Principals if the rest of the statement is exactly the same. - Combine Resources if the rest of the statement is exactly the same. - Combine Actions if the rest of the statement is exactly the same. - We will never combine NotPrincipals, NotResources or NotActions, because doing so would change the meaning of the policy document. Default: - false, unless the feature flag ``@aws-cdk/aws-iam:minimizePolicies`` is set\n")
    statements: typing.Optional[typing.Sequence[models.aws_iam.PolicyStatementDef]] = pydantic.Field(None, description='Initial statements to add to the policy document. Default: - No statements')
    _init_params: typing.ClassVar[list[str]] = ['assign_sids', 'minimize', 'statements']
    _method_names: typing.ClassVar[list[str]] = ['add_statements', 'resolve', 'validate_for_any_policy', 'validate_for_identity_policy', 'validate_for_resource_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_json']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.PolicyDocument'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_json']
    ...


    from_json: typing.Optional[PolicyDocumentDefFromJsonParams] = pydantic.Field(None, description='Creates a new PolicyDocument based on the object provided.\nThis will accept an object created from the ``.toJSON()`` call')
    resource_config: typing.Optional[PolicyDocumentDefConfig] = pydantic.Field(None)


class PolicyDocumentDefConfig(pydantic.BaseModel):
    add_statements: typing.Optional[list[PolicyDocumentDefAddStatementsParams]] = pydantic.Field(None, description='Adds a statement to the policy document.')
    resolve: typing.Optional[list[PolicyDocumentDefResolveParams]] = pydantic.Field(None, description="Produce the Token's value at resolution time.")
    validate_for_any_policy: typing.Optional[bool] = pydantic.Field(None, description='Validate that all policy statements in the policy document satisfies the requirements for any policy.\n:return: An array of validation error messages, or an empty array if the document is valid.\n\n:see: https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policies-json')
    validate_for_identity_policy: typing.Optional[bool] = pydantic.Field(None, description='Validate that all policy statements in the policy document satisfies the requirements for an identity-based policy.\n:return: An array of validation error messages, or an empty array if the document is valid.\n\n:see: https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policies-json')
    validate_for_resource_policy: typing.Optional[bool] = pydantic.Field(None, description='Validate that all policy statements in the policy document satisfies the requirements for a resource-based policy.\n:return: An array of validation error messages, or an empty array if the document is valid.\n\n:see: https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policies-json')

class PolicyDocumentDefAddStatementsParams(pydantic.BaseModel):
    statement: list[models.aws_iam.PolicyStatementDef] = pydantic.Field(...)
    ...

class PolicyDocumentDefFromJsonParams(pydantic.BaseModel):
    obj: typing.Any = pydantic.Field(..., description='the PolicyDocument in object form.')
    ...

class PolicyDocumentDefResolveParams(pydantic.BaseModel):
    context: models.UnsupportedResource = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_iam.PolicyStatement
class PolicyStatementDef(BaseClass):
    actions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of actions to add to the statement. Default: - no actions')
    conditions: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='Conditions to add to the statement. Default: - no condition\n')
    effect: typing.Optional[aws_cdk.aws_iam.Effect] = pydantic.Field(None, description='Whether to allow or deny the actions in this statement. Default: Effect.ALLOW\n')
    not_actions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of not actions to add to the statement. Default: - no not-actions\n')
    not_principals: typing.Optional[typing.Sequence[typing.Union[models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef]]] = pydantic.Field(None, description='List of not principals to add to the statement. Default: - no not principals\n')
    not_resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='NotResource ARNs to add to the statement. Default: - no not-resources\n')
    principals: typing.Optional[typing.Sequence[typing.Union[models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef]]] = pydantic.Field(None, description='List of principals to add to the statement. Default: - no principals\n')
    resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Resource ARNs to add to the statement. Default: - no resources\n')
    sid: typing.Optional[str] = pydantic.Field(None, description="The Sid (statement ID) is an optional identifier that you provide for the policy statement. You can assign a Sid value to each statement in a statement array. In services that let you specify an ID element, such as SQS and SNS, the Sid value is just a sub-ID of the policy document's ID. In IAM, the Sid value must be unique within a JSON policy. Default: - no sid")
    _init_params: typing.ClassVar[list[str]] = ['actions', 'conditions', 'effect', 'not_actions', 'not_principals', 'not_resources', 'principals', 'resources', 'sid']
    _method_names: typing.ClassVar[list[str]] = ['add_account_condition', 'add_account_root_principal', 'add_actions', 'add_all_resources', 'add_any_principal', 'add_arn_principal', 'add_aws_account_principal', 'add_canonical_user_principal', 'add_condition', 'add_conditions', 'add_federated_principal', 'add_not_actions', 'add_not_principals', 'add_not_resources', 'add_principals', 'add_resources', 'add_service_principal', 'add_source_account_condition', 'add_source_arn_condition', 'copy', 'freeze', 'validate_for_any_policy', 'validate_for_identity_policy', 'validate_for_resource_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_json']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.PolicyStatement'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_json']
    ...


    from_json: typing.Optional[PolicyStatementDefFromJsonParams] = pydantic.Field(None, description='Creates a new PolicyStatement based on the object provided.\nThis will accept an object created from the ``.toJSON()`` call')
    resource_config: typing.Optional[PolicyStatementDefConfig] = pydantic.Field(None)


class PolicyStatementDefConfig(pydantic.BaseModel):
    add_account_condition: typing.Optional[list[PolicyStatementDefAddAccountConditionParams]] = pydantic.Field(None, description='Add a ``StringEquals`` condition that limits to a given account from ``sts:ExternalId``.\nThis method can only be called once: subsequent calls will overwrite earlier calls.')
    add_account_root_principal: typing.Optional[bool] = pydantic.Field(None, description='Adds an AWS account root user principal to this policy statement.')
    add_actions: typing.Optional[list[PolicyStatementDefAddActionsParams]] = pydantic.Field(None, description='Specify allowed actions into the "Action" section of the policy statement.')
    add_all_resources: typing.Optional[bool] = pydantic.Field(None, description='Adds a ``"*"`` resource to this statement.')
    add_any_principal: typing.Optional[bool] = pydantic.Field(None, description='Adds all identities in all accounts ("*") to this policy statement.')
    add_arn_principal: typing.Optional[list[PolicyStatementDefAddArnPrincipalParams]] = pydantic.Field(None, description='Specify a principal using the ARN  identifier of the principal.\nYou cannot specify IAM groups and instance profiles as principals.')
    add_aws_account_principal: typing.Optional[list[PolicyStatementDefAddAwsAccountPrincipalParams]] = pydantic.Field(None, description='Specify AWS account ID as the principal entity to the "Principal" section of a policy statement.')
    add_canonical_user_principal: typing.Optional[list[PolicyStatementDefAddCanonicalUserPrincipalParams]] = pydantic.Field(None, description='Adds a canonical user ID principal to this policy document.')
    add_condition: typing.Optional[list[PolicyStatementDefAddConditionParams]] = pydantic.Field(None, description='Add a condition to the Policy.\nIf multiple calls are made to add a condition with the same operator and field, only\nthe last one wins. For example::\n\n   # stmt: iam.PolicyStatement\n\n\n   stmt.add_condition("StringEquals", {"aws:SomeField": "1"})\n   stmt.add_condition("StringEquals", {"aws:SomeField": "2"})\n\nWill end up with the single condition ``StringEquals: { \'aws:SomeField\': \'2\' }``.\n\nIf you meant to add a condition to say that the field can be *either* ``1`` or ``2``, write\nthis::\n\n   # stmt: iam.PolicyStatement\n\n\n   stmt.add_condition("StringEquals", {"aws:SomeField": ["1", "2"]})')
    add_conditions: typing.Optional[list[PolicyStatementDefAddConditionsParams]] = pydantic.Field(None, description='Add multiple conditions to the Policy.\nSee the ``addCondition`` function for a caveat on calling this method multiple times.')
    add_federated_principal: typing.Optional[list[PolicyStatementDefAddFederatedPrincipalParams]] = pydantic.Field(None, description='Adds a federated identity provider such as Amazon Cognito to this policy statement.')
    add_not_actions: typing.Optional[list[PolicyStatementDefAddNotActionsParams]] = pydantic.Field(None, description='Explicitly allow all actions except the specified list of actions into the "NotAction" section of the policy document.')
    add_not_principals: typing.Optional[list[PolicyStatementDefAddNotPrincipalsParams]] = pydantic.Field(None, description='Specify principals that is not allowed or denied access to the "NotPrincipal" section of a policy statement.')
    add_not_resources: typing.Optional[list[PolicyStatementDefAddNotResourcesParams]] = pydantic.Field(None, description='Specify resources that this policy statement will not apply to in the "NotResource" section of this policy statement.\nAll resources except the specified list will be matched.')
    add_principals: typing.Optional[list[PolicyStatementDefAddPrincipalsParams]] = pydantic.Field(None, description='Adds principals to the "Principal" section of a policy statement.')
    add_resources: typing.Optional[list[PolicyStatementDefAddResourcesParams]] = pydantic.Field(None, description='Specify resources that this policy statement applies into the "Resource" section of this policy statement.')
    add_service_principal: typing.Optional[list[PolicyStatementDefAddServicePrincipalParams]] = pydantic.Field(None, description='Adds a service principal to this policy statement.')
    add_source_account_condition: typing.Optional[list[PolicyStatementDefAddSourceAccountConditionParams]] = pydantic.Field(None, description='Add an ``StringEquals`` condition that limits to a given account from ``aws:SourceAccount``.\nThis method can only be called once: subsequent calls will overwrite earlier calls.')
    add_source_arn_condition: typing.Optional[list[PolicyStatementDefAddSourceArnConditionParams]] = pydantic.Field(None, description='Add an ``ArnEquals`` condition that limits to a given resource arn from ``aws:SourceArn``.\nThis method can only be called once: subsequent calls will overwrite earlier calls.')
    copy_: typing.Optional[list[PolicyStatementDefCopyParams]] = pydantic.Field(None, description='Create a new ``PolicyStatement`` with the same exact properties as this one, except for the overrides.', alias='copy')
    freeze: typing.Optional[list[PolicyStatementDefFreezeParams]] = pydantic.Field(None, description='Make the PolicyStatement immutable.\nAfter calling this, any of the ``addXxx()`` methods will throw an exception.\n\nLibraries that lazily generate statement bodies can override this method to\nfill the actual PolicyStatement fields. Be aware that this method may be called\nmultiple times.')
    validate_for_any_policy: typing.Optional[bool] = pydantic.Field(None, description='Validate that the policy statement satisfies base requirements for a policy.\n:return: An array of validation error messages, or an empty array if the statement is valid.')
    validate_for_identity_policy: typing.Optional[bool] = pydantic.Field(None, description='Validate that the policy statement satisfies all requirements for an identity-based policy.\n:return: An array of validation error messages, or an empty array if the statement is valid.')
    validate_for_resource_policy: typing.Optional[bool] = pydantic.Field(None, description='Validate that the policy statement satisfies all requirements for a resource-based policy.\n:return: An array of validation error messages, or an empty array if the statement is valid.')

class PolicyStatementDefAddAccountConditionParams(pydantic.BaseModel):
    account_id: str = pydantic.Field(..., description='-\n\n:see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html\n')
    ...

class PolicyStatementDefAddActionsParams(pydantic.BaseModel):
    actions: list[str] = pydantic.Field(...)
    ...

class PolicyStatementDefAddArnPrincipalParams(pydantic.BaseModel):
    arn: str = pydantic.Field(..., description='ARN identifier of AWS account, IAM user, or IAM role (i.e. arn:aws:iam::123456789012:user/user-name).')
    ...

class PolicyStatementDefAddAwsAccountPrincipalParams(pydantic.BaseModel):
    account_id: str = pydantic.Field(..., description='-')
    ...

class PolicyStatementDefAddCanonicalUserPrincipalParams(pydantic.BaseModel):
    canonical_user_id: str = pydantic.Field(..., description='unique identifier assigned by AWS for every account.')
    ...

class PolicyStatementDefAddConditionParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-')
    ...

class PolicyStatementDefAddConditionsParams(pydantic.BaseModel):
    conditions: typing.Mapping[str, typing.Any] = pydantic.Field(..., description='-')
    ...

class PolicyStatementDefAddFederatedPrincipalParams(pydantic.BaseModel):
    federated: typing.Any = pydantic.Field(..., description="federated identity provider (i.e. 'cognito-identity.amazonaws.com').\n")
    conditions: typing.Mapping[str, typing.Any] = pydantic.Field(..., description='The conditions under which the policy is in effect. See `the IAM documentation <https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition.html>`_.')
    ...

class PolicyStatementDefAddNotActionsParams(pydantic.BaseModel):
    not_actions: list[str] = pydantic.Field(...)
    ...

class PolicyStatementDefAddNotPrincipalsParams(pydantic.BaseModel):
    not_principals: list[typing.Union[models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef]] = pydantic.Field(...)
    ...

class PolicyStatementDefAddNotResourcesParams(pydantic.BaseModel):
    arns: list[str] = pydantic.Field(...)
    ...

class PolicyStatementDefAddPrincipalsParams(pydantic.BaseModel):
    principals: list[typing.Union[models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef]] = pydantic.Field(...)
    ...

class PolicyStatementDefAddResourcesParams(pydantic.BaseModel):
    arns: list[str] = pydantic.Field(...)
    ...

class PolicyStatementDefAddServicePrincipalParams(pydantic.BaseModel):
    service: str = pydantic.Field(..., description='the service name for which a service principal is requested (e.g: ``s3.amazonaws.com``).\n')
    conditions: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='Additional conditions to add to the Service Principal. Default: - No conditions\n')
    region: typing.Optional[str] = pydantic.Field(None, description="The region in which you want to reference the service. This is only necessary for *cross-region* references to *opt-in* regions. In those cases, the region name needs to be included to reference the correct service principal. In all other cases, the global service principal name is sufficient. This field behaves differently depending on whether the ``@aws-cdk/aws-iam:standardizedServicePrincipals`` flag is set or not: - If the flag is set, the input service principal is assumed to be of the form ``SERVICE.amazonaws.com``. That value will always be returned, unless the given region is an opt-in region and the service principal is rendered in a stack in a different region, in which case ``SERVICE.REGION.amazonaws.com`` will be rendered. Under this regime, there is no downside to always specifying the region property: it will be rendered only if necessary. - If the flag is not set, the service principal will resolve to a single principal whose name comes from the ``@aws-cdk/region-info`` package, using the region to override the stack region. If there is no entry for this service principal in the database,, the input service name is returned literally. This is legacy behavior and is not recommended. Default: - the resolving Stack's region.")
    ...

class PolicyStatementDefAddSourceAccountConditionParams(pydantic.BaseModel):
    account_id: str = pydantic.Field(..., description='-\n\n:see: https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#condition-keys-sourceaccount\n')
    ...

class PolicyStatementDefAddSourceArnConditionParams(pydantic.BaseModel):
    arn: str = pydantic.Field(..., description='-\n\n:see: https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#condition-keys-sourcearn\n')
    ...

class PolicyStatementDefCopyParams(pydantic.BaseModel):
    actions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of actions to add to the statement. Default: - no actions\n')
    conditions: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='Conditions to add to the statement. Default: - no condition\n')
    effect: typing.Optional[aws_cdk.aws_iam.Effect] = pydantic.Field(None, description='Whether to allow or deny the actions in this statement. Default: Effect.ALLOW\n')
    not_actions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of not actions to add to the statement. Default: - no not-actions\n')
    not_principals: typing.Optional[typing.Sequence[typing.Union[models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef]]] = pydantic.Field(None, description='List of not principals to add to the statement. Default: - no not principals\n')
    not_resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='NotResource ARNs to add to the statement. Default: - no not-resources\n')
    principals: typing.Optional[typing.Sequence[typing.Union[models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef]]] = pydantic.Field(None, description='List of principals to add to the statement. Default: - no principals\n')
    resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Resource ARNs to add to the statement. Default: - no resources\n')
    sid: typing.Optional[str] = pydantic.Field(None, description="The Sid (statement ID) is an optional identifier that you provide for the policy statement. You can assign a Sid value to each statement in a statement array. In services that let you specify an ID element, such as SQS and SNS, the Sid value is just a sub-ID of the policy document's ID. In IAM, the Sid value must be unique within a JSON policy. Default: - no sid")
    ...

class PolicyStatementDefFreezeParams(pydantic.BaseModel):
    ...

class PolicyStatementDefFromJsonParams(pydantic.BaseModel):
    obj: typing.Any = pydantic.Field(..., description='the PolicyStatement in object form.')
    ...


#  autogenerated from aws_cdk.aws_iam.PrincipalBase
class PrincipalBaseDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['add_to_assume_role_policy', 'add_to_policy', 'add_to_principal_policy', 'dedupe_string', 'with_conditions', 'with_session_tags']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.PrincipalBase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[PrincipalBaseDefConfig] = pydantic.Field(None)


class PrincipalBaseDefConfig(pydantic.BaseModel):
    add_to_assume_role_policy: typing.Optional[list[PrincipalBaseDefAddToAssumeRolePolicyParams]] = pydantic.Field(None, description='Add the principal to the AssumeRolePolicyDocument.\nAdd the statements to the AssumeRolePolicyDocument necessary to give this principal\npermissions to assume the given role.')
    add_to_policy: typing.Optional[list[PrincipalBaseDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[PrincipalBaseDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    dedupe_string: typing.Optional[bool] = pydantic.Field(None, description='Return whether or not this principal is equal to the given principal.')
    with_conditions: typing.Optional[list[PrincipalBaseDefWithConditionsParams]] = pydantic.Field(None, description='Returns a new PrincipalWithConditions using this principal as the base, with the passed conditions added.\nWhen there is a value for the same operator and key in both the principal and the\nconditions parameter, the value from the conditions parameter will be used.')
    with_session_tags: typing.Optional[list[PrincipalBaseDefWithSessionTagsParams]] = pydantic.Field(None, description='Returns a new principal using this principal as the base, with session tags enabled.\n:return: a new SessionTagsPrincipal object.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class PrincipalBaseDefAddToAssumeRolePolicyParams(pydantic.BaseModel):
    document: models.aws_iam.PolicyDocumentDef = pydantic.Field(..., description='-')
    ...

class PrincipalBaseDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class PrincipalBaseDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    _statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class PrincipalBaseDefWithConditionsParams(pydantic.BaseModel):
    conditions: typing.Mapping[str, typing.Any] = pydantic.Field(..., description='-\n')
    ...

class PrincipalBaseDefWithSessionTagsParams(pydantic.BaseModel):
    ...


#  autogenerated from aws_cdk.aws_iam.PrincipalPolicyFragment
class PrincipalPolicyFragmentDef(BaseClass):
    principal_json: typing.Union[typing.Mapping[str, typing.Sequence[str]], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='JSON of the "Principal" section in a policy statement.')
    conditions: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='The conditions under which the policy is in effect. See `the IAM documentation <https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition.html>`_. conditions that need to be applied to this policy')
    _init_params: typing.ClassVar[list[str]] = ['principal_json', 'conditions']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.PrincipalPolicyFragment'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.PrincipalWithConditions
class PrincipalWithConditionsDef(BaseClass):
    principal: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='-')
    conditions: typing.Union[typing.Mapping[str, typing.Any], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='-')
    _init_params: typing.ClassVar[list[str]] = ['principal', 'conditions']
    _method_names: typing.ClassVar[list[str]] = ['add_condition', 'add_conditions', 'add_to_assume_role_policy', 'add_to_policy', 'add_to_principal_policy', 'dedupe_string', 'with_conditions', 'with_session_tags']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.PrincipalWithConditions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[PrincipalWithConditionsDefConfig] = pydantic.Field(None)


class PrincipalWithConditionsDefConfig(pydantic.BaseModel):
    add_condition: typing.Optional[list[PrincipalWithConditionsDefAddConditionParams]] = pydantic.Field(None, description='Add a condition to the principal.')
    add_conditions: typing.Optional[list[PrincipalWithConditionsDefAddConditionsParams]] = pydantic.Field(None, description='Adds multiple conditions to the principal.\nValues from the conditions parameter will overwrite existing values with the same operator\nand key.')
    add_to_assume_role_policy: typing.Optional[list[PrincipalWithConditionsDefAddToAssumeRolePolicyParams]] = pydantic.Field(None, description='Add the principal to the AssumeRolePolicyDocument.\nAdd the statements to the AssumeRolePolicyDocument necessary to give this principal\npermissions to assume the given role.')
    add_to_policy: typing.Optional[list[PrincipalWithConditionsDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[PrincipalWithConditionsDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    dedupe_string: typing.Optional[bool] = pydantic.Field(None, description='Return whether or not this principal is equal to the given principal.')
    with_conditions: typing.Optional[list[PrincipalWithConditionsDefWithConditionsParams]] = pydantic.Field(None, description='Returns a new PrincipalWithConditions using this principal as the base, with the passed conditions added.\nWhen there is a value for the same operator and key in both the principal and the\nconditions parameter, the value from the conditions parameter will be used.')
    with_session_tags: typing.Optional[list[PrincipalWithConditionsDefWithSessionTagsParams]] = pydantic.Field(None, description='Returns a new principal using this principal as the base, with session tags enabled.\n:return: a new SessionTagsPrincipal object.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class PrincipalWithConditionsDefAddConditionParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-')
    ...

class PrincipalWithConditionsDefAddConditionsParams(pydantic.BaseModel):
    conditions: typing.Mapping[str, typing.Any] = pydantic.Field(..., description='-')
    ...

class PrincipalWithConditionsDefAddToAssumeRolePolicyParams(pydantic.BaseModel):
    document: models.aws_iam.PolicyDocumentDef = pydantic.Field(..., description='-')
    ...

class PrincipalWithConditionsDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class PrincipalWithConditionsDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class PrincipalWithConditionsDefWithConditionsParams(pydantic.BaseModel):
    conditions: typing.Mapping[str, typing.Any] = pydantic.Field(..., description='-\n')
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...

class PrincipalWithConditionsDefWithSessionTagsParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_iam.SamlConsolePrincipal
class SamlConsolePrincipalDef(BaseClass):
    saml_provider: typing.Union[_REQUIRED_INIT_PARAM, models.aws_iam.SamlProviderDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='-')
    conditions: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='The conditions under which the policy is in effect.')
    _init_params: typing.ClassVar[list[str]] = ['saml_provider', 'conditions']
    _method_names: typing.ClassVar[list[str]] = ['add_to_assume_role_policy', 'add_to_policy', 'add_to_principal_policy', 'dedupe_string', 'with_conditions', 'with_session_tags']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.SamlConsolePrincipal'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[SamlConsolePrincipalDefConfig] = pydantic.Field(None)


class SamlConsolePrincipalDefConfig(pydantic.BaseModel):
    add_to_assume_role_policy: typing.Optional[list[SamlConsolePrincipalDefAddToAssumeRolePolicyParams]] = pydantic.Field(None, description='Add the principal to the AssumeRolePolicyDocument.\nAdd the statements to the AssumeRolePolicyDocument necessary to give this principal\npermissions to assume the given role.')
    add_to_policy: typing.Optional[list[SamlConsolePrincipalDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[SamlConsolePrincipalDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    dedupe_string: typing.Optional[bool] = pydantic.Field(None, description='Return whether or not this principal is equal to the given principal.')
    with_conditions: typing.Optional[list[SamlConsolePrincipalDefWithConditionsParams]] = pydantic.Field(None, description='Returns a new PrincipalWithConditions using this principal as the base, with the passed conditions added.\nWhen there is a value for the same operator and key in both the principal and the\nconditions parameter, the value from the conditions parameter will be used.')
    with_session_tags: typing.Optional[list[SamlConsolePrincipalDefWithSessionTagsParams]] = pydantic.Field(None, description='Returns a new principal using this principal as the base, with session tags enabled.\n:return: a new SessionTagsPrincipal object.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class SamlConsolePrincipalDefAddToAssumeRolePolicyParams(pydantic.BaseModel):
    document: models.aws_iam.PolicyDocumentDef = pydantic.Field(..., description='-')
    ...

class SamlConsolePrincipalDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class SamlConsolePrincipalDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    _statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class SamlConsolePrincipalDefWithConditionsParams(pydantic.BaseModel):
    conditions: typing.Mapping[str, typing.Any] = pydantic.Field(..., description='-\n')
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...

class SamlConsolePrincipalDefWithSessionTagsParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_iam.SamlMetadataDocument
class SamlMetadataDocumentDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_file', 'from_xml']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.SamlMetadataDocument'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_file', 'from_xml']
    ...


    from_file: typing.Optional[SamlMetadataDocumentDefFromFileParams] = pydantic.Field(None, description='Create a SAML metadata document from a XML file.')
    from_xml: typing.Optional[SamlMetadataDocumentDefFromXmlParams] = pydantic.Field(None, description='Create a SAML metadata document from a XML string.')

class SamlMetadataDocumentDefFromFileParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='-')
    ...

class SamlMetadataDocumentDefFromXmlParams(pydantic.BaseModel):
    xml: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_iam.SamlPrincipal
class SamlPrincipalDef(BaseClass):
    saml_provider: typing.Union[_REQUIRED_INIT_PARAM, models.aws_iam.SamlProviderDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='-')
    conditions: typing.Union[typing.Mapping[str, typing.Any], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The conditions under which the policy is in effect.')
    _init_params: typing.ClassVar[list[str]] = ['saml_provider', 'conditions']
    _method_names: typing.ClassVar[list[str]] = ['add_to_assume_role_policy', 'add_to_policy', 'add_to_principal_policy', 'dedupe_string', 'with_conditions', 'with_session_tags']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.SamlPrincipal'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[SamlPrincipalDefConfig] = pydantic.Field(None)


class SamlPrincipalDefConfig(pydantic.BaseModel):
    add_to_assume_role_policy: typing.Optional[list[SamlPrincipalDefAddToAssumeRolePolicyParams]] = pydantic.Field(None, description='Add the principal to the AssumeRolePolicyDocument.\nAdd the statements to the AssumeRolePolicyDocument necessary to give this principal\npermissions to assume the given role.')
    add_to_policy: typing.Optional[list[SamlPrincipalDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[SamlPrincipalDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    dedupe_string: typing.Optional[bool] = pydantic.Field(None, description='Return whether or not this principal is equal to the given principal.')
    with_conditions: typing.Optional[list[SamlPrincipalDefWithConditionsParams]] = pydantic.Field(None, description='Returns a new PrincipalWithConditions using this principal as the base, with the passed conditions added.\nWhen there is a value for the same operator and key in both the principal and the\nconditions parameter, the value from the conditions parameter will be used.')
    with_session_tags: typing.Optional[list[SamlPrincipalDefWithSessionTagsParams]] = pydantic.Field(None, description='Returns a new principal using this principal as the base, with session tags enabled.\n:return: a new SessionTagsPrincipal object.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class SamlPrincipalDefAddToAssumeRolePolicyParams(pydantic.BaseModel):
    document: models.aws_iam.PolicyDocumentDef = pydantic.Field(..., description='-')
    ...

class SamlPrincipalDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class SamlPrincipalDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    _statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class SamlPrincipalDefWithConditionsParams(pydantic.BaseModel):
    conditions: typing.Mapping[str, typing.Any] = pydantic.Field(..., description='-\n')
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...

class SamlPrincipalDefWithSessionTagsParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_iam.ServicePrincipal
class ServicePrincipalDef(BaseClass):
    service: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='AWS service (i.e. sqs.amazonaws.com).\n')
    conditions: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='Additional conditions to add to the Service Principal. Default: - No conditions\n')
    region: typing.Optional[str] = pydantic.Field(None, description="The region in which you want to reference the service. This is only necessary for *cross-region* references to *opt-in* regions. In those cases, the region name needs to be included to reference the correct service principal. In all other cases, the global service principal name is sufficient. This field behaves differently depending on whether the ``@aws-cdk/aws-iam:standardizedServicePrincipals`` flag is set or not: - If the flag is set, the input service principal is assumed to be of the form ``SERVICE.amazonaws.com``. That value will always be returned, unless the given region is an opt-in region and the service principal is rendered in a stack in a different region, in which case ``SERVICE.REGION.amazonaws.com`` will be rendered. Under this regime, there is no downside to always specifying the region property: it will be rendered only if necessary. - If the flag is not set, the service principal will resolve to a single principal whose name comes from the ``@aws-cdk/region-info`` package, using the region to override the stack region. If there is no entry for this service principal in the database,, the input service name is returned literally. This is legacy behavior and is not recommended. Default: - the resolving Stack's region.")
    _init_params: typing.ClassVar[list[str]] = ['service', 'conditions', 'region']
    _method_names: typing.ClassVar[list[str]] = ['add_to_assume_role_policy', 'add_to_policy', 'add_to_principal_policy', 'dedupe_string', 'with_conditions', 'with_session_tags']
    _classmethod_names: typing.ClassVar[list[str]] = ['service_principal_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.ServicePrincipal'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ServicePrincipalDefConfig] = pydantic.Field(None)


class ServicePrincipalDefConfig(pydantic.BaseModel):
    add_to_assume_role_policy: typing.Optional[list[ServicePrincipalDefAddToAssumeRolePolicyParams]] = pydantic.Field(None, description='Add the principal to the AssumeRolePolicyDocument.\nAdd the statements to the AssumeRolePolicyDocument necessary to give this principal\npermissions to assume the given role.')
    add_to_policy: typing.Optional[list[ServicePrincipalDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[ServicePrincipalDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    dedupe_string: typing.Optional[bool] = pydantic.Field(None, description='Return whether or not this principal is equal to the given principal.')
    service_principal_name: typing.Optional[list[ServicePrincipalDefServicePrincipalNameParams]] = pydantic.Field(None, description="Return the service principal name based on the region it's used in.\nSome service principal names used to be different for different partitions,\nand some were not. This method would return the appropriate region-specific\nservice principal name, getting that information from the ``region-info``\nmodule.\n\nThese days all service principal names are standardized, and they are all\nof the form ``<servicename>.amazonaws.com``.\n\nIf the feature flag ``@aws-cdk/aws-iam:standardizedServicePrincipals`` is set, this\nmethod will always return its input. If this feature flag is not set, this\nmethod will perform the legacy behavior, which appends the region-specific\ndomain suffix for some select services (for example, it would append ``.cn``\nto some service principal names).")
    with_conditions: typing.Optional[list[ServicePrincipalDefWithConditionsParams]] = pydantic.Field(None, description='Returns a new PrincipalWithConditions using this principal as the base, with the passed conditions added.\nWhen there is a value for the same operator and key in both the principal and the\nconditions parameter, the value from the conditions parameter will be used.')
    with_session_tags: typing.Optional[list[ServicePrincipalDefWithSessionTagsParams]] = pydantic.Field(None, description='Returns a new principal using this principal as the base, with session tags enabled.\n:return: a new SessionTagsPrincipal object.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class ServicePrincipalDefAddToAssumeRolePolicyParams(pydantic.BaseModel):
    document: models.aws_iam.PolicyDocumentDef = pydantic.Field(..., description='-')
    ...

class ServicePrincipalDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class ServicePrincipalDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    _statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class ServicePrincipalDefServicePrincipalNameParams(pydantic.BaseModel):
    service: str = pydantic.Field(..., description='-\n\nExample::\n\n    principal_name = iam.ServicePrincipal.service_principal_name("ec2.amazonaws.com")\n')
    ...

class ServicePrincipalDefWithConditionsParams(pydantic.BaseModel):
    conditions: typing.Mapping[str, typing.Any] = pydantic.Field(..., description='-\n')
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...

class ServicePrincipalDefWithSessionTagsParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_iam.SessionTagsPrincipal
class SessionTagsPrincipalDef(BaseClass):
    principal: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='-')
    _init_params: typing.ClassVar[list[str]] = ['principal']
    _method_names: typing.ClassVar[list[str]] = ['add_to_assume_role_policy', 'add_to_policy', 'add_to_principal_policy', 'dedupe_string', 'with_conditions', 'with_session_tags']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.SessionTagsPrincipal'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[SessionTagsPrincipalDefConfig] = pydantic.Field(None)


class SessionTagsPrincipalDefConfig(pydantic.BaseModel):
    add_to_assume_role_policy: typing.Optional[list[SessionTagsPrincipalDefAddToAssumeRolePolicyParams]] = pydantic.Field(None, description='Add the principal to the AssumeRolePolicyDocument.\nAdd the statements to the AssumeRolePolicyDocument necessary to give this principal\npermissions to assume the given role.')
    add_to_policy: typing.Optional[list[SessionTagsPrincipalDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[SessionTagsPrincipalDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    dedupe_string: typing.Optional[bool] = pydantic.Field(None, description='Return whether or not this principal is equal to the given principal.')
    with_conditions: typing.Optional[list[SessionTagsPrincipalDefWithConditionsParams]] = pydantic.Field(None, description='Returns a new PrincipalWithConditions using this principal as the base, with the passed conditions added.\nWhen there is a value for the same operator and key in both the principal and the\nconditions parameter, the value from the conditions parameter will be used.')
    with_session_tags: typing.Optional[list[SessionTagsPrincipalDefWithSessionTagsParams]] = pydantic.Field(None, description='Returns a new principal using this principal as the base, with session tags enabled.\n:return: a new SessionTagsPrincipal object.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class SessionTagsPrincipalDefAddToAssumeRolePolicyParams(pydantic.BaseModel):
    doc: models.aws_iam.PolicyDocumentDef = pydantic.Field(..., description='-')
    ...

class SessionTagsPrincipalDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class SessionTagsPrincipalDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class SessionTagsPrincipalDefWithConditionsParams(pydantic.BaseModel):
    conditions: typing.Mapping[str, typing.Any] = pydantic.Field(..., description='-\n')
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...

class SessionTagsPrincipalDefWithSessionTagsParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_iam.StarPrincipal
class StarPrincipalDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['add_to_assume_role_policy', 'add_to_policy', 'add_to_principal_policy', 'dedupe_string', 'with_conditions', 'with_session_tags']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.StarPrincipal'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[StarPrincipalDefConfig] = pydantic.Field(None)


class StarPrincipalDefConfig(pydantic.BaseModel):
    add_to_assume_role_policy: typing.Optional[list[StarPrincipalDefAddToAssumeRolePolicyParams]] = pydantic.Field(None, description='Add the principal to the AssumeRolePolicyDocument.\nAdd the statements to the AssumeRolePolicyDocument necessary to give this principal\npermissions to assume the given role.')
    add_to_policy: typing.Optional[list[StarPrincipalDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[StarPrincipalDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    dedupe_string: typing.Optional[bool] = pydantic.Field(None, description='Return whether or not this principal is equal to the given principal.')
    with_conditions: typing.Optional[list[StarPrincipalDefWithConditionsParams]] = pydantic.Field(None, description='Returns a new PrincipalWithConditions using this principal as the base, with the passed conditions added.\nWhen there is a value for the same operator and key in both the principal and the\nconditions parameter, the value from the conditions parameter will be used.')
    with_session_tags: typing.Optional[list[StarPrincipalDefWithSessionTagsParams]] = pydantic.Field(None, description='Returns a new principal using this principal as the base, with session tags enabled.\n:return: a new SessionTagsPrincipal object.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class StarPrincipalDefAddToAssumeRolePolicyParams(pydantic.BaseModel):
    document: models.aws_iam.PolicyDocumentDef = pydantic.Field(..., description='-')
    ...

class StarPrincipalDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class StarPrincipalDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    _statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class StarPrincipalDefWithConditionsParams(pydantic.BaseModel):
    conditions: typing.Mapping[str, typing.Any] = pydantic.Field(..., description='-\n')
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...

class StarPrincipalDefWithSessionTagsParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_iam.UnknownPrincipal
class UnknownPrincipalDef(BaseClass):
    resource: typing.Union[models.AnyResource, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The resource the role proxy is for.')
    _init_params: typing.ClassVar[list[str]] = ['resource']
    _method_names: typing.ClassVar[list[str]] = ['add_to_policy', 'add_to_principal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.UnknownPrincipal'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[UnknownPrincipalDefConfig] = pydantic.Field(None)


class UnknownPrincipalDefConfig(pydantic.BaseModel):
    add_to_policy: typing.Optional[list[UnknownPrincipalDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[UnknownPrincipalDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class UnknownPrincipalDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class UnknownPrincipalDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_iam.WebIdentityPrincipal
class WebIdentityPrincipalDef(BaseClass):
    identity_provider: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="identity provider (i.e. 'cognito-identity.amazonaws.com' for users authenticated through Cognito).")
    conditions: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='The conditions under which the policy is in effect. See `the IAM documentation <https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition.html>`_.')
    _init_params: typing.ClassVar[list[str]] = ['identity_provider', 'conditions']
    _method_names: typing.ClassVar[list[str]] = ['add_to_assume_role_policy', 'add_to_policy', 'add_to_principal_policy', 'dedupe_string', 'with_conditions', 'with_session_tags']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.WebIdentityPrincipal'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[WebIdentityPrincipalDefConfig] = pydantic.Field(None)


class WebIdentityPrincipalDefConfig(pydantic.BaseModel):
    add_to_assume_role_policy: typing.Optional[list[WebIdentityPrincipalDefAddToAssumeRolePolicyParams]] = pydantic.Field(None, description='Add the principal to the AssumeRolePolicyDocument.\nAdd the statements to the AssumeRolePolicyDocument necessary to give this principal\npermissions to assume the given role.')
    add_to_policy: typing.Optional[list[WebIdentityPrincipalDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[WebIdentityPrincipalDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    dedupe_string: typing.Optional[bool] = pydantic.Field(None, description='Return whether or not this principal is equal to the given principal.')
    with_conditions: typing.Optional[list[WebIdentityPrincipalDefWithConditionsParams]] = pydantic.Field(None, description='Returns a new PrincipalWithConditions using this principal as the base, with the passed conditions added.\nWhen there is a value for the same operator and key in both the principal and the\nconditions parameter, the value from the conditions parameter will be used.')
    with_session_tags: typing.Optional[list[WebIdentityPrincipalDefWithSessionTagsParams]] = pydantic.Field(None, description='Returns a new principal using this principal as the base, with session tags enabled.\n:return: a new SessionTagsPrincipal object.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class WebIdentityPrincipalDefAddToAssumeRolePolicyParams(pydantic.BaseModel):
    document: models.aws_iam.PolicyDocumentDef = pydantic.Field(..., description='-')
    ...

class WebIdentityPrincipalDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class WebIdentityPrincipalDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    _statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class WebIdentityPrincipalDefWithConditionsParams(pydantic.BaseModel):
    conditions: typing.Mapping[str, typing.Any] = pydantic.Field(..., description='-\n')
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...

class WebIdentityPrincipalDefWithSessionTagsParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_iam.PrincipalBaseDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_iam.AccessKey
class AccessKeyDef(BaseConstruct):
    user: typing.Union[_REQUIRED_INIT_PARAM, models.aws_iam.UserDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The IAM user this key will belong to. Changing this value will result in the access key being deleted and a new access key (with a different ID and secret value) being assigned to the new user.\n')
    serial: typing.Union[int, float, None] = pydantic.Field(None, description='A CloudFormation-specific value that signifies the access key should be replaced/rotated. This value can only be incremented. Incrementing this value will cause CloudFormation to replace the Access Key resource. Default: - No serial value\n')
    status: typing.Optional[aws_cdk.aws_iam.AccessKeyStatus] = pydantic.Field(None, description='The status of the access key. An Active access key is allowed to be used to make API calls; An Inactive key cannot. Default: - The access key is active')
    _init_params: typing.ClassVar[list[str]] = ['user', 'serial', 'status']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.AccessKey'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AccessKeyDefConfig] = pydantic.Field(None)


class AccessKeyDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    secret_access_key_config: typing.Optional[models.core.SecretValueDefConfig] = pydantic.Field(None)

class AccessKeyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_iam.Group
class GroupDef(BaseConstruct):
    group_name: typing.Optional[str] = pydantic.Field(None, description="A name for the IAM group. For valid values, see the GroupName parameter for the CreateGroup action in the IAM API Reference. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the group name. If you specify a name, you must specify the CAPABILITY_NAMED_IAM value to acknowledge your template's capabilities. For more information, see Acknowledging IAM Resources in AWS CloudFormation Templates. Default: Generated by CloudFormation (recommended)\n")
    managed_policies: typing.Optional[typing.Sequence[typing.Union[models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_iam.ManagedPolicyDef]]] = pydantic.Field(None, description='A list of managed policies associated with this role. You can add managed policies later using ``addManagedPolicy(ManagedPolicy.fromAwsManagedPolicyName(policyName))``. Default: - No managed policies.\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path to the group. For more information about paths, see `IAM Identifiers <http://docs.aws.amazon.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html>`_ in the IAM User Guide. Default: /')
    _init_params: typing.ClassVar[list[str]] = ['group_name', 'managed_policies', 'path']
    _method_names: typing.ClassVar[list[str]] = ['add_managed_policy', 'add_to_policy', 'add_to_principal_policy', 'add_user', 'apply_removal_policy', 'attach_inline_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_group_arn', 'from_group_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.Group'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_group_arn', 'from_group_name']
    ...


    from_group_arn: typing.Optional[GroupDefFromGroupArnParams] = pydantic.Field(None, description='Import an external group by ARN.\nIf the imported Group ARN is a Token (such as a\n``CfnParameter.valueAsString`` or a ``Fn.importValue()``) *and* the referenced\ngroup has a ``path`` (like ``arn:...:group/AdminGroup/NetworkAdmin``), the\n``groupName`` property will not resolve to the correct value. Instead it\nwill resolve to the first path component. We unfortunately cannot express\nthe correct calculation of the full path name as a CloudFormation\nexpression. In this scenario the Group ARN should be supplied without the\n``path`` in order to resolve the correct group resource.')
    from_group_name: typing.Optional[GroupDefFromGroupNameParams] = pydantic.Field(None, description='Import an existing group by given name (with path).\nThis method has same caveats of ``fromGroupArn``')
    resource_config: typing.Optional[GroupDefConfig] = pydantic.Field(None)


class GroupDefConfig(pydantic.BaseModel):
    add_managed_policy: typing.Optional[list[GroupDefAddManagedPolicyParams]] = pydantic.Field(None, description='Attaches a managed policy to this group.\nSee [IAM and AWS STS quotas, name requirements, and character limits]\n(https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entities)\nfor quota of managed policies attached to an IAM group.')
    add_to_policy: typing.Optional[list[GroupDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[GroupDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description='Adds an IAM statement to the default policy.')
    add_user: typing.Optional[list[GroupDefAddUserParams]] = pydantic.Field(None, description='Adds a user to this group.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    attach_inline_policy: typing.Optional[list[GroupDefAttachInlinePolicyParams]] = pydantic.Field(None, description='Attaches a policy to this group.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class GroupDefAddManagedPolicyParams(pydantic.BaseModel):
    policy: typing.Union[models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_iam.ManagedPolicyDef] = pydantic.Field(..., description='The managed policy to attach.')
    ...

class GroupDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class GroupDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class GroupDefAddUserParams(pydantic.BaseModel):
    user: typing.Union[models.aws_iam.UserDef] = pydantic.Field(..., description='-')
    ...

class GroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class GroupDefAttachInlinePolicyParams(pydantic.BaseModel):
    policy: models.aws_iam.PolicyDef = pydantic.Field(..., description='The policy to attach.')
    ...

class GroupDefFromGroupArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='construct scope.\n')
    id: str = pydantic.Field(..., description='construct id.\n')
    group_arn: str = pydantic.Field(..., description='the ARN of the group to import (e.g. ``arn:aws:iam::account-id:group/group-name``).')
    ...

class GroupDefFromGroupNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='construct scope.\n')
    id: str = pydantic.Field(..., description='construct id.\n')
    group_name: str = pydantic.Field(..., description='the groupName (path included) of the existing group to import.')
    ...


#  autogenerated from aws_cdk.aws_iam.InstanceProfile
class InstanceProfileDef(BaseConstruct):
    instance_profile_name: typing.Optional[str] = pydantic.Field(None, description='The name of the InstanceProfile to create. Default: - generated by CloudFormation\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path to the InstanceProfile. Default: /\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role to associate with the instance profile that is used by EC2 instances. The role must be assumable by the service principal ``ec2.amazonaws.com``: Default: - a role will be automatically created, it can be accessed via the ``role`` property')
    _init_params: typing.ClassVar[list[str]] = ['instance_profile_name', 'path', 'role']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_instance_profile_arn', 'from_instance_profile_attributes', 'from_instance_profile_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.InstanceProfile'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_instance_profile_arn', 'from_instance_profile_attributes', 'from_instance_profile_name']
    ...


    from_instance_profile_arn: typing.Optional[InstanceProfileDefFromInstanceProfileArnParams] = pydantic.Field(None, description='Import an existing InstanceProfile from an InstanceProfile ARN.\nIf the ARN comes from a Token, the InstanceProfile cannot have a path; if so, any attempt\nto reference its instanceProfileName will fail.')
    from_instance_profile_attributes: typing.Optional[InstanceProfileDefFromInstanceProfileAttributesParams] = pydantic.Field(None, description='Import an existing InstanceProfile from given InstanceProfile attributes.\nIf the ARN comes from a Token, the InstanceProfile cannot have a path; if so, any attempt\nto reference its instanceProfileName will fail.')
    from_instance_profile_name: typing.Optional[InstanceProfileDefFromInstanceProfileNameParams] = pydantic.Field(None, description='Import an existing InstanceProfile from an InstanceProfile name.')
    resource_config: typing.Optional[InstanceProfileDefConfig] = pydantic.Field(None)


class InstanceProfileDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class InstanceProfileDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class InstanceProfileDefFromInstanceProfileArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='construct scope.\n')
    id: str = pydantic.Field(..., description='construct id.\n')
    instance_profile_arn: str = pydantic.Field(..., description='the ARN of the exiting InstanceProfile to import.')
    ...

class InstanceProfileDefFromInstanceProfileAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='construct scope.\n')
    id: str = pydantic.Field(..., description='construct id.\n')
    instance_profile_arn: str = pydantic.Field(..., description='The ARN of the InstanceProfile. Format: arn::iam:::instance-profile/\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The role associated with the InstanceProfile. Default: - no role')
    ...

class InstanceProfileDefFromInstanceProfileNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='construct scope.\n')
    id: str = pydantic.Field(..., description='construct id.\n')
    instance_profile_name: str = pydantic.Field(..., description='the name of the existing InstanceProfile to import.')
    ...


#  autogenerated from aws_cdk.aws_iam.LazyRole
class LazyRoleDef(BaseConstruct):
    assumed_by: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef] = pydantic.Field(REQUIRED_INIT_PARAM, description="The IAM principal (i.e. ``new ServicePrincipal('sns.amazonaws.com')``) which can assume this role. You can later modify the assume role policy document by accessing it via the ``assumeRolePolicy`` property.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the role. It can be up to 1000 characters long. Default: - No description.\n')
    external_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of IDs that the role assumer needs to provide one of when assuming this role. If the configured and provided external IDs do not match, the AssumeRole operation will fail. Default: No external ID required\n')
    inline_policies: typing.Optional[typing.Mapping[str, models.aws_iam.PolicyDocumentDef]] = pydantic.Field(None, description='A list of named policies to inline into this role. These policies will be created with the role, whereas those added by ``addToPolicy`` are added using a separate CloudFormation resource (allowing a way around circular dependencies that could otherwise be introduced). Default: - No policy is inlined in the Role resource.\n')
    managed_policies: typing.Optional[typing.Sequence[typing.Union[models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_iam.ManagedPolicyDef]]] = pydantic.Field(None, description='A list of managed policies associated with this role. You can add managed policies later using ``addManagedPolicy(ManagedPolicy.fromAwsManagedPolicyName(policyName))``. Default: - No managed policies.\n')
    max_session_duration: typing.Optional[models.DurationDef] = pydantic.Field(None, description="The maximum session duration that you want to set for the specified role. This setting can have a value from 1 hour (3600sec) to 12 (43200sec) hours. Anyone who assumes the role from the AWS CLI or API can use the DurationSeconds API parameter or the duration-seconds CLI parameter to request a longer session. The MaxSessionDuration setting determines the maximum duration that can be requested using the DurationSeconds parameter. If users don't specify a value for the DurationSeconds parameter, their security credentials are valid for one hour by default. This applies when you use the AssumeRole* API operations or the assume-role* CLI operations but does not apply when you use those operations to create a console URL. Default: Duration.hours(1)\n")
    path: typing.Optional[str] = pydantic.Field(None, description='The path associated with this role. For information about IAM paths, see Friendly Names and Paths in IAM User Guide. Default: /\n')
    permissions_boundary: typing.Optional[typing.Union[models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_iam.ManagedPolicyDef]] = pydantic.Field(None, description="AWS supports permissions boundaries for IAM entities (users or roles). A permissions boundary is an advanced feature for using a managed policy to set the maximum permissions that an identity-based policy can grant to an IAM entity. An entity's permissions boundary allows it to perform only the actions that are allowed by both its identity-based policies and its permissions boundaries. Default: - No permissions boundary.\n")
    role_name: typing.Optional[str] = pydantic.Field(None, description="A name for the IAM role. For valid values, see the RoleName parameter for the CreateRole action in the IAM API Reference. IMPORTANT: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name. If you specify a name, you must specify the CAPABILITY_NAMED_IAM value to acknowledge your template's capabilities. For more information, see Acknowledging IAM Resources in AWS CloudFormation Templates. Default: - AWS CloudFormation generates a unique physical ID and uses that ID for the role name.")
    _init_params: typing.ClassVar[list[str]] = ['assumed_by', 'description', 'external_ids', 'inline_policies', 'managed_policies', 'max_session_duration', 'path', 'permissions_boundary', 'role_name']
    _method_names: typing.ClassVar[list[str]] = ['add_managed_policy', 'add_to_policy', 'add_to_principal_policy', 'apply_removal_policy', 'attach_inline_policy', 'grant', 'grant_assume_role', 'grant_pass_role']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.LazyRole'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[LazyRoleDefConfig] = pydantic.Field(None)


class LazyRoleDefConfig(pydantic.BaseModel):
    add_managed_policy: typing.Optional[list[LazyRoleDefAddManagedPolicyParams]] = pydantic.Field(None, description='Attaches a managed policy to this role.')
    add_to_policy: typing.Optional[list[LazyRoleDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[LazyRoleDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description="Adds a permission to the role's default policy document.\nIf there is no default policy attached to this role, it will be created.")
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    attach_inline_policy: typing.Optional[list[LazyRoleDefAttachInlinePolicyParams]] = pydantic.Field(None, description='Attaches a policy to this role.')
    grant: typing.Optional[list[LazyRoleDefGrantParams]] = pydantic.Field(None, description='Grant the actions defined in actions to the identity Principal on this resource.')
    grant_assume_role: typing.Optional[list[LazyRoleDefGrantAssumeRoleParams]] = pydantic.Field(None, description='Grant permissions to the given principal to assume this role.')
    grant_pass_role: typing.Optional[list[LazyRoleDefGrantPassRoleParams]] = pydantic.Field(None, description='Grant permissions to the given principal to pass this role.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class LazyRoleDefAddManagedPolicyParams(pydantic.BaseModel):
    policy: typing.Union[models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_iam.ManagedPolicyDef] = pydantic.Field(..., description='The managed policy to attach.')
    ...

class LazyRoleDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class LazyRoleDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='The permission statement to add to the policy document.')
    ...

class LazyRoleDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class LazyRoleDefAttachInlinePolicyParams(pydantic.BaseModel):
    policy: models.aws_iam.PolicyDef = pydantic.Field(..., description='The policy to attach.')
    ...

class LazyRoleDefGrantParams(pydantic.BaseModel):
    identity: typing.Union[models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef] = pydantic.Field(..., description='-\n')
    actions: list[str] = pydantic.Field(...)
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class LazyRoleDefGrantAssumeRoleParams(pydantic.BaseModel):
    identity: typing.Union[models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class LazyRoleDefGrantPassRoleParams(pydantic.BaseModel):
    identity: typing.Union[models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_iam.ManagedPolicy
class ManagedPolicyDef(BaseConstruct):
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the managed policy. Typically used to store information about the permissions defined in the policy. For example, "Grants access to production DynamoDB tables." The policy description is immutable. After a value is assigned, it cannot be changed. Default: - empty\n')
    document: typing.Optional[models.aws_iam.PolicyDocumentDef] = pydantic.Field(None, description='Initial PolicyDocument to use for this ManagedPolicy. If omited, any ``PolicyStatement`` provided in the ``statements`` property will be applied against the empty default ``PolicyDocument``. Default: - An empty policy.\n')
    groups: typing.Optional[typing.Sequence[typing.Union[models.aws_iam.GroupDef]]] = pydantic.Field(None, description='Groups to attach this policy to. You can also use ``attachToGroup(group)`` to attach this policy to a group. Default: - No groups.\n')
    managed_policy_name: typing.Optional[str] = pydantic.Field(None, description='The name of the managed policy. If you specify multiple policies for an entity, specify unique names. For example, if you specify a list of policies for an IAM role, each policy must have a unique name. Default: - A name is automatically generated.\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path for the policy. This parameter allows (through its regex pattern) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\\u0021) through the DEL character (\\u007F), including most punctuation characters, digits, and upper and lowercased letters. For more information about paths, see IAM Identifiers in the IAM User Guide. Default: - "/"\n')
    roles: typing.Optional[typing.Sequence[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]]] = pydantic.Field(None, description='Roles to attach this policy to. You can also use ``attachToRole(role)`` to attach this policy to a role. Default: - No roles.\n')
    statements: typing.Optional[typing.Sequence[models.aws_iam.PolicyStatementDef]] = pydantic.Field(None, description='Initial set of permissions to add to this policy document. You can also use ``addPermission(statement)`` to add permissions later. Default: - No statements.\n')
    users: typing.Optional[typing.Sequence[typing.Union[models.aws_iam.UserDef]]] = pydantic.Field(None, description='Users to attach this policy to. You can also use ``attachToUser(user)`` to attach this policy to a user. Default: - No users.')
    _init_params: typing.ClassVar[list[str]] = ['description', 'document', 'groups', 'managed_policy_name', 'path', 'roles', 'statements', 'users']
    _method_names: typing.ClassVar[list[str]] = ['add_statements', 'apply_removal_policy', 'attach_to_group', 'attach_to_role', 'attach_to_user']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_aws_managed_policy_name', 'from_managed_policy_arn', 'from_managed_policy_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.ManagedPolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_aws_managed_policy_name', 'from_managed_policy_arn', 'from_managed_policy_name']
    ...


    from_aws_managed_policy_name: typing.Optional[ManagedPolicyDefFromAwsManagedPolicyNameParams] = pydantic.Field(None, description='Import a managed policy from one of the policies that AWS manages.\nFor this managed policy, you only need to know the name to be able to use it.\n\nSome managed policy names start with "service-role/", some start with\n"job-function/", and some don\'t start with anything. Include the\nprefix when constructing this object.')
    from_managed_policy_arn: typing.Optional[ManagedPolicyDefFromManagedPolicyArnParams] = pydantic.Field(None, description='Import an external managed policy by ARN.\nFor this managed policy, you only need to know the ARN to be able to use it.\nThis can be useful if you got the ARN from a CloudFormation Export.\n\nIf the imported Managed Policy ARN is a Token (such as a\n``CfnParameter.valueAsString`` or a ``Fn.importValue()``) *and* the referenced\nmanaged policy has a ``path`` (like ``arn:...:policy/AdminPolicy/AdminAllow``), the\n``managedPolicyName`` property will not resolve to the correct value. Instead it\nwill resolve to the first path component. We unfortunately cannot express\nthe correct calculation of the full path name as a CloudFormation\nexpression. In this scenario the Managed Policy ARN should be supplied without the\n``path`` in order to resolve the correct managed policy resource.')
    from_managed_policy_name: typing.Optional[ManagedPolicyDefFromManagedPolicyNameParams] = pydantic.Field(None, description='Import a customer managed policy from the managedPolicyName.\nFor this managed policy, you only need to know the name to be able to use it.')
    resource_config: typing.Optional[ManagedPolicyDefConfig] = pydantic.Field(None)


class ManagedPolicyDefConfig(pydantic.BaseModel):
    add_statements: typing.Optional[list[ManagedPolicyDefAddStatementsParams]] = pydantic.Field(None, description='Adds a statement to the policy document.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    attach_to_group: typing.Optional[list[ManagedPolicyDefAttachToGroupParams]] = pydantic.Field(None, description='Attaches this policy to a group.')
    attach_to_role: typing.Optional[list[ManagedPolicyDefAttachToRoleParams]] = pydantic.Field(None, description='Attaches this policy to a role.')
    attach_to_user: typing.Optional[list[ManagedPolicyDefAttachToUserParams]] = pydantic.Field(None, description='Attaches this policy to a user.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class ManagedPolicyDefAddStatementsParams(pydantic.BaseModel):
    statement: list[models.aws_iam.PolicyStatementDef] = pydantic.Field(...)
    ...

class ManagedPolicyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class ManagedPolicyDefAttachToGroupParams(pydantic.BaseModel):
    group: typing.Union[models.aws_iam.GroupDef] = pydantic.Field(..., description='-')
    ...

class ManagedPolicyDefAttachToRoleParams(pydantic.BaseModel):
    role: typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef] = pydantic.Field(..., description='-')
    ...

class ManagedPolicyDefAttachToUserParams(pydantic.BaseModel):
    user: typing.Union[models.aws_iam.UserDef] = pydantic.Field(..., description='-')
    ...

class ManagedPolicyDefFromAwsManagedPolicyNameParams(pydantic.BaseModel):
    managed_policy_name: str = pydantic.Field(..., description='-')
    ...

class ManagedPolicyDefFromManagedPolicyArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='construct scope.\n')
    id: str = pydantic.Field(..., description='construct id.\n')
    managed_policy_arn: str = pydantic.Field(..., description='the ARN of the managed policy to import.')
    ...

class ManagedPolicyDefFromManagedPolicyNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    managed_policy_name: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_iam.OpenIdConnectProvider
class OpenIdConnectProviderDef(BaseConstruct):
    url: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The URL of the identity provider. The URL must begin with https:// and should correspond to the iss claim in the provider's OpenID Connect ID tokens. Per the OIDC standard, path components are allowed but query parameters are not. Typically the URL consists of only a hostname, like https://server.example.org or https://example.com. You cannot register the same provider multiple times in a single AWS account. If you try to submit a URL that has already been used for an OpenID Connect provider in the AWS account, you will get an error.\n")
    client_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="A list of client IDs (also known as audiences). When a mobile or web app registers with an OpenID Connect provider, they establish a value that identifies the application. (This is the value that's sent as the client_id parameter on OAuth requests.) You can register multiple client IDs with the same provider. For example, you might have multiple applications that use the same OIDC provider. You cannot register more than 100 client IDs with a single IAM OIDC provider. Client IDs are up to 255 characters long. Default: - no clients are allowed\n")
    thumbprints: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="A list of server certificate thumbprints for the OpenID Connect (OIDC) identity provider's server certificates. Typically this list includes only one entry. However, IAM lets you have up to five thumbprints for an OIDC provider. This lets you maintain multiple thumbprints if the identity provider is rotating certificates. The server certificate thumbprint is the hex-encoded SHA-1 hash value of the X.509 certificate used by the domain where the OpenID Connect provider makes its keys available. It is always a 40-character string. You must provide at least one thumbprint when creating an IAM OIDC provider. For example, assume that the OIDC provider is server.example.com and the provider stores its keys at https://keys.server.example.com/openid-connect. In that case, the thumbprint string would be the hex-encoded SHA-1 hash value of the certificate used by https://keys.server.example.com. Default: - If no thumbprints are specified (an empty array or ``undefined``), the thumbprint of the root certificate authority will be obtained from the provider's server as described in https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_create_oidc_verify-thumbprint.html")
    _init_params: typing.ClassVar[list[str]] = ['url', 'client_ids', 'thumbprints']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_open_id_connect_provider_arn']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.OpenIdConnectProvider'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_open_id_connect_provider_arn']
    ...


    from_open_id_connect_provider_arn: typing.Optional[OpenIdConnectProviderDefFromOpenIdConnectProviderArnParams] = pydantic.Field(None, description='Imports an Open ID connect provider from an ARN.')
    resource_config: typing.Optional[OpenIdConnectProviderDefConfig] = pydantic.Field(None)


class OpenIdConnectProviderDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class OpenIdConnectProviderDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class OpenIdConnectProviderDefFromOpenIdConnectProviderArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The definition scope.\n')
    id: str = pydantic.Field(..., description='ID of the construct.\n')
    open_id_connect_provider_arn: str = pydantic.Field(..., description='the ARN to import.')
    ...


#  autogenerated from aws_cdk.aws_iam.Policy
class PolicyDef(BaseConstruct):
    document: typing.Optional[models.aws_iam.PolicyDocumentDef] = pydantic.Field(None, description='Initial PolicyDocument to use for this Policy. If omited, any ``PolicyStatement`` provided in the ``statements`` property will be applied against the empty default ``PolicyDocument``. Default: - An empty policy.\n')
    force: typing.Optional[bool] = pydantic.Field(None, description='Force creation of an ``AWS::IAM::Policy``. Unless set to ``true``, this ``Policy`` construct will not materialize to an ``AWS::IAM::Policy`` CloudFormation resource in case it would have no effect (for example, if it remains unattached to an IAM identity or if it has no statements). This is generally desired behavior, since it prevents creating invalid--and hence undeployable--CloudFormation templates. In cases where you know the policy must be created and it is actually an error if no statements have been added to it, you can set this to ``true``. Default: false\n')
    groups: typing.Optional[typing.Sequence[typing.Union[models.aws_iam.GroupDef]]] = pydantic.Field(None, description='Groups to attach this policy to. You can also use ``attachToGroup(group)`` to attach this policy to a group. Default: - No groups.\n')
    policy_name: typing.Optional[str] = pydantic.Field(None, description='The name of the policy. If you specify multiple policies for an entity, specify unique names. For example, if you specify a list of policies for an IAM role, each policy must have a unique name. Default: - Uses the logical ID of the policy resource, which is ensured to be unique within the stack.\n')
    roles: typing.Optional[typing.Sequence[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]]] = pydantic.Field(None, description='Roles to attach this policy to. You can also use ``attachToRole(role)`` to attach this policy to a role. Default: - No roles.\n')
    statements: typing.Optional[typing.Sequence[models.aws_iam.PolicyStatementDef]] = pydantic.Field(None, description='Initial set of permissions to add to this policy document. You can also use ``addStatements(...statement)`` to add permissions later. Default: - No statements.\n')
    users: typing.Optional[typing.Sequence[typing.Union[models.aws_iam.UserDef]]] = pydantic.Field(None, description='Users to attach this policy to. You can also use ``attachToUser(user)`` to attach this policy to a user. Default: - No users.')
    _init_params: typing.ClassVar[list[str]] = ['document', 'force', 'groups', 'policy_name', 'roles', 'statements', 'users']
    _method_names: typing.ClassVar[list[str]] = ['add_statements', 'apply_removal_policy', 'attach_to_group', 'attach_to_role', 'attach_to_user']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_policy_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.Policy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_policy_name']
    ...


    from_policy_name: typing.Optional[PolicyDefFromPolicyNameParams] = pydantic.Field(None, description='Import a policy in this app based on its name.')
    resource_config: typing.Optional[PolicyDefConfig] = pydantic.Field(None)


class PolicyDefConfig(pydantic.BaseModel):
    add_statements: typing.Optional[list[PolicyDefAddStatementsParams]] = pydantic.Field(None, description='Adds a statement to the policy document.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    attach_to_group: typing.Optional[list[PolicyDefAttachToGroupParams]] = pydantic.Field(None, description='Attaches this policy to a group.')
    attach_to_role: typing.Optional[list[PolicyDefAttachToRoleParams]] = pydantic.Field(None, description='Attaches this policy to a role.')
    attach_to_user: typing.Optional[list[PolicyDefAttachToUserParams]] = pydantic.Field(None, description='Attaches this policy to a user.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class PolicyDefAddStatementsParams(pydantic.BaseModel):
    statement: list[models.aws_iam.PolicyStatementDef] = pydantic.Field(...)
    ...

class PolicyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class PolicyDefAttachToGroupParams(pydantic.BaseModel):
    group: typing.Union[models.aws_iam.GroupDef] = pydantic.Field(..., description='-')
    ...

class PolicyDefAttachToRoleParams(pydantic.BaseModel):
    role: typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef] = pydantic.Field(..., description='-')
    ...

class PolicyDefAttachToUserParams(pydantic.BaseModel):
    user: typing.Union[models.aws_iam.UserDef] = pydantic.Field(..., description='-')
    ...

class PolicyDefFromPolicyNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    policy_name: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_iam.Role
class RoleDef(BaseConstruct):
    assumed_by: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef] = pydantic.Field(REQUIRED_INIT_PARAM, description="The IAM principal (i.e. ``new ServicePrincipal('sns.amazonaws.com')``) which can assume this role. You can later modify the assume role policy document by accessing it via the ``assumeRolePolicy`` property.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the role. It can be up to 1000 characters long. Default: - No description.\n')
    external_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of IDs that the role assumer needs to provide one of when assuming this role. If the configured and provided external IDs do not match, the AssumeRole operation will fail. Default: No external ID required\n')
    inline_policies: typing.Optional[typing.Mapping[str, models.aws_iam.PolicyDocumentDef]] = pydantic.Field(None, description='A list of named policies to inline into this role. These policies will be created with the role, whereas those added by ``addToPolicy`` are added using a separate CloudFormation resource (allowing a way around circular dependencies that could otherwise be introduced). Default: - No policy is inlined in the Role resource.\n')
    managed_policies: typing.Optional[typing.Sequence[typing.Union[models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_iam.ManagedPolicyDef]]] = pydantic.Field(None, description='A list of managed policies associated with this role. You can add managed policies later using ``addManagedPolicy(ManagedPolicy.fromAwsManagedPolicyName(policyName))``. Default: - No managed policies.\n')
    max_session_duration: typing.Optional[models.DurationDef] = pydantic.Field(None, description="The maximum session duration that you want to set for the specified role. This setting can have a value from 1 hour (3600sec) to 12 (43200sec) hours. Anyone who assumes the role from the AWS CLI or API can use the DurationSeconds API parameter or the duration-seconds CLI parameter to request a longer session. The MaxSessionDuration setting determines the maximum duration that can be requested using the DurationSeconds parameter. If users don't specify a value for the DurationSeconds parameter, their security credentials are valid for one hour by default. This applies when you use the AssumeRole* API operations or the assume-role* CLI operations but does not apply when you use those operations to create a console URL. Default: Duration.hours(1)\n")
    path: typing.Optional[str] = pydantic.Field(None, description='The path associated with this role. For information about IAM paths, see Friendly Names and Paths in IAM User Guide. Default: /\n')
    permissions_boundary: typing.Optional[typing.Union[models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_iam.ManagedPolicyDef]] = pydantic.Field(None, description="AWS supports permissions boundaries for IAM entities (users or roles). A permissions boundary is an advanced feature for using a managed policy to set the maximum permissions that an identity-based policy can grant to an IAM entity. An entity's permissions boundary allows it to perform only the actions that are allowed by both its identity-based policies and its permissions boundaries. Default: - No permissions boundary.\n")
    role_name: typing.Optional[str] = pydantic.Field(None, description="A name for the IAM role. For valid values, see the RoleName parameter for the CreateRole action in the IAM API Reference. IMPORTANT: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name. If you specify a name, you must specify the CAPABILITY_NAMED_IAM value to acknowledge your template's capabilities. For more information, see Acknowledging IAM Resources in AWS CloudFormation Templates. Default: - AWS CloudFormation generates a unique physical ID and uses that ID for the role name.")
    _init_params: typing.ClassVar[list[str]] = ['assumed_by', 'description', 'external_ids', 'inline_policies', 'managed_policies', 'max_session_duration', 'path', 'permissions_boundary', 'role_name']
    _method_names: typing.ClassVar[list[str]] = ['add_managed_policy', 'add_to_policy', 'add_to_principal_policy', 'apply_removal_policy', 'attach_inline_policy', 'grant', 'grant_assume_role', 'grant_pass_role', 'without_policy_updates']
    _classmethod_names: typing.ClassVar[list[str]] = ['customize_roles', 'from_role_arn', 'from_role_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.Role'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_role_arn', 'from_role_name']
    ...


    from_role_arn: typing.Optional[RoleDefFromRoleArnParams] = pydantic.Field(None, description='Import an external role by ARN.\nIf the imported Role ARN is a Token (such as a\n``CfnParameter.valueAsString`` or a ``Fn.importValue()``) *and* the referenced\nrole has a ``path`` (like ``arn:...:role/AdminRoles/Alice``), the\n``roleName`` property will not resolve to the correct value. Instead it\nwill resolve to the first path component. We unfortunately cannot express\nthe correct calculation of the full path name as a CloudFormation\nexpression. In this scenario the Role ARN should be supplied without the\n``path`` in order to resolve the correct role resource.')
    from_role_name: typing.Optional[RoleDefFromRoleNameParams] = pydantic.Field(None, description="Import an external role by name.\nThe imported role is assumed to exist in the same account as the account\nthe scope's containing Stack is being deployed to.")
    resource_config: typing.Optional[RoleDefConfig] = pydantic.Field(None)


class RoleDefConfig(pydantic.BaseModel):
    add_managed_policy: typing.Optional[list[RoleDefAddManagedPolicyParams]] = pydantic.Field(None, description='Attaches a managed policy to this role.')
    add_to_policy: typing.Optional[list[RoleDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[RoleDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description="Adds a permission to the role's default policy document.\nIf there is no default policy attached to this role, it will be created.")
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    attach_inline_policy: typing.Optional[list[RoleDefAttachInlinePolicyParams]] = pydantic.Field(None, description='Attaches a policy to this role.')
    customize_roles: typing.Optional[list[RoleDefCustomizeRolesParams]] = pydantic.Field(None, description='Customize the creation of IAM roles within the given scope.\nIt is recommended that you **do not** use this method and instead allow\nCDK to manage role creation. This should only be used\nin environments where CDK applications are not allowed to created IAM roles.\n\nThis can be used to prevent the CDK application from creating roles\nwithin the given scope and instead replace the references to the roles with\nprecreated role names. A report will be synthesized in the cloud assembly (i.e. cdk.out)\nthat will contain the list of IAM roles that would have been created along with the\nIAM policy statements that the role should contain. This report can then be used\nto create the IAM roles outside of CDK and then the created role names can be provided\nin ``usePrecreatedRoles``.')
    grant: typing.Optional[list[RoleDefGrantParams]] = pydantic.Field(None, description='Grant the actions defined in actions to the identity Principal on this resource.')
    grant_assume_role: typing.Optional[list[RoleDefGrantAssumeRoleParams]] = pydantic.Field(None, description='Grant permissions to the given principal to assume this role.')
    grant_pass_role: typing.Optional[list[RoleDefGrantPassRoleParams]] = pydantic.Field(None, description='Grant permissions to the given principal to pass this role.')
    without_policy_updates: typing.Optional[list[RoleDefWithoutPolicyUpdatesParams]] = pydantic.Field(None, description="Return a copy of this Role object whose Policies will not be updated.\nUse the object returned by this method if you want this Role to be used by\na construct without it automatically updating the Role's Policies.\n\nIf you do, you are responsible for adding the correct statements to the\nRole's policies yourself.")
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class RoleDefAddManagedPolicyParams(pydantic.BaseModel):
    policy: typing.Union[models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_iam.ManagedPolicyDef] = pydantic.Field(..., description='The the managed policy to attach.')
    ...

class RoleDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class RoleDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='The permission statement to add to the policy document.')
    ...

class RoleDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class RoleDefAttachInlinePolicyParams(pydantic.BaseModel):
    policy: models.aws_iam.PolicyDef = pydantic.Field(..., description='The policy to attach.')
    ...

class RoleDefCustomizeRolesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='construct scope to customize role creation.\n')
    prevent_synthesis: typing.Optional[bool] = pydantic.Field(None, description='Whether or not to synthesize the resource into the CFN template. Set this to ``false`` if you still want to create the resources *and* you also want to create the policy report. Default: true\n')
    use_precreated_roles: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='A list of precreated IAM roles to substitute for roles that CDK is creating. The constructPath can be either a relative or absolute path from the scope that ``customizeRoles`` is used on to the role being created. Default: - there are no precreated roles. Synthesis will fail if ``preventSynthesis=true``\n\nExample::\n\n    # app: App\n\n    iam.Role.customize_roles(app,\n        use_precreated_roles={\n            "ConstructPath/To/Role": "my-precreated-role-name"\n        }\n    )\n')
    ...

class RoleDefFromRoleArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='construct scope.\n')
    id: str = pydantic.Field(..., description='construct id.\n')
    role_arn: str = pydantic.Field(..., description='the ARN of the role to import.\n')
    add_grants_to_resources: typing.Optional[bool] = pydantic.Field(None, description='For immutable roles: add grants to resources instead of dropping them. If this is ``false`` or not specified, grant permissions added to this role are ignored. It is your own responsibility to make sure the role has the required permissions. If this is ``true``, any grant permissions will be added to the resource instead. Default: false\n')
    default_policy_name: typing.Optional[str] = pydantic.Field(None, description="Any policies created by this role will use this value as their ID, if specified. Specify this if importing the same role in multiple stacks, and granting it different permissions in at least two stacks. If this is not specified (or if the same name is specified in more than one stack), a CloudFormation issue will result in the policy created in whichever stack is deployed last overwriting the policies created by the others. Default: 'Policy'\n")
    mutable: typing.Optional[bool] = pydantic.Field(None, description='Whether the imported role can be modified by attaching policy resources to it. Default: true')
    ...

class RoleDefFromRoleNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='construct scope.\n')
    id: str = pydantic.Field(..., description='construct id.\n')
    role_name: str = pydantic.Field(..., description='the name of the role to import.\n')
    add_grants_to_resources: typing.Optional[bool] = pydantic.Field(None, description='For immutable roles: add grants to resources instead of dropping them. If this is ``false`` or not specified, grant permissions added to this role are ignored. It is your own responsibility to make sure the role has the required permissions. If this is ``true``, any grant permissions will be added to the resource instead. Default: false\n')
    default_policy_name: typing.Optional[str] = pydantic.Field(None, description="Any policies created by this role will use this value as their ID, if specified. Specify this if importing the same role in multiple stacks, and granting it different permissions in at least two stacks. If this is not specified (or if the same name is specified in more than one stack), a CloudFormation issue will result in the policy created in whichever stack is deployed last overwriting the policies created by the others. Default: 'Policy'\n")
    mutable: typing.Optional[bool] = pydantic.Field(None, description='Whether the imported role can be modified by attaching policy resources to it. Default: true')
    ...

class RoleDefGrantParams(pydantic.BaseModel):
    grantee: typing.Union[models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef] = pydantic.Field(..., description='-\n')
    actions: list[str] = pydantic.Field(...)
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class RoleDefGrantAssumeRoleParams(pydantic.BaseModel):
    identity: typing.Union[models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class RoleDefGrantPassRoleParams(pydantic.BaseModel):
    identity: typing.Union[models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class RoleDefWithoutPolicyUpdatesParams(pydantic.BaseModel):
    add_grants_to_resources: typing.Optional[bool] = pydantic.Field(None, description='Add grants to resources instead of dropping them. If this is ``false`` or not specified, grant permissions added to this role are ignored. It is your own responsibility to make sure the role has the required permissions. If this is ``true``, any grant permissions will be added to the resource instead. Default: false')
    return_config: typing.Optional[list[models._interface_methods.AwsIamIRoleDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_iam.SamlProvider
class SamlProviderDef(BaseConstruct):
    metadata_document: typing.Union[models.aws_iam.SamlMetadataDocumentDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="An XML document generated by an identity provider (IdP) that supports SAML 2.0. The document includes the issuer's name, expiration information, and keys that can be used to validate the SAML authentication response (assertions) that are received from the IdP. You must generate the metadata document using the identity management software that is used as your organization's IdP.\n")
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the provider to create. This parameter allows a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@- Length must be between 1 and 128 characters. Default: - a CloudFormation generated name')
    _init_params: typing.ClassVar[list[str]] = ['metadata_document', 'name']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_saml_provider_arn']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.SamlProvider'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_saml_provider_arn']
    ...


    from_saml_provider_arn: typing.Optional[SamlProviderDefFromSamlProviderArnParams] = pydantic.Field(None, description='Import an existing provider.')
    resource_config: typing.Optional[SamlProviderDefConfig] = pydantic.Field(None)


class SamlProviderDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class SamlProviderDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class SamlProviderDefFromSamlProviderArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    saml_provider_arn: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_iam.User
class UserDef(BaseConstruct):
    groups: typing.Optional[typing.Sequence[typing.Union[models.aws_iam.GroupDef]]] = pydantic.Field(None, description='Groups to add this user to. You can also use ``addToGroup`` to add this user to a group. Default: - No groups.\n')
    managed_policies: typing.Optional[typing.Sequence[typing.Union[models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_iam.ManagedPolicyDef]]] = pydantic.Field(None, description='A list of managed policies associated with this role. You can add managed policies later using ``addManagedPolicy(ManagedPolicy.fromAwsManagedPolicyName(policyName))``. Default: - No managed policies.\n')
    password: typing.Optional[models.SecretValueDef] = pydantic.Field(None, description="The password for the user. This is required so the user can access the AWS Management Console. You can use ``SecretValue.unsafePlainText`` to specify a password in plain text or use ``secretsmanager.Secret.fromSecretAttributes`` to reference a secret in Secrets Manager. Default: - User won't be able to access the management console without a password.\n")
    password_reset_required: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether the user is required to set a new password the next time the user logs in to the AWS Management Console. If this is set to \'true\', you must also specify "initialPassword". Default: false\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path for the user name. For more information about paths, see IAM Identifiers in the IAM User Guide. Default: /\n')
    permissions_boundary: typing.Optional[typing.Union[models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_iam.ManagedPolicyDef]] = pydantic.Field(None, description="AWS supports permissions boundaries for IAM entities (users or roles). A permissions boundary is an advanced feature for using a managed policy to set the maximum permissions that an identity-based policy can grant to an IAM entity. An entity's permissions boundary allows it to perform only the actions that are allowed by both its identity-based policies and its permissions boundaries. Default: - No permissions boundary.\n")
    user_name: typing.Optional[str] = pydantic.Field(None, description="A name for the IAM user. For valid values, see the UserName parameter for the CreateUser action in the IAM API Reference. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the user name. If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name. If you specify a name, you must specify the CAPABILITY_NAMED_IAM value to acknowledge your template's capabilities. For more information, see Acknowledging IAM Resources in AWS CloudFormation Templates. Default: - Generated by CloudFormation (recommended)")
    _init_params: typing.ClassVar[list[str]] = ['groups', 'managed_policies', 'password', 'password_reset_required', 'path', 'permissions_boundary', 'user_name']
    _method_names: typing.ClassVar[list[str]] = ['add_managed_policy', 'add_to_group', 'add_to_policy', 'add_to_principal_policy', 'apply_removal_policy', 'attach_inline_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_user_arn', 'from_user_attributes', 'from_user_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.User'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_user_arn', 'from_user_attributes', 'from_user_name']
    ...


    from_user_arn: typing.Optional[UserDefFromUserArnParams] = pydantic.Field(None, description='Import an existing user given a user ARN.\nIf the ARN comes from a Token, the User cannot have a path; if so, any attempt\nto reference its username will fail.')
    from_user_attributes: typing.Optional[UserDefFromUserAttributesParams] = pydantic.Field(None, description='Import an existing user given user attributes.\nIf the ARN comes from a Token, the User cannot have a path; if so, any attempt\nto reference its username will fail.')
    from_user_name: typing.Optional[UserDefFromUserNameParams] = pydantic.Field(None, description='Import an existing user given a username.')
    resource_config: typing.Optional[UserDefConfig] = pydantic.Field(None)


class UserDefConfig(pydantic.BaseModel):
    add_managed_policy: typing.Optional[list[UserDefAddManagedPolicyParams]] = pydantic.Field(None, description='Attaches a managed policy to the user.')
    add_to_group: typing.Optional[list[UserDefAddToGroupParams]] = pydantic.Field(None, description='Adds this user to a group.')
    add_to_policy: typing.Optional[list[UserDefAddToPolicyParams]] = pydantic.Field(None, description='Add to the policy of this principal.')
    add_to_principal_policy: typing.Optional[list[UserDefAddToPrincipalPolicyParams]] = pydantic.Field(None, description='Adds an IAM statement to the default policy.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    attach_inline_policy: typing.Optional[list[UserDefAttachInlinePolicyParams]] = pydantic.Field(None, description='Attaches a policy to this user.')
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class UserDefAddManagedPolicyParams(pydantic.BaseModel):
    policy: typing.Union[models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_iam.ManagedPolicyDef] = pydantic.Field(..., description='The managed policy to attach.')
    ...

class UserDefAddToGroupParams(pydantic.BaseModel):
    group: typing.Union[models.aws_iam.GroupDef] = pydantic.Field(..., description='-')
    ...

class UserDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class UserDefAddToPrincipalPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-\n')
    ...

class UserDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class UserDefAttachInlinePolicyParams(pydantic.BaseModel):
    policy: models.aws_iam.PolicyDef = pydantic.Field(..., description='-')
    ...

class UserDefFromUserArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='construct scope.\n')
    id: str = pydantic.Field(..., description='construct id.\n')
    user_arn: str = pydantic.Field(..., description='the ARN of an existing user to import.')
    ...

class UserDefFromUserAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='construct scope.\n')
    id: str = pydantic.Field(..., description='construct id.\n')
    user_arn: str = pydantic.Field(..., description='The ARN of the user. Format: arn::iam:::user/')
    ...

class UserDefFromUserNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='construct scope.\n')
    id: str = pydantic.Field(..., description='construct id.\n')
    user_name: str = pydantic.Field(..., description='the username of the existing user to import.')
    ...


#  autogenerated from aws_cdk.aws_iam.AccessKeyProps
class AccessKeyPropsDef(BaseStruct):
    user: typing.Union[_REQUIRED_INIT_PARAM, models.aws_iam.UserDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The IAM user this key will belong to. Changing this value will result in the access key being deleted and a new access key (with a different ID and secret value) being assigned to the new user.\n')
    serial: typing.Union[int, float, None] = pydantic.Field(None, description='A CloudFormation-specific value that signifies the access key should be replaced/rotated. This value can only be incremented. Incrementing this value will cause CloudFormation to replace the Access Key resource. Default: - No serial value\n')
    status: typing.Optional[aws_cdk.aws_iam.AccessKeyStatus] = pydantic.Field(None, description='The status of the access key. An Active access key is allowed to be used to make API calls; An Inactive key cannot. Default: - The access key is active\n\n:exampleMetadata: infused\n\nExample::\n\n    # Creates a new IAM user, access and secret keys, and stores the secret access key in a Secret.\n    user = iam.User(self, "User")\n    access_key = iam.AccessKey(self, "AccessKey", user=user)\n    secret = secretsmanager.Secret(self, "Secret",\n        secret_string_value=access_key.secret_access_key\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['user', 'serial', 'status']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.AccessKeyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.AddToPrincipalPolicyResult
class AddToPrincipalPolicyResultDef(BaseStruct):
    statement_added: typing.Union[bool, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="Whether the statement was added to the identity's policies.\n")
    policy_dependable: typing.Optional[models.UnsupportedResource] = pydantic.Field(None, description='Dependable which allows depending on the policy change being applied. Default: - Required if ``statementAdded`` is true.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n    import constructs as constructs\n\n    # dependable: constructs.IDependable\n\n    add_to_principal_policy_result = iam.AddToPrincipalPolicyResult(\n        statement_added=False,\n\n        # the properties below are optional\n        policy_dependable=dependable\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['statement_added', 'policy_dependable']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.AddToPrincipalPolicyResult'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.AddToResourcePolicyResult
class AddToResourcePolicyResultDef(BaseStruct):
    statement_added: typing.Union[bool, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Whether the statement was added.\n')
    policy_dependable: typing.Optional[models.UnsupportedResource] = pydantic.Field(None, description='Dependable which allows depending on the policy change being applied. Default: - If ``statementAdded`` is true, the resource object itself. Otherwise, no dependable.\n\n:exampleMetadata: infused\n\nExample::\n\n    bucket = s3.Bucket.from_bucket_name(self, "existingBucket", "bucket-name")\n\n    # No policy statement will be added to the resource\n    result = bucket.add_to_resource_policy(\n        iam.PolicyStatement(\n            actions=["s3:GetObject"],\n            resources=[bucket.arn_for_objects("file.txt")],\n            principals=[iam.AccountRootPrincipal()]\n        ))\n')
    _init_params: typing.ClassVar[list[str]] = ['statement_added', 'policy_dependable']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.AddToResourcePolicyResult'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CfnGroup.PolicyProperty
class CfnGroup_PolicyPropertyDef(BaseStruct):
    policy_document: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The policy document.\n')
    policy_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The friendly name (not ARN) identifying the policy.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-group-policy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    # policy_document: Any\n\n    policy_property = iam.CfnGroup.PolicyProperty(\n        policy_document=policy_document,\n        policy_name="policyName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['policy_document', 'policy_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnGroup.PolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CfnRole.PolicyProperty
class CfnRole_PolicyPropertyDef(BaseStruct):
    policy_document: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The entire contents of the policy that defines permissions. For more information, see `Overview of JSON policies <https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policies-json>`_ .\n')
    policy_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The friendly name (not ARN) identifying the policy.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-role-policy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    # policy_document: Any\n\n    policy_property = iam.CfnRole.PolicyProperty(\n        policy_document=policy_document,\n        policy_name="policyName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['policy_document', 'policy_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnRole.PolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CfnUser.LoginProfileProperty
class CfnUser_LoginProfilePropertyDef(BaseStruct):
    password: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The user's password.\n")
    password_reset_required: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether the user is required to set a new password on next sign-in.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-user-loginprofile.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    login_profile_property = iam.CfnUser.LoginProfileProperty(\n        password="password",\n\n        # the properties below are optional\n        password_reset_required=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['password', 'password_reset_required']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnUser.LoginProfileProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CfnUser.PolicyProperty
class CfnUser_PolicyPropertyDef(BaseStruct):
    policy_document: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The entire contents of the policy that defines permissions. For more information, see `Overview of JSON policies <https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policies-json>`_ .\n')
    policy_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The friendly name (not ARN) identifying the policy.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-user-policy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    # policy_document: Any\n\n    policy_property = iam.CfnUser.PolicyProperty(\n        policy_document=policy_document,\n        policy_name="policyName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['policy_document', 'policy_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnUser.PolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CommonGrantOptions
class CommonGrantOptionsDef(BaseStruct):
    actions: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The actions to grant.\n')
    grantee: typing.Union[models.AnyResource, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The principal to grant to. Default: if principal is undefined, no work is done.\n')
    resource_arns: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The resource ARNs to grant to.\n')
    conditions: typing.Optional[typing.Mapping[str, typing.Mapping[str, typing.Any]]] = pydantic.Field(None, description='Any conditions to attach to the grant. Default: - No conditions\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    # conditions: Any\n    # grantable: iam.IGrantable\n\n    common_grant_options = iam.CommonGrantOptions(\n        actions=["actions"],\n        grantee=grantable,\n        resource_arns=["resourceArns"],\n\n        # the properties below are optional\n        conditions={\n            "conditions_key": {\n                "conditions_key": conditions\n            }\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['actions', 'grantee', 'resource_arns', 'conditions']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CommonGrantOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CustomizeRolesOptions
class CustomizeRolesOptionsDef(BaseStruct):
    prevent_synthesis: typing.Optional[bool] = pydantic.Field(None, description='Whether or not to synthesize the resource into the CFN template. Set this to ``false`` if you still want to create the resources *and* you also want to create the policy report. Default: true\n')
    use_precreated_roles: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='A list of precreated IAM roles to substitute for roles that CDK is creating. The constructPath can be either a relative or absolute path from the scope that ``customizeRoles`` is used on to the role being created. Default: - there are no precreated roles. Synthesis will fail if ``preventSynthesis=true``\n\n:exampleMetadata: infused\n\nExample::\n\n    # app: App\n\n    stack = Stack(app, "MyStack")\n    iam.Role.customize_roles(self,\n        use_precreated_roles={\n            "MyStack/MyLambda/ServiceRole": "my-role-name"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['prevent_synthesis', 'use_precreated_roles']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CustomizeRolesOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.FromRoleArnOptions
class FromRoleArnOptionsDef(BaseStruct):
    add_grants_to_resources: typing.Optional[bool] = pydantic.Field(None, description='For immutable roles: add grants to resources instead of dropping them. If this is ``false`` or not specified, grant permissions added to this role are ignored. It is your own responsibility to make sure the role has the required permissions. If this is ``true``, any grant permissions will be added to the resource instead. Default: false\n')
    default_policy_name: typing.Optional[str] = pydantic.Field(None, description="Any policies created by this role will use this value as their ID, if specified. Specify this if importing the same role in multiple stacks, and granting it different permissions in at least two stacks. If this is not specified (or if the same name is specified in more than one stack), a CloudFormation issue will result in the policy created in whichever stack is deployed last overwriting the policies created by the others. Default: 'Policy'\n")
    mutable: typing.Optional[bool] = pydantic.Field(None, description='Whether the imported role can be modified by attaching policy resources to it. Default: true\n\n:exampleMetadata: infused\n\nExample::\n\n    role = iam.Role.from_role_arn(self, "Role", "arn:aws:iam::123456789012:role/MyExistingRole",\n        # Set \'mutable\' to \'false\' to use the role as-is and prevent adding new\n        # policies to it. The default is \'true\', which means the role may be\n        # modified as part of the deployment.\n        mutable=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['add_grants_to_resources', 'default_policy_name', 'mutable']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.FromRoleArnOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.FromRoleNameOptions
class FromRoleNameOptionsDef(BaseStruct):
    add_grants_to_resources: typing.Optional[bool] = pydantic.Field(None, description='For immutable roles: add grants to resources instead of dropping them. If this is ``false`` or not specified, grant permissions added to this role are ignored. It is your own responsibility to make sure the role has the required permissions. If this is ``true``, any grant permissions will be added to the resource instead. Default: false\n')
    default_policy_name: typing.Optional[str] = pydantic.Field(None, description="Any policies created by this role will use this value as their ID, if specified. Specify this if importing the same role in multiple stacks, and granting it different permissions in at least two stacks. If this is not specified (or if the same name is specified in more than one stack), a CloudFormation issue will result in the policy created in whichever stack is deployed last overwriting the policies created by the others. Default: 'Policy'\n")
    mutable: typing.Optional[bool] = pydantic.Field(None, description='Whether the imported role can be modified by attaching policy resources to it. Default: true\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    from_role_name_options = iam.FromRoleNameOptions(\n        add_grants_to_resources=False,\n        default_policy_name="defaultPolicyName",\n        mutable=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['add_grants_to_resources', 'default_policy_name', 'mutable']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.FromRoleNameOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.GrantOnPrincipalAndResourceOptions
class GrantOnPrincipalAndResourceOptionsDef(BaseStruct):
    actions: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The actions to grant.\n')
    grantee: typing.Union[models.AnyResource, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The principal to grant to. Default: if principal is undefined, no work is done.\n')
    resource_arns: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The resource ARNs to grant to.\n')
    conditions: typing.Optional[typing.Mapping[str, typing.Mapping[str, typing.Any]]] = pydantic.Field(None, description='Any conditions to attach to the grant. Default: - No conditions\n')
    resource: typing.Union[models.UnsupportedResource, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The resource with a resource policy. The statement will always be added to the resource policy.\n')
    resource_policy_principal: typing.Optional[typing.Union[models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef]] = pydantic.Field(None, description='The principal to use in the statement for the resource policy. Default: - the principal of the grantee will be used\n')
    resource_self_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='When referring to the resource in a resource policy, use this as ARN. (Depending on the resource type, this needs to be \'*\' in a resource policy). Default: Same as regular resource ARNs\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    # conditions: Any\n    # grantable: iam.IGrantable\n    # principal: iam.IPrincipal\n    # resource_with_policy: iam.IResourceWithPolicy\n\n    grant_on_principal_and_resource_options = iam.GrantOnPrincipalAndResourceOptions(\n        actions=["actions"],\n        grantee=grantable,\n        resource=resource_with_policy,\n        resource_arns=["resourceArns"],\n\n        # the properties below are optional\n        conditions={\n            "conditions_key": {\n                "conditions_key": conditions\n            }\n        },\n        resource_policy_principal=principal,\n        resource_self_arns=["resourceSelfArns"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['actions', 'grantee', 'resource_arns', 'conditions', 'resource', 'resource_policy_principal', 'resource_self_arns']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.GrantOnPrincipalAndResourceOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.GrantOnPrincipalOptions
class GrantOnPrincipalOptionsDef(BaseStruct):
    actions: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The actions to grant.\n')
    grantee: typing.Union[models.AnyResource, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The principal to grant to. Default: if principal is undefined, no work is done.\n')
    resource_arns: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The resource ARNs to grant to.\n')
    conditions: typing.Optional[typing.Mapping[str, typing.Mapping[str, typing.Any]]] = pydantic.Field(None, description='Any conditions to attach to the grant. Default: - No conditions\n')
    _init_params: typing.ClassVar[list[str]] = ['actions', 'grantee', 'resource_arns', 'conditions']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.GrantOnPrincipalOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.GrantWithResourceOptions
class GrantWithResourceOptionsDef(BaseStruct):
    actions: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The actions to grant.\n')
    grantee: typing.Union[models.AnyResource, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The principal to grant to. Default: if principal is undefined, no work is done.\n')
    resource_arns: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The resource ARNs to grant to.\n')
    conditions: typing.Optional[typing.Mapping[str, typing.Mapping[str, typing.Any]]] = pydantic.Field(None, description='Any conditions to attach to the grant. Default: - No conditions\n')
    resource: typing.Union[models.UnsupportedResource, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The resource with a resource policy. The statement will be added to the resource policy if it couldn't be added to the principal policy.\n")
    resource_self_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='When referring to the resource in a resource policy, use this as ARN. (Depending on the resource type, this needs to be \'*\' in a resource policy). Default: Same as regular resource ARNs\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    # conditions: Any\n    # grantable: iam.IGrantable\n    # resource_with_policy: iam.IResourceWithPolicy\n\n    grant_with_resource_options = iam.GrantWithResourceOptions(\n        actions=["actions"],\n        grantee=grantable,\n        resource=resource_with_policy,\n        resource_arns=["resourceArns"],\n\n        # the properties below are optional\n        conditions={\n            "conditions_key": {\n                "conditions_key": conditions\n            }\n        },\n        resource_self_arns=["resourceSelfArns"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['actions', 'grantee', 'resource_arns', 'conditions', 'resource', 'resource_self_arns']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.GrantWithResourceOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.GroupProps
class GroupPropsDef(BaseStruct):
    group_name: typing.Optional[str] = pydantic.Field(None, description="A name for the IAM group. For valid values, see the GroupName parameter for the CreateGroup action in the IAM API Reference. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the group name. If you specify a name, you must specify the CAPABILITY_NAMED_IAM value to acknowledge your template's capabilities. For more information, see Acknowledging IAM Resources in AWS CloudFormation Templates. Default: Generated by CloudFormation (recommended)\n")
    managed_policies: typing.Optional[typing.Sequence[typing.Union[models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_iam.ManagedPolicyDef]]] = pydantic.Field(None, description='A list of managed policies associated with this role. You can add managed policies later using ``addManagedPolicy(ManagedPolicy.fromAwsManagedPolicyName(policyName))``. Default: - No managed policies.\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path to the group. For more information about paths, see `IAM Identifiers <http://docs.aws.amazon.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html>`_ in the IAM User Guide. Default: /\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    # managed_policy: iam.ManagedPolicy\n\n    group_props = iam.GroupProps(\n        group_name="groupName",\n        managed_policies=[managed_policy],\n        path="path"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['group_name', 'managed_policies', 'path']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.GroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.InstanceProfileAttributes
class InstanceProfileAttributesDef(BaseStruct):
    instance_profile_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the InstanceProfile. Format: arn::iam:::instance-profile/\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The role associated with the InstanceProfile. Default: - no role\n\n:exampleMetadata: infused\n\nExample::\n\n    role = iam.Role(self, "Role",\n        assumed_by=iam.ServicePrincipal("ec2.amazonaws.com")\n    )\n\n    instance_profile = iam.InstanceProfile.from_instance_profile_attributes(self, "ImportedInstanceProfile",\n        instance_profile_arn="arn:aws:iam::account-id:instance-profile/MyInstanceProfile",\n        role=role\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_profile_arn', 'role']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.InstanceProfileAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.InstanceProfileProps
class InstanceProfilePropsDef(BaseStruct):
    instance_profile_name: typing.Optional[str] = pydantic.Field(None, description='The name of the InstanceProfile to create. Default: - generated by CloudFormation\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path to the InstanceProfile. Default: /\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role to associate with the instance profile that is used by EC2 instances. The role must be assumable by the service principal ``ec2.amazonaws.com``: Default: - a role will be automatically created, it can be accessed via the ``role`` property\n\n:exampleMetadata: infused\n\nExample::\n\n    role = iam.Role(self, "Role",\n        assumed_by=iam.ServicePrincipal("ec2.amazonaws.com")\n    )\n\n    instance_profile = iam.InstanceProfile(self, "InstanceProfile",\n        role=role,\n        instance_profile_name="MyInstanceProfile",\n        path="/sample/path/"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_profile_name', 'path', 'role']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.InstanceProfileProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.LazyRoleProps
class LazyRolePropsDef(BaseStruct):
    assumed_by: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef] = pydantic.Field(REQUIRED_INIT_PARAM, description="The IAM principal (i.e. ``new ServicePrincipal('sns.amazonaws.com')``) which can assume this role. You can later modify the assume role policy document by accessing it via the ``assumeRolePolicy`` property.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the role. It can be up to 1000 characters long. Default: - No description.\n')
    external_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of IDs that the role assumer needs to provide one of when assuming this role. If the configured and provided external IDs do not match, the AssumeRole operation will fail. Default: No external ID required\n')
    inline_policies: typing.Optional[typing.Mapping[str, models.aws_iam.PolicyDocumentDef]] = pydantic.Field(None, description='A list of named policies to inline into this role. These policies will be created with the role, whereas those added by ``addToPolicy`` are added using a separate CloudFormation resource (allowing a way around circular dependencies that could otherwise be introduced). Default: - No policy is inlined in the Role resource.\n')
    managed_policies: typing.Optional[typing.Sequence[typing.Union[models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_iam.ManagedPolicyDef]]] = pydantic.Field(None, description='A list of managed policies associated with this role. You can add managed policies later using ``addManagedPolicy(ManagedPolicy.fromAwsManagedPolicyName(policyName))``. Default: - No managed policies.\n')
    max_session_duration: typing.Optional[models.DurationDef] = pydantic.Field(None, description="The maximum session duration that you want to set for the specified role. This setting can have a value from 1 hour (3600sec) to 12 (43200sec) hours. Anyone who assumes the role from the AWS CLI or API can use the DurationSeconds API parameter or the duration-seconds CLI parameter to request a longer session. The MaxSessionDuration setting determines the maximum duration that can be requested using the DurationSeconds parameter. If users don't specify a value for the DurationSeconds parameter, their security credentials are valid for one hour by default. This applies when you use the AssumeRole* API operations or the assume-role* CLI operations but does not apply when you use those operations to create a console URL. Default: Duration.hours(1)\n")
    path: typing.Optional[str] = pydantic.Field(None, description='The path associated with this role. For information about IAM paths, see Friendly Names and Paths in IAM User Guide. Default: /\n')
    permissions_boundary: typing.Optional[typing.Union[models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_iam.ManagedPolicyDef]] = pydantic.Field(None, description="AWS supports permissions boundaries for IAM entities (users or roles). A permissions boundary is an advanced feature for using a managed policy to set the maximum permissions that an identity-based policy can grant to an IAM entity. An entity's permissions boundary allows it to perform only the actions that are allowed by both its identity-based policies and its permissions boundaries. Default: - No permissions boundary.\n")
    role_name: typing.Optional[str] = pydantic.Field(None, description='A name for the IAM role. For valid values, see the RoleName parameter for the CreateRole action in the IAM API Reference. IMPORTANT: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name. If you specify a name, you must specify the CAPABILITY_NAMED_IAM value to acknowledge your template\'s capabilities. For more information, see Acknowledging IAM Resources in AWS CloudFormation Templates. Default: - AWS CloudFormation generates a unique physical ID and uses that ID for the role name.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_iam as iam\n\n    # managed_policy: iam.ManagedPolicy\n    # policy_document: iam.PolicyDocument\n    # principal: iam.IPrincipal\n\n    lazy_role_props = iam.LazyRoleProps(\n        assumed_by=principal,\n\n        # the properties below are optional\n        description="description",\n        external_ids=["externalIds"],\n        inline_policies={\n            "inline_policies_key": policy_document\n        },\n        managed_policies=[managed_policy],\n        max_session_duration=cdk.Duration.minutes(30),\n        path="path",\n        permissions_boundary=managed_policy,\n        role_name="roleName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['assumed_by', 'description', 'external_ids', 'inline_policies', 'managed_policies', 'max_session_duration', 'path', 'permissions_boundary', 'role_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.LazyRoleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[LazyRolePropsDefConfig] = pydantic.Field(None)


class LazyRolePropsDefConfig(pydantic.BaseModel):
    assumed_by_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_iam.ManagedPolicyProps
class ManagedPolicyPropsDef(BaseStruct):
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the managed policy. Typically used to store information about the permissions defined in the policy. For example, "Grants access to production DynamoDB tables." The policy description is immutable. After a value is assigned, it cannot be changed. Default: - empty\n')
    document: typing.Optional[models.aws_iam.PolicyDocumentDef] = pydantic.Field(None, description='Initial PolicyDocument to use for this ManagedPolicy. If omited, any ``PolicyStatement`` provided in the ``statements`` property will be applied against the empty default ``PolicyDocument``. Default: - An empty policy.\n')
    groups: typing.Optional[typing.Sequence[typing.Union[models.aws_iam.GroupDef]]] = pydantic.Field(None, description='Groups to attach this policy to. You can also use ``attachToGroup(group)`` to attach this policy to a group. Default: - No groups.\n')
    managed_policy_name: typing.Optional[str] = pydantic.Field(None, description='The name of the managed policy. If you specify multiple policies for an entity, specify unique names. For example, if you specify a list of policies for an IAM role, each policy must have a unique name. Default: - A name is automatically generated.\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path for the policy. This parameter allows (through its regex pattern) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (\\u0021) through the DEL character (\\u007F), including most punctuation characters, digits, and upper and lowercased letters. For more information about paths, see IAM Identifiers in the IAM User Guide. Default: - "/"\n')
    roles: typing.Optional[typing.Sequence[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]]] = pydantic.Field(None, description='Roles to attach this policy to. You can also use ``attachToRole(role)`` to attach this policy to a role. Default: - No roles.\n')
    statements: typing.Optional[typing.Sequence[models.aws_iam.PolicyStatementDef]] = pydantic.Field(None, description='Initial set of permissions to add to this policy document. You can also use ``addPermission(statement)`` to add permissions later. Default: - No statements.\n')
    users: typing.Optional[typing.Sequence[typing.Union[models.aws_iam.UserDef]]] = pydantic.Field(None, description='Users to attach this policy to. You can also use ``attachToUser(user)`` to attach this policy to a user. Default: - No users.\n\n:exampleMetadata: infused\n\nExample::\n\n    policy_document = {\n        "Version": "2012-10-17",\n        "Statement": [{\n            "Sid": "FirstStatement",\n            "Effect": "Allow",\n            "Action": ["iam:ChangePassword"],\n            "Resource": ["*"]\n        }, {\n            "Sid": "SecondStatement",\n            "Effect": "Allow",\n            "Action": ["s3:ListAllMyBuckets"],\n            "Resource": ["*"]\n        }, {\n            "Sid": "ThirdStatement",\n            "Effect": "Allow",\n            "Action": ["s3:List*", "s3:Get*"\n            ],\n            "Resource": ["arn:aws:s3:::confidential-data", "arn:aws:s3:::confidential-data/*"\n            ],\n            "Condition": {"Bool": {"aws:_multi_factor_auth_present": "true"}}\n        }\n        ]\n    }\n\n    custom_policy_document = iam.PolicyDocument.from_json(policy_document)\n\n    # You can pass this document as an initial document to a ManagedPolicy\n    # or inline Policy.\n    new_managed_policy = iam.ManagedPolicy(self, "MyNewManagedPolicy",\n        document=custom_policy_document\n    )\n    new_policy = iam.Policy(self, "MyNewPolicy",\n        document=custom_policy_document\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'document', 'groups', 'managed_policy_name', 'path', 'roles', 'statements', 'users']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.ManagedPolicyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.OpenIdConnectProviderProps
class OpenIdConnectProviderPropsDef(BaseStruct):
    url: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The URL of the identity provider. The URL must begin with https:// and should correspond to the iss claim in the provider's OpenID Connect ID tokens. Per the OIDC standard, path components are allowed but query parameters are not. Typically the URL consists of only a hostname, like https://server.example.org or https://example.com. You cannot register the same provider multiple times in a single AWS account. If you try to submit a URL that has already been used for an OpenID Connect provider in the AWS account, you will get an error.\n")
    client_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="A list of client IDs (also known as audiences). When a mobile or web app registers with an OpenID Connect provider, they establish a value that identifies the application. (This is the value that's sent as the client_id parameter on OAuth requests.) You can register multiple client IDs with the same provider. For example, you might have multiple applications that use the same OIDC provider. You cannot register more than 100 client IDs with a single IAM OIDC provider. Client IDs are up to 255 characters long. Default: - no clients are allowed\n")
    thumbprints: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of server certificate thumbprints for the OpenID Connect (OIDC) identity provider\'s server certificates. Typically this list includes only one entry. However, IAM lets you have up to five thumbprints for an OIDC provider. This lets you maintain multiple thumbprints if the identity provider is rotating certificates. The server certificate thumbprint is the hex-encoded SHA-1 hash value of the X.509 certificate used by the domain where the OpenID Connect provider makes its keys available. It is always a 40-character string. You must provide at least one thumbprint when creating an IAM OIDC provider. For example, assume that the OIDC provider is server.example.com and the provider stores its keys at https://keys.server.example.com/openid-connect. In that case, the thumbprint string would be the hex-encoded SHA-1 hash value of the certificate used by https://keys.server.example.com. Default: - If no thumbprints are specified (an empty array or ``undefined``), the thumbprint of the root certificate authority will be obtained from the provider\'s server as described in https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_create_oidc_verify-thumbprint.html\n\n:exampleMetadata: infused\n\nExample::\n\n    provider = iam.OpenIdConnectProvider(self, "MyProvider",\n        url="https://openid/connect",\n        client_ids=["myclient1", "myclient2"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['url', 'client_ids', 'thumbprints']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.OpenIdConnectProviderProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.PolicyDocumentProps
class PolicyDocumentPropsDef(BaseStruct):
    assign_sids: typing.Optional[bool] = pydantic.Field(None, description='Automatically assign Statement Ids to all statements. Default: false\n')
    minimize: typing.Optional[bool] = pydantic.Field(None, description="Try to minimize the policy by merging statements. To avoid overrunning the maximum policy size, combine statements if they produce the same result. Merging happens according to the following rules: - The Effect of both statements is the same - Neither of the statements have a 'Sid' - Combine Principals if the rest of the statement is exactly the same. - Combine Resources if the rest of the statement is exactly the same. - Combine Actions if the rest of the statement is exactly the same. - We will never combine NotPrincipals, NotResources or NotActions, because doing so would change the meaning of the policy document. Default: - false, unless the feature flag ``@aws-cdk/aws-iam:minimizePolicies`` is set\n")
    statements: typing.Optional[typing.Sequence[models.aws_iam.PolicyStatementDef]] = pydantic.Field(None, description='Initial statements to add to the policy document. Default: - No statements\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_iam as iam\n\n\n    my_file_system_policy = iam.PolicyDocument(\n        statements=[iam.PolicyStatement(\n            actions=["elasticfilesystem:ClientWrite", "elasticfilesystem:ClientMount"\n            ],\n            principals=[iam.AccountRootPrincipal()],\n            resources=["*"],\n            conditions={\n                "Bool": {\n                    "elasticfilesystem:AccessedViaMountTarget": "true"\n                }\n            }\n        )]\n    )\n\n    file_system = efs.FileSystem(self, "MyEfsFileSystem",\n        vpc=ec2.Vpc(self, "VPC"),\n        file_system_policy=my_file_system_policy\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['assign_sids', 'minimize', 'statements']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.PolicyDocumentProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.PolicyProps
class PolicyPropsDef(BaseStruct):
    document: typing.Optional[models.aws_iam.PolicyDocumentDef] = pydantic.Field(None, description='Initial PolicyDocument to use for this Policy. If omited, any ``PolicyStatement`` provided in the ``statements`` property will be applied against the empty default ``PolicyDocument``. Default: - An empty policy.\n')
    force: typing.Optional[bool] = pydantic.Field(None, description='Force creation of an ``AWS::IAM::Policy``. Unless set to ``true``, this ``Policy`` construct will not materialize to an ``AWS::IAM::Policy`` CloudFormation resource in case it would have no effect (for example, if it remains unattached to an IAM identity or if it has no statements). This is generally desired behavior, since it prevents creating invalid--and hence undeployable--CloudFormation templates. In cases where you know the policy must be created and it is actually an error if no statements have been added to it, you can set this to ``true``. Default: false\n')
    groups: typing.Optional[typing.Sequence[typing.Union[models.aws_iam.GroupDef]]] = pydantic.Field(None, description='Groups to attach this policy to. You can also use ``attachToGroup(group)`` to attach this policy to a group. Default: - No groups.\n')
    policy_name: typing.Optional[str] = pydantic.Field(None, description='The name of the policy. If you specify multiple policies for an entity, specify unique names. For example, if you specify a list of policies for an IAM role, each policy must have a unique name. Default: - Uses the logical ID of the policy resource, which is ensured to be unique within the stack.\n')
    roles: typing.Optional[typing.Sequence[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]]] = pydantic.Field(None, description='Roles to attach this policy to. You can also use ``attachToRole(role)`` to attach this policy to a role. Default: - No roles.\n')
    statements: typing.Optional[typing.Sequence[models.aws_iam.PolicyStatementDef]] = pydantic.Field(None, description='Initial set of permissions to add to this policy document. You can also use ``addStatements(...statement)`` to add permissions later. Default: - No statements.\n')
    users: typing.Optional[typing.Sequence[typing.Union[models.aws_iam.UserDef]]] = pydantic.Field(None, description='Users to attach this policy to. You can also use ``attachToUser(user)`` to attach this policy to a user. Default: - No users.\n\n:exampleMetadata: infused\n\nExample::\n\n    # books: apigateway.Resource\n    # iam_user: iam.User\n\n\n    get_books = books.add_method("GET", apigateway.HttpIntegration("http://amazon.com"),\n        authorization_type=apigateway.AuthorizationType.IAM\n    )\n\n    iam_user.attach_inline_policy(iam.Policy(self, "AllowBooks",\n        statements=[\n            iam.PolicyStatement(\n                actions=["execute-api:Invoke"],\n                effect=iam.Effect.ALLOW,\n                resources=[get_books.method_arn]\n            )\n        ]\n    ))\n')
    _init_params: typing.ClassVar[list[str]] = ['document', 'force', 'groups', 'policy_name', 'roles', 'statements', 'users']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.PolicyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.PolicyStatementProps
class PolicyStatementPropsDef(BaseStruct):
    actions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of actions to add to the statement. Default: - no actions\n')
    conditions: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='Conditions to add to the statement. Default: - no condition\n')
    effect: typing.Optional[aws_cdk.aws_iam.Effect] = pydantic.Field(None, description='Whether to allow or deny the actions in this statement. Default: Effect.ALLOW\n')
    not_actions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of not actions to add to the statement. Default: - no not-actions\n')
    not_principals: typing.Optional[typing.Sequence[typing.Union[models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef]]] = pydantic.Field(None, description='List of not principals to add to the statement. Default: - no not principals\n')
    not_resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='NotResource ARNs to add to the statement. Default: - no not-resources\n')
    principals: typing.Optional[typing.Sequence[typing.Union[models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef]]] = pydantic.Field(None, description='List of principals to add to the statement. Default: - no principals\n')
    resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Resource ARNs to add to the statement. Default: - no resources\n')
    sid: typing.Optional[str] = pydantic.Field(None, description='The Sid (statement ID) is an optional identifier that you provide for the policy statement. You can assign a Sid value to each statement in a statement array. In services that let you specify an ID element, such as SQS and SNS, the Sid value is just a sub-ID of the policy document\'s ID. In IAM, the Sid value must be unique within a JSON policy. Default: - no sid\n\n:exampleMetadata: lit=aws-ec2/test/integ.vpc-endpoint.lit.ts infused\n\nExample::\n\n    # Add gateway endpoints when creating the VPC\n    vpc = ec2.Vpc(self, "MyVpc",\n        gateway_endpoints={\n            "S3": cdk.aws_ec2.GatewayVpcEndpointOptions(\n                service=ec2.GatewayVpcEndpointAwsService.S3\n            )\n        }\n    )\n\n    # Alternatively gateway endpoints can be added on the VPC\n    dynamo_db_endpoint = vpc.add_gateway_endpoint("DynamoDbEndpoint",\n        service=ec2.GatewayVpcEndpointAwsService.DYNAMODB\n    )\n\n    # This allows to customize the endpoint policy\n    dynamo_db_endpoint.add_to_policy(\n        iam.PolicyStatement( # Restrict to listing and describing tables\n            principals=[iam.AnyPrincipal()],\n            actions=["dynamodb:DescribeTable", "dynamodb:ListTables"],\n            resources=["*"]))\n\n    # Add an interface endpoint\n    vpc.add_interface_endpoint("EcrDockerEndpoint",\n        service=ec2.InterfaceVpcEndpointAwsService.ECR_DOCKER\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['actions', 'conditions', 'effect', 'not_actions', 'not_principals', 'not_resources', 'principals', 'resources', 'sid']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.PolicyStatementProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.RoleProps
class RolePropsDef(BaseStruct):
    assumed_by: typing.Union[_REQUIRED_INIT_PARAM, models.aws_eks.ServiceAccountDef, models.aws_iam.UnknownPrincipalDef] = pydantic.Field(REQUIRED_INIT_PARAM, description="The IAM principal (i.e. ``new ServicePrincipal('sns.amazonaws.com')``) which can assume this role. You can later modify the assume role policy document by accessing it via the ``assumeRolePolicy`` property.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the role. It can be up to 1000 characters long. Default: - No description.\n')
    external_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of IDs that the role assumer needs to provide one of when assuming this role. If the configured and provided external IDs do not match, the AssumeRole operation will fail. Default: No external ID required\n')
    inline_policies: typing.Optional[typing.Mapping[str, models.aws_iam.PolicyDocumentDef]] = pydantic.Field(None, description='A list of named policies to inline into this role. These policies will be created with the role, whereas those added by ``addToPolicy`` are added using a separate CloudFormation resource (allowing a way around circular dependencies that could otherwise be introduced). Default: - No policy is inlined in the Role resource.\n')
    managed_policies: typing.Optional[typing.Sequence[typing.Union[models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_iam.ManagedPolicyDef]]] = pydantic.Field(None, description='A list of managed policies associated with this role. You can add managed policies later using ``addManagedPolicy(ManagedPolicy.fromAwsManagedPolicyName(policyName))``. Default: - No managed policies.\n')
    max_session_duration: typing.Optional[models.DurationDef] = pydantic.Field(None, description="The maximum session duration that you want to set for the specified role. This setting can have a value from 1 hour (3600sec) to 12 (43200sec) hours. Anyone who assumes the role from the AWS CLI or API can use the DurationSeconds API parameter or the duration-seconds CLI parameter to request a longer session. The MaxSessionDuration setting determines the maximum duration that can be requested using the DurationSeconds parameter. If users don't specify a value for the DurationSeconds parameter, their security credentials are valid for one hour by default. This applies when you use the AssumeRole* API operations or the assume-role* CLI operations but does not apply when you use those operations to create a console URL. Default: Duration.hours(1)\n")
    path: typing.Optional[str] = pydantic.Field(None, description='The path associated with this role. For information about IAM paths, see Friendly Names and Paths in IAM User Guide. Default: /\n')
    permissions_boundary: typing.Optional[typing.Union[models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_iam.ManagedPolicyDef]] = pydantic.Field(None, description="AWS supports permissions boundaries for IAM entities (users or roles). A permissions boundary is an advanced feature for using a managed policy to set the maximum permissions that an identity-based policy can grant to an IAM entity. An entity's permissions boundary allows it to perform only the actions that are allowed by both its identity-based policies and its permissions boundaries. Default: - No permissions boundary.\n")
    role_name: typing.Optional[str] = pydantic.Field(None, description='A name for the IAM role. For valid values, see the RoleName parameter for the CreateRole action in the IAM API Reference. IMPORTANT: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name. If you specify a name, you must specify the CAPABILITY_NAMED_IAM value to acknowledge your template\'s capabilities. For more information, see Acknowledging IAM Resources in AWS CloudFormation Templates. Default: - AWS CloudFormation generates a unique physical ID and uses that ID for the role name.\n\n:exampleMetadata: infused\n\nExample::\n\n    lambda_role = iam.Role(self, "Role",\n        assumed_by=iam.ServicePrincipal("lambda.amazonaws.com"),\n        description="Example role..."\n    )\n\n    stream = kinesis.Stream(self, "MyEncryptedStream",\n        encryption=kinesis.StreamEncryption.KMS\n    )\n\n    # give lambda permissions to read stream\n    stream.grant_read(lambda_role)\n')
    _init_params: typing.ClassVar[list[str]] = ['assumed_by', 'description', 'external_ids', 'inline_policies', 'managed_policies', 'max_session_duration', 'path', 'permissions_boundary', 'role_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.RoleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[RolePropsDefConfig] = pydantic.Field(None)


class RolePropsDefConfig(pydantic.BaseModel):
    assumed_by_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_iam.SamlProviderProps
class SamlProviderPropsDef(BaseStruct):
    metadata_document: typing.Union[models.aws_iam.SamlMetadataDocumentDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="An XML document generated by an identity provider (IdP) that supports SAML 2.0. The document includes the issuer's name, expiration information, and keys that can be used to validate the SAML authentication response (assertions) that are received from the IdP. You must generate the metadata document using the identity management software that is used as your organization's IdP.\n")
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the provider to create. This parameter allows a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@- Length must be between 1 and 128 characters. Default: - a CloudFormation generated name\n\n:exampleMetadata: infused\n\nExample::\n\n    provider = iam.SamlProvider(self, "Provider",\n        metadata_document=iam.SamlMetadataDocument.from_file("/path/to/saml-metadata-document.xml")\n    )\n    iam.Role(self, "Role",\n        assumed_by=iam.SamlConsolePrincipal(provider)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['metadata_document', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.SamlProviderProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.ServicePrincipalOpts
class ServicePrincipalOptsDef(BaseStruct):
    conditions: typing.Optional[typing.Mapping[str, typing.Any]] = pydantic.Field(None, description='Additional conditions to add to the Service Principal. Default: - No conditions\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region in which you want to reference the service. This is only necessary for *cross-region* references to *opt-in* regions. In those cases, the region name needs to be included to reference the correct service principal. In all other cases, the global service principal name is sufficient. This field behaves differently depending on whether the ``@aws-cdk/aws-iam:standardizedServicePrincipals`` flag is set or not: - If the flag is set, the input service principal is assumed to be of the form ``SERVICE.amazonaws.com``. That value will always be returned, unless the given region is an opt-in region and the service principal is rendered in a stack in a different region, in which case ``SERVICE.REGION.amazonaws.com`` will be rendered. Under this regime, there is no downside to always specifying the region property: it will be rendered only if necessary. - If the flag is not set, the service principal will resolve to a single principal whose name comes from the ``@aws-cdk/region-info`` package, using the region to override the stack region. If there is no entry for this service principal in the database,, the input service name is returned literally. This is legacy behavior and is not recommended. Default: - the resolving Stack\'s region.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    # conditions: Any\n\n    service_principal_opts = iam.ServicePrincipalOpts(\n        conditions={\n            "conditions_key": conditions\n        },\n        region="region"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['conditions', 'region']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.ServicePrincipalOpts'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.UnknownPrincipalProps
class UnknownPrincipalPropsDef(BaseStruct):
    resource: typing.Union[models.AnyResource, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The resource the role proxy is for.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n    import constructs as constructs\n\n    # construct: constructs.Construct\n\n    unknown_principal_props = iam.UnknownPrincipalProps(\n        resource=construct\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resource']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.UnknownPrincipalProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.UserAttributes
class UserAttributesDef(BaseStruct):
    user_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the user. Format: arn::iam:::user/\n\n:exampleMetadata: infused\n\nExample::\n\n    user = iam.User.from_user_attributes(self, "MyImportedUserByAttributes",\n        user_arn="arn:aws:iam::123456789012:user/johnsmith"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['user_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.UserAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.UserProps
class UserPropsDef(BaseStruct):
    groups: typing.Optional[typing.Sequence[typing.Union[models.aws_iam.GroupDef]]] = pydantic.Field(None, description='Groups to add this user to. You can also use ``addToGroup`` to add this user to a group. Default: - No groups.\n')
    managed_policies: typing.Optional[typing.Sequence[typing.Union[models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_iam.ManagedPolicyDef]]] = pydantic.Field(None, description='A list of managed policies associated with this role. You can add managed policies later using ``addManagedPolicy(ManagedPolicy.fromAwsManagedPolicyName(policyName))``. Default: - No managed policies.\n')
    password: typing.Optional[models.SecretValueDef] = pydantic.Field(None, description="The password for the user. This is required so the user can access the AWS Management Console. You can use ``SecretValue.unsafePlainText`` to specify a password in plain text or use ``secretsmanager.Secret.fromSecretAttributes`` to reference a secret in Secrets Manager. Default: - User won't be able to access the management console without a password.\n")
    password_reset_required: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether the user is required to set a new password the next time the user logs in to the AWS Management Console. If this is set to \'true\', you must also specify "initialPassword". Default: false\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path for the user name. For more information about paths, see IAM Identifiers in the IAM User Guide. Default: /\n')
    permissions_boundary: typing.Optional[typing.Union[models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_iam.ManagedPolicyDef]] = pydantic.Field(None, description="AWS supports permissions boundaries for IAM entities (users or roles). A permissions boundary is an advanced feature for using a managed policy to set the maximum permissions that an identity-based policy can grant to an IAM entity. An entity's permissions boundary allows it to perform only the actions that are allowed by both its identity-based policies and its permissions boundaries. Default: - No permissions boundary.\n")
    user_name: typing.Optional[str] = pydantic.Field(None, description='A name for the IAM user. For valid values, see the UserName parameter for the CreateUser action in the IAM API Reference. If you don\'t specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the user name. If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name. If you specify a name, you must specify the CAPABILITY_NAMED_IAM value to acknowledge your template\'s capabilities. For more information, see Acknowledging IAM Resources in AWS CloudFormation Templates. Default: - Generated by CloudFormation (recommended)\n\n:exampleMetadata: lit=aws-iam/test/example.attaching.lit.ts infused\n\nExample::\n\n    user = User(self, "MyUser", password=SecretValue.plain_text("1234"))\n    group = Group(self, "MyGroup")\n\n    policy = Policy(self, "MyPolicy")\n    policy.attach_to_user(user)\n    group.attach_inline_policy(policy)\n')
    _init_params: typing.ClassVar[list[str]] = ['groups', 'managed_policies', 'password', 'password_reset_required', 'path', 'permissions_boundary', 'user_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.UserProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.WithoutPolicyUpdatesOptions
class WithoutPolicyUpdatesOptionsDef(BaseStruct):
    add_grants_to_resources: typing.Optional[bool] = pydantic.Field(None, description='Add grants to resources instead of dropping them. If this is ``false`` or not specified, grant permissions added to this role are ignored. It is your own responsibility to make sure the role has the required permissions. If this is ``true``, any grant permissions will be added to the resource instead. Default: false\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    without_policy_updates_options = iam.WithoutPolicyUpdatesOptions(\n        add_grants_to_resources=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['add_grants_to_resources']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.WithoutPolicyUpdatesOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.AccessKeyStatus
# skipping emum

#  autogenerated from aws_cdk.aws_iam.Effect
# skipping emum

#  autogenerated from aws_cdk.aws_iam.IAccessKey
#  skipping Interface

#  autogenerated from aws_cdk.aws_iam.IAssumeRolePrincipal
#  skipping Interface

#  autogenerated from aws_cdk.aws_iam.IComparablePrincipal
#  skipping Interface

#  autogenerated from aws_cdk.aws_iam.IGrantable
#  skipping Interface

#  autogenerated from aws_cdk.aws_iam.IGroup
#  skipping Interface

#  autogenerated from aws_cdk.aws_iam.IIdentity
#  skipping Interface

#  autogenerated from aws_cdk.aws_iam.IInstanceProfile
#  skipping Interface

#  autogenerated from aws_cdk.aws_iam.IManagedPolicy
#  skipping Interface

#  autogenerated from aws_cdk.aws_iam.IOpenIdConnectProvider
#  skipping Interface

#  autogenerated from aws_cdk.aws_iam.IPolicy
#  skipping Interface

#  autogenerated from aws_cdk.aws_iam.IPrincipal
#  skipping Interface

#  autogenerated from aws_cdk.aws_iam.IResourceWithPolicy
#  skipping Interface

#  autogenerated from aws_cdk.aws_iam.IRole
#  skipping Interface

#  autogenerated from aws_cdk.aws_iam.ISamlProvider
#  skipping Interface

#  autogenerated from aws_cdk.aws_iam.IUser
#  skipping Interface

#  autogenerated from aws_cdk.aws_iam.CfnAccessKey
class CfnAccessKeyDef(BaseCfnResource):
    user_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the IAM user that the new key will belong to. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    serial: typing.Union[int, float, None] = pydantic.Field(None, description='This value is specific to CloudFormation and can only be *incremented* . Incrementing this value notifies CloudFormation that you want to rotate your access key. When you update your stack, CloudFormation will replace the existing access key with a new key.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='The status of the access key. ``Active`` means that the key is valid for API calls, while ``Inactive`` means it is not.')
    _init_params: typing.ClassVar[list[str]] = ['user_name', 'serial', 'status']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnAccessKey'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnAccessKeyDefConfig] = pydantic.Field(None)


class CfnAccessKeyDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnAccessKeyDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnAccessKeyDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnAccessKeyDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnAccessKeyDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnAccessKeyDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnAccessKeyDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnAccessKeyDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnAccessKeyDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnAccessKeyDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnAccessKeyDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnAccessKeyDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnAccessKeyDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnAccessKeyDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnAccessKeyDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAccessKeyDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAccessKeyDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAccessKeyDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAccessKeyDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAccessKeyDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAccessKeyDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAccessKeyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAccessKeyDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAccessKeyDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAccessKeyDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnAccessKeyDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAccessKeyDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAccessKeyDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iam.CfnGroup
class CfnGroupDef(BaseCfnResource):
    group_name: typing.Optional[str] = pydantic.Field(None, description='The name of the group to create. Do not include the path in this value. The group name must be unique within the account. Group names are not distinguished by case. For example, you cannot create groups named both "ADMINS" and "admins". If you don\'t specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the group name. .. epigraph:: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name. If you specify a name, you must specify the ``CAPABILITY_NAMED_IAM`` value to acknowledge your template\'s capabilities. For more information, see `Acknowledging IAM Resources in AWS CloudFormation Templates <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html#using-iam-capabilities>`_ . .. epigraph:: Naming an IAM resource can cause an unrecoverable error if you reuse the same template in multiple Regions. To prevent this, we recommend using ``Fn::Join`` and ``AWS::Region`` to create a Region-specific name, as in the following example: ``{"Fn::Join": ["", [{"Ref": "AWS::Region"}, {"Ref": "MyResourceName"}]]}`` .\n')
    managed_policy_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the IAM policy you want to attach. For more information about ARNs, see `Amazon Resource Names (ARNs) <https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html>`_ in the *AWS General Reference* .\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path to the group. For more information about paths, see `IAM identifiers <https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html>`_ in the *IAM User Guide* . This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! ( ``\\u0021`` ) through the DEL character ( ``\\u007F`` ), including most punctuation characters, digits, and upper and lowercased letters.\n')
    policies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iam.CfnGroup_PolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="Adds or updates an inline policy document that is embedded in the specified IAM group. To view AWS::IAM::Group snippets, see `Declaring an IAM Group Resource <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-iam.html#scenario-iam-group>`_ . .. epigraph:: The name of each inline policy for a role, user, or group must be unique. If you don't choose unique names, updates to the IAM identity will fail. For information about limits on the number of inline policies that you can embed in a group, see `Limitations on IAM Entities <https://docs.aws.amazon.com/IAM/latest/UserGuide/LimitationsOnEntities.html>`_ in the *IAM User Guide* .")
    _init_params: typing.ClassVar[list[str]] = ['group_name', 'managed_policy_arns', 'path', 'policies']
    _method_names: typing.ClassVar[list[str]] = ['PolicyProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnGroupDefConfig] = pydantic.Field(None)


class CfnGroupDefConfig(pydantic.BaseModel):
    PolicyProperty: typing.Optional[list[CfnGroupDefPolicypropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnGroupDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnGroupDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnGroupDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnGroupDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnGroupDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnGroupDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnGroupDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnGroupDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnGroupDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnGroupDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnGroupDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnGroupDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnGroupDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnGroupDefPolicypropertyParams(pydantic.BaseModel):
    policy_document: typing.Any = pydantic.Field(..., description='')
    policy_name: str = pydantic.Field(..., description='')
    ...

class CfnGroupDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnGroupDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGroupDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnGroupDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGroupDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnGroupDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnGroupDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnGroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnGroupDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnGroupDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGroupDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnGroupDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnGroupDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGroupDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iam.CfnGroupPolicy
class CfnGroupPolicyDef(BaseCfnResource):
    group_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the group to associate the policy with. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-.\n')
    policy_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the policy document. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    policy_document: typing.Any = pydantic.Field(None, description='The policy document. You must provide policies in JSON format in IAM. However, for AWS CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ used to validate this parameter is a string of characters consisting of the following: - Any printable ASCII character ranging from the space character ( ``\\u0020`` ) through the end of the ASCII character range - The printable characters in the Basic Latin and Latin-1 Supplement character set (through ``\\u00FF`` ) - The special characters tab ( ``\\u0009`` ), line feed ( ``\\u000A`` ), and carriage return ( ``\\u000D`` )')
    _init_params: typing.ClassVar[list[str]] = ['group_name', 'policy_name', 'policy_document']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnGroupPolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnGroupPolicyDefConfig] = pydantic.Field(None)


class CfnGroupPolicyDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnGroupPolicyDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnGroupPolicyDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnGroupPolicyDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnGroupPolicyDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnGroupPolicyDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnGroupPolicyDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnGroupPolicyDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnGroupPolicyDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnGroupPolicyDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnGroupPolicyDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnGroupPolicyDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnGroupPolicyDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnGroupPolicyDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnGroupPolicyDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnGroupPolicyDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGroupPolicyDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnGroupPolicyDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGroupPolicyDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnGroupPolicyDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnGroupPolicyDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnGroupPolicyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnGroupPolicyDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnGroupPolicyDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGroupPolicyDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnGroupPolicyDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnGroupPolicyDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGroupPolicyDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iam.CfnInstanceProfile
class CfnInstanceProfileDef(BaseCfnResource):
    roles: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the role to associate with the instance profile. Only one role can be assigned to an EC2 instance at a time, and all applications on the instance share the same role and permissions.\n')
    instance_profile_name: typing.Optional[str] = pydantic.Field(None, description='The name of the instance profile to create. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path to the instance profile. For more information about paths, see `IAM Identifiers <https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html>`_ in the *IAM User Guide* . This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! ( ``\\u0021`` ) through the DEL character ( ``\\u007F`` ), including most punctuation characters, digits, and upper and lowercased letters.')
    _init_params: typing.ClassVar[list[str]] = ['roles', 'instance_profile_name', 'path']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnInstanceProfile'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnInstanceProfileDefConfig] = pydantic.Field(None)


class CfnInstanceProfileDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnInstanceProfileDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnInstanceProfileDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnInstanceProfileDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnInstanceProfileDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnInstanceProfileDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnInstanceProfileDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnInstanceProfileDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnInstanceProfileDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnInstanceProfileDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnInstanceProfileDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnInstanceProfileDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnInstanceProfileDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnInstanceProfileDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnInstanceProfileDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnInstanceProfileDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnInstanceProfileDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnInstanceProfileDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnInstanceProfileDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnInstanceProfileDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnInstanceProfileDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnInstanceProfileDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnInstanceProfileDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnInstanceProfileDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnInstanceProfileDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnInstanceProfileDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnInstanceProfileDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnInstanceProfileDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iam.CfnManagedPolicy
class CfnManagedPolicyDef(BaseCfnResource):
    policy_document: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The JSON policy document that you want to use as the content for the new policy. You must provide policies in JSON format in IAM. However, for AWS CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see `IAM and AWS STS character quotas <https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length>`_ . To learn more about JSON policy grammar, see `Grammar of the IAM JSON policy language <https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_grammar.html>`_ in the *IAM User Guide* . The `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ used to validate this parameter is a string of characters consisting of the following: - Any printable ASCII character ranging from the space character ( ``\\u0020`` ) through the end of the ASCII character range - The printable characters in the Basic Latin and Latin-1 Supplement character set (through ``\\u00FF`` ) - The special characters tab ( ``\\u0009`` ), line feed ( ``\\u000A`` ), and carriage return ( ``\\u000D`` )\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A friendly description of the policy. Typically used to store information about the permissions defined in the policy. For example, "Grants access to production DynamoDB tables." The policy description is immutable. After a value is assigned, it cannot be changed.\n')
    groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The name (friendly name, not ARN) of the group to attach the policy to. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    managed_policy_name: typing.Optional[str] = pydantic.Field(None, description='The friendly name of the policy. .. epigraph:: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name. If you specify a name, you must specify the ``CAPABILITY_NAMED_IAM`` value to acknowledge your template\'s capabilities. For more information, see `Acknowledging IAM Resources in AWS CloudFormation Templates <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html#using-iam-capabilities>`_ . .. epigraph:: Naming an IAM resource can cause an unrecoverable error if you reuse the same template in multiple Regions. To prevent this, we recommend using ``Fn::Join`` and ``AWS::Region`` to create a Region-specific name, as in the following example: ``{"Fn::Join": ["", [{"Ref": "AWS::Region"}, {"Ref": "MyResourceName"}]]}`` .\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path for the policy. For more information about paths, see `IAM identifiers <https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html>`_ in the *IAM User Guide* . This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! ( ``\\u0021`` ) through the DEL character ( ``\\u007F`` ), including most punctuation characters, digits, and upper and lowercased letters. .. epigraph:: You cannot use an asterisk (*) in the path name.\n')
    roles: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The name (friendly name, not ARN) of the role to attach the policy to. This parameter allows (per its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@- .. epigraph:: If an external policy (such as ``AWS::IAM::Policy`` or ``AWS::IAM::ManagedPolicy`` ) has a ``Ref`` to a role and if a resource (such as ``AWS::ECS::Service`` ) also has a ``Ref`` to the same role, add a ``DependsOn`` attribute to the resource to make the resource depend on the external policy. This dependency ensures that the role's policy is available throughout the resource's lifecycle. For example, when you delete a stack with an ``AWS::ECS::Service`` resource, the ``DependsOn`` attribute ensures that AWS CloudFormation deletes the ``AWS::ECS::Service`` resource before deleting its role's policy.\n")
    users: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The name (friendly name, not ARN) of the IAM user to attach the policy to. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-')
    _init_params: typing.ClassVar[list[str]] = ['policy_document', 'description', 'groups', 'managed_policy_name', 'path', 'roles', 'users']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnManagedPolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnManagedPolicyDefConfig] = pydantic.Field(None)


class CfnManagedPolicyDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnManagedPolicyDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnManagedPolicyDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnManagedPolicyDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnManagedPolicyDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnManagedPolicyDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnManagedPolicyDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnManagedPolicyDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnManagedPolicyDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnManagedPolicyDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnManagedPolicyDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnManagedPolicyDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnManagedPolicyDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnManagedPolicyDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_is_attachable_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)

class CfnManagedPolicyDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnManagedPolicyDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnManagedPolicyDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnManagedPolicyDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnManagedPolicyDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnManagedPolicyDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnManagedPolicyDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnManagedPolicyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnManagedPolicyDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnManagedPolicyDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnManagedPolicyDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnManagedPolicyDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnManagedPolicyDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnManagedPolicyDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iam.CfnOIDCProvider
class CfnOIDCProviderDef(BaseCfnResource):
    thumbprint_list: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of certificate thumbprints that are associated with the specified IAM OIDC provider resource object. For more information, see `CreateOpenIDConnectProvider <https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateOpenIDConnectProvider.html>`_ .\n')
    client_id_list: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of client IDs (also known as audiences) that are associated with the specified IAM OIDC provider resource object. For more information, see `CreateOpenIDConnectProvider <https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateOpenIDConnectProvider.html>`_ .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of tags that are attached to the specified IAM OIDC provider. The returned list of tags is sorted by tag key. For more information about tagging, see `Tagging IAM resources <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html>`_ in the *IAM User Guide* .\n')
    url: typing.Optional[str] = pydantic.Field(None, description='The URL that the IAM OIDC provider resource object is associated with. For more information, see `CreateOpenIDConnectProvider <https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateOpenIDConnectProvider.html>`_ .')
    _init_params: typing.ClassVar[list[str]] = ['thumbprint_list', 'client_id_list', 'tags', 'url']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnOIDCProvider'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnOIDCProviderDefConfig] = pydantic.Field(None)


class CfnOIDCProviderDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnOIDCProviderDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnOIDCProviderDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnOIDCProviderDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnOIDCProviderDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnOIDCProviderDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnOIDCProviderDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnOIDCProviderDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnOIDCProviderDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnOIDCProviderDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnOIDCProviderDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnOIDCProviderDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnOIDCProviderDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnOIDCProviderDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnOIDCProviderDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnOIDCProviderDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnOIDCProviderDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnOIDCProviderDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnOIDCProviderDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnOIDCProviderDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnOIDCProviderDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnOIDCProviderDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnOIDCProviderDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnOIDCProviderDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnOIDCProviderDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnOIDCProviderDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnOIDCProviderDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnOIDCProviderDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iam.CfnPolicy
class CfnPolicyDef(BaseCfnResource):
    policy_document: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The policy document. You must provide policies in JSON format in IAM. However, for AWS CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ used to validate this parameter is a string of characters consisting of the following: - Any printable ASCII character ranging from the space character ( ``\\u0020`` ) through the end of the ASCII character range - The printable characters in the Basic Latin and Latin-1 Supplement character set (through ``\\u00FF`` ) - The special characters tab ( ``\\u0009`` ), line feed ( ``\\u000A`` ), and carriage return ( ``\\u000D`` )\n')
    policy_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the policy document. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The name of the group to associate the policy with. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-.\n')
    roles: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The name of the role to associate the policy with. This parameter allows (per its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@- .. epigraph:: If an external policy (such as ``AWS::IAM::Policy`` or ``AWS::IAM::ManagedPolicy`` ) has a ``Ref`` to a role and if a resource (such as ``AWS::ECS::Service`` ) also has a ``Ref`` to the same role, add a ``DependsOn`` attribute to the resource to make the resource depend on the external policy. This dependency ensures that the role's policy is available throughout the resource's lifecycle. For example, when you delete a stack with an ``AWS::ECS::Service`` resource, the ``DependsOn`` attribute ensures that AWS CloudFormation deletes the ``AWS::ECS::Service`` resource before deleting its role's policy.\n")
    users: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The name of the user to associate the policy with. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-')
    _init_params: typing.ClassVar[list[str]] = ['policy_document', 'policy_name', 'groups', 'roles', 'users']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnPolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnPolicyDefConfig] = pydantic.Field(None)


class CfnPolicyDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnPolicyDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnPolicyDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnPolicyDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnPolicyDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnPolicyDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnPolicyDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnPolicyDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnPolicyDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnPolicyDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnPolicyDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnPolicyDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnPolicyDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnPolicyDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnPolicyDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPolicyDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPolicyDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPolicyDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPolicyDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPolicyDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPolicyDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPolicyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPolicyDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPolicyDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPolicyDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnPolicyDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPolicyDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPolicyDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iam.CfnRole
class CfnRoleDef(BaseCfnResource):
    assume_role_policy_document: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The trust policy that is associated with this role. Trust policies define which entities can assume the role. You can associate only one trust policy with a role. For an example of a policy that can be used to assume a role, see `Template Examples <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html#aws-resource-iam-role--examples>`_ . For more information about the elements that you can use in an IAM policy, see `IAM Policy Elements Reference <https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements.html>`_ in the *IAM User Guide* .\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the role that you provide.\n')
    managed_policy_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of Amazon Resource Names (ARNs) of the IAM managed policies that you want to attach to the role. For more information about ARNs, see `Amazon Resource Names (ARNs) and AWS Service Namespaces <https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html>`_ in the *AWS General Reference* .\n')
    max_session_duration: typing.Union[int, float, None] = pydantic.Field(None, description="The maximum session duration (in seconds) that you want to set for the specified role. If you do not specify a value for this setting, the default value of one hour is applied. This setting can have a value from 1 hour to 12 hours. Anyone who assumes the role from the AWS CLI or API can use the ``DurationSeconds`` API parameter or the ``duration-seconds`` AWS CLI parameter to request a longer session. The ``MaxSessionDuration`` setting determines the maximum duration that can be requested using the ``DurationSeconds`` parameter. If users don't specify a value for the ``DurationSeconds`` parameter, their security credentials are valid for one hour by default. This applies when you use the ``AssumeRole*`` API operations or the ``assume-role*`` AWS CLI operations but does not apply when you use those operations to create a console URL. For more information, see `Using IAM roles <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html>`_ in the *IAM User Guide* .\n")
    path: typing.Optional[str] = pydantic.Field(None, description='The path to the role. For more information about paths, see `IAM Identifiers <https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html>`_ in the *IAM User Guide* . This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! ( ``\\u0021`` ) through the DEL character ( ``\\u007F`` ), including most punctuation characters, digits, and upper and lowercased letters. Default: - "/"\n')
    permissions_boundary: typing.Optional[str] = pydantic.Field(None, description='The ARN of the policy used to set the permissions boundary for the role. For more information about permissions boundaries, see `Permissions boundaries for IAM identities <https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html>`_ in the *IAM User Guide* .\n')
    policies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iam.CfnRole_PolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="Adds or updates an inline policy document that is embedded in the specified IAM role. When you embed an inline policy in a role, the inline policy is used as part of the role's access (permissions) policy. The role's trust policy is created at the same time as the role. You can update a role's trust policy later. For more information about IAM roles, go to `Using Roles to Delegate Permissions and Federate Identities <https://docs.aws.amazon.com/IAM/latest/UserGuide/roles-toplevel.html>`_ . A role can also have an attached managed policy. For information about policies, see `Managed Policies and Inline Policies <https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html>`_ in the *IAM User Guide* . For information about limits on the number of inline policies that you can embed with a role, see `Limitations on IAM Entities <https://docs.aws.amazon.com/IAM/latest/UserGuide/LimitationsOnEntities.html>`_ in the *IAM User Guide* . .. epigraph:: If an external policy (such as ``AWS::IAM::Policy`` or ``AWS::IAM::ManagedPolicy`` ) has a ``Ref`` to a role and if a resource (such as ``AWS::ECS::Service`` ) also has a ``Ref`` to the same role, add a ``DependsOn`` attribute to the resource to make the resource depend on the external policy. This dependency ensures that the role's policy is available throughout the resource's lifecycle. For example, when you delete a stack with an ``AWS::ECS::Service`` resource, the ``DependsOn`` attribute ensures that AWS CloudFormation deletes the ``AWS::ECS::Service`` resource before deleting its role's policy.\n")
    role_name: typing.Optional[str] = pydantic.Field(None, description='A name for the IAM role, up to 64 characters in length. For valid values, see the ``RoleName`` parameter for the ```CreateRole`` <https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html>`_ action in the *IAM User Guide* . This parameter allows (per its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-. The role name must be unique within the account. Role names are not distinguished by case. For example, you cannot create roles named both "Role1" and "role1". If you don\'t specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the role name. If you specify a name, you must specify the ``CAPABILITY_NAMED_IAM`` value to acknowledge your template\'s capabilities. For more information, see `Acknowledging IAM Resources in AWS CloudFormation Templates <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html#using-iam-capabilities>`_ . .. epigraph:: Naming an IAM resource can cause an unrecoverable error if you reuse the same template in multiple Regions. To prevent this, we recommend using ``Fn::Join`` and ``AWS::Region`` to create a Region-specific name, as in the following example: ``{"Fn::Join": ["", [{"Ref": "AWS::Region"}, {"Ref": "MyResourceName"}]]}`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of tags that are attached to the role. For more information about tagging, see `Tagging IAM resources <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html>`_ in the *IAM User Guide* .')
    _init_params: typing.ClassVar[list[str]] = ['assume_role_policy_document', 'description', 'managed_policy_arns', 'max_session_duration', 'path', 'permissions_boundary', 'policies', 'role_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['PolicyProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnRole'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnRoleDefConfig] = pydantic.Field(None)


class CfnRoleDefConfig(pydantic.BaseModel):
    PolicyProperty: typing.Optional[list[CfnRoleDefPolicypropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnRoleDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnRoleDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnRoleDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnRoleDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnRoleDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnRoleDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnRoleDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnRoleDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnRoleDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnRoleDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnRoleDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnRoleDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnRoleDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnRoleDefPolicypropertyParams(pydantic.BaseModel):
    policy_document: typing.Any = pydantic.Field(..., description='')
    policy_name: str = pydantic.Field(..., description='')
    ...

class CfnRoleDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnRoleDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRoleDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnRoleDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRoleDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnRoleDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnRoleDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnRoleDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnRoleDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnRoleDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRoleDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnRoleDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnRoleDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRoleDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iam.CfnRolePolicy
class CfnRolePolicyDef(BaseCfnResource):
    policy_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the policy document. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    role_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the role to associate the policy with. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    policy_document: typing.Any = pydantic.Field(None, description='The policy document. You must provide policies in JSON format in IAM. However, for AWS CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ used to validate this parameter is a string of characters consisting of the following: - Any printable ASCII character ranging from the space character ( ``\\u0020`` ) through the end of the ASCII character range - The printable characters in the Basic Latin and Latin-1 Supplement character set (through ``\\u00FF`` ) - The special characters tab ( ``\\u0009`` ), line feed ( ``\\u000A`` ), and carriage return ( ``\\u000D`` )')
    _init_params: typing.ClassVar[list[str]] = ['policy_name', 'role_name', 'policy_document']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnRolePolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnRolePolicyDefConfig] = pydantic.Field(None)


class CfnRolePolicyDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnRolePolicyDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnRolePolicyDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnRolePolicyDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnRolePolicyDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnRolePolicyDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnRolePolicyDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnRolePolicyDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnRolePolicyDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnRolePolicyDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnRolePolicyDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnRolePolicyDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnRolePolicyDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnRolePolicyDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnRolePolicyDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnRolePolicyDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRolePolicyDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnRolePolicyDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRolePolicyDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnRolePolicyDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnRolePolicyDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnRolePolicyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnRolePolicyDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnRolePolicyDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRolePolicyDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnRolePolicyDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnRolePolicyDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRolePolicyDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iam.CfnSAMLProvider
class CfnSAMLProviderDef(BaseCfnResource):
    saml_metadata_document: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="An XML document generated by an identity provider (IdP) that supports SAML 2.0. The document includes the issuer's name, expiration information, and keys that can be used to validate the SAML authentication response (assertions) that are received from the IdP. You must generate the metadata document using the identity management software that is used as your organization's IdP. For more information, see `About SAML 2.0-based federation <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_saml.html>`_ in the *IAM User Guide*\n")
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the provider to create. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of tags that you want to attach to the new IAM SAML provider. Each tag consists of a key name and an associated value. For more information about tagging, see `Tagging IAM resources <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html>`_ in the *IAM User Guide* . .. epigraph:: If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.')
    _init_params: typing.ClassVar[list[str]] = ['saml_metadata_document', 'name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnSAMLProvider'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnSAMLProviderDefConfig] = pydantic.Field(None)


class CfnSAMLProviderDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnSAMLProviderDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnSAMLProviderDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnSAMLProviderDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnSAMLProviderDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnSAMLProviderDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnSAMLProviderDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnSAMLProviderDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnSAMLProviderDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnSAMLProviderDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnSAMLProviderDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnSAMLProviderDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnSAMLProviderDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnSAMLProviderDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnSAMLProviderDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSAMLProviderDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSAMLProviderDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSAMLProviderDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSAMLProviderDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSAMLProviderDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSAMLProviderDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSAMLProviderDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSAMLProviderDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSAMLProviderDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSAMLProviderDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnSAMLProviderDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSAMLProviderDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSAMLProviderDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iam.CfnServerCertificate
class CfnServerCertificateDef(BaseCfnResource):
    certificate_body: typing.Optional[str] = pydantic.Field(None, description='The contents of the public key certificate.\n')
    certificate_chain: typing.Optional[str] = pydantic.Field(None, description='The contents of the public key certificate chain.\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path for the server certificate. For more information about paths, see `IAM identifiers <https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html>`_ in the *IAM User Guide* . This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! ( ``\\u0021`` ) through the DEL character ( ``\\u007F`` ), including most punctuation characters, digits, and upper and lowercased letters. .. epigraph:: If you are uploading a server certificate specifically for use with Amazon CloudFront distributions, you must specify a path using the ``path`` parameter. The path must begin with ``/cloudfront`` and must include a trailing slash (for example, ``/cloudfront/test/`` ).\n')
    private_key: typing.Optional[str] = pydantic.Field(None, description='The contents of the private key in PEM-encoded format. The `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ used to validate this parameter is a string of characters consisting of the following: - Any printable ASCII character ranging from the space character ( ``\\u0020`` ) through the end of the ASCII character range - The printable characters in the Basic Latin and Latin-1 Supplement character set (through ``\\u00FF`` ) - The special characters tab ( ``\\u0009`` ), line feed ( ``\\u000A`` ), and carriage return ( ``\\u000D`` )\n')
    server_certificate_name: typing.Optional[str] = pydantic.Field(None, description='The name for the server certificate. Do not include the path in this value. The name of the certificate cannot contain any spaces. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of tags that are attached to the server certificate. For more information about tagging, see `Tagging IAM resources <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html>`_ in the *IAM User Guide* .')
    _init_params: typing.ClassVar[list[str]] = ['certificate_body', 'certificate_chain', 'path', 'private_key', 'server_certificate_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnServerCertificate'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnServerCertificateDefConfig] = pydantic.Field(None)


class CfnServerCertificateDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnServerCertificateDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnServerCertificateDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnServerCertificateDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnServerCertificateDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnServerCertificateDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnServerCertificateDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnServerCertificateDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnServerCertificateDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnServerCertificateDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnServerCertificateDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnServerCertificateDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnServerCertificateDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnServerCertificateDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnServerCertificateDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnServerCertificateDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnServerCertificateDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnServerCertificateDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnServerCertificateDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnServerCertificateDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnServerCertificateDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnServerCertificateDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnServerCertificateDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnServerCertificateDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnServerCertificateDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnServerCertificateDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnServerCertificateDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnServerCertificateDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iam.CfnServiceLinkedRole
class CfnServiceLinkedRoleDef(BaseCfnResource):
    aws_service_name: typing.Optional[str] = pydantic.Field(None, description='The service principal for the AWS service to which this role is attached. You use a string similar to a URL but without the http:// in front. For example: ``elasticbeanstalk.amazonaws.com`` . Service principals are unique and case-sensitive. To find the exact service principal for your service-linked role, see `AWS services that work with IAM <https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_aws-services-that-work-with-iam.html>`_ in the *IAM User Guide* . Look for the services that have *Yes* in the *Service-Linked Role* column. Choose the *Yes* link to view the service-linked role documentation for that service.\n')
    custom_suffix: typing.Optional[str] = pydantic.Field(None, description='A string that you provide, which is combined with the service-provided prefix to form the complete role name. If you make multiple requests for the same service, then you must supply a different ``CustomSuffix`` for each request. Otherwise the request fails with a duplicate role name error. For example, you could add ``-1`` or ``-debug`` to the suffix. Some services do not support the ``CustomSuffix`` parameter. If you provide an optional suffix and the operation fails, try the operation again without the suffix.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the role.')
    _init_params: typing.ClassVar[list[str]] = ['aws_service_name', 'custom_suffix', 'description']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnServiceLinkedRole'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnServiceLinkedRoleDefConfig] = pydantic.Field(None)


class CfnServiceLinkedRoleDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnServiceLinkedRoleDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnServiceLinkedRoleDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnServiceLinkedRoleDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnServiceLinkedRoleDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnServiceLinkedRoleDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnServiceLinkedRoleDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnServiceLinkedRoleDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnServiceLinkedRoleDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnServiceLinkedRoleDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnServiceLinkedRoleDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnServiceLinkedRoleDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnServiceLinkedRoleDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnServiceLinkedRoleDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnServiceLinkedRoleDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnServiceLinkedRoleDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnServiceLinkedRoleDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnServiceLinkedRoleDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnServiceLinkedRoleDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnServiceLinkedRoleDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnServiceLinkedRoleDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnServiceLinkedRoleDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnServiceLinkedRoleDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnServiceLinkedRoleDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnServiceLinkedRoleDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnServiceLinkedRoleDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnServiceLinkedRoleDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnServiceLinkedRoleDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iam.CfnUser
class CfnUserDef(BaseCfnResource):
    groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of group names to which you want to add the user.\n')
    login_profile: typing.Union[models.UnsupportedResource, models.aws_iam.CfnUser_LoginProfilePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Creates a password for the specified IAM user. A password allows an IAM user to access AWS services through the AWS Management Console . You can use the AWS CLI , the AWS API, or the *Users* page in the IAM console to create a password for any IAM user. Use `ChangePassword <https://docs.aws.amazon.com/IAM/latest/APIReference/API_ChangePassword.html>`_ to update your own existing password in the *My Security Credentials* page in the AWS Management Console . For more information about managing passwords, see `Managing passwords <https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_ManagingLogins.html>`_ in the *IAM User Guide* .\n')
    managed_policy_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of Amazon Resource Names (ARNs) of the IAM managed policies that you want to attach to the user. For more information about ARNs, see `Amazon Resource Names (ARNs) and AWS Service Namespaces <https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html>`_ in the *AWS General Reference* .\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path for the user name. For more information about paths, see `IAM identifiers <https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html>`_ in the *IAM User Guide* . This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! ( ``\\u0021`` ) through the DEL character ( ``\\u007F`` ), including most punctuation characters, digits, and upper and lowercased letters.\n')
    permissions_boundary: typing.Optional[str] = pydantic.Field(None, description='The ARN of the managed policy that is used to set the permissions boundary for the user. A permissions boundary policy defines the maximum permissions that identity-based policies can grant to an entity, but does not grant permissions. Permissions boundaries do not define the maximum permissions that a resource-based policy can grant to an entity. To learn more, see `Permissions boundaries for IAM entities <https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html>`_ in the *IAM User Guide* . For more information about policy types, see `Policy types <https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policy-types>`_ in the *IAM User Guide* .\n')
    policies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iam.CfnUser_PolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="Adds or updates an inline policy document that is embedded in the specified IAM user. To view AWS::IAM::User snippets, see `Declaring an IAM User Resource <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-iam.html#scenario-iam-user>`_ . .. epigraph:: The name of each policy for a role, user, or group must be unique. If you don't choose unique names, updates to the IAM identity will fail. For information about limits on the number of inline policies that you can embed in a user, see `Limitations on IAM Entities <https://docs.aws.amazon.com/IAM/latest/UserGuide/LimitationsOnEntities.html>`_ in the *IAM User Guide* .\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of tags that you want to attach to the new user. Each tag consists of a key name and an associated value. For more information about tagging, see `Tagging IAM resources <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html>`_ in the *IAM User Guide* . .. epigraph:: If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.\n')
    user_name: typing.Optional[str] = pydantic.Field(None, description='The name of the user to create. Do not include the path in this value. This parameter allows (per its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-. The user name must be unique within the account. User names are not distinguished by case. For example, you cannot create users named both "John" and "john". If you don\'t specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the user name. If you specify a name, you must specify the ``CAPABILITY_NAMED_IAM`` value to acknowledge your template\'s capabilities. For more information, see `Acknowledging IAM Resources in AWS CloudFormation Templates <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html#using-iam-capabilities>`_ . .. epigraph:: Naming an IAM resource can cause an unrecoverable error if you reuse the same template in multiple Regions. To prevent this, we recommend using ``Fn::Join`` and ``AWS::Region`` to create a Region-specific name, as in the following example: ``{"Fn::Join": ["", [{"Ref": "AWS::Region"}, {"Ref": "MyResourceName"}]]}`` .')
    _init_params: typing.ClassVar[list[str]] = ['groups', 'login_profile', 'managed_policy_arns', 'path', 'permissions_boundary', 'policies', 'tags', 'user_name']
    _method_names: typing.ClassVar[list[str]] = ['LoginProfileProperty', 'PolicyProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnUser'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnUserDefConfig] = pydantic.Field(None)


class CfnUserDefConfig(pydantic.BaseModel):
    LoginProfileProperty: typing.Optional[list[CfnUserDefLoginprofilepropertyParams]] = pydantic.Field(None, description='')
    PolicyProperty: typing.Optional[list[CfnUserDefPolicypropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnUserDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnUserDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnUserDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnUserDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnUserDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnUserDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnUserDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnUserDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnUserDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnUserDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnUserDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnUserDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnUserDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnUserDefLoginprofilepropertyParams(pydantic.BaseModel):
    password: str = pydantic.Field(..., description='')
    password_reset_required: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnUserDefPolicypropertyParams(pydantic.BaseModel):
    policy_document: typing.Any = pydantic.Field(..., description='')
    policy_name: str = pydantic.Field(..., description='')
    ...

class CfnUserDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnUserDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnUserDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnUserDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnUserDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnUserDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnUserDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnUserDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnUserDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnUserDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnUserDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnUserDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnUserDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnUserDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iam.CfnUserPolicy
class CfnUserPolicyDef(BaseCfnResource):
    policy_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the policy document. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    user_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the user to associate the policy with. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    policy_document: typing.Any = pydantic.Field(None, description='The policy document. You must provide policies in JSON format in IAM. However, for AWS CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ used to validate this parameter is a string of characters consisting of the following: - Any printable ASCII character ranging from the space character ( ``\\u0020`` ) through the end of the ASCII character range - The printable characters in the Basic Latin and Latin-1 Supplement character set (through ``\\u00FF`` ) - The special characters tab ( ``\\u0009`` ), line feed ( ``\\u000A`` ), and carriage return ( ``\\u000D`` )')
    _init_params: typing.ClassVar[list[str]] = ['policy_name', 'user_name', 'policy_document']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnUserPolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnUserPolicyDefConfig] = pydantic.Field(None)


class CfnUserPolicyDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnUserPolicyDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnUserPolicyDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnUserPolicyDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnUserPolicyDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnUserPolicyDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnUserPolicyDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnUserPolicyDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnUserPolicyDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnUserPolicyDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnUserPolicyDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnUserPolicyDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnUserPolicyDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnUserPolicyDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnUserPolicyDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnUserPolicyDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnUserPolicyDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnUserPolicyDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnUserPolicyDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnUserPolicyDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnUserPolicyDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnUserPolicyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnUserPolicyDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnUserPolicyDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnUserPolicyDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnUserPolicyDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnUserPolicyDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnUserPolicyDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iam.CfnUserToGroupAddition
class CfnUserToGroupAdditionDef(BaseCfnResource):
    group_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the group to update. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    users: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of the names of the users that you want to add to the group.')
    _init_params: typing.ClassVar[list[str]] = ['group_name', 'users']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnUserToGroupAddition'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnUserToGroupAdditionDefConfig] = pydantic.Field(None)


class CfnUserToGroupAdditionDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnUserToGroupAdditionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnUserToGroupAdditionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnUserToGroupAdditionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnUserToGroupAdditionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnUserToGroupAdditionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnUserToGroupAdditionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnUserToGroupAdditionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnUserToGroupAdditionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnUserToGroupAdditionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnUserToGroupAdditionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnUserToGroupAdditionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnUserToGroupAdditionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnUserToGroupAdditionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnUserToGroupAdditionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnUserToGroupAdditionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnUserToGroupAdditionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnUserToGroupAdditionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnUserToGroupAdditionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnUserToGroupAdditionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnUserToGroupAdditionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnUserToGroupAdditionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnUserToGroupAdditionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnUserToGroupAdditionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnUserToGroupAdditionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnUserToGroupAdditionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnUserToGroupAdditionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnUserToGroupAdditionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iam.CfnVirtualMFADevice
class CfnVirtualMFADeviceDef(BaseCfnResource):
    users: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The IAM user associated with this virtual MFA device.\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path for the virtual MFA device. For more information about paths, see `IAM identifiers <https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html>`_ in the *IAM User Guide* . This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! ( ``\\u0021`` ) through the DEL character ( ``\\u007F`` ), including most punctuation characters, digits, and upper and lowercased letters.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of tags that you want to attach to the new IAM virtual MFA device. Each tag consists of a key name and an associated value. For more information about tagging, see `Tagging IAM resources <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html>`_ in the *IAM User Guide* . .. epigraph:: If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.\n')
    virtual_mfa_device_name: typing.Optional[str] = pydantic.Field(None, description='The name of the virtual MFA device, which must be unique. Use with path to uniquely identify a virtual MFA device. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-')
    _init_params: typing.ClassVar[list[str]] = ['users', 'path', 'tags', 'virtual_mfa_device_name']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnVirtualMFADevice'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVirtualMFADeviceDefConfig] = pydantic.Field(None)


class CfnVirtualMFADeviceDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnVirtualMFADeviceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVirtualMFADeviceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVirtualMFADeviceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVirtualMFADeviceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVirtualMFADeviceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVirtualMFADeviceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVirtualMFADeviceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVirtualMFADeviceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVirtualMFADeviceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVirtualMFADeviceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVirtualMFADeviceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVirtualMFADeviceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVirtualMFADeviceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnVirtualMFADeviceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVirtualMFADeviceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVirtualMFADeviceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVirtualMFADeviceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVirtualMFADeviceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVirtualMFADeviceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVirtualMFADeviceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVirtualMFADeviceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVirtualMFADeviceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVirtualMFADeviceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVirtualMFADeviceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnVirtualMFADeviceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVirtualMFADeviceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVirtualMFADeviceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iam.CfnAccessKeyProps
class CfnAccessKeyPropsDef(BaseCfnProperty):
    user_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the IAM user that the new key will belong to. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    serial: typing.Union[int, float, None] = pydantic.Field(None, description='This value is specific to CloudFormation and can only be *incremented* . Incrementing this value notifies CloudFormation that you want to rotate your access key. When you update your stack, CloudFormation will replace the existing access key with a new key.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='The status of the access key. ``Active`` means that the key is valid for API calls, while ``Inactive`` means it is not.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-accesskey.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    cfn_access_key_props = iam.CfnAccessKeyProps(\n        user_name="userName",\n\n        # the properties below are optional\n        serial=123,\n        status="status"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['user_name', 'serial', 'status']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnAccessKeyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CfnGroupPolicyProps
class CfnGroupPolicyPropsDef(BaseCfnProperty):
    group_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the group to associate the policy with. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-.\n')
    policy_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the policy document. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    policy_document: typing.Any = pydantic.Field(None, description='The policy document. You must provide policies in JSON format in IAM. However, for AWS CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ used to validate this parameter is a string of characters consisting of the following: - Any printable ASCII character ranging from the space character ( ``\\u0020`` ) through the end of the ASCII character range - The printable characters in the Basic Latin and Latin-1 Supplement character set (through ``\\u00FF`` ) - The special characters tab ( ``\\u0009`` ), line feed ( ``\\u000A`` ), and carriage return ( ``\\u000D`` )\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-grouppolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    # policy_document: Any\n\n    cfn_group_policy_props = iam.CfnGroupPolicyProps(\n        group_name="groupName",\n        policy_name="policyName",\n\n        # the properties below are optional\n        policy_document=policy_document\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['group_name', 'policy_name', 'policy_document']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnGroupPolicyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CfnGroupProps
class CfnGroupPropsDef(BaseCfnProperty):
    group_name: typing.Optional[str] = pydantic.Field(None, description='The name of the group to create. Do not include the path in this value. The group name must be unique within the account. Group names are not distinguished by case. For example, you cannot create groups named both "ADMINS" and "admins". If you don\'t specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the group name. .. epigraph:: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name. If you specify a name, you must specify the ``CAPABILITY_NAMED_IAM`` value to acknowledge your template\'s capabilities. For more information, see `Acknowledging IAM Resources in AWS CloudFormation Templates <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html#using-iam-capabilities>`_ . .. epigraph:: Naming an IAM resource can cause an unrecoverable error if you reuse the same template in multiple Regions. To prevent this, we recommend using ``Fn::Join`` and ``AWS::Region`` to create a Region-specific name, as in the following example: ``{"Fn::Join": ["", [{"Ref": "AWS::Region"}, {"Ref": "MyResourceName"}]]}`` .\n')
    managed_policy_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the IAM policy you want to attach. For more information about ARNs, see `Amazon Resource Names (ARNs) <https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html>`_ in the *AWS General Reference* .\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path to the group. For more information about paths, see `IAM identifiers <https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html>`_ in the *IAM User Guide* . This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! ( ``\\u0021`` ) through the DEL character ( ``\\u007F`` ), including most punctuation characters, digits, and upper and lowercased letters.\n')
    policies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iam.CfnGroup_PolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Adds or updates an inline policy document that is embedded in the specified IAM group. To view AWS::IAM::Group snippets, see `Declaring an IAM Group Resource <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-iam.html#scenario-iam-group>`_ . .. epigraph:: The name of each inline policy for a role, user, or group must be unique. If you don\'t choose unique names, updates to the IAM identity will fail. For information about limits on the number of inline policies that you can embed in a group, see `Limitations on IAM Entities <https://docs.aws.amazon.com/IAM/latest/UserGuide/LimitationsOnEntities.html>`_ in the *IAM User Guide* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-group.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    # policy_document: Any\n\n    cfn_group_props = iam.CfnGroupProps(\n        group_name="groupName",\n        managed_policy_arns=["managedPolicyArns"],\n        path="path",\n        policies=[iam.CfnGroup.PolicyProperty(\n            policy_document=policy_document,\n            policy_name="policyName"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['group_name', 'managed_policy_arns', 'path', 'policies']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnGroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CfnInstanceProfileProps
class CfnInstanceProfilePropsDef(BaseCfnProperty):
    roles: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the role to associate with the instance profile. Only one role can be assigned to an EC2 instance at a time, and all applications on the instance share the same role and permissions.\n')
    instance_profile_name: typing.Optional[str] = pydantic.Field(None, description='The name of the instance profile to create. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path to the instance profile. For more information about paths, see `IAM Identifiers <https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html>`_ in the *IAM User Guide* . This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! ( ``\\u0021`` ) through the DEL character ( ``\\u007F`` ), including most punctuation characters, digits, and upper and lowercased letters.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    cfn_instance_profile_props = iam.CfnInstanceProfileProps(\n        roles=["roles"],\n\n        # the properties below are optional\n        instance_profile_name="instanceProfileName",\n        path="path"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['roles', 'instance_profile_name', 'path']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnInstanceProfileProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CfnManagedPolicyProps
class CfnManagedPolicyPropsDef(BaseCfnProperty):
    policy_document: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The JSON policy document that you want to use as the content for the new policy. You must provide policies in JSON format in IAM. However, for AWS CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The maximum length of the policy document that you can pass in this operation, including whitespace, is listed below. To view the maximum character counts of a managed policy with no whitespaces, see `IAM and AWS STS character quotas <https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-quotas-entity-length>`_ . To learn more about JSON policy grammar, see `Grammar of the IAM JSON policy language <https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_grammar.html>`_ in the *IAM User Guide* . The `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ used to validate this parameter is a string of characters consisting of the following: - Any printable ASCII character ranging from the space character ( ``\\u0020`` ) through the end of the ASCII character range - The printable characters in the Basic Latin and Latin-1 Supplement character set (through ``\\u00FF`` ) - The special characters tab ( ``\\u0009`` ), line feed ( ``\\u000A`` ), and carriage return ( ``\\u000D`` )\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A friendly description of the policy. Typically used to store information about the permissions defined in the policy. For example, "Grants access to production DynamoDB tables." The policy description is immutable. After a value is assigned, it cannot be changed.\n')
    groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The name (friendly name, not ARN) of the group to attach the policy to. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    managed_policy_name: typing.Optional[str] = pydantic.Field(None, description='The friendly name of the policy. .. epigraph:: If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name. If you specify a name, you must specify the ``CAPABILITY_NAMED_IAM`` value to acknowledge your template\'s capabilities. For more information, see `Acknowledging IAM Resources in AWS CloudFormation Templates <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html#using-iam-capabilities>`_ . .. epigraph:: Naming an IAM resource can cause an unrecoverable error if you reuse the same template in multiple Regions. To prevent this, we recommend using ``Fn::Join`` and ``AWS::Region`` to create a Region-specific name, as in the following example: ``{"Fn::Join": ["", [{"Ref": "AWS::Region"}, {"Ref": "MyResourceName"}]]}`` .\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path for the policy. For more information about paths, see `IAM identifiers <https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html>`_ in the *IAM User Guide* . This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! ( ``\\u0021`` ) through the DEL character ( ``\\u007F`` ), including most punctuation characters, digits, and upper and lowercased letters. .. epigraph:: You cannot use an asterisk (*) in the path name.\n')
    roles: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The name (friendly name, not ARN) of the role to attach the policy to. This parameter allows (per its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@- .. epigraph:: If an external policy (such as ``AWS::IAM::Policy`` or ``AWS::IAM::ManagedPolicy`` ) has a ``Ref`` to a role and if a resource (such as ``AWS::ECS::Service`` ) also has a ``Ref`` to the same role, add a ``DependsOn`` attribute to the resource to make the resource depend on the external policy. This dependency ensures that the role's policy is available throughout the resource's lifecycle. For example, when you delete a stack with an ``AWS::ECS::Service`` resource, the ``DependsOn`` attribute ensures that AWS CloudFormation deletes the ``AWS::ECS::Service`` resource before deleting its role's policy.\n")
    users: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The name (friendly name, not ARN) of the IAM user to attach the policy to. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-managedpolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    # policy_document: Any\n\n    cfn_managed_policy_props = iam.CfnManagedPolicyProps(\n        policy_document=policy_document,\n\n        # the properties below are optional\n        description="description",\n        groups=["groups"],\n        managed_policy_name="managedPolicyName",\n        path="path",\n        roles=["roles"],\n        users=["users"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['policy_document', 'description', 'groups', 'managed_policy_name', 'path', 'roles', 'users']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnManagedPolicyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CfnOIDCProviderProps
class CfnOIDCProviderPropsDef(BaseCfnProperty):
    thumbprint_list: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of certificate thumbprints that are associated with the specified IAM OIDC provider resource object. For more information, see `CreateOpenIDConnectProvider <https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateOpenIDConnectProvider.html>`_ .\n')
    client_id_list: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of client IDs (also known as audiences) that are associated with the specified IAM OIDC provider resource object. For more information, see `CreateOpenIDConnectProvider <https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateOpenIDConnectProvider.html>`_ .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of tags that are attached to the specified IAM OIDC provider. The returned list of tags is sorted by tag key. For more information about tagging, see `Tagging IAM resources <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html>`_ in the *IAM User Guide* .\n')
    url: typing.Optional[str] = pydantic.Field(None, description='The URL that the IAM OIDC provider resource object is associated with. For more information, see `CreateOpenIDConnectProvider <https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateOpenIDConnectProvider.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-oidcprovider.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    cfn_oIDCProvider_props = iam.CfnOIDCProviderProps(\n        thumbprint_list=["thumbprintList"],\n\n        # the properties below are optional\n        client_id_list=["clientIdList"],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        url="url"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['thumbprint_list', 'client_id_list', 'tags', 'url']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnOIDCProviderProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CfnPolicyProps
class CfnPolicyPropsDef(BaseCfnProperty):
    policy_document: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The policy document. You must provide policies in JSON format in IAM. However, for AWS CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ used to validate this parameter is a string of characters consisting of the following: - Any printable ASCII character ranging from the space character ( ``\\u0020`` ) through the end of the ASCII character range - The printable characters in the Basic Latin and Latin-1 Supplement character set (through ``\\u00FF`` ) - The special characters tab ( ``\\u0009`` ), line feed ( ``\\u000A`` ), and carriage return ( ``\\u000D`` )\n')
    policy_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the policy document. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The name of the group to associate the policy with. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-.\n')
    roles: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The name of the role to associate the policy with. This parameter allows (per its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@- .. epigraph:: If an external policy (such as ``AWS::IAM::Policy`` or ``AWS::IAM::ManagedPolicy`` ) has a ``Ref`` to a role and if a resource (such as ``AWS::ECS::Service`` ) also has a ``Ref`` to the same role, add a ``DependsOn`` attribute to the resource to make the resource depend on the external policy. This dependency ensures that the role's policy is available throughout the resource's lifecycle. For example, when you delete a stack with an ``AWS::ECS::Service`` resource, the ``DependsOn`` attribute ensures that AWS CloudFormation deletes the ``AWS::ECS::Service`` resource before deleting its role's policy.\n")
    users: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The name of the user to associate the policy with. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    # policy_document: Any\n\n    cfn_policy_props = iam.CfnPolicyProps(\n        policy_document=policy_document,\n        policy_name="policyName",\n\n        # the properties below are optional\n        groups=["groups"],\n        roles=["roles"],\n        users=["users"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['policy_document', 'policy_name', 'groups', 'roles', 'users']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnPolicyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CfnRolePolicyProps
class CfnRolePolicyPropsDef(BaseCfnProperty):
    policy_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the policy document. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    role_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the role to associate the policy with. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    policy_document: typing.Any = pydantic.Field(None, description='The policy document. You must provide policies in JSON format in IAM. However, for AWS CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ used to validate this parameter is a string of characters consisting of the following: - Any printable ASCII character ranging from the space character ( ``\\u0020`` ) through the end of the ASCII character range - The printable characters in the Basic Latin and Latin-1 Supplement character set (through ``\\u00FF`` ) - The special characters tab ( ``\\u0009`` ), line feed ( ``\\u000A`` ), and carriage return ( ``\\u000D`` )\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-rolepolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    # policy_document: Any\n\n    cfn_role_policy_props = iam.CfnRolePolicyProps(\n        policy_name="policyName",\n        role_name="roleName",\n\n        # the properties below are optional\n        policy_document=policy_document\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['policy_name', 'role_name', 'policy_document']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnRolePolicyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CfnRoleProps
class CfnRolePropsDef(BaseCfnProperty):
    assume_role_policy_document: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The trust policy that is associated with this role. Trust policies define which entities can assume the role. You can associate only one trust policy with a role. For an example of a policy that can be used to assume a role, see `Template Examples <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html#aws-resource-iam-role--examples>`_ . For more information about the elements that you can use in an IAM policy, see `IAM Policy Elements Reference <https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements.html>`_ in the *IAM User Guide* .\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the role that you provide.\n')
    managed_policy_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of Amazon Resource Names (ARNs) of the IAM managed policies that you want to attach to the role. For more information about ARNs, see `Amazon Resource Names (ARNs) and AWS Service Namespaces <https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html>`_ in the *AWS General Reference* .\n')
    max_session_duration: typing.Union[int, float, None] = pydantic.Field(None, description="The maximum session duration (in seconds) that you want to set for the specified role. If you do not specify a value for this setting, the default value of one hour is applied. This setting can have a value from 1 hour to 12 hours. Anyone who assumes the role from the AWS CLI or API can use the ``DurationSeconds`` API parameter or the ``duration-seconds`` AWS CLI parameter to request a longer session. The ``MaxSessionDuration`` setting determines the maximum duration that can be requested using the ``DurationSeconds`` parameter. If users don't specify a value for the ``DurationSeconds`` parameter, their security credentials are valid for one hour by default. This applies when you use the ``AssumeRole*`` API operations or the ``assume-role*`` AWS CLI operations but does not apply when you use those operations to create a console URL. For more information, see `Using IAM roles <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html>`_ in the *IAM User Guide* .\n")
    path: typing.Optional[str] = pydantic.Field(None, description='The path to the role. For more information about paths, see `IAM Identifiers <https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html>`_ in the *IAM User Guide* . This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! ( ``\\u0021`` ) through the DEL character ( ``\\u007F`` ), including most punctuation characters, digits, and upper and lowercased letters. Default: - "/"\n')
    permissions_boundary: typing.Optional[str] = pydantic.Field(None, description='The ARN of the policy used to set the permissions boundary for the role. For more information about permissions boundaries, see `Permissions boundaries for IAM identities <https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html>`_ in the *IAM User Guide* .\n')
    policies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iam.CfnRole_PolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="Adds or updates an inline policy document that is embedded in the specified IAM role. When you embed an inline policy in a role, the inline policy is used as part of the role's access (permissions) policy. The role's trust policy is created at the same time as the role. You can update a role's trust policy later. For more information about IAM roles, go to `Using Roles to Delegate Permissions and Federate Identities <https://docs.aws.amazon.com/IAM/latest/UserGuide/roles-toplevel.html>`_ . A role can also have an attached managed policy. For information about policies, see `Managed Policies and Inline Policies <https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html>`_ in the *IAM User Guide* . For information about limits on the number of inline policies that you can embed with a role, see `Limitations on IAM Entities <https://docs.aws.amazon.com/IAM/latest/UserGuide/LimitationsOnEntities.html>`_ in the *IAM User Guide* . .. epigraph:: If an external policy (such as ``AWS::IAM::Policy`` or ``AWS::IAM::ManagedPolicy`` ) has a ``Ref`` to a role and if a resource (such as ``AWS::ECS::Service`` ) also has a ``Ref`` to the same role, add a ``DependsOn`` attribute to the resource to make the resource depend on the external policy. This dependency ensures that the role's policy is available throughout the resource's lifecycle. For example, when you delete a stack with an ``AWS::ECS::Service`` resource, the ``DependsOn`` attribute ensures that AWS CloudFormation deletes the ``AWS::ECS::Service`` resource before deleting its role's policy.\n")
    role_name: typing.Optional[str] = pydantic.Field(None, description='A name for the IAM role, up to 64 characters in length. For valid values, see the ``RoleName`` parameter for the ```CreateRole`` <https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html>`_ action in the *IAM User Guide* . This parameter allows (per its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-. The role name must be unique within the account. Role names are not distinguished by case. For example, you cannot create roles named both "Role1" and "role1". If you don\'t specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the role name. If you specify a name, you must specify the ``CAPABILITY_NAMED_IAM`` value to acknowledge your template\'s capabilities. For more information, see `Acknowledging IAM Resources in AWS CloudFormation Templates <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html#using-iam-capabilities>`_ . .. epigraph:: Naming an IAM resource can cause an unrecoverable error if you reuse the same template in multiple Regions. To prevent this, we recommend using ``Fn::Join`` and ``AWS::Region`` to create a Region-specific name, as in the following example: ``{"Fn::Join": ["", [{"Ref": "AWS::Region"}, {"Ref": "MyResourceName"}]]}`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of tags that are attached to the role. For more information about tagging, see `Tagging IAM resources <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html>`_ in the *IAM User Guide* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    # assume_role_policy_document: Any\n    # policy_document: Any\n\n    cfn_role_props = iam.CfnRoleProps(\n        assume_role_policy_document=assume_role_policy_document,\n\n        # the properties below are optional\n        description="description",\n        managed_policy_arns=["managedPolicyArns"],\n        max_session_duration=123,\n        path="path",\n        permissions_boundary="permissionsBoundary",\n        policies=[iam.CfnRole.PolicyProperty(\n            policy_document=policy_document,\n            policy_name="policyName"\n        )],\n        role_name="roleName",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['assume_role_policy_document', 'description', 'managed_policy_arns', 'max_session_duration', 'path', 'permissions_boundary', 'policies', 'role_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnRoleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CfnSAMLProviderProps
class CfnSAMLProviderPropsDef(BaseCfnProperty):
    saml_metadata_document: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="An XML document generated by an identity provider (IdP) that supports SAML 2.0. The document includes the issuer's name, expiration information, and keys that can be used to validate the SAML authentication response (assertions) that are received from the IdP. You must generate the metadata document using the identity management software that is used as your organization's IdP. For more information, see `About SAML 2.0-based federation <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_saml.html>`_ in the *IAM User Guide*\n")
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the provider to create. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of tags that you want to attach to the new IAM SAML provider. Each tag consists of a key name and an associated value. For more information about tagging, see `Tagging IAM resources <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html>`_ in the *IAM User Guide* . .. epigraph:: If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-samlprovider.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    cfn_sAMLProvider_props = iam.CfnSAMLProviderProps(\n        saml_metadata_document="samlMetadataDocument",\n\n        # the properties below are optional\n        name="name",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['saml_metadata_document', 'name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnSAMLProviderProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CfnServerCertificateProps
class CfnServerCertificatePropsDef(BaseCfnProperty):
    certificate_body: typing.Optional[str] = pydantic.Field(None, description='The contents of the public key certificate.\n')
    certificate_chain: typing.Optional[str] = pydantic.Field(None, description='The contents of the public key certificate chain.\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path for the server certificate. For more information about paths, see `IAM identifiers <https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html>`_ in the *IAM User Guide* . This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! ( ``\\u0021`` ) through the DEL character ( ``\\u007F`` ), including most punctuation characters, digits, and upper and lowercased letters. .. epigraph:: If you are uploading a server certificate specifically for use with Amazon CloudFront distributions, you must specify a path using the ``path`` parameter. The path must begin with ``/cloudfront`` and must include a trailing slash (for example, ``/cloudfront/test/`` ).\n')
    private_key: typing.Optional[str] = pydantic.Field(None, description='The contents of the private key in PEM-encoded format. The `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ used to validate this parameter is a string of characters consisting of the following: - Any printable ASCII character ranging from the space character ( ``\\u0020`` ) through the end of the ASCII character range - The printable characters in the Basic Latin and Latin-1 Supplement character set (through ``\\u00FF`` ) - The special characters tab ( ``\\u0009`` ), line feed ( ``\\u000A`` ), and carriage return ( ``\\u000D`` )\n')
    server_certificate_name: typing.Optional[str] = pydantic.Field(None, description='The name for the server certificate. Do not include the path in this value. The name of the certificate cannot contain any spaces. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of tags that are attached to the server certificate. For more information about tagging, see `Tagging IAM resources <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html>`_ in the *IAM User Guide* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-servercertificate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    cfn_server_certificate_props = iam.CfnServerCertificateProps(\n        certificate_body="certificateBody",\n        certificate_chain="certificateChain",\n        path="path",\n        private_key="privateKey",\n        server_certificate_name="serverCertificateName",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate_body', 'certificate_chain', 'path', 'private_key', 'server_certificate_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnServerCertificateProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CfnServiceLinkedRoleProps
class CfnServiceLinkedRolePropsDef(BaseCfnProperty):
    aws_service_name: typing.Optional[str] = pydantic.Field(None, description='The service principal for the AWS service to which this role is attached. You use a string similar to a URL but without the http:// in front. For example: ``elasticbeanstalk.amazonaws.com`` . Service principals are unique and case-sensitive. To find the exact service principal for your service-linked role, see `AWS services that work with IAM <https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_aws-services-that-work-with-iam.html>`_ in the *IAM User Guide* . Look for the services that have *Yes* in the *Service-Linked Role* column. Choose the *Yes* link to view the service-linked role documentation for that service.\n')
    custom_suffix: typing.Optional[str] = pydantic.Field(None, description='A string that you provide, which is combined with the service-provided prefix to form the complete role name. If you make multiple requests for the same service, then you must supply a different ``CustomSuffix`` for each request. Otherwise the request fails with a duplicate role name error. For example, you could add ``-1`` or ``-debug`` to the suffix. Some services do not support the ``CustomSuffix`` parameter. If you provide an optional suffix and the operation fails, try the operation again without the suffix.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the role.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-servicelinkedrole.html\n:exampleMetadata: infused\n\nExample::\n\n    slr = iam.CfnServiceLinkedRole(self, "ElasticSLR",\n        aws_service_name="es.amazonaws.com"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['aws_service_name', 'custom_suffix', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnServiceLinkedRoleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CfnUserPolicyProps
class CfnUserPolicyPropsDef(BaseCfnProperty):
    policy_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the policy document. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    user_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the user to associate the policy with. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    policy_document: typing.Any = pydantic.Field(None, description='The policy document. You must provide policies in JSON format in IAM. However, for AWS CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format. AWS CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ used to validate this parameter is a string of characters consisting of the following: - Any printable ASCII character ranging from the space character ( ``\\u0020`` ) through the end of the ASCII character range - The printable characters in the Basic Latin and Latin-1 Supplement character set (through ``\\u00FF`` ) - The special characters tab ( ``\\u0009`` ), line feed ( ``\\u000A`` ), and carriage return ( ``\\u000D`` )\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-userpolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    # policy_document: Any\n\n    cfn_user_policy_props = iam.CfnUserPolicyProps(\n        policy_name="policyName",\n        user_name="userName",\n\n        # the properties below are optional\n        policy_document=policy_document\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['policy_name', 'user_name', 'policy_document']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnUserPolicyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CfnUserProps
class CfnUserPropsDef(BaseCfnProperty):
    groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of group names to which you want to add the user.\n')
    login_profile: typing.Union[models.UnsupportedResource, models.aws_iam.CfnUser_LoginProfilePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Creates a password for the specified IAM user. A password allows an IAM user to access AWS services through the AWS Management Console . You can use the AWS CLI , the AWS API, or the *Users* page in the IAM console to create a password for any IAM user. Use `ChangePassword <https://docs.aws.amazon.com/IAM/latest/APIReference/API_ChangePassword.html>`_ to update your own existing password in the *My Security Credentials* page in the AWS Management Console . For more information about managing passwords, see `Managing passwords <https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_ManagingLogins.html>`_ in the *IAM User Guide* .\n')
    managed_policy_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of Amazon Resource Names (ARNs) of the IAM managed policies that you want to attach to the user. For more information about ARNs, see `Amazon Resource Names (ARNs) and AWS Service Namespaces <https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html>`_ in the *AWS General Reference* .\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path for the user name. For more information about paths, see `IAM identifiers <https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html>`_ in the *IAM User Guide* . This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! ( ``\\u0021`` ) through the DEL character ( ``\\u007F`` ), including most punctuation characters, digits, and upper and lowercased letters.\n')
    permissions_boundary: typing.Optional[str] = pydantic.Field(None, description='The ARN of the managed policy that is used to set the permissions boundary for the user. A permissions boundary policy defines the maximum permissions that identity-based policies can grant to an entity, but does not grant permissions. Permissions boundaries do not define the maximum permissions that a resource-based policy can grant to an entity. To learn more, see `Permissions boundaries for IAM entities <https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html>`_ in the *IAM User Guide* . For more information about policy types, see `Policy types <https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policy-types>`_ in the *IAM User Guide* .\n')
    policies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iam.CfnUser_PolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="Adds or updates an inline policy document that is embedded in the specified IAM user. To view AWS::IAM::User snippets, see `Declaring an IAM User Resource <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-iam.html#scenario-iam-user>`_ . .. epigraph:: The name of each policy for a role, user, or group must be unique. If you don't choose unique names, updates to the IAM identity will fail. For information about limits on the number of inline policies that you can embed in a user, see `Limitations on IAM Entities <https://docs.aws.amazon.com/IAM/latest/UserGuide/LimitationsOnEntities.html>`_ in the *IAM User Guide* .\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of tags that you want to attach to the new user. Each tag consists of a key name and an associated value. For more information about tagging, see `Tagging IAM resources <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html>`_ in the *IAM User Guide* . .. epigraph:: If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.\n')
    user_name: typing.Optional[str] = pydantic.Field(None, description='The name of the user to create. Do not include the path in this value. This parameter allows (per its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-. The user name must be unique within the account. User names are not distinguished by case. For example, you cannot create users named both "John" and "john". If you don\'t specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the user name. If you specify a name, you must specify the ``CAPABILITY_NAMED_IAM`` value to acknowledge your template\'s capabilities. For more information, see `Acknowledging IAM Resources in AWS CloudFormation Templates <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html#using-iam-capabilities>`_ . .. epigraph:: Naming an IAM resource can cause an unrecoverable error if you reuse the same template in multiple Regions. To prevent this, we recommend using ``Fn::Join`` and ``AWS::Region`` to create a Region-specific name, as in the following example: ``{"Fn::Join": ["", [{"Ref": "AWS::Region"}, {"Ref": "MyResourceName"}]]}`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-user.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    # policy_document: Any\n\n    cfn_user_props = iam.CfnUserProps(\n        groups=["groups"],\n        login_profile=iam.CfnUser.LoginProfileProperty(\n            password="password",\n\n            # the properties below are optional\n            password_reset_required=False\n        ),\n        managed_policy_arns=["managedPolicyArns"],\n        path="path",\n        permissions_boundary="permissionsBoundary",\n        policies=[iam.CfnUser.PolicyProperty(\n            policy_document=policy_document,\n            policy_name="policyName"\n        )],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        user_name="userName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['groups', 'login_profile', 'managed_policy_arns', 'path', 'permissions_boundary', 'policies', 'tags', 'user_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnUserProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CfnUserToGroupAdditionProps
class CfnUserToGroupAdditionPropsDef(BaseCfnProperty):
    group_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the group to update. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n')
    users: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of the names of the users that you want to add to the group.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-usertogroupaddition.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    cfn_user_to_group_addition_props = iam.CfnUserToGroupAdditionProps(\n        group_name="groupName",\n        users=["users"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['group_name', 'users']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnUserToGroupAdditionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iam.CfnVirtualMFADeviceProps
class CfnVirtualMFADevicePropsDef(BaseCfnProperty):
    users: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The IAM user associated with this virtual MFA device.\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The path for the virtual MFA device. For more information about paths, see `IAM identifiers <https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html>`_ in the *IAM User Guide* . This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! ( ``\\u0021`` ) through the DEL character ( ``\\u007F`` ), including most punctuation characters, digits, and upper and lowercased letters.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of tags that you want to attach to the new IAM virtual MFA device. Each tag consists of a key name and an associated value. For more information about tagging, see `Tagging IAM resources <https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html>`_ in the *IAM User Guide* . .. epigraph:: If any one of the tags is invalid or if you exceed the allowed maximum number of tags, then the entire request fails and the resource is not created.\n')
    virtual_mfa_device_name: typing.Optional[str] = pydantic.Field(None, description='The name of the virtual MFA device, which must be unique. Use with path to uniquely identify a virtual MFA device. This parameter allows (through its `regex pattern <https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex>`_ ) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-virtualmfadevice.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iam as iam\n\n    cfn_virtual_mFADevice_props = iam.CfnVirtualMFADeviceProps(\n        users=["users"],\n\n        # the properties below are optional\n        path="path",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        virtual_mfa_device_name="virtualMfaDeviceName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['users', 'path', 'tags', 'virtual_mfa_device_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iam.CfnVirtualMFADeviceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    AccountPrincipal: typing.Optional[dict[str, AccountPrincipalDef]] = pydantic.Field(None)
    AccountRootPrincipal: typing.Optional[dict[str, AccountRootPrincipalDef]] = pydantic.Field(None)
    AnyPrincipal: typing.Optional[dict[str, AnyPrincipalDef]] = pydantic.Field(None)
    ArnPrincipal: typing.Optional[dict[str, ArnPrincipalDef]] = pydantic.Field(None)
    CanonicalUserPrincipal: typing.Optional[dict[str, CanonicalUserPrincipalDef]] = pydantic.Field(None)
    ComparablePrincipal: typing.Optional[dict[str, ComparablePrincipalDef]] = pydantic.Field(None)
    CompositeDependable: typing.Optional[dict[str, CompositeDependableDef]] = pydantic.Field(None)
    CompositePrincipal: typing.Optional[dict[str, CompositePrincipalDef]] = pydantic.Field(None)
    FederatedPrincipal: typing.Optional[dict[str, FederatedPrincipalDef]] = pydantic.Field(None)
    Grant: typing.Optional[dict[str, GrantDef]] = pydantic.Field(None)
    OpenIdConnectPrincipal: typing.Optional[dict[str, OpenIdConnectPrincipalDef]] = pydantic.Field(None)
    OrganizationPrincipal: typing.Optional[dict[str, OrganizationPrincipalDef]] = pydantic.Field(None)
    PermissionsBoundary: typing.Optional[dict[str, PermissionsBoundaryDef]] = pydantic.Field(None)
    PolicyDocument: typing.Optional[dict[str, PolicyDocumentDef]] = pydantic.Field(None)
    PolicyStatement: typing.Optional[dict[str, PolicyStatementDef]] = pydantic.Field(None)
    PrincipalBase: typing.Optional[dict[str, PrincipalBaseDef]] = pydantic.Field(None)
    PrincipalPolicyFragment: typing.Optional[dict[str, PrincipalPolicyFragmentDef]] = pydantic.Field(None)
    PrincipalWithConditions: typing.Optional[dict[str, PrincipalWithConditionsDef]] = pydantic.Field(None)
    SamlConsolePrincipal: typing.Optional[dict[str, SamlConsolePrincipalDef]] = pydantic.Field(None)
    SamlMetadataDocument: typing.Optional[dict[str, SamlMetadataDocumentDef]] = pydantic.Field(None)
    SamlPrincipal: typing.Optional[dict[str, SamlPrincipalDef]] = pydantic.Field(None)
    ServicePrincipal: typing.Optional[dict[str, ServicePrincipalDef]] = pydantic.Field(None)
    SessionTagsPrincipal: typing.Optional[dict[str, SessionTagsPrincipalDef]] = pydantic.Field(None)
    StarPrincipal: typing.Optional[dict[str, StarPrincipalDef]] = pydantic.Field(None)
    UnknownPrincipal: typing.Optional[dict[str, UnknownPrincipalDef]] = pydantic.Field(None)
    WebIdentityPrincipal: typing.Optional[dict[str, WebIdentityPrincipalDef]] = pydantic.Field(None)
    AccessKey: typing.Optional[dict[str, AccessKeyDef]] = pydantic.Field(None)
    Group: typing.Optional[dict[str, GroupDef]] = pydantic.Field(None)
    InstanceProfile: typing.Optional[dict[str, InstanceProfileDef]] = pydantic.Field(None)
    LazyRole: typing.Optional[dict[str, LazyRoleDef]] = pydantic.Field(None)
    ManagedPolicy: typing.Optional[dict[str, ManagedPolicyDef]] = pydantic.Field(None)
    OpenIdConnectProvider: typing.Optional[dict[str, OpenIdConnectProviderDef]] = pydantic.Field(None)
    Policy: typing.Optional[dict[str, PolicyDef]] = pydantic.Field(None)
    Role: typing.Optional[dict[str, RoleDef]] = pydantic.Field(None)
    SamlProvider: typing.Optional[dict[str, SamlProviderDef]] = pydantic.Field(None)
    User: typing.Optional[dict[str, UserDef]] = pydantic.Field(None)
    AccessKeyProps: typing.Optional[dict[str, AccessKeyPropsDef]] = pydantic.Field(None)
    AddToPrincipalPolicyResult: typing.Optional[dict[str, AddToPrincipalPolicyResultDef]] = pydantic.Field(None)
    AddToResourcePolicyResult: typing.Optional[dict[str, AddToResourcePolicyResultDef]] = pydantic.Field(None)
    CfnGroup_PolicyProperty: typing.Optional[dict[str, CfnGroup_PolicyPropertyDef]] = pydantic.Field(None)
    CfnRole_PolicyProperty: typing.Optional[dict[str, CfnRole_PolicyPropertyDef]] = pydantic.Field(None)
    CfnUser_LoginProfileProperty: typing.Optional[dict[str, CfnUser_LoginProfilePropertyDef]] = pydantic.Field(None)
    CfnUser_PolicyProperty: typing.Optional[dict[str, CfnUser_PolicyPropertyDef]] = pydantic.Field(None)
    CommonGrantOptions: typing.Optional[dict[str, CommonGrantOptionsDef]] = pydantic.Field(None)
    CustomizeRolesOptions: typing.Optional[dict[str, CustomizeRolesOptionsDef]] = pydantic.Field(None)
    FromRoleArnOptions: typing.Optional[dict[str, FromRoleArnOptionsDef]] = pydantic.Field(None)
    FromRoleNameOptions: typing.Optional[dict[str, FromRoleNameOptionsDef]] = pydantic.Field(None)
    GrantOnPrincipalAndResourceOptions: typing.Optional[dict[str, GrantOnPrincipalAndResourceOptionsDef]] = pydantic.Field(None)
    GrantOnPrincipalOptions: typing.Optional[dict[str, GrantOnPrincipalOptionsDef]] = pydantic.Field(None)
    GrantWithResourceOptions: typing.Optional[dict[str, GrantWithResourceOptionsDef]] = pydantic.Field(None)
    GroupProps: typing.Optional[dict[str, GroupPropsDef]] = pydantic.Field(None)
    InstanceProfileAttributes: typing.Optional[dict[str, InstanceProfileAttributesDef]] = pydantic.Field(None)
    InstanceProfileProps: typing.Optional[dict[str, InstanceProfilePropsDef]] = pydantic.Field(None)
    LazyRoleProps: typing.Optional[dict[str, LazyRolePropsDef]] = pydantic.Field(None)
    ManagedPolicyProps: typing.Optional[dict[str, ManagedPolicyPropsDef]] = pydantic.Field(None)
    OpenIdConnectProviderProps: typing.Optional[dict[str, OpenIdConnectProviderPropsDef]] = pydantic.Field(None)
    PolicyDocumentProps: typing.Optional[dict[str, PolicyDocumentPropsDef]] = pydantic.Field(None)
    PolicyProps: typing.Optional[dict[str, PolicyPropsDef]] = pydantic.Field(None)
    PolicyStatementProps: typing.Optional[dict[str, PolicyStatementPropsDef]] = pydantic.Field(None)
    RoleProps: typing.Optional[dict[str, RolePropsDef]] = pydantic.Field(None)
    SamlProviderProps: typing.Optional[dict[str, SamlProviderPropsDef]] = pydantic.Field(None)
    ServicePrincipalOpts: typing.Optional[dict[str, ServicePrincipalOptsDef]] = pydantic.Field(None)
    UnknownPrincipalProps: typing.Optional[dict[str, UnknownPrincipalPropsDef]] = pydantic.Field(None)
    UserAttributes: typing.Optional[dict[str, UserAttributesDef]] = pydantic.Field(None)
    UserProps: typing.Optional[dict[str, UserPropsDef]] = pydantic.Field(None)
    WithoutPolicyUpdatesOptions: typing.Optional[dict[str, WithoutPolicyUpdatesOptionsDef]] = pydantic.Field(None)
    CfnAccessKey: typing.Optional[dict[str, CfnAccessKeyDef]] = pydantic.Field(None)
    CfnGroup: typing.Optional[dict[str, CfnGroupDef]] = pydantic.Field(None)
    CfnGroupPolicy: typing.Optional[dict[str, CfnGroupPolicyDef]] = pydantic.Field(None)
    CfnInstanceProfile: typing.Optional[dict[str, CfnInstanceProfileDef]] = pydantic.Field(None)
    CfnManagedPolicy: typing.Optional[dict[str, CfnManagedPolicyDef]] = pydantic.Field(None)
    CfnOIDCProvider: typing.Optional[dict[str, CfnOIDCProviderDef]] = pydantic.Field(None)
    CfnPolicy: typing.Optional[dict[str, CfnPolicyDef]] = pydantic.Field(None)
    CfnRole: typing.Optional[dict[str, CfnRoleDef]] = pydantic.Field(None)
    CfnRolePolicy: typing.Optional[dict[str, CfnRolePolicyDef]] = pydantic.Field(None)
    CfnSAMLProvider: typing.Optional[dict[str, CfnSAMLProviderDef]] = pydantic.Field(None)
    CfnServerCertificate: typing.Optional[dict[str, CfnServerCertificateDef]] = pydantic.Field(None)
    CfnServiceLinkedRole: typing.Optional[dict[str, CfnServiceLinkedRoleDef]] = pydantic.Field(None)
    CfnUser: typing.Optional[dict[str, CfnUserDef]] = pydantic.Field(None)
    CfnUserPolicy: typing.Optional[dict[str, CfnUserPolicyDef]] = pydantic.Field(None)
    CfnUserToGroupAddition: typing.Optional[dict[str, CfnUserToGroupAdditionDef]] = pydantic.Field(None)
    CfnVirtualMFADevice: typing.Optional[dict[str, CfnVirtualMFADeviceDef]] = pydantic.Field(None)
    CfnAccessKeyProps: typing.Optional[dict[str, CfnAccessKeyPropsDef]] = pydantic.Field(None)
    CfnGroupPolicyProps: typing.Optional[dict[str, CfnGroupPolicyPropsDef]] = pydantic.Field(None)
    CfnGroupProps: typing.Optional[dict[str, CfnGroupPropsDef]] = pydantic.Field(None)
    CfnInstanceProfileProps: typing.Optional[dict[str, CfnInstanceProfilePropsDef]] = pydantic.Field(None)
    CfnManagedPolicyProps: typing.Optional[dict[str, CfnManagedPolicyPropsDef]] = pydantic.Field(None)
    CfnOIDCProviderProps: typing.Optional[dict[str, CfnOIDCProviderPropsDef]] = pydantic.Field(None)
    CfnPolicyProps: typing.Optional[dict[str, CfnPolicyPropsDef]] = pydantic.Field(None)
    CfnRolePolicyProps: typing.Optional[dict[str, CfnRolePolicyPropsDef]] = pydantic.Field(None)
    CfnRoleProps: typing.Optional[dict[str, CfnRolePropsDef]] = pydantic.Field(None)
    CfnSAMLProviderProps: typing.Optional[dict[str, CfnSAMLProviderPropsDef]] = pydantic.Field(None)
    CfnServerCertificateProps: typing.Optional[dict[str, CfnServerCertificatePropsDef]] = pydantic.Field(None)
    CfnServiceLinkedRoleProps: typing.Optional[dict[str, CfnServiceLinkedRolePropsDef]] = pydantic.Field(None)
    CfnUserPolicyProps: typing.Optional[dict[str, CfnUserPolicyPropsDef]] = pydantic.Field(None)
    CfnUserProps: typing.Optional[dict[str, CfnUserPropsDef]] = pydantic.Field(None)
    CfnUserToGroupAdditionProps: typing.Optional[dict[str, CfnUserToGroupAdditionPropsDef]] = pydantic.Field(None)
    CfnVirtualMFADeviceProps: typing.Optional[dict[str, CfnVirtualMFADevicePropsDef]] = pydantic.Field(None)
    ...
