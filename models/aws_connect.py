from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormBaseItemProperty
class CfnEvaluationForm_EvaluationFormBaseItemPropertyDef(BaseStruct):
    section: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormSectionPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A subsection or inner section of an item.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-evaluationform-evaluationformbaseitem.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    # evaluation_form_section_property_: connect.CfnEvaluationForm.EvaluationFormSectionProperty\n\n    evaluation_form_base_item_property = connect.CfnEvaluationForm.EvaluationFormBaseItemProperty(\n        section=connect.CfnEvaluationForm.EvaluationFormSectionProperty(\n            ref_id="refId",\n            title="title",\n\n            # the properties below are optional\n            instructions="instructions",\n            items=[connect.CfnEvaluationForm.EvaluationFormItemProperty(\n                question=connect.CfnEvaluationForm.EvaluationFormQuestionProperty(\n                    question_type="questionType",\n                    ref_id="refId",\n                    title="title",\n\n                    # the properties below are optional\n                    instructions="instructions",\n                    not_applicable_enabled=False,\n                    question_type_properties=connect.CfnEvaluationForm.EvaluationFormQuestionTypePropertiesProperty(\n                        numeric=connect.CfnEvaluationForm.EvaluationFormNumericQuestionPropertiesProperty(\n                            max_value=123,\n                            min_value=123,\n\n                            # the properties below are optional\n                            automation=connect.CfnEvaluationForm.EvaluationFormNumericQuestionAutomationProperty(\n                                property_value=connect.CfnEvaluationForm.NumericQuestionPropertyValueAutomationProperty(\n                                    label="label"\n                                )\n                            ),\n                            options=[connect.CfnEvaluationForm.EvaluationFormNumericQuestionOptionProperty(\n                                max_value=123,\n                                min_value=123,\n\n                                # the properties below are optional\n                                automatic_fail=False,\n                                score=123\n                            )]\n                        ),\n                        single_select=connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionPropertiesProperty(\n                            options=[connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionOptionProperty(\n                                ref_id="refId",\n                                text="text",\n\n                                # the properties below are optional\n                                automatic_fail=False,\n                                score=123\n                            )],\n\n                            # the properties below are optional\n                            automation=connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionAutomationProperty(\n                                options=[connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionAutomationOptionProperty(\n                                    rule_category=connect.CfnEvaluationForm.SingleSelectQuestionRuleCategoryAutomationProperty(\n                                        category="category",\n                                        condition="condition",\n                                        option_ref_id="optionRefId"\n                                    )\n                                )],\n\n                                # the properties below are optional\n                                default_option_ref_id="defaultOptionRefId"\n                            ),\n                            display_as="displayAs"\n                        )\n                    ),\n                    weight=123\n                ),\n                section=evaluation_form_section_property_\n            )],\n            weight=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['section']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormBaseItemProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormItemProperty
class CfnEvaluationForm_EvaluationFormItemPropertyDef(BaseStruct):
    question: typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormQuestionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The information of the question.\n')
    section: typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormSectionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The information of the section.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-evaluationform-evaluationformitem.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    # evaluation_form_item_property_: connect.CfnEvaluationForm.EvaluationFormItemProperty\n\n    evaluation_form_item_property = connect.CfnEvaluationForm.EvaluationFormItemProperty(\n        question=connect.CfnEvaluationForm.EvaluationFormQuestionProperty(\n            question_type="questionType",\n            ref_id="refId",\n            title="title",\n\n            # the properties below are optional\n            instructions="instructions",\n            not_applicable_enabled=False,\n            question_type_properties=connect.CfnEvaluationForm.EvaluationFormQuestionTypePropertiesProperty(\n                numeric=connect.CfnEvaluationForm.EvaluationFormNumericQuestionPropertiesProperty(\n                    max_value=123,\n                    min_value=123,\n\n                    # the properties below are optional\n                    automation=connect.CfnEvaluationForm.EvaluationFormNumericQuestionAutomationProperty(\n                        property_value=connect.CfnEvaluationForm.NumericQuestionPropertyValueAutomationProperty(\n                            label="label"\n                        )\n                    ),\n                    options=[connect.CfnEvaluationForm.EvaluationFormNumericQuestionOptionProperty(\n                        max_value=123,\n                        min_value=123,\n\n                        # the properties below are optional\n                        automatic_fail=False,\n                        score=123\n                    )]\n                ),\n                single_select=connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionPropertiesProperty(\n                    options=[connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionOptionProperty(\n                        ref_id="refId",\n                        text="text",\n\n                        # the properties below are optional\n                        automatic_fail=False,\n                        score=123\n                    )],\n\n                    # the properties below are optional\n                    automation=connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionAutomationProperty(\n                        options=[connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionAutomationOptionProperty(\n                            rule_category=connect.CfnEvaluationForm.SingleSelectQuestionRuleCategoryAutomationProperty(\n                                category="category",\n                                condition="condition",\n                                option_ref_id="optionRefId"\n                            )\n                        )],\n\n                        # the properties below are optional\n                        default_option_ref_id="defaultOptionRefId"\n                    ),\n                    display_as="displayAs"\n                )\n            ),\n            weight=123\n        ),\n        section=connect.CfnEvaluationForm.EvaluationFormSectionProperty(\n            ref_id="refId",\n            title="title",\n\n            # the properties below are optional\n            instructions="instructions",\n            items=[evaluation_form_item_property_],\n            weight=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['question', 'section']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormItemProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormNumericQuestionAutomationProperty
class CfnEvaluationForm_EvaluationFormNumericQuestionAutomationPropertyDef(BaseStruct):
    property_value: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_NumericQuestionPropertyValueAutomationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The property value of the automation.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-evaluationform-evaluationformnumericquestionautomation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    evaluation_form_numeric_question_automation_property = connect.CfnEvaluationForm.EvaluationFormNumericQuestionAutomationProperty(\n        property_value=connect.CfnEvaluationForm.NumericQuestionPropertyValueAutomationProperty(\n            label="label"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['property_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormNumericQuestionAutomationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormNumericQuestionOptionProperty
class CfnEvaluationForm_EvaluationFormNumericQuestionOptionPropertyDef(BaseStruct):
    max_value: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The maximum answer value of the range option.\n')
    min_value: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The minimum answer value of the range option.\n')
    automatic_fail: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='The flag to mark the option as automatic fail. If an automatic fail answer is provided, the overall evaluation gets a score of 0.\n')
    score: typing.Union[int, float, None] = pydantic.Field(None, description='The score assigned to answer values within the range option. *Minimum* : 0 *Maximum* : 10\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-evaluationform-evaluationformnumericquestionoption.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    evaluation_form_numeric_question_option_property = connect.CfnEvaluationForm.EvaluationFormNumericQuestionOptionProperty(\n        max_value=123,\n        min_value=123,\n\n        # the properties below are optional\n        automatic_fail=False,\n        score=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max_value', 'min_value', 'automatic_fail', 'score']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormNumericQuestionOptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormNumericQuestionPropertiesProperty
class CfnEvaluationForm_EvaluationFormNumericQuestionPropertiesPropertyDef(BaseStruct):
    max_value: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The maximum answer value.\n')
    min_value: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The minimum answer value.\n')
    automation: typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormNumericQuestionAutomationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The automation properties of the numeric question.\n')
    options: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormNumericQuestionOptionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The scoring options of the numeric question.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-evaluationform-evaluationformnumericquestionproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    evaluation_form_numeric_question_properties_property = connect.CfnEvaluationForm.EvaluationFormNumericQuestionPropertiesProperty(\n        max_value=123,\n        min_value=123,\n\n        # the properties below are optional\n        automation=connect.CfnEvaluationForm.EvaluationFormNumericQuestionAutomationProperty(\n            property_value=connect.CfnEvaluationForm.NumericQuestionPropertyValueAutomationProperty(\n                label="label"\n            )\n        ),\n        options=[connect.CfnEvaluationForm.EvaluationFormNumericQuestionOptionProperty(\n            max_value=123,\n            min_value=123,\n\n            # the properties below are optional\n            automatic_fail=False,\n            score=123\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max_value', 'min_value', 'automation', 'options']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormNumericQuestionPropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormQuestionProperty
class CfnEvaluationForm_EvaluationFormQuestionPropertyDef(BaseStruct):
    question_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of the question. *Allowed values* : ``NUMERIC`` | ``SINGLESELECT`` | ``TEXT``\n')
    ref_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the question. An identifier must be unique within the evaluation form. *Length Constraints* : Minimum length of 1. Maximum length of 40.\n')
    title: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The title of the question. *Length Constraints* : Minimum length of 1. Maximum length of 350.\n')
    instructions: typing.Optional[str] = pydantic.Field(None, description='The instructions of the section. *Length Constraints* : Minimum length of 0. Maximum length of 1024.\n')
    not_applicable_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='The flag to enable not applicable answers to the question.\n')
    question_type_properties: typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormQuestionTypePropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties of the type of question. Text questions do not have to define question type properties.\n')
    weight: typing.Union[int, float, None] = pydantic.Field(None, description='The scoring weight of the section. *Minimum* : 0 *Maximum* : 100\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-evaluationform-evaluationformquestion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    evaluation_form_question_property = connect.CfnEvaluationForm.EvaluationFormQuestionProperty(\n        question_type="questionType",\n        ref_id="refId",\n        title="title",\n\n        # the properties below are optional\n        instructions="instructions",\n        not_applicable_enabled=False,\n        question_type_properties=connect.CfnEvaluationForm.EvaluationFormQuestionTypePropertiesProperty(\n            numeric=connect.CfnEvaluationForm.EvaluationFormNumericQuestionPropertiesProperty(\n                max_value=123,\n                min_value=123,\n\n                # the properties below are optional\n                automation=connect.CfnEvaluationForm.EvaluationFormNumericQuestionAutomationProperty(\n                    property_value=connect.CfnEvaluationForm.NumericQuestionPropertyValueAutomationProperty(\n                        label="label"\n                    )\n                ),\n                options=[connect.CfnEvaluationForm.EvaluationFormNumericQuestionOptionProperty(\n                    max_value=123,\n                    min_value=123,\n\n                    # the properties below are optional\n                    automatic_fail=False,\n                    score=123\n                )]\n            ),\n            single_select=connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionPropertiesProperty(\n                options=[connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionOptionProperty(\n                    ref_id="refId",\n                    text="text",\n\n                    # the properties below are optional\n                    automatic_fail=False,\n                    score=123\n                )],\n\n                # the properties below are optional\n                automation=connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionAutomationProperty(\n                    options=[connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionAutomationOptionProperty(\n                        rule_category=connect.CfnEvaluationForm.SingleSelectQuestionRuleCategoryAutomationProperty(\n                            category="category",\n                            condition="condition",\n                            option_ref_id="optionRefId"\n                        )\n                    )],\n\n                    # the properties below are optional\n                    default_option_ref_id="defaultOptionRefId"\n                ),\n                display_as="displayAs"\n            )\n        ),\n        weight=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['question_type', 'ref_id', 'title', 'instructions', 'not_applicable_enabled', 'question_type_properties', 'weight']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormQuestionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormQuestionTypePropertiesProperty
class CfnEvaluationForm_EvaluationFormQuestionTypePropertiesPropertyDef(BaseStruct):
    numeric: typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormNumericQuestionPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties of the numeric question.\n')
    single_select: typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormSingleSelectQuestionPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The properties of the numeric question.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-evaluationform-evaluationformquestiontypeproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    evaluation_form_question_type_properties_property = connect.CfnEvaluationForm.EvaluationFormQuestionTypePropertiesProperty(\n        numeric=connect.CfnEvaluationForm.EvaluationFormNumericQuestionPropertiesProperty(\n            max_value=123,\n            min_value=123,\n\n            # the properties below are optional\n            automation=connect.CfnEvaluationForm.EvaluationFormNumericQuestionAutomationProperty(\n                property_value=connect.CfnEvaluationForm.NumericQuestionPropertyValueAutomationProperty(\n                    label="label"\n                )\n            ),\n            options=[connect.CfnEvaluationForm.EvaluationFormNumericQuestionOptionProperty(\n                max_value=123,\n                min_value=123,\n\n                # the properties below are optional\n                automatic_fail=False,\n                score=123\n            )]\n        ),\n        single_select=connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionPropertiesProperty(\n            options=[connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionOptionProperty(\n                ref_id="refId",\n                text="text",\n\n                # the properties below are optional\n                automatic_fail=False,\n                score=123\n            )],\n\n            # the properties below are optional\n            automation=connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionAutomationProperty(\n                options=[connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionAutomationOptionProperty(\n                    rule_category=connect.CfnEvaluationForm.SingleSelectQuestionRuleCategoryAutomationProperty(\n                        category="category",\n                        condition="condition",\n                        option_ref_id="optionRefId"\n                    )\n                )],\n\n                # the properties below are optional\n                default_option_ref_id="defaultOptionRefId"\n            ),\n            display_as="displayAs"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['numeric', 'single_select']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormQuestionTypePropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormSectionProperty
class CfnEvaluationForm_EvaluationFormSectionPropertyDef(BaseStruct):
    ref_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the section. An identifier must be unique within the evaluation form. *Length Constraints* : Minimum length of 1. Maximum length of 40.\n')
    title: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The title of the section. *Length Constraints* : Minimum length of 1. Maximum length of 128.\n')
    instructions: typing.Optional[str] = pydantic.Field(None, description='The instructions of the section.\n')
    items: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormItemPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The items of the section. *Minimum* : 1\n')
    weight: typing.Union[int, float, None] = pydantic.Field(None, description='The scoring weight of the section. *Minimum* : 0 *Maximum* : 100\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-evaluationform-evaluationformsection.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    # evaluation_form_section_property_: connect.CfnEvaluationForm.EvaluationFormSectionProperty\n\n    evaluation_form_section_property = connect.CfnEvaluationForm.EvaluationFormSectionProperty(\n        ref_id="refId",\n        title="title",\n\n        # the properties below are optional\n        instructions="instructions",\n        items=[connect.CfnEvaluationForm.EvaluationFormItemProperty(\n            question=connect.CfnEvaluationForm.EvaluationFormQuestionProperty(\n                question_type="questionType",\n                ref_id="refId",\n                title="title",\n\n                # the properties below are optional\n                instructions="instructions",\n                not_applicable_enabled=False,\n                question_type_properties=connect.CfnEvaluationForm.EvaluationFormQuestionTypePropertiesProperty(\n                    numeric=connect.CfnEvaluationForm.EvaluationFormNumericQuestionPropertiesProperty(\n                        max_value=123,\n                        min_value=123,\n\n                        # the properties below are optional\n                        automation=connect.CfnEvaluationForm.EvaluationFormNumericQuestionAutomationProperty(\n                            property_value=connect.CfnEvaluationForm.NumericQuestionPropertyValueAutomationProperty(\n                                label="label"\n                            )\n                        ),\n                        options=[connect.CfnEvaluationForm.EvaluationFormNumericQuestionOptionProperty(\n                            max_value=123,\n                            min_value=123,\n\n                            # the properties below are optional\n                            automatic_fail=False,\n                            score=123\n                        )]\n                    ),\n                    single_select=connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionPropertiesProperty(\n                        options=[connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionOptionProperty(\n                            ref_id="refId",\n                            text="text",\n\n                            # the properties below are optional\n                            automatic_fail=False,\n                            score=123\n                        )],\n\n                        # the properties below are optional\n                        automation=connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionAutomationProperty(\n                            options=[connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionAutomationOptionProperty(\n                                rule_category=connect.CfnEvaluationForm.SingleSelectQuestionRuleCategoryAutomationProperty(\n                                    category="category",\n                                    condition="condition",\n                                    option_ref_id="optionRefId"\n                                )\n                            )],\n\n                            # the properties below are optional\n                            default_option_ref_id="defaultOptionRefId"\n                        ),\n                        display_as="displayAs"\n                    )\n                ),\n                weight=123\n            ),\n            section=evaluation_form_section_property_\n        )],\n        weight=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ref_id', 'title', 'instructions', 'items', 'weight']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormSectionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionAutomationOptionProperty
class CfnEvaluationForm_EvaluationFormSingleSelectQuestionAutomationOptionPropertyDef(BaseStruct):
    rule_category: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_SingleSelectQuestionRuleCategoryAutomationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The automation option based on a rule category for the single select question.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-evaluationform-evaluationformsingleselectquestionautomationoption.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    evaluation_form_single_select_question_automation_option_property = connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionAutomationOptionProperty(\n        rule_category=connect.CfnEvaluationForm.SingleSelectQuestionRuleCategoryAutomationProperty(\n            category="category",\n            condition="condition",\n            option_ref_id="optionRefId"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['rule_category']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionAutomationOptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionAutomationProperty
class CfnEvaluationForm_EvaluationFormSingleSelectQuestionAutomationPropertyDef(BaseStruct):
    options: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormSingleSelectQuestionAutomationOptionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The automation options of the single select question. *Minimum* : 1 *Maximum* : 20\n')
    default_option_ref_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the default answer option, when none of the automation options match the criteria. *Length Constraints* : Minimum length of 1. Maximum length of 40.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-evaluationform-evaluationformsingleselectquestionautomation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    evaluation_form_single_select_question_automation_property = connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionAutomationProperty(\n        options=[connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionAutomationOptionProperty(\n            rule_category=connect.CfnEvaluationForm.SingleSelectQuestionRuleCategoryAutomationProperty(\n                category="category",\n                condition="condition",\n                option_ref_id="optionRefId"\n            )\n        )],\n\n        # the properties below are optional\n        default_option_ref_id="defaultOptionRefId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['options', 'default_option_ref_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionAutomationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionOptionProperty
class CfnEvaluationForm_EvaluationFormSingleSelectQuestionOptionPropertyDef(BaseStruct):
    ref_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the answer option. An identifier must be unique within the question. *Length Constraints* : Minimum length of 1. Maximum length of 40.\n')
    text: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The title of the answer option. *Length Constraints* : Minimum length of 1. Maximum length of 128.\n')
    automatic_fail: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='The flag to mark the option as automatic fail. If an automatic fail answer is provided, the overall evaluation gets a score of 0.\n')
    score: typing.Union[int, float, None] = pydantic.Field(None, description='The score assigned to the answer option. *Minimum* : 0 *Maximum* : 10\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-evaluationform-evaluationformsingleselectquestionoption.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    evaluation_form_single_select_question_option_property = connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionOptionProperty(\n        ref_id="refId",\n        text="text",\n\n        # the properties below are optional\n        automatic_fail=False,\n        score=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ref_id', 'text', 'automatic_fail', 'score']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionOptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionPropertiesProperty
class CfnEvaluationForm_EvaluationFormSingleSelectQuestionPropertiesPropertyDef(BaseStruct):
    options: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormSingleSelectQuestionOptionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The answer options of the single select question. *Minimum* : 2 *Maximum* : 256\n')
    automation: typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormSingleSelectQuestionAutomationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The display mode of the single select question.\n')
    display_as: typing.Optional[str] = pydantic.Field(None, description='The display mode of the single select question. *Allowed values* : ``DROPDOWN`` | ``RADIO``\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-evaluationform-evaluationformsingleselectquestionproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    evaluation_form_single_select_question_properties_property = connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionPropertiesProperty(\n        options=[connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionOptionProperty(\n            ref_id="refId",\n            text="text",\n\n            # the properties below are optional\n            automatic_fail=False,\n            score=123\n        )],\n\n        # the properties below are optional\n        automation=connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionAutomationProperty(\n            options=[connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionAutomationOptionProperty(\n                rule_category=connect.CfnEvaluationForm.SingleSelectQuestionRuleCategoryAutomationProperty(\n                    category="category",\n                    condition="condition",\n                    option_ref_id="optionRefId"\n                )\n            )],\n\n            # the properties below are optional\n            default_option_ref_id="defaultOptionRefId"\n        ),\n        display_as="displayAs"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['options', 'automation', 'display_as']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionPropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnEvaluationForm.NumericQuestionPropertyValueAutomationProperty
class CfnEvaluationForm_NumericQuestionPropertyValueAutomationPropertyDef(BaseStruct):
    label: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The property label of the automation.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-evaluationform-numericquestionpropertyvalueautomation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    numeric_question_property_value_automation_property = connect.CfnEvaluationForm.NumericQuestionPropertyValueAutomationProperty(\n        label="label"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['label']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnEvaluationForm.NumericQuestionPropertyValueAutomationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnEvaluationForm.ScoringStrategyProperty
class CfnEvaluationForm_ScoringStrategyPropertyDef(BaseStruct):
    mode: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The scoring mode of the evaluation form. *Allowed values* : ``QUESTION_ONLY`` | ``SECTION_ONLY``\n')
    status: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The scoring status of the evaluation form. *Allowed values* : ``ENABLED`` | ``DISABLED``\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-evaluationform-scoringstrategy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    scoring_strategy_property = connect.CfnEvaluationForm.ScoringStrategyProperty(\n        mode="mode",\n        status="status"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['mode', 'status']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnEvaluationForm.ScoringStrategyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnEvaluationForm.SingleSelectQuestionRuleCategoryAutomationProperty
class CfnEvaluationForm_SingleSelectQuestionRuleCategoryAutomationPropertyDef(BaseStruct):
    category: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The category name, as defined in Rules. *Minimum* : 1 *Maximum* : 50\n')
    condition: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The condition to apply for the automation option. If the condition is PRESENT, then the option is applied when the contact data includes the category. Similarly, if the condition is NOT_PRESENT, then the option is applied when the contact data does not include the category. *Allowed values* : ``PRESENT`` | ``NOT_PRESENT`` *Maximum* : 50\n')
    option_ref_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the answer option. An identifier must be unique within the question. *Length Constraints* : Minimum length of 1. Maximum length of 40.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-evaluationform-singleselectquestionrulecategoryautomation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    single_select_question_rule_category_automation_property = connect.CfnEvaluationForm.SingleSelectQuestionRuleCategoryAutomationProperty(\n        category="category",\n        condition="condition",\n        option_ref_id="optionRefId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['category', 'condition', 'option_ref_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnEvaluationForm.SingleSelectQuestionRuleCategoryAutomationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnHoursOfOperation.HoursOfOperationConfigProperty
class CfnHoursOfOperation_HoursOfOperationConfigPropertyDef(BaseStruct):
    day: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The day that the hours of operation applies to.\n')
    end_time: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_connect.CfnHoursOfOperation_HoursOfOperationTimeSlicePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The end time that your contact center closes.\n')
    start_time: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_connect.CfnHoursOfOperation_HoursOfOperationTimeSlicePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The start time that your contact center opens.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-hoursofoperation-hoursofoperationconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    hours_of_operation_config_property = connect.CfnHoursOfOperation.HoursOfOperationConfigProperty(\n        day="day",\n        end_time=connect.CfnHoursOfOperation.HoursOfOperationTimeSliceProperty(\n            hours=123,\n            minutes=123\n        ),\n        start_time=connect.CfnHoursOfOperation.HoursOfOperationTimeSliceProperty(\n            hours=123,\n            minutes=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['day', 'end_time', 'start_time']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnHoursOfOperation.HoursOfOperationConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnHoursOfOperation.HoursOfOperationTimeSliceProperty
class CfnHoursOfOperation_HoursOfOperationTimeSlicePropertyDef(BaseStruct):
    hours: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The hours.\n')
    minutes: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The minutes.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-hoursofoperation-hoursofoperationtimeslice.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    hours_of_operation_time_slice_property = connect.CfnHoursOfOperation.HoursOfOperationTimeSliceProperty(\n        hours=123,\n        minutes=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['hours', 'minutes']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnHoursOfOperation.HoursOfOperationTimeSliceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnInstance.AttributesProperty
class CfnInstance_AttributesPropertyDef(BaseStruct):
    inbound_calls: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='Mandatory element which enables inbound calls on new instance.\n')
    outbound_calls: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='Mandatory element which enables outbound calls on new instance.\n')
    auto_resolve_best_voices: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Boolean flag which enables AUTO_RESOLVE_BEST_VOICES on an instance.\n')
    contactflow_logs: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Boolean flag which enables CONTACTFLOW_LOGS on an instance.\n')
    contact_lens: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Boolean flag which enables CONTACT_LENS on an instance.\n')
    early_media: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Boolean flag which enables EARLY_MEDIA on an instance.\n')
    use_custom_tts_voices: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Boolean flag which enables USE_CUSTOM_TTS_VOICES on an instance.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-instance-attributes.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    attributes_property = connect.CfnInstance.AttributesProperty(\n        inbound_calls=False,\n        outbound_calls=False,\n\n        # the properties below are optional\n        auto_resolve_best_voices=False,\n        contactflow_logs=False,\n        contact_lens=False,\n        early_media=False,\n        use_custom_tts_voices=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['inbound_calls', 'outbound_calls', 'auto_resolve_best_voices', 'contactflow_logs', 'contact_lens', 'early_media', 'use_custom_tts_voices']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnInstance.AttributesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnInstanceStorageConfig.EncryptionConfigProperty
class CfnInstanceStorageConfig_EncryptionConfigPropertyDef(BaseStruct):
    encryption_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of encryption.\n')
    key_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The full ARN of the encryption key. .. epigraph:: Be sure to provide the full ARN of the encryption key, not just the ID. Amazon Connect supports only KMS keys with the default key spec of ```SYMMETRIC_DEFAULT`` <https://docs.aws.amazon.com/kms/latest/developerguide/asymmetric-key-specs.html#key-spec-symmetric-default>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-instancestorageconfig-encryptionconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    encryption_config_property = connect.CfnInstanceStorageConfig.EncryptionConfigProperty(\n        encryption_type="encryptionType",\n        key_id="keyId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['encryption_type', 'key_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnInstanceStorageConfig.EncryptionConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnInstanceStorageConfig.KinesisFirehoseConfigProperty
class CfnInstanceStorageConfig_KinesisFirehoseConfigPropertyDef(BaseStruct):
    firehose_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the delivery stream.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-instancestorageconfig-kinesisfirehoseconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    kinesis_firehose_config_property = connect.CfnInstanceStorageConfig.KinesisFirehoseConfigProperty(\n        firehose_arn="firehoseArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['firehose_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnInstanceStorageConfig.KinesisFirehoseConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnInstanceStorageConfig.KinesisStreamConfigProperty
class CfnInstanceStorageConfig_KinesisStreamConfigPropertyDef(BaseStruct):
    stream_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the data stream.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-instancestorageconfig-kinesisstreamconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    kinesis_stream_config_property = connect.CfnInstanceStorageConfig.KinesisStreamConfigProperty(\n        stream_arn="streamArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['stream_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnInstanceStorageConfig.KinesisStreamConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnInstanceStorageConfig.KinesisVideoStreamConfigProperty
class CfnInstanceStorageConfig_KinesisVideoStreamConfigPropertyDef(BaseStruct):
    encryption_config: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_connect.CfnInstanceStorageConfig_EncryptionConfigPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The encryption configuration.\n')
    prefix: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The prefix of the video stream.\n')
    retention_period_hours: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The number of hours data is retained in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream. The default value is 0, indicating that the stream does not persist data.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-instancestorageconfig-kinesisvideostreamconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    kinesis_video_stream_config_property = connect.CfnInstanceStorageConfig.KinesisVideoStreamConfigProperty(\n        encryption_config=connect.CfnInstanceStorageConfig.EncryptionConfigProperty(\n            encryption_type="encryptionType",\n            key_id="keyId"\n        ),\n        prefix="prefix",\n        retention_period_hours=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['encryption_config', 'prefix', 'retention_period_hours']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnInstanceStorageConfig.KinesisVideoStreamConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnInstanceStorageConfig.S3ConfigProperty
class CfnInstanceStorageConfig_S3ConfigPropertyDef(BaseStruct):
    bucket_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The S3 bucket name.\n')
    bucket_prefix: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The S3 bucket prefix.\n')
    encryption_config: typing.Union[models.UnsupportedResource, models.aws_connect.CfnInstanceStorageConfig_EncryptionConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The Amazon S3 encryption configuration.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-instancestorageconfig-s3config.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    s3_config_property = connect.CfnInstanceStorageConfig.S3ConfigProperty(\n        bucket_name="bucketName",\n        bucket_prefix="bucketPrefix",\n\n        # the properties below are optional\n        encryption_config=connect.CfnInstanceStorageConfig.EncryptionConfigProperty(\n            encryption_type="encryptionType",\n            key_id="keyId"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket_name', 'bucket_prefix', 'encryption_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnInstanceStorageConfig.S3ConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnPredefinedAttribute.ValuesProperty
class CfnPredefinedAttribute_ValuesPropertyDef(BaseStruct):
    string_list: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Predefined attribute values of type string list.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-predefinedattribute-values.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    values_property = connect.CfnPredefinedAttribute.ValuesProperty(\n        string_list=["stringList"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['string_list']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnPredefinedAttribute.ValuesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnQueue.OutboundCallerConfigProperty
class CfnQueue_OutboundCallerConfigPropertyDef(BaseStruct):
    outbound_caller_id_name: typing.Optional[str] = pydantic.Field(None, description='The caller ID name.\n')
    outbound_caller_id_number_arn: typing.Optional[str] = pydantic.Field(None, description="The Amazon Resource Name (ARN) of the outbound caller ID number. .. epigraph:: Only use the phone number ARN format that doesn't contain ``instance`` in the path, for example, ``arn:aws:connect:us-east-1:1234567890:phone-number/uuid`` . This is the same ARN format that is returned when you create a phone number using CloudFormation , or when you call the `ListPhoneNumbersV2 <https://docs.aws.amazon.com/connect/latest/APIReference/API_ListPhoneNumbersV2.html>`_ API.\n")
    outbound_flow_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the outbound flow.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-queue-outboundcallerconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    outbound_caller_config_property = connect.CfnQueue.OutboundCallerConfigProperty(\n        outbound_caller_id_name="outboundCallerIdName",\n        outbound_caller_id_number_arn="outboundCallerIdNumberArn",\n        outbound_flow_arn="outboundFlowArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['outbound_caller_id_name', 'outbound_caller_id_number_arn', 'outbound_flow_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnQueue.OutboundCallerConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnQuickConnect.PhoneNumberQuickConnectConfigProperty
class CfnQuickConnect_PhoneNumberQuickConnectConfigPropertyDef(BaseStruct):
    phone_number: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The phone number in E.164 format.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-quickconnect-phonenumberquickconnectconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    phone_number_quick_connect_config_property = connect.CfnQuickConnect.PhoneNumberQuickConnectConfigProperty(\n        phone_number="phoneNumber"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['phone_number']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnQuickConnect.PhoneNumberQuickConnectConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnQuickConnect.QueueQuickConnectConfigProperty
class CfnQuickConnect_QueueQuickConnectConfigPropertyDef(BaseStruct):
    contact_flow_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the flow.\n')
    queue_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the queue.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-quickconnect-queuequickconnectconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    queue_quick_connect_config_property = connect.CfnQuickConnect.QueueQuickConnectConfigProperty(\n        contact_flow_arn="contactFlowArn",\n        queue_arn="queueArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['contact_flow_arn', 'queue_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnQuickConnect.QueueQuickConnectConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnQuickConnect.QuickConnectConfigProperty
class CfnQuickConnect_QuickConnectConfigPropertyDef(BaseStruct):
    quick_connect_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).\n')
    phone_config: typing.Union[models.UnsupportedResource, models.aws_connect.CfnQuickConnect_PhoneNumberQuickConnectConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.\n')
    queue_config: typing.Union[models.UnsupportedResource, models.aws_connect.CfnQuickConnect_QueueQuickConnectConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The queue configuration. This is required only if QuickConnectType is QUEUE.\n')
    user_config: typing.Union[models.UnsupportedResource, models.aws_connect.CfnQuickConnect_UserQuickConnectConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The user configuration. This is required only if QuickConnectType is USER.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-quickconnect-quickconnectconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    quick_connect_config_property = connect.CfnQuickConnect.QuickConnectConfigProperty(\n        quick_connect_type="quickConnectType",\n\n        # the properties below are optional\n        phone_config=connect.CfnQuickConnect.PhoneNumberQuickConnectConfigProperty(\n            phone_number="phoneNumber"\n        ),\n        queue_config=connect.CfnQuickConnect.QueueQuickConnectConfigProperty(\n            contact_flow_arn="contactFlowArn",\n            queue_arn="queueArn"\n        ),\n        user_config=connect.CfnQuickConnect.UserQuickConnectConfigProperty(\n            contact_flow_arn="contactFlowArn",\n            user_arn="userArn"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['quick_connect_type', 'phone_config', 'queue_config', 'user_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnQuickConnect.QuickConnectConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnQuickConnect.UserQuickConnectConfigProperty
class CfnQuickConnect_UserQuickConnectConfigPropertyDef(BaseStruct):
    contact_flow_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the flow.\n')
    user_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the user.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-quickconnect-userquickconnectconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    user_quick_connect_config_property = connect.CfnQuickConnect.UserQuickConnectConfigProperty(\n        contact_flow_arn="contactFlowArn",\n        user_arn="userArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['contact_flow_arn', 'user_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnQuickConnect.UserQuickConnectConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnRoutingProfile.CrossChannelBehaviorProperty
class CfnRoutingProfile_CrossChannelBehaviorPropertyDef(BaseStruct):
    behavior_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the other channels that can be routed to an agent handling their current channel.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-routingprofile-crosschannelbehavior.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    cross_channel_behavior_property = connect.CfnRoutingProfile.CrossChannelBehaviorProperty(\n        behavior_type="behaviorType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['behavior_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnRoutingProfile.CrossChannelBehaviorProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnRoutingProfile.MediaConcurrencyProperty
class CfnRoutingProfile_MediaConcurrencyPropertyDef(BaseStruct):
    channel: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The channels that agents can handle in the Contact Control Panel (CCP).\n')
    concurrency: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The number of contacts an agent can have on a channel simultaneously. Valid Range for ``VOICE`` : Minimum value of 1. Maximum value of 1. Valid Range for ``CHAT`` : Minimum value of 1. Maximum value of 10. Valid Range for ``TASK`` : Minimum value of 1. Maximum value of 10.\n')
    cross_channel_behavior: typing.Union[models.UnsupportedResource, models.aws_connect.CfnRoutingProfile_CrossChannelBehaviorPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Defines the cross-channel routing behavior for each channel that is enabled for this Routing Profile. For example, this allows you to offer an agent a different contact from another channel when they are currently working with a contact from a Voice channel.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-routingprofile-mediaconcurrency.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    media_concurrency_property = connect.CfnRoutingProfile.MediaConcurrencyProperty(\n        channel="channel",\n        concurrency=123,\n\n        # the properties below are optional\n        cross_channel_behavior=connect.CfnRoutingProfile.CrossChannelBehaviorProperty(\n            behavior_type="behaviorType"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['channel', 'concurrency', 'cross_channel_behavior']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnRoutingProfile.MediaConcurrencyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnRoutingProfile.RoutingProfileQueueConfigProperty
class CfnRoutingProfile_RoutingProfileQueueConfigPropertyDef(BaseStruct):
    delay: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The delay, in seconds, a contact should be in the queue before they are routed to an available agent. For more information, see `Queues: priority and delay <https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html>`_ in the *Amazon Connect Administrator Guide* .\n')
    priority: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The order in which contacts are to be handled for the queue. For more information, see `Queues: priority and delay <https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html>`_ .\n')
    queue_reference: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_connect.CfnRoutingProfile_RoutingProfileQueueReferencePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Contains information about a queue resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-routingprofile-routingprofilequeueconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    routing_profile_queue_config_property = connect.CfnRoutingProfile.RoutingProfileQueueConfigProperty(\n        delay=123,\n        priority=123,\n        queue_reference=connect.CfnRoutingProfile.RoutingProfileQueueReferenceProperty(\n            channel="channel",\n            queue_arn="queueArn"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['delay', 'priority', 'queue_reference']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnRoutingProfile.RoutingProfileQueueConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnRoutingProfile.RoutingProfileQueueReferenceProperty
class CfnRoutingProfile_RoutingProfileQueueReferencePropertyDef(BaseStruct):
    channel: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.\n')
    queue_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the queue.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-routingprofile-routingprofilequeuereference.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    routing_profile_queue_reference_property = connect.CfnRoutingProfile.RoutingProfileQueueReferenceProperty(\n        channel="channel",\n        queue_arn="queueArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['channel', 'queue_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnRoutingProfile.RoutingProfileQueueReferenceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnRule.ActionsProperty
class CfnRule_ActionsPropertyDef(BaseStruct):
    assign_contact_category_actions: typing.Union[typing.Sequence[typing.Any], models.UnsupportedResource, None] = pydantic.Field(None, description='Information about the contact category action. The syntax can be empty, for example, ``{}`` .\n')
    create_case_actions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnRule_CreateCaseActionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='This action will create a case when a rule is triggered.\n')
    end_associated_tasks_actions: typing.Union[typing.Sequence[typing.Any], models.UnsupportedResource, None] = pydantic.Field(None, description='This action will end associated tasks when a rule is triggered.\n')
    event_bridge_actions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnRule_EventBridgeActionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Information about the EventBridge action.\n')
    send_notification_actions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnRule_SendNotificationActionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Information about the send notification action.\n')
    submit_auto_evaluation_actions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnRule_SubmitAutoEvaluationActionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='This action will submit an auto contact evaluation when a rule is triggered.\n')
    task_actions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnRule_TaskActionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Information about the task action. This field is required if ``TriggerEventSource`` is one of the following values: ``OnZendeskTicketCreate`` | ``OnZendeskTicketStatusUpdate`` | ``OnSalesforceCaseCreate``\n')
    update_case_actions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnRule_UpdateCaseActionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='This action will update a case when a rule is triggered.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-rule-actions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    # assign_contact_category_actions: Any\n    # empty_value: Any\n    # end_associated_tasks_actions: Any\n\n    actions_property = connect.CfnRule.ActionsProperty(\n        assign_contact_category_actions=[assign_contact_category_actions],\n        create_case_actions=[connect.CfnRule.CreateCaseActionProperty(\n            fields=[connect.CfnRule.FieldProperty(\n                id="id",\n                value=connect.CfnRule.FieldValueProperty(\n                    boolean_value=False,\n                    double_value=123,\n                    empty_value=empty_value,\n                    string_value="stringValue"\n                )\n            )],\n            template_id="templateId"\n        )],\n        end_associated_tasks_actions=[end_associated_tasks_actions],\n        event_bridge_actions=[connect.CfnRule.EventBridgeActionProperty(\n            name="name"\n        )],\n        send_notification_actions=[connect.CfnRule.SendNotificationActionProperty(\n            content="content",\n            content_type="contentType",\n            delivery_method="deliveryMethod",\n            recipient=connect.CfnRule.NotificationRecipientTypeProperty(\n                user_arns=["userArns"],\n                user_tags={\n                    "user_tags_key": "userTags"\n                }\n            ),\n\n            # the properties below are optional\n            subject="subject"\n        )],\n        submit_auto_evaluation_actions=[connect.CfnRule.SubmitAutoEvaluationActionProperty(\n            evaluation_form_arn="evaluationFormArn"\n        )],\n        task_actions=[connect.CfnRule.TaskActionProperty(\n            contact_flow_arn="contactFlowArn",\n            name="name",\n\n            # the properties below are optional\n            description="description",\n            references={\n                "references_key": connect.CfnRule.ReferenceProperty(\n                    type="type",\n                    value="value"\n                )\n            }\n        )],\n        update_case_actions=[connect.CfnRule.UpdateCaseActionProperty(\n            fields=[connect.CfnRule.FieldProperty(\n                id="id",\n                value=connect.CfnRule.FieldValueProperty(\n                    boolean_value=False,\n                    double_value=123,\n                    empty_value=empty_value,\n                    string_value="stringValue"\n                )\n            )]\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['assign_contact_category_actions', 'create_case_actions', 'end_associated_tasks_actions', 'event_bridge_actions', 'send_notification_actions', 'submit_auto_evaluation_actions', 'task_actions', 'update_case_actions']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnRule.ActionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnRule.CreateCaseActionProperty
class CfnRule_CreateCaseActionPropertyDef(BaseStruct):
    fields: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnRule_FieldPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='An array of case fields.\n')
    template_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Id of template.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-rule-createcaseaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    # empty_value: Any\n\n    create_case_action_property = connect.CfnRule.CreateCaseActionProperty(\n        fields=[connect.CfnRule.FieldProperty(\n            id="id",\n            value=connect.CfnRule.FieldValueProperty(\n                boolean_value=False,\n                double_value=123,\n                empty_value=empty_value,\n                string_value="stringValue"\n            )\n        )],\n        template_id="templateId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['fields', 'template_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnRule.CreateCaseActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnRule.EventBridgeActionProperty
class CfnRule_EventBridgeActionPropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-rule-eventbridgeaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    event_bridge_action_property = connect.CfnRule.EventBridgeActionProperty(\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnRule.EventBridgeActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnRule.FieldProperty
class CfnRule_FieldPropertyDef(BaseStruct):
    value: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_connect.CfnRule_FieldValuePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The value of the field.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-rule-field.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    # empty_value: Any\n\n    field_property = connect.CfnRule.FieldProperty(\n        id="id",\n        value=connect.CfnRule.FieldValueProperty(\n            boolean_value=False,\n            double_value=123,\n            empty_value=empty_value,\n            string_value="stringValue"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnRule.FieldProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnRule.FieldValueProperty
class CfnRule_FieldValuePropertyDef(BaseStruct):
    boolean_value: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    double_value: typing.Union[int, float, None] = pydantic.Field(None, description='')
    empty_value: typing.Any = pydantic.Field(None, description='')
    string_value: typing.Optional[str] = pydantic.Field(None, description='')
    _init_params: typing.ClassVar[list[str]] = ['boolean_value', 'double_value', 'empty_value', 'string_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnRule.FieldValueProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnRule.NotificationRecipientTypeProperty
class CfnRule_NotificationRecipientTypePropertyDef(BaseStruct):
    user_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the user account.\n')
    user_tags: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }. Amazon Connect users with the specified tags will be notified.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-rule-notificationrecipienttype.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    notification_recipient_type_property = connect.CfnRule.NotificationRecipientTypeProperty(\n        user_arns=["userArns"],\n        user_tags={\n            "user_tags_key": "userTags"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['user_arns', 'user_tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnRule.NotificationRecipientTypeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnRule.ReferenceProperty
class CfnRule_ReferencePropertyDef(BaseStruct):
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of the reference. ``DATE`` must be of type Epoch timestamp. *Allowed values* : ``URL`` | ``ATTACHMENT`` | ``NUMBER`` | ``STRING`` | ``DATE`` | ``EMAIL``\n')
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A valid value for the reference. For example, for a URL reference, a formatted URL that is displayed to an agent in the Contact Control Panel (CCP).\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-rule-reference.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    reference_property = connect.CfnRule.ReferenceProperty(\n        type="type",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnRule.ReferenceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnRule.RuleTriggerEventSourceProperty
class CfnRule_RuleTriggerEventSourcePropertyDef(BaseStruct):
    event_source_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the event source.\n')
    integration_association_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the integration association. ``IntegrationAssociationArn`` is required if ``TriggerEventSource`` is one of the following values: ``OnZendeskTicketCreate`` | ``OnZendeskTicketStatusUpdate`` | ``OnSalesforceCaseCreate``\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-rule-ruletriggereventsource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    rule_trigger_event_source_property = connect.CfnRule.RuleTriggerEventSourceProperty(\n        event_source_name="eventSourceName",\n\n        # the properties below are optional\n        integration_association_arn="integrationAssociationArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['event_source_name', 'integration_association_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnRule.RuleTriggerEventSourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnRule.SendNotificationActionProperty
class CfnRule_SendNotificationActionPropertyDef(BaseStruct):
    content: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Notification content. Supports variable injection. For more information, see `JSONPath reference <https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html>`_ in the *Amazon Connect Administrators Guide* .\n')
    content_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Content type format. *Allowed value* : ``PLAIN_TEXT``\n')
    delivery_method: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Notification delivery method. *Allowed value* : ``EMAIL``\n')
    recipient: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_connect.CfnRule_NotificationRecipientTypePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Notification recipient.\n')
    subject: typing.Optional[str] = pydantic.Field(None, description='The subject of the email if the delivery method is ``EMAIL`` . Supports variable injection. For more information, see `JSONPath reference <https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html>`_ in the *Amazon Connect Administrators Guide* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-rule-sendnotificationaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    send_notification_action_property = connect.CfnRule.SendNotificationActionProperty(\n        content="content",\n        content_type="contentType",\n        delivery_method="deliveryMethod",\n        recipient=connect.CfnRule.NotificationRecipientTypeProperty(\n            user_arns=["userArns"],\n            user_tags={\n                "user_tags_key": "userTags"\n            }\n        ),\n\n        # the properties below are optional\n        subject="subject"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['content', 'content_type', 'delivery_method', 'recipient', 'subject']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnRule.SendNotificationActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnRule.SubmitAutoEvaluationActionProperty
class CfnRule_SubmitAutoEvaluationActionPropertyDef(BaseStruct):
    evaluation_form_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the evaluation form.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-rule-submitautoevaluationaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    submit_auto_evaluation_action_property = connect.CfnRule.SubmitAutoEvaluationActionProperty(\n        evaluation_form_arn="evaluationFormArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['evaluation_form_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnRule.SubmitAutoEvaluationActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnRule.TaskActionProperty
class CfnRule_TaskActionPropertyDef(BaseStruct):
    contact_flow_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the flow.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name. Supports variable injection. For more information, see `JSONPath reference <https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html>`_ in the *Amazon Connect Administrators Guide* .\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description. Supports variable injection. For more information, see `JSONPath reference <https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html>`_ in the *Amazon Connect Administrators Guide* .\n')
    references: typing.Union[models.UnsupportedResource, typing.Mapping[str, typing.Union[models.UnsupportedResource, models.aws_connect.CfnRule_ReferencePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Information about the reference when the ``referenceType`` is ``URL`` . Otherwise, null. ``URL`` is the only accepted type. (Supports variable injection in the ``Value`` field.)\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-rule-taskaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    task_action_property = connect.CfnRule.TaskActionProperty(\n        contact_flow_arn="contactFlowArn",\n        name="name",\n\n        # the properties below are optional\n        description="description",\n        references={\n            "references_key": connect.CfnRule.ReferenceProperty(\n                type="type",\n                value="value"\n            )\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['contact_flow_arn', 'name', 'description', 'references']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnRule.TaskActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnRule.UpdateCaseActionProperty
class CfnRule_UpdateCaseActionPropertyDef(BaseStruct):
    fields: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnRule_FieldPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='An array of case fields.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-rule-updatecaseaction.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    # empty_value: Any\n\n    update_case_action_property = connect.CfnRule.UpdateCaseActionProperty(\n        fields=[connect.CfnRule.FieldProperty(\n            id="id",\n            value=connect.CfnRule.FieldValueProperty(\n                boolean_value=False,\n                double_value=123,\n                empty_value=empty_value,\n                string_value="stringValue"\n            )\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['fields']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnRule.UpdateCaseActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnSecurityProfile.ApplicationProperty
class CfnSecurityProfile_ApplicationPropertyDef(BaseStruct):
    application_permissions: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The permissions that the agent is granted on the application. Only the ``ACCESS`` permission is supported.\n')
    namespace: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Namespace of the application that you want to give access to.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-securityprofile-application.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    application_property = connect.CfnSecurityProfile.ApplicationProperty(\n        application_permissions=["applicationPermissions"],\n        namespace="namespace"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['application_permissions', 'namespace']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnSecurityProfile.ApplicationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnTaskTemplate.ConstraintsProperty
class CfnTaskTemplate_ConstraintsPropertyDef(BaseStruct):
    invisible_fields: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnTaskTemplate_InvisibleFieldInfoPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Lists the fields that are invisible to agents.\n')
    read_only_fields: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnTaskTemplate_ReadOnlyFieldInfoPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Lists the fields that are read-only to agents, and cannot be edited.\n')
    required_fields: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnTaskTemplate_RequiredFieldInfoPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Lists the fields that are required to be filled by agents.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-tasktemplate-constraints.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    constraints_property = connect.CfnTaskTemplate.ConstraintsProperty(\n        invisible_fields=[connect.CfnTaskTemplate.InvisibleFieldInfoProperty(\n            id=connect.CfnTaskTemplate.FieldIdentifierProperty(\n                name="name"\n            )\n        )],\n        read_only_fields=[connect.CfnTaskTemplate.ReadOnlyFieldInfoProperty(\n            id=connect.CfnTaskTemplate.FieldIdentifierProperty(\n                name="name"\n            )\n        )],\n        required_fields=[connect.CfnTaskTemplate.RequiredFieldInfoProperty(\n            id=connect.CfnTaskTemplate.FieldIdentifierProperty(\n                name="name"\n            )\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['invisible_fields', 'read_only_fields', 'required_fields']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnTaskTemplate.ConstraintsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnTaskTemplate.DefaultFieldValueProperty
class CfnTaskTemplate_DefaultFieldValuePropertyDef(BaseStruct):
    default_value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Default value for the field.\n')
    _init_params: typing.ClassVar[list[str]] = ['default_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnTaskTemplate.DefaultFieldValueProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnTaskTemplate.FieldIdentifierProperty
class CfnTaskTemplate_FieldIdentifierPropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the task template field.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-tasktemplate-fieldidentifier.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    field_identifier_property = connect.CfnTaskTemplate.FieldIdentifierProperty(\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnTaskTemplate.FieldIdentifierProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnTaskTemplate.FieldProperty
class CfnTaskTemplate_FieldPropertyDef(BaseStruct):
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Indicates the type of field. Following are the valid field types: ``NAME`` ``DESCRIPTION`` | ``SCHEDULED_TIME`` | ``QUICK_CONNECT`` | ``URL`` | ``NUMBER`` | ``TEXT`` | ``TEXT_AREA`` | ``DATE_TIME`` | ``BOOLEAN`` | ``SINGLE_SELECT`` | ``EMAIL``\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the field.\n')
    single_select_options: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of options for a single select field.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-tasktemplate-field.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    field_property = connect.CfnTaskTemplate.FieldProperty(\n        id=connect.CfnTaskTemplate.FieldIdentifierProperty(\n            name="name"\n        ),\n        type="type",\n\n        # the properties below are optional\n        description="description",\n        single_select_options=["singleSelectOptions"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'description', 'single_select_options']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnTaskTemplate.FieldProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnTaskTemplate.InvisibleFieldInfoProperty
class CfnTaskTemplate_InvisibleFieldInfoPropertyDef(BaseStruct):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnTaskTemplate.InvisibleFieldInfoProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnTaskTemplate.ReadOnlyFieldInfoProperty
class CfnTaskTemplate_ReadOnlyFieldInfoPropertyDef(BaseStruct):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnTaskTemplate.ReadOnlyFieldInfoProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnTaskTemplate.RequiredFieldInfoProperty
class CfnTaskTemplate_RequiredFieldInfoPropertyDef(BaseStruct):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnTaskTemplate.RequiredFieldInfoProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnUser.UserIdentityInfoProperty
class CfnUser_UserIdentityInfoPropertyDef(BaseStruct):
    email: typing.Optional[str] = pydantic.Field(None, description='The email address. If you are using SAML for identity management and include this parameter, an error is returned.\n')
    first_name: typing.Optional[str] = pydantic.Field(None, description='The first name. This is required if you are using Amazon Connect or SAML for identity management.\n')
    last_name: typing.Optional[str] = pydantic.Field(None, description='The last name. This is required if you are using Amazon Connect or SAML for identity management.\n')
    mobile: typing.Optional[str] = pydantic.Field(None, description="The user's mobile number.\n")
    secondary_email: typing.Optional[str] = pydantic.Field(None, description='The user\'s secondary email address. If you provide a secondary email, the user receives email notifications -- other than password reset notifications -- to this email address instead of to their primary email address. *Pattern* : ``(?=^.{0,265}$)[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,63}``\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-user-useridentityinfo.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    user_identity_info_property = connect.CfnUser.UserIdentityInfoProperty(\n        email="email",\n        first_name="firstName",\n        last_name="lastName",\n        mobile="mobile",\n        secondary_email="secondaryEmail"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['email', 'first_name', 'last_name', 'mobile', 'secondary_email']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnUser.UserIdentityInfoProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnUser.UserPhoneConfigProperty
class CfnUser_UserPhoneConfigPropertyDef(BaseStruct):
    phone_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The phone type.\n')
    after_contact_work_time_limit: typing.Union[int, float, None] = pydantic.Field(None, description="The After Call Work (ACW) timeout setting, in seconds. This parameter has a minimum value of 0 and a maximum value of 2,000,000 seconds (24 days). Enter 0 if you don't want to allocate a specific amount of ACW time. It essentially means an indefinite amount of time. When the conversation ends, ACW starts; the agent must choose Close contact to end ACW. .. epigraph:: When returned by a ``SearchUsers`` call, ``AfterContactWorkTimeLimit`` is returned in milliseconds.\n")
    auto_accept: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='The Auto accept setting.\n')
    desk_phone_number: typing.Optional[str] = pydantic.Field(None, description='The phone number for the user\'s desk phone.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-user-userphoneconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    user_phone_config_property = connect.CfnUser.UserPhoneConfigProperty(\n        phone_type="phoneType",\n\n        # the properties below are optional\n        after_contact_work_time_limit=123,\n        auto_accept=False,\n        desk_phone_number="deskPhoneNumber"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['phone_type', 'after_contact_work_time_limit', 'auto_accept', 'desk_phone_number']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnUser.UserPhoneConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnUser.UserProficiencyProperty
class CfnUser_UserProficiencyPropertyDef(BaseStruct):
    attribute_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of user’s proficiency. You must use a predefined attribute name that is present in the Amazon Connect instance.\n')
    attribute_value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The value of user’s proficiency. You must use a predefined attribute value that is present in the Amazon Connect instance.\n')
    level: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The level of the proficiency. The valid values are 1, 2, 3, 4 and 5.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-connect-user-userproficiency.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    user_proficiency_property = connect.CfnUser.UserProficiencyProperty(\n        attribute_name="attributeName",\n        attribute_value="attributeValue",\n        level=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['attribute_name', 'attribute_value', 'level']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnUser.UserProficiencyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnApprovedOrigin
class CfnApprovedOriginDef(BaseCfnResource):
    instance_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the instance. *Minimum* : ``1`` *Maximum* : ``100``\n')
    origin: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Domain name to be added to the allow-list of the instance. *Maximum* : ``267``')
    _init_params: typing.ClassVar[list[str]] = ['instance_id', 'origin']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnApprovedOrigin'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnApprovedOriginDefConfig] = pydantic.Field(None)


class CfnApprovedOriginDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnApprovedOriginDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnApprovedOriginDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnApprovedOriginDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnApprovedOriginDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnApprovedOriginDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnApprovedOriginDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnApprovedOriginDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnApprovedOriginDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnApprovedOriginDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnApprovedOriginDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnApprovedOriginDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnApprovedOriginDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnApprovedOriginDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnApprovedOriginDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnApprovedOriginDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnApprovedOriginDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnApprovedOriginDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnApprovedOriginDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnApprovedOriginDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnApprovedOriginDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnApprovedOriginDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnApprovedOriginDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnApprovedOriginDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnApprovedOriginDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnApprovedOriginDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnApprovedOriginDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnApprovedOriginDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnContactFlow
class CfnContactFlowDef(BaseCfnResource):
    content: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The content of the flow. For more information, see `Amazon Connect Flow language <https://docs.aws.amazon.com/connect/latest/adminguide/flow-language.html>`_ in the *Amazon Connect Administrator Guide* .\n')
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the Amazon Connect instance.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the flow.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of the flow. For descriptions of the available types, see `Choose a flow type <https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types>`_ in the *Amazon Connect Administrator Guide* .\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the flow.\n')
    state: typing.Optional[str] = pydantic.Field(None, description='The state of the flow.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .')
    _init_params: typing.ClassVar[list[str]] = ['content', 'instance_arn', 'name', 'type', 'description', 'state', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnContactFlow'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnContactFlowDefConfig] = pydantic.Field(None)


class CfnContactFlowDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnContactFlowDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnContactFlowDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnContactFlowDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnContactFlowDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnContactFlowDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnContactFlowDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnContactFlowDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnContactFlowDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnContactFlowDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnContactFlowDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnContactFlowDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnContactFlowDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnContactFlowDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnContactFlowDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnContactFlowDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnContactFlowDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnContactFlowDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnContactFlowDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnContactFlowDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnContactFlowDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnContactFlowDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnContactFlowDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnContactFlowDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnContactFlowDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnContactFlowDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnContactFlowDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnContactFlowDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnContactFlowModule
class CfnContactFlowModuleDef(BaseCfnResource):
    content: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The content of the flow module.\n')
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the Amazon Connect instance.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the flow module.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the flow module.\n')
    state: typing.Optional[str] = pydantic.Field(None, description='The state of the flow module.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .')
    _init_params: typing.ClassVar[list[str]] = ['content', 'instance_arn', 'name', 'description', 'state', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnContactFlowModule'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnContactFlowModuleDefConfig] = pydantic.Field(None)


class CfnContactFlowModuleDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnContactFlowModuleDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnContactFlowModuleDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnContactFlowModuleDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnContactFlowModuleDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnContactFlowModuleDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnContactFlowModuleDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnContactFlowModuleDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnContactFlowModuleDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnContactFlowModuleDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnContactFlowModuleDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnContactFlowModuleDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnContactFlowModuleDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnContactFlowModuleDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnContactFlowModuleDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnContactFlowModuleDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnContactFlowModuleDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnContactFlowModuleDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnContactFlowModuleDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnContactFlowModuleDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnContactFlowModuleDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnContactFlowModuleDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnContactFlowModuleDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnContactFlowModuleDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnContactFlowModuleDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnContactFlowModuleDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnContactFlowModuleDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnContactFlowModuleDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnEvaluationForm
class CfnEvaluationFormDef(BaseCfnResource):
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the Amazon Connect instance.\n')
    items: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormBaseItemPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Items that are part of the evaluation form. The total number of sections and questions must not exceed 100 each. Questions must be contained in a section. *Minimum size* : 1 *Maximum size* : 100\n')
    status: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The status of the evaluation form. *Allowed values* : ``DRAFT`` | ``ACTIVE`` Default: - "DRAFT"\n')
    title: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A title of the evaluation form.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the evaluation form. *Length Constraints* : Minimum length of 0. Maximum length of 1024.\n')
    scoring_strategy: typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_ScoringStrategyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A scoring strategy of the evaluation form.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.')
    _init_params: typing.ClassVar[list[str]] = ['instance_arn', 'items', 'status', 'title', 'description', 'scoring_strategy', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['EvaluationFormBaseItemProperty', 'EvaluationFormItemProperty', 'EvaluationFormNumericQuestionAutomationProperty', 'EvaluationFormNumericQuestionOptionProperty', 'EvaluationFormNumericQuestionPropertiesProperty', 'EvaluationFormQuestionProperty', 'EvaluationFormQuestionTypePropertiesProperty', 'EvaluationFormSectionProperty', 'EvaluationFormSingleSelectQuestionAutomationOptionProperty', 'EvaluationFormSingleSelectQuestionAutomationProperty', 'EvaluationFormSingleSelectQuestionOptionProperty', 'EvaluationFormSingleSelectQuestionPropertiesProperty', 'NumericQuestionPropertyValueAutomationProperty', 'ScoringStrategyProperty', 'SingleSelectQuestionRuleCategoryAutomationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnEvaluationForm'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnEvaluationFormDefConfig] = pydantic.Field(None)


class CfnEvaluationFormDefConfig(pydantic.BaseModel):
    EvaluationFormBaseItemProperty: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefEvaluationformbaseitempropertyParams]] = pydantic.Field(None, description='')
    EvaluationFormItemProperty: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefEvaluationformitempropertyParams]] = pydantic.Field(None, description='')
    EvaluationFormNumericQuestionAutomationProperty: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefEvaluationformnumericquestionautomationpropertyParams]] = pydantic.Field(None, description='')
    EvaluationFormNumericQuestionOptionProperty: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefEvaluationformnumericquestionoptionpropertyParams]] = pydantic.Field(None, description='')
    EvaluationFormNumericQuestionPropertiesProperty: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefEvaluationformnumericquestionpropertiespropertyParams]] = pydantic.Field(None, description='')
    EvaluationFormQuestionProperty: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefEvaluationformquestionpropertyParams]] = pydantic.Field(None, description='')
    EvaluationFormQuestionTypePropertiesProperty: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefEvaluationformquestiontypepropertiespropertyParams]] = pydantic.Field(None, description='')
    EvaluationFormSectionProperty: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefEvaluationformsectionpropertyParams]] = pydantic.Field(None, description='')
    EvaluationFormSingleSelectQuestionAutomationOptionProperty: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefEvaluationformsingleselectquestionautomationoptionpropertyParams]] = pydantic.Field(None, description='')
    EvaluationFormSingleSelectQuestionAutomationProperty: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefEvaluationformsingleselectquestionautomationpropertyParams]] = pydantic.Field(None, description='')
    EvaluationFormSingleSelectQuestionOptionProperty: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefEvaluationformsingleselectquestionoptionpropertyParams]] = pydantic.Field(None, description='')
    EvaluationFormSingleSelectQuestionPropertiesProperty: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefEvaluationformsingleselectquestionpropertiespropertyParams]] = pydantic.Field(None, description='')
    NumericQuestionPropertyValueAutomationProperty: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefNumericquestionpropertyvalueautomationpropertyParams]] = pydantic.Field(None, description='')
    ScoringStrategyProperty: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefScoringstrategypropertyParams]] = pydantic.Field(None, description='')
    SingleSelectQuestionRuleCategoryAutomationProperty: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefSingleselectquestionrulecategoryautomationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnEvaluationFormDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnEvaluationFormDefEvaluationformbaseitempropertyParams(pydantic.BaseModel):
    section: typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormSectionPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnEvaluationFormDefEvaluationformitempropertyParams(pydantic.BaseModel):
    question: typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormQuestionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    section: typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormSectionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnEvaluationFormDefEvaluationformnumericquestionautomationpropertyParams(pydantic.BaseModel):
    property_value: typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_NumericQuestionPropertyValueAutomationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnEvaluationFormDefEvaluationformnumericquestionoptionpropertyParams(pydantic.BaseModel):
    max_value: typing.Union[int, float] = pydantic.Field(..., description='')
    min_value: typing.Union[int, float] = pydantic.Field(..., description='')
    automatic_fail: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    score: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnEvaluationFormDefEvaluationformnumericquestionpropertiespropertyParams(pydantic.BaseModel):
    max_value: typing.Union[int, float] = pydantic.Field(..., description='')
    min_value: typing.Union[int, float] = pydantic.Field(..., description='')
    automation: typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormNumericQuestionAutomationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    options: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormNumericQuestionOptionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnEvaluationFormDefEvaluationformquestionpropertyParams(pydantic.BaseModel):
    question_type: str = pydantic.Field(..., description='')
    ref_id: str = pydantic.Field(..., description='')
    title: str = pydantic.Field(..., description='')
    instructions: typing.Optional[str] = pydantic.Field(None, description='')
    not_applicable_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    question_type_properties: typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormQuestionTypePropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    weight: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnEvaluationFormDefEvaluationformquestiontypepropertiespropertyParams(pydantic.BaseModel):
    numeric: typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormNumericQuestionPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    single_select: typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormSingleSelectQuestionPropertiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnEvaluationFormDefEvaluationformsectionpropertyParams(pydantic.BaseModel):
    ref_id: str = pydantic.Field(..., description='')
    title: str = pydantic.Field(..., description='')
    instructions: typing.Optional[str] = pydantic.Field(None, description='')
    items: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormItemPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    weight: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnEvaluationFormDefEvaluationformsingleselectquestionautomationoptionpropertyParams(pydantic.BaseModel):
    rule_category: typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_SingleSelectQuestionRuleCategoryAutomationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnEvaluationFormDefEvaluationformsingleselectquestionautomationpropertyParams(pydantic.BaseModel):
    options: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormSingleSelectQuestionAutomationOptionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    default_option_ref_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnEvaluationFormDefEvaluationformsingleselectquestionoptionpropertyParams(pydantic.BaseModel):
    ref_id: str = pydantic.Field(..., description='')
    text: str = pydantic.Field(..., description='')
    automatic_fail: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    score: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnEvaluationFormDefEvaluationformsingleselectquestionpropertiespropertyParams(pydantic.BaseModel):
    options: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormSingleSelectQuestionOptionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    automation: typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormSingleSelectQuestionAutomationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    display_as: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnEvaluationFormDefNumericquestionpropertyvalueautomationpropertyParams(pydantic.BaseModel):
    label: str = pydantic.Field(..., description='')
    ...

class CfnEvaluationFormDefScoringstrategypropertyParams(pydantic.BaseModel):
    mode: str = pydantic.Field(..., description='')
    status: str = pydantic.Field(..., description='')
    ...

class CfnEvaluationFormDefSingleselectquestionrulecategoryautomationpropertyParams(pydantic.BaseModel):
    category: str = pydantic.Field(..., description='')
    condition: str = pydantic.Field(..., description='')
    option_ref_id: str = pydantic.Field(..., description='')
    ...

class CfnEvaluationFormDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnEvaluationFormDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEvaluationFormDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnEvaluationFormDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEvaluationFormDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnEvaluationFormDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnEvaluationFormDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnEvaluationFormDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnEvaluationFormDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnEvaluationFormDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEvaluationFormDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnEvaluationFormDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnEvaluationFormDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEvaluationFormDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnHoursOfOperation
class CfnHoursOfOperationDef(BaseCfnResource):
    config: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnHoursOfOperation_HoursOfOperationConfigPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Configuration information for the hours of operation.\n')
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the instance.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name for the hours of operation.\n')
    time_zone: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The time zone for the hours of operation.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description for the hours of operation.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.')
    _init_params: typing.ClassVar[list[str]] = ['config', 'instance_arn', 'name', 'time_zone', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['HoursOfOperationConfigProperty', 'HoursOfOperationTimeSliceProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnHoursOfOperation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnHoursOfOperationDefConfig] = pydantic.Field(None)


class CfnHoursOfOperationDefConfig(pydantic.BaseModel):
    HoursOfOperationConfigProperty: typing.Optional[list[models.aws_connect.CfnHoursOfOperationDefHoursofoperationconfigpropertyParams]] = pydantic.Field(None, description='')
    HoursOfOperationTimeSliceProperty: typing.Optional[list[models.aws_connect.CfnHoursOfOperationDefHoursofoperationtimeslicepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnHoursOfOperationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnHoursOfOperationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnHoursOfOperationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnHoursOfOperationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnHoursOfOperationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnHoursOfOperationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnHoursOfOperationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnHoursOfOperationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnHoursOfOperationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnHoursOfOperationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnHoursOfOperationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnHoursOfOperationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnHoursOfOperationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnHoursOfOperationDefHoursofoperationconfigpropertyParams(pydantic.BaseModel):
    day: str = pydantic.Field(..., description='')
    end_time: typing.Union[models.UnsupportedResource, models.aws_connect.CfnHoursOfOperation_HoursOfOperationTimeSlicePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    start_time: typing.Union[models.UnsupportedResource, models.aws_connect.CfnHoursOfOperation_HoursOfOperationTimeSlicePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnHoursOfOperationDefHoursofoperationtimeslicepropertyParams(pydantic.BaseModel):
    hours: typing.Union[int, float] = pydantic.Field(..., description='')
    minutes: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnHoursOfOperationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnHoursOfOperationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnHoursOfOperationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnHoursOfOperationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnHoursOfOperationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnHoursOfOperationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnHoursOfOperationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnHoursOfOperationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnHoursOfOperationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnHoursOfOperationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnHoursOfOperationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnHoursOfOperationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnHoursOfOperationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnHoursOfOperationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnInstance
class CfnInstanceDef(BaseCfnResource):
    attributes: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_connect.CfnInstance_AttributesPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A toggle for an individual feature at the instance level.\n')
    identity_management_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identity management type.\n')
    directory_id: typing.Optional[str] = pydantic.Field(None, description='The identifier for the directory.\n')
    instance_alias: typing.Optional[str] = pydantic.Field(None, description='The alias of instance. ``InstanceAlias`` is only required when ``IdentityManagementType`` is ``CONNECT_MANAGED`` or ``SAML`` . ``InstanceAlias`` is not required when ``IdentityManagementType`` is ``EXISTING_DIRECTORY`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource.')
    _init_params: typing.ClassVar[list[str]] = ['attributes', 'identity_management_type', 'directory_id', 'instance_alias', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['AttributesProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnInstance'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnInstanceDefConfig] = pydantic.Field(None)


class CfnInstanceDefConfig(pydantic.BaseModel):
    AttributesProperty: typing.Optional[list[models.aws_connect.CfnInstanceDefAttributespropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnInstanceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnInstanceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnInstanceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnInstanceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnInstanceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnInstanceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnInstanceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnInstanceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnInstanceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnInstanceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnInstanceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnInstanceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnInstanceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnInstanceDefAttributespropertyParams(pydantic.BaseModel):
    inbound_calls: typing.Union[bool, models.UnsupportedResource] = pydantic.Field(..., description='')
    outbound_calls: typing.Union[bool, models.UnsupportedResource] = pydantic.Field(..., description='')
    auto_resolve_best_voices: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    contactflow_logs: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    contact_lens: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    early_media: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    use_custom_tts_voices: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnInstanceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnInstanceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnInstanceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnInstanceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnInstanceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnInstanceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnInstanceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnInstanceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnInstanceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnInstanceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnInstanceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnInstanceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnInstanceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnInstanceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnInstanceStorageConfig
class CfnInstanceStorageConfigDef(BaseCfnResource):
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the instance.\n')
    resource_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A valid resource type. Following are the valid resource types: ``CHAT_TRANSCRIPTS`` | ``CALL_RECORDINGS`` | ``SCHEDULED_REPORTS`` | ``MEDIA_STREAMS`` | ``CONTACT_TRACE_RECORDS`` | ``AGENT_EVENTS``\n')
    storage_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A valid storage type.\n')
    kinesis_firehose_config: typing.Union[models.UnsupportedResource, models.aws_connect.CfnInstanceStorageConfig_KinesisFirehoseConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration of the Kinesis Firehose delivery stream.\n')
    kinesis_stream_config: typing.Union[models.UnsupportedResource, models.aws_connect.CfnInstanceStorageConfig_KinesisStreamConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration of the Kinesis data stream.\n')
    kinesis_video_stream_config: typing.Union[models.UnsupportedResource, models.aws_connect.CfnInstanceStorageConfig_KinesisVideoStreamConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration of the Kinesis video stream.\n')
    s3_config: typing.Union[models.UnsupportedResource, models.aws_connect.CfnInstanceStorageConfig_S3ConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The S3 bucket configuration.')
    _init_params: typing.ClassVar[list[str]] = ['instance_arn', 'resource_type', 'storage_type', 'kinesis_firehose_config', 'kinesis_stream_config', 'kinesis_video_stream_config', 's3_config']
    _method_names: typing.ClassVar[list[str]] = ['EncryptionConfigProperty', 'KinesisFirehoseConfigProperty', 'KinesisStreamConfigProperty', 'KinesisVideoStreamConfigProperty', 'S3ConfigProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnInstanceStorageConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnInstanceStorageConfigDefConfig] = pydantic.Field(None)


class CfnInstanceStorageConfigDefConfig(pydantic.BaseModel):
    EncryptionConfigProperty: typing.Optional[list[models.aws_connect.CfnInstanceStorageConfigDefEncryptionconfigpropertyParams]] = pydantic.Field(None, description='')
    KinesisFirehoseConfigProperty: typing.Optional[list[models.aws_connect.CfnInstanceStorageConfigDefKinesisfirehoseconfigpropertyParams]] = pydantic.Field(None, description='')
    KinesisStreamConfigProperty: typing.Optional[list[models.aws_connect.CfnInstanceStorageConfigDefKinesisstreamconfigpropertyParams]] = pydantic.Field(None, description='')
    KinesisVideoStreamConfigProperty: typing.Optional[list[models.aws_connect.CfnInstanceStorageConfigDefKinesisvideostreamconfigpropertyParams]] = pydantic.Field(None, description='')
    S3ConfigProperty: typing.Optional[list[models.aws_connect.CfnInstanceStorageConfigDefS3ConfigpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnInstanceStorageConfigDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnInstanceStorageConfigDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnInstanceStorageConfigDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnInstanceStorageConfigDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnInstanceStorageConfigDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnInstanceStorageConfigDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnInstanceStorageConfigDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnInstanceStorageConfigDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnInstanceStorageConfigDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnInstanceStorageConfigDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnInstanceStorageConfigDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnInstanceStorageConfigDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnInstanceStorageConfigDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnInstanceStorageConfigDefEncryptionconfigpropertyParams(pydantic.BaseModel):
    encryption_type: str = pydantic.Field(..., description='')
    key_id: str = pydantic.Field(..., description='')
    ...

class CfnInstanceStorageConfigDefKinesisfirehoseconfigpropertyParams(pydantic.BaseModel):
    firehose_arn: str = pydantic.Field(..., description='')
    ...

class CfnInstanceStorageConfigDefKinesisstreamconfigpropertyParams(pydantic.BaseModel):
    stream_arn: str = pydantic.Field(..., description='')
    ...

class CfnInstanceStorageConfigDefKinesisvideostreamconfigpropertyParams(pydantic.BaseModel):
    encryption_config: typing.Union[models.UnsupportedResource, models.aws_connect.CfnInstanceStorageConfig_EncryptionConfigPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    prefix: str = pydantic.Field(..., description='')
    retention_period_hours: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnInstanceStorageConfigDefS3ConfigpropertyParams(pydantic.BaseModel):
    bucket_name: str = pydantic.Field(..., description='')
    bucket_prefix: str = pydantic.Field(..., description='')
    encryption_config: typing.Union[models.UnsupportedResource, models.aws_connect.CfnInstanceStorageConfig_EncryptionConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnInstanceStorageConfigDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnInstanceStorageConfigDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnInstanceStorageConfigDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnInstanceStorageConfigDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnInstanceStorageConfigDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnInstanceStorageConfigDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnInstanceStorageConfigDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnInstanceStorageConfigDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnInstanceStorageConfigDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnInstanceStorageConfigDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnInstanceStorageConfigDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnInstanceStorageConfigDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnInstanceStorageConfigDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnInstanceStorageConfigDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnIntegrationAssociation
class CfnIntegrationAssociationDef(BaseCfnResource):
    instance_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the instance. *Minimum* : ``1`` *Maximum* : ``100``\n')
    integration_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='ARN of the integration being associated with the instance. *Minimum* : ``1`` *Maximum* : ``140``\n')
    integration_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the integration type to be associated with the instance. *Allowed Values* : ``LEX_BOT`` | ``LAMBDA_FUNCTION``')
    _init_params: typing.ClassVar[list[str]] = ['instance_id', 'integration_arn', 'integration_type']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnIntegrationAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnIntegrationAssociationDefConfig] = pydantic.Field(None)


class CfnIntegrationAssociationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnIntegrationAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnIntegrationAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnIntegrationAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnIntegrationAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnIntegrationAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnIntegrationAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnIntegrationAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnIntegrationAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnIntegrationAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnIntegrationAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnIntegrationAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnIntegrationAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnIntegrationAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnIntegrationAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnIntegrationAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIntegrationAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnIntegrationAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIntegrationAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnIntegrationAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnIntegrationAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnIntegrationAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnIntegrationAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnIntegrationAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIntegrationAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnIntegrationAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnIntegrationAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIntegrationAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnPhoneNumber
class CfnPhoneNumberDef(BaseCfnResource):
    target_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution group that phone numbers are claimed to.\n')
    country_code: typing.Optional[str] = pydantic.Field(None, description='The ISO country code.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the phone number.\n')
    prefix: typing.Optional[str] = pydantic.Field(None, description='The prefix of the phone number. If provided, it must contain ``+`` as part of the country code. *Pattern* : ``^\\\\+[0-9]{1,15}``\n')
    source_phone_number_arn: typing.Optional[str] = pydantic.Field(None, description='The claimed phone number ARN that was previously imported from the external service, such as Amazon Pinpoint. If it is from Amazon Pinpoint, it looks like the ARN of the phone number that was imported from Amazon Pinpoint.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.\n')
    type: typing.Optional[str] = pydantic.Field(None, description='The type of phone number.')
    _init_params: typing.ClassVar[list[str]] = ['target_arn', 'country_code', 'description', 'prefix', 'source_phone_number_arn', 'tags', 'type']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnPhoneNumber'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnPhoneNumberDefConfig] = pydantic.Field(None)


class CfnPhoneNumberDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnPhoneNumberDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnPhoneNumberDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnPhoneNumberDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnPhoneNumberDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnPhoneNumberDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnPhoneNumberDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnPhoneNumberDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnPhoneNumberDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnPhoneNumberDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnPhoneNumberDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnPhoneNumberDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnPhoneNumberDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnPhoneNumberDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnPhoneNumberDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPhoneNumberDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPhoneNumberDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPhoneNumberDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPhoneNumberDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPhoneNumberDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPhoneNumberDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPhoneNumberDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPhoneNumberDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPhoneNumberDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPhoneNumberDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnPhoneNumberDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPhoneNumberDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPhoneNumberDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnPredefinedAttribute
class CfnPredefinedAttributeDef(BaseCfnResource):
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the instance.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the predefined attribute.\n')
    values: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_connect.CfnPredefinedAttribute_ValuesPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The values of a predefined attribute.')
    _init_params: typing.ClassVar[list[str]] = ['instance_arn', 'name', 'values']
    _method_names: typing.ClassVar[list[str]] = ['ValuesProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnPredefinedAttribute'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnPredefinedAttributeDefConfig] = pydantic.Field(None)


class CfnPredefinedAttributeDefConfig(pydantic.BaseModel):
    ValuesProperty: typing.Optional[list[models.aws_connect.CfnPredefinedAttributeDefValuespropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnPredefinedAttributeDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnPredefinedAttributeDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnPredefinedAttributeDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnPredefinedAttributeDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnPredefinedAttributeDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnPredefinedAttributeDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnPredefinedAttributeDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnPredefinedAttributeDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnPredefinedAttributeDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnPredefinedAttributeDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnPredefinedAttributeDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnPredefinedAttributeDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnPredefinedAttributeDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_last_modified_time_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)

class CfnPredefinedAttributeDefValuespropertyParams(pydantic.BaseModel):
    string_list: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnPredefinedAttributeDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPredefinedAttributeDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPredefinedAttributeDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPredefinedAttributeDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPredefinedAttributeDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPredefinedAttributeDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPredefinedAttributeDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPredefinedAttributeDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPredefinedAttributeDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPredefinedAttributeDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPredefinedAttributeDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnPredefinedAttributeDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPredefinedAttributeDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPredefinedAttributeDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnPrompt
class CfnPromptDef(BaseCfnResource):
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the Amazon Connect instance.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the prompt.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the prompt.\n')
    s3_uri: typing.Optional[str] = pydantic.Field(None, description='The URI for the S3 bucket where the prompt is stored. This property is required when you create a prompt.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.')
    _init_params: typing.ClassVar[list[str]] = ['instance_arn', 'name', 'description', 's3_uri', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnPrompt'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnPromptDefConfig] = pydantic.Field(None)


class CfnPromptDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnPromptDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnPromptDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnPromptDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnPromptDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnPromptDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnPromptDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnPromptDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnPromptDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnPromptDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnPromptDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnPromptDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnPromptDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnPromptDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnPromptDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPromptDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPromptDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPromptDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPromptDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPromptDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPromptDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPromptDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPromptDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPromptDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPromptDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnPromptDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPromptDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPromptDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnQueue
class CfnQueueDef(BaseCfnResource):
    hours_of_operation_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the hours of operation.\n')
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the Amazon Connect instance.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the queue.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the queue.\n')
    max_contacts: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of contacts that can be in the queue before it is considered full.\n')
    outbound_caller_config: typing.Union[models.UnsupportedResource, models.aws_connect.CfnQueue_OutboundCallerConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The outbound caller ID name, number, and outbound whisper flow.\n')
    quick_connect_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Amazon Resource Names (ARN) of the of the quick connects available to agents who are working the queue.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='The status of the queue.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.')
    _init_params: typing.ClassVar[list[str]] = ['hours_of_operation_arn', 'instance_arn', 'name', 'description', 'max_contacts', 'outbound_caller_config', 'quick_connect_arns', 'status', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['OutboundCallerConfigProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnQueue'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnQueueDefConfig] = pydantic.Field(None)


class CfnQueueDefConfig(pydantic.BaseModel):
    OutboundCallerConfigProperty: typing.Optional[list[models.aws_connect.CfnQueueDefOutboundcallerconfigpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnQueueDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnQueueDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnQueueDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnQueueDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnQueueDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnQueueDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnQueueDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnQueueDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnQueueDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnQueueDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnQueueDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnQueueDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnQueueDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnQueueDefOutboundcallerconfigpropertyParams(pydantic.BaseModel):
    outbound_caller_id_name: typing.Optional[str] = pydantic.Field(None, description='')
    outbound_caller_id_number_arn: typing.Optional[str] = pydantic.Field(None, description='')
    outbound_flow_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnQueueDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnQueueDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnQueueDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnQueueDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnQueueDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnQueueDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnQueueDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnQueueDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnQueueDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnQueueDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnQueueDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnQueueDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnQueueDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnQueueDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnQuickConnect
class CfnQuickConnectDef(BaseCfnResource):
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the instance.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the quick connect.\n')
    quick_connect_config: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_connect.CfnQuickConnect_QuickConnectConfigPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Contains information about the quick connect.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the quick connect.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.')
    _init_params: typing.ClassVar[list[str]] = ['instance_arn', 'name', 'quick_connect_config', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['PhoneNumberQuickConnectConfigProperty', 'QueueQuickConnectConfigProperty', 'QuickConnectConfigProperty', 'UserQuickConnectConfigProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnQuickConnect'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnQuickConnectDefConfig] = pydantic.Field(None)


class CfnQuickConnectDefConfig(pydantic.BaseModel):
    PhoneNumberQuickConnectConfigProperty: typing.Optional[list[models.aws_connect.CfnQuickConnectDefPhonenumberquickconnectconfigpropertyParams]] = pydantic.Field(None, description='')
    QueueQuickConnectConfigProperty: typing.Optional[list[models.aws_connect.CfnQuickConnectDefQueuequickconnectconfigpropertyParams]] = pydantic.Field(None, description='')
    QuickConnectConfigProperty: typing.Optional[list[models.aws_connect.CfnQuickConnectDefQuickconnectconfigpropertyParams]] = pydantic.Field(None, description='')
    UserQuickConnectConfigProperty: typing.Optional[list[models.aws_connect.CfnQuickConnectDefUserquickconnectconfigpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnQuickConnectDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnQuickConnectDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnQuickConnectDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnQuickConnectDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnQuickConnectDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnQuickConnectDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnQuickConnectDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnQuickConnectDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnQuickConnectDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnQuickConnectDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnQuickConnectDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnQuickConnectDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnQuickConnectDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnQuickConnectDefPhonenumberquickconnectconfigpropertyParams(pydantic.BaseModel):
    phone_number: str = pydantic.Field(..., description='')
    ...

class CfnQuickConnectDefQueuequickconnectconfigpropertyParams(pydantic.BaseModel):
    contact_flow_arn: str = pydantic.Field(..., description='')
    queue_arn: str = pydantic.Field(..., description='')
    ...

class CfnQuickConnectDefQuickconnectconfigpropertyParams(pydantic.BaseModel):
    quick_connect_type: str = pydantic.Field(..., description='')
    phone_config: typing.Union[models.UnsupportedResource, models.aws_connect.CfnQuickConnect_PhoneNumberQuickConnectConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    queue_config: typing.Union[models.UnsupportedResource, models.aws_connect.CfnQuickConnect_QueueQuickConnectConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    user_config: typing.Union[models.UnsupportedResource, models.aws_connect.CfnQuickConnect_UserQuickConnectConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnQuickConnectDefUserquickconnectconfigpropertyParams(pydantic.BaseModel):
    contact_flow_arn: str = pydantic.Field(..., description='')
    user_arn: str = pydantic.Field(..., description='')
    ...

class CfnQuickConnectDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnQuickConnectDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnQuickConnectDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnQuickConnectDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnQuickConnectDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnQuickConnectDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnQuickConnectDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnQuickConnectDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnQuickConnectDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnQuickConnectDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnQuickConnectDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnQuickConnectDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnQuickConnectDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnQuickConnectDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnRoutingProfile
class CfnRoutingProfileDef(BaseCfnResource):
    default_outbound_queue_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the default outbound queue for the routing profile.\n')
    description: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The description of the routing profile.\n')
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the Amazon Connect instance.\n')
    media_concurrencies: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnRoutingProfile_MediaConcurrencyPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the routing profile.\n')
    agent_availability_timer: typing.Optional[str] = pydantic.Field(None, description='Whether agents with this routing profile will have their routing order calculated based on *time since their last inbound contact* or *longest idle time* .\n')
    queue_configs: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnRoutingProfile_RoutingProfileQueueConfigPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The inbound queues associated with the routing profile. If no queue is added, the agent can make only outbound calls.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.')
    _init_params: typing.ClassVar[list[str]] = ['default_outbound_queue_arn', 'description', 'instance_arn', 'media_concurrencies', 'name', 'agent_availability_timer', 'queue_configs', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['CrossChannelBehaviorProperty', 'MediaConcurrencyProperty', 'RoutingProfileQueueConfigProperty', 'RoutingProfileQueueReferenceProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnRoutingProfile'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnRoutingProfileDefConfig] = pydantic.Field(None)


class CfnRoutingProfileDefConfig(pydantic.BaseModel):
    CrossChannelBehaviorProperty: typing.Optional[list[models.aws_connect.CfnRoutingProfileDefCrosschannelbehaviorpropertyParams]] = pydantic.Field(None, description='')
    MediaConcurrencyProperty: typing.Optional[list[models.aws_connect.CfnRoutingProfileDefMediaconcurrencypropertyParams]] = pydantic.Field(None, description='')
    RoutingProfileQueueConfigProperty: typing.Optional[list[models.aws_connect.CfnRoutingProfileDefRoutingprofilequeueconfigpropertyParams]] = pydantic.Field(None, description='')
    RoutingProfileQueueReferenceProperty: typing.Optional[list[models.aws_connect.CfnRoutingProfileDefRoutingprofilequeuereferencepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnRoutingProfileDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnRoutingProfileDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnRoutingProfileDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnRoutingProfileDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnRoutingProfileDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnRoutingProfileDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnRoutingProfileDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnRoutingProfileDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnRoutingProfileDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnRoutingProfileDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnRoutingProfileDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnRoutingProfileDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnRoutingProfileDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnRoutingProfileDefCrosschannelbehaviorpropertyParams(pydantic.BaseModel):
    behavior_type: str = pydantic.Field(..., description='')
    ...

class CfnRoutingProfileDefMediaconcurrencypropertyParams(pydantic.BaseModel):
    channel: str = pydantic.Field(..., description='')
    concurrency: typing.Union[int, float] = pydantic.Field(..., description='')
    cross_channel_behavior: typing.Union[models.UnsupportedResource, models.aws_connect.CfnRoutingProfile_CrossChannelBehaviorPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnRoutingProfileDefRoutingprofilequeueconfigpropertyParams(pydantic.BaseModel):
    delay: typing.Union[int, float] = pydantic.Field(..., description='')
    priority: typing.Union[int, float] = pydantic.Field(..., description='')
    queue_reference: typing.Union[models.UnsupportedResource, models.aws_connect.CfnRoutingProfile_RoutingProfileQueueReferencePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnRoutingProfileDefRoutingprofilequeuereferencepropertyParams(pydantic.BaseModel):
    channel: str = pydantic.Field(..., description='')
    queue_arn: str = pydantic.Field(..., description='')
    ...

class CfnRoutingProfileDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnRoutingProfileDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRoutingProfileDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnRoutingProfileDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRoutingProfileDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnRoutingProfileDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnRoutingProfileDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnRoutingProfileDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnRoutingProfileDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnRoutingProfileDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRoutingProfileDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnRoutingProfileDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnRoutingProfileDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRoutingProfileDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnRule
class CfnRuleDef(BaseCfnResource):
    actions: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_connect.CfnRule_ActionsPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of actions to be run when the rule is triggered.\n')
    function: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The conditions of the rule.\n')
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the instance.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the rule.\n')
    publish_status: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The publish status of the rule. *Allowed values* : ``DRAFT`` | ``PUBLISHED``\n')
    trigger_event_source: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_connect.CfnRule_RuleTriggerEventSourcePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The event source to trigger the rule.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.')
    _init_params: typing.ClassVar[list[str]] = ['actions', 'function', 'instance_arn', 'name', 'publish_status', 'trigger_event_source', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['ActionsProperty', 'CreateCaseActionProperty', 'EventBridgeActionProperty', 'FieldProperty', 'FieldValueProperty', 'NotificationRecipientTypeProperty', 'ReferenceProperty', 'RuleTriggerEventSourceProperty', 'SendNotificationActionProperty', 'SubmitAutoEvaluationActionProperty', 'TaskActionProperty', 'UpdateCaseActionProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnRule'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnRuleDefConfig] = pydantic.Field(None)


class CfnRuleDefConfig(pydantic.BaseModel):
    ActionsProperty: typing.Optional[list[models.aws_connect.CfnRuleDefActionspropertyParams]] = pydantic.Field(None, description='')
    CreateCaseActionProperty: typing.Optional[list[models.aws_connect.CfnRuleDefCreatecaseactionpropertyParams]] = pydantic.Field(None, description='')
    EventBridgeActionProperty: typing.Optional[list[models.aws_connect.CfnRuleDefEventbridgeactionpropertyParams]] = pydantic.Field(None, description='')
    FieldProperty: typing.Optional[list[models.aws_connect.CfnRuleDefFieldpropertyParams]] = pydantic.Field(None, description='')
    FieldValueProperty: typing.Optional[list[models.aws_connect.CfnRuleDefFieldvaluepropertyParams]] = pydantic.Field(None, description='')
    NotificationRecipientTypeProperty: typing.Optional[list[models.aws_connect.CfnRuleDefNotificationrecipienttypepropertyParams]] = pydantic.Field(None, description='')
    ReferenceProperty: typing.Optional[list[models.aws_connect.CfnRuleDefReferencepropertyParams]] = pydantic.Field(None, description='')
    RuleTriggerEventSourceProperty: typing.Optional[list[models.aws_connect.CfnRuleDefRuletriggereventsourcepropertyParams]] = pydantic.Field(None, description='')
    SendNotificationActionProperty: typing.Optional[list[models.aws_connect.CfnRuleDefSendnotificationactionpropertyParams]] = pydantic.Field(None, description='')
    SubmitAutoEvaluationActionProperty: typing.Optional[list[models.aws_connect.CfnRuleDefSubmitautoevaluationactionpropertyParams]] = pydantic.Field(None, description='')
    TaskActionProperty: typing.Optional[list[models.aws_connect.CfnRuleDefTaskactionpropertyParams]] = pydantic.Field(None, description='')
    UpdateCaseActionProperty: typing.Optional[list[models.aws_connect.CfnRuleDefUpdatecaseactionpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnRuleDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnRuleDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnRuleDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnRuleDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnRuleDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnRuleDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnRuleDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnRuleDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnRuleDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnRuleDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnRuleDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnRuleDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnRuleDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnRuleDefActionspropertyParams(pydantic.BaseModel):
    assign_contact_category_actions: typing.Union[typing.Sequence[typing.Any], models.UnsupportedResource, None] = pydantic.Field(None, description='')
    create_case_actions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnRule_CreateCaseActionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    end_associated_tasks_actions: typing.Union[typing.Sequence[typing.Any], models.UnsupportedResource, None] = pydantic.Field(None, description='')
    event_bridge_actions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnRule_EventBridgeActionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    send_notification_actions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnRule_SendNotificationActionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    submit_auto_evaluation_actions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnRule_SubmitAutoEvaluationActionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    task_actions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnRule_TaskActionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    update_case_actions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnRule_UpdateCaseActionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnRuleDefCreatecaseactionpropertyParams(pydantic.BaseModel):
    fields: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnRule_FieldPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    template_id: str = pydantic.Field(..., description='')
    ...

class CfnRuleDefEventbridgeactionpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    ...

class CfnRuleDefFieldpropertyParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='')
    value: typing.Union[models.UnsupportedResource, models.aws_connect.CfnRule_FieldValuePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnRuleDefFieldvaluepropertyParams(pydantic.BaseModel):
    boolean_value: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    double_value: typing.Union[int, float, None] = pydantic.Field(None, description='')
    empty_value: typing.Any = pydantic.Field(None, description='')
    string_value: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnRuleDefNotificationrecipienttypepropertyParams(pydantic.BaseModel):
    user_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    user_tags: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='')
    ...

class CfnRuleDefReferencepropertyParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnRuleDefRuletriggereventsourcepropertyParams(pydantic.BaseModel):
    event_source_name: str = pydantic.Field(..., description='')
    integration_association_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnRuleDefSendnotificationactionpropertyParams(pydantic.BaseModel):
    content: str = pydantic.Field(..., description='')
    content_type: str = pydantic.Field(..., description='')
    delivery_method: str = pydantic.Field(..., description='')
    recipient: typing.Union[models.UnsupportedResource, models.aws_connect.CfnRule_NotificationRecipientTypePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    subject: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnRuleDefSubmitautoevaluationactionpropertyParams(pydantic.BaseModel):
    evaluation_form_arn: str = pydantic.Field(..., description='')
    ...

class CfnRuleDefTaskactionpropertyParams(pydantic.BaseModel):
    contact_flow_arn: str = pydantic.Field(..., description='')
    name: str = pydantic.Field(..., description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    references: typing.Union[models.UnsupportedResource, typing.Mapping[str, typing.Union[models.UnsupportedResource, models.aws_connect.CfnRule_ReferencePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnRuleDefUpdatecaseactionpropertyParams(pydantic.BaseModel):
    fields: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnRule_FieldPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnRuleDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnRuleDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRuleDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnRuleDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRuleDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnRuleDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnRuleDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnRuleDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnRuleDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnRuleDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRuleDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnRuleDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnRuleDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRuleDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnSecurityKey
class CfnSecurityKeyDef(BaseCfnResource):
    instance_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the instance. *Minimum* : ``1`` *Maximum* : ``100``\n')
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A valid security key in PEM format. For example:. ``"-----BEGIN PUBLIC KEY-----\\ [a lot of characters] ----END PUBLIC KEY-----"`` *Minimum* : ``1`` *Maximum* : ``1024``')
    _init_params: typing.ClassVar[list[str]] = ['instance_id', 'key']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnSecurityKey'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnSecurityKeyDefConfig] = pydantic.Field(None)


class CfnSecurityKeyDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnSecurityKeyDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnSecurityKeyDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnSecurityKeyDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnSecurityKeyDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnSecurityKeyDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnSecurityKeyDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnSecurityKeyDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnSecurityKeyDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnSecurityKeyDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnSecurityKeyDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnSecurityKeyDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnSecurityKeyDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnSecurityKeyDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnSecurityKeyDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSecurityKeyDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSecurityKeyDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSecurityKeyDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSecurityKeyDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSecurityKeyDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSecurityKeyDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSecurityKeyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSecurityKeyDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSecurityKeyDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSecurityKeyDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnSecurityKeyDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSecurityKeyDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSecurityKeyDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnSecurityProfile
class CfnSecurityProfileDef(BaseCfnResource):
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the Amazon Connect instance.\n')
    security_profile_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name for the security profile.\n')
    allowed_access_control_hierarchy_group_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the hierarchy group that a security profile uses to restrict access to resources in Amazon Connect.\n')
    allowed_access_control_tags: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.CfnTagDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The list of tags that a security profile uses to restrict access to resources in Amazon Connect.\n')
    applications: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnSecurityProfile_ApplicationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of third-party applications that the security profile will give access to.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the security profile.\n')
    hierarchy_restricted_resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of resources that a security profile applies hierarchy restrictions to in Amazon Connect. Following are acceptable ResourceNames: ``User`` .\n')
    permissions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Permissions assigned to the security profile. For a list of valid permissions, see `List of security profile permissions <https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-list.html>`_ .\n')
    tag_restricted_resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of resources that a security profile applies tag restrictions to in Amazon Connect.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.')
    _init_params: typing.ClassVar[list[str]] = ['instance_arn', 'security_profile_name', 'allowed_access_control_hierarchy_group_id', 'allowed_access_control_tags', 'applications', 'description', 'hierarchy_restricted_resources', 'permissions', 'tag_restricted_resources', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['ApplicationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnSecurityProfile'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnSecurityProfileDefConfig] = pydantic.Field(None)


class CfnSecurityProfileDefConfig(pydantic.BaseModel):
    ApplicationProperty: typing.Optional[list[models.aws_connect.CfnSecurityProfileDefApplicationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnSecurityProfileDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnSecurityProfileDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnSecurityProfileDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnSecurityProfileDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnSecurityProfileDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnSecurityProfileDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnSecurityProfileDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnSecurityProfileDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnSecurityProfileDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnSecurityProfileDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnSecurityProfileDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnSecurityProfileDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnSecurityProfileDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_last_modified_time_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnSecurityProfileDefApplicationpropertyParams(pydantic.BaseModel):
    application_permissions: typing.Sequence[str] = pydantic.Field(..., description='')
    namespace: str = pydantic.Field(..., description='')
    ...

class CfnSecurityProfileDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSecurityProfileDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSecurityProfileDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSecurityProfileDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSecurityProfileDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSecurityProfileDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSecurityProfileDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSecurityProfileDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSecurityProfileDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSecurityProfileDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSecurityProfileDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnSecurityProfileDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSecurityProfileDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSecurityProfileDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnTaskTemplate
class CfnTaskTemplateDef(BaseCfnResource):
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the Amazon Connect instance.\n')
    client_token: typing.Optional[str] = pydantic.Field(None, description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.\n')
    constraints: typing.Any = pydantic.Field(None, description='Constraints that are applicable to the fields listed. The values can be represented in either JSON or YAML format. For an example of the JSON configuration, see *Examples* at the bottom of this page.\n')
    contact_flow_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the flow that runs by default when a task is created by referencing this template. ``ContactFlowArn`` is not required when there is a field with ``fieldType`` = ``QUICK_CONNECT`` .\n')
    defaults: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnTaskTemplate_DefaultFieldValuePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The default values for fields when a task is created by referencing this template.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the task template.\n')
    fields: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnTaskTemplate_FieldPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Fields that are part of the template. A template requires at least one field that has type ``Name`` .\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the task template.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='The status of the task template.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource.')
    _init_params: typing.ClassVar[list[str]] = ['instance_arn', 'client_token', 'constraints', 'contact_flow_arn', 'defaults', 'description', 'fields', 'name', 'status', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['ConstraintsProperty', 'DefaultFieldValueProperty', 'FieldIdentifierProperty', 'FieldProperty', 'InvisibleFieldInfoProperty', 'ReadOnlyFieldInfoProperty', 'RequiredFieldInfoProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnTaskTemplate'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnTaskTemplateDefConfig] = pydantic.Field(None)


class CfnTaskTemplateDefConfig(pydantic.BaseModel):
    ConstraintsProperty: typing.Optional[list[models.aws_connect.CfnTaskTemplateDefConstraintspropertyParams]] = pydantic.Field(None, description='')
    DefaultFieldValueProperty: typing.Optional[list[models.aws_connect.CfnTaskTemplateDefDefaultfieldvaluepropertyParams]] = pydantic.Field(None, description='')
    FieldIdentifierProperty: typing.Optional[list[models.aws_connect.CfnTaskTemplateDefFieldidentifierpropertyParams]] = pydantic.Field(None, description='')
    FieldProperty: typing.Optional[list[models.aws_connect.CfnTaskTemplateDefFieldpropertyParams]] = pydantic.Field(None, description='')
    InvisibleFieldInfoProperty: typing.Optional[list[models.aws_connect.CfnTaskTemplateDefInvisiblefieldinfopropertyParams]] = pydantic.Field(None, description='')
    ReadOnlyFieldInfoProperty: typing.Optional[list[models.aws_connect.CfnTaskTemplateDefReadonlyfieldinfopropertyParams]] = pydantic.Field(None, description='')
    RequiredFieldInfoProperty: typing.Optional[list[models.aws_connect.CfnTaskTemplateDefRequiredfieldinfopropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnTaskTemplateDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnTaskTemplateDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnTaskTemplateDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnTaskTemplateDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnTaskTemplateDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnTaskTemplateDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnTaskTemplateDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnTaskTemplateDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnTaskTemplateDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnTaskTemplateDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnTaskTemplateDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnTaskTemplateDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnTaskTemplateDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnTaskTemplateDefConstraintspropertyParams(pydantic.BaseModel):
    invisible_fields: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnTaskTemplate_InvisibleFieldInfoPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    read_only_fields: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnTaskTemplate_ReadOnlyFieldInfoPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    required_fields: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnTaskTemplate_RequiredFieldInfoPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnTaskTemplateDefDefaultfieldvaluepropertyParams(pydantic.BaseModel):
    default_value: str = pydantic.Field(..., description='')
    id: typing.Union[models.UnsupportedResource, models.aws_connect.CfnTaskTemplate_FieldIdentifierPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnTaskTemplateDefFieldidentifierpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    ...

class CfnTaskTemplateDefFieldpropertyParams(pydantic.BaseModel):
    id: typing.Union[models.UnsupportedResource, models.aws_connect.CfnTaskTemplate_FieldIdentifierPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    single_select_options: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnTaskTemplateDefInvisiblefieldinfopropertyParams(pydantic.BaseModel):
    id: typing.Union[models.UnsupportedResource, models.aws_connect.CfnTaskTemplate_FieldIdentifierPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnTaskTemplateDefReadonlyfieldinfopropertyParams(pydantic.BaseModel):
    id: typing.Union[models.UnsupportedResource, models.aws_connect.CfnTaskTemplate_FieldIdentifierPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnTaskTemplateDefRequiredfieldinfopropertyParams(pydantic.BaseModel):
    id: typing.Union[models.UnsupportedResource, models.aws_connect.CfnTaskTemplate_FieldIdentifierPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnTaskTemplateDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTaskTemplateDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTaskTemplateDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTaskTemplateDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTaskTemplateDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTaskTemplateDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTaskTemplateDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTaskTemplateDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTaskTemplateDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTaskTemplateDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTaskTemplateDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnTaskTemplateDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTaskTemplateDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTaskTemplateDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnTrafficDistributionGroup
class CfnTrafficDistributionGroupDef(BaseCfnResource):
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN).\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the traffic distribution group.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the traffic distribution group.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource. For example, {"tags": {"key1":"value1", "key2":"value2"} }.')
    _init_params: typing.ClassVar[list[str]] = ['instance_arn', 'name', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnTrafficDistributionGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnTrafficDistributionGroupDefConfig] = pydantic.Field(None)


class CfnTrafficDistributionGroupDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnTrafficDistributionGroupDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnTrafficDistributionGroupDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnTrafficDistributionGroupDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnTrafficDistributionGroupDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnTrafficDistributionGroupDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnTrafficDistributionGroupDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnTrafficDistributionGroupDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnTrafficDistributionGroupDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnTrafficDistributionGroupDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnTrafficDistributionGroupDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnTrafficDistributionGroupDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnTrafficDistributionGroupDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnTrafficDistributionGroupDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_is_default_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnTrafficDistributionGroupDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTrafficDistributionGroupDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTrafficDistributionGroupDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTrafficDistributionGroupDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTrafficDistributionGroupDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTrafficDistributionGroupDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTrafficDistributionGroupDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTrafficDistributionGroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTrafficDistributionGroupDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTrafficDistributionGroupDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTrafficDistributionGroupDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnTrafficDistributionGroupDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTrafficDistributionGroupDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTrafficDistributionGroupDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnUser
class CfnUserDef(BaseCfnResource):
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the instance.\n')
    phone_config: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_connect.CfnUser_UserPhoneConfigPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Information about the phone configuration for the user.\n')
    routing_profile_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The Amazon Resource Name (ARN) of the user's routing profile.\n")
    security_profile_arns: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The Amazon Resource Name (ARN) of the user's security profile.\n")
    username: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The user name assigned to the user account.\n')
    directory_user_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the user account in the directory used for identity management.\n')
    hierarchy_group_arn: typing.Optional[str] = pydantic.Field(None, description="The Amazon Resource Name (ARN) of the user's hierarchy group.\n")
    identity_info: typing.Union[models.UnsupportedResource, models.aws_connect.CfnUser_UserIdentityInfoPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about the user identity.\n')
    password: typing.Optional[str] = pydantic.Field(None, description="The user's password.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags.\n')
    user_proficiencies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnUser_UserProficiencyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='One or more predefined attributes assigned to a user, with a numeric value that indicates how their level of skill in a specified area.')
    _init_params: typing.ClassVar[list[str]] = ['instance_arn', 'phone_config', 'routing_profile_arn', 'security_profile_arns', 'username', 'directory_user_id', 'hierarchy_group_arn', 'identity_info', 'password', 'tags', 'user_proficiencies']
    _method_names: typing.ClassVar[list[str]] = ['UserIdentityInfoProperty', 'UserPhoneConfigProperty', 'UserProficiencyProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnUser'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnUserDefConfig] = pydantic.Field(None)


class CfnUserDefConfig(pydantic.BaseModel):
    UserIdentityInfoProperty: typing.Optional[list[models.aws_connect.CfnUserDefUseridentityinfopropertyParams]] = pydantic.Field(None, description='')
    UserPhoneConfigProperty: typing.Optional[list[models.aws_connect.CfnUserDefUserphoneconfigpropertyParams]] = pydantic.Field(None, description='')
    UserProficiencyProperty: typing.Optional[list[models.aws_connect.CfnUserDefUserproficiencypropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnUserDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnUserDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnUserDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnUserDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnUserDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnUserDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnUserDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnUserDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnUserDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnUserDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnUserDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnUserDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnUserDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnUserDefUseridentityinfopropertyParams(pydantic.BaseModel):
    email: typing.Optional[str] = pydantic.Field(None, description='')
    first_name: typing.Optional[str] = pydantic.Field(None, description='')
    last_name: typing.Optional[str] = pydantic.Field(None, description='')
    mobile: typing.Optional[str] = pydantic.Field(None, description='')
    secondary_email: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnUserDefUserphoneconfigpropertyParams(pydantic.BaseModel):
    phone_type: str = pydantic.Field(..., description='')
    after_contact_work_time_limit: typing.Union[int, float, None] = pydantic.Field(None, description='')
    auto_accept: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    desk_phone_number: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnUserDefUserproficiencypropertyParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='')
    attribute_value: str = pydantic.Field(..., description='')
    level: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnUserDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnUserDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnUserDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnUserDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnUserDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnUserDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnUserDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnUserDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnUserDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnUserDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnUserDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnUserDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnUserDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnUserDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnUserHierarchyGroup
class CfnUserHierarchyGroupDef(BaseCfnResource):
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the user hierarchy group.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the user hierarchy group.\n')
    parent_group_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the parent group.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource.')
    _init_params: typing.ClassVar[list[str]] = ['instance_arn', 'name', 'parent_group_arn', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnUserHierarchyGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnUserHierarchyGroupDefConfig] = pydantic.Field(None)


class CfnUserHierarchyGroupDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnUserHierarchyGroupDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnUserHierarchyGroupDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnUserHierarchyGroupDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnUserHierarchyGroupDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnUserHierarchyGroupDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnUserHierarchyGroupDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnUserHierarchyGroupDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnUserHierarchyGroupDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnUserHierarchyGroupDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnUserHierarchyGroupDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnUserHierarchyGroupDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnUserHierarchyGroupDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnUserHierarchyGroupDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnUserHierarchyGroupDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnUserHierarchyGroupDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnUserHierarchyGroupDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnUserHierarchyGroupDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnUserHierarchyGroupDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnUserHierarchyGroupDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnUserHierarchyGroupDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnUserHierarchyGroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnUserHierarchyGroupDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnUserHierarchyGroupDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnUserHierarchyGroupDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnUserHierarchyGroupDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnUserHierarchyGroupDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnUserHierarchyGroupDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnView
class CfnViewDef(BaseCfnResource):
    actions: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of actions possible from the view.\n')
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the instance.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the view.\n')
    template: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The view template representing the structure of the view.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the view.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags associated with the view resource (not specific to view version).')
    _init_params: typing.ClassVar[list[str]] = ['actions', 'instance_arn', 'name', 'template', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnView'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnViewDefConfig] = pydantic.Field(None)


class CfnViewDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnViewDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnViewDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnViewDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnViewDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnViewDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnViewDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnViewDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnViewDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnViewDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnViewDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnViewDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnViewDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnViewDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    cdk_tag_manager_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnViewDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnViewDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnViewDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnViewDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnViewDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnViewDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnViewDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnViewDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnViewDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnViewDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnViewDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnViewDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnViewDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnViewDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnViewVersion
class CfnViewVersionDef(BaseCfnResource):
    view_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unqualified Amazon Resource Name (ARN) of the view. For example: ``arn:<partition>:connect:<region>:<accountId>:instance/00000000-0000-0000-0000-000000000000/view/00000000-0000-0000-0000-000000000000``\n')
    version_description: typing.Optional[str] = pydantic.Field(None, description='The description of the view version.\n')
    view_content_sha256: typing.Optional[str] = pydantic.Field(None, description='Indicates the checksum value of the latest published view content.')
    _init_params: typing.ClassVar[list[str]] = ['view_arn', 'version_description', 'view_content_sha256']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnViewVersion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_connect.CfnViewVersionDefConfig] = pydantic.Field(None)


class CfnViewVersionDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_connect.CfnViewVersionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_connect.CfnViewVersionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_connect.CfnViewVersionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_connect.CfnViewVersionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_connect.CfnViewVersionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_connect.CfnViewVersionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_connect.CfnViewVersionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_connect.CfnViewVersionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_connect.CfnViewVersionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_connect.CfnViewVersionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_connect.CfnViewVersionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_connect.CfnViewVersionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_connect.CfnViewVersionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnViewVersionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnViewVersionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnViewVersionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnViewVersionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnViewVersionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnViewVersionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnViewVersionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnViewVersionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnViewVersionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnViewVersionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnViewVersionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnViewVersionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnViewVersionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnViewVersionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_connect.CfnApprovedOriginProps
class CfnApprovedOriginPropsDef(BaseCfnProperty):
    instance_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the instance. *Minimum* : ``1`` *Maximum* : ``100``\n')
    origin: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Domain name to be added to the allow-list of the instance. *Maximum* : ``267``\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-approvedorigin.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    cfn_approved_origin_props = connect.CfnApprovedOriginProps(\n        instance_id="instanceId",\n        origin="origin"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_id', 'origin']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnApprovedOriginProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnContactFlowModuleProps
class CfnContactFlowModulePropsDef(BaseCfnProperty):
    content: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The content of the flow module.\n')
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the Amazon Connect instance.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the flow module.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the flow module.\n')
    state: typing.Optional[str] = pydantic.Field(None, description='The state of the flow module.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-contactflowmodule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    cfn_contact_flow_module_props = connect.CfnContactFlowModuleProps(\n        content="content",\n        instance_arn="instanceArn",\n        name="name",\n\n        # the properties below are optional\n        description="description",\n        state="state",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['content', 'instance_arn', 'name', 'description', 'state', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnContactFlowModuleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnContactFlowProps
class CfnContactFlowPropsDef(BaseCfnProperty):
    content: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The content of the flow. For more information, see `Amazon Connect Flow language <https://docs.aws.amazon.com/connect/latest/adminguide/flow-language.html>`_ in the *Amazon Connect Administrator Guide* .\n')
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the Amazon Connect instance.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the flow.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of the flow. For descriptions of the available types, see `Choose a flow type <https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types>`_ in the *Amazon Connect Administrator Guide* .\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the flow.\n')
    state: typing.Optional[str] = pydantic.Field(None, description='The state of the flow.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-contactflow.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    cfn_contact_flow_props = connect.CfnContactFlowProps(\n        content="content",\n        instance_arn="instanceArn",\n        name="name",\n        type="type",\n\n        # the properties below are optional\n        description="description",\n        state="state",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['content', 'instance_arn', 'name', 'type', 'description', 'state', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnContactFlowProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnEvaluationFormProps
class CfnEvaluationFormPropsDef(BaseCfnProperty):
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the Amazon Connect instance.\n')
    items: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_EvaluationFormBaseItemPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Items that are part of the evaluation form. The total number of sections and questions must not exceed 100 each. Questions must be contained in a section. *Minimum size* : 1 *Maximum size* : 100\n')
    status: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The status of the evaluation form. *Allowed values* : ``DRAFT`` | ``ACTIVE`` Default: - "DRAFT"\n')
    title: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A title of the evaluation form.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the evaluation form. *Length Constraints* : Minimum length of 0. Maximum length of 1024.\n')
    scoring_strategy: typing.Union[models.UnsupportedResource, models.aws_connect.CfnEvaluationForm_ScoringStrategyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A scoring strategy of the evaluation form.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-evaluationform.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    # evaluation_form_section_property_: connect.CfnEvaluationForm.EvaluationFormSectionProperty\n\n    cfn_evaluation_form_props = connect.CfnEvaluationFormProps(\n        instance_arn="instanceArn",\n        items=[connect.CfnEvaluationForm.EvaluationFormBaseItemProperty(\n            section=connect.CfnEvaluationForm.EvaluationFormSectionProperty(\n                ref_id="refId",\n                title="title",\n\n                # the properties below are optional\n                instructions="instructions",\n                items=[connect.CfnEvaluationForm.EvaluationFormItemProperty(\n                    question=connect.CfnEvaluationForm.EvaluationFormQuestionProperty(\n                        question_type="questionType",\n                        ref_id="refId",\n                        title="title",\n\n                        # the properties below are optional\n                        instructions="instructions",\n                        not_applicable_enabled=False,\n                        question_type_properties=connect.CfnEvaluationForm.EvaluationFormQuestionTypePropertiesProperty(\n                            numeric=connect.CfnEvaluationForm.EvaluationFormNumericQuestionPropertiesProperty(\n                                max_value=123,\n                                min_value=123,\n\n                                # the properties below are optional\n                                automation=connect.CfnEvaluationForm.EvaluationFormNumericQuestionAutomationProperty(\n                                    property_value=connect.CfnEvaluationForm.NumericQuestionPropertyValueAutomationProperty(\n                                        label="label"\n                                    )\n                                ),\n                                options=[connect.CfnEvaluationForm.EvaluationFormNumericQuestionOptionProperty(\n                                    max_value=123,\n                                    min_value=123,\n\n                                    # the properties below are optional\n                                    automatic_fail=False,\n                                    score=123\n                                )]\n                            ),\n                            single_select=connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionPropertiesProperty(\n                                options=[connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionOptionProperty(\n                                    ref_id="refId",\n                                    text="text",\n\n                                    # the properties below are optional\n                                    automatic_fail=False,\n                                    score=123\n                                )],\n\n                                # the properties below are optional\n                                automation=connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionAutomationProperty(\n                                    options=[connect.CfnEvaluationForm.EvaluationFormSingleSelectQuestionAutomationOptionProperty(\n                                        rule_category=connect.CfnEvaluationForm.SingleSelectQuestionRuleCategoryAutomationProperty(\n                                            category="category",\n                                            condition="condition",\n                                            option_ref_id="optionRefId"\n                                        )\n                                    )],\n\n                                    # the properties below are optional\n                                    default_option_ref_id="defaultOptionRefId"\n                                ),\n                                display_as="displayAs"\n                            )\n                        ),\n                        weight=123\n                    ),\n                    section=evaluation_form_section_property_\n                )],\n                weight=123\n            )\n        )],\n        status="status",\n        title="title",\n\n        # the properties below are optional\n        description="description",\n        scoring_strategy=connect.CfnEvaluationForm.ScoringStrategyProperty(\n            mode="mode",\n            status="status"\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_arn', 'items', 'status', 'title', 'description', 'scoring_strategy', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnEvaluationFormProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnHoursOfOperationProps
class CfnHoursOfOperationPropsDef(BaseCfnProperty):
    config: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnHoursOfOperation_HoursOfOperationConfigPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Configuration information for the hours of operation.\n')
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the instance.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name for the hours of operation.\n')
    time_zone: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The time zone for the hours of operation.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description for the hours of operation.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-hoursofoperation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    cfn_hours_of_operation_props = connect.CfnHoursOfOperationProps(\n        config=[connect.CfnHoursOfOperation.HoursOfOperationConfigProperty(\n            day="day",\n            end_time=connect.CfnHoursOfOperation.HoursOfOperationTimeSliceProperty(\n                hours=123,\n                minutes=123\n            ),\n            start_time=connect.CfnHoursOfOperation.HoursOfOperationTimeSliceProperty(\n                hours=123,\n                minutes=123\n            )\n        )],\n        instance_arn="instanceArn",\n        name="name",\n        time_zone="timeZone",\n\n        # the properties below are optional\n        description="description",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['config', 'instance_arn', 'name', 'time_zone', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnHoursOfOperationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnInstanceProps
class CfnInstancePropsDef(BaseCfnProperty):
    attributes: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_connect.CfnInstance_AttributesPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A toggle for an individual feature at the instance level.\n')
    identity_management_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identity management type.\n')
    directory_id: typing.Optional[str] = pydantic.Field(None, description='The identifier for the directory.\n')
    instance_alias: typing.Optional[str] = pydantic.Field(None, description='The alias of instance. ``InstanceAlias`` is only required when ``IdentityManagementType`` is ``CONNECT_MANAGED`` or ``SAML`` . ``InstanceAlias`` is not required when ``IdentityManagementType`` is ``EXISTING_DIRECTORY`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-instance.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    cfn_instance_props = connect.CfnInstanceProps(\n        attributes=connect.CfnInstance.AttributesProperty(\n            inbound_calls=False,\n            outbound_calls=False,\n\n            # the properties below are optional\n            auto_resolve_best_voices=False,\n            contactflow_logs=False,\n            contact_lens=False,\n            early_media=False,\n            use_custom_tts_voices=False\n        ),\n        identity_management_type="identityManagementType",\n\n        # the properties below are optional\n        directory_id="directoryId",\n        instance_alias="instanceAlias",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['attributes', 'identity_management_type', 'directory_id', 'instance_alias', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnInstanceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnInstanceStorageConfigProps
class CfnInstanceStorageConfigPropsDef(BaseCfnProperty):
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the instance.\n')
    resource_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A valid resource type. Following are the valid resource types: ``CHAT_TRANSCRIPTS`` | ``CALL_RECORDINGS`` | ``SCHEDULED_REPORTS`` | ``MEDIA_STREAMS`` | ``CONTACT_TRACE_RECORDS`` | ``AGENT_EVENTS``\n')
    storage_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A valid storage type.\n')
    kinesis_firehose_config: typing.Union[models.UnsupportedResource, models.aws_connect.CfnInstanceStorageConfig_KinesisFirehoseConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration of the Kinesis Firehose delivery stream.\n')
    kinesis_stream_config: typing.Union[models.UnsupportedResource, models.aws_connect.CfnInstanceStorageConfig_KinesisStreamConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration of the Kinesis data stream.\n')
    kinesis_video_stream_config: typing.Union[models.UnsupportedResource, models.aws_connect.CfnInstanceStorageConfig_KinesisVideoStreamConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration of the Kinesis video stream.\n')
    s3_config: typing.Union[models.UnsupportedResource, models.aws_connect.CfnInstanceStorageConfig_S3ConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The S3 bucket configuration.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-instancestorageconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    cfn_instance_storage_config_props = connect.CfnInstanceStorageConfigProps(\n        instance_arn="instanceArn",\n        resource_type="resourceType",\n        storage_type="storageType",\n\n        # the properties below are optional\n        kinesis_firehose_config=connect.CfnInstanceStorageConfig.KinesisFirehoseConfigProperty(\n            firehose_arn="firehoseArn"\n        ),\n        kinesis_stream_config=connect.CfnInstanceStorageConfig.KinesisStreamConfigProperty(\n            stream_arn="streamArn"\n        ),\n        kinesis_video_stream_config=connect.CfnInstanceStorageConfig.KinesisVideoStreamConfigProperty(\n            encryption_config=connect.CfnInstanceStorageConfig.EncryptionConfigProperty(\n                encryption_type="encryptionType",\n                key_id="keyId"\n            ),\n            prefix="prefix",\n            retention_period_hours=123\n        ),\n        s3_config=connect.CfnInstanceStorageConfig.S3ConfigProperty(\n            bucket_name="bucketName",\n            bucket_prefix="bucketPrefix",\n\n            # the properties below are optional\n            encryption_config=connect.CfnInstanceStorageConfig.EncryptionConfigProperty(\n                encryption_type="encryptionType",\n                key_id="keyId"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_arn', 'resource_type', 'storage_type', 'kinesis_firehose_config', 'kinesis_stream_config', 'kinesis_video_stream_config', 's3_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnInstanceStorageConfigProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnIntegrationAssociationProps
class CfnIntegrationAssociationPropsDef(BaseCfnProperty):
    instance_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the instance. *Minimum* : ``1`` *Maximum* : ``100``\n')
    integration_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='ARN of the integration being associated with the instance. *Minimum* : ``1`` *Maximum* : ``140``\n')
    integration_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies the integration type to be associated with the instance. *Allowed Values* : ``LEX_BOT`` | ``LAMBDA_FUNCTION``\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-integrationassociation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    cfn_integration_association_props = connect.CfnIntegrationAssociationProps(\n        instance_id="instanceId",\n        integration_arn="integrationArn",\n        integration_type="integrationType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_id', 'integration_arn', 'integration_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnIntegrationAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnPhoneNumberProps
class CfnPhoneNumberPropsDef(BaseCfnProperty):
    target_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution group that phone numbers are claimed to.\n')
    country_code: typing.Optional[str] = pydantic.Field(None, description='The ISO country code.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the phone number.\n')
    prefix: typing.Optional[str] = pydantic.Field(None, description='The prefix of the phone number. If provided, it must contain ``+`` as part of the country code. *Pattern* : ``^\\\\+[0-9]{1,15}``\n')
    source_phone_number_arn: typing.Optional[str] = pydantic.Field(None, description='The claimed phone number ARN that was previously imported from the external service, such as Amazon Pinpoint. If it is from Amazon Pinpoint, it looks like the ARN of the phone number that was imported from Amazon Pinpoint.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.\n')
    type: typing.Optional[str] = pydantic.Field(None, description='The type of phone number.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-phonenumber.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    cfn_phone_number_props = connect.CfnPhoneNumberProps(\n        target_arn="targetArn",\n\n        # the properties below are optional\n        country_code="countryCode",\n        description="description",\n        prefix="prefix",\n        source_phone_number_arn="sourcePhoneNumberArn",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['target_arn', 'country_code', 'description', 'prefix', 'source_phone_number_arn', 'tags', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnPhoneNumberProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnPredefinedAttributeProps
class CfnPredefinedAttributePropsDef(BaseCfnProperty):
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the instance.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the predefined attribute.\n')
    values: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_connect.CfnPredefinedAttribute_ValuesPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The values of a predefined attribute.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-predefinedattribute.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    cfn_predefined_attribute_props = connect.CfnPredefinedAttributeProps(\n        instance_arn="instanceArn",\n        name="name",\n        values=connect.CfnPredefinedAttribute.ValuesProperty(\n            string_list=["stringList"]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_arn', 'name', 'values']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnPredefinedAttributeProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnPromptProps
class CfnPromptPropsDef(BaseCfnProperty):
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the Amazon Connect instance.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the prompt.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the prompt.\n')
    s3_uri: typing.Optional[str] = pydantic.Field(None, description='The URI for the S3 bucket where the prompt is stored. This property is required when you create a prompt.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-prompt.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    cfn_prompt_props = connect.CfnPromptProps(\n        instance_arn="instanceArn",\n        name="name",\n\n        # the properties below are optional\n        description="description",\n        s3_uri="s3Uri",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_arn', 'name', 'description', 's3_uri', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnPromptProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnQueueProps
class CfnQueuePropsDef(BaseCfnProperty):
    hours_of_operation_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the hours of operation.\n')
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the Amazon Connect instance.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the queue.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the queue.\n')
    max_contacts: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of contacts that can be in the queue before it is considered full.\n')
    outbound_caller_config: typing.Union[models.UnsupportedResource, models.aws_connect.CfnQueue_OutboundCallerConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The outbound caller ID name, number, and outbound whisper flow.\n')
    quick_connect_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Amazon Resource Names (ARN) of the of the quick connects available to agents who are working the queue.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='The status of the queue.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-queue.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    cfn_queue_props = connect.CfnQueueProps(\n        hours_of_operation_arn="hoursOfOperationArn",\n        instance_arn="instanceArn",\n        name="name",\n\n        # the properties below are optional\n        description="description",\n        max_contacts=123,\n        outbound_caller_config=connect.CfnQueue.OutboundCallerConfigProperty(\n            outbound_caller_id_name="outboundCallerIdName",\n            outbound_caller_id_number_arn="outboundCallerIdNumberArn",\n            outbound_flow_arn="outboundFlowArn"\n        ),\n        quick_connect_arns=["quickConnectArns"],\n        status="status",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['hours_of_operation_arn', 'instance_arn', 'name', 'description', 'max_contacts', 'outbound_caller_config', 'quick_connect_arns', 'status', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnQueueProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnQuickConnectProps
class CfnQuickConnectPropsDef(BaseCfnProperty):
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the instance.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the quick connect.\n')
    quick_connect_config: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_connect.CfnQuickConnect_QuickConnectConfigPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Contains information about the quick connect.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the quick connect.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-quickconnect.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    cfn_quick_connect_props = connect.CfnQuickConnectProps(\n        instance_arn="instanceArn",\n        name="name",\n        quick_connect_config=connect.CfnQuickConnect.QuickConnectConfigProperty(\n            quick_connect_type="quickConnectType",\n\n            # the properties below are optional\n            phone_config=connect.CfnQuickConnect.PhoneNumberQuickConnectConfigProperty(\n                phone_number="phoneNumber"\n            ),\n            queue_config=connect.CfnQuickConnect.QueueQuickConnectConfigProperty(\n                contact_flow_arn="contactFlowArn",\n                queue_arn="queueArn"\n            ),\n            user_config=connect.CfnQuickConnect.UserQuickConnectConfigProperty(\n                contact_flow_arn="contactFlowArn",\n                user_arn="userArn"\n            )\n        ),\n\n        # the properties below are optional\n        description="description",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_arn', 'name', 'quick_connect_config', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnQuickConnectProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnRoutingProfileProps
class CfnRoutingProfilePropsDef(BaseCfnProperty):
    default_outbound_queue_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the default outbound queue for the routing profile.\n')
    description: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The description of the routing profile.\n')
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the Amazon Connect instance.\n')
    media_concurrencies: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnRoutingProfile_MediaConcurrencyPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the routing profile.\n')
    agent_availability_timer: typing.Optional[str] = pydantic.Field(None, description='Whether agents with this routing profile will have their routing order calculated based on *time since their last inbound contact* or *longest idle time* .\n')
    queue_configs: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnRoutingProfile_RoutingProfileQueueConfigPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The inbound queues associated with the routing profile. If no queue is added, the agent can make only outbound calls.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-routingprofile.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    cfn_routing_profile_props = connect.CfnRoutingProfileProps(\n        default_outbound_queue_arn="defaultOutboundQueueArn",\n        description="description",\n        instance_arn="instanceArn",\n        media_concurrencies=[connect.CfnRoutingProfile.MediaConcurrencyProperty(\n            channel="channel",\n            concurrency=123,\n\n            # the properties below are optional\n            cross_channel_behavior=connect.CfnRoutingProfile.CrossChannelBehaviorProperty(\n                behavior_type="behaviorType"\n            )\n        )],\n        name="name",\n\n        # the properties below are optional\n        agent_availability_timer="agentAvailabilityTimer",\n        queue_configs=[connect.CfnRoutingProfile.RoutingProfileQueueConfigProperty(\n            delay=123,\n            priority=123,\n            queue_reference=connect.CfnRoutingProfile.RoutingProfileQueueReferenceProperty(\n                channel="channel",\n                queue_arn="queueArn"\n            )\n        )],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['default_outbound_queue_arn', 'description', 'instance_arn', 'media_concurrencies', 'name', 'agent_availability_timer', 'queue_configs', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnRoutingProfileProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnRuleProps
class CfnRulePropsDef(BaseCfnProperty):
    actions: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_connect.CfnRule_ActionsPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of actions to be run when the rule is triggered.\n')
    function: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The conditions of the rule.\n')
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the instance.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the rule.\n')
    publish_status: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The publish status of the rule. *Allowed values* : ``DRAFT`` | ``PUBLISHED``\n')
    trigger_event_source: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_connect.CfnRule_RuleTriggerEventSourcePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The event source to trigger the rule.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-rule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    # assign_contact_category_actions: Any\n    # empty_value: Any\n    # end_associated_tasks_actions: Any\n\n    cfn_rule_props = connect.CfnRuleProps(\n        actions=connect.CfnRule.ActionsProperty(\n            assign_contact_category_actions=[assign_contact_category_actions],\n            create_case_actions=[connect.CfnRule.CreateCaseActionProperty(\n                fields=[connect.CfnRule.FieldProperty(\n                    id="id",\n                    value=connect.CfnRule.FieldValueProperty(\n                        boolean_value=False,\n                        double_value=123,\n                        empty_value=empty_value,\n                        string_value="stringValue"\n                    )\n                )],\n                template_id="templateId"\n            )],\n            end_associated_tasks_actions=[end_associated_tasks_actions],\n            event_bridge_actions=[connect.CfnRule.EventBridgeActionProperty(\n                name="name"\n            )],\n            send_notification_actions=[connect.CfnRule.SendNotificationActionProperty(\n                content="content",\n                content_type="contentType",\n                delivery_method="deliveryMethod",\n                recipient=connect.CfnRule.NotificationRecipientTypeProperty(\n                    user_arns=["userArns"],\n                    user_tags={\n                        "user_tags_key": "userTags"\n                    }\n                ),\n\n                # the properties below are optional\n                subject="subject"\n            )],\n            submit_auto_evaluation_actions=[connect.CfnRule.SubmitAutoEvaluationActionProperty(\n                evaluation_form_arn="evaluationFormArn"\n            )],\n            task_actions=[connect.CfnRule.TaskActionProperty(\n                contact_flow_arn="contactFlowArn",\n                name="name",\n\n                # the properties below are optional\n                description="description",\n                references={\n                    "references_key": connect.CfnRule.ReferenceProperty(\n                        type="type",\n                        value="value"\n                    )\n                }\n            )],\n            update_case_actions=[connect.CfnRule.UpdateCaseActionProperty(\n                fields=[connect.CfnRule.FieldProperty(\n                    id="id",\n                    value=connect.CfnRule.FieldValueProperty(\n                        boolean_value=False,\n                        double_value=123,\n                        empty_value=empty_value,\n                        string_value="stringValue"\n                    )\n                )]\n            )]\n        ),\n        function="function",\n        instance_arn="instanceArn",\n        name="name",\n        publish_status="publishStatus",\n        trigger_event_source=connect.CfnRule.RuleTriggerEventSourceProperty(\n            event_source_name="eventSourceName",\n\n            # the properties below are optional\n            integration_association_arn="integrationAssociationArn"\n        ),\n\n        # the properties below are optional\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['actions', 'function', 'instance_arn', 'name', 'publish_status', 'trigger_event_source', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnRuleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnSecurityKeyProps
class CfnSecurityKeyPropsDef(BaseCfnProperty):
    instance_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the instance. *Minimum* : ``1`` *Maximum* : ``100``\n')
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A valid security key in PEM format. For example:. ``"-----BEGIN PUBLIC KEY-----\\ [a lot of characters] ----END PUBLIC KEY-----"`` *Minimum* : ``1`` *Maximum* : ``1024``\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-securitykey.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    cfn_security_key_props = connect.CfnSecurityKeyProps(\n        instance_id="instanceId",\n        key="key"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_id', 'key']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnSecurityKeyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnSecurityProfileProps
class CfnSecurityProfilePropsDef(BaseCfnProperty):
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the Amazon Connect instance.\n')
    security_profile_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name for the security profile.\n')
    allowed_access_control_hierarchy_group_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the hierarchy group that a security profile uses to restrict access to resources in Amazon Connect.\n')
    allowed_access_control_tags: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.CfnTagDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The list of tags that a security profile uses to restrict access to resources in Amazon Connect.\n')
    applications: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnSecurityProfile_ApplicationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of third-party applications that the security profile will give access to.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the security profile.\n')
    hierarchy_restricted_resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of resources that a security profile applies hierarchy restrictions to in Amazon Connect. Following are acceptable ResourceNames: ``User`` .\n')
    permissions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Permissions assigned to the security profile. For a list of valid permissions, see `List of security profile permissions <https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-list.html>`_ .\n')
    tag_restricted_resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of resources that a security profile applies tag restrictions to in Amazon Connect.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-securityprofile.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    cfn_security_profile_props = connect.CfnSecurityProfileProps(\n        instance_arn="instanceArn",\n        security_profile_name="securityProfileName",\n\n        # the properties below are optional\n        allowed_access_control_hierarchy_group_id="allowedAccessControlHierarchyGroupId",\n        allowed_access_control_tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        applications=[connect.CfnSecurityProfile.ApplicationProperty(\n            application_permissions=["applicationPermissions"],\n            namespace="namespace"\n        )],\n        description="description",\n        hierarchy_restricted_resources=["hierarchyRestrictedResources"],\n        permissions=["permissions"],\n        tag_restricted_resources=["tagRestrictedResources"],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_arn', 'security_profile_name', 'allowed_access_control_hierarchy_group_id', 'allowed_access_control_tags', 'applications', 'description', 'hierarchy_restricted_resources', 'permissions', 'tag_restricted_resources', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnSecurityProfileProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnTaskTemplateProps
class CfnTaskTemplatePropsDef(BaseCfnProperty):
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the Amazon Connect instance.\n')
    client_token: typing.Optional[str] = pydantic.Field(None, description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.\n')
    constraints: typing.Any = pydantic.Field(None, description='Constraints that are applicable to the fields listed. The values can be represented in either JSON or YAML format. For an example of the JSON configuration, see *Examples* at the bottom of this page.\n')
    contact_flow_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the flow that runs by default when a task is created by referencing this template. ``ContactFlowArn`` is not required when there is a field with ``fieldType`` = ``QUICK_CONNECT`` .\n')
    defaults: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnTaskTemplate_DefaultFieldValuePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The default values for fields when a task is created by referencing this template.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the task template.\n')
    fields: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnTaskTemplate_FieldPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Fields that are part of the template. A template requires at least one field that has type ``Name`` .\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the task template.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='The status of the task template.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-tasktemplate.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    # constraints: Any\n\n    cfn_task_template_props = connect.CfnTaskTemplateProps(\n        instance_arn="instanceArn",\n\n        # the properties below are optional\n        client_token="clientToken",\n        constraints=constraints,\n        contact_flow_arn="contactFlowArn",\n        defaults=[connect.CfnTaskTemplate.DefaultFieldValueProperty(\n            default_value="defaultValue",\n            id=connect.CfnTaskTemplate.FieldIdentifierProperty(\n                name="name"\n            )\n        )],\n        description="description",\n        fields=[connect.CfnTaskTemplate.FieldProperty(\n            id=connect.CfnTaskTemplate.FieldIdentifierProperty(\n                name="name"\n            ),\n            type="type",\n\n            # the properties below are optional\n            description="description",\n            single_select_options=["singleSelectOptions"]\n        )],\n        name="name",\n        status="status",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_arn', 'client_token', 'constraints', 'contact_flow_arn', 'defaults', 'description', 'fields', 'name', 'status', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnTaskTemplateProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnTrafficDistributionGroupProps
class CfnTrafficDistributionGroupPropsDef(BaseCfnProperty):
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN).\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the traffic distribution group.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the traffic distribution group.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags used to organize, track, or control access for this resource. For example, {"tags": {"key1":"value1", "key2":"value2"} }.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-trafficdistributiongroup.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    cfn_traffic_distribution_group_props = connect.CfnTrafficDistributionGroupProps(\n        instance_arn="instanceArn",\n        name="name",\n\n        # the properties below are optional\n        description="description",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_arn', 'name', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnTrafficDistributionGroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnUserHierarchyGroupProps
class CfnUserHierarchyGroupPropsDef(BaseCfnProperty):
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the user hierarchy group.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the user hierarchy group.\n')
    parent_group_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the parent group.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An array of key-value pairs to apply to this resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-userhierarchygroup.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    cfn_user_hierarchy_group_props = connect.CfnUserHierarchyGroupProps(\n        instance_arn="instanceArn",\n        name="name",\n\n        # the properties below are optional\n        parent_group_arn="parentGroupArn",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_arn', 'name', 'parent_group_arn', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnUserHierarchyGroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnUserProps
class CfnUserPropsDef(BaseCfnProperty):
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the instance.\n')
    phone_config: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_connect.CfnUser_UserPhoneConfigPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Information about the phone configuration for the user.\n')
    routing_profile_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The Amazon Resource Name (ARN) of the user's routing profile.\n")
    security_profile_arns: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The Amazon Resource Name (ARN) of the user's security profile.\n")
    username: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The user name assigned to the user account.\n')
    directory_user_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the user account in the directory used for identity management.\n')
    hierarchy_group_arn: typing.Optional[str] = pydantic.Field(None, description="The Amazon Resource Name (ARN) of the user's hierarchy group.\n")
    identity_info: typing.Union[models.UnsupportedResource, models.aws_connect.CfnUser_UserIdentityInfoPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about the user identity.\n')
    password: typing.Optional[str] = pydantic.Field(None, description="The user's password.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags.\n')
    user_proficiencies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_connect.CfnUser_UserProficiencyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='One or more predefined attributes assigned to a user, with a numeric value that indicates how their level of skill in a specified area.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-user.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    cfn_user_props = connect.CfnUserProps(\n        instance_arn="instanceArn",\n        phone_config=connect.CfnUser.UserPhoneConfigProperty(\n            phone_type="phoneType",\n\n            # the properties below are optional\n            after_contact_work_time_limit=123,\n            auto_accept=False,\n            desk_phone_number="deskPhoneNumber"\n        ),\n        routing_profile_arn="routingProfileArn",\n        security_profile_arns=["securityProfileArns"],\n        username="username",\n\n        # the properties below are optional\n        directory_user_id="directoryUserId",\n        hierarchy_group_arn="hierarchyGroupArn",\n        identity_info=connect.CfnUser.UserIdentityInfoProperty(\n            email="email",\n            first_name="firstName",\n            last_name="lastName",\n            mobile="mobile",\n            secondary_email="secondaryEmail"\n        ),\n        password="password",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        user_proficiencies=[connect.CfnUser.UserProficiencyProperty(\n            attribute_name="attributeName",\n            attribute_value="attributeValue",\n            level=123\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_arn', 'phone_config', 'routing_profile_arn', 'security_profile_arns', 'username', 'directory_user_id', 'hierarchy_group_arn', 'identity_info', 'password', 'tags', 'user_proficiencies']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnUserProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnViewProps
class CfnViewPropsDef(BaseCfnProperty):
    actions: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of actions possible from the view.\n')
    instance_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the instance.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the view.\n')
    template: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The view template representing the structure of the view.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the view.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags associated with the view resource (not specific to view version).\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-view.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    # template: Any\n\n    cfn_view_props = connect.CfnViewProps(\n        actions=["actions"],\n        instance_arn="instanceArn",\n        name="name",\n        template=template,\n\n        # the properties below are optional\n        description="description",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['actions', 'instance_arn', 'name', 'template', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnViewProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_connect.CfnViewVersionProps
class CfnViewVersionPropsDef(BaseCfnProperty):
    view_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unqualified Amazon Resource Name (ARN) of the view. For example: ``arn:<partition>:connect:<region>:<accountId>:instance/00000000-0000-0000-0000-000000000000/view/00000000-0000-0000-0000-000000000000``\n')
    version_description: typing.Optional[str] = pydantic.Field(None, description='The description of the view version.\n')
    view_content_sha256: typing.Optional[str] = pydantic.Field(None, description='Indicates the checksum value of the latest published view content.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-connect-viewversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_connect as connect\n\n    cfn_view_version_props = connect.CfnViewVersionProps(\n        view_arn="viewArn",\n\n        # the properties below are optional\n        version_description="versionDescription",\n        view_content_sha256="viewContentSha256"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['view_arn', 'version_description', 'view_content_sha256']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_connect.CfnViewVersionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    CfnEvaluationForm_EvaluationFormBaseItemProperty: typing.Optional[dict[str, models.aws_connect.CfnEvaluationForm_EvaluationFormBaseItemPropertyDef]] = pydantic.Field(None)
    CfnEvaluationForm_EvaluationFormItemProperty: typing.Optional[dict[str, models.aws_connect.CfnEvaluationForm_EvaluationFormItemPropertyDef]] = pydantic.Field(None)
    CfnEvaluationForm_EvaluationFormNumericQuestionAutomationProperty: typing.Optional[dict[str, models.aws_connect.CfnEvaluationForm_EvaluationFormNumericQuestionAutomationPropertyDef]] = pydantic.Field(None)
    CfnEvaluationForm_EvaluationFormNumericQuestionOptionProperty: typing.Optional[dict[str, models.aws_connect.CfnEvaluationForm_EvaluationFormNumericQuestionOptionPropertyDef]] = pydantic.Field(None)
    CfnEvaluationForm_EvaluationFormNumericQuestionPropertiesProperty: typing.Optional[dict[str, models.aws_connect.CfnEvaluationForm_EvaluationFormNumericQuestionPropertiesPropertyDef]] = pydantic.Field(None)
    CfnEvaluationForm_EvaluationFormQuestionProperty: typing.Optional[dict[str, models.aws_connect.CfnEvaluationForm_EvaluationFormQuestionPropertyDef]] = pydantic.Field(None)
    CfnEvaluationForm_EvaluationFormQuestionTypePropertiesProperty: typing.Optional[dict[str, models.aws_connect.CfnEvaluationForm_EvaluationFormQuestionTypePropertiesPropertyDef]] = pydantic.Field(None)
    CfnEvaluationForm_EvaluationFormSectionProperty: typing.Optional[dict[str, models.aws_connect.CfnEvaluationForm_EvaluationFormSectionPropertyDef]] = pydantic.Field(None)
    CfnEvaluationForm_EvaluationFormSingleSelectQuestionAutomationOptionProperty: typing.Optional[dict[str, models.aws_connect.CfnEvaluationForm_EvaluationFormSingleSelectQuestionAutomationOptionPropertyDef]] = pydantic.Field(None)
    CfnEvaluationForm_EvaluationFormSingleSelectQuestionAutomationProperty: typing.Optional[dict[str, models.aws_connect.CfnEvaluationForm_EvaluationFormSingleSelectQuestionAutomationPropertyDef]] = pydantic.Field(None)
    CfnEvaluationForm_EvaluationFormSingleSelectQuestionOptionProperty: typing.Optional[dict[str, models.aws_connect.CfnEvaluationForm_EvaluationFormSingleSelectQuestionOptionPropertyDef]] = pydantic.Field(None)
    CfnEvaluationForm_EvaluationFormSingleSelectQuestionPropertiesProperty: typing.Optional[dict[str, models.aws_connect.CfnEvaluationForm_EvaluationFormSingleSelectQuestionPropertiesPropertyDef]] = pydantic.Field(None)
    CfnEvaluationForm_NumericQuestionPropertyValueAutomationProperty: typing.Optional[dict[str, models.aws_connect.CfnEvaluationForm_NumericQuestionPropertyValueAutomationPropertyDef]] = pydantic.Field(None)
    CfnEvaluationForm_ScoringStrategyProperty: typing.Optional[dict[str, models.aws_connect.CfnEvaluationForm_ScoringStrategyPropertyDef]] = pydantic.Field(None)
    CfnEvaluationForm_SingleSelectQuestionRuleCategoryAutomationProperty: typing.Optional[dict[str, models.aws_connect.CfnEvaluationForm_SingleSelectQuestionRuleCategoryAutomationPropertyDef]] = pydantic.Field(None)
    CfnHoursOfOperation_HoursOfOperationConfigProperty: typing.Optional[dict[str, models.aws_connect.CfnHoursOfOperation_HoursOfOperationConfigPropertyDef]] = pydantic.Field(None)
    CfnHoursOfOperation_HoursOfOperationTimeSliceProperty: typing.Optional[dict[str, models.aws_connect.CfnHoursOfOperation_HoursOfOperationTimeSlicePropertyDef]] = pydantic.Field(None)
    CfnInstance_AttributesProperty: typing.Optional[dict[str, models.aws_connect.CfnInstance_AttributesPropertyDef]] = pydantic.Field(None)
    CfnInstanceStorageConfig_EncryptionConfigProperty: typing.Optional[dict[str, models.aws_connect.CfnInstanceStorageConfig_EncryptionConfigPropertyDef]] = pydantic.Field(None)
    CfnInstanceStorageConfig_KinesisFirehoseConfigProperty: typing.Optional[dict[str, models.aws_connect.CfnInstanceStorageConfig_KinesisFirehoseConfigPropertyDef]] = pydantic.Field(None)
    CfnInstanceStorageConfig_KinesisStreamConfigProperty: typing.Optional[dict[str, models.aws_connect.CfnInstanceStorageConfig_KinesisStreamConfigPropertyDef]] = pydantic.Field(None)
    CfnInstanceStorageConfig_KinesisVideoStreamConfigProperty: typing.Optional[dict[str, models.aws_connect.CfnInstanceStorageConfig_KinesisVideoStreamConfigPropertyDef]] = pydantic.Field(None)
    CfnInstanceStorageConfig_S3ConfigProperty: typing.Optional[dict[str, models.aws_connect.CfnInstanceStorageConfig_S3ConfigPropertyDef]] = pydantic.Field(None)
    CfnPredefinedAttribute_ValuesProperty: typing.Optional[dict[str, models.aws_connect.CfnPredefinedAttribute_ValuesPropertyDef]] = pydantic.Field(None)
    CfnQueue_OutboundCallerConfigProperty: typing.Optional[dict[str, models.aws_connect.CfnQueue_OutboundCallerConfigPropertyDef]] = pydantic.Field(None)
    CfnQuickConnect_PhoneNumberQuickConnectConfigProperty: typing.Optional[dict[str, models.aws_connect.CfnQuickConnect_PhoneNumberQuickConnectConfigPropertyDef]] = pydantic.Field(None)
    CfnQuickConnect_QueueQuickConnectConfigProperty: typing.Optional[dict[str, models.aws_connect.CfnQuickConnect_QueueQuickConnectConfigPropertyDef]] = pydantic.Field(None)
    CfnQuickConnect_QuickConnectConfigProperty: typing.Optional[dict[str, models.aws_connect.CfnQuickConnect_QuickConnectConfigPropertyDef]] = pydantic.Field(None)
    CfnQuickConnect_UserQuickConnectConfigProperty: typing.Optional[dict[str, models.aws_connect.CfnQuickConnect_UserQuickConnectConfigPropertyDef]] = pydantic.Field(None)
    CfnRoutingProfile_CrossChannelBehaviorProperty: typing.Optional[dict[str, models.aws_connect.CfnRoutingProfile_CrossChannelBehaviorPropertyDef]] = pydantic.Field(None)
    CfnRoutingProfile_MediaConcurrencyProperty: typing.Optional[dict[str, models.aws_connect.CfnRoutingProfile_MediaConcurrencyPropertyDef]] = pydantic.Field(None)
    CfnRoutingProfile_RoutingProfileQueueConfigProperty: typing.Optional[dict[str, models.aws_connect.CfnRoutingProfile_RoutingProfileQueueConfigPropertyDef]] = pydantic.Field(None)
    CfnRoutingProfile_RoutingProfileQueueReferenceProperty: typing.Optional[dict[str, models.aws_connect.CfnRoutingProfile_RoutingProfileQueueReferencePropertyDef]] = pydantic.Field(None)
    CfnRule_ActionsProperty: typing.Optional[dict[str, models.aws_connect.CfnRule_ActionsPropertyDef]] = pydantic.Field(None)
    CfnRule_CreateCaseActionProperty: typing.Optional[dict[str, models.aws_connect.CfnRule_CreateCaseActionPropertyDef]] = pydantic.Field(None)
    CfnRule_EventBridgeActionProperty: typing.Optional[dict[str, models.aws_connect.CfnRule_EventBridgeActionPropertyDef]] = pydantic.Field(None)
    CfnRule_FieldProperty: typing.Optional[dict[str, models.aws_connect.CfnRule_FieldPropertyDef]] = pydantic.Field(None)
    CfnRule_FieldValueProperty: typing.Optional[dict[str, models.aws_connect.CfnRule_FieldValuePropertyDef]] = pydantic.Field(None)
    CfnRule_NotificationRecipientTypeProperty: typing.Optional[dict[str, models.aws_connect.CfnRule_NotificationRecipientTypePropertyDef]] = pydantic.Field(None)
    CfnRule_ReferenceProperty: typing.Optional[dict[str, models.aws_connect.CfnRule_ReferencePropertyDef]] = pydantic.Field(None)
    CfnRule_RuleTriggerEventSourceProperty: typing.Optional[dict[str, models.aws_connect.CfnRule_RuleTriggerEventSourcePropertyDef]] = pydantic.Field(None)
    CfnRule_SendNotificationActionProperty: typing.Optional[dict[str, models.aws_connect.CfnRule_SendNotificationActionPropertyDef]] = pydantic.Field(None)
    CfnRule_SubmitAutoEvaluationActionProperty: typing.Optional[dict[str, models.aws_connect.CfnRule_SubmitAutoEvaluationActionPropertyDef]] = pydantic.Field(None)
    CfnRule_TaskActionProperty: typing.Optional[dict[str, models.aws_connect.CfnRule_TaskActionPropertyDef]] = pydantic.Field(None)
    CfnRule_UpdateCaseActionProperty: typing.Optional[dict[str, models.aws_connect.CfnRule_UpdateCaseActionPropertyDef]] = pydantic.Field(None)
    CfnSecurityProfile_ApplicationProperty: typing.Optional[dict[str, models.aws_connect.CfnSecurityProfile_ApplicationPropertyDef]] = pydantic.Field(None)
    CfnTaskTemplate_ConstraintsProperty: typing.Optional[dict[str, models.aws_connect.CfnTaskTemplate_ConstraintsPropertyDef]] = pydantic.Field(None)
    CfnTaskTemplate_DefaultFieldValueProperty: typing.Optional[dict[str, models.aws_connect.CfnTaskTemplate_DefaultFieldValuePropertyDef]] = pydantic.Field(None)
    CfnTaskTemplate_FieldIdentifierProperty: typing.Optional[dict[str, models.aws_connect.CfnTaskTemplate_FieldIdentifierPropertyDef]] = pydantic.Field(None)
    CfnTaskTemplate_FieldProperty: typing.Optional[dict[str, models.aws_connect.CfnTaskTemplate_FieldPropertyDef]] = pydantic.Field(None)
    CfnTaskTemplate_InvisibleFieldInfoProperty: typing.Optional[dict[str, models.aws_connect.CfnTaskTemplate_InvisibleFieldInfoPropertyDef]] = pydantic.Field(None)
    CfnTaskTemplate_ReadOnlyFieldInfoProperty: typing.Optional[dict[str, models.aws_connect.CfnTaskTemplate_ReadOnlyFieldInfoPropertyDef]] = pydantic.Field(None)
    CfnTaskTemplate_RequiredFieldInfoProperty: typing.Optional[dict[str, models.aws_connect.CfnTaskTemplate_RequiredFieldInfoPropertyDef]] = pydantic.Field(None)
    CfnUser_UserIdentityInfoProperty: typing.Optional[dict[str, models.aws_connect.CfnUser_UserIdentityInfoPropertyDef]] = pydantic.Field(None)
    CfnUser_UserPhoneConfigProperty: typing.Optional[dict[str, models.aws_connect.CfnUser_UserPhoneConfigPropertyDef]] = pydantic.Field(None)
    CfnUser_UserProficiencyProperty: typing.Optional[dict[str, models.aws_connect.CfnUser_UserProficiencyPropertyDef]] = pydantic.Field(None)
    CfnApprovedOrigin: typing.Optional[dict[str, models.aws_connect.CfnApprovedOriginDef]] = pydantic.Field(None)
    CfnContactFlow: typing.Optional[dict[str, models.aws_connect.CfnContactFlowDef]] = pydantic.Field(None)
    CfnContactFlowModule: typing.Optional[dict[str, models.aws_connect.CfnContactFlowModuleDef]] = pydantic.Field(None)
    CfnEvaluationForm: typing.Optional[dict[str, models.aws_connect.CfnEvaluationFormDef]] = pydantic.Field(None)
    CfnHoursOfOperation: typing.Optional[dict[str, models.aws_connect.CfnHoursOfOperationDef]] = pydantic.Field(None)
    CfnInstance: typing.Optional[dict[str, models.aws_connect.CfnInstanceDef]] = pydantic.Field(None)
    CfnInstanceStorageConfig: typing.Optional[dict[str, models.aws_connect.CfnInstanceStorageConfigDef]] = pydantic.Field(None)
    CfnIntegrationAssociation: typing.Optional[dict[str, models.aws_connect.CfnIntegrationAssociationDef]] = pydantic.Field(None)
    CfnPhoneNumber: typing.Optional[dict[str, models.aws_connect.CfnPhoneNumberDef]] = pydantic.Field(None)
    CfnPredefinedAttribute: typing.Optional[dict[str, models.aws_connect.CfnPredefinedAttributeDef]] = pydantic.Field(None)
    CfnPrompt: typing.Optional[dict[str, models.aws_connect.CfnPromptDef]] = pydantic.Field(None)
    CfnQueue: typing.Optional[dict[str, models.aws_connect.CfnQueueDef]] = pydantic.Field(None)
    CfnQuickConnect: typing.Optional[dict[str, models.aws_connect.CfnQuickConnectDef]] = pydantic.Field(None)
    CfnRoutingProfile: typing.Optional[dict[str, models.aws_connect.CfnRoutingProfileDef]] = pydantic.Field(None)
    CfnRule: typing.Optional[dict[str, models.aws_connect.CfnRuleDef]] = pydantic.Field(None)
    CfnSecurityKey: typing.Optional[dict[str, models.aws_connect.CfnSecurityKeyDef]] = pydantic.Field(None)
    CfnSecurityProfile: typing.Optional[dict[str, models.aws_connect.CfnSecurityProfileDef]] = pydantic.Field(None)
    CfnTaskTemplate: typing.Optional[dict[str, models.aws_connect.CfnTaskTemplateDef]] = pydantic.Field(None)
    CfnTrafficDistributionGroup: typing.Optional[dict[str, models.aws_connect.CfnTrafficDistributionGroupDef]] = pydantic.Field(None)
    CfnUser: typing.Optional[dict[str, models.aws_connect.CfnUserDef]] = pydantic.Field(None)
    CfnUserHierarchyGroup: typing.Optional[dict[str, models.aws_connect.CfnUserHierarchyGroupDef]] = pydantic.Field(None)
    CfnView: typing.Optional[dict[str, models.aws_connect.CfnViewDef]] = pydantic.Field(None)
    CfnViewVersion: typing.Optional[dict[str, models.aws_connect.CfnViewVersionDef]] = pydantic.Field(None)
    CfnApprovedOriginProps: typing.Optional[dict[str, models.aws_connect.CfnApprovedOriginPropsDef]] = pydantic.Field(None)
    CfnContactFlowModuleProps: typing.Optional[dict[str, models.aws_connect.CfnContactFlowModulePropsDef]] = pydantic.Field(None)
    CfnContactFlowProps: typing.Optional[dict[str, models.aws_connect.CfnContactFlowPropsDef]] = pydantic.Field(None)
    CfnEvaluationFormProps: typing.Optional[dict[str, models.aws_connect.CfnEvaluationFormPropsDef]] = pydantic.Field(None)
    CfnHoursOfOperationProps: typing.Optional[dict[str, models.aws_connect.CfnHoursOfOperationPropsDef]] = pydantic.Field(None)
    CfnInstanceProps: typing.Optional[dict[str, models.aws_connect.CfnInstancePropsDef]] = pydantic.Field(None)
    CfnInstanceStorageConfigProps: typing.Optional[dict[str, models.aws_connect.CfnInstanceStorageConfigPropsDef]] = pydantic.Field(None)
    CfnIntegrationAssociationProps: typing.Optional[dict[str, models.aws_connect.CfnIntegrationAssociationPropsDef]] = pydantic.Field(None)
    CfnPhoneNumberProps: typing.Optional[dict[str, models.aws_connect.CfnPhoneNumberPropsDef]] = pydantic.Field(None)
    CfnPredefinedAttributeProps: typing.Optional[dict[str, models.aws_connect.CfnPredefinedAttributePropsDef]] = pydantic.Field(None)
    CfnPromptProps: typing.Optional[dict[str, models.aws_connect.CfnPromptPropsDef]] = pydantic.Field(None)
    CfnQueueProps: typing.Optional[dict[str, models.aws_connect.CfnQueuePropsDef]] = pydantic.Field(None)
    CfnQuickConnectProps: typing.Optional[dict[str, models.aws_connect.CfnQuickConnectPropsDef]] = pydantic.Field(None)
    CfnRoutingProfileProps: typing.Optional[dict[str, models.aws_connect.CfnRoutingProfilePropsDef]] = pydantic.Field(None)
    CfnRuleProps: typing.Optional[dict[str, models.aws_connect.CfnRulePropsDef]] = pydantic.Field(None)
    CfnSecurityKeyProps: typing.Optional[dict[str, models.aws_connect.CfnSecurityKeyPropsDef]] = pydantic.Field(None)
    CfnSecurityProfileProps: typing.Optional[dict[str, models.aws_connect.CfnSecurityProfilePropsDef]] = pydantic.Field(None)
    CfnTaskTemplateProps: typing.Optional[dict[str, models.aws_connect.CfnTaskTemplatePropsDef]] = pydantic.Field(None)
    CfnTrafficDistributionGroupProps: typing.Optional[dict[str, models.aws_connect.CfnTrafficDistributionGroupPropsDef]] = pydantic.Field(None)
    CfnUserHierarchyGroupProps: typing.Optional[dict[str, models.aws_connect.CfnUserHierarchyGroupPropsDef]] = pydantic.Field(None)
    CfnUserProps: typing.Optional[dict[str, models.aws_connect.CfnUserPropsDef]] = pydantic.Field(None)
    CfnViewProps: typing.Optional[dict[str, models.aws_connect.CfnViewPropsDef]] = pydantic.Field(None)
    CfnViewVersionProps: typing.Optional[dict[str, models.aws_connect.CfnViewVersionPropsDef]] = pydantic.Field(None)
    ...

import models
