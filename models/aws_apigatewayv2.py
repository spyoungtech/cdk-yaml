from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_apigatewayv2.HttpNoneAuthorizer
class HttpNoneAuthorizerDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.HttpNoneAuthorizer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.HttpNoneAuthorizerDefConfig] = pydantic.Field(None)


class HttpNoneAuthorizerDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[models.aws_apigatewayv2.HttpNoneAuthorizerDefBindParams]] = pydantic.Field(None, description='Bind this authorizer to a specified Http route.')

class HttpNoneAuthorizerDefBindParams(pydantic.BaseModel):
    route: typing.Union[models.aws_apigatewayv2.HttpRouteDef] = pydantic.Field(..., description='The route to which the authorizer is being bound.\n')
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The scope for any constructs created as part of the bind.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.HttpRouteIntegration
class HttpRouteIntegrationDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.HttpRouteIntegration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.HttpRouteIntegrationDefConfig] = pydantic.Field(None)


class HttpRouteIntegrationDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[models.aws_apigatewayv2.HttpRouteIntegrationDefBindParams]] = pydantic.Field(None, description='Bind this integration to the route.')

class HttpRouteIntegrationDefBindParams(pydantic.BaseModel):
    route: typing.Union[models.aws_apigatewayv2.HttpRouteDef] = pydantic.Field(..., description='The route to which this is being bound.\n')
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The current scope in which the bind is occurring. If the ``HttpRouteIntegration`` being bound creates additional constructs, this will be used as their parent scope.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.HttpRouteKey
class HttpRouteKeyDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['with_']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.HttpRouteKey'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.HttpRouteKeyDefConfig] = pydantic.Field(None)


class HttpRouteKeyDefConfig(pydantic.BaseModel):
    with_: typing.Optional[list[models.aws_apigatewayv2.HttpRouteKeyDefWithParams]] = pydantic.Field(None, description='Create a route key with the combination of the path and the method.')

class HttpRouteKeyDefWithParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='-\n')
    method: typing.Optional[aws_cdk.aws_apigatewayv2.HttpMethod] = pydantic.Field(None, description="default is 'ANY'.")
    return_config: typing.Optional[list[models.aws_apigatewayv2.HttpRouteKeyDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.IntegrationCredentials
class IntegrationCredentialsDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_role', 'use_caller_identity']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.IntegrationCredentials'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_role']
    ...


    from_role: typing.Optional[models.aws_apigatewayv2.IntegrationCredentialsDefFromRoleParams] = pydantic.Field(None, description='Use the specified role for integration requests.')
    resource_config: typing.Optional[models.aws_apigatewayv2.IntegrationCredentialsDefConfig] = pydantic.Field(None)


class IntegrationCredentialsDefConfig(pydantic.BaseModel):
    use_caller_identity: typing.Optional[list[models.aws_apigatewayv2.IntegrationCredentialsDefUseCallerIdentityParams]] = pydantic.Field(None, description="Use the calling user's identity to call the integration.")

class IntegrationCredentialsDefFromRoleParams(pydantic.BaseModel):
    role: typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef] = pydantic.Field(..., description='-')
    ...

class IntegrationCredentialsDefUseCallerIdentityParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_apigatewayv2.IntegrationCredentialsDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.MappingValue
class MappingValueDef(BaseClass):
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Represents a Mapping Value.')
    _init_params: typing.ClassVar[list[str]] = ['value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['context_variable', 'custom', 'request_body', 'request_header', 'request_path', 'request_path_param', 'request_query_string', 'stage_variable']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.MappingValue'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.MappingValueDefConfig] = pydantic.Field(None)


class MappingValueDefConfig(pydantic.BaseModel):
    context_variable: typing.Optional[list[models.aws_apigatewayv2.MappingValueDefContextVariableParams]] = pydantic.Field(None, description='Creates a context variable mapping value.')
    custom: typing.Optional[list[models.aws_apigatewayv2.MappingValueDefCustomParams]] = pydantic.Field(None, description='Creates a custom mapping value.')
    request_body: typing.Optional[list[models.aws_apigatewayv2.MappingValueDefRequestBodyParams]] = pydantic.Field(None, description='Creates a request body mapping value.')
    request_header: typing.Optional[list[models.aws_apigatewayv2.MappingValueDefRequestHeaderParams]] = pydantic.Field(None, description='Creates a header mapping value.')
    request_path: typing.Optional[list[models.aws_apigatewayv2.MappingValueDefRequestPathParams]] = pydantic.Field(None, description='Creates a request path mapping value.')
    request_path_param: typing.Optional[list[models.aws_apigatewayv2.MappingValueDefRequestPathParamParams]] = pydantic.Field(None, description='Creates a request path parameter mapping value.')
    request_query_string: typing.Optional[list[models.aws_apigatewayv2.MappingValueDefRequestQueryStringParams]] = pydantic.Field(None, description='Creates a query string mapping value.')
    stage_variable: typing.Optional[list[models.aws_apigatewayv2.MappingValueDefStageVariableParams]] = pydantic.Field(None, description='Creates a stage variable mapping value.')

class MappingValueDefContextVariableParams(pydantic.BaseModel):
    variable_name: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_apigatewayv2.MappingValueDefConfig]] = pydantic.Field(None)
    ...

class MappingValueDefCustomParams(pydantic.BaseModel):
    value: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_apigatewayv2.MappingValueDefConfig]] = pydantic.Field(None)
    ...

class MappingValueDefRequestBodyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_apigatewayv2.MappingValueDefConfig]] = pydantic.Field(None)
    ...

class MappingValueDefRequestHeaderParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_apigatewayv2.MappingValueDefConfig]] = pydantic.Field(None)
    ...

class MappingValueDefRequestPathParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_apigatewayv2.MappingValueDefConfig]] = pydantic.Field(None)
    ...

class MappingValueDefRequestPathParamParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_apigatewayv2.MappingValueDefConfig]] = pydantic.Field(None)
    ...

class MappingValueDefRequestQueryStringParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_apigatewayv2.MappingValueDefConfig]] = pydantic.Field(None)
    ...

class MappingValueDefStageVariableParams(pydantic.BaseModel):
    variable_name: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_apigatewayv2.MappingValueDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.ParameterMapping
class ParameterMappingDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['append_header', 'append_query_string', 'custom', 'overwrite_header', 'overwrite_path', 'overwrite_query_string', 'remove_header', 'remove_query_string']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_object']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.ParameterMapping'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_object']
    ...


    from_object: typing.Optional[models.aws_apigatewayv2.ParameterMappingDefFromObjectParams] = pydantic.Field(None, description='Creates a mapping from an object.')
    resource_config: typing.Optional[models.aws_apigatewayv2.ParameterMappingDefConfig] = pydantic.Field(None)


class ParameterMappingDefConfig(pydantic.BaseModel):
    append_header: typing.Optional[list[models.aws_apigatewayv2.ParameterMappingDefAppendHeaderParams]] = pydantic.Field(None, description='Creates a mapping to append a header.')
    append_query_string: typing.Optional[list[models.aws_apigatewayv2.ParameterMappingDefAppendQueryStringParams]] = pydantic.Field(None, description='Creates a mapping to append a query string.')
    custom: typing.Optional[list[models.aws_apigatewayv2.ParameterMappingDefCustomParams]] = pydantic.Field(None, description='Creates a custom mapping.')
    overwrite_header: typing.Optional[list[models.aws_apigatewayv2.ParameterMappingDefOverwriteHeaderParams]] = pydantic.Field(None, description='Creates a mapping to overwrite a header.')
    overwrite_path: typing.Optional[list[models.aws_apigatewayv2.ParameterMappingDefOverwritePathParams]] = pydantic.Field(None, description='Creates a mapping to overwrite a path.')
    overwrite_query_string: typing.Optional[list[models.aws_apigatewayv2.ParameterMappingDefOverwriteQueryStringParams]] = pydantic.Field(None, description='Creates a mapping to overwrite a querystring.')
    remove_header: typing.Optional[list[models.aws_apigatewayv2.ParameterMappingDefRemoveHeaderParams]] = pydantic.Field(None, description='Creates a mapping to remove a header.')
    remove_query_string: typing.Optional[list[models.aws_apigatewayv2.ParameterMappingDefRemoveQueryStringParams]] = pydantic.Field(None, description='Creates a mapping to remove a querystring.')

class ParameterMappingDefAppendHeaderParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='-\n')
    value: models.aws_apigatewayv2.MappingValueDef = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_apigatewayv2.ParameterMappingDefConfig]] = pydantic.Field(None)
    ...

class ParameterMappingDefAppendQueryStringParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='-\n')
    value: models.aws_apigatewayv2.MappingValueDef = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_apigatewayv2.ParameterMappingDefConfig]] = pydantic.Field(None)
    ...

class ParameterMappingDefCustomParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_apigatewayv2.ParameterMappingDefConfig]] = pydantic.Field(None)
    ...

class ParameterMappingDefFromObjectParams(pydantic.BaseModel):
    obj: typing.Mapping[str, models.aws_apigatewayv2.MappingValueDef] = pydantic.Field(..., description='-')
    ...

class ParameterMappingDefOverwriteHeaderParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='-\n')
    value: models.aws_apigatewayv2.MappingValueDef = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_apigatewayv2.ParameterMappingDefConfig]] = pydantic.Field(None)
    ...

class ParameterMappingDefOverwritePathParams(pydantic.BaseModel):
    value: models.aws_apigatewayv2.MappingValueDef = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_apigatewayv2.ParameterMappingDefConfig]] = pydantic.Field(None)
    ...

class ParameterMappingDefOverwriteQueryStringParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='-\n')
    value: models.aws_apigatewayv2.MappingValueDef = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_apigatewayv2.ParameterMappingDefConfig]] = pydantic.Field(None)
    ...

class ParameterMappingDefRemoveHeaderParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_apigatewayv2.ParameterMappingDefConfig]] = pydantic.Field(None)
    ...

class ParameterMappingDefRemoveQueryStringParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_apigatewayv2.ParameterMappingDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.PayloadFormatVersion
class PayloadFormatVersionDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['custom']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.PayloadFormatVersion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.PayloadFormatVersionDefConfig] = pydantic.Field(None)


class PayloadFormatVersionDefConfig(pydantic.BaseModel):
    custom: typing.Optional[list[models.aws_apigatewayv2.PayloadFormatVersionDefCustomParams]] = pydantic.Field(None, description="A custom payload version.\nTypically used if there is a version number that the CDK doesn't support yet")

class PayloadFormatVersionDefCustomParams(pydantic.BaseModel):
    version: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_apigatewayv2.PayloadFormatVersionDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketApiKeySelectionExpression
class WebSocketApiKeySelectionExpressionDef(BaseClass):
    custom_api_key_selector: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The expression used by API Gateway.')
    _init_params: typing.ClassVar[list[str]] = ['custom_api_key_selector']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.WebSocketApiKeySelectionExpression'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketNoneAuthorizer
class WebSocketNoneAuthorizerDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.WebSocketNoneAuthorizer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.WebSocketNoneAuthorizerDefConfig] = pydantic.Field(None)


class WebSocketNoneAuthorizerDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[models.aws_apigatewayv2.WebSocketNoneAuthorizerDefBindParams]] = pydantic.Field(None, description='Bind this authorizer to a specified WebSocket route.')

class WebSocketNoneAuthorizerDefBindParams(pydantic.BaseModel):
    route: typing.Union[models.aws_apigatewayv2.WebSocketRouteDef] = pydantic.Field(..., description='The route to which the authorizer is being bound.\n')
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The scope for any constructs created as part of the bind.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketRouteIntegration
class WebSocketRouteIntegrationDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.WebSocketRouteIntegration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.WebSocketRouteIntegrationDefConfig] = pydantic.Field(None)


class WebSocketRouteIntegrationDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[models.aws_apigatewayv2.WebSocketRouteIntegrationDefBindParams]] = pydantic.Field(None, description='Bind this integration to the route.')

class WebSocketRouteIntegrationDefBindParams(pydantic.BaseModel):
    route: typing.Union[models.aws_apigatewayv2.WebSocketRouteDef] = pydantic.Field(..., description='The route to which this is being bound.\n')
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='The current scope in which the bind is occurring. If the ``WebSocketRouteIntegration`` being bound creates additional constructs, this will be used as their parent scope.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.ApiMapping
class ApiMappingDef(BaseConstruct):
    api: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.HttpApiDef, models.aws_apigatewayv2.WebSocketApiDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Api to which this mapping is applied.\n')
    domain_name: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.DomainNameDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='custom domain name of the mapping target.\n')
    api_mapping_key: typing.Optional[str] = pydantic.Field(None, description='Api mapping key. The path where this stage should be mapped to on the domain Default: - undefined for the root path mapping.\n')
    stage: typing.Optional[typing.Union[models.aws_apigatewayv2.HttpStageDef, models.aws_apigatewayv2.WebSocketStageDef]] = pydantic.Field(None, description='stage for the ApiMapping resource required for WebSocket API defaults to default stage of an HTTP API. Default: - Default stage of the passed API for HTTP API, required for WebSocket API')
    _init_params: typing.ClassVar[list[str]] = ['api', 'domain_name', 'api_mapping_key', 'stage']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_api_mapping_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.ApiMapping'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_api_mapping_attributes']
    ...


    from_api_mapping_attributes: typing.Optional[models.aws_apigatewayv2.ApiMappingDefFromApiMappingAttributesParams] = pydantic.Field(None, description='import from API ID.')
    resource_config: typing.Optional[models.aws_apigatewayv2.ApiMappingDefConfig] = pydantic.Field(None)


class ApiMappingDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    domain_name_config: typing.Optional[models._interface_methods.AwsApigatewayv2IDomainNameDefConfig] = pydantic.Field(None)

class ApiMappingDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class ApiMappingDefFromApiMappingAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    api_mapping_id: str = pydantic.Field(..., description='The API mapping ID.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.DomainName
class DomainNameDef(BaseConstruct):
    domain_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The custom domain name.\n')
    mtls: typing.Union[models.aws_apigatewayv2.MTLSConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The mutual TLS authentication configuration for a custom domain name. Default: - mTLS is not configured.\n')
    certificate: typing.Union[_REQUIRED_INIT_PARAM, models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ACM certificate for this domain name. Certificate can be both ACM issued or imported.\n')
    certificate_name: typing.Optional[str] = pydantic.Field(None, description='The user-friendly name of the certificate that will be used by the endpoint for this domain name. Default: - No friendly certificate name\n')
    endpoint_type: typing.Optional[aws_cdk.aws_apigatewayv2.EndpointType] = pydantic.Field(None, description='The type of endpoint for this DomainName. Default: EndpointType.REGIONAL\n')
    ownership_certificate: typing.Optional[typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef]] = pydantic.Field(None, description='A public certificate issued by ACM to validate that you own a custom domain. This parameter is required only when you configure mutual TLS authentication and you specify an ACM imported or private CA certificate for ``certificate``. The ownership certificate validates that you have permissions to use the domain name. Default: - only required when configuring mTLS\n')
    security_policy: typing.Optional[aws_cdk.aws_apigatewayv2.SecurityPolicy] = pydantic.Field(None, description='The Transport Layer Security (TLS) version + cipher suite for this domain name. Default: SecurityPolicy.TLS_1_2')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'mtls', 'certificate', 'certificate_name', 'endpoint_type', 'ownership_certificate', 'security_policy']
    _method_names: typing.ClassVar[list[str]] = ['add_endpoint', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_domain_name_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.DomainName'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_domain_name_attributes']
    ...


    from_domain_name_attributes: typing.Optional[models.aws_apigatewayv2.DomainNameDefFromDomainNameAttributesParams] = pydantic.Field(None, description='Import from attributes.')
    resource_config: typing.Optional[models.aws_apigatewayv2.DomainNameDefConfig] = pydantic.Field(None)


class DomainNameDefConfig(pydantic.BaseModel):
    add_endpoint: typing.Optional[list[models.aws_apigatewayv2.DomainNameDefAddEndpointParams]] = pydantic.Field(None, description='Adds an endpoint to a domain name.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class DomainNameDefAddEndpointParams(pydantic.BaseModel):
    certificate: typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef] = pydantic.Field(..., description='The ACM certificate for this domain name. Certificate can be both ACM issued or imported.\n')
    certificate_name: typing.Optional[str] = pydantic.Field(None, description='The user-friendly name of the certificate that will be used by the endpoint for this domain name. Default: - No friendly certificate name\n')
    endpoint_type: typing.Optional[aws_cdk.aws_apigatewayv2.EndpointType] = pydantic.Field(None, description='The type of endpoint for this DomainName. Default: EndpointType.REGIONAL\n')
    ownership_certificate: typing.Optional[typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef]] = pydantic.Field(None, description='A public certificate issued by ACM to validate that you own a custom domain. This parameter is required only when you configure mutual TLS authentication and you specify an ACM imported or private CA certificate for ``certificate``. The ownership certificate validates that you have permissions to use the domain name. Default: - only required when configuring mTLS\n')
    security_policy: typing.Optional[aws_cdk.aws_apigatewayv2.SecurityPolicy] = pydantic.Field(None, description='The Transport Layer Security (TLS) version + cipher suite for this domain name. Default: SecurityPolicy.TLS_1_2')
    ...

class DomainNameDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class DomainNameDefFromDomainNameAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    name: str = pydantic.Field(..., description='domain name string.\n')
    regional_domain_name: str = pydantic.Field(..., description='The domain name associated with the regional endpoint for this custom domain name.\n')
    regional_hosted_zone_id: str = pydantic.Field(..., description='The region-specific Amazon Route 53 Hosted Zone ID of the regional endpoint.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.HttpApi
class HttpApiDef(BaseConstruct):
    api_name: typing.Optional[str] = pydantic.Field(None, description='Name for the HTTP API resource. Default: - id of the HttpApi construct.\n')
    cors_preflight: typing.Union[models.aws_apigatewayv2.CorsPreflightOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies a CORS configuration for an API. Default: - CORS disabled.\n')
    create_default_stage: typing.Optional[bool] = pydantic.Field(None, description='Whether a default stage and deployment should be automatically created. Default: true\n')
    default_authorization_scopes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Default OIDC scopes attached to all routes in the gateway, unless explicitly configured on the route. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. Default: - no default authorization scopes\n')
    default_authorizer: typing.Optional[typing.Union[models.aws_apigatewayv2.HttpNoneAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpIamAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpJwtAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpLambdaAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpUserPoolAuthorizerDef]] = pydantic.Field(None, description='Default Authorizer applied to all routes in the gateway. Default: - no default authorizer\n')
    default_domain_mapping: typing.Union[models.aws_apigatewayv2.DomainMappingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configure a custom domain with the API mapping resource to the HTTP API. Default: - no default domain mapping configured. meaningless if ``createDefaultStage`` is ``false``.\n')
    default_integration: typing.Optional[models.aws_apigatewayv2.HttpRouteIntegrationDef] = pydantic.Field(None, description='An integration that will be configured on the catch-all route ($default). Default: - none\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the API. Default: - none\n')
    disable_execute_api_endpoint: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether clients can invoke your API using the default endpoint. By default, clients can invoke your API with the default ``https://{api_id}.execute-api.{region}.amazonaws.com`` endpoint. Enable this if you would like clients to use your custom domain name. Default: false execute-api endpoint enabled.')
    _init_params: typing.ClassVar[list[str]] = ['api_name', 'cors_preflight', 'create_default_stage', 'default_authorization_scopes', 'default_authorizer', 'default_domain_mapping', 'default_integration', 'description', 'disable_execute_api_endpoint']
    _method_names: typing.ClassVar[list[str]] = ['add_routes', 'add_stage', 'add_vpc_link', 'apply_removal_policy', 'arn_for_execute_api', 'metric', 'metric_client_error', 'metric_count', 'metric_data_processed', 'metric_integration_latency', 'metric_latency', 'metric_server_error']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_http_api_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.HttpApi'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_http_api_attributes']
    ...


    from_http_api_attributes: typing.Optional[models.aws_apigatewayv2.HttpApiDefFromHttpApiAttributesParams] = pydantic.Field(None, description='Import an existing HTTP API into this CDK app.')
    resource_config: typing.Optional[models.aws_apigatewayv2.HttpApiDefConfig] = pydantic.Field(None)


class HttpApiDefConfig(pydantic.BaseModel):
    add_routes: typing.Optional[list[models.aws_apigatewayv2.HttpApiDefAddRoutesParams]] = pydantic.Field(None, description='Add multiple routes that uses the same configuration.\nThe routes all go to the same path, but for different\nmethods.')
    add_stage: typing.Optional[list[models.aws_apigatewayv2.HttpApiDefAddStageParams]] = pydantic.Field(None, description='Add a new stage.')
    add_vpc_link: typing.Optional[list[models.aws_apigatewayv2.HttpApiDefAddVpcLinkParams]] = pydantic.Field(None, description='Add a new VpcLink.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    arn_for_execute_api: typing.Optional[list[models.aws_apigatewayv2.HttpApiDefArnForExecuteApiParams]] = pydantic.Field(None, description='Get the "execute-api" ARN.\nWhen \'ANY\' is passed to the method, an ARN with the method set to \'*\' is obtained.')
    metric: typing.Optional[list[models.aws_apigatewayv2.HttpApiDefMetricParams]] = pydantic.Field(None, description='Return the given named metric for this Api Gateway.')
    metric_client_error: typing.Optional[list[models.aws_apigatewayv2.HttpApiDefMetricClientErrorParams]] = pydantic.Field(None, description='Metric for the number of client-side errors captured in a given period.')
    metric_count: typing.Optional[list[models.aws_apigatewayv2.HttpApiDefMetricCountParams]] = pydantic.Field(None, description='Metric for the total number API requests in a given period.')
    metric_data_processed: typing.Optional[list[models.aws_apigatewayv2.HttpApiDefMetricDataProcessedParams]] = pydantic.Field(None, description='Metric for the amount of data processed in bytes.')
    metric_integration_latency: typing.Optional[list[models.aws_apigatewayv2.HttpApiDefMetricIntegrationLatencyParams]] = pydantic.Field(None, description='Metric for the time between when API Gateway relays a request to the backend and when it receives a response from the backend.')
    metric_latency: typing.Optional[list[models.aws_apigatewayv2.HttpApiDefMetricLatencyParams]] = pydantic.Field(None, description='The time between when API Gateway receives a request from a client and when it returns a response to the client.\nThe latency includes the integration latency and other API Gateway overhead.')
    metric_server_error: typing.Optional[list[models.aws_apigatewayv2.HttpApiDefMetricServerErrorParams]] = pydantic.Field(None, description='Metric for the number of server-side errors captured in a given period.')

class HttpApiDefAddRoutesParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path at which all of these routes are configured.\n')
    authorization_scopes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of OIDC scopes to include in the authorization. These scopes will override the default authorization scopes on the gateway. Set to [] to remove default scopes Default: - uses defaultAuthorizationScopes if configured on the API, otherwise none.\n')
    authorizer: typing.Optional[typing.Union[models.aws_apigatewayv2.HttpNoneAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpIamAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpJwtAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpLambdaAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpUserPoolAuthorizerDef]] = pydantic.Field(None, description='Authorizer to be associated to these routes. Use NoneAuthorizer to remove the default authorizer for the api Default: - uses the default authorizer if one is specified on the HttpApi\n')
    methods: typing.Optional[typing.Sequence[aws_cdk.aws_apigatewayv2.HttpMethod]] = pydantic.Field(None, description='The HTTP methods to be configured. Default: HttpMethod.ANY\n')
    integration: models.aws_apigatewayv2.HttpRouteIntegrationDef = pydantic.Field(..., description='The integration to be configured on this route.')
    ...

class HttpApiDefAddStageParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    stage_name: typing.Optional[str] = pydantic.Field(None, description="The name of the stage. See ``StageName`` class for more details. Default: '$default' the default stage of the API. This stage will have the URL at the root of the API endpoint.\n")
    auto_deploy: typing.Optional[bool] = pydantic.Field(None, description='Whether updates to an API automatically trigger a new deployment. Default: false\n')
    domain_mapping: typing.Union[models.aws_apigatewayv2.DomainMappingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for custom domain and api mapping. Default: - no custom domain and api mapping configuration\n')
    throttle: typing.Union[models.aws_apigatewayv2.ThrottleSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Throttle settings for the routes of this stage. Default: - no throttling configuration')
    return_config: typing.Optional[list[models.aws_apigatewayv2.HttpStageDefConfig]] = pydantic.Field(None)
    ...

class HttpApiDefAddVpcLinkParams(pydantic.BaseModel):
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='The VPC in which the private resources reside.\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='A list of security groups for the VPC link. Default: - no security groups. Use ``addSecurityGroups`` to add security groups\n')
    subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A list of subnets for the VPC link. Default: - private subnets of the provided VPC. Use ``addSubnets`` to add more subnets\n')
    vpc_link_name: typing.Optional[str] = pydantic.Field(None, description='The name used to label and identify the VPC link. Default: - automatically generated name')
    return_config: typing.Optional[list[models.aws_apigatewayv2.VpcLinkDefConfig]] = pydantic.Field(None)
    ...

class HttpApiDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class HttpApiDefArnForExecuteApiParams(pydantic.BaseModel):
    method: typing.Optional[str] = pydantic.Field(None, description='-\n')
    path: typing.Optional[str] = pydantic.Field(None, description='-\n')
    stage: typing.Optional[str] = pydantic.Field(None, description='-')
    ...

class HttpApiDefFromHttpApiAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    http_api_id: str = pydantic.Field(..., description='The identifier of the HttpApi.\n')
    api_endpoint: typing.Optional[str] = pydantic.Field(None, description='The endpoint URL of the HttpApi. Default: - throws an error if apiEndpoint is accessed.')
    ...

class HttpApiDefMetricParams(pydantic.BaseModel):
    metric_name: str = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class HttpApiDefMetricClientErrorParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class HttpApiDefMetricCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class HttpApiDefMetricDataProcessedParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class HttpApiDefMetricIntegrationLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class HttpApiDefMetricLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class HttpApiDefMetricServerErrorParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.HttpAuthorizer
class HttpAuthorizerDef(BaseConstruct):
    http_api: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.HttpApiDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='HTTP Api to attach the authorizer to.\n')
    identity_source: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identity source for which authorization is requested.\n')
    type: typing.Union[aws_cdk.aws_apigatewayv2.HttpAuthorizerType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of authorizer.\n')
    authorizer_name: typing.Optional[str] = pydantic.Field(None, description='Name of the authorizer. Default: - id of the HttpAuthorizer construct.\n')
    authorizer_uri: typing.Optional[str] = pydantic.Field(None, description="The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI. Default: - required for Request authorizer types\n")
    enable_simple_responses: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Default: - The lambda authorizer must return an IAM policy as its response\n')
    jwt_audience: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of the intended recipients of the JWT. A valid JWT must provide an aud that matches at least one entry in this list. Default: - required for JWT authorizer typess.\n')
    jwt_issuer: typing.Optional[str] = pydantic.Field(None, description='The base domain of the identity provider that issues JWT. Default: - required for JWT authorizer types.\n')
    payload_format_version: typing.Optional[aws_cdk.aws_apigatewayv2.AuthorizerPayloadVersion] = pydantic.Field(None, description='Specifies the format of the payload sent to an HTTP API Lambda authorizer. Default: AuthorizerPayloadVersion.VERSION_2_0 if the authorizer type is HttpAuthorizerType.LAMBDA\n')
    results_cache_ttl: typing.Optional[models.DurationDef] = pydantic.Field(None, description='How long APIGateway should cache the results. Max 1 hour. Default: - API Gateway will not cache authorizer responses')
    _init_params: typing.ClassVar[list[str]] = ['http_api', 'identity_source', 'type', 'authorizer_name', 'authorizer_uri', 'enable_simple_responses', 'jwt_audience', 'jwt_issuer', 'payload_format_version', 'results_cache_ttl']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_http_authorizer_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.HttpAuthorizer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_http_authorizer_attributes']
    ...


    from_http_authorizer_attributes: typing.Optional[models.aws_apigatewayv2.HttpAuthorizerDefFromHttpAuthorizerAttributesParams] = pydantic.Field(None, description='Import an existing HTTP Authorizer into this CDK app.')
    resource_config: typing.Optional[models.aws_apigatewayv2.HttpAuthorizerDefConfig] = pydantic.Field(None)


class HttpAuthorizerDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class HttpAuthorizerDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class HttpAuthorizerDefFromHttpAuthorizerAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    authorizer_id: str = pydantic.Field(..., description='Id of the Authorizer.\n')
    authorizer_type: str = pydantic.Field(..., description='Type of authorizer. Possible values are: - JWT - JSON Web Token Authorizer - CUSTOM - Lambda Authorizer - NONE - No Authorization')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.HttpIntegration
class HttpIntegrationDef(BaseConstruct):
    http_api: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.HttpApiDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The HTTP API to which this integration should be bound.\n')
    integration_type: typing.Union[aws_cdk.aws_apigatewayv2.HttpIntegrationType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Integration type.\n')
    connection_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the VPC link for a private integration. Supported only for HTTP APIs. Default: - undefined\n')
    connection_type: typing.Optional[aws_cdk.aws_apigatewayv2.HttpConnectionType] = pydantic.Field(None, description='The type of the network connection to the integration endpoint. Default: HttpConnectionType.INTERNET\n')
    credentials: typing.Optional[models.aws_apigatewayv2.IntegrationCredentialsDef] = pydantic.Field(None, description='The credentials with which to invoke the integration. Default: - no credentials, use resource-based permissions on supported AWS services\n')
    integration_subtype: typing.Optional[aws_cdk.aws_apigatewayv2.HttpIntegrationSubtype] = pydantic.Field(None, description='Integration subtype. Used for AWS Service integrations, specifies the target of the integration. Default: - none, required if no ``integrationUri`` is defined.\n')
    integration_uri: typing.Optional[str] = pydantic.Field(None, description='Integration URI. This will be the function ARN in the case of ``HttpIntegrationType.AWS_PROXY``, or HTTP URL in the case of ``HttpIntegrationType.HTTP_PROXY``. Default: - none, required if no ``integrationSubtype`` is defined.\n')
    method: typing.Optional[aws_cdk.aws_apigatewayv2.HttpMethod] = pydantic.Field(None, description='The HTTP method to use when calling the underlying HTTP proxy. Default: - none. required if the integration type is ``HttpIntegrationType.HTTP_PROXY``.\n')
    parameter_mapping: typing.Optional[models.aws_apigatewayv2.ParameterMappingDef] = pydantic.Field(None, description='Specifies how to transform HTTP requests before sending them to the backend. Default: undefined requests are sent to the backend unmodified\n')
    payload_format_version: typing.Optional[models.aws_apigatewayv2.PayloadFormatVersionDef] = pydantic.Field(None, description='The version of the payload format. Default: - defaults to latest in the case of HttpIntegrationType.AWS_PROXY`, irrelevant otherwise.\n')
    secure_server_name: typing.Optional[str] = pydantic.Field(None, description='Specifies the TLS configuration for a private integration. Default: undefined private integration traffic will use HTTP protocol\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum amount of time an integration will run before it returns without a response. Must be between 50 milliseconds and 29 seconds. Default: Duration.seconds(29)')
    _init_params: typing.ClassVar[list[str]] = ['http_api', 'integration_type', 'connection_id', 'connection_type', 'credentials', 'integration_subtype', 'integration_uri', 'method', 'parameter_mapping', 'payload_format_version', 'secure_server_name', 'timeout']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.HttpIntegration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.HttpIntegrationDefConfig] = pydantic.Field(None)


class HttpIntegrationDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    http_api_config: typing.Optional[models._interface_methods.AwsApigatewayv2IHttpApiDefConfig] = pydantic.Field(None)

class HttpIntegrationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.HttpRoute
class HttpRouteDef(BaseConstruct):
    http_api: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.HttpApiDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='the API the route is associated with.\n')
    route_key: typing.Union[models.aws_apigatewayv2.HttpRouteKeyDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The key to this route. This is a combination of an HTTP method and an HTTP path.\n')
    authorization_scopes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of OIDC scopes to include in the authorization. These scopes will be merged with the scopes from the attached authorizer Default: - no additional authorization scopes\n')
    authorizer: typing.Optional[typing.Union[models.aws_apigatewayv2.HttpNoneAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpIamAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpJwtAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpLambdaAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpUserPoolAuthorizerDef]] = pydantic.Field(None, description='Authorizer for a WebSocket API or an HTTP API. Default: - No authorizer\n')
    integration: typing.Union[models.aws_apigatewayv2.HttpRouteIntegrationDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The integration to be configured on this route.')
    _init_params: typing.ClassVar[list[str]] = ['http_api', 'route_key', 'authorization_scopes', 'authorizer', 'integration']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'grant_invoke']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.HttpRoute'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.HttpRouteDefConfig] = pydantic.Field(None)


class HttpRouteDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    grant_invoke: typing.Optional[list[models.aws_apigatewayv2.HttpRouteDefGrantInvokeParams]] = pydantic.Field(None, description='Grant access to invoke the route.\nThis method requires that the authorizer of the route is undefined or is\nan ``HttpIamAuthorizer``.')
    http_api_config: typing.Optional[models._interface_methods.AwsApigatewayv2IHttpApiDefConfig] = pydantic.Field(None)

class HttpRouteDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class HttpRouteDefGrantInvokeParams(pydantic.BaseModel):
    grantee: models.AnyResource = pydantic.Field(..., description='-\n')
    http_methods: typing.Optional[typing.Sequence[aws_cdk.aws_apigatewayv2.HttpMethod]] = pydantic.Field(None, description='The HTTP methods to allow. Default: - the HttpMethod of the route')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.HttpStage
class HttpStageDef(BaseConstruct):
    http_api: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.HttpApiDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The HTTP API to which this stage is associated.\n')
    stage_name: typing.Optional[str] = pydantic.Field(None, description="The name of the stage. See ``StageName`` class for more details. Default: '$default' the default stage of the API. This stage will have the URL at the root of the API endpoint.\n")
    auto_deploy: typing.Optional[bool] = pydantic.Field(None, description='Whether updates to an API automatically trigger a new deployment. Default: false\n')
    domain_mapping: typing.Union[models.aws_apigatewayv2.DomainMappingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for custom domain and api mapping. Default: - no custom domain and api mapping configuration\n')
    throttle: typing.Union[models.aws_apigatewayv2.ThrottleSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Throttle settings for the routes of this stage. Default: - no throttling configuration')
    _init_params: typing.ClassVar[list[str]] = ['http_api', 'stage_name', 'auto_deploy', 'domain_mapping', 'throttle']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'metric', 'metric_client_error', 'metric_count', 'metric_data_processed', 'metric_integration_latency', 'metric_latency', 'metric_server_error']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_http_stage_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.HttpStage'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_http_stage_attributes']
    ...


    from_http_stage_attributes: typing.Optional[models.aws_apigatewayv2.HttpStageDefFromHttpStageAttributesParams] = pydantic.Field(None, description='Import an existing stage into this CDK app.')
    resource_config: typing.Optional[models.aws_apigatewayv2.HttpStageDefConfig] = pydantic.Field(None)


class HttpStageDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    metric: typing.Optional[list[models.aws_apigatewayv2.HttpStageDefMetricParams]] = pydantic.Field(None, description='Return the given named metric for this HTTP Api Gateway Stage.')
    metric_client_error: typing.Optional[list[models.aws_apigatewayv2.HttpStageDefMetricClientErrorParams]] = pydantic.Field(None, description='Metric for the number of client-side errors captured in a given period.')
    metric_count: typing.Optional[list[models.aws_apigatewayv2.HttpStageDefMetricCountParams]] = pydantic.Field(None, description='Metric for the total number API requests in a given period.')
    metric_data_processed: typing.Optional[list[models.aws_apigatewayv2.HttpStageDefMetricDataProcessedParams]] = pydantic.Field(None, description='Metric for the amount of data processed in bytes.')
    metric_integration_latency: typing.Optional[list[models.aws_apigatewayv2.HttpStageDefMetricIntegrationLatencyParams]] = pydantic.Field(None, description='Metric for the time between when API Gateway relays a request to the backend and when it receives a response from the backend.')
    metric_latency: typing.Optional[list[models.aws_apigatewayv2.HttpStageDefMetricLatencyParams]] = pydantic.Field(None, description='The time between when API Gateway receives a request from a client and when it returns a response to the client.\nThe latency includes the integration latency and other API Gateway overhead.')
    metric_server_error: typing.Optional[list[models.aws_apigatewayv2.HttpStageDefMetricServerErrorParams]] = pydantic.Field(None, description='Metric for the number of server-side errors captured in a given period.')
    api_config: typing.Optional[models._interface_methods.AwsApigatewayv2IHttpApiDefConfig] = pydantic.Field(None)

class HttpStageDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class HttpStageDefFromHttpStageAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    api: typing.Union[models.aws_apigatewayv2.HttpApiDef] = pydantic.Field(..., description='The API to which this stage is associated.\n')
    stage_name: str = pydantic.Field(..., description='The name of the stage.')
    ...

class HttpStageDefMetricParams(pydantic.BaseModel):
    metric_name: str = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class HttpStageDefMetricClientErrorParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class HttpStageDefMetricCountParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class HttpStageDefMetricDataProcessedParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class HttpStageDefMetricIntegrationLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class HttpStageDefMetricLatencyParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class HttpStageDefMetricServerErrorParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.VpcLink
class VpcLinkDef(BaseConstruct):
    vpc: typing.Union[_REQUIRED_INIT_PARAM, models.aws_ec2.VpcDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The VPC in which the private resources reside.\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='A list of security groups for the VPC link. Default: - no security groups. Use ``addSecurityGroups`` to add security groups\n')
    subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A list of subnets for the VPC link. Default: - private subnets of the provided VPC. Use ``addSubnets`` to add more subnets\n')
    vpc_link_name: typing.Optional[str] = pydantic.Field(None, description='The name used to label and identify the VPC link. Default: - automatically generated name')
    _init_params: typing.ClassVar[list[str]] = ['vpc', 'security_groups', 'subnets', 'vpc_link_name']
    _method_names: typing.ClassVar[list[str]] = ['add_security_groups', 'add_subnets', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_vpc_link_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.VpcLink'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_vpc_link_attributes']
    ...


    from_vpc_link_attributes: typing.Optional[models.aws_apigatewayv2.VpcLinkDefFromVpcLinkAttributesParams] = pydantic.Field(None, description='Import a VPC Link by specifying its attributes.')
    resource_config: typing.Optional[models.aws_apigatewayv2.VpcLinkDefConfig] = pydantic.Field(None)


class VpcLinkDefConfig(pydantic.BaseModel):
    add_security_groups: typing.Optional[list[models.aws_apigatewayv2.VpcLinkDefAddSecurityGroupsParams]] = pydantic.Field(None, description='Adds the provided security groups to the vpc link.')
    add_subnets: typing.Optional[list[models.aws_apigatewayv2.VpcLinkDefAddSubnetsParams]] = pydantic.Field(None, description='Adds the provided subnets to the vpc link.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    vpc_config: typing.Optional[models._interface_methods.AwsEc2IVpcDefConfig] = pydantic.Field(None)

class VpcLinkDefAddSecurityGroupsParams(pydantic.BaseModel):
    groups: list[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(...)
    ...

class VpcLinkDefAddSubnetsParams(pydantic.BaseModel):
    subnets: list[typing.Union[models.aws_ec2.PrivateSubnetDef, models.aws_ec2.PublicSubnetDef, models.aws_ec2.SubnetDef]] = pydantic.Field(...)
    ...

class VpcLinkDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class VpcLinkDefFromVpcLinkAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='The VPC to which this VPC link is associated with.\n')
    vpc_link_id: str = pydantic.Field(..., description='The VPC Link id.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketApi
class WebSocketApiDef(BaseConstruct):
    api_key_selection_expression: typing.Optional[models.aws_apigatewayv2.WebSocketApiKeySelectionExpressionDef] = pydantic.Field(None, description='An API key selection expression. Providing this option will require an API Key be provided to access the API. Default: - Key is not required to access these APIs\n')
    api_name: typing.Optional[str] = pydantic.Field(None, description='Name for the WebSocket API resource. Default: - id of the WebSocketApi construct.\n')
    connect_route_options: typing.Union[models.aws_apigatewayv2.WebSocketRouteOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Options to configure a '$connect' route. Default: - no '$connect' route configured\n")
    default_route_options: typing.Union[models.aws_apigatewayv2.WebSocketRouteOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Options to configure a '$default' route. Default: - no '$default' route configured\n")
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the API. Default: - none\n')
    disconnect_route_options: typing.Union[models.aws_apigatewayv2.WebSocketRouteOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Options to configure a '$disconnect' route. Default: - no '$disconnect' route configured\n")
    route_selection_expression: typing.Optional[str] = pydantic.Field(None, description="The route selection expression for the API. Default: '$request.body.action'")
    _init_params: typing.ClassVar[list[str]] = ['api_key_selection_expression', 'api_name', 'connect_route_options', 'default_route_options', 'description', 'disconnect_route_options', 'route_selection_expression']
    _method_names: typing.ClassVar[list[str]] = ['add_route', 'apply_removal_policy', 'arn_for_execute_api', 'grant_manage_connections', 'metric']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_web_socket_api_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.WebSocketApi'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_web_socket_api_attributes']
    ...


    from_web_socket_api_attributes: typing.Optional[models.aws_apigatewayv2.WebSocketApiDefFromWebSocketApiAttributesParams] = pydantic.Field(None, description='Import an existing WebSocket API into this CDK app.')
    resource_config: typing.Optional[models.aws_apigatewayv2.WebSocketApiDefConfig] = pydantic.Field(None)


class WebSocketApiDefConfig(pydantic.BaseModel):
    add_route: typing.Optional[list[models.aws_apigatewayv2.WebSocketApiDefAddRouteParams]] = pydantic.Field(None, description='Add a new route.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    arn_for_execute_api: typing.Optional[list[models.aws_apigatewayv2.WebSocketApiDefArnForExecuteApiParams]] = pydantic.Field(None, description='Get the "execute-api" ARN.\nWhen \'ANY\' is passed to the method, an ARN with the method set to \'*\' is obtained.')
    grant_manage_connections: typing.Optional[list[models.aws_apigatewayv2.WebSocketApiDefGrantManageConnectionsParams]] = pydantic.Field(None, description='Grant access to the API Gateway management API for this WebSocket API to an IAM principal (Role/Group/User).')
    metric: typing.Optional[list[models.aws_apigatewayv2.WebSocketApiDefMetricParams]] = pydantic.Field(None, description='Return the given named metric for this Api Gateway.')

class WebSocketApiDefAddRouteParams(pydantic.BaseModel):
    route_key: str = pydantic.Field(..., description='-\n')
    integration: models.aws_apigatewayv2.WebSocketRouteIntegrationDef = pydantic.Field(..., description='The integration to be configured on this route.\n')
    authorizer: typing.Optional[typing.Union[models.aws_apigatewayv2.WebSocketNoneAuthorizerDef, models.aws_apigatewayv2_authorizers.WebSocketIamAuthorizerDef, models.aws_apigatewayv2_authorizers.WebSocketLambdaAuthorizerDef]] = pydantic.Field(None, description='The authorize to this route. You can only set authorizer to a $connect route. Default: - No Authorizer\n')
    return_response: typing.Optional[bool] = pydantic.Field(None, description='Should the route send a response to the client. Default: false')
    return_config: typing.Optional[list[models.aws_apigatewayv2.WebSocketRouteDefConfig]] = pydantic.Field(None)
    ...

class WebSocketApiDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class WebSocketApiDefArnForExecuteApiParams(pydantic.BaseModel):
    method: typing.Optional[str] = pydantic.Field(None, description='-\n')
    path: typing.Optional[str] = pydantic.Field(None, description='-\n')
    stage: typing.Optional[str] = pydantic.Field(None, description="-\n\n:default:\n\n- The default behavior applies when no specific method, path, or stage is provided.\nIn this case, the ARN will cover all methods, all resources, and all stages of this API.\nSpecifically, if 'method' is not specified, it defaults to '*', representing all methods.\nIf 'path' is not specified, it defaults to '/*', representing all paths.\nIf 'stage' is not specified, it also defaults to '*', representing all stages.\n")
    ...

class WebSocketApiDefFromWebSocketApiAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    web_socket_id: str = pydantic.Field(..., description='The identifier of the WebSocketApi.\n')
    api_endpoint: typing.Optional[str] = pydantic.Field(None, description='The endpoint URL of the WebSocketApi. Default: - throw san error if apiEndpoint is accessed.')
    ...

class WebSocketApiDefGrantManageConnectionsParams(pydantic.BaseModel):
    identity: models.AnyResource = pydantic.Field(..., description='The principal.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class WebSocketApiDefMetricParams(pydantic.BaseModel):
    metric_name: str = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketAuthorizer
class WebSocketAuthorizerDef(BaseConstruct):
    identity_source: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identity source for which authorization is requested.\n')
    type: typing.Union[aws_cdk.aws_apigatewayv2.WebSocketAuthorizerType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of authorizer.\n')
    web_socket_api: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.WebSocketApiDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='WebSocket Api to attach the authorizer to.\n')
    authorizer_name: typing.Optional[str] = pydantic.Field(None, description='Name of the authorizer. Default: - id of the WebSocketAuthorizer construct.\n')
    authorizer_uri: typing.Optional[str] = pydantic.Field(None, description="The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI. Default: - required for Request authorizer types")
    _init_params: typing.ClassVar[list[str]] = ['identity_source', 'type', 'web_socket_api', 'authorizer_name', 'authorizer_uri']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_web_socket_authorizer_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.WebSocketAuthorizer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_web_socket_authorizer_attributes']
    ...


    from_web_socket_authorizer_attributes: typing.Optional[models.aws_apigatewayv2.WebSocketAuthorizerDefFromWebSocketAuthorizerAttributesParams] = pydantic.Field(None, description='Import an existing WebSocket Authorizer into this CDK app.')
    resource_config: typing.Optional[models.aws_apigatewayv2.WebSocketAuthorizerDefConfig] = pydantic.Field(None)


class WebSocketAuthorizerDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class WebSocketAuthorizerDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class WebSocketAuthorizerDefFromWebSocketAuthorizerAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    authorizer_id: str = pydantic.Field(..., description='Id of the Authorizer.\n')
    authorizer_type: str = pydantic.Field(..., description='Type of authorizer. Possible values are: - CUSTOM - Lambda Authorizer - NONE - No Authorization')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketIntegration
class WebSocketIntegrationDef(BaseConstruct):
    integration_type: typing.Union[aws_cdk.aws_apigatewayv2.WebSocketIntegrationType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Integration type.\n')
    integration_uri: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Integration URI.\n')
    web_socket_api: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.WebSocketApiDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The WebSocket API to which this integration should be bound.\n')
    content_handling: typing.Optional[aws_cdk.aws_apigatewayv2.ContentHandling] = pydantic.Field(None, description='Specifies how to handle response payload content type conversions. Default: - The response payload will be passed through from the integration response to the route response or method response without modification.\n')
    credentials_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='Specifies the IAM role required for the integration. Default: - No IAM role required.\n')
    integration_method: typing.Optional[str] = pydantic.Field(None, description="Specifies the integration's HTTP method type. Default: - No HTTP method required.\n")
    passthrough_behavior: typing.Optional[aws_cdk.aws_apigatewayv2.PassthroughBehavior] = pydantic.Field(None, description='Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Default: - No passthrough behavior required.\n')
    request_parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The request parameters that API Gateway sends with the backend request. Specify request parameters as key-value pairs (string-to-string mappings), with a destination as the key and a source as the value. Default: - No request parameters required.\n')
    request_templates: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='A map of Apache Velocity templates that are applied on the request payload. Example:: { "application/json": "{ \\"statusCode\\": 200 }" } Default: - No request templates required.\n')
    template_selection_expression: typing.Optional[str] = pydantic.Field(None, description='The template selection expression for the integration. Default: - No template selection expression required.\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum amount of time an integration will run before it returns without a response. Must be between 50 milliseconds and 29 seconds. Default: Duration.seconds(29)')
    _init_params: typing.ClassVar[list[str]] = ['integration_type', 'integration_uri', 'web_socket_api', 'content_handling', 'credentials_role', 'integration_method', 'passthrough_behavior', 'request_parameters', 'request_templates', 'template_selection_expression', 'timeout']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.WebSocketIntegration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.WebSocketIntegrationDefConfig] = pydantic.Field(None)


class WebSocketIntegrationDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    web_socket_api_config: typing.Optional[models._interface_methods.AwsApigatewayv2IWebSocketApiDefConfig] = pydantic.Field(None)

class WebSocketIntegrationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketRoute
class WebSocketRouteDef(BaseConstruct):
    route_key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The key to this route.\n')
    web_socket_api: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.WebSocketApiDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API the route is associated with.\n')
    api_key_required: typing.Optional[bool] = pydantic.Field(None, description='Whether the route requires an API Key to be provided. Default: false\n')
    integration: typing.Union[models.aws_apigatewayv2.WebSocketRouteIntegrationDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The integration to be configured on this route.\n')
    authorizer: typing.Optional[typing.Union[models.aws_apigatewayv2.WebSocketNoneAuthorizerDef, models.aws_apigatewayv2_authorizers.WebSocketIamAuthorizerDef, models.aws_apigatewayv2_authorizers.WebSocketLambdaAuthorizerDef]] = pydantic.Field(None, description='The authorize to this route. You can only set authorizer to a $connect route. Default: - No Authorizer\n')
    return_response: typing.Optional[bool] = pydantic.Field(None, description='Should the route send a response to the client. Default: false')
    _init_params: typing.ClassVar[list[str]] = ['route_key', 'web_socket_api', 'api_key_required', 'integration', 'authorizer', 'return_response']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.WebSocketRoute'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.WebSocketRouteDefConfig] = pydantic.Field(None)


class WebSocketRouteDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    web_socket_api_config: typing.Optional[models._interface_methods.AwsApigatewayv2IWebSocketApiDefConfig] = pydantic.Field(None)

class WebSocketRouteDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketStage
class WebSocketStageDef(BaseConstruct):
    stage_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the stage.\n')
    web_socket_api: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.WebSocketApiDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The WebSocket API to which this stage is associated.\n')
    auto_deploy: typing.Optional[bool] = pydantic.Field(None, description='Whether updates to an API automatically trigger a new deployment. Default: false\n')
    domain_mapping: typing.Union[models.aws_apigatewayv2.DomainMappingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for custom domain and api mapping. Default: - no custom domain and api mapping configuration\n')
    throttle: typing.Union[models.aws_apigatewayv2.ThrottleSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Throttle settings for the routes of this stage. Default: - no throttling configuration')
    _init_params: typing.ClassVar[list[str]] = ['stage_name', 'web_socket_api', 'auto_deploy', 'domain_mapping', 'throttle']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'grant_management_api_access', 'metric']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_web_socket_stage_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.WebSocketStage'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_web_socket_stage_attributes']
    ...


    from_web_socket_stage_attributes: typing.Optional[models.aws_apigatewayv2.WebSocketStageDefFromWebSocketStageAttributesParams] = pydantic.Field(None, description='Import an existing stage into this CDK app.')
    resource_config: typing.Optional[models.aws_apigatewayv2.WebSocketStageDefConfig] = pydantic.Field(None)


class WebSocketStageDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    grant_management_api_access: typing.Optional[list[models.aws_apigatewayv2.WebSocketStageDefGrantManagementApiAccessParams]] = pydantic.Field(None, description='Grant access to the API Gateway management API for this WebSocket API Stage to an IAM principal (Role/Group/User).')
    metric: typing.Optional[list[models.aws_apigatewayv2.WebSocketStageDefMetricParams]] = pydantic.Field(None, description='Return the given named metric for this HTTP Api Gateway Stage.')
    api_config: typing.Optional[models._interface_methods.AwsApigatewayv2IWebSocketApiDefConfig] = pydantic.Field(None)

class WebSocketStageDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class WebSocketStageDefFromWebSocketStageAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    api: typing.Union[models.aws_apigatewayv2.WebSocketApiDef] = pydantic.Field(..., description='The API to which this stage is associated.\n')
    stage_name: str = pydantic.Field(..., description='The name of the stage.')
    ...

class WebSocketStageDefGrantManagementApiAccessParams(pydantic.BaseModel):
    identity: models.AnyResource = pydantic.Field(..., description='The principal.')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class WebSocketStageDefMetricParams(pydantic.BaseModel):
    metric_name: str = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.AddRoutesOptions
class AddRoutesOptionsDef(BaseStruct):
    integration: typing.Union[models.aws_apigatewayv2.HttpRouteIntegrationDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The integration to be configured on this route.\n')
    path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The path at which all of these routes are configured.\n')
    authorization_scopes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of OIDC scopes to include in the authorization. These scopes will override the default authorization scopes on the gateway. Set to [] to remove default scopes Default: - uses defaultAuthorizationScopes if configured on the API, otherwise none.\n')
    authorizer: typing.Optional[typing.Union[models.aws_apigatewayv2.HttpNoneAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpIamAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpJwtAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpLambdaAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpUserPoolAuthorizerDef]] = pydantic.Field(None, description='Authorizer to be associated to these routes. Use NoneAuthorizer to remove the default authorizer for the api Default: - uses the default authorizer if one is specified on the HttpApi\n')
    methods: typing.Optional[typing.Sequence[aws_cdk.aws_apigatewayv2.HttpMethod]] = pydantic.Field(None, description='The HTTP methods to be configured. Default: HttpMethod.ANY\n\n:exampleMetadata: infused\n\nExample::\n\n    from aws_cdk.aws_apigatewayv2_integrations import HttpUrlIntegration, HttpLambdaIntegration\n\n    # book_store_default_fn: lambda.Function\n\n\n    get_books_integration = HttpUrlIntegration("GetBooksIntegration", "https://get-books-proxy.example.com")\n    book_store_default_integration = HttpLambdaIntegration("BooksIntegration", book_store_default_fn)\n\n    http_api = apigwv2.HttpApi(self, "HttpApi")\n\n    http_api.add_routes(\n        path="/books",\n        methods=[apigwv2.HttpMethod.GET],\n        integration=get_books_integration\n    )\n    http_api.add_routes(\n        path="/books",\n        methods=[apigwv2.HttpMethod.ANY],\n        integration=book_store_default_integration\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['integration', 'path', 'authorization_scopes', 'authorizer', 'methods']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.AddRoutesOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.AddRoutesOptionsDefConfig] = pydantic.Field(None)


class AddRoutesOptionsDefConfig(pydantic.BaseModel):
    integration_config: typing.Optional[models.aws_apigatewayv2.HttpRouteIntegrationDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigatewayv2.ApiMappingAttributes
class ApiMappingAttributesDef(BaseStruct):
    api_mapping_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API mapping ID.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    api_mapping_attributes = apigatewayv2.ApiMappingAttributes(\n        api_mapping_id="apiMappingId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['api_mapping_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.ApiMappingAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.ApiMappingProps
class ApiMappingPropsDef(BaseStruct):
    api: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.HttpApiDef, models.aws_apigatewayv2.WebSocketApiDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Api to which this mapping is applied.\n')
    domain_name: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.DomainNameDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='custom domain name of the mapping target.\n')
    api_mapping_key: typing.Optional[str] = pydantic.Field(None, description='Api mapping key. The path where this stage should be mapped to on the domain Default: - undefined for the root path mapping.\n')
    stage: typing.Optional[typing.Union[models.aws_apigatewayv2.HttpStageDef, models.aws_apigatewayv2.WebSocketStageDef]] = pydantic.Field(None, description='stage for the ApiMapping resource required for WebSocket API defaults to default stage of an HTTP API. Default: - Default stage of the passed API for HTTP API, required for WebSocket API\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    # api: apigatewayv2.IApi\n    # domain_name: apigatewayv2.DomainName\n    # stage: apigatewayv2.IStage\n\n    api_mapping_props = apigatewayv2.ApiMappingProps(\n        api=api,\n        domain_name=domain_name,\n\n        # the properties below are optional\n        api_mapping_key="apiMappingKey",\n        stage=stage\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['api', 'domain_name', 'api_mapping_key', 'stage']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.ApiMappingProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.BatchHttpRouteOptions
class BatchHttpRouteOptionsDef(BaseStruct):
    integration: typing.Union[models.aws_apigatewayv2.HttpRouteIntegrationDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The integration to be configured on this route.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    # http_route_integration: apigatewayv2.HttpRouteIntegration\n\n    batch_http_route_options = apigatewayv2.BatchHttpRouteOptions(\n        integration=http_route_integration\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['integration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.BatchHttpRouteOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnApi.BodyS3LocationProperty
class CfnApi_BodyS3LocationPropertyDef(BaseStruct):
    bucket: typing.Optional[str] = pydantic.Field(None, description='The S3 bucket that contains the OpenAPI definition to import. Required if you specify a ``BodyS3Location`` for an API.\n')
    etag: typing.Optional[str] = pydantic.Field(None, description='The Etag of the S3 object.\n')
    key: typing.Optional[str] = pydantic.Field(None, description='The key of the S3 object. Required if you specify a ``BodyS3Location`` for an API.\n')
    version: typing.Optional[str] = pydantic.Field(None, description='The version of the S3 object.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigatewayv2-api-bodys3location.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    body_s3_location_property = apigatewayv2.CfnApi.BodyS3LocationProperty(\n        bucket="bucket",\n        etag="etag",\n        key="key",\n        version="version"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket', 'etag', 'key', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnApi.BodyS3LocationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnApi.CorsProperty
class CfnApi_CorsPropertyDef(BaseStruct):
    allow_credentials: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether credentials are included in the CORS request. Supported only for HTTP APIs.\n')
    allow_headers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Represents a collection of allowed headers. Supported only for HTTP APIs.\n')
    allow_methods: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Represents a collection of allowed HTTP methods. Supported only for HTTP APIs.\n')
    allow_origins: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Represents a collection of allowed origins. Supported only for HTTP APIs.\n')
    expose_headers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Represents a collection of exposed headers. Supported only for HTTP APIs.\n')
    max_age: typing.Union[int, float, None] = pydantic.Field(None, description='The number of seconds that the browser should cache preflight request results. Supported only for HTTP APIs.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigatewayv2-api-cors.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    cors_property = apigatewayv2.CfnApi.CorsProperty(\n        allow_credentials=False,\n        allow_headers=["allowHeaders"],\n        allow_methods=["allowMethods"],\n        allow_origins=["allowOrigins"],\n        expose_headers=["exposeHeaders"],\n        max_age=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allow_credentials', 'allow_headers', 'allow_methods', 'allow_origins', 'expose_headers', 'max_age']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnApi.CorsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnApiGatewayManagedOverrides.AccessLogSettingsProperty
class CfnApiGatewayManagedOverrides_AccessLogSettingsPropertyDef(BaseStruct):
    destination_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the CloudWatch Logs log group to receive access logs.\n')
    format: typing.Optional[str] = pydantic.Field(None, description='A single line format of the access logs of data, as specified by selected $context variables. The format must include at least $context.requestId.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigatewayv2-apigatewaymanagedoverrides-accesslogsettings.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    access_log_settings_property = apigatewayv2.CfnApiGatewayManagedOverrides.AccessLogSettingsProperty(\n        destination_arn="destinationArn",\n        format="format"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_arn', 'format']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnApiGatewayManagedOverrides.AccessLogSettingsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnApiGatewayManagedOverrides.IntegrationOverridesProperty
class CfnApiGatewayManagedOverrides_IntegrationOverridesPropertyDef(BaseStruct):
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the integration.\n')
    integration_method: typing.Optional[str] = pydantic.Field(None, description="Specifies the integration's HTTP method type. For WebSocket APIs, if you use a Lambda integration, you must set the integration method to ``POST`` .\n")
    payload_format_version: typing.Optional[str] = pydantic.Field(None, description='Specifies the format of the payload sent to an integration. Required for HTTP APIs. For HTTP APIs, supported values for Lambda proxy integrations are ``1.0`` and ``2.0`` . For all other integrations, ``1.0`` is the only supported value. To learn more, see `Working with AWS Lambda proxy integrations for HTTP APIs <https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html>`_ .\n')
    timeout_in_millis: typing.Union[int, float, None] = pydantic.Field(None, description='Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigatewayv2-apigatewaymanagedoverrides-integrationoverrides.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    integration_overrides_property = apigatewayv2.CfnApiGatewayManagedOverrides.IntegrationOverridesProperty(\n        description="description",\n        integration_method="integrationMethod",\n        payload_format_version="payloadFormatVersion",\n        timeout_in_millis=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'integration_method', 'payload_format_version', 'timeout_in_millis']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnApiGatewayManagedOverrides.IntegrationOverridesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnApiGatewayManagedOverrides.RouteOverridesProperty
class CfnApiGatewayManagedOverrides_RouteOverridesPropertyDef(BaseStruct):
    authorization_scopes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The authorization scopes supported by this route.\n')
    authorization_type: typing.Optional[str] = pydantic.Field(None, description='The authorization type for the route. To learn more, see `AuthorizationType <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigatewayv2-route.html#cfn-apigatewayv2-route-authorizationtype>`_ .\n')
    authorizer_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the ``Authorizer`` resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.\n')
    operation_name: typing.Optional[str] = pydantic.Field(None, description='The operation name for the route.\n')
    target: typing.Optional[str] = pydantic.Field(None, description='For HTTP integrations, specify a fully qualified URL. For Lambda integrations, specify a function ARN. The type of the integration will be HTTP_PROXY or AWS_PROXY, respectively.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigatewayv2-apigatewaymanagedoverrides-routeoverrides.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    route_overrides_property = apigatewayv2.CfnApiGatewayManagedOverrides.RouteOverridesProperty(\n        authorization_scopes=["authorizationScopes"],\n        authorization_type="authorizationType",\n        authorizer_id="authorizerId",\n        operation_name="operationName",\n        target="target"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['authorization_scopes', 'authorization_type', 'authorizer_id', 'operation_name', 'target']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnApiGatewayManagedOverrides.RouteOverridesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnApiGatewayManagedOverrides.RouteSettingsProperty
class CfnApiGatewayManagedOverrides_RouteSettingsPropertyDef(BaseStruct):
    data_trace_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether ( ``true`` ) or not ( ``false`` ) data trace logging is enabled for this route. This property affects the log entries pushed to Amazon CloudWatch Logs. Supported only for WebSocket APIs.\n')
    detailed_metrics_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether detailed metrics are enabled.\n')
    logging_level: typing.Optional[str] = pydantic.Field(None, description='Specifies the logging level for this route: ``INFO`` , ``ERROR`` , or ``OFF`` . This property affects the log entries pushed to Amazon CloudWatch Logs. Supported only for WebSocket APIs.\n')
    throttling_burst_limit: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the throttling burst limit.\n')
    throttling_rate_limit: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the throttling rate limit.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigatewayv2-apigatewaymanagedoverrides-routesettings.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    route_settings_property = apigatewayv2.CfnApiGatewayManagedOverrides.RouteSettingsProperty(\n        data_trace_enabled=False,\n        detailed_metrics_enabled=False,\n        logging_level="loggingLevel",\n        throttling_burst_limit=123,\n        throttling_rate_limit=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['data_trace_enabled', 'detailed_metrics_enabled', 'logging_level', 'throttling_burst_limit', 'throttling_rate_limit']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnApiGatewayManagedOverrides.RouteSettingsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnApiGatewayManagedOverrides.StageOverridesProperty
class CfnApiGatewayManagedOverrides_StageOverridesPropertyDef(BaseStruct):
    access_log_settings: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnApiGatewayManagedOverrides_AccessLogSettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for logging access in a stage.\n')
    auto_deploy: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether updates to an API automatically trigger a new deployment. The default value is ``true`` .\n')
    default_route_settings: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnApiGatewayManagedOverrides_RouteSettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The default route settings for the stage.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description for the API stage.\n')
    route_settings: typing.Any = pydantic.Field(None, description='Route settings for the stage.\n')
    stage_variables: typing.Any = pydantic.Field(None, description='A map that defines the stage variables for a ``Stage`` . Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigatewayv2-apigatewaymanagedoverrides-stageoverrides.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    # route_settings: Any\n    # stage_variables: Any\n\n    stage_overrides_property = apigatewayv2.CfnApiGatewayManagedOverrides.StageOverridesProperty(\n        access_log_settings=apigatewayv2.CfnApiGatewayManagedOverrides.AccessLogSettingsProperty(\n            destination_arn="destinationArn",\n            format="format"\n        ),\n        auto_deploy=False,\n        default_route_settings=apigatewayv2.CfnApiGatewayManagedOverrides.RouteSettingsProperty(\n            data_trace_enabled=False,\n            detailed_metrics_enabled=False,\n            logging_level="loggingLevel",\n            throttling_burst_limit=123,\n            throttling_rate_limit=123\n        ),\n        description="description",\n        route_settings=route_settings,\n        stage_variables=stage_variables\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['access_log_settings', 'auto_deploy', 'default_route_settings', 'description', 'route_settings', 'stage_variables']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnApiGatewayManagedOverrides.StageOverridesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnAuthorizer.JWTConfigurationProperty
class CfnAuthorizer_JWTConfigurationPropertyDef(BaseStruct):
    audience: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of the intended recipients of the JWT. A valid JWT must provide an ``aud`` that matches at least one entry in this list. See `RFC 7519 <https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc7519#section-4.1.3>`_ . Required for the ``JWT`` authorizer type. Supported only for HTTP APIs.\n')
    issuer: typing.Optional[str] = pydantic.Field(None, description='The base domain of the identity provider that issues JSON Web Tokens. For example, an Amazon Cognito user pool has the following format: ``https://cognito-idp. {region} .amazonaws.com/ {userPoolId}`` . Required for the ``JWT`` authorizer type. Supported only for HTTP APIs.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigatewayv2-authorizer-jwtconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    j_wTConfiguration_property = apigatewayv2.CfnAuthorizer.JWTConfigurationProperty(\n        audience=["audience"],\n        issuer="issuer"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['audience', 'issuer']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnAuthorizer.JWTConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnDomainName.DomainNameConfigurationProperty
class CfnDomainName_DomainNameConfigurationPropertyDef(BaseStruct):
    certificate_arn: typing.Optional[str] = pydantic.Field(None, description='An AWS -managed certificate that will be used by the edge-optimized endpoint for this domain name. AWS Certificate Manager is the only supported source.\n')
    certificate_name: typing.Optional[str] = pydantic.Field(None, description='The user-friendly name of the certificate that will be used by the edge-optimized endpoint for this domain name.\n')
    endpoint_type: typing.Optional[str] = pydantic.Field(None, description='The endpoint type.\n')
    ownership_verification_certificate_arn: typing.Optional[str] = pydantic.Field(None, description="The Amazon resource name (ARN) for the public certificate issued by AWS Certificate Manager . This ARN is used to validate custom domain ownership. It's required only if you configure mutual TLS and use either an ACM-imported or a private CA certificate ARN as the regionalCertificateArn.\n")
    security_policy: typing.Optional[str] = pydantic.Field(None, description='The Transport Layer Security (TLS) version of the security policy for this domain name. The valid values are ``TLS_1_0`` and ``TLS_1_2`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigatewayv2-domainname-domainnameconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    domain_name_configuration_property = apigatewayv2.CfnDomainName.DomainNameConfigurationProperty(\n        certificate_arn="certificateArn",\n        certificate_name="certificateName",\n        endpoint_type="endpointType",\n        ownership_verification_certificate_arn="ownershipVerificationCertificateArn",\n        security_policy="securityPolicy"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate_arn', 'certificate_name', 'endpoint_type', 'ownership_verification_certificate_arn', 'security_policy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnDomainName.DomainNameConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnDomainName.MutualTlsAuthenticationProperty
class CfnDomainName_MutualTlsAuthenticationPropertyDef(BaseStruct):
    truststore_uri: typing.Optional[str] = pydantic.Field(None, description='An Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, ``s3:// bucket-name / key-name`` . The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version. To update the truststore, you must have permissions to access the S3 object.\n')
    truststore_version: typing.Optional[str] = pydantic.Field(None, description='The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigatewayv2-domainname-mutualtlsauthentication.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    mutual_tls_authentication_property = apigatewayv2.CfnDomainName.MutualTlsAuthenticationProperty(\n        truststore_uri="truststoreUri",\n        truststore_version="truststoreVersion"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['truststore_uri', 'truststore_version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnDomainName.MutualTlsAuthenticationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnIntegration.ResponseParameterListProperty
class CfnIntegration_ResponseParameterListPropertyDef(BaseStruct):
    response_parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnIntegration_ResponseParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    _init_params: typing.ClassVar[list[str]] = ['response_parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnIntegration.ResponseParameterListProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnIntegration.ResponseParameterProperty
class CfnIntegration_ResponseParameterPropertyDef(BaseStruct):
    destination: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='')
    source: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='')
    _init_params: typing.ClassVar[list[str]] = ['destination', 'source']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnIntegration.ResponseParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnIntegration.TlsConfigProperty
class CfnIntegration_TlsConfigPropertyDef(BaseStruct):
    server_name_to_verify: typing.Optional[str] = pydantic.Field(None, description='If you specify a server name, API Gateway uses it to verify the hostname on the integration\'s certificate. The server name is also included in the TLS handshake to support Server Name Indication (SNI) or virtual hosting.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigatewayv2-integration-tlsconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    tls_config_property = apigatewayv2.CfnIntegration.TlsConfigProperty(\n        server_name_to_verify="serverNameToVerify"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['server_name_to_verify']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnIntegration.TlsConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnRoute.ParameterConstraintsProperty
class CfnRoute_ParameterConstraintsPropertyDef(BaseStruct):
    required: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='')
    _init_params: typing.ClassVar[list[str]] = ['required']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnRoute.ParameterConstraintsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnRouteResponse.ParameterConstraintsProperty
class CfnRouteResponse_ParameterConstraintsPropertyDef(BaseStruct):
    required: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies whether the parameter is required.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigatewayv2-routeresponse-parameterconstraints.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    parameter_constraints_property = apigatewayv2.CfnRouteResponse.ParameterConstraintsProperty(\n        required=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['required']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnRouteResponse.ParameterConstraintsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnStage.AccessLogSettingsProperty
class CfnStage_AccessLogSettingsPropertyDef(BaseStruct):
    destination_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the CloudWatch Logs log group to receive access logs. This parameter is required to enable access logging.\n')
    format: typing.Optional[str] = pydantic.Field(None, description='A single line format of the access logs of data, as specified by selected $context variables. The format must include at least $context.requestId. This parameter is required to enable access logging.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigatewayv2-stage-accesslogsettings.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    access_log_settings_property = apigatewayv2.CfnStage.AccessLogSettingsProperty(\n        destination_arn="destinationArn",\n        format="format"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_arn', 'format']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnStage.AccessLogSettingsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnStage.RouteSettingsProperty
class CfnStage_RouteSettingsPropertyDef(BaseStruct):
    data_trace_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether ( ``true`` ) or not ( ``false`` ) data trace logging is enabled for this route. This property affects the log entries pushed to Amazon CloudWatch Logs. Supported only for WebSocket APIs.\n')
    detailed_metrics_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether detailed metrics are enabled.\n')
    logging_level: typing.Optional[str] = pydantic.Field(None, description='Specifies the logging level for this route: ``INFO`` , ``ERROR`` , or ``OFF`` . This property affects the log entries pushed to Amazon CloudWatch Logs. Supported only for WebSocket APIs.\n')
    throttling_burst_limit: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the throttling burst limit.\n')
    throttling_rate_limit: typing.Union[int, float, None] = pydantic.Field(None, description='Specifies the throttling rate limit.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigatewayv2-stage-routesettings.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    route_settings_property = apigatewayv2.CfnStage.RouteSettingsProperty(\n        data_trace_enabled=False,\n        detailed_metrics_enabled=False,\n        logging_level="loggingLevel",\n        throttling_burst_limit=123,\n        throttling_rate_limit=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['data_trace_enabled', 'detailed_metrics_enabled', 'logging_level', 'throttling_burst_limit', 'throttling_rate_limit']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnStage.RouteSettingsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CorsPreflightOptions
class CorsPreflightOptionsDef(BaseStruct):
    allow_credentials: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether credentials are included in the CORS request. Default: false\n')
    allow_headers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Represents a collection of allowed headers. Default: - No Headers are allowed.\n')
    allow_methods: typing.Optional[typing.Sequence[aws_cdk.aws_apigatewayv2.CorsHttpMethod]] = pydantic.Field(None, description='Represents a collection of allowed HTTP methods. Default: - No Methods are allowed.\n')
    allow_origins: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Represents a collection of allowed origins. Default: - No Origins are allowed.\n')
    expose_headers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Represents a collection of exposed headers. Default: - No Expose Headers are allowed.\n')
    max_age: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The duration that the browser should cache preflight request results. Default: Duration.seconds(0)\n\n:exampleMetadata: infused\n\nExample::\n\n    apigwv2.HttpApi(self, "HttpProxyApi",\n        cors_preflight=apigwv2.CorsPreflightOptions(\n            allow_headers=["Authorization"],\n            allow_methods=[apigwv2.CorsHttpMethod.GET, apigwv2.CorsHttpMethod.HEAD, apigwv2.CorsHttpMethod.OPTIONS, apigwv2.CorsHttpMethod.POST\n            ],\n            allow_origins=["*"],\n            max_age=Duration.days(10)\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allow_credentials', 'allow_headers', 'allow_methods', 'allow_origins', 'expose_headers', 'max_age']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CorsPreflightOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.DomainMappingOptions
class DomainMappingOptionsDef(BaseStruct):
    domain_name: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.DomainNameDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The domain name for the mapping.\n')
    mapping_key: typing.Optional[str] = pydantic.Field(None, description='The API mapping key. Leave it undefined for the root path mapping. Default: - empty key for the root path mapping\n\n:exampleMetadata: infused\n\nExample::\n\n    from aws_cdk.aws_apigatewayv2_integrations import HttpLambdaIntegration\n\n    # handler: lambda.Function\n    # dn: apigwv2.DomainName\n\n\n    api_demo = apigwv2.HttpApi(self, "DemoApi",\n        default_integration=HttpLambdaIntegration("DefaultIntegration", handler),\n        # https://${dn.domainName}/demo goes to apiDemo $default stage\n        default_domain_mapping=apigwv2.DomainMappingOptions(\n            domain_name=dn,\n            mapping_key="demo"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'mapping_key']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.DomainMappingOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.DomainNameAttributes
class DomainNameAttributesDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='domain name string.\n')
    regional_domain_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The domain name associated with the regional endpoint for this custom domain name.\n')
    regional_hosted_zone_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The region-specific Amazon Route 53 Hosted Zone ID of the regional endpoint.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    domain_name_attributes = apigatewayv2.DomainNameAttributes(\n        name="name",\n        regional_domain_name="regionalDomainName",\n        regional_hosted_zone_id="regionalHostedZoneId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'regional_domain_name', 'regional_hosted_zone_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.DomainNameAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.DomainNameProps
class DomainNamePropsDef(BaseStruct):
    certificate: typing.Union[_REQUIRED_INIT_PARAM, models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ACM certificate for this domain name. Certificate can be both ACM issued or imported.\n')
    certificate_name: typing.Optional[str] = pydantic.Field(None, description='The user-friendly name of the certificate that will be used by the endpoint for this domain name. Default: - No friendly certificate name\n')
    endpoint_type: typing.Optional[aws_cdk.aws_apigatewayv2.EndpointType] = pydantic.Field(None, description='The type of endpoint for this DomainName. Default: EndpointType.REGIONAL\n')
    ownership_certificate: typing.Optional[typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef]] = pydantic.Field(None, description='A public certificate issued by ACM to validate that you own a custom domain. This parameter is required only when you configure mutual TLS authentication and you specify an ACM imported or private CA certificate for ``certificate``. The ownership certificate validates that you have permissions to use the domain name. Default: - only required when configuring mTLS\n')
    security_policy: typing.Optional[aws_cdk.aws_apigatewayv2.SecurityPolicy] = pydantic.Field(None, description='The Transport Layer Security (TLS) version + cipher suite for this domain name. Default: SecurityPolicy.TLS_1_2\n')
    domain_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The custom domain name.\n')
    mtls: typing.Union[models.aws_apigatewayv2.MTLSConfigDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The mutual TLS authentication configuration for a custom domain name. Default: - mTLS is not configured.\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_certificatemanager as acm\n    from aws_cdk.aws_apigatewayv2_integrations import HttpLambdaIntegration\n\n    # handler: lambda.Function\n\n\n    cert_arn = "arn:aws:acm:us-east-1:111111111111:certificate"\n    domain_name = "example.com"\n\n    dn = apigwv2.DomainName(self, "DN",\n        domain_name=domain_name,\n        certificate=acm.Certificate.from_certificate_arn(self, "cert", cert_arn)\n    )\n    api = apigwv2.HttpApi(self, "HttpProxyProdApi",\n        default_integration=HttpLambdaIntegration("DefaultIntegration", handler),\n        # https://${dn.domainName}/foo goes to prodApi $default stage\n        default_domain_mapping=apigwv2.DomainMappingOptions(\n            domain_name=dn,\n            mapping_key="foo"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate', 'certificate_name', 'endpoint_type', 'ownership_certificate', 'security_policy', 'domain_name', 'mtls']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.DomainNameProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.DomainNamePropsDefConfig] = pydantic.Field(None)


class DomainNamePropsDefConfig(pydantic.BaseModel):
    certificate_config: typing.Optional[models._interface_methods.AwsCertificatemanagerICertificateDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigatewayv2.EndpointOptions
class EndpointOptionsDef(BaseStruct):
    certificate: typing.Union[_REQUIRED_INIT_PARAM, models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ACM certificate for this domain name. Certificate can be both ACM issued or imported.\n')
    certificate_name: typing.Optional[str] = pydantic.Field(None, description='The user-friendly name of the certificate that will be used by the endpoint for this domain name. Default: - No friendly certificate name\n')
    endpoint_type: typing.Optional[aws_cdk.aws_apigatewayv2.EndpointType] = pydantic.Field(None, description='The type of endpoint for this DomainName. Default: EndpointType.REGIONAL\n')
    ownership_certificate: typing.Optional[typing.Union[models.aws_certificatemanager.CertificateDef, models.aws_certificatemanager.DnsValidatedCertificateDef, models.aws_certificatemanager.PrivateCertificateDef]] = pydantic.Field(None, description='A public certificate issued by ACM to validate that you own a custom domain. This parameter is required only when you configure mutual TLS authentication and you specify an ACM imported or private CA certificate for ``certificate``. The ownership certificate validates that you have permissions to use the domain name. Default: - only required when configuring mTLS\n')
    security_policy: typing.Optional[aws_cdk.aws_apigatewayv2.SecurityPolicy] = pydantic.Field(None, description='The Transport Layer Security (TLS) version + cipher suite for this domain name. Default: SecurityPolicy.TLS_1_2\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n    from aws_cdk import aws_certificatemanager as certificatemanager\n\n    # certificate: certificatemanager.Certificate\n\n    endpoint_options = apigatewayv2.EndpointOptions(\n        certificate=certificate,\n\n        # the properties below are optional\n        certificate_name="certificateName",\n        endpoint_type=apigatewayv2.EndpointType.EDGE,\n        ownership_certificate=certificate,\n        security_policy=apigatewayv2.SecurityPolicy.TLS_1_0\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate', 'certificate_name', 'endpoint_type', 'ownership_certificate', 'security_policy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.EndpointOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.EndpointOptionsDefConfig] = pydantic.Field(None)


class EndpointOptionsDefConfig(pydantic.BaseModel):
    certificate_config: typing.Optional[models._interface_methods.AwsCertificatemanagerICertificateDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigatewayv2.GrantInvokeOptions
class GrantInvokeOptionsDef(BaseStruct):
    http_methods: typing.Optional[typing.Sequence[aws_cdk.aws_apigatewayv2.HttpMethod]] = pydantic.Field(None, description='The HTTP methods to allow. Default: - the HttpMethod of the route\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    grant_invoke_options = apigatewayv2.GrantInvokeOptions(\n        http_methods=[apigatewayv2.HttpMethod.ANY]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['http_methods']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.GrantInvokeOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.HttpApiAttributes
class HttpApiAttributesDef(BaseStruct):
    http_api_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the HttpApi.\n')
    api_endpoint: typing.Optional[str] = pydantic.Field(None, description='The endpoint URL of the HttpApi. Default: - throws an error if apiEndpoint is accessed.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    http_api_attributes = apigatewayv2.HttpApiAttributes(\n        http_api_id="httpApiId",\n\n        # the properties below are optional\n        api_endpoint="apiEndpoint"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['http_api_id', 'api_endpoint']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.HttpApiAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.HttpApiProps
class HttpApiPropsDef(BaseStruct):
    api_name: typing.Optional[str] = pydantic.Field(None, description='Name for the HTTP API resource. Default: - id of the HttpApi construct.\n')
    cors_preflight: typing.Union[models.aws_apigatewayv2.CorsPreflightOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Specifies a CORS configuration for an API. Default: - CORS disabled.\n')
    create_default_stage: typing.Optional[bool] = pydantic.Field(None, description='Whether a default stage and deployment should be automatically created. Default: true\n')
    default_authorization_scopes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Default OIDC scopes attached to all routes in the gateway, unless explicitly configured on the route. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. Default: - no default authorization scopes\n')
    default_authorizer: typing.Optional[typing.Union[models.aws_apigatewayv2.HttpNoneAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpIamAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpJwtAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpLambdaAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpUserPoolAuthorizerDef]] = pydantic.Field(None, description='Default Authorizer applied to all routes in the gateway. Default: - no default authorizer\n')
    default_domain_mapping: typing.Union[models.aws_apigatewayv2.DomainMappingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configure a custom domain with the API mapping resource to the HTTP API. Default: - no default domain mapping configured. meaningless if ``createDefaultStage`` is ``false``.\n')
    default_integration: typing.Optional[models.aws_apigatewayv2.HttpRouteIntegrationDef] = pydantic.Field(None, description='An integration that will be configured on the catch-all route ($default). Default: - none\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the API. Default: - none\n')
    disable_execute_api_endpoint: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether clients can invoke your API using the default endpoint. By default, clients can invoke your API with the default ``https://{api_id}.execute-api.{region}.amazonaws.com`` endpoint. Enable this if you would like clients to use your custom domain name. Default: false execute-api endpoint enabled.\n\n:exampleMetadata: infused\n\nExample::\n\n    from aws_cdk.aws_apigatewayv2_integrations import HttpAlbIntegration\n\n    # lb: elbv2.ApplicationLoadBalancer\n\n    listener = lb.add_listener("listener", port=80)\n    listener.add_targets("target",\n        port=80\n    )\n\n    http_endpoint = apigwv2.HttpApi(self, "HttpProxyPrivateApi",\n        default_integration=HttpAlbIntegration("DefaultIntegration", listener,\n            parameter_mapping=apigwv2.ParameterMapping().custom("myKey", "myValue")\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['api_name', 'cors_preflight', 'create_default_stage', 'default_authorization_scopes', 'default_authorizer', 'default_domain_mapping', 'default_integration', 'description', 'disable_execute_api_endpoint']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.HttpApiProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.HttpAuthorizerAttributes
class HttpAuthorizerAttributesDef(BaseStruct):
    authorizer_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Id of the Authorizer.\n')
    authorizer_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Type of authorizer. Possible values are: - JWT - JSON Web Token Authorizer - CUSTOM - Lambda Authorizer - NONE - No Authorization\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    http_authorizer_attributes = apigatewayv2.HttpAuthorizerAttributes(\n        authorizer_id="authorizerId",\n        authorizer_type="authorizerType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['authorizer_id', 'authorizer_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.HttpAuthorizerAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.HttpAuthorizerProps
class HttpAuthorizerPropsDef(BaseStruct):
    http_api: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.HttpApiDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='HTTP Api to attach the authorizer to.\n')
    identity_source: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identity source for which authorization is requested.\n')
    type: typing.Union[aws_cdk.aws_apigatewayv2.HttpAuthorizerType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of authorizer.\n')
    authorizer_name: typing.Optional[str] = pydantic.Field(None, description='Name of the authorizer. Default: - id of the HttpAuthorizer construct.\n')
    authorizer_uri: typing.Optional[str] = pydantic.Field(None, description="The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI. Default: - required for Request authorizer types\n")
    enable_simple_responses: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Default: - The lambda authorizer must return an IAM policy as its response\n')
    jwt_audience: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of the intended recipients of the JWT. A valid JWT must provide an aud that matches at least one entry in this list. Default: - required for JWT authorizer typess.\n')
    jwt_issuer: typing.Optional[str] = pydantic.Field(None, description='The base domain of the identity provider that issues JWT. Default: - required for JWT authorizer types.\n')
    payload_format_version: typing.Optional[aws_cdk.aws_apigatewayv2.AuthorizerPayloadVersion] = pydantic.Field(None, description='Specifies the format of the payload sent to an HTTP API Lambda authorizer. Default: AuthorizerPayloadVersion.VERSION_2_0 if the authorizer type is HttpAuthorizerType.LAMBDA\n')
    results_cache_ttl: typing.Optional[models.DurationDef] = pydantic.Field(None, description='How long APIGateway should cache the results. Max 1 hour. Default: - API Gateway will not cache authorizer responses\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    # http_api: apigatewayv2.HttpApi\n\n    http_authorizer_props = apigatewayv2.HttpAuthorizerProps(\n        http_api=http_api,\n        identity_source=["identitySource"],\n        type=apigatewayv2.HttpAuthorizerType.IAM,\n\n        # the properties below are optional\n        authorizer_name="authorizerName",\n        authorizer_uri="authorizerUri",\n        enable_simple_responses=False,\n        jwt_audience=["jwtAudience"],\n        jwt_issuer="jwtIssuer",\n        payload_format_version=apigatewayv2.AuthorizerPayloadVersion.VERSION_1_0,\n        results_cache_ttl=cdk.Duration.minutes(30)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['http_api', 'identity_source', 'type', 'authorizer_name', 'authorizer_uri', 'enable_simple_responses', 'jwt_audience', 'jwt_issuer', 'payload_format_version', 'results_cache_ttl']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.HttpAuthorizerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.HttpIntegrationProps
class HttpIntegrationPropsDef(BaseStruct):
    http_api: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.HttpApiDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The HTTP API to which this integration should be bound.\n')
    integration_type: typing.Union[aws_cdk.aws_apigatewayv2.HttpIntegrationType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Integration type.\n')
    connection_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the VPC link for a private integration. Supported only for HTTP APIs. Default: - undefined\n')
    connection_type: typing.Optional[aws_cdk.aws_apigatewayv2.HttpConnectionType] = pydantic.Field(None, description='The type of the network connection to the integration endpoint. Default: HttpConnectionType.INTERNET\n')
    credentials: typing.Optional[models.aws_apigatewayv2.IntegrationCredentialsDef] = pydantic.Field(None, description='The credentials with which to invoke the integration. Default: - no credentials, use resource-based permissions on supported AWS services\n')
    integration_subtype: typing.Optional[aws_cdk.aws_apigatewayv2.HttpIntegrationSubtype] = pydantic.Field(None, description='Integration subtype. Used for AWS Service integrations, specifies the target of the integration. Default: - none, required if no ``integrationUri`` is defined.\n')
    integration_uri: typing.Optional[str] = pydantic.Field(None, description='Integration URI. This will be the function ARN in the case of ``HttpIntegrationType.AWS_PROXY``, or HTTP URL in the case of ``HttpIntegrationType.HTTP_PROXY``. Default: - none, required if no ``integrationSubtype`` is defined.\n')
    method: typing.Optional[aws_cdk.aws_apigatewayv2.HttpMethod] = pydantic.Field(None, description='The HTTP method to use when calling the underlying HTTP proxy. Default: - none. required if the integration type is ``HttpIntegrationType.HTTP_PROXY``.\n')
    parameter_mapping: typing.Optional[models.aws_apigatewayv2.ParameterMappingDef] = pydantic.Field(None, description='Specifies how to transform HTTP requests before sending them to the backend. Default: undefined requests are sent to the backend unmodified\n')
    payload_format_version: typing.Optional[models.aws_apigatewayv2.PayloadFormatVersionDef] = pydantic.Field(None, description='The version of the payload format. Default: - defaults to latest in the case of HttpIntegrationType.AWS_PROXY`, irrelevant otherwise.\n')
    secure_server_name: typing.Optional[str] = pydantic.Field(None, description='Specifies the TLS configuration for a private integration. Default: undefined private integration traffic will use HTTP protocol\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum amount of time an integration will run before it returns without a response. Must be between 50 milliseconds and 29 seconds. Default: Duration.seconds(29)\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    # http_api: apigatewayv2.HttpApi\n    # integration_credentials: apigatewayv2.IntegrationCredentials\n    # parameter_mapping: apigatewayv2.ParameterMapping\n    # payload_format_version: apigatewayv2.PayloadFormatVersion\n\n    http_integration_props = apigatewayv2.HttpIntegrationProps(\n        http_api=http_api,\n        integration_type=apigatewayv2.HttpIntegrationType.HTTP_PROXY,\n\n        # the properties below are optional\n        connection_id="connectionId",\n        connection_type=apigatewayv2.HttpConnectionType.VPC_LINK,\n        credentials=integration_credentials,\n        integration_subtype=apigatewayv2.HttpIntegrationSubtype.EVENTBRIDGE_PUT_EVENTS,\n        integration_uri="integrationUri",\n        method=apigatewayv2.HttpMethod.ANY,\n        parameter_mapping=parameter_mapping,\n        payload_format_version=payload_format_version,\n        secure_server_name="secureServerName",\n        timeout=cdk.Duration.minutes(30)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['http_api', 'integration_type', 'connection_id', 'connection_type', 'credentials', 'integration_subtype', 'integration_uri', 'method', 'parameter_mapping', 'payload_format_version', 'secure_server_name', 'timeout']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.HttpIntegrationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.HttpRouteAuthorizerBindOptions
class HttpRouteAuthorizerBindOptionsDef(BaseStruct):
    route: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.HttpRouteDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The route to which the authorizer is being bound.\n')
    _init_params: typing.ClassVar[list[str]] = ['route']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.HttpRouteAuthorizerBindOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.HttpRouteAuthorizerConfig
class HttpRouteAuthorizerConfigDef(BaseStruct):
    authorization_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of authorization. Possible values are: - AWS_IAM - IAM Authorizer - JWT - JSON Web Token Authorizer - CUSTOM - Lambda Authorizer - NONE - No Authorization\n')
    authorization_scopes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of OIDC scopes to include in the authorization. Default: - no authorization scopes\n')
    authorizer_id: typing.Optional[str] = pydantic.Field(None, description='The authorizer id. Default: - No authorizer id (useful for AWS_IAM route authorizer)\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    http_route_authorizer_config = apigatewayv2.HttpRouteAuthorizerConfig(\n        authorization_type="authorizationType",\n\n        # the properties below are optional\n        authorization_scopes=["authorizationScopes"],\n        authorizer_id="authorizerId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['authorization_type', 'authorization_scopes', 'authorizer_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.HttpRouteAuthorizerConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.HttpRouteIntegrationBindOptions
class HttpRouteIntegrationBindOptionsDef(BaseStruct):
    route: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.HttpRouteDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The route to which this is being bound.\n')
    _init_params: typing.ClassVar[list[str]] = ['route']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.HttpRouteIntegrationBindOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.HttpRouteIntegrationConfig
class HttpRouteIntegrationConfigDef(BaseStruct):
    payload_format_version: typing.Union[models.aws_apigatewayv2.PayloadFormatVersionDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Payload format version in the case of lambda proxy integration. Default: - undefined\n')
    type: typing.Union[aws_cdk.aws_apigatewayv2.HttpIntegrationType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Integration type.\n')
    connection_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the VPC link for a private integration. Supported only for HTTP APIs. Default: - undefined\n')
    connection_type: typing.Optional[aws_cdk.aws_apigatewayv2.HttpConnectionType] = pydantic.Field(None, description='The type of the network connection to the integration endpoint. Default: HttpConnectionType.INTERNET\n')
    credentials: typing.Optional[models.aws_apigatewayv2.IntegrationCredentialsDef] = pydantic.Field(None, description='The credentials with which to invoke the integration. Default: - no credentials, use resource-based permissions on supported AWS services\n')
    method: typing.Optional[aws_cdk.aws_apigatewayv2.HttpMethod] = pydantic.Field(None, description='The HTTP method that must be used to invoke the underlying proxy. Required for ``HttpIntegrationType.HTTP_PROXY`` Default: - undefined\n')
    parameter_mapping: typing.Optional[models.aws_apigatewayv2.ParameterMappingDef] = pydantic.Field(None, description='Specifies how to transform HTTP requests before sending them to the backend. Default: undefined requests are sent to the backend unmodified\n')
    secure_server_name: typing.Optional[str] = pydantic.Field(None, description='Specifies the server name to verified by HTTPS when calling the backend integration. Default: undefined private integration traffic will use HTTP protocol\n')
    subtype: typing.Optional[aws_cdk.aws_apigatewayv2.HttpIntegrationSubtype] = pydantic.Field(None, description='Integration subtype. Default: - none, required if no ``integrationUri`` is defined.\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum amount of time an integration will run before it returns without a response. Must be between 50 milliseconds and 29 seconds. Default: Duration.seconds(29)\n')
    uri: typing.Optional[str] = pydantic.Field(None, description='Integration URI. Default: - none, required if no ``integrationSubtype`` is defined.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    # integration_credentials: apigatewayv2.IntegrationCredentials\n    # parameter_mapping: apigatewayv2.ParameterMapping\n    # payload_format_version: apigatewayv2.PayloadFormatVersion\n\n    http_route_integration_config = apigatewayv2.HttpRouteIntegrationConfig(\n        payload_format_version=payload_format_version,\n        type=apigatewayv2.HttpIntegrationType.HTTP_PROXY,\n\n        # the properties below are optional\n        connection_id="connectionId",\n        connection_type=apigatewayv2.HttpConnectionType.VPC_LINK,\n        credentials=integration_credentials,\n        method=apigatewayv2.HttpMethod.ANY,\n        parameter_mapping=parameter_mapping,\n        secure_server_name="secureServerName",\n        subtype=apigatewayv2.HttpIntegrationSubtype.EVENTBRIDGE_PUT_EVENTS,\n        timeout=cdk.Duration.minutes(30),\n        uri="uri"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['payload_format_version', 'type', 'connection_id', 'connection_type', 'credentials', 'method', 'parameter_mapping', 'secure_server_name', 'subtype', 'timeout', 'uri']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.HttpRouteIntegrationConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.HttpRouteProps
class HttpRoutePropsDef(BaseStruct):
    integration: typing.Union[models.aws_apigatewayv2.HttpRouteIntegrationDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The integration to be configured on this route.\n')
    http_api: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.HttpApiDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='the API the route is associated with.\n')
    route_key: typing.Union[models.aws_apigatewayv2.HttpRouteKeyDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The key to this route. This is a combination of an HTTP method and an HTTP path.\n')
    authorization_scopes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of OIDC scopes to include in the authorization. These scopes will be merged with the scopes from the attached authorizer Default: - no additional authorization scopes\n')
    authorizer: typing.Optional[typing.Union[models.aws_apigatewayv2.HttpNoneAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpIamAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpJwtAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpLambdaAuthorizerDef, models.aws_apigatewayv2_authorizers.HttpUserPoolAuthorizerDef]] = pydantic.Field(None, description='Authorizer for a WebSocket API or an HTTP API. Default: - No authorizer\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    # http_api: apigatewayv2.HttpApi\n    # http_route_authorizer: apigatewayv2.IHttpRouteAuthorizer\n    # http_route_integration: apigatewayv2.HttpRouteIntegration\n    # http_route_key: apigatewayv2.HttpRouteKey\n\n    http_route_props = apigatewayv2.HttpRouteProps(\n        http_api=http_api,\n        integration=http_route_integration,\n        route_key=http_route_key,\n\n        # the properties below are optional\n        authorization_scopes=["authorizationScopes"],\n        authorizer=http_route_authorizer\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['integration', 'http_api', 'route_key', 'authorization_scopes', 'authorizer']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.HttpRouteProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.HttpRoutePropsDefConfig] = pydantic.Field(None)


class HttpRoutePropsDefConfig(pydantic.BaseModel):
    integration_config: typing.Optional[models.aws_apigatewayv2.HttpRouteIntegrationDefConfig] = pydantic.Field(None)
    route_key_config: typing.Optional[models.aws_apigatewayv2.HttpRouteKeyDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigatewayv2.HttpStageAttributes
class HttpStageAttributesDef(BaseStruct):
    stage_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the stage.\n')
    api: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.HttpApiDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API to which this stage is associated.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    # http_api: apigatewayv2.HttpApi\n\n    http_stage_attributes = apigatewayv2.HttpStageAttributes(\n        api=http_api,\n        stage_name="stageName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['stage_name', 'api']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.HttpStageAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.HttpStageAttributesDefConfig] = pydantic.Field(None)


class HttpStageAttributesDefConfig(pydantic.BaseModel):
    api_config: typing.Optional[models._interface_methods.AwsApigatewayv2IHttpApiDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigatewayv2.HttpStageOptions
class HttpStageOptionsDef(BaseStruct):
    auto_deploy: typing.Optional[bool] = pydantic.Field(None, description='Whether updates to an API automatically trigger a new deployment. Default: false\n')
    domain_mapping: typing.Union[models.aws_apigatewayv2.DomainMappingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for custom domain and api mapping. Default: - no custom domain and api mapping configuration\n')
    throttle: typing.Union[models.aws_apigatewayv2.ThrottleSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Throttle settings for the routes of this stage. Default: - no throttling configuration\n')
    stage_name: typing.Optional[str] = pydantic.Field(None, description='The name of the stage. See ``StageName`` class for more details. Default: \'$default\' the default stage of the API. This stage will have the URL at the root of the API endpoint.\n\n:exampleMetadata: infused\n\nExample::\n\n    # api: apigwv2.HttpApi\n    # dn: apigwv2.DomainName\n\n\n    api.add_stage("beta",\n        stage_name="beta",\n        auto_deploy=True,\n        # https://${dn.domainName}/bar goes to the beta stage\n        domain_mapping=apigwv2.DomainMappingOptions(\n            domain_name=dn,\n            mapping_key="bar"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['auto_deploy', 'domain_mapping', 'throttle', 'stage_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.HttpStageOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.HttpStageProps
class HttpStagePropsDef(BaseStruct):
    auto_deploy: typing.Optional[bool] = pydantic.Field(None, description='Whether updates to an API automatically trigger a new deployment. Default: false\n')
    domain_mapping: typing.Union[models.aws_apigatewayv2.DomainMappingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for custom domain and api mapping. Default: - no custom domain and api mapping configuration\n')
    throttle: typing.Union[models.aws_apigatewayv2.ThrottleSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Throttle settings for the routes of this stage. Default: - no throttling configuration\n')
    stage_name: typing.Optional[str] = pydantic.Field(None, description="The name of the stage. See ``StageName`` class for more details. Default: '$default' the default stage of the API. This stage will have the URL at the root of the API endpoint.\n")
    http_api: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.HttpApiDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The HTTP API to which this stage is associated.\n\n:exampleMetadata: infused\n\nExample::\n\n    # api: apigwv2.HttpApi\n\n\n    apigwv2.HttpStage(self, "Stage",\n        http_api=api,\n        stage_name="beta"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['auto_deploy', 'domain_mapping', 'throttle', 'stage_name', 'http_api']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.HttpStageProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.HttpStagePropsDefConfig] = pydantic.Field(None)


class HttpStagePropsDefConfig(pydantic.BaseModel):
    http_api_config: typing.Optional[models._interface_methods.AwsApigatewayv2IHttpApiDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigatewayv2.MTLSConfig
class MTLSConfigDef(BaseStruct):
    bucket: typing.Union[_REQUIRED_INIT_PARAM, models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The bucket that the trust store is hosted in.\n')
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The key in S3 to look at for the trust store.\n')
    version: typing.Optional[str] = pydantic.Field(None, description='The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket. Default: - latest version\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_s3 as s3\n    import aws_cdk.aws_certificatemanager as acm\n    # bucket: s3.Bucket\n\n\n    cert_arn = "arn:aws:acm:us-east-1:111111111111:certificate"\n    domain_name = "example.com"\n\n    apigwv2.DomainName(self, "DomainName",\n        domain_name=domain_name,\n        certificate=acm.Certificate.from_certificate_arn(self, "cert", cert_arn),\n        mtls=apigwv2.MTLSConfig(\n            bucket=bucket,\n            key="someca.pem",\n            version="version"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket', 'key', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.MTLSConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.MTLSConfigDefConfig] = pydantic.Field(None)


class MTLSConfigDefConfig(pydantic.BaseModel):
    bucket_config: typing.Optional[models._interface_methods.AwsS3IBucketDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigatewayv2.StageAttributes
class StageAttributesDef(BaseStruct):
    stage_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the stage.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    stage_attributes = apigatewayv2.StageAttributes(\n        stage_name="stageName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['stage_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.StageAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.StageOptions
class StageOptionsDef(BaseStruct):
    auto_deploy: typing.Optional[bool] = pydantic.Field(None, description='Whether updates to an API automatically trigger a new deployment. Default: false\n')
    domain_mapping: typing.Union[models.aws_apigatewayv2.DomainMappingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for custom domain and api mapping. Default: - no custom domain and api mapping configuration\n')
    throttle: typing.Union[models.aws_apigatewayv2.ThrottleSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Throttle settings for the routes of this stage. Default: - no throttling configuration\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    # domain_name: apigatewayv2.DomainName\n\n    stage_options = apigatewayv2.StageOptions(\n        auto_deploy=False,\n        domain_mapping=apigatewayv2.DomainMappingOptions(\n            domain_name=domain_name,\n\n            # the properties below are optional\n            mapping_key="mappingKey"\n        ),\n        throttle=apigatewayv2.ThrottleSettings(\n            burst_limit=123,\n            rate_limit=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['auto_deploy', 'domain_mapping', 'throttle']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.StageOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.ThrottleSettings
class ThrottleSettingsDef(BaseStruct):
    burst_limit: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum API request rate limit over a time ranging from one to a few seconds. Default: none\n')
    rate_limit: typing.Union[int, float, None] = pydantic.Field(None, description='The API request steady-state rate limit (average requests per second over an extended period of time). Default: none\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    throttle_settings = apigatewayv2.ThrottleSettings(\n        burst_limit=123,\n        rate_limit=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['burst_limit', 'rate_limit']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.ThrottleSettings'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.VpcLinkAttributes
class VpcLinkAttributesDef(BaseStruct):
    vpc: typing.Union[_REQUIRED_INIT_PARAM, models.aws_ec2.VpcDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The VPC to which this VPC link is associated with.\n')
    vpc_link_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The VPC Link id.\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_ec2 as ec2\n\n    # vpc: ec2.Vpc\n\n    awesome_link = apigwv2.VpcLink.from_vpc_link_attributes(self, "awesome-vpc-link",\n        vpc_link_id="us-east-1_oiuR12Abd",\n        vpc=vpc\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['vpc', 'vpc_link_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.VpcLinkAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.VpcLinkAttributesDefConfig] = pydantic.Field(None)


class VpcLinkAttributesDefConfig(pydantic.BaseModel):
    vpc_config: typing.Optional[models._interface_methods.AwsEc2IVpcDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigatewayv2.VpcLinkProps
class VpcLinkPropsDef(BaseStruct):
    vpc: typing.Union[_REQUIRED_INIT_PARAM, models.aws_ec2.VpcDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The VPC in which the private resources reside.\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='A list of security groups for the VPC link. Default: - no security groups. Use ``addSecurityGroups`` to add security groups\n')
    subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A list of subnets for the VPC link. Default: - private subnets of the provided VPC. Use ``addSubnets`` to add more subnets\n')
    vpc_link_name: typing.Optional[str] = pydantic.Field(None, description='The name used to label and identify the VPC link. Default: - automatically generated name\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_ec2 as ec2\n    import aws_cdk.aws_elasticloadbalancingv2 as elb\n    from aws_cdk.aws_apigatewayv2_integrations import HttpAlbIntegration\n\n\n    vpc = ec2.Vpc(self, "VPC")\n    alb = elb.ApplicationLoadBalancer(self, "AppLoadBalancer", vpc=vpc)\n\n    vpc_link = apigwv2.VpcLink(self, "VpcLink", vpc=vpc)\n\n    # Creating an HTTP ALB Integration:\n    alb_integration = HttpAlbIntegration("ALBIntegration", alb.listeners[0])\n')
    _init_params: typing.ClassVar[list[str]] = ['vpc', 'security_groups', 'subnets', 'vpc_link_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.VpcLinkProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.VpcLinkPropsDefConfig] = pydantic.Field(None)


class VpcLinkPropsDefConfig(pydantic.BaseModel):
    vpc_config: typing.Optional[models._interface_methods.AwsEc2IVpcDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketApiAttributes
class WebSocketApiAttributesDef(BaseStruct):
    web_socket_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier of the WebSocketApi.\n')
    api_endpoint: typing.Optional[str] = pydantic.Field(None, description='The endpoint URL of the WebSocketApi. Default: - throw san error if apiEndpoint is accessed.\n\n:exampleMetadata: infused\n\nExample::\n\n    web_socket_api = apigwv2.WebSocketApi.from_web_socket_api_attributes(self, "mywsapi", web_socket_id="api-1234")\n')
    _init_params: typing.ClassVar[list[str]] = ['web_socket_id', 'api_endpoint']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.WebSocketApiAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketApiProps
class WebSocketApiPropsDef(BaseStruct):
    api_key_selection_expression: typing.Optional[models.aws_apigatewayv2.WebSocketApiKeySelectionExpressionDef] = pydantic.Field(None, description='An API key selection expression. Providing this option will require an API Key be provided to access the API. Default: - Key is not required to access these APIs\n')
    api_name: typing.Optional[str] = pydantic.Field(None, description='Name for the WebSocket API resource. Default: - id of the WebSocketApi construct.\n')
    connect_route_options: typing.Union[models.aws_apigatewayv2.WebSocketRouteOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Options to configure a '$connect' route. Default: - no '$connect' route configured\n")
    default_route_options: typing.Union[models.aws_apigatewayv2.WebSocketRouteOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Options to configure a '$default' route. Default: - no '$default' route configured\n")
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the API. Default: - none\n')
    disconnect_route_options: typing.Union[models.aws_apigatewayv2.WebSocketRouteOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Options to configure a '$disconnect' route. Default: - no '$disconnect' route configured\n")
    route_selection_expression: typing.Optional[str] = pydantic.Field(None, description='The route selection expression for the API. Default: \'$request.body.action\'\n\n:exampleMetadata: infused\n\nExample::\n\n    from aws_cdk.aws_apigatewayv2_authorizers import WebSocketLambdaAuthorizer\n    from aws_cdk.aws_apigatewayv2_integrations import WebSocketLambdaIntegration\n\n    # This function handles your auth logic\n    # auth_handler: lambda.Function\n\n    # This function handles your WebSocket requests\n    # handler: lambda.Function\n\n\n    authorizer = WebSocketLambdaAuthorizer("Authorizer", auth_handler)\n\n    integration = WebSocketLambdaIntegration("Integration", handler)\n\n    apigwv2.WebSocketApi(self, "WebSocketApi",\n        connect_route_options=apigwv2.WebSocketRouteOptions(\n            integration=integration,\n            authorizer=authorizer\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['api_key_selection_expression', 'api_name', 'connect_route_options', 'default_route_options', 'description', 'disconnect_route_options', 'route_selection_expression']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.WebSocketApiProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketAuthorizerAttributes
class WebSocketAuthorizerAttributesDef(BaseStruct):
    authorizer_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Id of the Authorizer.\n')
    authorizer_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Type of authorizer. Possible values are: - CUSTOM - Lambda Authorizer - NONE - No Authorization\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    web_socket_authorizer_attributes = apigatewayv2.WebSocketAuthorizerAttributes(\n        authorizer_id="authorizerId",\n        authorizer_type="authorizerType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['authorizer_id', 'authorizer_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.WebSocketAuthorizerAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketAuthorizerProps
class WebSocketAuthorizerPropsDef(BaseStruct):
    identity_source: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identity source for which authorization is requested.\n')
    type: typing.Union[aws_cdk.aws_apigatewayv2.WebSocketAuthorizerType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of authorizer.\n')
    web_socket_api: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.WebSocketApiDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='WebSocket Api to attach the authorizer to.\n')
    authorizer_name: typing.Optional[str] = pydantic.Field(None, description='Name of the authorizer. Default: - id of the WebSocketAuthorizer construct.\n')
    authorizer_uri: typing.Optional[str] = pydantic.Field(None, description='The authorizer\'s Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI. Default: - required for Request authorizer types\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    # web_socket_api: apigatewayv2.WebSocketApi\n\n    web_socket_authorizer_props = apigatewayv2.WebSocketAuthorizerProps(\n        identity_source=["identitySource"],\n        type=apigatewayv2.WebSocketAuthorizerType.LAMBDA,\n        web_socket_api=web_socket_api,\n\n        # the properties below are optional\n        authorizer_name="authorizerName",\n        authorizer_uri="authorizerUri"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['identity_source', 'type', 'web_socket_api', 'authorizer_name', 'authorizer_uri']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.WebSocketAuthorizerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.WebSocketAuthorizerPropsDefConfig] = pydantic.Field(None)


class WebSocketAuthorizerPropsDefConfig(pydantic.BaseModel):
    web_socket_api_config: typing.Optional[models._interface_methods.AwsApigatewayv2IWebSocketApiDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketIntegrationProps
class WebSocketIntegrationPropsDef(BaseStruct):
    integration_type: typing.Union[aws_cdk.aws_apigatewayv2.WebSocketIntegrationType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Integration type.\n')
    integration_uri: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Integration URI.\n')
    web_socket_api: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.WebSocketApiDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The WebSocket API to which this integration should be bound.\n')
    content_handling: typing.Optional[aws_cdk.aws_apigatewayv2.ContentHandling] = pydantic.Field(None, description='Specifies how to handle response payload content type conversions. Default: - The response payload will be passed through from the integration response to the route response or method response without modification.\n')
    credentials_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='Specifies the IAM role required for the integration. Default: - No IAM role required.\n')
    integration_method: typing.Optional[str] = pydantic.Field(None, description="Specifies the integration's HTTP method type. Default: - No HTTP method required.\n")
    passthrough_behavior: typing.Optional[aws_cdk.aws_apigatewayv2.PassthroughBehavior] = pydantic.Field(None, description='Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Default: - No passthrough behavior required.\n')
    request_parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The request parameters that API Gateway sends with the backend request. Specify request parameters as key-value pairs (string-to-string mappings), with a destination as the key and a source as the value. Default: - No request parameters required.\n')
    request_templates: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='A map of Apache Velocity templates that are applied on the request payload. Example:: { "application/json": "{ \\"statusCode\\": 200 }" } Default: - No request templates required.\n')
    template_selection_expression: typing.Optional[str] = pydantic.Field(None, description='The template selection expression for the integration. Default: - No template selection expression required.\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum amount of time an integration will run before it returns without a response. Must be between 50 milliseconds and 29 seconds. Default: Duration.seconds(29)\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n    from aws_cdk import aws_iam as iam\n\n    # role: iam.Role\n    # web_socket_api: apigatewayv2.WebSocketApi\n\n    web_socket_integration_props = apigatewayv2.WebSocketIntegrationProps(\n        integration_type=apigatewayv2.WebSocketIntegrationType.AWS_PROXY,\n        integration_uri="integrationUri",\n        web_socket_api=web_socket_api,\n\n        # the properties below are optional\n        content_handling=apigatewayv2.ContentHandling.CONVERT_TO_BINARY,\n        credentials_role=role,\n        integration_method="integrationMethod",\n        passthrough_behavior=apigatewayv2.PassthroughBehavior.WHEN_NO_MATCH,\n        request_parameters={\n            "request_parameters_key": "requestParameters"\n        },\n        request_templates={\n            "request_templates_key": "requestTemplates"\n        },\n        template_selection_expression="templateSelectionExpression",\n        timeout=cdk.Duration.minutes(30)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['integration_type', 'integration_uri', 'web_socket_api', 'content_handling', 'credentials_role', 'integration_method', 'passthrough_behavior', 'request_parameters', 'request_templates', 'template_selection_expression', 'timeout']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.WebSocketIntegrationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.WebSocketIntegrationPropsDefConfig] = pydantic.Field(None)


class WebSocketIntegrationPropsDefConfig(pydantic.BaseModel):
    web_socket_api_config: typing.Optional[models._interface_methods.AwsApigatewayv2IWebSocketApiDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketRouteAuthorizerBindOptions
class WebSocketRouteAuthorizerBindOptionsDef(BaseStruct):
    route: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.WebSocketRouteDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The route to which the authorizer is being bound.\n')
    _init_params: typing.ClassVar[list[str]] = ['route']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.WebSocketRouteAuthorizerBindOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.WebSocketRouteAuthorizerBindOptionsDefConfig] = pydantic.Field(None)


class WebSocketRouteAuthorizerBindOptionsDefConfig(pydantic.BaseModel):
    route_config: typing.Optional[models._interface_methods.AwsApigatewayv2IWebSocketRouteDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketRouteAuthorizerConfig
class WebSocketRouteAuthorizerConfigDef(BaseStruct):
    authorization_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of authorization. Possible values are: - CUSTOM - Lambda Authorizer - NONE - No Authorization\n')
    authorizer_id: typing.Optional[str] = pydantic.Field(None, description='The authorizer id. Default: - No authorizer id (useful for AWS_IAM route authorizer)\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    web_socket_route_authorizer_config = apigatewayv2.WebSocketRouteAuthorizerConfig(\n        authorization_type="authorizationType",\n\n        # the properties below are optional\n        authorizer_id="authorizerId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['authorization_type', 'authorizer_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.WebSocketRouteAuthorizerConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketRouteIntegrationBindOptions
class WebSocketRouteIntegrationBindOptionsDef(BaseStruct):
    route: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.WebSocketRouteDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The route to which this is being bound.\n')
    _init_params: typing.ClassVar[list[str]] = ['route']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.WebSocketRouteIntegrationBindOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.WebSocketRouteIntegrationBindOptionsDefConfig] = pydantic.Field(None)


class WebSocketRouteIntegrationBindOptionsDefConfig(pydantic.BaseModel):
    route_config: typing.Optional[models._interface_methods.AwsApigatewayv2IWebSocketRouteDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketRouteIntegrationConfig
class WebSocketRouteIntegrationConfigDef(BaseStruct):
    type: typing.Union[aws_cdk.aws_apigatewayv2.WebSocketIntegrationType, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Integration type.\n')
    uri: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Integration URI.\n')
    content_handling: typing.Optional[aws_cdk.aws_apigatewayv2.ContentHandling] = pydantic.Field(None, description='Specifies how to handle response payload content type conversions. Default: - The response payload will be passed through from the integration response to the route response or method response without modification.\n')
    credentials_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='Credentials role. Default: - No role provided.\n')
    method: typing.Optional[str] = pydantic.Field(None, description='Integration method. Default: - No integration method.\n')
    passthrough_behavior: typing.Optional[aws_cdk.aws_apigatewayv2.PassthroughBehavior] = pydantic.Field(None, description='Integration passthrough behaviors. Default: - No pass through bahavior.\n')
    request_parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Request parameters. Default: - No request parameters provided.\n')
    request_templates: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Request template. Default: - No request template provided.\n')
    template_selection_expression: typing.Optional[str] = pydantic.Field(None, description='Template selection expression. Default: - No template selection expression.\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The maximum amount of time an integration will run before it returns without a response. Must be between 50 milliseconds and 29 seconds. Default: Duration.seconds(29)\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n    from aws_cdk import aws_iam as iam\n\n    # role: iam.Role\n\n    web_socket_route_integration_config = apigatewayv2.WebSocketRouteIntegrationConfig(\n        type=apigatewayv2.WebSocketIntegrationType.AWS_PROXY,\n        uri="uri",\n\n        # the properties below are optional\n        content_handling=apigatewayv2.ContentHandling.CONVERT_TO_BINARY,\n        credentials_role=role,\n        method="method",\n        passthrough_behavior=apigatewayv2.PassthroughBehavior.WHEN_NO_MATCH,\n        request_parameters={\n            "request_parameters_key": "requestParameters"\n        },\n        request_templates={\n            "request_templates_key": "requestTemplates"\n        },\n        template_selection_expression="templateSelectionExpression",\n        timeout=cdk.Duration.minutes(30)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'uri', 'content_handling', 'credentials_role', 'method', 'passthrough_behavior', 'request_parameters', 'request_templates', 'template_selection_expression', 'timeout']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.WebSocketRouteIntegrationConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketRouteOptions
class WebSocketRouteOptionsDef(BaseStruct):
    integration: typing.Union[models.aws_apigatewayv2.WebSocketRouteIntegrationDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The integration to be configured on this route.\n')
    authorizer: typing.Optional[typing.Union[models.aws_apigatewayv2.WebSocketNoneAuthorizerDef, models.aws_apigatewayv2_authorizers.WebSocketIamAuthorizerDef, models.aws_apigatewayv2_authorizers.WebSocketLambdaAuthorizerDef]] = pydantic.Field(None, description='The authorize to this route. You can only set authorizer to a $connect route. Default: - No Authorizer\n')
    return_response: typing.Optional[bool] = pydantic.Field(None, description='Should the route send a response to the client. Default: false\n\n:exampleMetadata: infused\n\nExample::\n\n    from aws_cdk.aws_apigatewayv2_integrations import WebSocketLambdaIntegration\n\n    # message_handler: lambda.Function\n\n\n    web_socket_api = apigwv2.WebSocketApi(self, "mywsapi")\n    apigwv2.WebSocketStage(self, "mystage",\n        web_socket_api=web_socket_api,\n        stage_name="dev",\n        auto_deploy=True\n    )\n    web_socket_api.add_route("sendMessage",\n        integration=WebSocketLambdaIntegration("SendMessageIntegration", message_handler)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['integration', 'authorizer', 'return_response']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.WebSocketRouteOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.WebSocketRouteOptionsDefConfig] = pydantic.Field(None)


class WebSocketRouteOptionsDefConfig(pydantic.BaseModel):
    integration_config: typing.Optional[models.aws_apigatewayv2.WebSocketRouteIntegrationDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketRouteProps
class WebSocketRoutePropsDef(BaseStruct):
    integration: typing.Union[models.aws_apigatewayv2.WebSocketRouteIntegrationDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The integration to be configured on this route.\n')
    authorizer: typing.Optional[typing.Union[models.aws_apigatewayv2.WebSocketNoneAuthorizerDef, models.aws_apigatewayv2_authorizers.WebSocketIamAuthorizerDef, models.aws_apigatewayv2_authorizers.WebSocketLambdaAuthorizerDef]] = pydantic.Field(None, description='The authorize to this route. You can only set authorizer to a $connect route. Default: - No Authorizer\n')
    return_response: typing.Optional[bool] = pydantic.Field(None, description='Should the route send a response to the client. Default: false\n')
    route_key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The key to this route.\n')
    web_socket_api: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.WebSocketApiDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API the route is associated with.\n')
    api_key_required: typing.Optional[bool] = pydantic.Field(None, description='Whether the route requires an API Key to be provided. Default: false\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    # web_socket_api: apigatewayv2.WebSocketApi\n    # web_socket_route_authorizer: apigatewayv2.IWebSocketRouteAuthorizer\n    # web_socket_route_integration: apigatewayv2.WebSocketRouteIntegration\n\n    web_socket_route_props = apigatewayv2.WebSocketRouteProps(\n        integration=web_socket_route_integration,\n        route_key="routeKey",\n        web_socket_api=web_socket_api,\n\n        # the properties below are optional\n        api_key_required=False,\n        authorizer=web_socket_route_authorizer,\n        return_response=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['integration', 'authorizer', 'return_response', 'route_key', 'web_socket_api', 'api_key_required']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.WebSocketRouteProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.WebSocketRoutePropsDefConfig] = pydantic.Field(None)


class WebSocketRoutePropsDefConfig(pydantic.BaseModel):
    integration_config: typing.Optional[models.aws_apigatewayv2.WebSocketRouteIntegrationDefConfig] = pydantic.Field(None)
    web_socket_api_config: typing.Optional[models._interface_methods.AwsApigatewayv2IWebSocketApiDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketStageAttributes
class WebSocketStageAttributesDef(BaseStruct):
    stage_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the stage.\n')
    api: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.WebSocketApiDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API to which this stage is associated.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    # web_socket_api: apigatewayv2.WebSocketApi\n\n    web_socket_stage_attributes = apigatewayv2.WebSocketStageAttributes(\n        api=web_socket_api,\n        stage_name="stageName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['stage_name', 'api']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.WebSocketStageAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.WebSocketStageAttributesDefConfig] = pydantic.Field(None)


class WebSocketStageAttributesDefConfig(pydantic.BaseModel):
    api_config: typing.Optional[models._interface_methods.AwsApigatewayv2IWebSocketApiDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketStageProps
class WebSocketStagePropsDef(BaseStruct):
    auto_deploy: typing.Optional[bool] = pydantic.Field(None, description='Whether updates to an API automatically trigger a new deployment. Default: false\n')
    domain_mapping: typing.Union[models.aws_apigatewayv2.DomainMappingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for custom domain and api mapping. Default: - no custom domain and api mapping configuration\n')
    throttle: typing.Union[models.aws_apigatewayv2.ThrottleSettingsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Throttle settings for the routes of this stage. Default: - no throttling configuration\n')
    stage_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the stage.\n')
    web_socket_api: typing.Union[_REQUIRED_INIT_PARAM, models.aws_apigatewayv2.WebSocketApiDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The WebSocket API to which this stage is associated.\n\n:exampleMetadata: infused\n\nExample::\n\n    from aws_cdk.aws_apigatewayv2_integrations import WebSocketLambdaIntegration\n\n    # connect_handler: lambda.Function\n    # disconnect_handler: lambda.Function\n    # default_handler: lambda.Function\n\n\n    web_socket_api = apigwv2.WebSocketApi(self, "mywsapi",\n        connect_route_options=apigwv2.WebSocketRouteOptions(integration=WebSocketLambdaIntegration("ConnectIntegration", connect_handler)),\n        disconnect_route_options=apigwv2.WebSocketRouteOptions(integration=WebSocketLambdaIntegration("DisconnectIntegration", disconnect_handler)),\n        default_route_options=apigwv2.WebSocketRouteOptions(integration=WebSocketLambdaIntegration("DefaultIntegration", default_handler))\n    )\n\n    apigwv2.WebSocketStage(self, "mystage",\n        web_socket_api=web_socket_api,\n        stage_name="dev",\n        auto_deploy=True\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['auto_deploy', 'domain_mapping', 'throttle', 'stage_name', 'web_socket_api']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.WebSocketStageProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.WebSocketStagePropsDefConfig] = pydantic.Field(None)


class WebSocketStagePropsDefConfig(pydantic.BaseModel):
    web_socket_api_config: typing.Optional[models._interface_methods.AwsApigatewayv2IWebSocketApiDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_apigatewayv2.AuthorizerPayloadVersion
# skipping emum

#  autogenerated from aws_cdk.aws_apigatewayv2.ContentHandling
# skipping emum

#  autogenerated from aws_cdk.aws_apigatewayv2.CorsHttpMethod
# skipping emum

#  autogenerated from aws_cdk.aws_apigatewayv2.EndpointType
# skipping emum

#  autogenerated from aws_cdk.aws_apigatewayv2.HttpAuthorizerType
# skipping emum

#  autogenerated from aws_cdk.aws_apigatewayv2.HttpConnectionType
# skipping emum

#  autogenerated from aws_cdk.aws_apigatewayv2.HttpIntegrationSubtype
# skipping emum

#  autogenerated from aws_cdk.aws_apigatewayv2.HttpIntegrationType
# skipping emum

#  autogenerated from aws_cdk.aws_apigatewayv2.HttpMethod
# skipping emum

#  autogenerated from aws_cdk.aws_apigatewayv2.PassthroughBehavior
# skipping emum

#  autogenerated from aws_cdk.aws_apigatewayv2.SecurityPolicy
# skipping emum

#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketAuthorizerType
# skipping emum

#  autogenerated from aws_cdk.aws_apigatewayv2.WebSocketIntegrationType
# skipping emum

#  autogenerated from aws_cdk.aws_apigatewayv2.IApi
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigatewayv2.IApiMapping
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigatewayv2.IAuthorizer
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigatewayv2.IDomainName
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigatewayv2.IHttpApi
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigatewayv2.IHttpAuthorizer
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigatewayv2.IHttpIntegration
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigatewayv2.IHttpRoute
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigatewayv2.IHttpRouteAuthorizer
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigatewayv2.IHttpStage
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigatewayv2.IIntegration
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigatewayv2.IMappingValue
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigatewayv2.IRoute
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigatewayv2.IStage
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigatewayv2.IVpcLink
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigatewayv2.IWebSocketApi
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigatewayv2.IWebSocketAuthorizer
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigatewayv2.IWebSocketIntegration
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigatewayv2.IWebSocketRoute
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigatewayv2.IWebSocketRouteAuthorizer
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigatewayv2.IWebSocketStage
#  skipping Interface

#  autogenerated from aws_cdk.aws_apigatewayv2.CfnApi
class CfnApiDef(BaseCfnResource):
    api_key_selection_expression: typing.Optional[str] = pydantic.Field(None, description='An API key selection expression. Supported only for WebSocket APIs. See `API Key Selection Expressions <https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions>`_ .\n')
    base_path: typing.Optional[str] = pydantic.Field(None, description='Specifies how to interpret the base path of the API during import. Valid values are ``ignore`` , ``prepend`` , and ``split`` . The default value is ``ignore`` . To learn more, see `Set the OpenAPI basePath Property <https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-import-api-basePath.html>`_ . Supported only for HTTP APIs.\n')
    body: typing.Any = pydantic.Field(None, description="The OpenAPI definition. Supported only for HTTP APIs. To import an HTTP API, you must specify a ``Body`` or ``BodyS3Location`` . If you specify a ``Body`` or ``BodyS3Location`` , don't specify CloudFormation resources such as ``AWS::ApiGatewayV2::Authorizer`` or ``AWS::ApiGatewayV2::Route`` . API Gateway doesn't support the combination of OpenAPI and CloudFormation resources.\n")
    body_s3_location: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnApi_BodyS3LocationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The S3 location of an OpenAPI definition. Supported only for HTTP APIs. To import an HTTP API, you must specify a ``Body`` or ``BodyS3Location`` . If you specify a ``Body`` or ``BodyS3Location`` , don't specify CloudFormation resources such as ``AWS::ApiGatewayV2::Authorizer`` or ``AWS::ApiGatewayV2::Route`` . API Gateway doesn't support the combination of OpenAPI and CloudFormation resources.\n")
    cors_configuration: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnApi_CorsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A CORS configuration. Supported only for HTTP APIs. See `Configuring CORS <https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-cors.html>`_ for more information.\n')
    credentials_arn: typing.Optional[str] = pydantic.Field(None, description="This property is part of quick create. It specifies the credentials required for the integration, if any. For a Lambda integration, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify ``arn:aws:iam::*:user/*`` . To use resource-based permissions on supported AWS services, specify ``null`` . Currently, this property is not used for HTTP integrations. Supported only for HTTP APIs.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the API.\n')
    disable_execute_api_endpoint: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether clients can invoke your API by using the default ``execute-api`` endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.\n')
    disable_schema_validation: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Avoid validating models when creating a deployment. Supported only for WebSocket APIs.\n')
    fail_on_warnings: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether to rollback the API creation when a warning is encountered. By default, API creation continues if a warning is encountered.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the API. Required unless you specify an OpenAPI definition for ``Body`` or ``S3BodyLocation`` .\n')
    protocol_type: typing.Optional[str] = pydantic.Field(None, description='The API protocol. Valid values are ``WEBSOCKET`` or ``HTTP`` . Required unless you specify an OpenAPI definition for ``Body`` or ``S3BodyLocation`` .\n')
    route_key: typing.Optional[str] = pydantic.Field(None, description="This property is part of quick create. If you don't specify a ``routeKey`` , a default route of ``$default`` is created. The ``$default`` route acts as a catch-all for any request made to your API, for a particular stage. The ``$default`` route key can't be modified. You can add routes after creating the API, and you can update the route keys of additional routes. Supported only for HTTP APIs.\n")
    route_selection_expression: typing.Optional[str] = pydantic.Field(None, description='The route selection expression for the API. For HTTP APIs, the ``routeSelectionExpression`` must be ``${request.method} ${request.path}`` . If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The collection of tags. Each tag element is associated with a given resource.\n')
    target: typing.Optional[str] = pydantic.Field(None, description='This property is part of quick create. Quick create produces an API with an integration, a default catch-all route, and a default stage which is configured to automatically deploy changes. For HTTP integrations, specify a fully qualified URL. For Lambda integrations, specify a function ARN. The type of the integration will be HTTP_PROXY or AWS_PROXY, respectively. Supported only for HTTP APIs.\n')
    version: typing.Optional[str] = pydantic.Field(None, description='A version identifier for the API.')
    _init_params: typing.ClassVar[list[str]] = ['api_key_selection_expression', 'base_path', 'body', 'body_s3_location', 'cors_configuration', 'credentials_arn', 'description', 'disable_execute_api_endpoint', 'disable_schema_validation', 'fail_on_warnings', 'name', 'protocol_type', 'route_key', 'route_selection_expression', 'tags', 'target', 'version']
    _method_names: typing.ClassVar[list[str]] = ['BodyS3LocationProperty', 'CorsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnApi'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.CfnApiDefConfig] = pydantic.Field(None)


class CfnApiDefConfig(pydantic.BaseModel):
    BodyS3LocationProperty: typing.Optional[list[models.aws_apigatewayv2.CfnApiDefBodys3LocationpropertyParams]] = pydantic.Field(None, description='')
    CorsProperty: typing.Optional[list[models.aws_apigatewayv2.CfnApiDefCorspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnApiDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnApiDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_apigatewayv2.CfnApiDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnApiDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_apigatewayv2.CfnApiDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnApiDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_apigatewayv2.CfnApiDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_apigatewayv2.CfnApiDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnApiDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_apigatewayv2.CfnApiDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_apigatewayv2.CfnApiDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnApiDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnApiDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnApiDefBodys3LocationpropertyParams(pydantic.BaseModel):
    bucket: typing.Optional[str] = pydantic.Field(None, description='')
    etag: typing.Optional[str] = pydantic.Field(None, description='')
    key: typing.Optional[str] = pydantic.Field(None, description='')
    version: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnApiDefCorspropertyParams(pydantic.BaseModel):
    allow_credentials: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    allow_headers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    allow_methods: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    allow_origins: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    expose_headers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    max_age: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnApiDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnApiDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnApiDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnApiDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnApiDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnApiDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnApiDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnApiDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnApiDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnApiDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnApiDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnApiDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnApiDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnApiDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.CfnApiGatewayManagedOverrides
class CfnApiGatewayManagedOverridesDef(BaseCfnResource):
    api_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the API for which to override the configuration of API Gateway-managed resources.\n')
    integration: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnApiGatewayManagedOverrides_IntegrationOverridesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Overrides the integration configuration for an API Gateway-managed integration.\n')
    route: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnApiGatewayManagedOverrides_RouteOverridesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Overrides the route configuration for an API Gateway-managed route.\n')
    stage: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnApiGatewayManagedOverrides_StageOverridesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Overrides the stage configuration for an API Gateway-managed stage.')
    _init_params: typing.ClassVar[list[str]] = ['api_id', 'integration', 'route', 'stage']
    _method_names: typing.ClassVar[list[str]] = ['AccessLogSettingsProperty', 'IntegrationOverridesProperty', 'RouteOverridesProperty', 'RouteSettingsProperty', 'StageOverridesProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnApiGatewayManagedOverrides'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.CfnApiGatewayManagedOverridesDefConfig] = pydantic.Field(None)


class CfnApiGatewayManagedOverridesDefConfig(pydantic.BaseModel):
    AccessLogSettingsProperty: typing.Optional[list[models.aws_apigatewayv2.CfnApiGatewayManagedOverridesDefAccesslogsettingspropertyParams]] = pydantic.Field(None, description='')
    IntegrationOverridesProperty: typing.Optional[list[models.aws_apigatewayv2.CfnApiGatewayManagedOverridesDefIntegrationoverridespropertyParams]] = pydantic.Field(None, description='')
    RouteOverridesProperty: typing.Optional[list[models.aws_apigatewayv2.CfnApiGatewayManagedOverridesDefRouteoverridespropertyParams]] = pydantic.Field(None, description='')
    RouteSettingsProperty: typing.Optional[list[models.aws_apigatewayv2.CfnApiGatewayManagedOverridesDefRoutesettingspropertyParams]] = pydantic.Field(None, description='')
    StageOverridesProperty: typing.Optional[list[models.aws_apigatewayv2.CfnApiGatewayManagedOverridesDefStageoverridespropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnApiGatewayManagedOverridesDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnApiGatewayManagedOverridesDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_apigatewayv2.CfnApiGatewayManagedOverridesDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnApiGatewayManagedOverridesDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_apigatewayv2.CfnApiGatewayManagedOverridesDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnApiGatewayManagedOverridesDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_apigatewayv2.CfnApiGatewayManagedOverridesDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_apigatewayv2.CfnApiGatewayManagedOverridesDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnApiGatewayManagedOverridesDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_apigatewayv2.CfnApiGatewayManagedOverridesDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_apigatewayv2.CfnApiGatewayManagedOverridesDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnApiGatewayManagedOverridesDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnApiGatewayManagedOverridesDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnApiGatewayManagedOverridesDefAccesslogsettingspropertyParams(pydantic.BaseModel):
    destination_arn: typing.Optional[str] = pydantic.Field(None, description='')
    format: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnApiGatewayManagedOverridesDefIntegrationoverridespropertyParams(pydantic.BaseModel):
    description: typing.Optional[str] = pydantic.Field(None, description='')
    integration_method: typing.Optional[str] = pydantic.Field(None, description='')
    payload_format_version: typing.Optional[str] = pydantic.Field(None, description='')
    timeout_in_millis: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnApiGatewayManagedOverridesDefRouteoverridespropertyParams(pydantic.BaseModel):
    authorization_scopes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    authorization_type: typing.Optional[str] = pydantic.Field(None, description='')
    authorizer_id: typing.Optional[str] = pydantic.Field(None, description='')
    operation_name: typing.Optional[str] = pydantic.Field(None, description='')
    target: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnApiGatewayManagedOverridesDefRoutesettingspropertyParams(pydantic.BaseModel):
    data_trace_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    detailed_metrics_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    logging_level: typing.Optional[str] = pydantic.Field(None, description='')
    throttling_burst_limit: typing.Union[int, float, None] = pydantic.Field(None, description='')
    throttling_rate_limit: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnApiGatewayManagedOverridesDefStageoverridespropertyParams(pydantic.BaseModel):
    access_log_settings: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnApiGatewayManagedOverrides_AccessLogSettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    auto_deploy: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    default_route_settings: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnApiGatewayManagedOverrides_RouteSettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    route_settings: typing.Any = pydantic.Field(None, description='')
    stage_variables: typing.Any = pydantic.Field(None, description='')
    ...

class CfnApiGatewayManagedOverridesDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnApiGatewayManagedOverridesDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnApiGatewayManagedOverridesDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnApiGatewayManagedOverridesDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnApiGatewayManagedOverridesDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnApiGatewayManagedOverridesDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnApiGatewayManagedOverridesDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnApiGatewayManagedOverridesDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnApiGatewayManagedOverridesDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnApiGatewayManagedOverridesDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnApiGatewayManagedOverridesDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnApiGatewayManagedOverridesDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnApiGatewayManagedOverridesDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnApiGatewayManagedOverridesDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.CfnApiMapping
class CfnApiMappingDef(BaseCfnResource):
    api_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API identifier.\n')
    domain_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The domain name.\n')
    stage: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API stage.\n')
    api_mapping_key: typing.Optional[str] = pydantic.Field(None, description='The API mapping key.')
    _init_params: typing.ClassVar[list[str]] = ['api_id', 'domain_name', 'stage', 'api_mapping_key']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnApiMapping'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.CfnApiMappingDefConfig] = pydantic.Field(None)


class CfnApiMappingDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnApiMappingDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnApiMappingDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_apigatewayv2.CfnApiMappingDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnApiMappingDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_apigatewayv2.CfnApiMappingDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnApiMappingDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_apigatewayv2.CfnApiMappingDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_apigatewayv2.CfnApiMappingDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnApiMappingDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_apigatewayv2.CfnApiMappingDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_apigatewayv2.CfnApiMappingDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnApiMappingDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnApiMappingDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnApiMappingDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnApiMappingDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnApiMappingDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnApiMappingDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnApiMappingDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnApiMappingDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnApiMappingDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnApiMappingDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnApiMappingDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnApiMappingDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnApiMappingDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnApiMappingDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnApiMappingDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnApiMappingDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.CfnAuthorizer
class CfnAuthorizerDef(BaseCfnResource):
    api_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API identifier.\n')
    authorizer_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The authorizer type. Specify ``REQUEST`` for a Lambda function using incoming request parameters. Specify ``JWT`` to use JSON Web Tokens (supported only for HTTP APIs).\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the authorizer.\n')
    authorizer_credentials_arn: typing.Optional[str] = pydantic.Field(None, description="Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null. Supported only for ``REQUEST`` authorizers.\n")
    authorizer_payload_format_version: typing.Optional[str] = pydantic.Field(None, description='Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are ``1.0`` and ``2.0`` . To learn more, see `Working with AWS Lambda authorizers for HTTP APIs <https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html>`_ .\n')
    authorizer_result_ttl_in_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.\n')
    authorizer_uri: typing.Optional[str] = pydantic.Field(None, description="The authorizer's Uniform Resource Identifier (URI). For ``REQUEST`` authorizers, this must be a well-formed Lambda function URI, for example, ``arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2: *{account_id}* :function: *{lambda_function_name}* /invocations`` . In general, the URI has this form: ``arn:aws:apigateway: *{region}* :lambda:path/ *{service_api}*`` , where *{region}* is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial ``/`` . For Lambda functions, this is usually of the form ``/2015-03-31/functions/[FunctionARN]/invocations`` .\n")
    enable_simple_responses: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether a Lambda authorizer returns a response in a simple format. By default, a Lambda authorizer must return an IAM policy. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see `Working with AWS Lambda authorizers for HTTP APIs <https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html>`_ .\n')
    identity_source: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The identity source for which authorization is requested. For a ``REQUEST`` authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with ``$`` , for example, ``$request.header.Auth`` , ``$request.querystring.Name`` . These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see `Working with AWS Lambda authorizers for HTTP APIs <https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html>`_ . For ``JWT`` , a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example ``$request.header.Authorization`` .\n')
    identity_validation_expression: typing.Optional[str] = pydantic.Field(None, description='This parameter is not used.\n')
    jwt_configuration: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnAuthorizer_JWTConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The ``JWTConfiguration`` property specifies the configuration of a JWT authorizer. Required for the ``JWT`` authorizer type. Supported only for HTTP APIs.')
    _init_params: typing.ClassVar[list[str]] = ['api_id', 'authorizer_type', 'name', 'authorizer_credentials_arn', 'authorizer_payload_format_version', 'authorizer_result_ttl_in_seconds', 'authorizer_uri', 'enable_simple_responses', 'identity_source', 'identity_validation_expression', 'jwt_configuration']
    _method_names: typing.ClassVar[list[str]] = ['JWTConfigurationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnAuthorizer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.CfnAuthorizerDefConfig] = pydantic.Field(None)


class CfnAuthorizerDefConfig(pydantic.BaseModel):
    JWTConfigurationProperty: typing.Optional[list[models.aws_apigatewayv2.CfnAuthorizerDefJwtconfigurationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnAuthorizerDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnAuthorizerDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_apigatewayv2.CfnAuthorizerDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnAuthorizerDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_apigatewayv2.CfnAuthorizerDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnAuthorizerDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_apigatewayv2.CfnAuthorizerDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_apigatewayv2.CfnAuthorizerDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnAuthorizerDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_apigatewayv2.CfnAuthorizerDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_apigatewayv2.CfnAuthorizerDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnAuthorizerDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnAuthorizerDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnAuthorizerDefJwtconfigurationpropertyParams(pydantic.BaseModel):
    audience: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    issuer: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAuthorizerDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAuthorizerDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAuthorizerDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAuthorizerDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAuthorizerDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAuthorizerDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAuthorizerDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAuthorizerDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAuthorizerDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAuthorizerDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAuthorizerDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnAuthorizerDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAuthorizerDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAuthorizerDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.CfnDeployment
class CfnDeploymentDef(BaseCfnResource):
    api_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API identifier.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description for the deployment resource.\n')
    stage_name: typing.Optional[str] = pydantic.Field(None, description='The name of an existing stage to associate with the deployment.')
    _init_params: typing.ClassVar[list[str]] = ['api_id', 'description', 'stage_name']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnDeployment'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.CfnDeploymentDefConfig] = pydantic.Field(None)


class CfnDeploymentDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnDeploymentDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnDeploymentDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_apigatewayv2.CfnDeploymentDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnDeploymentDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_apigatewayv2.CfnDeploymentDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnDeploymentDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_apigatewayv2.CfnDeploymentDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_apigatewayv2.CfnDeploymentDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnDeploymentDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_apigatewayv2.CfnDeploymentDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_apigatewayv2.CfnDeploymentDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnDeploymentDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnDeploymentDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnDeploymentDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDeploymentDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDeploymentDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDeploymentDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDeploymentDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDeploymentDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDeploymentDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDeploymentDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDeploymentDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDeploymentDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDeploymentDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDeploymentDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDeploymentDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDeploymentDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.CfnDomainName
class CfnDomainNameDef(BaseCfnResource):
    domain_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The custom domain name for your API in Amazon API Gateway. Uppercase letters are not supported.\n')
    domain_name_configurations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnDomainName_DomainNameConfigurationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The domain name configurations.\n')
    mutual_tls_authentication: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnDomainName_MutualTlsAuthenticationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The mutual TLS authentication configuration for a custom domain name.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The collection of tags associated with a domain name.')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'domain_name_configurations', 'mutual_tls_authentication', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['DomainNameConfigurationProperty', 'MutualTlsAuthenticationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnDomainName'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.CfnDomainNameDefConfig] = pydantic.Field(None)


class CfnDomainNameDefConfig(pydantic.BaseModel):
    DomainNameConfigurationProperty: typing.Optional[list[models.aws_apigatewayv2.CfnDomainNameDefDomainnameconfigurationpropertyParams]] = pydantic.Field(None, description='')
    MutualTlsAuthenticationProperty: typing.Optional[list[models.aws_apigatewayv2.CfnDomainNameDefMutualtlsauthenticationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnDomainNameDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnDomainNameDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_apigatewayv2.CfnDomainNameDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnDomainNameDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_apigatewayv2.CfnDomainNameDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnDomainNameDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_apigatewayv2.CfnDomainNameDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_apigatewayv2.CfnDomainNameDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnDomainNameDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_apigatewayv2.CfnDomainNameDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_apigatewayv2.CfnDomainNameDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnDomainNameDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnDomainNameDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDomainNameDefDomainnameconfigurationpropertyParams(pydantic.BaseModel):
    certificate_arn: typing.Optional[str] = pydantic.Field(None, description='')
    certificate_name: typing.Optional[str] = pydantic.Field(None, description='')
    endpoint_type: typing.Optional[str] = pydantic.Field(None, description='')
    ownership_verification_certificate_arn: typing.Optional[str] = pydantic.Field(None, description='')
    security_policy: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDomainNameDefMutualtlsauthenticationpropertyParams(pydantic.BaseModel):
    truststore_uri: typing.Optional[str] = pydantic.Field(None, description='')
    truststore_version: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDomainNameDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDomainNameDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDomainNameDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDomainNameDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDomainNameDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDomainNameDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDomainNameDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDomainNameDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDomainNameDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDomainNameDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDomainNameDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDomainNameDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDomainNameDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDomainNameDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.CfnIntegration
class CfnIntegrationDef(BaseCfnResource):
    api_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API identifier.\n')
    integration_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The integration type of an integration. One of the following:. ``AWS`` : for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. ``AWS_PROXY`` : for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. ``HTTP`` : for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. ``HTTP_PROXY`` : for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. For HTTP API private integrations, use an ``HTTP_PROXY`` integration. ``MOCK`` : for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.\n')
    connection_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the VPC link for a private integration. Supported only for HTTP APIs.\n')
    connection_type: typing.Optional[str] = pydantic.Field(None, description='The type of the network connection to the integration endpoint. Specify ``INTERNET`` for connections through the public routable internet or ``VPC_LINK`` for private connections between API Gateway and resources in a VPC. The default value is ``INTERNET`` .\n')
    content_handling_strategy: typing.Optional[str] = pydantic.Field(None, description='Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are ``CONVERT_TO_BINARY`` and ``CONVERT_TO_TEXT`` , with the following behaviors: ``CONVERT_TO_BINARY`` : Converts a response payload from a Base64-encoded string to the corresponding binary blob. ``CONVERT_TO_TEXT`` : Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.\n')
    credentials_arn: typing.Optional[str] = pydantic.Field(None, description="Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string ``arn:aws:iam::*:user/*`` . To use resource-based permissions on supported AWS services, don't specify this parameter.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the integration.\n')
    integration_method: typing.Optional[str] = pydantic.Field(None, description="Specifies the integration's HTTP method type. For WebSocket APIs, if you use a Lambda integration, you must set the integration method to ``POST`` .\n")
    integration_subtype: typing.Optional[str] = pydantic.Field(None, description='Supported only for HTTP API ``AWS_PROXY`` integrations. Specifies the AWS service action to invoke. To learn more, see `Integration subtype reference <https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html>`_ .\n')
    integration_uri: typing.Optional[str] = pydantic.Field(None, description='For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses ``DiscoverInstances`` to identify resources. You can use query parameters to target specific resources. To learn more, see `DiscoverInstances <https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html>`_ . For private integrations, all resources must be owned by the same AWS account .\n')
    passthrough_behavior: typing.Optional[str] = pydantic.Field(None, description='Specifies the pass-through behavior for incoming requests based on the ``Content-Type`` header in the request, and the available mapping templates specified as the ``requestTemplates`` property on the ``Integration`` resource. There are three valid values: ``WHEN_NO_MATCH`` , ``WHEN_NO_TEMPLATES`` , and ``NEVER`` . Supported only for WebSocket APIs. ``WHEN_NO_MATCH`` passes the request body for unmapped content types through to the integration backend without transformation. ``NEVER`` rejects unmapped content types with an ``HTTP 415 Unsupported Media Type`` response. ``WHEN_NO_TEMPLATES`` allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same ``HTTP 415 Unsupported Media Type`` response.\n')
    payload_format_version: typing.Optional[str] = pydantic.Field(None, description='Specifies the format of the payload sent to an integration. Required for HTTP APIs. For HTTP APIs, supported values for Lambda proxy integrations are ``1.0`` and ``2.0`` . For all other integrations, ``1.0`` is the only supported value. To learn more, see `Working with AWS Lambda proxy integrations for HTTP APIs <https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html>`_ .\n')
    request_parameters: typing.Any = pydantic.Field(None, description='For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of ``method.request. {location} . {name}`` , where ``{location}`` is ``querystring`` , ``path`` , or ``header`` ; and ``{name}`` must be a valid and unique method request parameter name. For HTTP API integrations with a specified ``integrationSubtype`` , request parameters are a key-value map specifying parameters that are passed to ``AWS_PROXY`` integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see `Working with AWS service integrations for HTTP APIs <https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html>`_ . For HTTP API integrations without a specified ``integrationSubtype`` request parameters are a key-value map specifying how to transform HTTP requests before sending them to the backend. The key should follow the pattern :<header|querystring|path>. where action can be ``append`` , ``overwrite`` or ``remove`` . For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see `Transforming API requests and responses <https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html>`_ .\n')
    request_templates: typing.Any = pydantic.Field(None, description='Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.\n')
    response_parameters: typing.Any = pydantic.Field(None, description='Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. The value is of type ```ResponseParameterList`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigatewayv2-integration-responseparameterlist.html>`_ . To learn more, see `Transforming API requests and responses <https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html>`_ .\n')
    template_selection_expression: typing.Optional[str] = pydantic.Field(None, description='The template selection expression for the integration. Supported only for WebSocket APIs.\n')
    timeout_in_millis: typing.Union[int, float, None] = pydantic.Field(None, description='Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.\n')
    tls_config: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnIntegration_TlsConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.')
    _init_params: typing.ClassVar[list[str]] = ['api_id', 'integration_type', 'connection_id', 'connection_type', 'content_handling_strategy', 'credentials_arn', 'description', 'integration_method', 'integration_subtype', 'integration_uri', 'passthrough_behavior', 'payload_format_version', 'request_parameters', 'request_templates', 'response_parameters', 'template_selection_expression', 'timeout_in_millis', 'tls_config']
    _method_names: typing.ClassVar[list[str]] = ['ResponseParameterListProperty', 'ResponseParameterProperty', 'TlsConfigProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnIntegration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.CfnIntegrationDefConfig] = pydantic.Field(None)


class CfnIntegrationDefConfig(pydantic.BaseModel):
    ResponseParameterListProperty: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationDefResponseparameterlistpropertyParams]] = pydantic.Field(None, description='')
    ResponseParameterProperty: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationDefResponseparameterpropertyParams]] = pydantic.Field(None, description='')
    TlsConfigProperty: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationDefTlsconfigpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnIntegrationDefResponseparameterlistpropertyParams(pydantic.BaseModel):
    response_parameters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnIntegration_ResponseParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnIntegrationDefResponseparameterpropertyParams(pydantic.BaseModel):
    destination: str = pydantic.Field(..., description='')
    source: str = pydantic.Field(..., description='')
    ...

class CfnIntegrationDefTlsconfigpropertyParams(pydantic.BaseModel):
    server_name_to_verify: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnIntegrationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnIntegrationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIntegrationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnIntegrationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIntegrationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnIntegrationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnIntegrationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnIntegrationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnIntegrationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnIntegrationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIntegrationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnIntegrationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnIntegrationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIntegrationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.CfnIntegrationResponse
class CfnIntegrationResponseDef(BaseCfnResource):
    api_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API identifier.\n')
    integration_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The integration ID.\n')
    integration_response_key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The integration response key.\n')
    content_handling_strategy: typing.Optional[str] = pydantic.Field(None, description='Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are ``CONVERT_TO_BINARY`` and ``CONVERT_TO_TEXT`` , with the following behaviors: ``CONVERT_TO_BINARY`` : Converts a response payload from a Base64-encoded string to the corresponding binary blob. ``CONVERT_TO_TEXT`` : Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.\n')
    response_parameters: typing.Any = pydantic.Field(None, description='A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of ``method.response.header. *{name}*`` , where name is a valid and unique header name. The mapped non-static value must match the pattern of ``integration.response.header. *{name}*`` or ``integration.response.body. *{JSON-expression}*`` , where ``*{name}*`` is a valid and unique response header name and ``*{JSON-expression}*`` is a valid JSON expression without the ``$`` prefix.\n')
    response_templates: typing.Any = pydantic.Field(None, description='The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.\n')
    template_selection_expression: typing.Optional[str] = pydantic.Field(None, description='The template selection expression for the integration response. Supported only for WebSocket APIs.')
    _init_params: typing.ClassVar[list[str]] = ['api_id', 'integration_id', 'integration_response_key', 'content_handling_strategy', 'response_parameters', 'response_templates', 'template_selection_expression']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnIntegrationResponse'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.CfnIntegrationResponseDefConfig] = pydantic.Field(None)


class CfnIntegrationResponseDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationResponseDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationResponseDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationResponseDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationResponseDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationResponseDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationResponseDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationResponseDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationResponseDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationResponseDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationResponseDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationResponseDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationResponseDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnIntegrationResponseDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnIntegrationResponseDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnIntegrationResponseDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIntegrationResponseDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnIntegrationResponseDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIntegrationResponseDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnIntegrationResponseDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnIntegrationResponseDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnIntegrationResponseDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnIntegrationResponseDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnIntegrationResponseDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIntegrationResponseDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnIntegrationResponseDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnIntegrationResponseDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIntegrationResponseDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.CfnModel
class CfnModelDef(BaseCfnResource):
    api_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API identifier.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the model.\n')
    schema_: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The schema for the model. For application/json models, this should be JSON schema draft 4 model.\n', alias='schema')
    content_type: typing.Optional[str] = pydantic.Field(None, description='The content-type for the model, for example, "application/json".\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the model.')
    _init_params: typing.ClassVar[list[str]] = ['api_id', 'name', 'schema', 'content_type', 'description']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnModel'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.CfnModelDefConfig] = pydantic.Field(None)


class CfnModelDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnModelDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnModelDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_apigatewayv2.CfnModelDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnModelDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_apigatewayv2.CfnModelDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnModelDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_apigatewayv2.CfnModelDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_apigatewayv2.CfnModelDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnModelDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_apigatewayv2.CfnModelDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_apigatewayv2.CfnModelDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnModelDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnModelDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnModelDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnModelDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnModelDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnModelDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnModelDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnModelDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnModelDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnModelDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnModelDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnModelDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnModelDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnModelDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnModelDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnModelDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.CfnRoute
class CfnRouteDef(BaseCfnResource):
    api_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API identifier.\n')
    route_key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The route key for the route. For HTTP APIs, the route key can be either ``$default`` , or a combination of an HTTP method and resource path, for example, ``GET /pets`` .\n')
    api_key_required: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether an API key is required for the route. Supported only for WebSocket APIs.\n')
    authorization_scopes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The authorization scopes supported by this route.\n')
    authorization_type: typing.Optional[str] = pydantic.Field(None, description='The authorization type for the route. For WebSocket APIs, valid values are ``NONE`` for open access, ``AWS_IAM`` for using AWS IAM permissions, and ``CUSTOM`` for using a Lambda authorizer. For HTTP APIs, valid values are ``NONE`` for open access, ``JWT`` for using JSON Web Tokens, ``AWS_IAM`` for using AWS IAM permissions, and ``CUSTOM`` for using a Lambda authorizer.\n')
    authorizer_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the ``Authorizer`` resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.\n')
    model_config = pydantic.ConfigDict(protected_namespaces=())
    model_selection_expression_: typing.Optional[str] = pydantic.Field(None, description='The model selection expression for the route. Supported only for WebSocket APIs.\n', alias='model_selection_expression')
    operation_name_: typing.Optional[str] = pydantic.Field(None, description='The operation name for the route.\n', alias='operation_name')
    request_models_: typing.Any = pydantic.Field(None, description='The request models for the route. Supported only for WebSocket APIs.\n', alias='request_models')
    request_parameters_: typing.Any = pydantic.Field(None, description='The request parameters for the route. Supported only for WebSocket APIs.\n', alias='request_parameters')
    route_response_selection_expression_: typing.Optional[str] = pydantic.Field(None, description='The route response selection expression for the route. Supported only for WebSocket APIs.\n', alias='route_response_selection_expression')
    target_: typing.Optional[str] = pydantic.Field(None, description='The target for the route.', alias='target')
    _init_params: typing.ClassVar[list[str]] = ['api_id', 'route_key', 'api_key_required', 'authorization_scopes', 'authorization_type', 'authorizer_id', 'model_selection_expression', 'operation_name', 'request_models', 'request_parameters', 'route_response_selection_expression', 'target']
    _method_names: typing.ClassVar[list[str]] = ['ParameterConstraintsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnRoute'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.CfnRouteDefConfig] = pydantic.Field(None)


class CfnRouteDefConfig(pydantic.BaseModel):
    ParameterConstraintsProperty: typing.Optional[list[models.aws_apigatewayv2.CfnRouteDefParameterconstraintspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnRouteDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnRouteDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_apigatewayv2.CfnRouteDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnRouteDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_apigatewayv2.CfnRouteDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnRouteDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_apigatewayv2.CfnRouteDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_apigatewayv2.CfnRouteDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnRouteDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_apigatewayv2.CfnRouteDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_apigatewayv2.CfnRouteDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnRouteDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnRouteDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnRouteDefParameterconstraintspropertyParams(pydantic.BaseModel):
    required: typing.Union[bool, models.UnsupportedResource] = pydantic.Field(..., description='')
    ...

class CfnRouteDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnRouteDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRouteDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnRouteDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRouteDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnRouteDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnRouteDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnRouteDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnRouteDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnRouteDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRouteDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnRouteDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnRouteDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRouteDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.CfnRouteResponse
class CfnRouteResponseDef(BaseCfnResource):
    api_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API identifier.\n')
    route_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The route ID.\n')
    route_response_key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The route response key.\n')
    model_config = pydantic.ConfigDict(protected_namespaces=())
    model_selection_expression_: typing.Optional[str] = pydantic.Field(None, description='The model selection expression for the route response. Supported only for WebSocket APIs.\n', alias='model_selection_expression')
    response_models_: typing.Any = pydantic.Field(None, description='The response models for the route response.\n', alias='response_models')
    response_parameters_: typing.Union[models.UnsupportedResource, typing.Mapping[str, typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnRouteResponse_ParameterConstraintsPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The route response parameters.', alias='response_parameters')
    _init_params: typing.ClassVar[list[str]] = ['api_id', 'route_id', 'route_response_key', 'model_selection_expression', 'response_models', 'response_parameters']
    _method_names: typing.ClassVar[list[str]] = ['ParameterConstraintsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnRouteResponse'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.CfnRouteResponseDefConfig] = pydantic.Field(None)


class CfnRouteResponseDefConfig(pydantic.BaseModel):
    ParameterConstraintsProperty: typing.Optional[list[models.aws_apigatewayv2.CfnRouteResponseDefParameterconstraintspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnRouteResponseDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnRouteResponseDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_apigatewayv2.CfnRouteResponseDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnRouteResponseDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_apigatewayv2.CfnRouteResponseDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnRouteResponseDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_apigatewayv2.CfnRouteResponseDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_apigatewayv2.CfnRouteResponseDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnRouteResponseDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_apigatewayv2.CfnRouteResponseDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_apigatewayv2.CfnRouteResponseDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnRouteResponseDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnRouteResponseDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnRouteResponseDefParameterconstraintspropertyParams(pydantic.BaseModel):
    required: typing.Union[bool, models.UnsupportedResource] = pydantic.Field(..., description='')
    ...

class CfnRouteResponseDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnRouteResponseDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRouteResponseDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnRouteResponseDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRouteResponseDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnRouteResponseDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnRouteResponseDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnRouteResponseDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnRouteResponseDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnRouteResponseDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRouteResponseDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnRouteResponseDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnRouteResponseDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRouteResponseDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.CfnStage
class CfnStageDef(BaseCfnResource):
    api_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API identifier.\n')
    stage_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The stage name. Stage names can contain only alphanumeric characters, hyphens, and underscores, or be ``$default`` . Maximum length is 128 characters.\n')
    access_log_settings: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnStage_AccessLogSettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for logging access in this stage.\n')
    access_policy_id: typing.Optional[str] = pydantic.Field(None, description='This parameter is not currently supported.\n')
    auto_deploy: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether updates to an API automatically trigger a new deployment. The default value is ``false`` .\n')
    client_certificate_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of a client certificate for a ``Stage`` . Supported only for WebSocket APIs.\n')
    default_route_settings: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnStage_RouteSettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The default route settings for the stage.\n')
    deployment_id: typing.Optional[str] = pydantic.Field(None, description="The deployment identifier for the API stage. Can't be updated if ``autoDeploy`` is enabled.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='The description for the API stage.\n')
    route_settings: typing.Any = pydantic.Field(None, description='Route settings for the stage.\n')
    stage_variables: typing.Any = pydantic.Field(None, description='A map that defines the stage variables for a ``Stage`` . Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.\n')
    tags: typing.Any = pydantic.Field(None, description='The collection of tags. Each tag element is associated with a given resource.')
    _init_params: typing.ClassVar[list[str]] = ['api_id', 'stage_name', 'access_log_settings', 'access_policy_id', 'auto_deploy', 'client_certificate_id', 'default_route_settings', 'deployment_id', 'description', 'route_settings', 'stage_variables', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['AccessLogSettingsProperty', 'RouteSettingsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnStage'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.CfnStageDefConfig] = pydantic.Field(None)


class CfnStageDefConfig(pydantic.BaseModel):
    AccessLogSettingsProperty: typing.Optional[list[models.aws_apigatewayv2.CfnStageDefAccesslogsettingspropertyParams]] = pydantic.Field(None, description='')
    RouteSettingsProperty: typing.Optional[list[models.aws_apigatewayv2.CfnStageDefRoutesettingspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnStageDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnStageDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_apigatewayv2.CfnStageDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnStageDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_apigatewayv2.CfnStageDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnStageDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_apigatewayv2.CfnStageDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_apigatewayv2.CfnStageDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnStageDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_apigatewayv2.CfnStageDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_apigatewayv2.CfnStageDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnStageDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnStageDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnStageDefAccesslogsettingspropertyParams(pydantic.BaseModel):
    destination_arn: typing.Optional[str] = pydantic.Field(None, description='')
    format: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnStageDefRoutesettingspropertyParams(pydantic.BaseModel):
    data_trace_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    detailed_metrics_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    logging_level: typing.Optional[str] = pydantic.Field(None, description='')
    throttling_burst_limit: typing.Union[int, float, None] = pydantic.Field(None, description='')
    throttling_rate_limit: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnStageDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnStageDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnStageDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnStageDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnStageDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnStageDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnStageDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnStageDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnStageDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnStageDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnStageDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnStageDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnStageDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnStageDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.CfnVpcLink
class CfnVpcLinkDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the VPC link.\n')
    subnet_ids: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of subnet IDs to include in the VPC link.\n')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of security group IDs for the VPC link.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The collection of tags. Each tag element is associated with a given resource.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'subnet_ids', 'security_group_ids', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnVpcLink'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_apigatewayv2.CfnVpcLinkDefConfig] = pydantic.Field(None)


class CfnVpcLinkDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnVpcLinkDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnVpcLinkDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_apigatewayv2.CfnVpcLinkDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnVpcLinkDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_apigatewayv2.CfnVpcLinkDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_apigatewayv2.CfnVpcLinkDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_apigatewayv2.CfnVpcLinkDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_apigatewayv2.CfnVpcLinkDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_apigatewayv2.CfnVpcLinkDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_apigatewayv2.CfnVpcLinkDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_apigatewayv2.CfnVpcLinkDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnVpcLinkDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_apigatewayv2.CfnVpcLinkDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnVpcLinkDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVpcLinkDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVpcLinkDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVpcLinkDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVpcLinkDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVpcLinkDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVpcLinkDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVpcLinkDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVpcLinkDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVpcLinkDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVpcLinkDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnVpcLinkDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVpcLinkDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVpcLinkDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apigatewayv2.CfnApiGatewayManagedOverridesProps
class CfnApiGatewayManagedOverridesPropsDef(BaseCfnProperty):
    api_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the API for which to override the configuration of API Gateway-managed resources.\n')
    integration: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnApiGatewayManagedOverrides_IntegrationOverridesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Overrides the integration configuration for an API Gateway-managed integration.\n')
    route: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnApiGatewayManagedOverrides_RouteOverridesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Overrides the route configuration for an API Gateway-managed route.\n')
    stage: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnApiGatewayManagedOverrides_StageOverridesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Overrides the stage configuration for an API Gateway-managed stage.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigatewayv2-apigatewaymanagedoverrides.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    # route_settings: Any\n    # stage_variables: Any\n\n    cfn_api_gateway_managed_overrides_props = apigatewayv2.CfnApiGatewayManagedOverridesProps(\n        api_id="apiId",\n\n        # the properties below are optional\n        integration=apigatewayv2.CfnApiGatewayManagedOverrides.IntegrationOverridesProperty(\n            description="description",\n            integration_method="integrationMethod",\n            payload_format_version="payloadFormatVersion",\n            timeout_in_millis=123\n        ),\n        route=apigatewayv2.CfnApiGatewayManagedOverrides.RouteOverridesProperty(\n            authorization_scopes=["authorizationScopes"],\n            authorization_type="authorizationType",\n            authorizer_id="authorizerId",\n            operation_name="operationName",\n            target="target"\n        ),\n        stage=apigatewayv2.CfnApiGatewayManagedOverrides.StageOverridesProperty(\n            access_log_settings=apigatewayv2.CfnApiGatewayManagedOverrides.AccessLogSettingsProperty(\n                destination_arn="destinationArn",\n                format="format"\n            ),\n            auto_deploy=False,\n            default_route_settings=apigatewayv2.CfnApiGatewayManagedOverrides.RouteSettingsProperty(\n                data_trace_enabled=False,\n                detailed_metrics_enabled=False,\n                logging_level="loggingLevel",\n                throttling_burst_limit=123,\n                throttling_rate_limit=123\n            ),\n            description="description",\n            route_settings=route_settings,\n            stage_variables=stage_variables\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['api_id', 'integration', 'route', 'stage']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnApiGatewayManagedOverridesProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnApiMappingProps
class CfnApiMappingPropsDef(BaseCfnProperty):
    api_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API identifier.\n')
    domain_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The domain name.\n')
    stage: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API stage.\n')
    api_mapping_key: typing.Optional[str] = pydantic.Field(None, description='The API mapping key.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigatewayv2-apimapping.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    cfn_api_mapping_props = apigatewayv2.CfnApiMappingProps(\n        api_id="apiId",\n        domain_name="domainName",\n        stage="stage",\n\n        # the properties below are optional\n        api_mapping_key="apiMappingKey"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['api_id', 'domain_name', 'stage', 'api_mapping_key']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnApiMappingProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnApiProps
class CfnApiPropsDef(BaseCfnProperty):
    api_key_selection_expression: typing.Optional[str] = pydantic.Field(None, description='An API key selection expression. Supported only for WebSocket APIs. See `API Key Selection Expressions <https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions>`_ .\n')
    base_path: typing.Optional[str] = pydantic.Field(None, description='Specifies how to interpret the base path of the API during import. Valid values are ``ignore`` , ``prepend`` , and ``split`` . The default value is ``ignore`` . To learn more, see `Set the OpenAPI basePath Property <https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-import-api-basePath.html>`_ . Supported only for HTTP APIs.\n')
    body: typing.Any = pydantic.Field(None, description="The OpenAPI definition. Supported only for HTTP APIs. To import an HTTP API, you must specify a ``Body`` or ``BodyS3Location`` . If you specify a ``Body`` or ``BodyS3Location`` , don't specify CloudFormation resources such as ``AWS::ApiGatewayV2::Authorizer`` or ``AWS::ApiGatewayV2::Route`` . API Gateway doesn't support the combination of OpenAPI and CloudFormation resources.\n")
    body_s3_location: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnApi_BodyS3LocationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The S3 location of an OpenAPI definition. Supported only for HTTP APIs. To import an HTTP API, you must specify a ``Body`` or ``BodyS3Location`` . If you specify a ``Body`` or ``BodyS3Location`` , don't specify CloudFormation resources such as ``AWS::ApiGatewayV2::Authorizer`` or ``AWS::ApiGatewayV2::Route`` . API Gateway doesn't support the combination of OpenAPI and CloudFormation resources.\n")
    cors_configuration: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnApi_CorsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A CORS configuration. Supported only for HTTP APIs. See `Configuring CORS <https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-cors.html>`_ for more information.\n')
    credentials_arn: typing.Optional[str] = pydantic.Field(None, description="This property is part of quick create. It specifies the credentials required for the integration, if any. For a Lambda integration, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify ``arn:aws:iam::*:user/*`` . To use resource-based permissions on supported AWS services, specify ``null`` . Currently, this property is not used for HTTP integrations. Supported only for HTTP APIs.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the API.\n')
    disable_execute_api_endpoint: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether clients can invoke your API by using the default ``execute-api`` endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.\n')
    disable_schema_validation: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Avoid validating models when creating a deployment. Supported only for WebSocket APIs.\n')
    fail_on_warnings: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether to rollback the API creation when a warning is encountered. By default, API creation continues if a warning is encountered.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the API. Required unless you specify an OpenAPI definition for ``Body`` or ``S3BodyLocation`` .\n')
    protocol_type: typing.Optional[str] = pydantic.Field(None, description='The API protocol. Valid values are ``WEBSOCKET`` or ``HTTP`` . Required unless you specify an OpenAPI definition for ``Body`` or ``S3BodyLocation`` .\n')
    route_key: typing.Optional[str] = pydantic.Field(None, description="This property is part of quick create. If you don't specify a ``routeKey`` , a default route of ``$default`` is created. The ``$default`` route acts as a catch-all for any request made to your API, for a particular stage. The ``$default`` route key can't be modified. You can add routes after creating the API, and you can update the route keys of additional routes. Supported only for HTTP APIs.\n")
    route_selection_expression: typing.Optional[str] = pydantic.Field(None, description='The route selection expression for the API. For HTTP APIs, the ``routeSelectionExpression`` must be ``${request.method} ${request.path}`` . If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The collection of tags. Each tag element is associated with a given resource.\n')
    target: typing.Optional[str] = pydantic.Field(None, description='This property is part of quick create. Quick create produces an API with an integration, a default catch-all route, and a default stage which is configured to automatically deploy changes. For HTTP integrations, specify a fully qualified URL. For Lambda integrations, specify a function ARN. The type of the integration will be HTTP_PROXY or AWS_PROXY, respectively. Supported only for HTTP APIs.\n')
    version: typing.Optional[str] = pydantic.Field(None, description='A version identifier for the API.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigatewayv2-api.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    # body: Any\n\n    cfn_api_props = apigatewayv2.CfnApiProps(\n        api_key_selection_expression="apiKeySelectionExpression",\n        base_path="basePath",\n        body=body,\n        body_s3_location=apigatewayv2.CfnApi.BodyS3LocationProperty(\n            bucket="bucket",\n            etag="etag",\n            key="key",\n            version="version"\n        ),\n        cors_configuration=apigatewayv2.CfnApi.CorsProperty(\n            allow_credentials=False,\n            allow_headers=["allowHeaders"],\n            allow_methods=["allowMethods"],\n            allow_origins=["allowOrigins"],\n            expose_headers=["exposeHeaders"],\n            max_age=123\n        ),\n        credentials_arn="credentialsArn",\n        description="description",\n        disable_execute_api_endpoint=False,\n        disable_schema_validation=False,\n        fail_on_warnings=False,\n        name="name",\n        protocol_type="protocolType",\n        route_key="routeKey",\n        route_selection_expression="routeSelectionExpression",\n        tags={\n            "tags_key": "tags"\n        },\n        target="target",\n        version="version"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['api_key_selection_expression', 'base_path', 'body', 'body_s3_location', 'cors_configuration', 'credentials_arn', 'description', 'disable_execute_api_endpoint', 'disable_schema_validation', 'fail_on_warnings', 'name', 'protocol_type', 'route_key', 'route_selection_expression', 'tags', 'target', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnApiProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnAuthorizerProps
class CfnAuthorizerPropsDef(BaseCfnProperty):
    api_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API identifier.\n')
    authorizer_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The authorizer type. Specify ``REQUEST`` for a Lambda function using incoming request parameters. Specify ``JWT`` to use JSON Web Tokens (supported only for HTTP APIs).\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the authorizer.\n')
    authorizer_credentials_arn: typing.Optional[str] = pydantic.Field(None, description="Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null. Supported only for ``REQUEST`` authorizers.\n")
    authorizer_payload_format_version: typing.Optional[str] = pydantic.Field(None, description='Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are ``1.0`` and ``2.0`` . To learn more, see `Working with AWS Lambda authorizers for HTTP APIs <https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html>`_ .\n')
    authorizer_result_ttl_in_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.\n')
    authorizer_uri: typing.Optional[str] = pydantic.Field(None, description="The authorizer's Uniform Resource Identifier (URI). For ``REQUEST`` authorizers, this must be a well-formed Lambda function URI, for example, ``arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2: *{account_id}* :function: *{lambda_function_name}* /invocations`` . In general, the URI has this form: ``arn:aws:apigateway: *{region}* :lambda:path/ *{service_api}*`` , where *{region}* is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial ``/`` . For Lambda functions, this is usually of the form ``/2015-03-31/functions/[FunctionARN]/invocations`` .\n")
    enable_simple_responses: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether a Lambda authorizer returns a response in a simple format. By default, a Lambda authorizer must return an IAM policy. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see `Working with AWS Lambda authorizers for HTTP APIs <https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html>`_ .\n')
    identity_source: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The identity source for which authorization is requested. For a ``REQUEST`` authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with ``$`` , for example, ``$request.header.Auth`` , ``$request.querystring.Name`` . These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see `Working with AWS Lambda authorizers for HTTP APIs <https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html>`_ . For ``JWT`` , a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example ``$request.header.Authorization`` .\n')
    identity_validation_expression: typing.Optional[str] = pydantic.Field(None, description='This parameter is not used.\n')
    jwt_configuration: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnAuthorizer_JWTConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The ``JWTConfiguration`` property specifies the configuration of a JWT authorizer. Required for the ``JWT`` authorizer type. Supported only for HTTP APIs.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigatewayv2-authorizer.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    cfn_authorizer_props = apigatewayv2.CfnAuthorizerProps(\n        api_id="apiId",\n        authorizer_type="authorizerType",\n        name="name",\n\n        # the properties below are optional\n        authorizer_credentials_arn="authorizerCredentialsArn",\n        authorizer_payload_format_version="authorizerPayloadFormatVersion",\n        authorizer_result_ttl_in_seconds=123,\n        authorizer_uri="authorizerUri",\n        enable_simple_responses=False,\n        identity_source=["identitySource"],\n        identity_validation_expression="identityValidationExpression",\n        jwt_configuration=apigatewayv2.CfnAuthorizer.JWTConfigurationProperty(\n            audience=["audience"],\n            issuer="issuer"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['api_id', 'authorizer_type', 'name', 'authorizer_credentials_arn', 'authorizer_payload_format_version', 'authorizer_result_ttl_in_seconds', 'authorizer_uri', 'enable_simple_responses', 'identity_source', 'identity_validation_expression', 'jwt_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnAuthorizerProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnDeploymentProps
class CfnDeploymentPropsDef(BaseCfnProperty):
    api_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API identifier.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description for the deployment resource.\n')
    stage_name: typing.Optional[str] = pydantic.Field(None, description='The name of an existing stage to associate with the deployment.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigatewayv2-deployment.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    cfn_deployment_props = apigatewayv2.CfnDeploymentProps(\n        api_id="apiId",\n\n        # the properties below are optional\n        description="description",\n        stage_name="stageName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['api_id', 'description', 'stage_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnDeploymentProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnDomainNameProps
class CfnDomainNamePropsDef(BaseCfnProperty):
    domain_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The custom domain name for your API in Amazon API Gateway. Uppercase letters are not supported.\n')
    domain_name_configurations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnDomainName_DomainNameConfigurationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The domain name configurations.\n')
    mutual_tls_authentication: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnDomainName_MutualTlsAuthenticationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The mutual TLS authentication configuration for a custom domain name.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The collection of tags associated with a domain name.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigatewayv2-domainname.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    cfn_domain_name_props = apigatewayv2.CfnDomainNameProps(\n        domain_name="domainName",\n\n        # the properties below are optional\n        domain_name_configurations=[apigatewayv2.CfnDomainName.DomainNameConfigurationProperty(\n            certificate_arn="certificateArn",\n            certificate_name="certificateName",\n            endpoint_type="endpointType",\n            ownership_verification_certificate_arn="ownershipVerificationCertificateArn",\n            security_policy="securityPolicy"\n        )],\n        mutual_tls_authentication=apigatewayv2.CfnDomainName.MutualTlsAuthenticationProperty(\n            truststore_uri="truststoreUri",\n            truststore_version="truststoreVersion"\n        ),\n        tags={\n            "tags_key": "tags"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'domain_name_configurations', 'mutual_tls_authentication', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnDomainNameProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnIntegrationProps
class CfnIntegrationPropsDef(BaseCfnProperty):
    api_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API identifier.\n')
    integration_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The integration type of an integration. One of the following:. ``AWS`` : for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. ``AWS_PROXY`` : for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. ``HTTP`` : for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. ``HTTP_PROXY`` : for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. For HTTP API private integrations, use an ``HTTP_PROXY`` integration. ``MOCK`` : for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.\n')
    connection_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the VPC link for a private integration. Supported only for HTTP APIs.\n')
    connection_type: typing.Optional[str] = pydantic.Field(None, description='The type of the network connection to the integration endpoint. Specify ``INTERNET`` for connections through the public routable internet or ``VPC_LINK`` for private connections between API Gateway and resources in a VPC. The default value is ``INTERNET`` .\n')
    content_handling_strategy: typing.Optional[str] = pydantic.Field(None, description='Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are ``CONVERT_TO_BINARY`` and ``CONVERT_TO_TEXT`` , with the following behaviors: ``CONVERT_TO_BINARY`` : Converts a response payload from a Base64-encoded string to the corresponding binary blob. ``CONVERT_TO_TEXT`` : Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.\n')
    credentials_arn: typing.Optional[str] = pydantic.Field(None, description="Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string ``arn:aws:iam::*:user/*`` . To use resource-based permissions on supported AWS services, don't specify this parameter.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the integration.\n')
    integration_method: typing.Optional[str] = pydantic.Field(None, description="Specifies the integration's HTTP method type. For WebSocket APIs, if you use a Lambda integration, you must set the integration method to ``POST`` .\n")
    integration_subtype: typing.Optional[str] = pydantic.Field(None, description='Supported only for HTTP API ``AWS_PROXY`` integrations. Specifies the AWS service action to invoke. To learn more, see `Integration subtype reference <https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html>`_ .\n')
    integration_uri: typing.Optional[str] = pydantic.Field(None, description='For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses ``DiscoverInstances`` to identify resources. You can use query parameters to target specific resources. To learn more, see `DiscoverInstances <https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html>`_ . For private integrations, all resources must be owned by the same AWS account .\n')
    passthrough_behavior: typing.Optional[str] = pydantic.Field(None, description='Specifies the pass-through behavior for incoming requests based on the ``Content-Type`` header in the request, and the available mapping templates specified as the ``requestTemplates`` property on the ``Integration`` resource. There are three valid values: ``WHEN_NO_MATCH`` , ``WHEN_NO_TEMPLATES`` , and ``NEVER`` . Supported only for WebSocket APIs. ``WHEN_NO_MATCH`` passes the request body for unmapped content types through to the integration backend without transformation. ``NEVER`` rejects unmapped content types with an ``HTTP 415 Unsupported Media Type`` response. ``WHEN_NO_TEMPLATES`` allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same ``HTTP 415 Unsupported Media Type`` response.\n')
    payload_format_version: typing.Optional[str] = pydantic.Field(None, description='Specifies the format of the payload sent to an integration. Required for HTTP APIs. For HTTP APIs, supported values for Lambda proxy integrations are ``1.0`` and ``2.0`` . For all other integrations, ``1.0`` is the only supported value. To learn more, see `Working with AWS Lambda proxy integrations for HTTP APIs <https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html>`_ .\n')
    request_parameters: typing.Any = pydantic.Field(None, description='For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of ``method.request. {location} . {name}`` , where ``{location}`` is ``querystring`` , ``path`` , or ``header`` ; and ``{name}`` must be a valid and unique method request parameter name. For HTTP API integrations with a specified ``integrationSubtype`` , request parameters are a key-value map specifying parameters that are passed to ``AWS_PROXY`` integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see `Working with AWS service integrations for HTTP APIs <https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html>`_ . For HTTP API integrations without a specified ``integrationSubtype`` request parameters are a key-value map specifying how to transform HTTP requests before sending them to the backend. The key should follow the pattern :<header|querystring|path>. where action can be ``append`` , ``overwrite`` or ``remove`` . For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see `Transforming API requests and responses <https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html>`_ .\n')
    request_templates: typing.Any = pydantic.Field(None, description='Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.\n')
    response_parameters: typing.Any = pydantic.Field(None, description='Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. The value is of type ```ResponseParameterList`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigatewayv2-integration-responseparameterlist.html>`_ . To learn more, see `Transforming API requests and responses <https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html>`_ .\n')
    template_selection_expression: typing.Optional[str] = pydantic.Field(None, description='The template selection expression for the integration. Supported only for WebSocket APIs.\n')
    timeout_in_millis: typing.Union[int, float, None] = pydantic.Field(None, description='Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.\n')
    tls_config: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnIntegration_TlsConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigatewayv2-integration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    # request_parameters: Any\n    # request_templates: Any\n    # response_parameters: Any\n\n    cfn_integration_props = apigatewayv2.CfnIntegrationProps(\n        api_id="apiId",\n        integration_type="integrationType",\n\n        # the properties below are optional\n        connection_id="connectionId",\n        connection_type="connectionType",\n        content_handling_strategy="contentHandlingStrategy",\n        credentials_arn="credentialsArn",\n        description="description",\n        integration_method="integrationMethod",\n        integration_subtype="integrationSubtype",\n        integration_uri="integrationUri",\n        passthrough_behavior="passthroughBehavior",\n        payload_format_version="payloadFormatVersion",\n        request_parameters=request_parameters,\n        request_templates=request_templates,\n        response_parameters=response_parameters,\n        template_selection_expression="templateSelectionExpression",\n        timeout_in_millis=123,\n        tls_config=apigatewayv2.CfnIntegration.TlsConfigProperty(\n            server_name_to_verify="serverNameToVerify"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['api_id', 'integration_type', 'connection_id', 'connection_type', 'content_handling_strategy', 'credentials_arn', 'description', 'integration_method', 'integration_subtype', 'integration_uri', 'passthrough_behavior', 'payload_format_version', 'request_parameters', 'request_templates', 'response_parameters', 'template_selection_expression', 'timeout_in_millis', 'tls_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnIntegrationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnIntegrationResponseProps
class CfnIntegrationResponsePropsDef(BaseCfnProperty):
    api_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API identifier.\n')
    integration_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The integration ID.\n')
    integration_response_key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The integration response key.\n')
    content_handling_strategy: typing.Optional[str] = pydantic.Field(None, description='Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are ``CONVERT_TO_BINARY`` and ``CONVERT_TO_TEXT`` , with the following behaviors: ``CONVERT_TO_BINARY`` : Converts a response payload from a Base64-encoded string to the corresponding binary blob. ``CONVERT_TO_TEXT`` : Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.\n')
    response_parameters: typing.Any = pydantic.Field(None, description='A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of ``method.response.header. *{name}*`` , where name is a valid and unique header name. The mapped non-static value must match the pattern of ``integration.response.header. *{name}*`` or ``integration.response.body. *{JSON-expression}*`` , where ``*{name}*`` is a valid and unique response header name and ``*{JSON-expression}*`` is a valid JSON expression without the ``$`` prefix.\n')
    response_templates: typing.Any = pydantic.Field(None, description='The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.\n')
    template_selection_expression: typing.Optional[str] = pydantic.Field(None, description='The template selection expression for the integration response. Supported only for WebSocket APIs.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigatewayv2-integrationresponse.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    # response_parameters: Any\n    # response_templates: Any\n\n    cfn_integration_response_props = apigatewayv2.CfnIntegrationResponseProps(\n        api_id="apiId",\n        integration_id="integrationId",\n        integration_response_key="integrationResponseKey",\n\n        # the properties below are optional\n        content_handling_strategy="contentHandlingStrategy",\n        response_parameters=response_parameters,\n        response_templates=response_templates,\n        template_selection_expression="templateSelectionExpression"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['api_id', 'integration_id', 'integration_response_key', 'content_handling_strategy', 'response_parameters', 'response_templates', 'template_selection_expression']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnIntegrationResponseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnModelProps
class CfnModelPropsDef(BaseCfnProperty):
    api_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API identifier.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the model.\n')
    schema_: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The schema for the model. For application/json models, this should be JSON schema draft 4 model.\n', alias='schema')
    content_type: typing.Optional[str] = pydantic.Field(None, description='The content-type for the model, for example, "application/json".\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the model.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigatewayv2-model.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    # schema: Any\n\n    cfn_model_props = apigatewayv2.CfnModelProps(\n        api_id="apiId",\n        name="name",\n        schema=schema,\n\n        # the properties below are optional\n        content_type="contentType",\n        description="description"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['api_id', 'name', 'schema', 'content_type', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnModelProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnRouteProps
class CfnRoutePropsDef(BaseCfnProperty):
    api_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API identifier.\n')
    route_key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The route key for the route. For HTTP APIs, the route key can be either ``$default`` , or a combination of an HTTP method and resource path, for example, ``GET /pets`` .\n')
    api_key_required: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether an API key is required for the route. Supported only for WebSocket APIs.\n')
    authorization_scopes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The authorization scopes supported by this route.\n')
    authorization_type: typing.Optional[str] = pydantic.Field(None, description='The authorization type for the route. For WebSocket APIs, valid values are ``NONE`` for open access, ``AWS_IAM`` for using AWS IAM permissions, and ``CUSTOM`` for using a Lambda authorizer. For HTTP APIs, valid values are ``NONE`` for open access, ``JWT`` for using JSON Web Tokens, ``AWS_IAM`` for using AWS IAM permissions, and ``CUSTOM`` for using a Lambda authorizer.\n')
    authorizer_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the ``Authorizer`` resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.\n')
    model_config = pydantic.ConfigDict(protected_namespaces=())
    model_selection_expression_: typing.Optional[str] = pydantic.Field(None, description='The model selection expression for the route. Supported only for WebSocket APIs.\n', alias='model_selection_expression')
    operation_name_: typing.Optional[str] = pydantic.Field(None, description='The operation name for the route.\n', alias='operation_name')
    request_models_: typing.Any = pydantic.Field(None, description='The request models for the route. Supported only for WebSocket APIs.\n', alias='request_models')
    request_parameters_: typing.Any = pydantic.Field(None, description='The request parameters for the route. Supported only for WebSocket APIs.\n', alias='request_parameters')
    route_response_selection_expression_: typing.Optional[str] = pydantic.Field(None, description='The route response selection expression for the route. Supported only for WebSocket APIs.\n', alias='route_response_selection_expression')
    target_: typing.Optional[str] = pydantic.Field(None, description='The target for the route.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigatewayv2-route.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    # request_models: Any\n    # request_parameters: Any\n\n    cfn_route_props = apigatewayv2.CfnRouteProps(\n        api_id="apiId",\n        route_key="routeKey",\n\n        # the properties below are optional\n        api_key_required=False,\n        authorization_scopes=["authorizationScopes"],\n        authorization_type="authorizationType",\n        authorizer_id="authorizerId",\n        model_selection_expression="modelSelectionExpression",\n        operation_name="operationName",\n        request_models=request_models,\n        request_parameters=request_parameters,\n        route_response_selection_expression="routeResponseSelectionExpression",\n        target="target"\n    )\n', alias='target')
    _init_params: typing.ClassVar[list[str]] = ['api_id', 'route_key', 'api_key_required', 'authorization_scopes', 'authorization_type', 'authorizer_id', 'model_selection_expression', 'operation_name', 'request_models', 'request_parameters', 'route_response_selection_expression', 'target']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnRouteProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnRouteResponseProps
class CfnRouteResponsePropsDef(BaseCfnProperty):
    api_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API identifier.\n')
    route_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The route ID.\n')
    route_response_key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The route response key.\n')
    model_config = pydantic.ConfigDict(protected_namespaces=())
    model_selection_expression_: typing.Optional[str] = pydantic.Field(None, description='The model selection expression for the route response. Supported only for WebSocket APIs.\n', alias='model_selection_expression')
    response_models_: typing.Any = pydantic.Field(None, description='The response models for the route response.\n', alias='response_models')
    response_parameters_: typing.Union[models.UnsupportedResource, typing.Mapping[str, typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnRouteResponse_ParameterConstraintsPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The route response parameters.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigatewayv2-routeresponse.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    # response_models: Any\n\n    cfn_route_response_props = apigatewayv2.CfnRouteResponseProps(\n        api_id="apiId",\n        route_id="routeId",\n        route_response_key="routeResponseKey",\n\n        # the properties below are optional\n        model_selection_expression="modelSelectionExpression",\n        response_models=response_models,\n        response_parameters={\n            "response_parameters_key": apigatewayv2.CfnRouteResponse.ParameterConstraintsProperty(\n                required=False\n            )\n        }\n    )\n', alias='response_parameters')
    _init_params: typing.ClassVar[list[str]] = ['api_id', 'route_id', 'route_response_key', 'model_selection_expression', 'response_models', 'response_parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnRouteResponseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnStageProps
class CfnStagePropsDef(BaseCfnProperty):
    api_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The API identifier.\n')
    stage_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The stage name. Stage names can contain only alphanumeric characters, hyphens, and underscores, or be ``$default`` . Maximum length is 128 characters.\n')
    access_log_settings: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnStage_AccessLogSettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for logging access in this stage.\n')
    access_policy_id: typing.Optional[str] = pydantic.Field(None, description='This parameter is not currently supported.\n')
    auto_deploy: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether updates to an API automatically trigger a new deployment. The default value is ``false`` .\n')
    client_certificate_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of a client certificate for a ``Stage`` . Supported only for WebSocket APIs.\n')
    default_route_settings: typing.Union[models.UnsupportedResource, models.aws_apigatewayv2.CfnStage_RouteSettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The default route settings for the stage.\n')
    deployment_id: typing.Optional[str] = pydantic.Field(None, description="The deployment identifier for the API stage. Can't be updated if ``autoDeploy`` is enabled.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='The description for the API stage.\n')
    route_settings: typing.Any = pydantic.Field(None, description='Route settings for the stage.\n')
    stage_variables: typing.Any = pydantic.Field(None, description='A map that defines the stage variables for a ``Stage`` . Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.\n')
    tags: typing.Any = pydantic.Field(None, description='The collection of tags. Each tag element is associated with a given resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigatewayv2-stage.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    # route_settings: Any\n    # stage_variables: Any\n    # tags: Any\n\n    cfn_stage_props = apigatewayv2.CfnStageProps(\n        api_id="apiId",\n        stage_name="stageName",\n\n        # the properties below are optional\n        access_log_settings=apigatewayv2.CfnStage.AccessLogSettingsProperty(\n            destination_arn="destinationArn",\n            format="format"\n        ),\n        access_policy_id="accessPolicyId",\n        auto_deploy=False,\n        client_certificate_id="clientCertificateId",\n        default_route_settings=apigatewayv2.CfnStage.RouteSettingsProperty(\n            data_trace_enabled=False,\n            detailed_metrics_enabled=False,\n            logging_level="loggingLevel",\n            throttling_burst_limit=123,\n            throttling_rate_limit=123\n        ),\n        deployment_id="deploymentId",\n        description="description",\n        route_settings=route_settings,\n        stage_variables=stage_variables,\n        tags=tags\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['api_id', 'stage_name', 'access_log_settings', 'access_policy_id', 'auto_deploy', 'client_certificate_id', 'default_route_settings', 'deployment_id', 'description', 'route_settings', 'stage_variables', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnStageProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apigatewayv2.CfnVpcLinkProps
class CfnVpcLinkPropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the VPC link.\n')
    subnet_ids: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of subnet IDs to include in the VPC link.\n')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of security group IDs for the VPC link.\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='The collection of tags. Each tag element is associated with a given resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigatewayv2-vpclink.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apigatewayv2 as apigatewayv2\n\n    cfn_vpc_link_props = apigatewayv2.CfnVpcLinkProps(\n        name="name",\n        subnet_ids=["subnetIds"],\n\n        # the properties below are optional\n        security_group_ids=["securityGroupIds"],\n        tags={\n            "tags_key": "tags"\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'subnet_ids', 'security_group_ids', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apigatewayv2.CfnVpcLinkProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    HttpNoneAuthorizer: typing.Optional[dict[str, models.aws_apigatewayv2.HttpNoneAuthorizerDef]] = pydantic.Field(None)
    HttpRouteIntegration: typing.Optional[dict[str, models.aws_apigatewayv2.HttpRouteIntegrationDef]] = pydantic.Field(None)
    HttpRouteKey: typing.Optional[dict[str, models.aws_apigatewayv2.HttpRouteKeyDef]] = pydantic.Field(None)
    IntegrationCredentials: typing.Optional[dict[str, models.aws_apigatewayv2.IntegrationCredentialsDef]] = pydantic.Field(None)
    MappingValue: typing.Optional[dict[str, models.aws_apigatewayv2.MappingValueDef]] = pydantic.Field(None)
    ParameterMapping: typing.Optional[dict[str, models.aws_apigatewayv2.ParameterMappingDef]] = pydantic.Field(None)
    PayloadFormatVersion: typing.Optional[dict[str, models.aws_apigatewayv2.PayloadFormatVersionDef]] = pydantic.Field(None)
    WebSocketApiKeySelectionExpression: typing.Optional[dict[str, models.aws_apigatewayv2.WebSocketApiKeySelectionExpressionDef]] = pydantic.Field(None)
    WebSocketNoneAuthorizer: typing.Optional[dict[str, models.aws_apigatewayv2.WebSocketNoneAuthorizerDef]] = pydantic.Field(None)
    WebSocketRouteIntegration: typing.Optional[dict[str, models.aws_apigatewayv2.WebSocketRouteIntegrationDef]] = pydantic.Field(None)
    ApiMapping: typing.Optional[dict[str, models.aws_apigatewayv2.ApiMappingDef]] = pydantic.Field(None)
    DomainName: typing.Optional[dict[str, models.aws_apigatewayv2.DomainNameDef]] = pydantic.Field(None)
    HttpApi: typing.Optional[dict[str, models.aws_apigatewayv2.HttpApiDef]] = pydantic.Field(None)
    HttpAuthorizer: typing.Optional[dict[str, models.aws_apigatewayv2.HttpAuthorizerDef]] = pydantic.Field(None)
    HttpIntegration: typing.Optional[dict[str, models.aws_apigatewayv2.HttpIntegrationDef]] = pydantic.Field(None)
    HttpRoute: typing.Optional[dict[str, models.aws_apigatewayv2.HttpRouteDef]] = pydantic.Field(None)
    HttpStage: typing.Optional[dict[str, models.aws_apigatewayv2.HttpStageDef]] = pydantic.Field(None)
    VpcLink: typing.Optional[dict[str, models.aws_apigatewayv2.VpcLinkDef]] = pydantic.Field(None)
    WebSocketApi: typing.Optional[dict[str, models.aws_apigatewayv2.WebSocketApiDef]] = pydantic.Field(None)
    WebSocketAuthorizer: typing.Optional[dict[str, models.aws_apigatewayv2.WebSocketAuthorizerDef]] = pydantic.Field(None)
    WebSocketIntegration: typing.Optional[dict[str, models.aws_apigatewayv2.WebSocketIntegrationDef]] = pydantic.Field(None)
    WebSocketRoute: typing.Optional[dict[str, models.aws_apigatewayv2.WebSocketRouteDef]] = pydantic.Field(None)
    WebSocketStage: typing.Optional[dict[str, models.aws_apigatewayv2.WebSocketStageDef]] = pydantic.Field(None)
    AddRoutesOptions: typing.Optional[dict[str, models.aws_apigatewayv2.AddRoutesOptionsDef]] = pydantic.Field(None)
    ApiMappingAttributes: typing.Optional[dict[str, models.aws_apigatewayv2.ApiMappingAttributesDef]] = pydantic.Field(None)
    ApiMappingProps: typing.Optional[dict[str, models.aws_apigatewayv2.ApiMappingPropsDef]] = pydantic.Field(None)
    BatchHttpRouteOptions: typing.Optional[dict[str, models.aws_apigatewayv2.BatchHttpRouteOptionsDef]] = pydantic.Field(None)
    CfnApi_BodyS3LocationProperty: typing.Optional[dict[str, models.aws_apigatewayv2.CfnApi_BodyS3LocationPropertyDef]] = pydantic.Field(None)
    CfnApi_CorsProperty: typing.Optional[dict[str, models.aws_apigatewayv2.CfnApi_CorsPropertyDef]] = pydantic.Field(None)
    CfnApiGatewayManagedOverrides_AccessLogSettingsProperty: typing.Optional[dict[str, models.aws_apigatewayv2.CfnApiGatewayManagedOverrides_AccessLogSettingsPropertyDef]] = pydantic.Field(None)
    CfnApiGatewayManagedOverrides_IntegrationOverridesProperty: typing.Optional[dict[str, models.aws_apigatewayv2.CfnApiGatewayManagedOverrides_IntegrationOverridesPropertyDef]] = pydantic.Field(None)
    CfnApiGatewayManagedOverrides_RouteOverridesProperty: typing.Optional[dict[str, models.aws_apigatewayv2.CfnApiGatewayManagedOverrides_RouteOverridesPropertyDef]] = pydantic.Field(None)
    CfnApiGatewayManagedOverrides_RouteSettingsProperty: typing.Optional[dict[str, models.aws_apigatewayv2.CfnApiGatewayManagedOverrides_RouteSettingsPropertyDef]] = pydantic.Field(None)
    CfnApiGatewayManagedOverrides_StageOverridesProperty: typing.Optional[dict[str, models.aws_apigatewayv2.CfnApiGatewayManagedOverrides_StageOverridesPropertyDef]] = pydantic.Field(None)
    CfnAuthorizer_JWTConfigurationProperty: typing.Optional[dict[str, models.aws_apigatewayv2.CfnAuthorizer_JWTConfigurationPropertyDef]] = pydantic.Field(None)
    CfnDomainName_DomainNameConfigurationProperty: typing.Optional[dict[str, models.aws_apigatewayv2.CfnDomainName_DomainNameConfigurationPropertyDef]] = pydantic.Field(None)
    CfnDomainName_MutualTlsAuthenticationProperty: typing.Optional[dict[str, models.aws_apigatewayv2.CfnDomainName_MutualTlsAuthenticationPropertyDef]] = pydantic.Field(None)
    CfnIntegration_ResponseParameterListProperty: typing.Optional[dict[str, models.aws_apigatewayv2.CfnIntegration_ResponseParameterListPropertyDef]] = pydantic.Field(None)
    CfnIntegration_ResponseParameterProperty: typing.Optional[dict[str, models.aws_apigatewayv2.CfnIntegration_ResponseParameterPropertyDef]] = pydantic.Field(None)
    CfnIntegration_TlsConfigProperty: typing.Optional[dict[str, models.aws_apigatewayv2.CfnIntegration_TlsConfigPropertyDef]] = pydantic.Field(None)
    CfnRoute_ParameterConstraintsProperty: typing.Optional[dict[str, models.aws_apigatewayv2.CfnRoute_ParameterConstraintsPropertyDef]] = pydantic.Field(None)
    CfnRouteResponse_ParameterConstraintsProperty: typing.Optional[dict[str, models.aws_apigatewayv2.CfnRouteResponse_ParameterConstraintsPropertyDef]] = pydantic.Field(None)
    CfnStage_AccessLogSettingsProperty: typing.Optional[dict[str, models.aws_apigatewayv2.CfnStage_AccessLogSettingsPropertyDef]] = pydantic.Field(None)
    CfnStage_RouteSettingsProperty: typing.Optional[dict[str, models.aws_apigatewayv2.CfnStage_RouteSettingsPropertyDef]] = pydantic.Field(None)
    CorsPreflightOptions: typing.Optional[dict[str, models.aws_apigatewayv2.CorsPreflightOptionsDef]] = pydantic.Field(None)
    DomainMappingOptions: typing.Optional[dict[str, models.aws_apigatewayv2.DomainMappingOptionsDef]] = pydantic.Field(None)
    DomainNameAttributes: typing.Optional[dict[str, models.aws_apigatewayv2.DomainNameAttributesDef]] = pydantic.Field(None)
    DomainNameProps: typing.Optional[dict[str, models.aws_apigatewayv2.DomainNamePropsDef]] = pydantic.Field(None)
    EndpointOptions: typing.Optional[dict[str, models.aws_apigatewayv2.EndpointOptionsDef]] = pydantic.Field(None)
    GrantInvokeOptions: typing.Optional[dict[str, models.aws_apigatewayv2.GrantInvokeOptionsDef]] = pydantic.Field(None)
    HttpApiAttributes: typing.Optional[dict[str, models.aws_apigatewayv2.HttpApiAttributesDef]] = pydantic.Field(None)
    HttpApiProps: typing.Optional[dict[str, models.aws_apigatewayv2.HttpApiPropsDef]] = pydantic.Field(None)
    HttpAuthorizerAttributes: typing.Optional[dict[str, models.aws_apigatewayv2.HttpAuthorizerAttributesDef]] = pydantic.Field(None)
    HttpAuthorizerProps: typing.Optional[dict[str, models.aws_apigatewayv2.HttpAuthorizerPropsDef]] = pydantic.Field(None)
    HttpIntegrationProps: typing.Optional[dict[str, models.aws_apigatewayv2.HttpIntegrationPropsDef]] = pydantic.Field(None)
    HttpRouteAuthorizerBindOptions: typing.Optional[dict[str, models.aws_apigatewayv2.HttpRouteAuthorizerBindOptionsDef]] = pydantic.Field(None)
    HttpRouteAuthorizerConfig: typing.Optional[dict[str, models.aws_apigatewayv2.HttpRouteAuthorizerConfigDef]] = pydantic.Field(None)
    HttpRouteIntegrationBindOptions: typing.Optional[dict[str, models.aws_apigatewayv2.HttpRouteIntegrationBindOptionsDef]] = pydantic.Field(None)
    HttpRouteIntegrationConfig: typing.Optional[dict[str, models.aws_apigatewayv2.HttpRouteIntegrationConfigDef]] = pydantic.Field(None)
    HttpRouteProps: typing.Optional[dict[str, models.aws_apigatewayv2.HttpRoutePropsDef]] = pydantic.Field(None)
    HttpStageAttributes: typing.Optional[dict[str, models.aws_apigatewayv2.HttpStageAttributesDef]] = pydantic.Field(None)
    HttpStageOptions: typing.Optional[dict[str, models.aws_apigatewayv2.HttpStageOptionsDef]] = pydantic.Field(None)
    HttpStageProps: typing.Optional[dict[str, models.aws_apigatewayv2.HttpStagePropsDef]] = pydantic.Field(None)
    MTLSConfig: typing.Optional[dict[str, models.aws_apigatewayv2.MTLSConfigDef]] = pydantic.Field(None)
    StageAttributes: typing.Optional[dict[str, models.aws_apigatewayv2.StageAttributesDef]] = pydantic.Field(None)
    StageOptions: typing.Optional[dict[str, models.aws_apigatewayv2.StageOptionsDef]] = pydantic.Field(None)
    ThrottleSettings: typing.Optional[dict[str, models.aws_apigatewayv2.ThrottleSettingsDef]] = pydantic.Field(None)
    VpcLinkAttributes: typing.Optional[dict[str, models.aws_apigatewayv2.VpcLinkAttributesDef]] = pydantic.Field(None)
    VpcLinkProps: typing.Optional[dict[str, models.aws_apigatewayv2.VpcLinkPropsDef]] = pydantic.Field(None)
    WebSocketApiAttributes: typing.Optional[dict[str, models.aws_apigatewayv2.WebSocketApiAttributesDef]] = pydantic.Field(None)
    WebSocketApiProps: typing.Optional[dict[str, models.aws_apigatewayv2.WebSocketApiPropsDef]] = pydantic.Field(None)
    WebSocketAuthorizerAttributes: typing.Optional[dict[str, models.aws_apigatewayv2.WebSocketAuthorizerAttributesDef]] = pydantic.Field(None)
    WebSocketAuthorizerProps: typing.Optional[dict[str, models.aws_apigatewayv2.WebSocketAuthorizerPropsDef]] = pydantic.Field(None)
    WebSocketIntegrationProps: typing.Optional[dict[str, models.aws_apigatewayv2.WebSocketIntegrationPropsDef]] = pydantic.Field(None)
    WebSocketRouteAuthorizerBindOptions: typing.Optional[dict[str, models.aws_apigatewayv2.WebSocketRouteAuthorizerBindOptionsDef]] = pydantic.Field(None)
    WebSocketRouteAuthorizerConfig: typing.Optional[dict[str, models.aws_apigatewayv2.WebSocketRouteAuthorizerConfigDef]] = pydantic.Field(None)
    WebSocketRouteIntegrationBindOptions: typing.Optional[dict[str, models.aws_apigatewayv2.WebSocketRouteIntegrationBindOptionsDef]] = pydantic.Field(None)
    WebSocketRouteIntegrationConfig: typing.Optional[dict[str, models.aws_apigatewayv2.WebSocketRouteIntegrationConfigDef]] = pydantic.Field(None)
    WebSocketRouteOptions: typing.Optional[dict[str, models.aws_apigatewayv2.WebSocketRouteOptionsDef]] = pydantic.Field(None)
    WebSocketRouteProps: typing.Optional[dict[str, models.aws_apigatewayv2.WebSocketRoutePropsDef]] = pydantic.Field(None)
    WebSocketStageAttributes: typing.Optional[dict[str, models.aws_apigatewayv2.WebSocketStageAttributesDef]] = pydantic.Field(None)
    WebSocketStageProps: typing.Optional[dict[str, models.aws_apigatewayv2.WebSocketStagePropsDef]] = pydantic.Field(None)
    CfnApi: typing.Optional[dict[str, models.aws_apigatewayv2.CfnApiDef]] = pydantic.Field(None)
    CfnApiGatewayManagedOverrides: typing.Optional[dict[str, models.aws_apigatewayv2.CfnApiGatewayManagedOverridesDef]] = pydantic.Field(None)
    CfnApiMapping: typing.Optional[dict[str, models.aws_apigatewayv2.CfnApiMappingDef]] = pydantic.Field(None)
    CfnAuthorizer: typing.Optional[dict[str, models.aws_apigatewayv2.CfnAuthorizerDef]] = pydantic.Field(None)
    CfnDeployment: typing.Optional[dict[str, models.aws_apigatewayv2.CfnDeploymentDef]] = pydantic.Field(None)
    CfnDomainName: typing.Optional[dict[str, models.aws_apigatewayv2.CfnDomainNameDef]] = pydantic.Field(None)
    CfnIntegration: typing.Optional[dict[str, models.aws_apigatewayv2.CfnIntegrationDef]] = pydantic.Field(None)
    CfnIntegrationResponse: typing.Optional[dict[str, models.aws_apigatewayv2.CfnIntegrationResponseDef]] = pydantic.Field(None)
    CfnModel: typing.Optional[dict[str, models.aws_apigatewayv2.CfnModelDef]] = pydantic.Field(None)
    CfnRoute: typing.Optional[dict[str, models.aws_apigatewayv2.CfnRouteDef]] = pydantic.Field(None)
    CfnRouteResponse: typing.Optional[dict[str, models.aws_apigatewayv2.CfnRouteResponseDef]] = pydantic.Field(None)
    CfnStage: typing.Optional[dict[str, models.aws_apigatewayv2.CfnStageDef]] = pydantic.Field(None)
    CfnVpcLink: typing.Optional[dict[str, models.aws_apigatewayv2.CfnVpcLinkDef]] = pydantic.Field(None)
    CfnApiGatewayManagedOverridesProps: typing.Optional[dict[str, models.aws_apigatewayv2.CfnApiGatewayManagedOverridesPropsDef]] = pydantic.Field(None)
    CfnApiMappingProps: typing.Optional[dict[str, models.aws_apigatewayv2.CfnApiMappingPropsDef]] = pydantic.Field(None)
    CfnApiProps: typing.Optional[dict[str, models.aws_apigatewayv2.CfnApiPropsDef]] = pydantic.Field(None)
    CfnAuthorizerProps: typing.Optional[dict[str, models.aws_apigatewayv2.CfnAuthorizerPropsDef]] = pydantic.Field(None)
    CfnDeploymentProps: typing.Optional[dict[str, models.aws_apigatewayv2.CfnDeploymentPropsDef]] = pydantic.Field(None)
    CfnDomainNameProps: typing.Optional[dict[str, models.aws_apigatewayv2.CfnDomainNamePropsDef]] = pydantic.Field(None)
    CfnIntegrationProps: typing.Optional[dict[str, models.aws_apigatewayv2.CfnIntegrationPropsDef]] = pydantic.Field(None)
    CfnIntegrationResponseProps: typing.Optional[dict[str, models.aws_apigatewayv2.CfnIntegrationResponsePropsDef]] = pydantic.Field(None)
    CfnModelProps: typing.Optional[dict[str, models.aws_apigatewayv2.CfnModelPropsDef]] = pydantic.Field(None)
    CfnRouteProps: typing.Optional[dict[str, models.aws_apigatewayv2.CfnRoutePropsDef]] = pydantic.Field(None)
    CfnRouteResponseProps: typing.Optional[dict[str, models.aws_apigatewayv2.CfnRouteResponsePropsDef]] = pydantic.Field(None)
    CfnStageProps: typing.Optional[dict[str, models.aws_apigatewayv2.CfnStagePropsDef]] = pydantic.Field(None)
    CfnVpcLinkProps: typing.Optional[dict[str, models.aws_apigatewayv2.CfnVpcLinkPropsDef]] = pydantic.Field(None)
    ...

import models
