from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams

#  autogenerated from aws_cdk.aws_secretsmanager.HostedRotation
class HostedRotationDef(BaseClass, ConnectableMixin):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = ['maria_db_multi_user', 'maria_db_single_user', 'mongo_db_multi_user', 'mongo_db_single_user', 'mysql_multi_user', 'mysql_single_user', 'oracle_multi_user', 'oracle_single_user', 'postgre_sql_multi_user', 'postgre_sql_single_user', 'redshift_multi_user', 'redshift_single_user', 'sql_server_multi_user', 'sql_server_single_user']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.HostedRotation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[HostedRotationDefConfig] = pydantic.Field(None)


class HostedRotationDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[HostedRotationDefBindParams]] = pydantic.Field(None, description='Binds this hosted rotation to a secret.')
    maria_db_multi_user: typing.Optional[list[HostedRotationDefMariaDbMultiUserParams]] = pydantic.Field(None, description='MariaDB Multi User.')
    maria_db_single_user: typing.Optional[list[HostedRotationDefMariaDbSingleUserParams]] = pydantic.Field(None, description='MariaDB Single User.')
    mongo_db_multi_user: typing.Optional[list[HostedRotationDefMongoDbMultiUserParams]] = pydantic.Field(None, description='MongoDB Multi User.')
    mongo_db_single_user: typing.Optional[list[HostedRotationDefMongoDbSingleUserParams]] = pydantic.Field(None, description='MongoDB Single User.')
    mysql_multi_user: typing.Optional[list[HostedRotationDefMysqlMultiUserParams]] = pydantic.Field(None, description='MySQL Multi User.')
    mysql_single_user: typing.Optional[list[HostedRotationDefMysqlSingleUserParams]] = pydantic.Field(None, description='MySQL Single User.')
    oracle_multi_user: typing.Optional[list[HostedRotationDefOracleMultiUserParams]] = pydantic.Field(None, description='Oracle Multi User.')
    oracle_single_user: typing.Optional[list[HostedRotationDefOracleSingleUserParams]] = pydantic.Field(None, description='Oracle Single User.')
    postgre_sql_multi_user: typing.Optional[list[HostedRotationDefPostgreSqlMultiUserParams]] = pydantic.Field(None, description='PostgreSQL Multi User.')
    postgre_sql_single_user: typing.Optional[list[HostedRotationDefPostgreSqlSingleUserParams]] = pydantic.Field(None, description='PostgreSQL Single User.')
    redshift_multi_user: typing.Optional[list[HostedRotationDefRedshiftMultiUserParams]] = pydantic.Field(None, description='Redshift Multi User.')
    redshift_single_user: typing.Optional[list[HostedRotationDefRedshiftSingleUserParams]] = pydantic.Field(None, description='Redshift Single User.')
    sql_server_multi_user: typing.Optional[list[HostedRotationDefSqlServerMultiUserParams]] = pydantic.Field(None, description='SQL Server Multi User.')
    sql_server_single_user: typing.Optional[list[HostedRotationDefSqlServerSingleUserParams]] = pydantic.Field(None, description='SQL Server Single User.')
    connections_config: typing.Optional[models.aws_ec2.ConnectionsDefConfig] = pydantic.Field(None)

class HostedRotationDefBindParams(pydantic.BaseModel):
    secret: typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef] = pydantic.Field(..., description='-\n')
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class HostedRotationDefMariaDbMultiUserParams(pydantic.BaseModel):
    master_secret: typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef] = pydantic.Field(..., description='The master secret for a multi user rotation scheme.\n')
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='A string of the characters that you don\'t want in the password. Default: the same exclude characters as the ones used for the secret or " %+~`#$&*()|[]{}:;<>?!\'/@"\\"\n')
    function_name: typing.Optional[str] = pydantic.Field(None, description='A name for the Lambda created to rotate the secret. Default: - a CloudFormation generated name\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='A list of security groups for the Lambda created to rotate the secret. Default: - a new security group is created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the Lambda rotation function will run. Default: - the Lambda is not deployed in a VPC\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of subnets in the VPC where the Lambda rotation function will run. Default: - the Vpc default strategy if not specified.')
    return_config: typing.Optional[list[models.aws_secretsmanager.HostedRotationDefConfig]] = pydantic.Field(None)
    ...

class HostedRotationDefMariaDbSingleUserParams(pydantic.BaseModel):
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='A string of the characters that you don\'t want in the password. Default: the same exclude characters as the ones used for the secret or " %+~`#$&*()|[]{}:;<>?!\'/@"\\"\n')
    function_name: typing.Optional[str] = pydantic.Field(None, description='A name for the Lambda created to rotate the secret. Default: - a CloudFormation generated name\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='A list of security groups for the Lambda created to rotate the secret. Default: - a new security group is created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the Lambda rotation function will run. Default: - the Lambda is not deployed in a VPC\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of subnets in the VPC where the Lambda rotation function will run. Default: - the Vpc default strategy if not specified.')
    return_config: typing.Optional[list[models.aws_secretsmanager.HostedRotationDefConfig]] = pydantic.Field(None)
    ...

class HostedRotationDefMongoDbMultiUserParams(pydantic.BaseModel):
    master_secret: typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef] = pydantic.Field(..., description='The master secret for a multi user rotation scheme.\n')
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='A string of the characters that you don\'t want in the password. Default: the same exclude characters as the ones used for the secret or " %+~`#$&*()|[]{}:;<>?!\'/@"\\"\n')
    function_name: typing.Optional[str] = pydantic.Field(None, description='A name for the Lambda created to rotate the secret. Default: - a CloudFormation generated name\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='A list of security groups for the Lambda created to rotate the secret. Default: - a new security group is created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the Lambda rotation function will run. Default: - the Lambda is not deployed in a VPC\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of subnets in the VPC where the Lambda rotation function will run. Default: - the Vpc default strategy if not specified.')
    return_config: typing.Optional[list[models.aws_secretsmanager.HostedRotationDefConfig]] = pydantic.Field(None)
    ...

class HostedRotationDefMongoDbSingleUserParams(pydantic.BaseModel):
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='A string of the characters that you don\'t want in the password. Default: the same exclude characters as the ones used for the secret or " %+~`#$&*()|[]{}:;<>?!\'/@"\\"\n')
    function_name: typing.Optional[str] = pydantic.Field(None, description='A name for the Lambda created to rotate the secret. Default: - a CloudFormation generated name\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='A list of security groups for the Lambda created to rotate the secret. Default: - a new security group is created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the Lambda rotation function will run. Default: - the Lambda is not deployed in a VPC\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of subnets in the VPC where the Lambda rotation function will run. Default: - the Vpc default strategy if not specified.')
    return_config: typing.Optional[list[models.aws_secretsmanager.HostedRotationDefConfig]] = pydantic.Field(None)
    ...

class HostedRotationDefMysqlMultiUserParams(pydantic.BaseModel):
    master_secret: typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef] = pydantic.Field(..., description='The master secret for a multi user rotation scheme.\n')
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='A string of the characters that you don\'t want in the password. Default: the same exclude characters as the ones used for the secret or " %+~`#$&*()|[]{}:;<>?!\'/@"\\"\n')
    function_name: typing.Optional[str] = pydantic.Field(None, description='A name for the Lambda created to rotate the secret. Default: - a CloudFormation generated name\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='A list of security groups for the Lambda created to rotate the secret. Default: - a new security group is created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the Lambda rotation function will run. Default: - the Lambda is not deployed in a VPC\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of subnets in the VPC where the Lambda rotation function will run. Default: - the Vpc default strategy if not specified.')
    return_config: typing.Optional[list[models.aws_secretsmanager.HostedRotationDefConfig]] = pydantic.Field(None)
    ...

class HostedRotationDefMysqlSingleUserParams(pydantic.BaseModel):
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='A string of the characters that you don\'t want in the password. Default: the same exclude characters as the ones used for the secret or " %+~`#$&*()|[]{}:;<>?!\'/@"\\"\n')
    function_name: typing.Optional[str] = pydantic.Field(None, description='A name for the Lambda created to rotate the secret. Default: - a CloudFormation generated name\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='A list of security groups for the Lambda created to rotate the secret. Default: - a new security group is created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the Lambda rotation function will run. Default: - the Lambda is not deployed in a VPC\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of subnets in the VPC where the Lambda rotation function will run. Default: - the Vpc default strategy if not specified.')
    return_config: typing.Optional[list[models.aws_secretsmanager.HostedRotationDefConfig]] = pydantic.Field(None)
    ...

class HostedRotationDefOracleMultiUserParams(pydantic.BaseModel):
    master_secret: typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef] = pydantic.Field(..., description='The master secret for a multi user rotation scheme.\n')
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='A string of the characters that you don\'t want in the password. Default: the same exclude characters as the ones used for the secret or " %+~`#$&*()|[]{}:;<>?!\'/@"\\"\n')
    function_name: typing.Optional[str] = pydantic.Field(None, description='A name for the Lambda created to rotate the secret. Default: - a CloudFormation generated name\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='A list of security groups for the Lambda created to rotate the secret. Default: - a new security group is created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the Lambda rotation function will run. Default: - the Lambda is not deployed in a VPC\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of subnets in the VPC where the Lambda rotation function will run. Default: - the Vpc default strategy if not specified.')
    return_config: typing.Optional[list[models.aws_secretsmanager.HostedRotationDefConfig]] = pydantic.Field(None)
    ...

class HostedRotationDefOracleSingleUserParams(pydantic.BaseModel):
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='A string of the characters that you don\'t want in the password. Default: the same exclude characters as the ones used for the secret or " %+~`#$&*()|[]{}:;<>?!\'/@"\\"\n')
    function_name: typing.Optional[str] = pydantic.Field(None, description='A name for the Lambda created to rotate the secret. Default: - a CloudFormation generated name\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='A list of security groups for the Lambda created to rotate the secret. Default: - a new security group is created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the Lambda rotation function will run. Default: - the Lambda is not deployed in a VPC\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of subnets in the VPC where the Lambda rotation function will run. Default: - the Vpc default strategy if not specified.')
    return_config: typing.Optional[list[models.aws_secretsmanager.HostedRotationDefConfig]] = pydantic.Field(None)
    ...

class HostedRotationDefPostgreSqlMultiUserParams(pydantic.BaseModel):
    master_secret: typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef] = pydantic.Field(..., description='The master secret for a multi user rotation scheme.\n')
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='A string of the characters that you don\'t want in the password. Default: the same exclude characters as the ones used for the secret or " %+~`#$&*()|[]{}:;<>?!\'/@"\\"\n')
    function_name: typing.Optional[str] = pydantic.Field(None, description='A name for the Lambda created to rotate the secret. Default: - a CloudFormation generated name\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='A list of security groups for the Lambda created to rotate the secret. Default: - a new security group is created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the Lambda rotation function will run. Default: - the Lambda is not deployed in a VPC\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of subnets in the VPC where the Lambda rotation function will run. Default: - the Vpc default strategy if not specified.')
    return_config: typing.Optional[list[models.aws_secretsmanager.HostedRotationDefConfig]] = pydantic.Field(None)
    ...

class HostedRotationDefPostgreSqlSingleUserParams(pydantic.BaseModel):
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='A string of the characters that you don\'t want in the password. Default: the same exclude characters as the ones used for the secret or " %+~`#$&*()|[]{}:;<>?!\'/@"\\"\n')
    function_name: typing.Optional[str] = pydantic.Field(None, description='A name for the Lambda created to rotate the secret. Default: - a CloudFormation generated name\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='A list of security groups for the Lambda created to rotate the secret. Default: - a new security group is created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the Lambda rotation function will run. Default: - the Lambda is not deployed in a VPC\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of subnets in the VPC where the Lambda rotation function will run. Default: - the Vpc default strategy if not specified.')
    return_config: typing.Optional[list[models.aws_secretsmanager.HostedRotationDefConfig]] = pydantic.Field(None)
    ...

class HostedRotationDefRedshiftMultiUserParams(pydantic.BaseModel):
    master_secret: typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef] = pydantic.Field(..., description='The master secret for a multi user rotation scheme.\n')
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='A string of the characters that you don\'t want in the password. Default: the same exclude characters as the ones used for the secret or " %+~`#$&*()|[]{}:;<>?!\'/@"\\"\n')
    function_name: typing.Optional[str] = pydantic.Field(None, description='A name for the Lambda created to rotate the secret. Default: - a CloudFormation generated name\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='A list of security groups for the Lambda created to rotate the secret. Default: - a new security group is created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the Lambda rotation function will run. Default: - the Lambda is not deployed in a VPC\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of subnets in the VPC where the Lambda rotation function will run. Default: - the Vpc default strategy if not specified.')
    return_config: typing.Optional[list[models.aws_secretsmanager.HostedRotationDefConfig]] = pydantic.Field(None)
    ...

class HostedRotationDefRedshiftSingleUserParams(pydantic.BaseModel):
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='A string of the characters that you don\'t want in the password. Default: the same exclude characters as the ones used for the secret or " %+~`#$&*()|[]{}:;<>?!\'/@"\\"\n')
    function_name: typing.Optional[str] = pydantic.Field(None, description='A name for the Lambda created to rotate the secret. Default: - a CloudFormation generated name\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='A list of security groups for the Lambda created to rotate the secret. Default: - a new security group is created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the Lambda rotation function will run. Default: - the Lambda is not deployed in a VPC\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of subnets in the VPC where the Lambda rotation function will run. Default: - the Vpc default strategy if not specified.')
    return_config: typing.Optional[list[models.aws_secretsmanager.HostedRotationDefConfig]] = pydantic.Field(None)
    ...

class HostedRotationDefSqlServerMultiUserParams(pydantic.BaseModel):
    master_secret: typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef] = pydantic.Field(..., description='The master secret for a multi user rotation scheme.\n')
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='A string of the characters that you don\'t want in the password. Default: the same exclude characters as the ones used for the secret or " %+~`#$&*()|[]{}:;<>?!\'/@"\\"\n')
    function_name: typing.Optional[str] = pydantic.Field(None, description='A name for the Lambda created to rotate the secret. Default: - a CloudFormation generated name\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='A list of security groups for the Lambda created to rotate the secret. Default: - a new security group is created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the Lambda rotation function will run. Default: - the Lambda is not deployed in a VPC\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of subnets in the VPC where the Lambda rotation function will run. Default: - the Vpc default strategy if not specified.')
    return_config: typing.Optional[list[models.aws_secretsmanager.HostedRotationDefConfig]] = pydantic.Field(None)
    ...

class HostedRotationDefSqlServerSingleUserParams(pydantic.BaseModel):
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='A string of the characters that you don\'t want in the password. Default: the same exclude characters as the ones used for the secret or " %+~`#$&*()|[]{}:;<>?!\'/@"\\"\n')
    function_name: typing.Optional[str] = pydantic.Field(None, description='A name for the Lambda created to rotate the secret. Default: - a CloudFormation generated name\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='A list of security groups for the Lambda created to rotate the secret. Default: - a new security group is created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the Lambda rotation function will run. Default: - the Lambda is not deployed in a VPC\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of subnets in the VPC where the Lambda rotation function will run. Default: - the Vpc default strategy if not specified.')
    return_config: typing.Optional[list[models.aws_secretsmanager.HostedRotationDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_secretsmanager.HostedRotationType
class HostedRotationTypeDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.HostedRotationType'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_secretsmanager.SecretRotationApplication
class SecretRotationApplicationDef(BaseClass):
    application_id: str = pydantic.Field(..., description='-')
    semantic_version: str = pydantic.Field(..., description='-\n')
    is_multi_user: typing.Optional[bool] = pydantic.Field(None, description='Whether the rotation application uses the mutli user scheme. Default: false')
    _init_params: typing.ClassVar[list[str]] = ['application_id', 'semantic_version', 'is_multi_user']
    _method_names: typing.ClassVar[list[str]] = ['application_arn_for_partition', 'semantic_version_for_partition']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.SecretRotationApplication'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[SecretRotationApplicationDefConfig] = pydantic.Field(None)


class SecretRotationApplicationDefConfig(pydantic.BaseModel):
    application_arn_for_partition: typing.Optional[list[SecretRotationApplicationDefApplicationArnForPartitionParams]] = pydantic.Field(None, description='Returns the application ARN for the current partition.\nCan be used in combination with a ``CfnMapping`` to automatically select the correct ARN based on the current partition.')
    semantic_version_for_partition: typing.Optional[list[SecretRotationApplicationDefSemanticVersionForPartitionParams]] = pydantic.Field(None, description='The semantic version of the app for the current partition.\nCan be used in combination with a ``CfnMapping`` to automatically select the correct version based on the current partition.')

class SecretRotationApplicationDefApplicationArnForPartitionParams(pydantic.BaseModel):
    partition: str = pydantic.Field(..., description='-')
    ...

class SecretRotationApplicationDefSemanticVersionForPartitionParams(pydantic.BaseModel):
    partition: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_secretsmanager.SecretStringValueBeta1
class SecretStringValueBeta1Def(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['secret_value']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_token', 'from_unsafe_plaintext']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.SecretStringValueBeta1'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_token', 'from_unsafe_plaintext']
    ...


    from_token: typing.Optional[SecretStringValueBeta1DefFromTokenParams] = pydantic.Field(None, description='(deprecated) Creates a ``SecretValueValueBeta1`` from a string value coming from a Token.\nThe intent is to enable creating secrets from references (e.g., ``Ref``, ``Fn::GetAtt``) from other resources.\nThis might be the direct output of another Construct, or the output of a Custom Resource.\nThis method throws if it determines the input is an unsafe plaintext string.\n\nFor example::\n\n   # Creates a new IAM user, access and secret keys, and stores the secret access key in a Secret.\n   user = iam.User(self, "User")\n   access_key = iam.AccessKey(self, "AccessKey", user=user)\n   secret = secretsmanager.Secret(self, "Secret",\n       secret_string_value=access_key.secret_access_key\n   )\n\nThe secret may also be embedded in a string representation of a JSON structure::\n\n   user = iam.User(self, "User")\n   access_key = iam.AccessKey(self, "AccessKey", user=user)\n   secret_value = secretsmanager.SecretStringValueBeta1.from_token(JSON.stringify({\n       "username": user.user_name,\n       "database": "foo",\n       "password": access_key.secret_access_key.unsafe_unwrap()\n   }))\n\nNote that the value being a Token does *not* guarantee safety. For example, a Lazy-evaluated string\n(e.g., ``Lazy.string({ produce: () => \'myInsecurePassword\' }))``) is a Token, but as the output is\nultimately a plaintext string, and so insecure.')
    from_unsafe_plaintext: typing.Optional[SecretStringValueBeta1DefFromUnsafePlaintextParams] = pydantic.Field(None, description='(deprecated) Creates a ``SecretStringValueBeta1`` from a plaintext value.\nThis approach is inherently unsafe, as the secret value may be visible in your source control repository\nand will also appear in plaintext in the resulting CloudFormation template, including in the AWS Console or APIs.\nUsage of this method is discouraged, especially for production workloads.')
    resource_config: typing.Optional[SecretStringValueBeta1DefConfig] = pydantic.Field(None)


class SecretStringValueBeta1DefConfig(pydantic.BaseModel):
    secret_value: typing.Optional[bool] = pydantic.Field(None, description='(deprecated) Returns the secret value.\n:stability: deprecated')

class SecretStringValueBeta1DefFromTokenParams(pydantic.BaseModel):
    secret_value_from_token: str = pydantic.Field(..., description='a secret value coming from a Construct attribute or Custom Resource output.\n\n:stability: deprecated\n')
    ...

class SecretStringValueBeta1DefFromUnsafePlaintextParams(pydantic.BaseModel):
    secret_value: str = pydantic.Field(..., description='-\n\n:stability: deprecated\n')
    ...


#  autogenerated from aws_cdk.aws_secretsmanager.ResourcePolicy
class ResourcePolicyDef(BaseConstruct):
    secret: typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef] = pydantic.Field(..., description='The secret to attach a resource-based permissions policy.')
    _init_params: typing.ClassVar[list[str]] = ['secret']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.ResourcePolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ResourcePolicyDefConfig] = pydantic.Field(None)


class ResourcePolicyDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    document_config: typing.Optional[models.aws_iam.PolicyDocumentDefConfig] = pydantic.Field(None)

class ResourcePolicyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_secretsmanager.RotationSchedule
class RotationScheduleDef(BaseConstruct):
    secret: typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef] = pydantic.Field(..., description='The secret to rotate. If hosted rotation is used, this must be a JSON string with the following format:: { "engine": <required: database engine>, "host": <required: instance host name>, "username": <required: username>, "password": <required: password>, "dbname": <optional: database name>, "port": <optional: if not specified, default port will be used>, "masterarn": <required for multi user rotation: the arn of the master secret which will be used to create users/change passwords> } This is typically the case for a secret referenced from an ``AWS::SecretsManager::SecretTargetAttachment`` or an ``ISecret`` returned by the ``attach()`` method of ``Secret``.\n')
    automatically_after: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. A value of zero will disable automatic rotation - ``Duration.days(0)``. Default: Duration.days(30)\n')
    hosted_rotation: typing.Optional[models.aws_secretsmanager.HostedRotationDef] = pydantic.Field(None, description='Hosted rotation. Default: - either ``rotationLambda`` or ``hostedRotation`` must be specified\n')
    rotate_immediately_on_update: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to rotate the secret immediately or wait until the next scheduled rotation window. Default: - secret is rotated immediately\n')
    rotation_lambda: typing.Optional[typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef]] = pydantic.Field(None, description='A Lambda function that can rotate the secret. Default: - either ``rotationLambda`` or ``hostedRotation`` must be specified')
    _init_params: typing.ClassVar[list[str]] = ['secret', 'automatically_after', 'hosted_rotation', 'rotate_immediately_on_update', 'rotation_lambda']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.RotationSchedule'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[RotationScheduleDefConfig] = pydantic.Field(None)


class RotationScheduleDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class RotationScheduleDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_secretsmanager.Secret
class SecretDef(BaseConstruct):
    description: typing.Optional[str] = pydantic.Field(None, description='An optional, human-friendly description of the secret. Default: - No description.\n')
    encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The customer-managed encryption key to use for encrypting the secret value. Default: - A default KMS key for the account and region is used.\n')
    generate_secret_string: typing.Union[models.aws_secretsmanager.SecretStringGeneratorDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configuration for how to generate a secret value. Only one of ``secretString`` and ``generateSecretString`` can be provided. Default: - 32 characters with upper-case letters, lower-case letters, punctuation and numbers (at least one from each category), per the default values of ``SecretStringGenerator``.\n')
    removal_policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='Policy to apply when the secret is removed from this stack. Default: - Not set.\n')
    replica_regions: typing.Optional[typing.Sequence[typing.Union[models.aws_secretsmanager.ReplicaRegionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of regions where to replicate this secret. Default: - Secret is not replicated\n')
    secret_name: typing.Optional[str] = pydantic.Field(None, description='A name for the secret. Note that deleting secrets from SecretsManager does not happen immediately, but after a 7 to 30 days blackout period. During that period, it is not possible to create another secret that shares the same name. Default: - A name is generated by CloudFormation.\n')
    secret_object_value: typing.Optional[typing.Mapping[str, models.SecretValueDef]] = pydantic.Field(None, description="Initial value for a JSON secret. **NOTE:** *It is **highly** encouraged to leave this field undefined and allow SecretsManager to create the secret value. The secret object -- if provided -- will be included in the output of the cdk as part of synthesis, and will appear in the CloudFormation template in the console. This can be secure(-ish) if that value is merely reference to another resource (or one of its attributes), but if the value is a plaintext string, it will be visible to anyone with access to the CloudFormation template (via the AWS Console, SDKs, or CLI). Specifies a JSON object that you want to encrypt and store in this new version of the secret. To specify a simple string value instead, use ``SecretProps.secretStringValue`` Only one of ``secretStringBeta1``, ``secretStringValue``, 'secretObjectValue', and ``generateSecretString`` can be provided. Default: - SecretsManager generates a new secret value.\n")
    secret_string_beta1: typing.Optional[models.aws_secretsmanager.SecretStringValueBeta1Def] = pydantic.Field(None, description='(deprecated) Initial value for the secret. **NOTE:** *It is **highly** encouraged to leave this field undefined and allow SecretsManager to create the secret value. The secret string -- if provided -- will be included in the output of the cdk as part of synthesis, and will appear in the CloudFormation template in the console. This can be secure(-ish) if that value is merely reference to another resource (or one of its attributes), but if the value is a plaintext string, it will be visible to anyone with access to the CloudFormation template (via the AWS Console, SDKs, or CLI). Specifies text data that you want to encrypt and store in this new version of the secret. May be a simple string value, or a string representation of a JSON structure. Only one of ``secretStringBeta1``, ``secretStringValue``, and ``generateSecretString`` can be provided. Default: - SecretsManager generates a new secret value.\n')
    secret_string_value: typing.Optional[models.SecretValueDef] = pydantic.Field(None, description="Initial value for the secret. **NOTE:** *It is **highly** encouraged to leave this field undefined and allow SecretsManager to create the secret value. The secret string -- if provided -- will be included in the output of the cdk as part of synthesis, and will appear in the CloudFormation template in the console. This can be secure(-ish) if that value is merely reference to another resource (or one of its attributes), but if the value is a plaintext string, it will be visible to anyone with access to the CloudFormation template (via the AWS Console, SDKs, or CLI). Specifies text data that you want to encrypt and store in this new version of the secret. May be a simple string value. To provide a string representation of JSON structure, use ``SecretProps.secretObjectValue`` instead. Only one of ``secretStringBeta1``, ``secretStringValue``, 'secretObjectValue', and ``generateSecretString`` can be provided. Default: - SecretsManager generates a new secret value.")
    _init_params: typing.ClassVar[list[str]] = ['description', 'encryption_key', 'generate_secret_string', 'removal_policy', 'replica_regions', 'secret_name', 'secret_object_value', 'secret_string_beta1', 'secret_string_value']
    _method_names: typing.ClassVar[list[str]] = ['add_replica_region', 'add_rotation_schedule', 'add_to_resource_policy', 'apply_removal_policy', 'attach', 'deny_account_root_delete', 'grant_read', 'grant_write', 'secret_value_from_json']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_secret_attributes', 'from_secret_complete_arn', 'from_secret_name_v2', 'from_secret_partial_arn']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.Secret'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_secret_attributes', 'from_secret_complete_arn', 'from_secret_name_v2', 'from_secret_partial_arn']
    ...


    from_secret_attributes: typing.Optional[SecretDefFromSecretAttributesParams] = pydantic.Field(None, description='Import an existing secret into the Stack.')
    from_secret_complete_arn: typing.Optional[SecretDefFromSecretCompleteArnParams] = pydantic.Field(None, description='Imports a secret by complete ARN.\nThe complete ARN is the ARN with the Secrets Manager-supplied suffix.')
    from_secret_name_v2: typing.Optional[SecretDefFromSecretNameV2Params] = pydantic.Field(None, description='Imports a secret by secret name.\nA secret with this name must exist in the same account & region.\nReplaces the deprecated ``fromSecretName``.\nPlease note this method returns ISecret that only contains partial ARN and could lead to AccessDeniedException\nwhen you pass the partial ARN to CLI or SDK to get the secret value. If your secret name ends with a hyphen and\n6 characters, you should always use fromSecretCompleteArn() to avoid potential AccessDeniedException.')
    from_secret_partial_arn: typing.Optional[SecretDefFromSecretPartialArnParams] = pydantic.Field(None, description='Imports a secret by partial ARN.\nThe partial ARN is the ARN without the Secrets Manager-supplied suffix.')
    resource_config: typing.Optional[SecretDefConfig] = pydantic.Field(None)


class SecretDefConfig(pydantic.BaseModel):
    add_replica_region: typing.Optional[list[SecretDefAddReplicaRegionParams]] = pydantic.Field(None, description='Adds a replica region for the secret.')
    add_rotation_schedule: typing.Optional[list[SecretDefAddRotationScheduleParams]] = pydantic.Field(None, description='Adds a rotation schedule to the secret.')
    add_to_resource_policy: typing.Optional[list[SecretDefAddToResourcePolicyParams]] = pydantic.Field(None, description='Adds a statement to the IAM resource policy associated with this secret.\nIf this secret was created in this stack, a resource policy will be\nautomatically created upon the first call to ``addToResourcePolicy``. If\nthe secret is imported, then this is a no-op.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    attach: typing.Optional[list[SecretDefAttachParams]] = pydantic.Field(None, description='Attach a target to this secret.')
    deny_account_root_delete: typing.Optional[bool] = pydantic.Field(None, description='Denies the ``DeleteSecret`` action to all principals within the current account.')
    grant_read: typing.Optional[list[SecretDefGrantReadParams]] = pydantic.Field(None, description='Grants reading the secret value to some role.')
    grant_write: typing.Optional[list[SecretDefGrantWriteParams]] = pydantic.Field(None, description='Grants writing and updating the secret value to some role.')
    secret_value_from_json: typing.Optional[list[SecretDefSecretValueFromJsonParams]] = pydantic.Field(None, description="Interpret the secret as a JSON object and return a field's value from it as a ``SecretValue``.")
    secret_value_config: typing.Optional[models.core.SecretValueDefConfig] = pydantic.Field(None)

class SecretDefAddReplicaRegionParams(pydantic.BaseModel):
    region: str = pydantic.Field(..., description='The name of the region.\n')
    encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The customer-managed encryption key to use for encrypting the secret value.')
    ...

class SecretDefAddRotationScheduleParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    automatically_after: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. A value of zero will disable automatic rotation - ``Duration.days(0)``. Default: Duration.days(30)\n')
    hosted_rotation: typing.Optional[models.aws_secretsmanager.HostedRotationDef] = pydantic.Field(None, description='Hosted rotation. Default: - either ``rotationLambda`` or ``hostedRotation`` must be specified\n')
    rotate_immediately_on_update: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to rotate the secret immediately or wait until the next scheduled rotation window. Default: - secret is rotated immediately\n')
    rotation_lambda: typing.Optional[typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef]] = pydantic.Field(None, description='A Lambda function that can rotate the secret. Default: - either ``rotationLambda`` or ``hostedRotation`` must be specified')
    return_config: typing.Optional[list[models.aws_secretsmanager.RotationScheduleDefConfig]] = pydantic.Field(None)
    ...

class SecretDefAddToResourcePolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class SecretDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class SecretDefAttachParams(pydantic.BaseModel):
    target: typing.Union[models.aws_rds.DatabaseProxyDef] = pydantic.Field(..., description='The target to attach.\n')
    return_config: typing.Optional[list[models._interface_methods.AwsSecretsmanagerISecretDefConfig]] = pydantic.Field(None)
    ...

class SecretDefFromSecretAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the scope of the import.\n')
    id: str = pydantic.Field(..., description='the ID of the imported Secret in the construct tree.\n')
    encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The encryption key that is used to encrypt the secret, unless the default SecretsManager key is used.\n')
    secret_complete_arn: typing.Optional[str] = pydantic.Field(None, description='The complete ARN of the secret in SecretsManager. This is the ARN including the Secrets Manager 6-character suffix. Cannot be used with ``secretArn`` or ``secretPartialArn``.\n')
    secret_partial_arn: typing.Optional[str] = pydantic.Field(None, description='The partial ARN of the secret in SecretsManager. This is the ARN without the Secrets Manager 6-character suffix. Cannot be used with ``secretArn`` or ``secretCompleteArn``.')
    ...

class SecretDefFromSecretCompleteArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    secret_complete_arn: str = pydantic.Field(..., description='-')
    ...

class SecretDefFromSecretNameV2Params(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    secret_name: str = pydantic.Field(..., description='-\n\n:see: https://docs.aws.amazon.com/secretsmanager/latest/userguide/troubleshoot.html#ARN_secretnamehyphen\n')
    ...

class SecretDefFromSecretPartialArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    secret_partial_arn: str = pydantic.Field(..., description='-')
    ...

class SecretDefGrantReadParams(pydantic.BaseModel):
    grantee: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='-\n')
    version_stages: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class SecretDefGrantWriteParams(pydantic.BaseModel):
    grantee: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class SecretDefSecretValueFromJsonParams(pydantic.BaseModel):
    json_field: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.core.SecretValueDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_secretsmanager.SecretRotation
class SecretRotationDef(BaseConstruct):
    application: models.aws_secretsmanager.SecretRotationApplicationDef = pydantic.Field(..., description='The serverless application for the rotation.\n')
    secret: typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef] = pydantic.Field(..., description='The secret to rotate. It must be a JSON string with the following format:. Example:: { "engine": <required: database engine>, "host": <required: instance host name>, "username": <required: username>, "password": <required: password>, "dbname": <optional: database name>, "port": <optional: if not specified, default port will be used>, "masterarn": <required for multi user rotation: the arn of the master secret which will be used to create users/change passwords> } This is typically the case for a secret referenced from an ``AWS::SecretsManager::SecretTargetAttachment`` or an ``ISecret`` returned by the ``attach()`` method of ``Secret``.\n')
    target: typing.Union[models.aws_autoscaling.AutoScalingGroupDef, models.aws_ec2.ConnectionsDef, models.aws_ec2.NatInstanceProviderDef, models.aws_ec2.LaunchTemplateDef, models.aws_elasticloadbalancing.ListenerPortDef, models.aws_elasticloadbalancing.LoadBalancerDef, models.aws_elasticsearch.DomainDef, models.aws_opensearchservice.DomainDef, models.aws_rds.DatabaseProxyDef, models.aws_secretsmanager.HostedRotationDef, models.aws_stepfunctions_tasks.EcsRunTaskDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef] = pydantic.Field(..., description='The target service or database.\n')
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='The VPC where the Lambda rotation function will run.\n')
    automatically_after: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. Default: Duration.days(30)\n')
    endpoint: typing.Optional[typing.Union[models.aws_ec2.InterfaceVpcEndpointDef]] = pydantic.Field(None, description="The VPC interface endpoint to use for the Secrets Manager API. If you enable private DNS hostnames for your VPC private endpoint (the default), you don't need to specify an endpoint. The standard Secrets Manager DNS hostname the Secrets Manager CLI and SDKs use by default (https://secretsmanager..amazonaws.com) automatically resolves to your VPC endpoint. Default: https://secretsmanager..amazonaws.com\n")
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='Characters which should not appear in the generated password. Default: - no additional characters are explicitly excluded\n')
    master_secret: typing.Optional[typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef]] = pydantic.Field(None, description='The master secret for a multi user rotation scheme. Default: - single user rotation scheme\n')
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='The security group for the Lambda rotation function. Default: - a new security group is created\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of subnets in the VPC where the Lambda rotation function will run. Default: - the Vpc default strategy if not specified.')
    _init_params: typing.ClassVar[list[str]] = ['application', 'secret', 'target', 'vpc', 'automatically_after', 'endpoint', 'exclude_characters', 'master_secret', 'security_group', 'vpc_subnets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.SecretRotation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_secretsmanager.SecretTargetAttachment
class SecretTargetAttachmentDef(BaseConstruct):
    secret: typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef] = pydantic.Field(..., description='The secret to attach to the target.\n')
    target: typing.Union[models.aws_rds.DatabaseProxyDef] = pydantic.Field(..., description='The target to attach the secret to.')
    _init_params: typing.ClassVar[list[str]] = ['secret', 'target']
    _method_names: typing.ClassVar[list[str]] = ['add_rotation_schedule', 'add_to_resource_policy', 'apply_removal_policy', 'attach', 'deny_account_root_delete', 'grant_read', 'grant_write', 'secret_value_from_json']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_secret_target_attachment_secret_arn']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.SecretTargetAttachment'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_secret_target_attachment_secret_arn']
    ...


    from_secret_target_attachment_secret_arn: typing.Optional[SecretTargetAttachmentDefFromSecretTargetAttachmentSecretArnParams] = pydantic.Field(None, description='')
    resource_config: typing.Optional[SecretTargetAttachmentDefConfig] = pydantic.Field(None)


class SecretTargetAttachmentDefConfig(pydantic.BaseModel):
    add_rotation_schedule: typing.Optional[list[SecretTargetAttachmentDefAddRotationScheduleParams]] = pydantic.Field(None, description='Adds a rotation schedule to the secret.')
    add_to_resource_policy: typing.Optional[list[SecretTargetAttachmentDefAddToResourcePolicyParams]] = pydantic.Field(None, description='Forward any additions to the resource policy to the original secret.\nThis is required because a secret can only have a single resource policy.\nIf we do not forward policy additions, a new policy resource is created using the secret attachment ARN.\nThis ends up being rejected by CloudFormation.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    attach: typing.Optional[list[SecretTargetAttachmentDefAttachParams]] = pydantic.Field(None, description='Attach a target to this secret.')
    deny_account_root_delete: typing.Optional[bool] = pydantic.Field(None, description='Denies the ``DeleteSecret`` action to all principals within the current account.')
    grant_read: typing.Optional[list[SecretTargetAttachmentDefGrantReadParams]] = pydantic.Field(None, description='Grants reading the secret value to some role.')
    grant_write: typing.Optional[list[SecretTargetAttachmentDefGrantWriteParams]] = pydantic.Field(None, description='Grants writing and updating the secret value to some role.')
    secret_value_from_json: typing.Optional[list[SecretTargetAttachmentDefSecretValueFromJsonParams]] = pydantic.Field(None, description="Interpret the secret as a JSON object and return a field's value from it as a ``SecretValue``.")
    secret_value_config: typing.Optional[models.core.SecretValueDefConfig] = pydantic.Field(None)

class SecretTargetAttachmentDefAddRotationScheduleParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    automatically_after: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. A value of zero will disable automatic rotation - ``Duration.days(0)``. Default: Duration.days(30)\n')
    hosted_rotation: typing.Optional[models.aws_secretsmanager.HostedRotationDef] = pydantic.Field(None, description='Hosted rotation. Default: - either ``rotationLambda`` or ``hostedRotation`` must be specified\n')
    rotate_immediately_on_update: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to rotate the secret immediately or wait until the next scheduled rotation window. Default: - secret is rotated immediately\n')
    rotation_lambda: typing.Optional[typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef]] = pydantic.Field(None, description='A Lambda function that can rotate the secret. Default: - either ``rotationLambda`` or ``hostedRotation`` must be specified')
    return_config: typing.Optional[list[models.aws_secretsmanager.RotationScheduleDefConfig]] = pydantic.Field(None)
    ...

class SecretTargetAttachmentDefAddToResourcePolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class SecretTargetAttachmentDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class SecretTargetAttachmentDefAttachParams(pydantic.BaseModel):
    target: typing.Union[models.aws_rds.DatabaseProxyDef] = pydantic.Field(..., description='The target to attach.\n')
    return_config: typing.Optional[list[models._interface_methods.AwsSecretsmanagerISecretDefConfig]] = pydantic.Field(None)
    ...

class SecretTargetAttachmentDefFromSecretTargetAttachmentSecretArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    id: str = pydantic.Field(..., description='-\n')
    secret_target_attachment_secret_arn: str = pydantic.Field(..., description='-')
    ...

class SecretTargetAttachmentDefGrantReadParams(pydantic.BaseModel):
    grantee: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='-\n')
    version_stages: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class SecretTargetAttachmentDefGrantWriteParams(pydantic.BaseModel):
    grantee: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class SecretTargetAttachmentDefSecretValueFromJsonParams(pydantic.BaseModel):
    json_field: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.core.SecretValueDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_secretsmanager.AttachedSecretOptions
class AttachedSecretOptionsDef(BaseStruct):
    target: typing.Union[models.aws_rds.DatabaseProxyDef] = pydantic.Field(..., description='The target to attach the secret to.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_secretsmanager as secretsmanager\n\n    # secret_attachment_target: secretsmanager.ISecretAttachmentTarget\n\n    attached_secret_options = secretsmanager.AttachedSecretOptions(\n        target=secret_attachment_target\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['target']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.AttachedSecretOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_secretsmanager.CfnRotationSchedule.HostedRotationLambdaProperty
class CfnRotationSchedule_HostedRotationLambdaPropertyDef(BaseStruct):
    rotation_type: str = pydantic.Field(..., description='The rotation template to base the rotation function on, one of the following:. - ``MySQLSingleUser`` to use the template `SecretsManagerRDSMySQLRotationSingleUser <https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_available-rotation-templates.html#sar-template-mysql-singleuser>`_ . - ``MySQLMultiUser`` to use the template `SecretsManagerRDSMySQLRotationMultiUser <https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_available-rotation-templates.html#sar-template-mysql-multiuser>`_ . - ``PostgreSQLSingleUser`` to use the template `SecretsManagerRDSPostgreSQLRotationSingleUser <https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_available-rotation-templates.html#sar-template-postgre-singleuser>`_ - ``PostgreSQLMultiUser`` to use the template `SecretsManagerRDSPostgreSQLRotationMultiUser <https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_available-rotation-templates.html#sar-template-postgre-multiuser>`_ . - ``OracleSingleUser`` to use the template `SecretsManagerRDSOracleRotationSingleUser <https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_available-rotation-templates.html#sar-template-oracle-singleuser>`_ . - ``OracleMultiUser`` to use the template `SecretsManagerRDSOracleRotationMultiUser <https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_available-rotation-templates.html#sar-template-oracle-multiuser>`_ . - ``MariaDBSingleUser`` to use the template `SecretsManagerRDSMariaDBRotationSingleUser <https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_available-rotation-templates.html#sar-template-mariadb-singleuser>`_ . - ``MariaDBMultiUser`` to use the template `SecretsManagerRDSMariaDBRotationMultiUser <https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_available-rotation-templates.html#sar-template-mariadb-multiuser>`_ . - ``SQLServerSingleUser`` to use the template `SecretsManagerRDSSQLServerRotationSingleUser <https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_available-rotation-templates.html#sar-template-sqlserver-singleuser>`_ . - ``SQLServerMultiUser`` to use the template `SecretsManagerRDSSQLServerRotationMultiUser <https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_available-rotation-templates.html#sar-template-sqlserver-multiuser>`_ . - ``RedshiftSingleUser`` to use the template `SecretsManagerRedshiftRotationSingleUsr <https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_available-rotation-templates.html#sar-template-redshift-singleuser>`_ . - ``RedshiftMultiUser`` to use the template `SecretsManagerRedshiftRotationMultiUser <https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_available-rotation-templates.html#sar-template-redshift-multiuser>`_ . - ``MongoDBSingleUser`` to use the template `SecretsManagerMongoDBRotationSingleUser <https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_available-rotation-templates.html#sar-template-mongodb-singleuser>`_ . - ``MongoDBMultiUser`` to use the template `SecretsManagerMongoDBRotationMultiUser <https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_available-rotation-templates.html#sar-template-mongodb-multiuser>`_ .\n')
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description="A string of the characters that you don't want in the password.\n")
    kms_key_arn: typing.Optional[str] = pydantic.Field(None, description="The ARN of the KMS key that Secrets Manager uses to encrypt the secret. If you don't specify this value, then Secrets Manager uses the key ``aws/secretsmanager`` . If ``aws/secretsmanager`` doesn't yet exist, then Secrets Manager creates it for you automatically the first time it encrypts the secret value.\n")
    master_secret_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the secret that contains superuser credentials, if you use the `Alternating users rotation strategy <https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotating-secrets_strategies.html#rotating-secrets-two-users>`_ . CloudFormation grants the execution role for the Lambda rotation function ``GetSecretValue`` permission to the secret in this property. For more information, see `Lambda rotation function execution role permissions for Secrets Manager <https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotating-secrets-required-permissions-function.html>`_ . You must create the superuser secret before you can set this property. You must also include the superuser secret ARN as a key in the JSON of the rotating secret so that the Lambda rotation function can find it. CloudFormation does not hardcode secret ARNs in the Lambda rotation function, so you can use the function to rotate multiple secrets. For more information, see `JSON structure of Secrets Manager secrets <https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_secret_json_structure.html>`_ . You can specify ``MasterSecretArn`` or ``SuperuserSecretArn`` but not both. They represent the same superuser secret.\n')
    master_secret_kms_key_arn: typing.Optional[str] = pydantic.Field(None, description="The ARN of the KMS key that Secrets Manager used to encrypt the superuser secret, if you use the `alternating users strategy <https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotating-secrets_strategies.html#rotating-secrets-two-users>`_ and the superuser secret is encrypted with a customer managed key. You don't need to specify this property if the superuser secret is encrypted using the key ``aws/secretsmanager`` . CloudFormation grants the execution role for the Lambda rotation function ``Decrypt`` , ``DescribeKey`` , and ``GenerateDataKey`` permission to the key in this property. For more information, see `Lambda rotation function execution role permissions for Secrets Manager <https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotating-secrets-required-permissions-function.html>`_ . You can specify ``MasterSecretKmsKeyArn`` or ``SuperuserSecretKmsKeyArn`` but not both. They represent the same superuser secret KMS key .\n")
    rotation_lambda_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Lambda rotation function.\n')
    runtime: typing.Optional[str] = pydantic.Field(None, description='By default, CloudFormation deploys Python 3.9 binaries for the rotation function. To use a different version of Python, you must do the following two steps:. - Deploy the matching version Python binaries with your rotation function. - Set the version number in this field. For example, for Python 3.7, enter *python3.7* If you only do one of the steps, your rotation function will be incompatible with the binaries. For more information, see `Why did my Lambda rotation function fail with a "pg module not found" error <https://docs.aws.amazon.com/https://repost.aws/knowledge-center/secrets-manager-lambda-rotation>`_ .\n')
    superuser_secret_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the secret that contains superuser credentials, if you use the `Alternating users rotation strategy <https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotating-secrets_strategies.html#rotating-secrets-two-users>`_ . CloudFormation grants the execution role for the Lambda rotation function ``GetSecretValue`` permission to the secret in this property. For more information, see `Lambda rotation function execution role permissions for Secrets Manager <https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotating-secrets-required-permissions-function.html>`_ . You must create the superuser secret before you can set this property. You must also include the superuser secret ARN as a key in the JSON of the rotating secret so that the Lambda rotation function can find it. CloudFormation does not hardcode secret ARNs in the Lambda rotation function, so you can use the function to rotate multiple secrets. For more information, see `JSON structure of Secrets Manager secrets <https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_secret_json_structure.html>`_ . You can specify ``MasterSecretArn`` or ``SuperuserSecretArn`` but not both. They represent the same superuser secret.\n')
    superuser_secret_kms_key_arn: typing.Optional[str] = pydantic.Field(None, description="The ARN of the KMS key that Secrets Manager used to encrypt the superuser secret, if you use the `alternating users strategy <https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotating-secrets_strategies.html#rotating-secrets-two-users>`_ and the superuser secret is encrypted with a customer managed key. You don't need to specify this property if the superuser secret is encrypted using the key ``aws/secretsmanager`` . CloudFormation grants the execution role for the Lambda rotation function ``Decrypt`` , ``DescribeKey`` , and ``GenerateDataKey`` permission to the key in this property. For more information, see `Lambda rotation function execution role permissions for Secrets Manager <https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotating-secrets-required-permissions-function.html>`_ . You can specify ``MasterSecretKmsKeyArn`` or ``SuperuserSecretKmsKeyArn`` but not both. They represent the same superuser secret KMS key .\n")
    vpc_security_group_ids: typing.Optional[str] = pydantic.Field(None, description='A comma-separated list of security group IDs applied to the target database. The template applies the same security groups as on the Lambda rotation function that is created as part of this stack.\n')
    vpc_subnet_ids: typing.Optional[str] = pydantic.Field(None, description='A comma separated list of VPC subnet IDs of the target database network. The Lambda rotation function is in the same subnet group.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-secretsmanager-rotationschedule-hostedrotationlambda.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_secretsmanager as secretsmanager\n\n    hosted_rotation_lambda_property = secretsmanager.CfnRotationSchedule.HostedRotationLambdaProperty(\n        rotation_type="rotationType",\n\n        # the properties below are optional\n        exclude_characters="excludeCharacters",\n        kms_key_arn="kmsKeyArn",\n        master_secret_arn="masterSecretArn",\n        master_secret_kms_key_arn="masterSecretKmsKeyArn",\n        rotation_lambda_name="rotationLambdaName",\n        runtime="runtime",\n        superuser_secret_arn="superuserSecretArn",\n        superuser_secret_kms_key_arn="superuserSecretKmsKeyArn",\n        vpc_security_group_ids="vpcSecurityGroupIds",\n        vpc_subnet_ids="vpcSubnetIds"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['rotation_type', 'exclude_characters', 'kms_key_arn', 'master_secret_arn', 'master_secret_kms_key_arn', 'rotation_lambda_name', 'runtime', 'superuser_secret_arn', 'superuser_secret_kms_key_arn', 'vpc_security_group_ids', 'vpc_subnet_ids']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.CfnRotationSchedule.HostedRotationLambdaProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_secretsmanager.CfnRotationSchedule.RotationRulesProperty
class CfnRotationSchedule_RotationRulesPropertyDef(BaseStruct):
    automatically_after_days: typing.Union[int, float, None] = pydantic.Field(None, description='The number of days between automatic scheduled rotations of the secret. You can use this value to check that your secret meets your compliance guidelines for how often secrets must be rotated. In ``DescribeSecret`` and ``ListSecrets`` , this value is calculated from the rotation schedule after every successful rotation. In ``RotateSecret`` , you can set the rotation schedule in ``RotationRules`` with ``AutomaticallyAfterDays`` or ``ScheduleExpression`` , but not both.\n')
    duration: typing.Optional[str] = pydantic.Field(None, description="The length of the rotation window in hours, for example ``3h`` for a three hour window. Secrets Manager rotates your secret at any time during this window. The window must not extend into the next rotation window or the next UTC day. The window starts according to the ``ScheduleExpression`` . If you don't specify a ``Duration`` , for a ``ScheduleExpression`` in hours, the window automatically closes after one hour. For a ``ScheduleExpression`` in days, the window automatically closes at the end of the UTC day. For more information, including examples, see `Schedule expressions in Secrets Manager rotation <https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotate-secrets_schedule.html>`_ in the *Secrets Manager Users Guide* .\n")
    schedule_expression: typing.Optional[str] = pydantic.Field(None, description='A ``cron()`` or ``rate()`` expression that defines the schedule for rotating your secret. Secrets Manager rotation schedules use UTC time zone. Secrets Manager rotates your secret any time during a rotation window. Secrets Manager ``rate()`` expressions represent the interval in hours or days that you want to rotate your secret, for example ``rate(12 hours)`` or ``rate(10 days)`` . You can rotate a secret as often as every four hours. If you use a ``rate()`` expression, the rotation window starts at midnight. For a rate in hours, the default rotation window closes after one hour. For a rate in days, the default rotation window closes at the end of the day. You can set the ``Duration`` to change the rotation window. The rotation window must not extend into the next UTC day or into the next rotation window. You can use a ``cron()`` expression to create a rotation schedule that is more detailed than a rotation interval. For more information, including examples, see `Schedule expressions in Secrets Manager rotation <https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotate-secrets_schedule.html>`_ in the *Secrets Manager Users Guide* . For a cron expression that represents a schedule in hours, the default rotation window closes after one hour. For a cron expression that represents a schedule in days, the default rotation window closes at the end of the day. You can set the ``Duration`` to change the rotation window. The rotation window must not extend into the next UTC day or into the next rotation window.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-secretsmanager-rotationschedule-rotationrules.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_secretsmanager as secretsmanager\n\n    rotation_rules_property = secretsmanager.CfnRotationSchedule.RotationRulesProperty(\n        automatically_after_days=123,\n        duration="duration",\n        schedule_expression="scheduleExpression"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['automatically_after_days', 'duration', 'schedule_expression']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.CfnRotationSchedule.RotationRulesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_secretsmanager.CfnSecret.GenerateSecretStringProperty
class CfnSecret_GenerateSecretStringPropertyDef(BaseStruct):
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description="A string of the characters that you don't want in the password.\n")
    exclude_lowercase: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Specifies whether to exclude lowercase letters from the password. If you don't include this switch, the password can contain lowercase letters.\n")
    exclude_numbers: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Specifies whether to exclude numbers from the password. If you don't include this switch, the password can contain numbers.\n")
    exclude_punctuation: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether to exclude the following punctuation characters from the password: `! " # $ % & \' ( ) * + , - . / : ; < = > ? @ [ \\ ] ^ _ `` { | } ~`` . If you don\'t include this switch, the password can contain punctuation.\n')
    exclude_uppercase: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Specifies whether to exclude uppercase letters from the password. If you don't include this switch, the password can contain uppercase letters.\n")
    generate_string_key: typing.Optional[str] = pydantic.Field(None, description='The JSON key name for the key/value pair, where the value is the generated password. This pair is added to the JSON structure specified by the ``SecretStringTemplate`` parameter. If you specify this parameter, then you must also specify ``SecretStringTemplate`` .\n')
    include_space: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether to include the space character. If you include this switch, the password can contain space characters.\n')
    password_length: typing.Union[int, float, None] = pydantic.Field(None, description="The length of the password. If you don't include this parameter, the default length is 32 characters.\n")
    require_each_included_type: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Specifies whether to include at least one upper and lowercase letter, one number, and one punctuation. If you don't include this switch, the password contains at least one of every character type.\n")
    secret_string_template: typing.Optional[str] = pydantic.Field(None, description='A template that the generated string must match. When you make a change to this property, a new secret version is created.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-secretsmanager-secret-generatesecretstring.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_secretsmanager as secretsmanager\n\n    generate_secret_string_property = secretsmanager.CfnSecret.GenerateSecretStringProperty(\n        exclude_characters="excludeCharacters",\n        exclude_lowercase=False,\n        exclude_numbers=False,\n        exclude_punctuation=False,\n        exclude_uppercase=False,\n        generate_string_key="generateStringKey",\n        include_space=False,\n        password_length=123,\n        require_each_included_type=False,\n        secret_string_template="secretStringTemplate"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['exclude_characters', 'exclude_lowercase', 'exclude_numbers', 'exclude_punctuation', 'exclude_uppercase', 'generate_string_key', 'include_space', 'password_length', 'require_each_included_type', 'secret_string_template']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.CfnSecret.GenerateSecretStringProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_secretsmanager.CfnSecret.ReplicaRegionProperty
class CfnSecret_ReplicaRegionPropertyDef(BaseStruct):
    region: str = pydantic.Field(..., description='(Optional) A string that represents a ``Region`` , for example "us-east-1".\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The ARN, key ID, or alias of the KMS key to encrypt the secret. If you don\'t include this field, Secrets Manager uses ``aws/secretsmanager`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-secretsmanager-secret-replicaregion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_secretsmanager as secretsmanager\n\n    replica_region_property = secretsmanager.CfnSecret.ReplicaRegionProperty(\n        region="region",\n\n        # the properties below are optional\n        kms_key_id="kmsKeyId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['region', 'kms_key_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.CfnSecret.ReplicaRegionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_secretsmanager.MultiUserHostedRotationOptions
class MultiUserHostedRotationOptionsDef(BaseStruct):
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='A string of the characters that you don\'t want in the password. Default: the same exclude characters as the ones used for the secret or " %+~`#$&*()|[]{}:;<>?!\'/@"\\"\n')
    function_name: typing.Optional[str] = pydantic.Field(None, description='A name for the Lambda created to rotate the secret. Default: - a CloudFormation generated name\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='A list of security groups for the Lambda created to rotate the secret. Default: - a new security group is created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the Lambda rotation function will run. Default: - the Lambda is not deployed in a VPC\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of subnets in the VPC where the Lambda rotation function will run. Default: - the Vpc default strategy if not specified.\n')
    master_secret: typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef] = pydantic.Field(..., description='The master secret for a multi user rotation scheme.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n    from aws_cdk import aws_secretsmanager as secretsmanager\n\n    # secret: secretsmanager.Secret\n    # security_group: ec2.SecurityGroup\n    # subnet: ec2.Subnet\n    # subnet_filter: ec2.SubnetFilter\n    # vpc: ec2.Vpc\n\n    multi_user_hosted_rotation_options = secretsmanager.MultiUserHostedRotationOptions(\n        master_secret=secret,\n\n        # the properties below are optional\n        exclude_characters="excludeCharacters",\n        function_name="functionName",\n        security_groups=[security_group],\n        vpc=vpc,\n        vpc_subnets=ec2.SubnetSelection(\n            availability_zones=["availabilityZones"],\n            one_per_az=False,\n            subnet_filters=[subnet_filter],\n            subnet_group_name="subnetGroupName",\n            subnets=[subnet],\n            subnet_type=ec2.SubnetType.PRIVATE_ISOLATED\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['exclude_characters', 'function_name', 'security_groups', 'vpc', 'vpc_subnets', 'master_secret']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.MultiUserHostedRotationOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[MultiUserHostedRotationOptionsDefConfig] = pydantic.Field(None)


class MultiUserHostedRotationOptionsDefConfig(pydantic.BaseModel):
    master_secret_config: typing.Optional[models._interface_methods.AwsSecretsmanagerISecretDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_secretsmanager.ReplicaRegion
class ReplicaRegionDef(BaseStruct):
    region: str = pydantic.Field(..., description='The name of the region.\n')
    encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The customer-managed encryption key to use for encrypting the secret value. Default: - A default KMS key for the account and region is used.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_kms as kms\n    from aws_cdk import aws_secretsmanager as secretsmanager\n\n    # key: kms.Key\n\n    replica_region = secretsmanager.ReplicaRegion(\n        region="region",\n\n        # the properties below are optional\n        encryption_key=key\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['region', 'encryption_key']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.ReplicaRegion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_secretsmanager.ResourcePolicyProps
class ResourcePolicyPropsDef(BaseStruct):
    secret: typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef] = pydantic.Field(..., description='The secret to attach a resource-based permissions policy.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_secretsmanager as secretsmanager\n\n    # secret: secretsmanager.Secret\n\n    resource_policy_props = secretsmanager.ResourcePolicyProps(\n        secret=secret\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['secret']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.ResourcePolicyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ResourcePolicyPropsDefConfig] = pydantic.Field(None)


class ResourcePolicyPropsDefConfig(pydantic.BaseModel):
    secret_config: typing.Optional[models._interface_methods.AwsSecretsmanagerISecretDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_secretsmanager.RotationScheduleOptions
class RotationScheduleOptionsDef(BaseStruct):
    automatically_after: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. A value of zero will disable automatic rotation - ``Duration.days(0)``. Default: Duration.days(30)\n')
    hosted_rotation: typing.Optional[models.aws_secretsmanager.HostedRotationDef] = pydantic.Field(None, description='Hosted rotation. Default: - either ``rotationLambda`` or ``hostedRotation`` must be specified\n')
    rotate_immediately_on_update: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to rotate the secret immediately or wait until the next scheduled rotation window. Default: - secret is rotated immediately\n')
    rotation_lambda: typing.Optional[typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef]] = pydantic.Field(None, description='A Lambda function that can rotate the secret. Default: - either ``rotationLambda`` or ``hostedRotation`` must be specified\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_lambda as lambda_\n\n    # fn: lambda.Function\n\n    secret = secretsmanager.Secret(self, "Secret")\n\n    secret.add_rotation_schedule("RotationSchedule",\n        rotation_lambda=fn,\n        automatically_after=Duration.days(15)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['automatically_after', 'hosted_rotation', 'rotate_immediately_on_update', 'rotation_lambda']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.RotationScheduleOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_secretsmanager.RotationScheduleProps
class RotationSchedulePropsDef(BaseStruct):
    automatically_after: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. A value of zero will disable automatic rotation - ``Duration.days(0)``. Default: Duration.days(30)\n')
    hosted_rotation: typing.Optional[models.aws_secretsmanager.HostedRotationDef] = pydantic.Field(None, description='Hosted rotation. Default: - either ``rotationLambda`` or ``hostedRotation`` must be specified\n')
    rotate_immediately_on_update: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to rotate the secret immediately or wait until the next scheduled rotation window. Default: - secret is rotated immediately\n')
    rotation_lambda: typing.Optional[typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef]] = pydantic.Field(None, description='A Lambda function that can rotate the secret. Default: - either ``rotationLambda`` or ``hostedRotation`` must be specified\n')
    secret: typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef] = pydantic.Field(..., description='The secret to rotate. If hosted rotation is used, this must be a JSON string with the following format:: { "engine": <required: database engine>, "host": <required: instance host name>, "username": <required: username>, "password": <required: password>, "dbname": <optional: database name>, "port": <optional: if not specified, default port will be used>, "masterarn": <required for multi user rotation: the arn of the master secret which will be used to create users/change passwords> } This is typically the case for a secret referenced from an ``AWS::SecretsManager::SecretTargetAttachment`` or an ``ISecret`` returned by the ``attach()`` method of ``Secret``.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_lambda as lambda_\n    from aws_cdk import aws_secretsmanager as secretsmanager\n\n    # function_: lambda.Function\n    # hosted_rotation: secretsmanager.HostedRotation\n    # secret: secretsmanager.Secret\n\n    rotation_schedule_props = secretsmanager.RotationScheduleProps(\n        secret=secret,\n\n        # the properties below are optional\n        automatically_after=cdk.Duration.minutes(30),\n        hosted_rotation=hosted_rotation,\n        rotate_immediately_on_update=False,\n        rotation_lambda=function_\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['automatically_after', 'hosted_rotation', 'rotate_immediately_on_update', 'rotation_lambda', 'secret']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.RotationScheduleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[RotationSchedulePropsDefConfig] = pydantic.Field(None)


class RotationSchedulePropsDefConfig(pydantic.BaseModel):
    secret_config: typing.Optional[models._interface_methods.AwsSecretsmanagerISecretDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_secretsmanager.SecretAttachmentTargetProps
class SecretAttachmentTargetPropsDef(BaseStruct):
    target_id: str = pydantic.Field(..., description='The id of the target to attach the secret to.\n')
    target_type: aws_cdk.aws_secretsmanager.AttachmentTargetType = pydantic.Field(..., description='The type of the target to attach the secret to.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_secretsmanager as secretsmanager\n\n    secret_attachment_target_props = secretsmanager.SecretAttachmentTargetProps(\n        target_id="targetId",\n        target_type=secretsmanager.AttachmentTargetType.RDS_DB_INSTANCE\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['target_id', 'target_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.SecretAttachmentTargetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_secretsmanager.SecretAttributes
class SecretAttributesDef(BaseStruct):
    encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The encryption key that is used to encrypt the secret, unless the default SecretsManager key is used.\n')
    secret_complete_arn: typing.Optional[str] = pydantic.Field(None, description='The complete ARN of the secret in SecretsManager. This is the ARN including the Secrets Manager 6-character suffix. Cannot be used with ``secretArn`` or ``secretPartialArn``.\n')
    secret_partial_arn: typing.Optional[str] = pydantic.Field(None, description='The partial ARN of the secret in SecretsManager. This is the ARN without the Secrets Manager 6-character suffix. Cannot be used with ``secretArn`` or ``secretCompleteArn``.\n\n:exampleMetadata: infused\n\nExample::\n\n    userpool = cognito.UserPool(self, "Pool")\n    secret = secretsmanager.Secret.from_secret_attributes(self, "CognitoClientSecret",\n        secret_complete_arn="arn:aws:secretsmanager:xxx:xxx:secret:xxx-xxx"\n    ).secret_value\n\n    provider = cognito.UserPoolIdentityProviderGoogle(self, "Google",\n        client_id="amzn-client-id",\n        client_secret_value=secret,\n        user_pool=userpool\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['encryption_key', 'secret_complete_arn', 'secret_partial_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.SecretAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_secretsmanager.SecretProps
class SecretPropsDef(BaseStruct):
    description: typing.Optional[str] = pydantic.Field(None, description='An optional, human-friendly description of the secret. Default: - No description.\n')
    encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The customer-managed encryption key to use for encrypting the secret value. Default: - A default KMS key for the account and region is used.\n')
    generate_secret_string: typing.Union[models.aws_secretsmanager.SecretStringGeneratorDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configuration for how to generate a secret value. Only one of ``secretString`` and ``generateSecretString`` can be provided. Default: - 32 characters with upper-case letters, lower-case letters, punctuation and numbers (at least one from each category), per the default values of ``SecretStringGenerator``.\n')
    removal_policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='Policy to apply when the secret is removed from this stack. Default: - Not set.\n')
    replica_regions: typing.Optional[typing.Sequence[typing.Union[models.aws_secretsmanager.ReplicaRegionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of regions where to replicate this secret. Default: - Secret is not replicated\n')
    secret_name: typing.Optional[str] = pydantic.Field(None, description='A name for the secret. Note that deleting secrets from SecretsManager does not happen immediately, but after a 7 to 30 days blackout period. During that period, it is not possible to create another secret that shares the same name. Default: - A name is generated by CloudFormation.\n')
    secret_object_value: typing.Optional[typing.Mapping[str, models.SecretValueDef]] = pydantic.Field(None, description="Initial value for a JSON secret. **NOTE:** *It is **highly** encouraged to leave this field undefined and allow SecretsManager to create the secret value. The secret object -- if provided -- will be included in the output of the cdk as part of synthesis, and will appear in the CloudFormation template in the console. This can be secure(-ish) if that value is merely reference to another resource (or one of its attributes), but if the value is a plaintext string, it will be visible to anyone with access to the CloudFormation template (via the AWS Console, SDKs, or CLI). Specifies a JSON object that you want to encrypt and store in this new version of the secret. To specify a simple string value instead, use ``SecretProps.secretStringValue`` Only one of ``secretStringBeta1``, ``secretStringValue``, 'secretObjectValue', and ``generateSecretString`` can be provided. Default: - SecretsManager generates a new secret value.\n")
    secret_string_beta1: typing.Optional[models.aws_secretsmanager.SecretStringValueBeta1Def] = pydantic.Field(None, description='(deprecated) Initial value for the secret. **NOTE:** *It is **highly** encouraged to leave this field undefined and allow SecretsManager to create the secret value. The secret string -- if provided -- will be included in the output of the cdk as part of synthesis, and will appear in the CloudFormation template in the console. This can be secure(-ish) if that value is merely reference to another resource (or one of its attributes), but if the value is a plaintext string, it will be visible to anyone with access to the CloudFormation template (via the AWS Console, SDKs, or CLI). Specifies text data that you want to encrypt and store in this new version of the secret. May be a simple string value, or a string representation of a JSON structure. Only one of ``secretStringBeta1``, ``secretStringValue``, and ``generateSecretString`` can be provided. Default: - SecretsManager generates a new secret value.\n')
    secret_string_value: typing.Optional[models.SecretValueDef] = pydantic.Field(None, description='Initial value for the secret. **NOTE:** *It is **highly** encouraged to leave this field undefined and allow SecretsManager to create the secret value. The secret string -- if provided -- will be included in the output of the cdk as part of synthesis, and will appear in the CloudFormation template in the console. This can be secure(-ish) if that value is merely reference to another resource (or one of its attributes), but if the value is a plaintext string, it will be visible to anyone with access to the CloudFormation template (via the AWS Console, SDKs, or CLI). Specifies text data that you want to encrypt and store in this new version of the secret. May be a simple string value. To provide a string representation of JSON structure, use ``SecretProps.secretObjectValue`` instead. Only one of ``secretStringBeta1``, ``secretStringValue``, \'secretObjectValue\', and ``generateSecretString`` can be provided. Default: - SecretsManager generates a new secret value.\n\n:exampleMetadata: infused\n\nExample::\n\n    # stack: Stack\n    user = iam.User(self, "User")\n    access_key = iam.AccessKey(self, "AccessKey", user=user)\n\n    secretsmanager.Secret(self, "Secret",\n        secret_object_value={\n            "username": SecretValue.unsafe_plain_text(user.user_name),\n            "database": SecretValue.unsafe_plain_text("foo"),\n            "password": access_key.secret_access_key\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'encryption_key', 'generate_secret_string', 'removal_policy', 'replica_regions', 'secret_name', 'secret_object_value', 'secret_string_beta1', 'secret_string_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.SecretProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_secretsmanager.SecretRotationApplicationOptions
class SecretRotationApplicationOptionsDef(BaseStruct):
    is_multi_user: typing.Optional[bool] = pydantic.Field(None, description='Whether the rotation application uses the mutli user scheme. Default: false\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_secretsmanager as secretsmanager\n\n    secret_rotation_application_options = secretsmanager.SecretRotationApplicationOptions(\n        is_multi_user=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['is_multi_user']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.SecretRotationApplicationOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_secretsmanager.SecretRotationProps
class SecretRotationPropsDef(BaseStruct):
    application: models.aws_secretsmanager.SecretRotationApplicationDef = pydantic.Field(..., description='The serverless application for the rotation.\n')
    secret: typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef] = pydantic.Field(..., description='The secret to rotate. It must be a JSON string with the following format:. Example:: { "engine": <required: database engine>, "host": <required: instance host name>, "username": <required: username>, "password": <required: password>, "dbname": <optional: database name>, "port": <optional: if not specified, default port will be used>, "masterarn": <required for multi user rotation: the arn of the master secret which will be used to create users/change passwords> } This is typically the case for a secret referenced from an ``AWS::SecretsManager::SecretTargetAttachment`` or an ``ISecret`` returned by the ``attach()`` method of ``Secret``.\n')
    target: typing.Union[models.aws_autoscaling.AutoScalingGroupDef, models.aws_ec2.ConnectionsDef, models.aws_ec2.NatInstanceProviderDef, models.aws_ec2.LaunchTemplateDef, models.aws_elasticloadbalancing.ListenerPortDef, models.aws_elasticloadbalancing.LoadBalancerDef, models.aws_elasticsearch.DomainDef, models.aws_opensearchservice.DomainDef, models.aws_rds.DatabaseProxyDef, models.aws_secretsmanager.HostedRotationDef, models.aws_stepfunctions_tasks.EcsRunTaskDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef] = pydantic.Field(..., description='The target service or database.\n')
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='The VPC where the Lambda rotation function will run.\n')
    automatically_after: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Specifies the number of days after the previous rotation before Secrets Manager triggers the next automatic rotation. Default: Duration.days(30)\n')
    endpoint: typing.Optional[typing.Union[models.aws_ec2.InterfaceVpcEndpointDef]] = pydantic.Field(None, description="The VPC interface endpoint to use for the Secrets Manager API. If you enable private DNS hostnames for your VPC private endpoint (the default), you don't need to specify an endpoint. The standard Secrets Manager DNS hostname the Secrets Manager CLI and SDKs use by default (https://secretsmanager..amazonaws.com) automatically resolves to your VPC endpoint. Default: https://secretsmanager..amazonaws.com\n")
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='Characters which should not appear in the generated password. Default: - no additional characters are explicitly excluded\n')
    master_secret: typing.Optional[typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef]] = pydantic.Field(None, description='The master secret for a multi user rotation scheme. Default: - single user rotation scheme\n')
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='The security group for the Lambda rotation function. Default: - a new security group is created\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of subnets in the VPC where the Lambda rotation function will run. Default: - the Vpc default strategy if not specified.\n\n:exampleMetadata: infused\n\nExample::\n\n    # my_secret: secretsmanager.Secret\n    # my_database: ec2.IConnectable\n    # my_vpc: ec2.Vpc\n\n\n    secretsmanager.SecretRotation(self, "SecretRotation",\n        application=secretsmanager.SecretRotationApplication.MYSQL_ROTATION_SINGLE_USER,  # MySQL single user scheme\n        secret=my_secret,\n        target=my_database,  # a Connectable\n        vpc=my_vpc,  # The VPC where the secret rotation application will be deployed\n        exclude_characters=" %+:;{}"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['application', 'secret', 'target', 'vpc', 'automatically_after', 'endpoint', 'exclude_characters', 'master_secret', 'security_group', 'vpc_subnets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.SecretRotationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[SecretRotationPropsDefConfig] = pydantic.Field(None)


class SecretRotationPropsDefConfig(pydantic.BaseModel):
    application_config: typing.Optional[models.aws_secretsmanager.SecretRotationApplicationDefConfig] = pydantic.Field(None)
    secret_config: typing.Optional[models._interface_methods.AwsSecretsmanagerISecretDefConfig] = pydantic.Field(None)
    vpc_config: typing.Optional[models._interface_methods.AwsEc2IVpcDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_secretsmanager.SecretStringGenerator
class SecretStringGeneratorDef(BaseStruct):
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description="A string that includes characters that shouldn't be included in the generated password. The string can be a minimum of ``0`` and a maximum of ``4096`` characters long. Default: no exclusions\n")
    exclude_lowercase: typing.Optional[bool] = pydantic.Field(None, description="Specifies that the generated password shouldn't include lowercase letters. Default: false\n")
    exclude_numbers: typing.Optional[bool] = pydantic.Field(None, description="Specifies that the generated password shouldn't include digits. Default: false\n")
    exclude_punctuation: typing.Optional[bool] = pydantic.Field(None, description="Specifies that the generated password shouldn't include punctuation characters. Default: false\n")
    exclude_uppercase: typing.Optional[bool] = pydantic.Field(None, description="Specifies that the generated password shouldn't include uppercase letters. Default: false\n")
    generate_string_key: typing.Optional[str] = pydantic.Field(None, description="The JSON key name that's used to add the generated password to the JSON structure specified by the ``secretStringTemplate`` parameter. If you specify ``generateStringKey`` then ``secretStringTemplate`` must be also be specified.\n")
    include_space: typing.Optional[bool] = pydantic.Field(None, description='Specifies that the generated password can include the space character. Default: false\n')
    password_length: typing.Union[int, float, None] = pydantic.Field(None, description='The desired length of the generated password. Default: 32\n')
    require_each_included_type: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether the generated password must include at least one of every allowed character type. Default: true\n')
    secret_string_template: typing.Optional[str] = pydantic.Field(None, description='A properly structured JSON string that the generated password can be added to. The ``generateStringKey`` is combined with the generated random string and inserted into the JSON structure that\'s specified by this parameter. The merged JSON string is returned as the completed SecretString of the secret. If you specify ``secretStringTemplate`` then ``generateStringKey`` must be also be specified.\n\n:exampleMetadata: infused\n\nExample::\n\n    # vpc: ec2.IVpc\n\n\n    instance1 = rds.DatabaseInstance(self, "PostgresInstance1",\n        engine=rds.DatabaseInstanceEngine.POSTGRES,\n        # Generate the secret with admin username `postgres` and random password\n        credentials=rds.Credentials.from_generated_secret("postgres"),\n        vpc=vpc\n    )\n    # Templated secret with username and password fields\n    templated_secret = secretsmanager.Secret(self, "TemplatedSecret",\n        generate_secret_string=secretsmanager.SecretStringGenerator(\n            secret_string_template=JSON.stringify({"username": "postgres"}),\n            generate_string_key="password",\n            exclude_characters="/@""\n        )\n    )\n    # Using the templated secret as credentials\n    instance2 = rds.DatabaseInstance(self, "PostgresInstance2",\n        engine=rds.DatabaseInstanceEngine.POSTGRES,\n        credentials={\n            "username": templated_secret.secret_value_from_json("username").to_string(),\n            "password": templated_secret.secret_value_from_json("password")\n        },\n        vpc=vpc\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['exclude_characters', 'exclude_lowercase', 'exclude_numbers', 'exclude_punctuation', 'exclude_uppercase', 'generate_string_key', 'include_space', 'password_length', 'require_each_included_type', 'secret_string_template']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.SecretStringGenerator'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_secretsmanager.SecretTargetAttachmentProps
class SecretTargetAttachmentPropsDef(BaseStruct):
    target: typing.Union[models.aws_rds.DatabaseProxyDef] = pydantic.Field(..., description='The target to attach the secret to.\n')
    secret: typing.Union[models.aws_docdb.DatabaseSecretDef, models.aws_rds.DatabaseSecretDef, models.aws_secretsmanager.SecretDef, models.aws_secretsmanager.SecretTargetAttachmentDef] = pydantic.Field(..., description='The secret to attach to the target.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_secretsmanager as secretsmanager\n\n    # secret: secretsmanager.Secret\n    # secret_attachment_target: secretsmanager.ISecretAttachmentTarget\n\n    secret_target_attachment_props = secretsmanager.SecretTargetAttachmentProps(\n        secret=secret,\n        target=secret_attachment_target\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['target', 'secret']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.SecretTargetAttachmentProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[SecretTargetAttachmentPropsDefConfig] = pydantic.Field(None)


class SecretTargetAttachmentPropsDefConfig(pydantic.BaseModel):
    secret_config: typing.Optional[models._interface_methods.AwsSecretsmanagerISecretDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_secretsmanager.SingleUserHostedRotationOptions
class SingleUserHostedRotationOptionsDef(BaseStruct):
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='A string of the characters that you don\'t want in the password. Default: the same exclude characters as the ones used for the secret or " %+~`#$&*()|[]{}:;<>?!\'/@"\\"\n')
    function_name: typing.Optional[str] = pydantic.Field(None, description='A name for the Lambda created to rotate the secret. Default: - a CloudFormation generated name\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='A list of security groups for the Lambda created to rotate the secret. Default: - a new security group is created\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The VPC where the Lambda rotation function will run. Default: - the Lambda is not deployed in a VPC\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The type of subnets in the VPC where the Lambda rotation function will run. Default: - the Vpc default strategy if not specified.\n\n:exampleMetadata: infused\n\nExample::\n\n    # my_vpc: ec2.IVpc\n    # db_connections: ec2.Connections\n    # secret: secretsmanager.Secret\n\n\n    my_hosted_rotation = secretsmanager.HostedRotation.mysql_single_user(vpc=my_vpc)\n    secret.add_rotation_schedule("RotationSchedule", hosted_rotation=my_hosted_rotation)\n    db_connections.allow_default_port_from(my_hosted_rotation)\n')
    _init_params: typing.ClassVar[list[str]] = ['exclude_characters', 'function_name', 'security_groups', 'vpc', 'vpc_subnets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.SingleUserHostedRotationOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_secretsmanager.AttachmentTargetType
# skipping emum

#  autogenerated from aws_cdk.aws_secretsmanager.ISecret
#  skipping Interface

#  autogenerated from aws_cdk.aws_secretsmanager.ISecretAttachmentTarget
#  skipping Interface

#  autogenerated from aws_cdk.aws_secretsmanager.ISecretTargetAttachment
#  skipping Interface

#  autogenerated from aws_cdk.aws_secretsmanager.CfnResourcePolicy
class CfnResourcePolicyDef(BaseCfnResource):
    resource_policy: typing.Any = pydantic.Field(..., description='A JSON-formatted string for an AWS resource-based policy. For example policies, see `Permissions policy examples <https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access_examples.html>`_ .\n')
    secret_id: str = pydantic.Field(..., description='The ARN or name of the secret to attach the resource-based policy. For an ARN, we recommend that you specify a complete ARN rather than a partial ARN.\n')
    block_public_policy: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether to block resource-based policies that allow broad access to the secret. By default, Secrets Manager blocks policies that allow broad access, for example those that use a wildcard for the principal.')
    _init_params: typing.ClassVar[list[str]] = ['resource_policy', 'secret_id', 'block_public_policy']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.CfnResourcePolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnResourcePolicyDefConfig] = pydantic.Field(None)


class CfnResourcePolicyDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnResourcePolicyDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnResourcePolicyDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnResourcePolicyDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnResourcePolicyDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnResourcePolicyDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnResourcePolicyDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnResourcePolicyDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnResourcePolicyDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnResourcePolicyDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnResourcePolicyDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnResourcePolicyDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnResourcePolicyDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnResourcePolicyDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnResourcePolicyDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnResourcePolicyDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnResourcePolicyDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnResourcePolicyDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnResourcePolicyDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnResourcePolicyDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnResourcePolicyDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnResourcePolicyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnResourcePolicyDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnResourcePolicyDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnResourcePolicyDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnResourcePolicyDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnResourcePolicyDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnResourcePolicyDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_secretsmanager.CfnRotationSchedule
class CfnRotationScheduleDef(BaseCfnResource):
    secret_id: str = pydantic.Field(..., description="The ARN or name of the secret to rotate. To reference a secret also created in this template, use the `Ref <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-ref.html>`_ function with the secret's logical ID.\n")
    hosted_rotation_lambda: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_secretsmanager.CfnRotationSchedule_HostedRotationLambdaPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Creates a new Lambda rotation function based on one of the `Secrets Manager rotation function templates <https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_available-rotation-templates.html>`_ . To use a rotation function that already exists, specify ``RotationLambdaARN`` instead. For Amazon RDS master user credentials, see `AWS::RDS::DBCluster MasterUserSecret <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-masterusersecret.html>`_ .\n')
    rotate_immediately_on_update: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Specifies whether to rotate the secret immediately or wait until the next scheduled rotation window. The rotation schedule is defined in ``RotationRules`` . If you don't immediately rotate the secret, Secrets Manager tests the rotation configuration by running the ```testSecret`` step <https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotate-secrets_how.html>`_ of the Lambda rotation function. The test creates an ``AWSPENDING`` version of the secret and then removes it. If you don't specify this value, then by default, Secrets Manager rotates the secret immediately. Rotation is an asynchronous process. For more information, see `How rotation works <https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotate-secrets_how.html>`_ .\n")
    rotation_lambda_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of an existing Lambda rotation function. To specify a rotation function that is also defined in this template, use the `Ref <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-ref.html>`_ function. For Amazon RDS master user credentials, see `AWS::RDS::DBCluster MasterUserSecret <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-masterusersecret.html>`_ . To create a new rotation function based on one of the `Secrets Manager rotation function templates <https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_available-rotation-templates.html>`_ , specify ``HostedRotationLambda`` instead.\n')
    rotation_rules: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_secretsmanager.CfnRotationSchedule_RotationRulesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A structure that defines the rotation configuration for this secret.')
    _init_params: typing.ClassVar[list[str]] = ['secret_id', 'hosted_rotation_lambda', 'rotate_immediately_on_update', 'rotation_lambda_arn', 'rotation_rules']
    _method_names: typing.ClassVar[list[str]] = ['HostedRotationLambdaProperty', 'RotationRulesProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.CfnRotationSchedule'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnRotationScheduleDefConfig] = pydantic.Field(None)


class CfnRotationScheduleDefConfig(pydantic.BaseModel):
    HostedRotationLambdaProperty: typing.Optional[list[CfnRotationScheduleDefHostedrotationlambdapropertyParams]] = pydantic.Field(None, description='')
    RotationRulesProperty: typing.Optional[list[CfnRotationScheduleDefRotationrulespropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnRotationScheduleDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnRotationScheduleDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnRotationScheduleDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnRotationScheduleDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnRotationScheduleDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnRotationScheduleDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnRotationScheduleDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnRotationScheduleDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnRotationScheduleDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnRotationScheduleDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnRotationScheduleDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnRotationScheduleDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnRotationScheduleDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnRotationScheduleDefHostedrotationlambdapropertyParams(pydantic.BaseModel):
    rotation_type: str = pydantic.Field(..., description='')
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='')
    kms_key_arn: typing.Optional[str] = pydantic.Field(None, description='')
    master_secret_arn: typing.Optional[str] = pydantic.Field(None, description='')
    master_secret_kms_key_arn: typing.Optional[str] = pydantic.Field(None, description='')
    rotation_lambda_name: typing.Optional[str] = pydantic.Field(None, description='')
    runtime: typing.Optional[str] = pydantic.Field(None, description='')
    superuser_secret_arn: typing.Optional[str] = pydantic.Field(None, description='')
    superuser_secret_kms_key_arn: typing.Optional[str] = pydantic.Field(None, description='')
    vpc_security_group_ids: typing.Optional[str] = pydantic.Field(None, description='')
    vpc_subnet_ids: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnRotationScheduleDefRotationrulespropertyParams(pydantic.BaseModel):
    automatically_after_days: typing.Union[int, float, None] = pydantic.Field(None, description='')
    duration: typing.Optional[str] = pydantic.Field(None, description='')
    schedule_expression: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnRotationScheduleDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnRotationScheduleDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRotationScheduleDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnRotationScheduleDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRotationScheduleDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnRotationScheduleDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnRotationScheduleDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnRotationScheduleDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnRotationScheduleDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnRotationScheduleDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRotationScheduleDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnRotationScheduleDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnRotationScheduleDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRotationScheduleDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_secretsmanager.CfnSecret
class CfnSecretDef(BaseCfnResource):
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the secret.\n')
    generate_secret_string: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_secretsmanager.CfnSecret_GenerateSecretStringPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A structure that specifies how to generate a password to encrypt and store in the secret. To include a specific string in the secret, use ``SecretString`` instead. If you omit both ``GenerateSecretString`` and ``SecretString`` , you create an empty secret. When you make a change to this property, a new secret version is created. We recommend that you specify the maximum length and include every character type that the system you are generating a password for can support.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description="The ARN, key ID, or alias of the AWS KMS key that Secrets Manager uses to encrypt the secret value in the secret. An alias is always prefixed by ``alias/`` , for example ``alias/aws/secretsmanager`` . For more information, see `About aliases <https://docs.aws.amazon.com/kms/latest/developerguide/alias-about.html>`_ . To use a AWS KMS key in a different account, use the key ARN or the alias ARN. If you don't specify this value, then Secrets Manager uses the key ``aws/secretsmanager`` . If that key doesn't yet exist, then Secrets Manager creates it for you automatically the first time it encrypts the secret value. If the secret is in a different AWS account from the credentials calling the API, then you can't use ``aws/secretsmanager`` to encrypt the secret, and you must create and use a customer managed AWS KMS key.\n")
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the new secret. The secret name can contain ASCII letters, numbers, and the following characters: /_+=.@- Do not end your secret name with a hyphen followed by six characters. If you do so, you risk confusion and unexpected results when searching for a secret by partial ARN. Secrets Manager automatically adds a hyphen and six random characters after the secret name at the end of the ARN.\n')
    replica_regions: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_secretsmanager.CfnSecret_ReplicaRegionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A custom type that specifies a ``Region`` and the ``KmsKeyId`` for a replica secret.\n')
    secret_string: typing.Optional[str] = pydantic.Field(None, description='The text to encrypt and store in the secret. We recommend you use a JSON structure of key/value pairs for your secret value. To generate a random password, use ``GenerateSecretString`` instead. If you omit both ``GenerateSecretString`` and ``SecretString`` , you create an empty secret. When you make a change to this property, a new secret version is created.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of tags to attach to the secret. Each tag is a key and value pair of strings in a JSON text string, for example: ``[{"Key":"CostCenter","Value":"12345"},{"Key":"environment","Value":"production"}]`` Secrets Manager tag key names are case sensitive. A tag with the key "ABC" is a different tag from one with key "abc". If you check tags in permissions policies as part of your security strategy, then adding or removing a tag can change permissions. If the completion of this operation would result in you losing your permissions for this secret, then Secrets Manager blocks the operation and returns an ``Access Denied`` error. For more information, see `Control access to secrets using tags <https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access_examples.html#tag-secrets-abac>`_ and `Limit access to identities with tags that match secrets\' tags <https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access_examples.html#auth-and-access_tags2>`_ . For information about how to format a JSON parameter for the various command line tool environments, see `Using JSON for Parameters <https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json>`_ . If your command-line tool or SDK requires quotation marks around the parameter, you should use single quotes to avoid confusion with the double quotes required in the JSON text. The following restrictions apply to tags: - Maximum number of tags per secret: 50 - Maximum key length: 127 Unicode characters in UTF-8 - Maximum value length: 255 Unicode characters in UTF-8 - Tag keys and values are case sensitive. - Do not use the ``aws:`` prefix in your tag names or values because AWS reserves it for AWS use. You can\'t edit or delete tag names or values with this prefix. Tags with this prefix do not count against your tags per secret limit. - If you use your tagging schema across multiple services and resources, other services might have restrictions on allowed characters. Generally allowed characters: letters, spaces, and numbers representable in UTF-8, plus the following special characters: + - = . _ : / @.')
    _init_params: typing.ClassVar[list[str]] = ['description', 'generate_secret_string', 'kms_key_id', 'name', 'replica_regions', 'secret_string', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['GenerateSecretStringProperty', 'ReplicaRegionProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.CfnSecret'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnSecretDefConfig] = pydantic.Field(None)


class CfnSecretDefConfig(pydantic.BaseModel):
    GenerateSecretStringProperty: typing.Optional[list[CfnSecretDefGeneratesecretstringpropertyParams]] = pydantic.Field(None, description='')
    ReplicaRegionProperty: typing.Optional[list[CfnSecretDefReplicaregionpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnSecretDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnSecretDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnSecretDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnSecretDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnSecretDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnSecretDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnSecretDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnSecretDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnSecretDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnSecretDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnSecretDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnSecretDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnSecretDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnSecretDefGeneratesecretstringpropertyParams(pydantic.BaseModel):
    exclude_characters: typing.Optional[str] = pydantic.Field(None, description='')
    exclude_lowercase: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    exclude_numbers: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    exclude_punctuation: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    exclude_uppercase: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    generate_string_key: typing.Optional[str] = pydantic.Field(None, description='')
    include_space: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    password_length: typing.Union[int, float, None] = pydantic.Field(None, description='')
    require_each_included_type: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    secret_string_template: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSecretDefReplicaregionpropertyParams(pydantic.BaseModel):
    region: str = pydantic.Field(..., description='')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSecretDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSecretDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSecretDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSecretDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSecretDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSecretDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSecretDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSecretDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSecretDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSecretDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSecretDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnSecretDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSecretDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSecretDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_secretsmanager.CfnSecretTargetAttachment
class CfnSecretTargetAttachmentDef(BaseCfnResource):
    secret_id: str = pydantic.Field(..., description="The ARN or name of the secret. To reference a secret also created in this template, use the see `Ref <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-ref.html>`_ function with the secret's logical ID.\n")
    target_id: str = pydantic.Field(..., description='The ID of the database or cluster.\n')
    target_type: str = pydantic.Field(..., description='A string that defines the type of service or database associated with the secret. This value instructs Secrets Manager how to update the secret with the details of the service or database. This value must be one of the following: - AWS::RDS::DBInstance - AWS::RDS::DBCluster - AWS::Redshift::Cluster - AWS::DocDB::DBInstance - AWS::DocDB::DBCluster')
    _init_params: typing.ClassVar[list[str]] = ['secret_id', 'target_id', 'target_type']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.CfnSecretTargetAttachment'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnSecretTargetAttachmentDefConfig] = pydantic.Field(None)


class CfnSecretTargetAttachmentDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnSecretTargetAttachmentDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnSecretTargetAttachmentDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnSecretTargetAttachmentDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnSecretTargetAttachmentDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnSecretTargetAttachmentDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnSecretTargetAttachmentDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnSecretTargetAttachmentDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnSecretTargetAttachmentDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnSecretTargetAttachmentDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnSecretTargetAttachmentDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnSecretTargetAttachmentDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnSecretTargetAttachmentDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnSecretTargetAttachmentDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnSecretTargetAttachmentDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSecretTargetAttachmentDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSecretTargetAttachmentDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSecretTargetAttachmentDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSecretTargetAttachmentDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSecretTargetAttachmentDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSecretTargetAttachmentDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSecretTargetAttachmentDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSecretTargetAttachmentDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSecretTargetAttachmentDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSecretTargetAttachmentDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnSecretTargetAttachmentDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSecretTargetAttachmentDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSecretTargetAttachmentDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_secretsmanager.CfnResourcePolicyProps
class CfnResourcePolicyPropsDef(BaseCfnProperty):
    resource_policy: typing.Any = pydantic.Field(..., description='A JSON-formatted string for an AWS resource-based policy. For example policies, see `Permissions policy examples <https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access_examples.html>`_ .\n')
    secret_id: str = pydantic.Field(..., description='The ARN or name of the secret to attach the resource-based policy. For an ARN, we recommend that you specify a complete ARN rather than a partial ARN.\n')
    block_public_policy: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether to block resource-based policies that allow broad access to the secret. By default, Secrets Manager blocks policies that allow broad access, for example those that use a wildcard for the principal.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-secretsmanager-resourcepolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_secretsmanager as secretsmanager\n\n    # resource_policy: Any\n\n    cfn_resource_policy_props = secretsmanager.CfnResourcePolicyProps(\n        resource_policy=resource_policy,\n        secret_id="secretId",\n\n        # the properties below are optional\n        block_public_policy=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resource_policy', 'secret_id', 'block_public_policy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.CfnResourcePolicyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_secretsmanager.CfnRotationScheduleProps
class CfnRotationSchedulePropsDef(BaseCfnProperty):
    secret_id: str = pydantic.Field(..., description="The ARN or name of the secret to rotate. To reference a secret also created in this template, use the `Ref <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-ref.html>`_ function with the secret's logical ID.\n")
    hosted_rotation_lambda: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_secretsmanager.CfnRotationSchedule_HostedRotationLambdaPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Creates a new Lambda rotation function based on one of the `Secrets Manager rotation function templates <https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_available-rotation-templates.html>`_ . To use a rotation function that already exists, specify ``RotationLambdaARN`` instead. For Amazon RDS master user credentials, see `AWS::RDS::DBCluster MasterUserSecret <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-masterusersecret.html>`_ .\n')
    rotate_immediately_on_update: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Specifies whether to rotate the secret immediately or wait until the next scheduled rotation window. The rotation schedule is defined in ``RotationRules`` . If you don't immediately rotate the secret, Secrets Manager tests the rotation configuration by running the ```testSecret`` step <https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotate-secrets_how.html>`_ of the Lambda rotation function. The test creates an ``AWSPENDING`` version of the secret and then removes it. If you don't specify this value, then by default, Secrets Manager rotates the secret immediately. Rotation is an asynchronous process. For more information, see `How rotation works <https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotate-secrets_how.html>`_ .\n")
    rotation_lambda_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of an existing Lambda rotation function. To specify a rotation function that is also defined in this template, use the `Ref <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-ref.html>`_ function. For Amazon RDS master user credentials, see `AWS::RDS::DBCluster MasterUserSecret <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbcluster-masterusersecret.html>`_ . To create a new rotation function based on one of the `Secrets Manager rotation function templates <https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_available-rotation-templates.html>`_ , specify ``HostedRotationLambda`` instead.\n')
    rotation_rules: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_secretsmanager.CfnRotationSchedule_RotationRulesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A structure that defines the rotation configuration for this secret.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-secretsmanager-rotationschedule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_secretsmanager as secretsmanager\n\n    cfn_rotation_schedule_props = secretsmanager.CfnRotationScheduleProps(\n        secret_id="secretId",\n\n        # the properties below are optional\n        hosted_rotation_lambda=secretsmanager.CfnRotationSchedule.HostedRotationLambdaProperty(\n            rotation_type="rotationType",\n\n            # the properties below are optional\n            exclude_characters="excludeCharacters",\n            kms_key_arn="kmsKeyArn",\n            master_secret_arn="masterSecretArn",\n            master_secret_kms_key_arn="masterSecretKmsKeyArn",\n            rotation_lambda_name="rotationLambdaName",\n            runtime="runtime",\n            superuser_secret_arn="superuserSecretArn",\n            superuser_secret_kms_key_arn="superuserSecretKmsKeyArn",\n            vpc_security_group_ids="vpcSecurityGroupIds",\n            vpc_subnet_ids="vpcSubnetIds"\n        ),\n        rotate_immediately_on_update=False,\n        rotation_lambda_arn="rotationLambdaArn",\n        rotation_rules=secretsmanager.CfnRotationSchedule.RotationRulesProperty(\n            automatically_after_days=123,\n            duration="duration",\n            schedule_expression="scheduleExpression"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['secret_id', 'hosted_rotation_lambda', 'rotate_immediately_on_update', 'rotation_lambda_arn', 'rotation_rules']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.CfnRotationScheduleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_secretsmanager.CfnSecretProps
class CfnSecretPropsDef(BaseCfnProperty):
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the secret.\n')
    generate_secret_string: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_secretsmanager.CfnSecret_GenerateSecretStringPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A structure that specifies how to generate a password to encrypt and store in the secret. To include a specific string in the secret, use ``SecretString`` instead. If you omit both ``GenerateSecretString`` and ``SecretString`` , you create an empty secret. When you make a change to this property, a new secret version is created. We recommend that you specify the maximum length and include every character type that the system you are generating a password for can support.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description="The ARN, key ID, or alias of the AWS KMS key that Secrets Manager uses to encrypt the secret value in the secret. An alias is always prefixed by ``alias/`` , for example ``alias/aws/secretsmanager`` . For more information, see `About aliases <https://docs.aws.amazon.com/kms/latest/developerguide/alias-about.html>`_ . To use a AWS KMS key in a different account, use the key ARN or the alias ARN. If you don't specify this value, then Secrets Manager uses the key ``aws/secretsmanager`` . If that key doesn't yet exist, then Secrets Manager creates it for you automatically the first time it encrypts the secret value. If the secret is in a different AWS account from the credentials calling the API, then you can't use ``aws/secretsmanager`` to encrypt the secret, and you must create and use a customer managed AWS KMS key.\n")
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the new secret. The secret name can contain ASCII letters, numbers, and the following characters: /_+=.@- Do not end your secret name with a hyphen followed by six characters. If you do so, you risk confusion and unexpected results when searching for a secret by partial ARN. Secrets Manager automatically adds a hyphen and six random characters after the secret name at the end of the ARN.\n')
    replica_regions: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_secretsmanager.CfnSecret_ReplicaRegionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A custom type that specifies a ``Region`` and the ``KmsKeyId`` for a replica secret.\n')
    secret_string: typing.Optional[str] = pydantic.Field(None, description='The text to encrypt and store in the secret. We recommend you use a JSON structure of key/value pairs for your secret value. To generate a random password, use ``GenerateSecretString`` instead. If you omit both ``GenerateSecretString`` and ``SecretString`` , you create an empty secret. When you make a change to this property, a new secret version is created.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of tags to attach to the secret. Each tag is a key and value pair of strings in a JSON text string, for example: ``[{"Key":"CostCenter","Value":"12345"},{"Key":"environment","Value":"production"}]`` Secrets Manager tag key names are case sensitive. A tag with the key "ABC" is a different tag from one with key "abc". If you check tags in permissions policies as part of your security strategy, then adding or removing a tag can change permissions. If the completion of this operation would result in you losing your permissions for this secret, then Secrets Manager blocks the operation and returns an ``Access Denied`` error. For more information, see `Control access to secrets using tags <https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access_examples.html#tag-secrets-abac>`_ and `Limit access to identities with tags that match secrets\' tags <https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access_examples.html#auth-and-access_tags2>`_ . For information about how to format a JSON parameter for the various command line tool environments, see `Using JSON for Parameters <https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json>`_ . If your command-line tool or SDK requires quotation marks around the parameter, you should use single quotes to avoid confusion with the double quotes required in the JSON text. The following restrictions apply to tags: - Maximum number of tags per secret: 50 - Maximum key length: 127 Unicode characters in UTF-8 - Maximum value length: 255 Unicode characters in UTF-8 - Tag keys and values are case sensitive. - Do not use the ``aws:`` prefix in your tag names or values because AWS reserves it for AWS use. You can\'t edit or delete tag names or values with this prefix. Tags with this prefix do not count against your tags per secret limit. - If you use your tagging schema across multiple services and resources, other services might have restrictions on allowed characters. Generally allowed characters: letters, spaces, and numbers representable in UTF-8, plus the following special characters: + - = . _ : / @.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-secretsmanager-secret.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_secretsmanager as secretsmanager\n\n    cfn_secret_props = secretsmanager.CfnSecretProps(\n        description="description",\n        generate_secret_string=secretsmanager.CfnSecret.GenerateSecretStringProperty(\n            exclude_characters="excludeCharacters",\n            exclude_lowercase=False,\n            exclude_numbers=False,\n            exclude_punctuation=False,\n            exclude_uppercase=False,\n            generate_string_key="generateStringKey",\n            include_space=False,\n            password_length=123,\n            require_each_included_type=False,\n            secret_string_template="secretStringTemplate"\n        ),\n        kms_key_id="kmsKeyId",\n        name="name",\n        replica_regions=[secretsmanager.CfnSecret.ReplicaRegionProperty(\n            region="region",\n\n            # the properties below are optional\n            kms_key_id="kmsKeyId"\n        )],\n        secret_string="secretString",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'generate_secret_string', 'kms_key_id', 'name', 'replica_regions', 'secret_string', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.CfnSecretProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_secretsmanager.CfnSecretTargetAttachmentProps
class CfnSecretTargetAttachmentPropsDef(BaseCfnProperty):
    secret_id: str = pydantic.Field(..., description="The ARN or name of the secret. To reference a secret also created in this template, use the see `Ref <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-ref.html>`_ function with the secret's logical ID.\n")
    target_id: str = pydantic.Field(..., description='The ID of the database or cluster.\n')
    target_type: str = pydantic.Field(..., description='A string that defines the type of service or database associated with the secret. This value instructs Secrets Manager how to update the secret with the details of the service or database. This value must be one of the following: - AWS::RDS::DBInstance - AWS::RDS::DBCluster - AWS::Redshift::Cluster - AWS::DocDB::DBInstance - AWS::DocDB::DBCluster\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-secretsmanager-secrettargetattachment.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_secretsmanager as secretsmanager\n\n    cfn_secret_target_attachment_props = secretsmanager.CfnSecretTargetAttachmentProps(\n        secret_id="secretId",\n        target_id="targetId",\n        target_type="targetType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['secret_id', 'target_id', 'target_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_secretsmanager.CfnSecretTargetAttachmentProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    HostedRotation: typing.Optional[dict[str, HostedRotationDef]] = pydantic.Field(None)
    HostedRotationType: typing.Optional[dict[str, HostedRotationTypeDef]] = pydantic.Field(None)
    SecretRotationApplication: typing.Optional[dict[str, SecretRotationApplicationDef]] = pydantic.Field(None)
    SecretStringValueBeta1: typing.Optional[dict[str, SecretStringValueBeta1Def]] = pydantic.Field(None)
    ResourcePolicy: typing.Optional[dict[str, ResourcePolicyDef]] = pydantic.Field(None)
    RotationSchedule: typing.Optional[dict[str, RotationScheduleDef]] = pydantic.Field(None)
    Secret: typing.Optional[dict[str, SecretDef]] = pydantic.Field(None)
    SecretRotation: typing.Optional[dict[str, SecretRotationDef]] = pydantic.Field(None)
    SecretTargetAttachment: typing.Optional[dict[str, SecretTargetAttachmentDef]] = pydantic.Field(None)
    AttachedSecretOptions: typing.Optional[dict[str, AttachedSecretOptionsDef]] = pydantic.Field(None)
    CfnRotationSchedule_HostedRotationLambdaProperty: typing.Optional[dict[str, CfnRotationSchedule_HostedRotationLambdaPropertyDef]] = pydantic.Field(None)
    CfnRotationSchedule_RotationRulesProperty: typing.Optional[dict[str, CfnRotationSchedule_RotationRulesPropertyDef]] = pydantic.Field(None)
    CfnSecret_GenerateSecretStringProperty: typing.Optional[dict[str, CfnSecret_GenerateSecretStringPropertyDef]] = pydantic.Field(None)
    CfnSecret_ReplicaRegionProperty: typing.Optional[dict[str, CfnSecret_ReplicaRegionPropertyDef]] = pydantic.Field(None)
    MultiUserHostedRotationOptions: typing.Optional[dict[str, MultiUserHostedRotationOptionsDef]] = pydantic.Field(None)
    ReplicaRegion: typing.Optional[dict[str, ReplicaRegionDef]] = pydantic.Field(None)
    ResourcePolicyProps: typing.Optional[dict[str, ResourcePolicyPropsDef]] = pydantic.Field(None)
    RotationScheduleOptions: typing.Optional[dict[str, RotationScheduleOptionsDef]] = pydantic.Field(None)
    RotationScheduleProps: typing.Optional[dict[str, RotationSchedulePropsDef]] = pydantic.Field(None)
    SecretAttachmentTargetProps: typing.Optional[dict[str, SecretAttachmentTargetPropsDef]] = pydantic.Field(None)
    SecretAttributes: typing.Optional[dict[str, SecretAttributesDef]] = pydantic.Field(None)
    SecretProps: typing.Optional[dict[str, SecretPropsDef]] = pydantic.Field(None)
    SecretRotationApplicationOptions: typing.Optional[dict[str, SecretRotationApplicationOptionsDef]] = pydantic.Field(None)
    SecretRotationProps: typing.Optional[dict[str, SecretRotationPropsDef]] = pydantic.Field(None)
    SecretStringGenerator: typing.Optional[dict[str, SecretStringGeneratorDef]] = pydantic.Field(None)
    SecretTargetAttachmentProps: typing.Optional[dict[str, SecretTargetAttachmentPropsDef]] = pydantic.Field(None)
    SingleUserHostedRotationOptions: typing.Optional[dict[str, SingleUserHostedRotationOptionsDef]] = pydantic.Field(None)
    CfnResourcePolicy: typing.Optional[dict[str, CfnResourcePolicyDef]] = pydantic.Field(None)
    CfnRotationSchedule: typing.Optional[dict[str, CfnRotationScheduleDef]] = pydantic.Field(None)
    CfnSecret: typing.Optional[dict[str, CfnSecretDef]] = pydantic.Field(None)
    CfnSecretTargetAttachment: typing.Optional[dict[str, CfnSecretTargetAttachmentDef]] = pydantic.Field(None)
    CfnResourcePolicyProps: typing.Optional[dict[str, CfnResourcePolicyPropsDef]] = pydantic.Field(None)
    CfnRotationScheduleProps: typing.Optional[dict[str, CfnRotationSchedulePropsDef]] = pydantic.Field(None)
    CfnSecretProps: typing.Optional[dict[str, CfnSecretPropsDef]] = pydantic.Field(None)
    CfnSecretTargetAttachmentProps: typing.Optional[dict[str, CfnSecretTargetAttachmentPropsDef]] = pydantic.Field(None)
    ...
