from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_lakeformation.CfnDataCellsFilter.ColumnWildcardProperty
class CfnDataCellsFilter_ColumnWildcardPropertyDef(BaseStruct):
    excluded_column_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Excludes column names. Any column with this name will be excluded.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-datacellsfilter-columnwildcard.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    column_wildcard_property = lakeformation.CfnDataCellsFilter.ColumnWildcardProperty(\n        excluded_column_names=["excludedColumnNames"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['excluded_column_names']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnDataCellsFilter.ColumnWildcardProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnDataCellsFilter.RowFilterProperty
class CfnDataCellsFilter_RowFilterPropertyDef(BaseStruct):
    all_rows_wildcard: typing.Any = pydantic.Field(None, description='A wildcard for all rows.\n')
    filter_expression: typing.Optional[str] = pydantic.Field(None, description='A filter expression.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-datacellsfilter-rowfilter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    # all_rows_wildcard: Any\n\n    row_filter_property = lakeformation.CfnDataCellsFilter.RowFilterProperty(\n        all_rows_wildcard=all_rows_wildcard,\n        filter_expression="filterExpression"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['all_rows_wildcard', 'filter_expression']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnDataCellsFilter.RowFilterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnDataLakeSettings.DataLakePrincipalProperty
class CfnDataLakeSettings_DataLakePrincipalPropertyDef(BaseStruct):
    data_lake_principal_identifier: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='An identifier for the Lake Formation principal.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-datalakesettings-datalakeprincipal.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    data_lake_principal_property = lakeformation.CfnDataLakeSettings.DataLakePrincipalProperty(\n        data_lake_principal_identifier="dataLakePrincipalIdentifier"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['data_lake_principal_identifier']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnDataLakeSettings.DataLakePrincipalProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnDataLakeSettings.PrincipalPermissionsProperty
class CfnDataLakeSettings_PrincipalPermissionsPropertyDef(BaseStruct):
    permissions: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The permissions that are granted to the principal.\n')
    principal: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_lakeformation.CfnDataLakeSettings_DataLakePrincipalPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The principal who is granted permissions.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-datalakesettings-principalpermissions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    principal_permissions_property = lakeformation.CfnDataLakeSettings.PrincipalPermissionsProperty(\n        permissions=["permissions"],\n        principal=lakeformation.CfnDataLakeSettings.DataLakePrincipalProperty(\n            data_lake_principal_identifier="dataLakePrincipalIdentifier"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['permissions', 'principal']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnDataLakeSettings.PrincipalPermissionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnPermissions.ColumnWildcardProperty
class CfnPermissions_ColumnWildcardPropertyDef(BaseStruct):
    excluded_column_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Excludes column names. Any column with this name will be excluded.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-permissions-columnwildcard.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    column_wildcard_property = lakeformation.CfnPermissions.ColumnWildcardProperty(\n        excluded_column_names=["excludedColumnNames"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['excluded_column_names']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPermissions.ColumnWildcardProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnPermissions.DatabaseResourceProperty
class CfnPermissions_DatabaseResourcePropertyDef(BaseStruct):
    catalog_id: typing.Optional[str] = pydantic.Field(None, description='The identifier for the Data Catalog . By default, it is the account ID of the caller.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the database resource. Unique to the Data Catalog.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-permissions-databaseresource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    database_resource_property = lakeformation.CfnPermissions.DatabaseResourceProperty(\n        catalog_id="catalogId",\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPermissions.DatabaseResourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnPermissions.DataLakePrincipalProperty
class CfnPermissions_DataLakePrincipalPropertyDef(BaseStruct):
    data_lake_principal_identifier: typing.Optional[str] = pydantic.Field(None, description='An identifier for the Lake Formation principal.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-permissions-datalakeprincipal.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    data_lake_principal_property = lakeformation.CfnPermissions.DataLakePrincipalProperty(\n        data_lake_principal_identifier="dataLakePrincipalIdentifier"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['data_lake_principal_identifier']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPermissions.DataLakePrincipalProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnPermissions.DataLocationResourceProperty
class CfnPermissions_DataLocationResourcePropertyDef(BaseStruct):
    catalog_id: typing.Optional[str] = pydantic.Field(None, description='The identifier for the Data Catalog . By default, it is the account ID of the caller.\n')
    s3_resource: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) that uniquely identifies the data location resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-permissions-datalocationresource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    data_location_resource_property = lakeformation.CfnPermissions.DataLocationResourceProperty(\n        catalog_id="catalogId",\n        s3_resource="s3Resource"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 's3_resource']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPermissions.DataLocationResourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnPermissions.ResourceProperty
class CfnPermissions_ResourcePropertyDef(BaseStruct):
    database_resource: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPermissions_DatabaseResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A structure for the database object.\n')
    data_location_resource: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPermissions_DataLocationResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A structure for a data location object where permissions are granted or revoked.\n')
    table_resource: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPermissions_TableResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A structure for the table object. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal.\n')
    table_with_columns_resource: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPermissions_TableWithColumnsResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A structure for a table with columns object. This object is only used when granting a SELECT permission.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-permissions-resource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    resource_property = lakeformation.CfnPermissions.ResourceProperty(\n        database_resource=lakeformation.CfnPermissions.DatabaseResourceProperty(\n            catalog_id="catalogId",\n            name="name"\n        ),\n        data_location_resource=lakeformation.CfnPermissions.DataLocationResourceProperty(\n            catalog_id="catalogId",\n            s3_resource="s3Resource"\n        ),\n        table_resource=lakeformation.CfnPermissions.TableResourceProperty(\n            catalog_id="catalogId",\n            database_name="databaseName",\n            name="name",\n            table_wildcard=lakeformation.CfnPermissions.TableWildcardProperty()\n        ),\n        table_with_columns_resource=lakeformation.CfnPermissions.TableWithColumnsResourceProperty(\n            catalog_id="catalogId",\n            column_names=["columnNames"],\n            column_wildcard=lakeformation.CfnPermissions.ColumnWildcardProperty(\n                excluded_column_names=["excludedColumnNames"]\n            ),\n            database_name="databaseName",\n            name="name"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['database_resource', 'data_location_resource', 'table_resource', 'table_with_columns_resource']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPermissions.ResourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnPermissions.TableResourceProperty
class CfnPermissions_TableResourcePropertyDef(BaseStruct):
    catalog_id: typing.Optional[str] = pydantic.Field(None, description='The identifier for the Data Catalog . By default, it is the account ID of the caller.\n')
    database_name: typing.Optional[str] = pydantic.Field(None, description='The name of the database for the table. Unique to a Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the table.\n')
    table_wildcard: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPermissions_TableWildcardPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An empty object representing all tables under a database. If this field is specified instead of the ``Name`` field, all tables under ``DatabaseName`` will have permission changes applied.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-permissions-tableresource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    table_resource_property = lakeformation.CfnPermissions.TableResourceProperty(\n        catalog_id="catalogId",\n        database_name="databaseName",\n        name="name",\n        table_wildcard=lakeformation.CfnPermissions.TableWildcardProperty()\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'database_name', 'name', 'table_wildcard']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPermissions.TableResourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnPermissions.TableWildcardProperty
class CfnPermissions_TableWildcardPropertyDef(BaseStruct):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPermissions.TableWildcardProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnPermissions.TableWithColumnsResourceProperty
class CfnPermissions_TableWithColumnsResourcePropertyDef(BaseStruct):
    catalog_id: typing.Optional[str] = pydantic.Field(None, description='The identifier for the Data Catalog . By default, it is the account ID of the caller.\n')
    column_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of column names for the table. At least one of ``ColumnNames`` or ``ColumnWildcard`` is required.\n')
    column_wildcard: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPermissions_ColumnWildcardPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A wildcard specified by a ``ColumnWildcard`` object. At least one of ``ColumnNames`` or ``ColumnWildcard`` is required.\n')
    database_name: typing.Optional[str] = pydantic.Field(None, description='The name of the database for the table with columns resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the table resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-permissions-tablewithcolumnsresource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    table_with_columns_resource_property = lakeformation.CfnPermissions.TableWithColumnsResourceProperty(\n        catalog_id="catalogId",\n        column_names=["columnNames"],\n        column_wildcard=lakeformation.CfnPermissions.ColumnWildcardProperty(\n            excluded_column_names=["excludedColumnNames"]\n        ),\n        database_name="databaseName",\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'column_names', 'column_wildcard', 'database_name', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPermissions.TableWithColumnsResourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnPrincipalPermissions.ColumnWildcardProperty
class CfnPrincipalPermissions_ColumnWildcardPropertyDef(BaseStruct):
    excluded_column_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Excludes column names. Any column with this name will be excluded.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-principalpermissions-columnwildcard.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    column_wildcard_property = lakeformation.CfnPrincipalPermissions.ColumnWildcardProperty(\n        excluded_column_names=["excludedColumnNames"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['excluded_column_names']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPrincipalPermissions.ColumnWildcardProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnPrincipalPermissions.DatabaseResourceProperty
class CfnPrincipalPermissions_DatabaseResourcePropertyDef(BaseStruct):
    catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier for the Data Catalog. By default, it is the account ID of the caller.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the database resource. Unique to the Data Catalog.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-principalpermissions-databaseresource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    database_resource_property = lakeformation.CfnPrincipalPermissions.DatabaseResourceProperty(\n        catalog_id="catalogId",\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPrincipalPermissions.DatabaseResourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnPrincipalPermissions.DataCellsFilterResourceProperty
class CfnPrincipalPermissions_DataCellsFilterResourcePropertyDef(BaseStruct):
    database_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A database in the Data Catalog .\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name given by the user to the data filter cell.\n')
    table_catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the catalog to which the table belongs.\n')
    table_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the table.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-principalpermissions-datacellsfilterresource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    data_cells_filter_resource_property = lakeformation.CfnPrincipalPermissions.DataCellsFilterResourceProperty(\n        database_name="databaseName",\n        name="name",\n        table_catalog_id="tableCatalogId",\n        table_name="tableName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['database_name', 'name', 'table_catalog_id', 'table_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPrincipalPermissions.DataCellsFilterResourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnPrincipalPermissions.DataLakePrincipalProperty
class CfnPrincipalPermissions_DataLakePrincipalPropertyDef(BaseStruct):
    data_lake_principal_identifier: typing.Optional[str] = pydantic.Field(None, description='An identifier for the AWS Lake Formation principal.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-principalpermissions-datalakeprincipal.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    data_lake_principal_property = lakeformation.CfnPrincipalPermissions.DataLakePrincipalProperty(\n        data_lake_principal_identifier="dataLakePrincipalIdentifier"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['data_lake_principal_identifier']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPrincipalPermissions.DataLakePrincipalProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnPrincipalPermissions.DataLocationResourceProperty
class CfnPrincipalPermissions_DataLocationResourcePropertyDef(BaseStruct):
    catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier for the Data Catalog where the location is registered with AWS Lake Formation .\n')
    resource_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) that uniquely identifies the data location resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-principalpermissions-datalocationresource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    data_location_resource_property = lakeformation.CfnPrincipalPermissions.DataLocationResourceProperty(\n        catalog_id="catalogId",\n        resource_arn="resourceArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'resource_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPrincipalPermissions.DataLocationResourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnPrincipalPermissions.LFTagKeyResourceProperty
class CfnPrincipalPermissions_LFTagKeyResourcePropertyDef(BaseStruct):
    catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier for the Data Catalog where the location is registered with Data Catalog .\n')
    tag_key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The key-name for the LF-tag.\n')
    tag_values: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of possible values for the corresponding ``TagKey`` of an LF-tag key-value pair.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-principalpermissions-lftagkeyresource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    l_fTag_key_resource_property = lakeformation.CfnPrincipalPermissions.LFTagKeyResourceProperty(\n        catalog_id="catalogId",\n        tag_key="tagKey",\n        tag_values=["tagValues"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'tag_key', 'tag_values']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPrincipalPermissions.LFTagKeyResourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnPrincipalPermissions.LFTagPolicyResourceProperty
class CfnPrincipalPermissions_LFTagPolicyResourcePropertyDef(BaseStruct):
    catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier for the Data Catalog . The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment.\n')
    expression: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_LFTagPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description="A list of LF-tag conditions that apply to the resource's LF-tag policy.\n")
    resource_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The resource type for which the LF-tag policy applies.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-principalpermissions-lftagpolicyresource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    l_fTag_policy_resource_property = lakeformation.CfnPrincipalPermissions.LFTagPolicyResourceProperty(\n        catalog_id="catalogId",\n        expression=[lakeformation.CfnPrincipalPermissions.LFTagProperty(\n            tag_key="tagKey",\n            tag_values=["tagValues"]\n        )],\n        resource_type="resourceType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'expression', 'resource_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPrincipalPermissions.LFTagPolicyResourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnPrincipalPermissions.LFTagProperty
class CfnPrincipalPermissions_LFTagPropertyDef(BaseStruct):
    tag_key: typing.Optional[str] = pydantic.Field(None, description='The key-name for the LF-tag.\n')
    tag_values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of possible values of the corresponding ``TagKey`` of an LF-tag key-value pair.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-principalpermissions-lftag.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    l_fTag_property = lakeformation.CfnPrincipalPermissions.LFTagProperty(\n        tag_key="tagKey",\n        tag_values=["tagValues"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['tag_key', 'tag_values']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPrincipalPermissions.LFTagProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnPrincipalPermissions.ResourceProperty
class CfnPrincipalPermissions_ResourcePropertyDef(BaseStruct):
    catalog: typing.Any = pydantic.Field(None, description='The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment.\n')
    database: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_DatabaseResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The database for the resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database permissions to a principal.\n')
    data_cells_filter: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_DataCellsFilterResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A data cell filter.\n')
    data_location: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_DataLocationResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The location of an Amazon S3 path where permissions are granted or revoked.\n')
    lf_tag: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_LFTagKeyResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The LF-tag key and values attached to a resource.\n')
    lf_tag_policy: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_LFTagPolicyResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="A list of LF-tag conditions that define a resource's LF-tag policy.\n")
    table: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_TableResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The table for the resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal.\n')
    table_with_columns: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_TableWithColumnsResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The table with columns for the resource. A principal with permissions to this resource can select metadata from the columns of a table in the Data Catalog and the underlying data in Amazon S3.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-principalpermissions-resource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    # catalog: Any\n    # table_wildcard: Any\n\n    resource_property = lakeformation.CfnPrincipalPermissions.ResourceProperty(\n        catalog=catalog,\n        database=lakeformation.CfnPrincipalPermissions.DatabaseResourceProperty(\n            catalog_id="catalogId",\n            name="name"\n        ),\n        data_cells_filter=lakeformation.CfnPrincipalPermissions.DataCellsFilterResourceProperty(\n            database_name="databaseName",\n            name="name",\n            table_catalog_id="tableCatalogId",\n            table_name="tableName"\n        ),\n        data_location=lakeformation.CfnPrincipalPermissions.DataLocationResourceProperty(\n            catalog_id="catalogId",\n            resource_arn="resourceArn"\n        ),\n        lf_tag=lakeformation.CfnPrincipalPermissions.LFTagKeyResourceProperty(\n            catalog_id="catalogId",\n            tag_key="tagKey",\n            tag_values=["tagValues"]\n        ),\n        lf_tag_policy=lakeformation.CfnPrincipalPermissions.LFTagPolicyResourceProperty(\n            catalog_id="catalogId",\n            expression=[lakeformation.CfnPrincipalPermissions.LFTagProperty(\n                tag_key="tagKey",\n                tag_values=["tagValues"]\n            )],\n            resource_type="resourceType"\n        ),\n        table=lakeformation.CfnPrincipalPermissions.TableResourceProperty(\n            catalog_id="catalogId",\n            database_name="databaseName",\n\n            # the properties below are optional\n            name="name",\n            table_wildcard=table_wildcard\n        ),\n        table_with_columns=lakeformation.CfnPrincipalPermissions.TableWithColumnsResourceProperty(\n            catalog_id="catalogId",\n            database_name="databaseName",\n            name="name",\n\n            # the properties below are optional\n            column_names=["columnNames"],\n            column_wildcard=lakeformation.CfnPrincipalPermissions.ColumnWildcardProperty(\n                excluded_column_names=["excludedColumnNames"]\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog', 'database', 'data_cells_filter', 'data_location', 'lf_tag', 'lf_tag_policy', 'table', 'table_with_columns']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPrincipalPermissions.ResourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnPrincipalPermissions.TableResourceProperty
class CfnPrincipalPermissions_TableResourcePropertyDef(BaseStruct):
    catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='')
    database_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the database for the table. Unique to a Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the table.\n')
    table_wildcard: typing.Any = pydantic.Field(None, description='A wildcard object representing every table under a database. At least one of ``TableResource$Name`` or ``TableResource$TableWildcard`` is required.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-principalpermissions-tableresource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    # table_wildcard: Any\n\n    table_resource_property = lakeformation.CfnPrincipalPermissions.TableResourceProperty(\n        catalog_id="catalogId",\n        database_name="databaseName",\n\n        # the properties below are optional\n        name="name",\n        table_wildcard=table_wildcard\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'database_name', 'name', 'table_wildcard']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPrincipalPermissions.TableResourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnPrincipalPermissions.TableWithColumnsResourceProperty
class CfnPrincipalPermissions_TableWithColumnsResourcePropertyDef(BaseStruct):
    catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier for the Data Catalog where the location is registered with AWS Lake Formation .\n')
    database_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the database for the table with columns resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the table resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal.\n')
    column_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The list of column names for the table. At least one of ``ColumnNames`` or ``ColumnWildcard`` is required.\n')
    column_wildcard: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_ColumnWildcardPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A wildcard specified by a ``ColumnWildcard`` object. At least one of ``ColumnNames`` or ``ColumnWildcard`` is required.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-principalpermissions-tablewithcolumnsresource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    table_with_columns_resource_property = lakeformation.CfnPrincipalPermissions.TableWithColumnsResourceProperty(\n        catalog_id="catalogId",\n        database_name="databaseName",\n        name="name",\n\n        # the properties below are optional\n        column_names=["columnNames"],\n        column_wildcard=lakeformation.CfnPrincipalPermissions.ColumnWildcardProperty(\n            excluded_column_names=["excludedColumnNames"]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'database_name', 'name', 'column_names', 'column_wildcard']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPrincipalPermissions.TableWithColumnsResourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnTagAssociation.DatabaseResourceProperty
class CfnTagAssociation_DatabaseResourcePropertyDef(BaseStruct):
    catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier for the Data Catalog . By default, it should be the account ID of the caller.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the database resource. Unique to the Data Catalog.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-tagassociation-databaseresource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    database_resource_property = lakeformation.CfnTagAssociation.DatabaseResourceProperty(\n        catalog_id="catalogId",\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnTagAssociation.DatabaseResourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnTagAssociation.LFTagPairProperty
class CfnTagAssociation_LFTagPairPropertyDef(BaseStruct):
    catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier for the Data Catalog . By default, it is the account ID of the caller.\n')
    tag_key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The key-name for the LF-tag.\n')
    tag_values: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A list of possible values of the corresponding ``TagKey`` of an LF-tag key-value pair.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-tagassociation-lftagpair.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    l_fTag_pair_property = lakeformation.CfnTagAssociation.LFTagPairProperty(\n        catalog_id="catalogId",\n        tag_key="tagKey",\n        tag_values=["tagValues"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'tag_key', 'tag_values']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnTagAssociation.LFTagPairProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnTagAssociation.ResourceProperty
class CfnTagAssociation_ResourcePropertyDef(BaseStruct):
    catalog: typing.Any = pydantic.Field(None, description='The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment.\n')
    database: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnTagAssociation_DatabaseResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The database for the resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database permissions to a principal.\n')
    table: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnTagAssociation_TableResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The table for the resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal.\n')
    table_with_columns: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnTagAssociation_TableWithColumnsResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The table with columns for the resource. A principal with permissions to this resource can select metadata from the columns of a table in the Data Catalog and the underlying data in Amazon S3.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-tagassociation-resource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    # catalog: Any\n    # table_wildcard: Any\n\n    resource_property = lakeformation.CfnTagAssociation.ResourceProperty(\n        catalog=catalog,\n        database=lakeformation.CfnTagAssociation.DatabaseResourceProperty(\n            catalog_id="catalogId",\n            name="name"\n        ),\n        table=lakeformation.CfnTagAssociation.TableResourceProperty(\n            catalog_id="catalogId",\n            database_name="databaseName",\n\n            # the properties below are optional\n            name="name",\n            table_wildcard=table_wildcard\n        ),\n        table_with_columns=lakeformation.CfnTagAssociation.TableWithColumnsResourceProperty(\n            catalog_id="catalogId",\n            column_names=["columnNames"],\n            database_name="databaseName",\n            name="name"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog', 'database', 'table', 'table_with_columns']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnTagAssociation.ResourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnTagAssociation.TableResourceProperty
class CfnTagAssociation_TableResourcePropertyDef(BaseStruct):
    catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The identifier for the Data Catalog . By default, it is the account ID of the caller.\n')
    database_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the database for the table. Unique to a Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the table.\n')
    table_wildcard: typing.Any = pydantic.Field(None, description='A wildcard object representing every table under a database.This is an object with no properties that effectively behaves as a true or false depending on whether not it is passed as a parameter. The valid inputs for a property with this type in either yaml or json is null or {}. At least one of ``TableResource$Name`` or ``TableResource$TableWildcard`` is required.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-tagassociation-tableresource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    # table_wildcard: Any\n\n    table_resource_property = lakeformation.CfnTagAssociation.TableResourceProperty(\n        catalog_id="catalogId",\n        database_name="databaseName",\n\n        # the properties below are optional\n        name="name",\n        table_wildcard=table_wildcard\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'database_name', 'name', 'table_wildcard']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnTagAssociation.TableResourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnTagAssociation.TableWithColumnsResourceProperty
class CfnTagAssociation_TableWithColumnsResourcePropertyDef(BaseStruct):
    catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A wildcard object representing every table under a database. At least one of TableResource$Name or TableResource$TableWildcard is required.\n')
    column_names: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The list of column names for the table. At least one of ``ColumnNames`` or ``ColumnWildcard`` is required.\n')
    database_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the database for the table with columns resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the table resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lakeformation-tagassociation-tablewithcolumnsresource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    table_with_columns_resource_property = lakeformation.CfnTagAssociation.TableWithColumnsResourceProperty(\n        catalog_id="catalogId",\n        column_names=["columnNames"],\n        database_name="databaseName",\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['catalog_id', 'column_names', 'database_name', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnTagAssociation.TableWithColumnsResourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnDataCellsFilter
class CfnDataCellsFilterDef(BaseCfnResource):
    database_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='UTF-8 string, not less than 1 or more than 255 bytes long, matching the `single-line string pattern <https://docs.aws.amazon.com/lake-formation/latest/dg/aws-lake-formation-api-aws-lake-formation-api-common.html>`_ . A database in the Data Catalog .\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='UTF-8 string, not less than 1 or more than 255 bytes long, matching the `single-line string pattern <https://docs.aws.amazon.com/lake-formation/latest/dg/aws-lake-formation-api-aws-lake-formation-api-common.html>`_ . The name given by the user to the data filter cell.\n')
    table_catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Catalog id string, not less than 1 or more than 255 bytes long, matching the `single-line string pattern <https://docs.aws.amazon.com/lake-formation/latest/dg/aws-lake-formation-api-aws-lake-formation-api-common.html>`_ . The ID of the catalog to which the table belongs.\n')
    table_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='UTF-8 string, not less than 1 or more than 255 bytes long, matching the `single-line string pattern <https://docs.aws.amazon.com/lake-formation/latest/dg/aws-lake-formation-api-aws-lake-formation-api-common.html>`_ . A table in the database.\n')
    column_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='An array of UTF-8 strings. A list of column names.\n')
    column_wildcard: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnDataCellsFilter_ColumnWildcardPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A wildcard with exclusions. You must specify either a ``ColumnNames`` list or the ``ColumnWildCard`` .\n')
    row_filter: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnDataCellsFilter_RowFilterPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A PartiQL predicate.')
    _init_params: typing.ClassVar[list[str]] = ['database_name', 'name', 'table_catalog_id', 'table_name', 'column_names', 'column_wildcard', 'row_filter']
    _method_names: typing.ClassVar[list[str]] = ['ColumnWildcardProperty', 'RowFilterProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnDataCellsFilter'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnDataCellsFilterDefConfig] = pydantic.Field(None)


class CfnDataCellsFilterDefConfig(pydantic.BaseModel):
    ColumnWildcardProperty: typing.Optional[list[CfnDataCellsFilterDefColumnwildcardpropertyParams]] = pydantic.Field(None, description='')
    RowFilterProperty: typing.Optional[list[CfnDataCellsFilterDefRowfilterpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnDataCellsFilterDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnDataCellsFilterDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnDataCellsFilterDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnDataCellsFilterDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnDataCellsFilterDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnDataCellsFilterDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnDataCellsFilterDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnDataCellsFilterDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnDataCellsFilterDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnDataCellsFilterDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnDataCellsFilterDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnDataCellsFilterDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnDataCellsFilterDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnDataCellsFilterDefColumnwildcardpropertyParams(pydantic.BaseModel):
    excluded_column_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnDataCellsFilterDefRowfilterpropertyParams(pydantic.BaseModel):
    all_rows_wildcard: typing.Any = pydantic.Field(None, description='')
    filter_expression: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDataCellsFilterDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDataCellsFilterDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDataCellsFilterDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDataCellsFilterDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDataCellsFilterDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDataCellsFilterDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDataCellsFilterDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDataCellsFilterDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDataCellsFilterDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDataCellsFilterDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDataCellsFilterDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDataCellsFilterDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDataCellsFilterDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDataCellsFilterDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_lakeformation.CfnDataLakeSettings
class CfnDataLakeSettingsDef(BaseCfnResource):
    admins: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnDataLakeSettings_DataLakePrincipalPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of AWS Lake Formation principals.\n')
    allow_external_data_filtering: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Whether to allow Amazon EMR clusters or other third-party query engines to access data managed by Lake Formation . If set to true, you allow Amazon EMR clusters or other third-party engines to access data in Amazon S3 locations that are registered with Lake Formation . If false or null, no third-party query engines will be able to access data in Amazon S3 locations that are registered with Lake Formation. For more information, see `External data filtering setting <https://docs.aws.amazon.com/lake-formation/latest/dg/initial-LF-setup.html#external-data-filter>`_ .\n')
    allow_full_table_external_data_access: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether query engines and applications can get credentials without IAM session tags if the user has full table access. It provides query engines and applications performance benefits as well as simplifies data access. Amazon EMR on Amazon EC2 is able to leverage this setting. For more information, see ` <https://docs.aws.amazon.com/lake-formation/latest/dg/using-cred-vending.html>`_\n')
    authorized_session_tag_value_list: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Lake Formation relies on a privileged process secured by Amazon EMR or the third party integrator to tag the user\'s role while assuming it. Lake Formation will publish the acceptable key-value pair, for example key = "LakeFormationTrustedCaller" and value = "TRUE" and the third party integrator must properly tag the temporary security credentials that will be used to call Lake Formation \'s administrative API operations.\n')
    create_database_default_permissions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnDataLakeSettings_PrincipalPermissionsPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Specifies whether access control on a newly created database is managed by Lake Formation permissions or exclusively by IAM permissions. A null value indicates that the access is controlled by Lake Formation permissions. ``ALL`` permissions assigned to ``IAM_ALLOWED_PRINCIPALS`` group indicates that the user\'s IAM permissions determine the access to the database. This is referred to as the setting "Use only IAM access control," and is to support backward compatibility with the AWS Glue permission model implemented by IAM permissions. The only permitted values are an empty array or an array that contains a single JSON object that grants ``ALL`` to ``IAM_ALLOWED_PRINCIPALS`` . For more information, see `Changing the default security settings for your data lake <https://docs.aws.amazon.com/lake-formation/latest/dg/change-settings.html>`_ .\n')
    create_table_default_permissions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnDataLakeSettings_PrincipalPermissionsPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Specifies whether access control on a newly created table is managed by Lake Formation permissions or exclusively by IAM permissions. A null value indicates that the access is controlled by Lake Formation permissions. ``ALL`` permissions assigned to ``IAM_ALLOWED_PRINCIPALS`` group indicate that the user\'s IAM permissions determine the access to the table. This is referred to as the setting "Use only IAM access control," and is to support the backward compatibility with the AWS Glue permission model implemented by IAM permissions. The only permitted values are an empty array or an array that contains a single JSON object that grants ``ALL`` permissions to ``IAM_ALLOWED_PRINCIPALS`` . For more information, see `Changing the default security settings for your data lake <https://docs.aws.amazon.com/lake-formation/latest/dg/change-settings.html>`_ .\n')
    external_data_filtering_allow_list: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnDataLakeSettings_DataLakePrincipalPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of the account IDs of AWS accounts with Amazon EMR clusters or third-party engines that are allwed to perform data filtering.\n')
    mutation_type: typing.Optional[str] = pydantic.Field(None, description='Specifies whether the data lake settings are updated by adding new values to the current settings ( ``APPEND`` ) or by replacing the current settings with new settings ( ``REPLACE`` ). .. epigraph:: If you choose ``REPLACE`` , your current data lake settings will be replaced with the new values in your template.\n')
    parameters: typing.Any = pydantic.Field(None, description='A key-value map that provides an additional configuration on your data lake. ``CrossAccountVersion`` is the key you can configure in the ``Parameters`` field. Accepted values for the ``CrossAccountVersion`` key are 1, 2, and 3.\n')
    trusted_resource_owners: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="An array of UTF-8 strings. A list of the resource-owning account IDs that the caller's account can use to share their user access details (user ARNs). The user ARNs can be logged in the resource owner's CloudTrail log. You may want to specify this property when you are in a high-trust boundary, such as the same team or company.")
    _init_params: typing.ClassVar[list[str]] = ['admins', 'allow_external_data_filtering', 'allow_full_table_external_data_access', 'authorized_session_tag_value_list', 'create_database_default_permissions', 'create_table_default_permissions', 'external_data_filtering_allow_list', 'mutation_type', 'parameters', 'trusted_resource_owners']
    _method_names: typing.ClassVar[list[str]] = ['DataLakePrincipalProperty', 'PrincipalPermissionsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnDataLakeSettings'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnDataLakeSettingsDefConfig] = pydantic.Field(None)


class CfnDataLakeSettingsDefConfig(pydantic.BaseModel):
    DataLakePrincipalProperty: typing.Optional[list[CfnDataLakeSettingsDefDatalakeprincipalpropertyParams]] = pydantic.Field(None, description='')
    PrincipalPermissionsProperty: typing.Optional[list[CfnDataLakeSettingsDefPrincipalpermissionspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnDataLakeSettingsDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnDataLakeSettingsDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnDataLakeSettingsDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnDataLakeSettingsDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnDataLakeSettingsDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnDataLakeSettingsDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnDataLakeSettingsDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnDataLakeSettingsDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnDataLakeSettingsDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnDataLakeSettingsDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnDataLakeSettingsDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnDataLakeSettingsDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnDataLakeSettingsDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnDataLakeSettingsDefDatalakeprincipalpropertyParams(pydantic.BaseModel):
    data_lake_principal_identifier: str = pydantic.Field(..., description='')
    ...

class CfnDataLakeSettingsDefPrincipalpermissionspropertyParams(pydantic.BaseModel):
    permissions: typing.Sequence[str] = pydantic.Field(..., description='')
    principal: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnDataLakeSettings_DataLakePrincipalPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnDataLakeSettingsDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDataLakeSettingsDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDataLakeSettingsDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDataLakeSettingsDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDataLakeSettingsDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDataLakeSettingsDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDataLakeSettingsDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDataLakeSettingsDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDataLakeSettingsDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDataLakeSettingsDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDataLakeSettingsDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDataLakeSettingsDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDataLakeSettingsDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDataLakeSettingsDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_lakeformation.CfnPermissions
class CfnPermissionsDef(BaseCfnResource):
    data_lake_principal: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_lakeformation.CfnPermissions_DataLakePrincipalPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The AWS Lake Formation principal.\n')
    resource: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_lakeformation.CfnPermissions_ResourcePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A structure for the resource.\n')
    permissions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The permissions granted or revoked.\n')
    permissions_with_grant_option: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Indicates the ability to grant permissions (as a subset of permissions granted).')
    _init_params: typing.ClassVar[list[str]] = ['data_lake_principal', 'resource', 'permissions', 'permissions_with_grant_option']
    _method_names: typing.ClassVar[list[str]] = ['ColumnWildcardProperty', 'DataLakePrincipalProperty', 'DataLocationResourceProperty', 'DatabaseResourceProperty', 'ResourceProperty', 'TableResourceProperty', 'TableWildcardProperty', 'TableWithColumnsResourceProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPermissions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnPermissionsDefConfig] = pydantic.Field(None)


class CfnPermissionsDefConfig(pydantic.BaseModel):
    ColumnWildcardProperty: typing.Optional[list[CfnPermissionsDefColumnwildcardpropertyParams]] = pydantic.Field(None, description='')
    DataLakePrincipalProperty: typing.Optional[list[CfnPermissionsDefDatalakeprincipalpropertyParams]] = pydantic.Field(None, description='')
    DataLocationResourceProperty: typing.Optional[list[CfnPermissionsDefDatalocationresourcepropertyParams]] = pydantic.Field(None, description='')
    DatabaseResourceProperty: typing.Optional[list[CfnPermissionsDefDatabaseresourcepropertyParams]] = pydantic.Field(None, description='')
    ResourceProperty: typing.Optional[list[CfnPermissionsDefResourcepropertyParams]] = pydantic.Field(None, description='')
    TableResourceProperty: typing.Optional[list[CfnPermissionsDefTableresourcepropertyParams]] = pydantic.Field(None, description='')
    TableWildcardProperty: typing.Optional[bool] = pydantic.Field(None, description='')
    TableWithColumnsResourceProperty: typing.Optional[list[CfnPermissionsDefTablewithcolumnsresourcepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnPermissionsDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnPermissionsDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnPermissionsDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnPermissionsDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnPermissionsDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnPermissionsDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnPermissionsDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnPermissionsDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnPermissionsDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnPermissionsDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnPermissionsDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnPermissionsDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnPermissionsDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnPermissionsDefColumnwildcardpropertyParams(pydantic.BaseModel):
    excluded_column_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnPermissionsDefDatalakeprincipalpropertyParams(pydantic.BaseModel):
    data_lake_principal_identifier: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnPermissionsDefDatalocationresourcepropertyParams(pydantic.BaseModel):
    catalog_id: typing.Optional[str] = pydantic.Field(None, description='')
    s3_resource: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnPermissionsDefDatabaseresourcepropertyParams(pydantic.BaseModel):
    catalog_id: typing.Optional[str] = pydantic.Field(None, description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnPermissionsDefResourcepropertyParams(pydantic.BaseModel):
    database_resource: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPermissions_DatabaseResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    data_location_resource: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPermissions_DataLocationResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    table_resource: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPermissions_TableResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    table_with_columns_resource: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPermissions_TableWithColumnsResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnPermissionsDefTableresourcepropertyParams(pydantic.BaseModel):
    catalog_id: typing.Optional[str] = pydantic.Field(None, description='')
    database_name: typing.Optional[str] = pydantic.Field(None, description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    table_wildcard: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPermissions_TableWildcardPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnPermissionsDefTablewithcolumnsresourcepropertyParams(pydantic.BaseModel):
    catalog_id: typing.Optional[str] = pydantic.Field(None, description='')
    column_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    column_wildcard: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPermissions_ColumnWildcardPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    database_name: typing.Optional[str] = pydantic.Field(None, description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnPermissionsDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPermissionsDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPermissionsDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPermissionsDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPermissionsDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPermissionsDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPermissionsDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPermissionsDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPermissionsDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPermissionsDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPermissionsDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnPermissionsDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPermissionsDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPermissionsDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_lakeformation.CfnPrincipalPermissions
class CfnPrincipalPermissionsDef(BaseCfnResource):
    permissions: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The permissions granted or revoked.\n')
    permissions_with_grant_option: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Indicates the ability to grant permissions (as a subset of permissions granted).\n')
    principal: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_DataLakePrincipalPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The principal to be granted a permission.\n')
    resource: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_ResourcePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The resource to be granted or revoked permissions.\n')
    catalog: typing.Optional[str] = pydantic.Field(None, description='The identifier for the Data Catalog . By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.')
    _init_params: typing.ClassVar[list[str]] = ['permissions', 'permissions_with_grant_option', 'principal', 'resource', 'catalog']
    _method_names: typing.ClassVar[list[str]] = ['ColumnWildcardProperty', 'DataCellsFilterResourceProperty', 'DataLakePrincipalProperty', 'DataLocationResourceProperty', 'DatabaseResourceProperty', 'LFTagKeyResourceProperty', 'LFTagPolicyResourceProperty', 'LFTagProperty', 'ResourceProperty', 'TableResourceProperty', 'TableWithColumnsResourceProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPrincipalPermissions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnPrincipalPermissionsDefConfig] = pydantic.Field(None)


class CfnPrincipalPermissionsDefConfig(pydantic.BaseModel):
    ColumnWildcardProperty: typing.Optional[list[CfnPrincipalPermissionsDefColumnwildcardpropertyParams]] = pydantic.Field(None, description='')
    DataCellsFilterResourceProperty: typing.Optional[list[CfnPrincipalPermissionsDefDatacellsfilterresourcepropertyParams]] = pydantic.Field(None, description='')
    DataLakePrincipalProperty: typing.Optional[list[CfnPrincipalPermissionsDefDatalakeprincipalpropertyParams]] = pydantic.Field(None, description='')
    DataLocationResourceProperty: typing.Optional[list[CfnPrincipalPermissionsDefDatalocationresourcepropertyParams]] = pydantic.Field(None, description='')
    DatabaseResourceProperty: typing.Optional[list[CfnPrincipalPermissionsDefDatabaseresourcepropertyParams]] = pydantic.Field(None, description='')
    LFTagKeyResourceProperty: typing.Optional[list[CfnPrincipalPermissionsDefLftagkeyresourcepropertyParams]] = pydantic.Field(None, description='')
    LFTagPolicyResourceProperty: typing.Optional[list[CfnPrincipalPermissionsDefLftagpolicyresourcepropertyParams]] = pydantic.Field(None, description='')
    LFTagProperty: typing.Optional[list[CfnPrincipalPermissionsDefLftagpropertyParams]] = pydantic.Field(None, description='')
    ResourceProperty: typing.Optional[list[CfnPrincipalPermissionsDefResourcepropertyParams]] = pydantic.Field(None, description='')
    TableResourceProperty: typing.Optional[list[CfnPrincipalPermissionsDefTableresourcepropertyParams]] = pydantic.Field(None, description='')
    TableWithColumnsResourceProperty: typing.Optional[list[CfnPrincipalPermissionsDefTablewithcolumnsresourcepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnPrincipalPermissionsDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnPrincipalPermissionsDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnPrincipalPermissionsDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnPrincipalPermissionsDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnPrincipalPermissionsDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnPrincipalPermissionsDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnPrincipalPermissionsDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnPrincipalPermissionsDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnPrincipalPermissionsDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnPrincipalPermissionsDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnPrincipalPermissionsDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnPrincipalPermissionsDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnPrincipalPermissionsDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnPrincipalPermissionsDefColumnwildcardpropertyParams(pydantic.BaseModel):
    excluded_column_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnPrincipalPermissionsDefDatacellsfilterresourcepropertyParams(pydantic.BaseModel):
    database_name: str = pydantic.Field(..., description='')
    name: str = pydantic.Field(..., description='')
    table_catalog_id: str = pydantic.Field(..., description='')
    table_name: str = pydantic.Field(..., description='')
    ...

class CfnPrincipalPermissionsDefDatalakeprincipalpropertyParams(pydantic.BaseModel):
    data_lake_principal_identifier: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnPrincipalPermissionsDefDatalocationresourcepropertyParams(pydantic.BaseModel):
    catalog_id: str = pydantic.Field(..., description='')
    resource_arn: str = pydantic.Field(..., description='')
    ...

class CfnPrincipalPermissionsDefDatabaseresourcepropertyParams(pydantic.BaseModel):
    catalog_id: str = pydantic.Field(..., description='')
    name: str = pydantic.Field(..., description='')
    ...

class CfnPrincipalPermissionsDefLftagkeyresourcepropertyParams(pydantic.BaseModel):
    catalog_id: str = pydantic.Field(..., description='')
    tag_key: str = pydantic.Field(..., description='')
    tag_values: typing.Sequence[str] = pydantic.Field(..., description='')
    ...

class CfnPrincipalPermissionsDefLftagpolicyresourcepropertyParams(pydantic.BaseModel):
    catalog_id: str = pydantic.Field(..., description='')
    expression: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_LFTagPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    resource_type: str = pydantic.Field(..., description='')
    ...

class CfnPrincipalPermissionsDefLftagpropertyParams(pydantic.BaseModel):
    tag_key: typing.Optional[str] = pydantic.Field(None, description='')
    tag_values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnPrincipalPermissionsDefResourcepropertyParams(pydantic.BaseModel):
    catalog: typing.Any = pydantic.Field(None, description='')
    database: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_DatabaseResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    data_cells_filter: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_DataCellsFilterResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    data_location: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_DataLocationResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    lf_tag: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_LFTagKeyResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    lf_tag_policy: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_LFTagPolicyResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    table: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_TableResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    table_with_columns: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_TableWithColumnsResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnPrincipalPermissionsDefTableresourcepropertyParams(pydantic.BaseModel):
    catalog_id: str = pydantic.Field(..., description='')
    database_name: str = pydantic.Field(..., description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    table_wildcard: typing.Any = pydantic.Field(None, description='')
    ...

class CfnPrincipalPermissionsDefTablewithcolumnsresourcepropertyParams(pydantic.BaseModel):
    catalog_id: str = pydantic.Field(..., description='')
    database_name: str = pydantic.Field(..., description='')
    name: str = pydantic.Field(..., description='')
    column_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    column_wildcard: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_ColumnWildcardPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnPrincipalPermissionsDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPrincipalPermissionsDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPrincipalPermissionsDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPrincipalPermissionsDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPrincipalPermissionsDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPrincipalPermissionsDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPrincipalPermissionsDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPrincipalPermissionsDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPrincipalPermissionsDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPrincipalPermissionsDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPrincipalPermissionsDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnPrincipalPermissionsDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPrincipalPermissionsDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPrincipalPermissionsDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_lakeformation.CfnResource
class CfnResourceDef(BaseCfnResource):
    resource_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the resource.\n')
    use_service_linked_role: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='Designates a trusted caller, an IAM principal, by registering this caller with the Data Catalog .\n')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='The IAM role that registered a resource.\n')
    with_federation: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Allows Lake Formation to assume a role to access tables in a federated database.')
    _init_params: typing.ClassVar[list[str]] = ['resource_arn', 'use_service_linked_role', 'role_arn', 'with_federation']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnResource'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnResourceDefConfig] = pydantic.Field(None)


class CfnResourceDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnResourceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnResourceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnResourceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnResourceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnResourceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnResourceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnResourceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnResourceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnResourceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnResourceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnResourceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnResourceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnResourceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnResourceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnResourceDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnResourceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnResourceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnResourceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnResourceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnResourceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnResourceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnResourceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnResourceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnResourceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnResourceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnResourceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnResourceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_lakeformation.CfnTag
class CfnTagDef(BaseCfnResource):
    tag_key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='UTF-8 string, not less than 1 or more than 255 bytes long, matching the `single-line string pattern <https://docs.aws.amazon.com/lake-formation/latest/dg/aws-lake-formation-api-aws-lake-formation-api-common.html>`_ . The key-name for the LF-tag.\n')
    tag_values: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='An array of UTF-8 strings, not less than 1 or more than 50 strings. A list of possible values of the corresponding ``TagKey`` of an LF-tag key-value pair.\n')
    catalog_id: typing.Optional[str] = pydantic.Field(None, description='Catalog id string, not less than 1 or more than 255 bytes long, matching the `single-line string pattern <https://docs.aws.amazon.com/lake-formation/latest/dg/aws-lake-formation-api-aws-lake-formation-api-common.html>`_ . The identifier for the Data Catalog . By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment.')
    _init_params: typing.ClassVar[list[str]] = ['tag_key', 'tag_values', 'catalog_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnTag'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTagDefConfig] = pydantic.Field(None)


class CfnTagDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnTagDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTagDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTagDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTagDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTagDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTagDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTagDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTagDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTagDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTagDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTagDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTagDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTagDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnTagDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTagDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTagDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTagDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTagDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTagDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTagDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTagDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTagDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTagDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTagDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnTagDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTagDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTagDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_lakeformation.CfnTagAssociation
class CfnTagAssociationDef(BaseCfnResource):
    lf_tags: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnTagAssociation_LFTagPairPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A structure containing an LF-tag key-value pair.\n')
    resource: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_lakeformation.CfnTagAssociation_ResourcePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='UTF-8 string (valid values: ``DATABASE | TABLE`` ). The resource for which the LF-tag policy applies.')
    _init_params: typing.ClassVar[list[str]] = ['lf_tags', 'resource']
    _method_names: typing.ClassVar[list[str]] = ['DatabaseResourceProperty', 'LFTagPairProperty', 'ResourceProperty', 'TableResourceProperty', 'TableWithColumnsResourceProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnTagAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTagAssociationDefConfig] = pydantic.Field(None)


class CfnTagAssociationDefConfig(pydantic.BaseModel):
    DatabaseResourceProperty: typing.Optional[list[CfnTagAssociationDefDatabaseresourcepropertyParams]] = pydantic.Field(None, description='')
    LFTagPairProperty: typing.Optional[list[CfnTagAssociationDefLftagpairpropertyParams]] = pydantic.Field(None, description='')
    ResourceProperty: typing.Optional[list[CfnTagAssociationDefResourcepropertyParams]] = pydantic.Field(None, description='')
    TableResourceProperty: typing.Optional[list[CfnTagAssociationDefTableresourcepropertyParams]] = pydantic.Field(None, description='')
    TableWithColumnsResourceProperty: typing.Optional[list[CfnTagAssociationDefTablewithcolumnsresourcepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnTagAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTagAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTagAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTagAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTagAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTagAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTagAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTagAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTagAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTagAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTagAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTagAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTagAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnTagAssociationDefDatabaseresourcepropertyParams(pydantic.BaseModel):
    catalog_id: str = pydantic.Field(..., description='')
    name: str = pydantic.Field(..., description='')
    ...

class CfnTagAssociationDefLftagpairpropertyParams(pydantic.BaseModel):
    catalog_id: str = pydantic.Field(..., description='')
    tag_key: str = pydantic.Field(..., description='')
    tag_values: typing.Sequence[str] = pydantic.Field(..., description='')
    ...

class CfnTagAssociationDefResourcepropertyParams(pydantic.BaseModel):
    catalog: typing.Any = pydantic.Field(None, description='')
    database: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnTagAssociation_DatabaseResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    table: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnTagAssociation_TableResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    table_with_columns: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnTagAssociation_TableWithColumnsResourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnTagAssociationDefTableresourcepropertyParams(pydantic.BaseModel):
    catalog_id: str = pydantic.Field(..., description='')
    database_name: str = pydantic.Field(..., description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    table_wildcard: typing.Any = pydantic.Field(None, description='')
    ...

class CfnTagAssociationDefTablewithcolumnsresourcepropertyParams(pydantic.BaseModel):
    catalog_id: str = pydantic.Field(..., description='')
    column_names: typing.Sequence[str] = pydantic.Field(..., description='')
    database_name: str = pydantic.Field(..., description='')
    name: str = pydantic.Field(..., description='')
    ...

class CfnTagAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTagAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTagAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTagAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTagAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTagAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTagAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTagAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTagAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTagAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTagAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnTagAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTagAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTagAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.aws_lakeformation.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_lakeformation.CfnDataCellsFilterProps
class CfnDataCellsFilterPropsDef(BaseCfnProperty):
    database_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='UTF-8 string, not less than 1 or more than 255 bytes long, matching the `single-line string pattern <https://docs.aws.amazon.com/lake-formation/latest/dg/aws-lake-formation-api-aws-lake-formation-api-common.html>`_ . A database in the Data Catalog .\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='UTF-8 string, not less than 1 or more than 255 bytes long, matching the `single-line string pattern <https://docs.aws.amazon.com/lake-formation/latest/dg/aws-lake-formation-api-aws-lake-formation-api-common.html>`_ . The name given by the user to the data filter cell.\n')
    table_catalog_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Catalog id string, not less than 1 or more than 255 bytes long, matching the `single-line string pattern <https://docs.aws.amazon.com/lake-formation/latest/dg/aws-lake-formation-api-aws-lake-formation-api-common.html>`_ . The ID of the catalog to which the table belongs.\n')
    table_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='UTF-8 string, not less than 1 or more than 255 bytes long, matching the `single-line string pattern <https://docs.aws.amazon.com/lake-formation/latest/dg/aws-lake-formation-api-aws-lake-formation-api-common.html>`_ . A table in the database.\n')
    column_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='An array of UTF-8 strings. A list of column names.\n')
    column_wildcard: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnDataCellsFilter_ColumnWildcardPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A wildcard with exclusions. You must specify either a ``ColumnNames`` list or the ``ColumnWildCard`` .\n')
    row_filter: typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnDataCellsFilter_RowFilterPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A PartiQL predicate.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lakeformation-datacellsfilter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    # all_rows_wildcard: Any\n\n    cfn_data_cells_filter_props = lakeformation.CfnDataCellsFilterProps(\n        database_name="databaseName",\n        name="name",\n        table_catalog_id="tableCatalogId",\n        table_name="tableName",\n\n        # the properties below are optional\n        column_names=["columnNames"],\n        column_wildcard=lakeformation.CfnDataCellsFilter.ColumnWildcardProperty(\n            excluded_column_names=["excludedColumnNames"]\n        ),\n        row_filter=lakeformation.CfnDataCellsFilter.RowFilterProperty(\n            all_rows_wildcard=all_rows_wildcard,\n            filter_expression="filterExpression"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['database_name', 'name', 'table_catalog_id', 'table_name', 'column_names', 'column_wildcard', 'row_filter']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnDataCellsFilterProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnDataLakeSettingsProps
class CfnDataLakeSettingsPropsDef(BaseCfnProperty):
    admins: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnDataLakeSettings_DataLakePrincipalPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of AWS Lake Formation principals.\n')
    allow_external_data_filtering: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Whether to allow Amazon EMR clusters or other third-party query engines to access data managed by Lake Formation . If set to true, you allow Amazon EMR clusters or other third-party engines to access data in Amazon S3 locations that are registered with Lake Formation . If false or null, no third-party query engines will be able to access data in Amazon S3 locations that are registered with Lake Formation. For more information, see `External data filtering setting <https://docs.aws.amazon.com/lake-formation/latest/dg/initial-LF-setup.html#external-data-filter>`_ .\n')
    allow_full_table_external_data_access: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether query engines and applications can get credentials without IAM session tags if the user has full table access. It provides query engines and applications performance benefits as well as simplifies data access. Amazon EMR on Amazon EC2 is able to leverage this setting. For more information, see ` <https://docs.aws.amazon.com/lake-formation/latest/dg/using-cred-vending.html>`_\n')
    authorized_session_tag_value_list: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Lake Formation relies on a privileged process secured by Amazon EMR or the third party integrator to tag the user\'s role while assuming it. Lake Formation will publish the acceptable key-value pair, for example key = "LakeFormationTrustedCaller" and value = "TRUE" and the third party integrator must properly tag the temporary security credentials that will be used to call Lake Formation \'s administrative API operations.\n')
    create_database_default_permissions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnDataLakeSettings_PrincipalPermissionsPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Specifies whether access control on a newly created database is managed by Lake Formation permissions or exclusively by IAM permissions. A null value indicates that the access is controlled by Lake Formation permissions. ``ALL`` permissions assigned to ``IAM_ALLOWED_PRINCIPALS`` group indicates that the user\'s IAM permissions determine the access to the database. This is referred to as the setting "Use only IAM access control," and is to support backward compatibility with the AWS Glue permission model implemented by IAM permissions. The only permitted values are an empty array or an array that contains a single JSON object that grants ``ALL`` to ``IAM_ALLOWED_PRINCIPALS`` . For more information, see `Changing the default security settings for your data lake <https://docs.aws.amazon.com/lake-formation/latest/dg/change-settings.html>`_ .\n')
    create_table_default_permissions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnDataLakeSettings_PrincipalPermissionsPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Specifies whether access control on a newly created table is managed by Lake Formation permissions or exclusively by IAM permissions. A null value indicates that the access is controlled by Lake Formation permissions. ``ALL`` permissions assigned to ``IAM_ALLOWED_PRINCIPALS`` group indicate that the user\'s IAM permissions determine the access to the table. This is referred to as the setting "Use only IAM access control," and is to support the backward compatibility with the AWS Glue permission model implemented by IAM permissions. The only permitted values are an empty array or an array that contains a single JSON object that grants ``ALL`` permissions to ``IAM_ALLOWED_PRINCIPALS`` . For more information, see `Changing the default security settings for your data lake <https://docs.aws.amazon.com/lake-formation/latest/dg/change-settings.html>`_ .\n')
    external_data_filtering_allow_list: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnDataLakeSettings_DataLakePrincipalPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of the account IDs of AWS accounts with Amazon EMR clusters or third-party engines that are allwed to perform data filtering.\n')
    mutation_type: typing.Optional[str] = pydantic.Field(None, description='Specifies whether the data lake settings are updated by adding new values to the current settings ( ``APPEND`` ) or by replacing the current settings with new settings ( ``REPLACE`` ). .. epigraph:: If you choose ``REPLACE`` , your current data lake settings will be replaced with the new values in your template.\n')
    parameters: typing.Any = pydantic.Field(None, description='A key-value map that provides an additional configuration on your data lake. ``CrossAccountVersion`` is the key you can configure in the ``Parameters`` field. Accepted values for the ``CrossAccountVersion`` key are 1, 2, and 3.\n')
    trusted_resource_owners: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='An array of UTF-8 strings. A list of the resource-owning account IDs that the caller\'s account can use to share their user access details (user ARNs). The user ARNs can be logged in the resource owner\'s CloudTrail log. You may want to specify this property when you are in a high-trust boundary, such as the same team or company.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lakeformation-datalakesettings.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    # parameters: Any\n\n    cfn_data_lake_settings_props = lakeformation.CfnDataLakeSettingsProps(\n        admins=[lakeformation.CfnDataLakeSettings.DataLakePrincipalProperty(\n            data_lake_principal_identifier="dataLakePrincipalIdentifier"\n        )],\n        allow_external_data_filtering=False,\n        allow_full_table_external_data_access=False,\n        authorized_session_tag_value_list=["authorizedSessionTagValueList"],\n        create_database_default_permissions=[lakeformation.CfnDataLakeSettings.PrincipalPermissionsProperty(\n            permissions=["permissions"],\n            principal=lakeformation.CfnDataLakeSettings.DataLakePrincipalProperty(\n                data_lake_principal_identifier="dataLakePrincipalIdentifier"\n            )\n        )],\n        create_table_default_permissions=[lakeformation.CfnDataLakeSettings.PrincipalPermissionsProperty(\n            permissions=["permissions"],\n            principal=lakeformation.CfnDataLakeSettings.DataLakePrincipalProperty(\n                data_lake_principal_identifier="dataLakePrincipalIdentifier"\n            )\n        )],\n        external_data_filtering_allow_list=[lakeformation.CfnDataLakeSettings.DataLakePrincipalProperty(\n            data_lake_principal_identifier="dataLakePrincipalIdentifier"\n        )],\n        mutation_type="mutationType",\n        parameters=parameters,\n        trusted_resource_owners=["trustedResourceOwners"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['admins', 'allow_external_data_filtering', 'allow_full_table_external_data_access', 'authorized_session_tag_value_list', 'create_database_default_permissions', 'create_table_default_permissions', 'external_data_filtering_allow_list', 'mutation_type', 'parameters', 'trusted_resource_owners']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnDataLakeSettingsProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnPermissionsProps
class CfnPermissionsPropsDef(BaseCfnProperty):
    data_lake_principal: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_lakeformation.CfnPermissions_DataLakePrincipalPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The AWS Lake Formation principal.\n')
    resource: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_lakeformation.CfnPermissions_ResourcePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A structure for the resource.\n')
    permissions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The permissions granted or revoked.\n')
    permissions_with_grant_option: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Indicates the ability to grant permissions (as a subset of permissions granted).\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lakeformation-permissions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    cfn_permissions_props = lakeformation.CfnPermissionsProps(\n        data_lake_principal=lakeformation.CfnPermissions.DataLakePrincipalProperty(\n            data_lake_principal_identifier="dataLakePrincipalIdentifier"\n        ),\n        resource=lakeformation.CfnPermissions.ResourceProperty(\n            database_resource=lakeformation.CfnPermissions.DatabaseResourceProperty(\n                catalog_id="catalogId",\n                name="name"\n            ),\n            data_location_resource=lakeformation.CfnPermissions.DataLocationResourceProperty(\n                catalog_id="catalogId",\n                s3_resource="s3Resource"\n            ),\n            table_resource=lakeformation.CfnPermissions.TableResourceProperty(\n                catalog_id="catalogId",\n                database_name="databaseName",\n                name="name",\n                table_wildcard=lakeformation.CfnPermissions.TableWildcardProperty()\n            ),\n            table_with_columns_resource=lakeformation.CfnPermissions.TableWithColumnsResourceProperty(\n                catalog_id="catalogId",\n                column_names=["columnNames"],\n                column_wildcard=lakeformation.CfnPermissions.ColumnWildcardProperty(\n                    excluded_column_names=["excludedColumnNames"]\n                ),\n                database_name="databaseName",\n                name="name"\n            )\n        ),\n\n        # the properties below are optional\n        permissions=["permissions"],\n        permissions_with_grant_option=["permissionsWithGrantOption"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['data_lake_principal', 'resource', 'permissions', 'permissions_with_grant_option']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPermissionsProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnPrincipalPermissionsProps
class CfnPrincipalPermissionsPropsDef(BaseCfnProperty):
    permissions: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The permissions granted or revoked.\n')
    permissions_with_grant_option: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Indicates the ability to grant permissions (as a subset of permissions granted).\n')
    principal: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_DataLakePrincipalPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The principal to be granted a permission.\n')
    resource: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_lakeformation.CfnPrincipalPermissions_ResourcePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The resource to be granted or revoked permissions.\n')
    catalog: typing.Optional[str] = pydantic.Field(None, description='The identifier for the Data Catalog . By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lakeformation-principalpermissions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    # catalog: Any\n    # table_wildcard: Any\n\n    cfn_principal_permissions_props = lakeformation.CfnPrincipalPermissionsProps(\n        permissions=["permissions"],\n        permissions_with_grant_option=["permissionsWithGrantOption"],\n        principal=lakeformation.CfnPrincipalPermissions.DataLakePrincipalProperty(\n            data_lake_principal_identifier="dataLakePrincipalIdentifier"\n        ),\n        resource=lakeformation.CfnPrincipalPermissions.ResourceProperty(\n            catalog=catalog,\n            database=lakeformation.CfnPrincipalPermissions.DatabaseResourceProperty(\n                catalog_id="catalogId",\n                name="name"\n            ),\n            data_cells_filter=lakeformation.CfnPrincipalPermissions.DataCellsFilterResourceProperty(\n                database_name="databaseName",\n                name="name",\n                table_catalog_id="tableCatalogId",\n                table_name="tableName"\n            ),\n            data_location=lakeformation.CfnPrincipalPermissions.DataLocationResourceProperty(\n                catalog_id="catalogId",\n                resource_arn="resourceArn"\n            ),\n            lf_tag=lakeformation.CfnPrincipalPermissions.LFTagKeyResourceProperty(\n                catalog_id="catalogId",\n                tag_key="tagKey",\n                tag_values=["tagValues"]\n            ),\n            lf_tag_policy=lakeformation.CfnPrincipalPermissions.LFTagPolicyResourceProperty(\n                catalog_id="catalogId",\n                expression=[lakeformation.CfnPrincipalPermissions.LFTagProperty(\n                    tag_key="tagKey",\n                    tag_values=["tagValues"]\n                )],\n                resource_type="resourceType"\n            ),\n            table=lakeformation.CfnPrincipalPermissions.TableResourceProperty(\n                catalog_id="catalogId",\n                database_name="databaseName",\n\n                # the properties below are optional\n                name="name",\n                table_wildcard=table_wildcard\n            ),\n            table_with_columns=lakeformation.CfnPrincipalPermissions.TableWithColumnsResourceProperty(\n                catalog_id="catalogId",\n                database_name="databaseName",\n                name="name",\n\n                # the properties below are optional\n                column_names=["columnNames"],\n                column_wildcard=lakeformation.CfnPrincipalPermissions.ColumnWildcardProperty(\n                    excluded_column_names=["excludedColumnNames"]\n                )\n            )\n        ),\n\n        # the properties below are optional\n        catalog="catalog"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['permissions', 'permissions_with_grant_option', 'principal', 'resource', 'catalog']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnPrincipalPermissionsProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnResourceProps
class CfnResourcePropsDef(BaseCfnProperty):
    resource_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the resource.\n')
    use_service_linked_role: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='Designates a trusted caller, an IAM principal, by registering this caller with the Data Catalog .\n')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='The IAM role that registered a resource.\n')
    with_federation: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Allows Lake Formation to assume a role to access tables in a federated database.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lakeformation-resource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    cfn_resource_props = lakeformation.CfnResourceProps(\n        resource_arn="resourceArn",\n        use_service_linked_role=False,\n\n        # the properties below are optional\n        role_arn="roleArn",\n        with_federation=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resource_arn', 'use_service_linked_role', 'role_arn', 'with_federation']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnResourceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnTagAssociationProps
class CfnTagAssociationPropsDef(BaseCfnProperty):
    lf_tags: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_lakeformation.CfnTagAssociation_LFTagPairPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A structure containing an LF-tag key-value pair.\n')
    resource: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_lakeformation.CfnTagAssociation_ResourcePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='UTF-8 string (valid values: ``DATABASE | TABLE`` ). The resource for which the LF-tag policy applies.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lakeformation-tagassociation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    # catalog: Any\n    # table_wildcard: Any\n\n    cfn_tag_association_props = lakeformation.CfnTagAssociationProps(\n        lf_tags=[lakeformation.CfnTagAssociation.LFTagPairProperty(\n            catalog_id="catalogId",\n            tag_key="tagKey",\n            tag_values=["tagValues"]\n        )],\n        resource=lakeformation.CfnTagAssociation.ResourceProperty(\n            catalog=catalog,\n            database=lakeformation.CfnTagAssociation.DatabaseResourceProperty(\n                catalog_id="catalogId",\n                name="name"\n            ),\n            table=lakeformation.CfnTagAssociation.TableResourceProperty(\n                catalog_id="catalogId",\n                database_name="databaseName",\n\n                # the properties below are optional\n                name="name",\n                table_wildcard=table_wildcard\n            ),\n            table_with_columns=lakeformation.CfnTagAssociation.TableWithColumnsResourceProperty(\n                catalog_id="catalogId",\n                column_names=["columnNames"],\n                database_name="databaseName",\n                name="name"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['lf_tags', 'resource']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnTagAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_lakeformation.CfnTagProps
class CfnTagPropsDef(BaseCfnProperty):
    tag_key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='UTF-8 string, not less than 1 or more than 255 bytes long, matching the `single-line string pattern <https://docs.aws.amazon.com/lake-formation/latest/dg/aws-lake-formation-api-aws-lake-formation-api-common.html>`_ . The key-name for the LF-tag.\n')
    tag_values: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='An array of UTF-8 strings, not less than 1 or more than 50 strings. A list of possible values of the corresponding ``TagKey`` of an LF-tag key-value pair.\n')
    catalog_id: typing.Optional[str] = pydantic.Field(None, description='Catalog id string, not less than 1 or more than 255 bytes long, matching the `single-line string pattern <https://docs.aws.amazon.com/lake-formation/latest/dg/aws-lake-formation-api-aws-lake-formation-api-common.html>`_ . The identifier for the Data Catalog . By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your AWS Lake Formation environment.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lakeformation-tag.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_lakeformation as lakeformation\n\n    cfn_tag_props = lakeformation.CfnTagProps(\n        tag_key="tagKey",\n        tag_values=["tagValues"],\n\n        # the properties below are optional\n        catalog_id="catalogId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['tag_key', 'tag_values', 'catalog_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_lakeformation.CfnTagProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    CfnDataCellsFilter_ColumnWildcardProperty: typing.Optional[dict[str, CfnDataCellsFilter_ColumnWildcardPropertyDef]] = pydantic.Field(None)
    CfnDataCellsFilter_RowFilterProperty: typing.Optional[dict[str, CfnDataCellsFilter_RowFilterPropertyDef]] = pydantic.Field(None)
    CfnDataLakeSettings_DataLakePrincipalProperty: typing.Optional[dict[str, CfnDataLakeSettings_DataLakePrincipalPropertyDef]] = pydantic.Field(None)
    CfnDataLakeSettings_PrincipalPermissionsProperty: typing.Optional[dict[str, CfnDataLakeSettings_PrincipalPermissionsPropertyDef]] = pydantic.Field(None)
    CfnPermissions_ColumnWildcardProperty: typing.Optional[dict[str, CfnPermissions_ColumnWildcardPropertyDef]] = pydantic.Field(None)
    CfnPermissions_DatabaseResourceProperty: typing.Optional[dict[str, CfnPermissions_DatabaseResourcePropertyDef]] = pydantic.Field(None)
    CfnPermissions_DataLakePrincipalProperty: typing.Optional[dict[str, CfnPermissions_DataLakePrincipalPropertyDef]] = pydantic.Field(None)
    CfnPermissions_DataLocationResourceProperty: typing.Optional[dict[str, CfnPermissions_DataLocationResourcePropertyDef]] = pydantic.Field(None)
    CfnPermissions_ResourceProperty: typing.Optional[dict[str, CfnPermissions_ResourcePropertyDef]] = pydantic.Field(None)
    CfnPermissions_TableResourceProperty: typing.Optional[dict[str, CfnPermissions_TableResourcePropertyDef]] = pydantic.Field(None)
    CfnPermissions_TableWildcardProperty: typing.Optional[dict[str, CfnPermissions_TableWildcardPropertyDef]] = pydantic.Field(None)
    CfnPermissions_TableWithColumnsResourceProperty: typing.Optional[dict[str, CfnPermissions_TableWithColumnsResourcePropertyDef]] = pydantic.Field(None)
    CfnPrincipalPermissions_ColumnWildcardProperty: typing.Optional[dict[str, CfnPrincipalPermissions_ColumnWildcardPropertyDef]] = pydantic.Field(None)
    CfnPrincipalPermissions_DatabaseResourceProperty: typing.Optional[dict[str, CfnPrincipalPermissions_DatabaseResourcePropertyDef]] = pydantic.Field(None)
    CfnPrincipalPermissions_DataCellsFilterResourceProperty: typing.Optional[dict[str, CfnPrincipalPermissions_DataCellsFilterResourcePropertyDef]] = pydantic.Field(None)
    CfnPrincipalPermissions_DataLakePrincipalProperty: typing.Optional[dict[str, CfnPrincipalPermissions_DataLakePrincipalPropertyDef]] = pydantic.Field(None)
    CfnPrincipalPermissions_DataLocationResourceProperty: typing.Optional[dict[str, CfnPrincipalPermissions_DataLocationResourcePropertyDef]] = pydantic.Field(None)
    CfnPrincipalPermissions_LFTagKeyResourceProperty: typing.Optional[dict[str, CfnPrincipalPermissions_LFTagKeyResourcePropertyDef]] = pydantic.Field(None)
    CfnPrincipalPermissions_LFTagPolicyResourceProperty: typing.Optional[dict[str, CfnPrincipalPermissions_LFTagPolicyResourcePropertyDef]] = pydantic.Field(None)
    CfnPrincipalPermissions_LFTagProperty: typing.Optional[dict[str, CfnPrincipalPermissions_LFTagPropertyDef]] = pydantic.Field(None)
    CfnPrincipalPermissions_ResourceProperty: typing.Optional[dict[str, CfnPrincipalPermissions_ResourcePropertyDef]] = pydantic.Field(None)
    CfnPrincipalPermissions_TableResourceProperty: typing.Optional[dict[str, CfnPrincipalPermissions_TableResourcePropertyDef]] = pydantic.Field(None)
    CfnPrincipalPermissions_TableWithColumnsResourceProperty: typing.Optional[dict[str, CfnPrincipalPermissions_TableWithColumnsResourcePropertyDef]] = pydantic.Field(None)
    CfnTagAssociation_DatabaseResourceProperty: typing.Optional[dict[str, CfnTagAssociation_DatabaseResourcePropertyDef]] = pydantic.Field(None)
    CfnTagAssociation_LFTagPairProperty: typing.Optional[dict[str, CfnTagAssociation_LFTagPairPropertyDef]] = pydantic.Field(None)
    CfnTagAssociation_ResourceProperty: typing.Optional[dict[str, CfnTagAssociation_ResourcePropertyDef]] = pydantic.Field(None)
    CfnTagAssociation_TableResourceProperty: typing.Optional[dict[str, CfnTagAssociation_TableResourcePropertyDef]] = pydantic.Field(None)
    CfnTagAssociation_TableWithColumnsResourceProperty: typing.Optional[dict[str, CfnTagAssociation_TableWithColumnsResourcePropertyDef]] = pydantic.Field(None)
    CfnDataCellsFilter: typing.Optional[dict[str, CfnDataCellsFilterDef]] = pydantic.Field(None)
    CfnDataLakeSettings: typing.Optional[dict[str, CfnDataLakeSettingsDef]] = pydantic.Field(None)
    CfnPermissions: typing.Optional[dict[str, CfnPermissionsDef]] = pydantic.Field(None)
    CfnPrincipalPermissions: typing.Optional[dict[str, CfnPrincipalPermissionsDef]] = pydantic.Field(None)
    CfnResource: typing.Optional[dict[str, CfnResourceDef]] = pydantic.Field(None)
    CfnTag: typing.Optional[dict[str, CfnTagDef]] = pydantic.Field(None)
    CfnTagAssociation: typing.Optional[dict[str, CfnTagAssociationDef]] = pydantic.Field(None)
    CfnDataCellsFilterProps: typing.Optional[dict[str, CfnDataCellsFilterPropsDef]] = pydantic.Field(None)
    CfnDataLakeSettingsProps: typing.Optional[dict[str, CfnDataLakeSettingsPropsDef]] = pydantic.Field(None)
    CfnPermissionsProps: typing.Optional[dict[str, CfnPermissionsPropsDef]] = pydantic.Field(None)
    CfnPrincipalPermissionsProps: typing.Optional[dict[str, CfnPrincipalPermissionsPropsDef]] = pydantic.Field(None)
    CfnResourceProps: typing.Optional[dict[str, CfnResourcePropsDef]] = pydantic.Field(None)
    CfnTagAssociationProps: typing.Optional[dict[str, CfnTagAssociationPropsDef]] = pydantic.Field(None)
    CfnTagProps: typing.Optional[dict[str, CfnTagPropsDef]] = pydantic.Field(None)
    ...
