from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_ssm.StringListParameter
class StringListParameterDef(BaseConstruct):
    string_list_value: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The values of the parameter. It may not reference another parameter and ``{{}}`` cannot be used in the value.\n')
    allowed_pattern: typing.Optional[str] = pydantic.Field(None, description='A regular expression used to validate the parameter value. For example, for String types with values restricted to numbers, you can specify the following: ``^\\d+$`` Default: no validation is performed\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Information about the parameter that you want to add to the system. Default: none\n')
    parameter_name: typing.Optional[str] = pydantic.Field(None, description='The name of the parameter. Default: - a name will be generated by CloudFormation\n')
    simple_name: typing.Optional[bool] = pydantic.Field(None, description='Indicates if the parameter name is a simple name (i.e. does not include "/" separators). This is required only if ``parameterName`` is a token, which means we are unable to detect if the name is simple or "path-like" for the purpose of rendering SSM parameter ARNs. If ``parameterName`` is not specified, ``simpleName`` must be ``true`` (or undefined) since the name generated by AWS CloudFormation is always a simple name. Default: - auto-detect based on ``parameterName``\n')
    tier: typing.Optional[aws_cdk.aws_ssm.ParameterTier] = pydantic.Field(None, description='The tier of the string parameter. Default: - undefined')
    _init_params: typing.ClassVar[list[str]] = ['string_list_value', 'allowed_pattern', 'description', 'parameter_name', 'simple_name', 'tier']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'grant_read', 'grant_write']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_list_parameter_attributes', 'from_string_list_parameter_name', 'value_for_typed_list_parameter']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.StringListParameter'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_list_parameter_attributes', 'from_string_list_parameter_name']
    ...


    from_list_parameter_attributes: typing.Optional[models.aws_ssm.StringListParameterDefFromListParameterAttributesParams] = pydantic.Field(None, description='Imports an external string list parameter with name and optional version.')
    from_string_list_parameter_name: typing.Optional[models.aws_ssm.StringListParameterDefFromStringListParameterNameParams] = pydantic.Field(None, description='Imports an external parameter of type string list.\nReturns a token and should not be parsed.')
    resource_config: typing.Optional[models.aws_ssm.StringListParameterDefConfig] = pydantic.Field(None)


class StringListParameterDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    grant_read: typing.Optional[list[models.aws_ssm.StringListParameterDefGrantReadParams]] = pydantic.Field(None, description='Grants read (DescribeParameter, GetParameter, GetParameterHistory) permissions on the SSM Parameter.')
    grant_write: typing.Optional[list[models.aws_ssm.StringListParameterDefGrantWriteParams]] = pydantic.Field(None, description='Grants write (PutParameter) permissions on the SSM Parameter.')
    value_for_typed_list_parameter: typing.Optional[list[models.aws_ssm.StringListParameterDefValueForTypedListParameterParams]] = pydantic.Field(None, description='Returns a token that will resolve (during deployment) to the list value of an SSM StringList parameter.')

class StringListParameterDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class StringListParameterDefFromListParameterAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    element_type: typing.Optional[aws_cdk.aws_ssm.ParameterValueType] = pydantic.Field(None, description='The type of the string list parameter value. Using specific types can be helpful in catching invalid values at the start of creating or updating a stack. CloudFormation validates the values against existing values in the account. Note - if you want to allow values from different AWS accounts, use ParameterValueType.STRING Default: ParameterValueType.STRING\n')
    version: typing.Union[int, float, None] = pydantic.Field(None, description='The version number of the value you wish to retrieve. Default: The latest version will be retrieved.\n')
    parameter_name: str = pydantic.Field(..., description='The name of the parameter store value. This value can be a token or a concrete string. If it is a concrete string and includes "/" it must also be prefixed with a "/" (fully-qualified).\n')
    simple_name: typing.Optional[bool] = pydantic.Field(None, description='Indicates if the parameter name is a simple name (i.e. does not include "/" separators). This is required only if ``parameterName`` is a token, which means we are unable to detect if the name is simple or "path-like" for the purpose of rendering SSM parameter ARNs. If ``parameterName`` is not specified, ``simpleName`` must be ``true`` (or undefined) since the name generated by AWS CloudFormation is always a simple name. Default: - auto-detect based on ``parameterName``')
    ...

class StringListParameterDefFromStringListParameterNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    string_list_parameter_name: str = pydantic.Field(..., description='-')
    ...

class StringListParameterDefGrantReadParams(pydantic.BaseModel):
    grantee: models.AnyResource = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class StringListParameterDefGrantWriteParams(pydantic.BaseModel):
    grantee: models.AnyResource = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class StringListParameterDefValueForTypedListParameterParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='Some scope within a stack.\n')
    parameter_name: str = pydantic.Field(..., description='The name of the SSM parameter.\n')
    type: typing.Optional[aws_cdk.aws_ssm.ParameterValueType] = pydantic.Field(None, description='the type of the SSM list parameter.\n')
    version: typing.Union[int, float, None] = pydantic.Field(None, description="The parameter version (recommended in order to ensure that the value won't change during deployment).")
    ...


#  autogenerated from aws_cdk.aws_ssm.StringParameter
class StringParameterDef(BaseConstruct):
    string_value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The value of the parameter. It may not reference another parameter and ``{{}}`` cannot be used in the value.\n')
    data_type: typing.Optional[aws_cdk.aws_ssm.ParameterDataType] = pydantic.Field(None, description='The data type of the parameter, such as ``text`` or ``aws:ec2:image``. Default: ParameterDataType.TEXT\n')
    type: typing.Optional[aws_cdk.aws_ssm.ParameterType] = pydantic.Field(None, description='(deprecated) The type of the string parameter. Default: ParameterType.STRING\n')
    allowed_pattern: typing.Optional[str] = pydantic.Field(None, description='A regular expression used to validate the parameter value. For example, for String types with values restricted to numbers, you can specify the following: ``^\\d+$`` Default: no validation is performed\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Information about the parameter that you want to add to the system. Default: none\n')
    parameter_name: typing.Optional[str] = pydantic.Field(None, description='The name of the parameter. Default: - a name will be generated by CloudFormation\n')
    simple_name: typing.Optional[bool] = pydantic.Field(None, description='Indicates if the parameter name is a simple name (i.e. does not include "/" separators). This is required only if ``parameterName`` is a token, which means we are unable to detect if the name is simple or "path-like" for the purpose of rendering SSM parameter ARNs. If ``parameterName`` is not specified, ``simpleName`` must be ``true`` (or undefined) since the name generated by AWS CloudFormation is always a simple name. Default: - auto-detect based on ``parameterName``\n')
    tier: typing.Optional[aws_cdk.aws_ssm.ParameterTier] = pydantic.Field(None, description='The tier of the string parameter. Default: - undefined')
    _init_params: typing.ClassVar[list[str]] = ['string_value', 'data_type', 'type', 'allowed_pattern', 'description', 'parameter_name', 'simple_name', 'tier']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'grant_read', 'grant_write']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_secure_string_parameter_attributes', 'from_string_parameter_attributes', 'from_string_parameter_name', 'value_for_secure_string_parameter', 'value_for_string_parameter', 'value_for_typed_string_parameter', 'value_for_typed_string_parameter_v2', 'value_from_lookup']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.StringParameter'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_secure_string_parameter_attributes', 'from_string_parameter_attributes', 'from_string_parameter_name']
    ...


    from_secure_string_parameter_attributes: typing.Optional[models.aws_ssm.StringParameterDefFromSecureStringParameterAttributesParams] = pydantic.Field(None, description='Imports a secure string parameter from the SSM parameter store.')
    from_string_parameter_attributes: typing.Optional[models.aws_ssm.StringParameterDefFromStringParameterAttributesParams] = pydantic.Field(None, description='Imports an external string parameter with name and optional version.')
    from_string_parameter_name: typing.Optional[models.aws_ssm.StringParameterDefFromStringParameterNameParams] = pydantic.Field(None, description='Imports an external string parameter by name.')
    resource_config: typing.Optional[models.aws_ssm.StringParameterDefConfig] = pydantic.Field(None)


class StringParameterDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    grant_read: typing.Optional[list[models.aws_ssm.StringParameterDefGrantReadParams]] = pydantic.Field(None, description='Grants read (DescribeParameter, GetParameter, GetParameterHistory) permissions on the SSM Parameter.')
    grant_write: typing.Optional[list[models.aws_ssm.StringParameterDefGrantWriteParams]] = pydantic.Field(None, description='Grants write (PutParameter) permissions on the SSM Parameter.')
    value_for_secure_string_parameter: typing.Optional[list[models.aws_ssm.StringParameterDefValueForSecureStringParameterParams]] = pydantic.Field(None, description='(deprecated) Returns a token that will resolve (during deployment).')
    value_for_string_parameter: typing.Optional[list[models.aws_ssm.StringParameterDefValueForStringParameterParams]] = pydantic.Field(None, description='Returns a token that will resolve (during deployment) to the string value of an SSM string parameter.')
    value_for_typed_string_parameter: typing.Optional[list[models.aws_ssm.StringParameterDefValueForTypedStringParameterParams]] = pydantic.Field(None, description='(deprecated) Returns a token that will resolve (during deployment) to the string value of an SSM string parameter.')
    value_for_typed_string_parameter_v2: typing.Optional[list[models.aws_ssm.StringParameterDefValueForTypedStringParameterV2Params]] = pydantic.Field(None, description='Returns a token that will resolve (during deployment) to the string value of an SSM string parameter.')
    value_from_lookup: typing.Optional[list[models.aws_ssm.StringParameterDefValueFromLookupParams]] = pydantic.Field(None, description='Reads the value of an SSM parameter during synthesis through an environmental context provider.\nRequires that the stack this scope is defined in will have explicit\naccount/region information. Otherwise, it will fail during synthesis.')

class StringParameterDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class StringParameterDefFromSecureStringParameterAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The encryption key that is used to encrypt this parameter. Default: - default master key\n')
    version: typing.Union[int, float, None] = pydantic.Field(None, description='The version number of the value you wish to retrieve. Default: - AWS CloudFormation uses the latest version of the parameter\n')
    parameter_name: str = pydantic.Field(..., description='The name of the parameter store value. This value can be a token or a concrete string. If it is a concrete string and includes "/" it must also be prefixed with a "/" (fully-qualified).\n')
    simple_name: typing.Optional[bool] = pydantic.Field(None, description='Indicates if the parameter name is a simple name (i.e. does not include "/" separators). This is required only if ``parameterName`` is a token, which means we are unable to detect if the name is simple or "path-like" for the purpose of rendering SSM parameter ARNs. If ``parameterName`` is not specified, ``simpleName`` must be ``true`` (or undefined) since the name generated by AWS CloudFormation is always a simple name. Default: - auto-detect based on ``parameterName``')
    ...

class StringParameterDefFromStringParameterAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    force_dynamic_reference: typing.Optional[bool] = pydantic.Field(None, description='Use a dynamic reference as the representation in CloudFormation template level. By default, CDK tries to deduce an appropriate representation based on the parameter value (a CfnParameter or a dynamic reference). Use this flag to override the representation when it does not work. Default: false\n')
    type: typing.Optional[aws_cdk.aws_ssm.ParameterType] = pydantic.Field(None, description='(deprecated) The type of the string parameter. Default: ParameterType.STRING\n')
    value_type: typing.Optional[aws_cdk.aws_ssm.ParameterValueType] = pydantic.Field(None, description='The type of the string parameter value. Using specific types can be helpful in catching invalid values at the start of creating or updating a stack. CloudFormation validates the values against existing values in the account. Note - if you want to allow values from different AWS accounts, use ParameterValueType.STRING Default: ParameterValueType.STRING\n')
    version: typing.Union[int, float, None] = pydantic.Field(None, description='The version number of the value you wish to retrieve. Default: The latest version will be retrieved.\n')
    parameter_name: str = pydantic.Field(..., description='The name of the parameter store value. This value can be a token or a concrete string. If it is a concrete string and includes "/" it must also be prefixed with a "/" (fully-qualified).\n')
    simple_name: typing.Optional[bool] = pydantic.Field(None, description='Indicates if the parameter name is a simple name (i.e. does not include "/" separators). This is required only if ``parameterName`` is a token, which means we are unable to detect if the name is simple or "path-like" for the purpose of rendering SSM parameter ARNs. If ``parameterName`` is not specified, ``simpleName`` must be ``true`` (or undefined) since the name generated by AWS CloudFormation is always a simple name. Default: - auto-detect based on ``parameterName``')
    ...

class StringParameterDefFromStringParameterNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    string_parameter_name: str = pydantic.Field(..., description='-')
    ...

class StringParameterDefGrantReadParams(pydantic.BaseModel):
    grantee: models.AnyResource = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class StringParameterDefGrantWriteParams(pydantic.BaseModel):
    grantee: models.AnyResource = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class StringParameterDefValueForSecureStringParameterParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='Some scope within a stack.\n')
    parameter_name: str = pydantic.Field(..., description='The name of the SSM parameter.\n')
    version: typing.Union[int, float] = pydantic.Field(..., description='The parameter version (required for secure strings).\n\n:deprecated: Use ``SecretValue.ssmSecure()`` instead, it will correctly type the imported value as a ``SecretValue`` and allow importing without version. ``SecretValue`` lives in the core ``aws-cdk-lib`` module.\n\n:stability: deprecated\n')
    ...

class StringParameterDefValueForStringParameterParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='Some scope within a stack.\n')
    parameter_name: str = pydantic.Field(..., description='The name of the SSM parameter.\n')
    version: typing.Union[int, float, None] = pydantic.Field(None, description="The parameter version (recommended in order to ensure that the value won't change during deployment).")
    ...

class StringParameterDefValueForTypedStringParameterParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='Some scope within a stack.\n')
    parameter_name: str = pydantic.Field(..., description='The name of the SSM parameter.\n')
    type: typing.Optional[aws_cdk.aws_ssm.ParameterType] = pydantic.Field(None, description='The type of the SSM parameter.\n')
    version: typing.Union[int, float, None] = pydantic.Field(None, description="The parameter version (recommended in order to ensure that the value won't change during deployment).\n\n:deprecated: - use valueForTypedStringParameterV2 instead\n\n:stability: deprecated\n")
    ...

class StringParameterDefValueForTypedStringParameterV2Params(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='Some scope within a stack.\n')
    parameter_name: str = pydantic.Field(..., description='The name of the SSM parameter.\n')
    type: typing.Optional[aws_cdk.aws_ssm.ParameterValueType] = pydantic.Field(None, description='The type of the SSM parameter.\n')
    version: typing.Union[int, float, None] = pydantic.Field(None, description="The parameter version (recommended in order to ensure that the value won't change during deployment).")
    ...

class StringParameterDefValueFromLookupParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    parameter_name: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ssm.CfnAssociation.InstanceAssociationOutputLocationProperty
class CfnAssociation_InstanceAssociationOutputLocationPropertyDef(BaseStruct):
    s3_location: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnAssociation_S3OutputLocationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='``S3OutputLocation`` is a property of the `InstanceAssociationOutputLocation <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-association-instanceassociationoutputlocation.html>`_ property that specifies an Amazon S3 bucket where you want to store the results of this request.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-association-instanceassociationoutputlocation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    instance_association_output_location_property = ssm.CfnAssociation.InstanceAssociationOutputLocationProperty(\n        s3_location=ssm.CfnAssociation.S3OutputLocationProperty(\n            output_s3_bucket_name="outputS3BucketName",\n            output_s3_key_prefix="outputS3KeyPrefix",\n            output_s3_region="outputS3Region"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['s3_location']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnAssociation.InstanceAssociationOutputLocationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnAssociation.S3OutputLocationProperty
class CfnAssociation_S3OutputLocationPropertyDef(BaseStruct):
    output_s3_bucket_name: typing.Optional[str] = pydantic.Field(None, description='The name of the S3 bucket.\n')
    output_s3_key_prefix: typing.Optional[str] = pydantic.Field(None, description='The S3 bucket subfolder.\n')
    output_s3_region: typing.Optional[str] = pydantic.Field(None, description='The AWS Region of the S3 bucket.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-association-s3outputlocation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    s3_output_location_property = ssm.CfnAssociation.S3OutputLocationProperty(\n        output_s3_bucket_name="outputS3BucketName",\n        output_s3_key_prefix="outputS3KeyPrefix",\n        output_s3_region="outputS3Region"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['output_s3_bucket_name', 'output_s3_key_prefix', 'output_s3_region']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnAssociation.S3OutputLocationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnAssociation.TargetProperty
class CfnAssociation_TargetPropertyDef(BaseStruct):
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='User-defined criteria for sending commands that target managed nodes that meet the criteria.\n')
    values: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='User-defined criteria that maps to ``Key`` . For example, if you specified ``tag:ServerRole`` , you could specify ``value:WebServer`` to run a command on instances that include EC2 tags of ``ServerRole,WebServer`` . Depending on the type of target, the maximum number of values for a key might be lower than the global maximum of 50.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-association-target.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    target_property = ssm.CfnAssociation.TargetProperty(\n        key="key",\n        values=["values"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'values']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnAssociation.TargetProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnDocument.AttachmentsSourceProperty
class CfnDocument_AttachmentsSourcePropertyDef(BaseStruct):
    key: typing.Optional[str] = pydantic.Field(None, description='The key of a key-value pair that identifies the location of an attachment to a document.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the document attachment file.\n')
    values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The value of a key-value pair that identifies the location of an attachment to a document. The format for *Value* depends on the type of key you specify. - For the key *SourceUrl* , the value is an S3 bucket location. For example: ``"Values": [ "s3://doc-example-bucket/my-folder" ]`` - For the key *S3FileUrl* , the value is a file in an S3 bucket. For example: ``"Values": [ "s3://doc-example-bucket/my-folder/my-file.py" ]`` - For the key *AttachmentReference* , the value is constructed from the name of another SSM document in your account, a version number of that document, and a file attached to that document version that you want to reuse. For example: ``"Values": [ "MyOtherDocument/3/my-other-file.py" ]`` However, if the SSM document is shared with you from another account, the full SSM document ARN must be specified instead of the document name only. For example: ``"Values": [ "arn:aws:ssm:us-east-2:111122223333:document/OtherAccountDocument/3/their-file.py" ]``\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-document-attachmentssource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    attachments_source_property = ssm.CfnDocument.AttachmentsSourceProperty(\n        key="key",\n        name="name",\n        values=["values"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'name', 'values']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnDocument.AttachmentsSourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnDocument.DocumentRequiresProperty
class CfnDocument_DocumentRequiresPropertyDef(BaseStruct):
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the required SSM document. The name can be an Amazon Resource Name (ARN).\n')
    version: typing.Optional[str] = pydantic.Field(None, description='The document version required by the current document.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-document-documentrequires.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    document_requires_property = ssm.CfnDocument.DocumentRequiresProperty(\n        name="name",\n        version="version"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnDocument.DocumentRequiresProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnMaintenanceWindowTarget.TargetsProperty
class CfnMaintenanceWindowTarget_TargetsPropertyDef(BaseStruct):
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='User-defined criteria for sending commands that target managed nodes that meet the criteria.\n')
    values: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='User-defined criteria that maps to ``Key`` . For example, if you specified ``tag:ServerRole`` , you could specify ``value:WebServer`` to run a command on instances that include EC2 tags of ``ServerRole,WebServer`` . Depending on the type of target, the maximum number of values for a key might be lower than the global maximum of 50.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-maintenancewindowtarget-targets.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    targets_property = ssm.CfnMaintenanceWindowTarget.TargetsProperty(\n        key="key",\n        values=["values"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'values']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnMaintenanceWindowTarget.TargetsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnMaintenanceWindowTask.CloudWatchOutputConfigProperty
class CfnMaintenanceWindowTask_CloudWatchOutputConfigPropertyDef(BaseStruct):
    cloud_watch_log_group_name: typing.Optional[str] = pydantic.Field(None, description="The name of the CloudWatch Logs log group where you want to send command output. If you don't specify a group name, AWS Systems Manager automatically creates a log group for you. The log group uses the following naming format: ``aws/ssm/ *SystemsManagerDocumentName*``\n")
    cloud_watch_output_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Enables Systems Manager to send command output to CloudWatch Logs.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-maintenancewindowtask-cloudwatchoutputconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    cloud_watch_output_config_property = ssm.CfnMaintenanceWindowTask.CloudWatchOutputConfigProperty(\n        cloud_watch_log_group_name="cloudWatchLogGroupName",\n        cloud_watch_output_enabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cloud_watch_log_group_name', 'cloud_watch_output_enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnMaintenanceWindowTask.CloudWatchOutputConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnMaintenanceWindowTask.LoggingInfoProperty
class CfnMaintenanceWindowTask_LoggingInfoPropertyDef(BaseStruct):
    region: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The AWS Region where the S3 bucket is located.\n')
    s3_bucket: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of an S3 bucket where execution logs are stored.\n')
    s3_prefix: typing.Optional[str] = pydantic.Field(None, description='The Amazon S3 bucket subfolder.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-maintenancewindowtask-logginginfo.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    logging_info_property = ssm.CfnMaintenanceWindowTask.LoggingInfoProperty(\n        region="region",\n        s3_bucket="s3Bucket",\n\n        # the properties below are optional\n        s3_prefix="s3Prefix"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['region', 's3_bucket', 's3_prefix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnMaintenanceWindowTask.LoggingInfoProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnMaintenanceWindowTask.MaintenanceWindowAutomationParametersProperty
class CfnMaintenanceWindowTask_MaintenanceWindowAutomationParametersPropertyDef(BaseStruct):
    document_version: typing.Optional[str] = pydantic.Field(None, description='The version of an Automation runbook to use during task execution.\n')
    parameters: typing.Any = pydantic.Field(None, description='The parameters for the AUTOMATION task.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-maintenancewindowtask-maintenancewindowautomationparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    # parameters: Any\n\n    maintenance_window_automation_parameters_property = ssm.CfnMaintenanceWindowTask.MaintenanceWindowAutomationParametersProperty(\n        document_version="documentVersion",\n        parameters=parameters\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['document_version', 'parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnMaintenanceWindowTask.MaintenanceWindowAutomationParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnMaintenanceWindowTask.MaintenanceWindowLambdaParametersProperty
class CfnMaintenanceWindowTask_MaintenanceWindowLambdaParametersPropertyDef(BaseStruct):
    client_context: typing.Optional[str] = pydantic.Field(None, description="Client-specific information to pass to the AWS Lambda function that you're invoking. You can then use the ``context`` variable to process the client information in your AWS Lambda function.\n")
    payload: typing.Optional[str] = pydantic.Field(None, description='JSON to provide to your AWS Lambda function as input. .. epigraph:: Although ``Type`` is listed as "String" for this property, the payload content must be formatted as a Base64-encoded binary data object. *Length Constraint:* 4096\n')
    qualifier: typing.Optional[str] = pydantic.Field(None, description='An AWS Lambda function version or alias name. If you specify a function version, the action uses the qualified function Amazon Resource Name (ARN) to invoke a specific Lambda function. If you specify an alias name, the action uses the alias ARN to invoke the Lambda function version that the alias points to.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-maintenancewindowtask-maintenancewindowlambdaparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    maintenance_window_lambda_parameters_property = ssm.CfnMaintenanceWindowTask.MaintenanceWindowLambdaParametersProperty(\n        client_context="clientContext",\n        payload="payload",\n        qualifier="qualifier"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['client_context', 'payload', 'qualifier']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnMaintenanceWindowTask.MaintenanceWindowLambdaParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnMaintenanceWindowTask.MaintenanceWindowRunCommandParametersProperty
class CfnMaintenanceWindowTask_MaintenanceWindowRunCommandParametersPropertyDef(BaseStruct):
    cloud_watch_output_config: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnMaintenanceWindowTask_CloudWatchOutputConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configuration options for sending command output to Amazon CloudWatch Logs.\n')
    comment: typing.Optional[str] = pydantic.Field(None, description='Information about the command or commands to run.\n')
    document_hash: typing.Optional[str] = pydantic.Field(None, description='The SHA-256 or SHA-1 hash created by the system when the document was created. SHA-1 hashes have been deprecated.\n')
    document_hash_type: typing.Optional[str] = pydantic.Field(None, description='The SHA-256 or SHA-1 hash type. SHA-1 hashes are deprecated.\n')
    document_version: typing.Optional[str] = pydantic.Field(None, description='The AWS Systems Manager document (SSM document) version to use in the request. You can specify ``$DEFAULT`` , ``$LATEST`` , or a specific version number. If you run commands by using the AWS CLI, then you must escape the first two options by using a backslash. If you specify a version number, then you don\'t need to use the backslash. For example: ``--document-version "\\$DEFAULT"`` ``--document-version "\\$LATEST"`` ``--document-version "3"``\n')
    notification_config: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnMaintenanceWindowTask_NotificationConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configurations for sending notifications about command status changes on a per-managed node basis.\n')
    output_s3_bucket_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Amazon Simple Storage Service (Amazon S3) bucket.\n')
    output_s3_key_prefix: typing.Optional[str] = pydantic.Field(None, description='The S3 bucket subfolder.\n')
    parameters: typing.Any = pydantic.Field(None, description='The parameters for the ``RUN_COMMAND`` task execution. The supported parameters are the same as those for the ``SendCommand`` API call. For more information, see `SendCommand <https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_SendCommand.html>`_ in the *AWS Systems Manager API Reference* .\n')
    service_role_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for maintenance window Run Command tasks.\n')
    timeout_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='If this time is reached and the command hasn\'t already started running, it doesn\'t run.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-maintenancewindowtask-maintenancewindowruncommandparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    # parameters: Any\n\n    maintenance_window_run_command_parameters_property = ssm.CfnMaintenanceWindowTask.MaintenanceWindowRunCommandParametersProperty(\n        cloud_watch_output_config=ssm.CfnMaintenanceWindowTask.CloudWatchOutputConfigProperty(\n            cloud_watch_log_group_name="cloudWatchLogGroupName",\n            cloud_watch_output_enabled=False\n        ),\n        comment="comment",\n        document_hash="documentHash",\n        document_hash_type="documentHashType",\n        document_version="documentVersion",\n        notification_config=ssm.CfnMaintenanceWindowTask.NotificationConfigProperty(\n            notification_arn="notificationArn",\n\n            # the properties below are optional\n            notification_events=["notificationEvents"],\n            notification_type="notificationType"\n        ),\n        output_s3_bucket_name="outputS3BucketName",\n        output_s3_key_prefix="outputS3KeyPrefix",\n        parameters=parameters,\n        service_role_arn="serviceRoleArn",\n        timeout_seconds=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cloud_watch_output_config', 'comment', 'document_hash', 'document_hash_type', 'document_version', 'notification_config', 'output_s3_bucket_name', 'output_s3_key_prefix', 'parameters', 'service_role_arn', 'timeout_seconds']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnMaintenanceWindowTask.MaintenanceWindowRunCommandParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnMaintenanceWindowTask.MaintenanceWindowStepFunctionsParametersProperty
class CfnMaintenanceWindowTask_MaintenanceWindowStepFunctionsParametersPropertyDef(BaseStruct):
    input: typing.Optional[str] = pydantic.Field(None, description='The inputs for the ``STEP_FUNCTIONS`` task.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the ``STEP_FUNCTIONS`` task.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-maintenancewindowtask-maintenancewindowstepfunctionsparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    maintenance_window_step_functions_parameters_property = ssm.CfnMaintenanceWindowTask.MaintenanceWindowStepFunctionsParametersProperty(\n        input="input",\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['input', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnMaintenanceWindowTask.MaintenanceWindowStepFunctionsParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnMaintenanceWindowTask.NotificationConfigProperty
class CfnMaintenanceWindowTask_NotificationConfigPropertyDef(BaseStruct):
    notification_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='An Amazon Resource Name (ARN) for an Amazon Simple Notification Service (Amazon SNS) topic. Run Command pushes notifications about command status changes to this topic.\n')
    notification_events: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The different events that you can receive notifications for. These events include the following: ``All`` (events), ``InProgress`` , ``Success`` , ``TimedOut`` , ``Cancelled`` , ``Failed`` . To learn more about these events, see `Configuring Amazon SNS Notifications for AWS Systems Manager <https://docs.aws.amazon.com/systems-manager/latest/userguide/monitoring-sns-notifications.html>`_ in the *AWS Systems Manager User Guide* .\n')
    notification_type: typing.Optional[str] = pydantic.Field(None, description='The notification type. - ``Command`` : Receive notification when the status of a command changes. - ``Invocation`` : For commands sent to multiple instances, receive notification on a per-instance basis when the status of a command changes.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-maintenancewindowtask-notificationconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    notification_config_property = ssm.CfnMaintenanceWindowTask.NotificationConfigProperty(\n        notification_arn="notificationArn",\n\n        # the properties below are optional\n        notification_events=["notificationEvents"],\n        notification_type="notificationType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['notification_arn', 'notification_events', 'notification_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnMaintenanceWindowTask.NotificationConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnMaintenanceWindowTask.TargetProperty
class CfnMaintenanceWindowTask_TargetPropertyDef(BaseStruct):
    key: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="User-defined criteria for sending commands that target instances that meet the criteria. ``Key`` can be ``InstanceIds`` or ``WindowTargetIds`` . For more information about how to target instances within a maintenance window task, see `About 'register-task-with-maintenance-window' Options and Values <https://docs.aws.amazon.com/systems-manager/latest/userguide/register-tasks-options.html>`_ in the *AWS Systems Manager User Guide* .\n")
    values: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='User-defined criteria that maps to ``Key`` . For example, if you specify ``InstanceIds`` , you can specify ``i-1234567890abcdef0,i-9876543210abcdef0`` to run a command on two EC2 instances. For more information about how to target instances within a maintenance window task, see `About \'register-task-with-maintenance-window\' Options and Values <https://docs.aws.amazon.com/systems-manager/latest/userguide/register-tasks-options.html>`_ in the *AWS Systems Manager User Guide* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-maintenancewindowtask-target.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    target_property = ssm.CfnMaintenanceWindowTask.TargetProperty(\n        key="key",\n        values=["values"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'values']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnMaintenanceWindowTask.TargetProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnMaintenanceWindowTask.TaskInvocationParametersProperty
class CfnMaintenanceWindowTask_TaskInvocationParametersPropertyDef(BaseStruct):
    maintenance_window_automation_parameters: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnMaintenanceWindowTask_MaintenanceWindowAutomationParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The parameters for an ``AUTOMATION`` task type.\n')
    maintenance_window_lambda_parameters: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnMaintenanceWindowTask_MaintenanceWindowLambdaParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The parameters for a ``LAMBDA`` task type.\n')
    maintenance_window_run_command_parameters: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnMaintenanceWindowTask_MaintenanceWindowRunCommandParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The parameters for a ``RUN_COMMAND`` task type.\n')
    maintenance_window_step_functions_parameters: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnMaintenanceWindowTask_MaintenanceWindowStepFunctionsParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The parameters for a ``STEP_FUNCTIONS`` task type.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-maintenancewindowtask-taskinvocationparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    # parameters: Any\n\n    task_invocation_parameters_property = ssm.CfnMaintenanceWindowTask.TaskInvocationParametersProperty(\n        maintenance_window_automation_parameters=ssm.CfnMaintenanceWindowTask.MaintenanceWindowAutomationParametersProperty(\n            document_version="documentVersion",\n            parameters=parameters\n        ),\n        maintenance_window_lambda_parameters=ssm.CfnMaintenanceWindowTask.MaintenanceWindowLambdaParametersProperty(\n            client_context="clientContext",\n            payload="payload",\n            qualifier="qualifier"\n        ),\n        maintenance_window_run_command_parameters=ssm.CfnMaintenanceWindowTask.MaintenanceWindowRunCommandParametersProperty(\n            cloud_watch_output_config=ssm.CfnMaintenanceWindowTask.CloudWatchOutputConfigProperty(\n                cloud_watch_log_group_name="cloudWatchLogGroupName",\n                cloud_watch_output_enabled=False\n            ),\n            comment="comment",\n            document_hash="documentHash",\n            document_hash_type="documentHashType",\n            document_version="documentVersion",\n            notification_config=ssm.CfnMaintenanceWindowTask.NotificationConfigProperty(\n                notification_arn="notificationArn",\n\n                # the properties below are optional\n                notification_events=["notificationEvents"],\n                notification_type="notificationType"\n            ),\n            output_s3_bucket_name="outputS3BucketName",\n            output_s3_key_prefix="outputS3KeyPrefix",\n            parameters=parameters,\n            service_role_arn="serviceRoleArn",\n            timeout_seconds=123\n        ),\n        maintenance_window_step_functions_parameters=ssm.CfnMaintenanceWindowTask.MaintenanceWindowStepFunctionsParametersProperty(\n            input="input",\n            name="name"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['maintenance_window_automation_parameters', 'maintenance_window_lambda_parameters', 'maintenance_window_run_command_parameters', 'maintenance_window_step_functions_parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnMaintenanceWindowTask.TaskInvocationParametersProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnPatchBaseline.PatchFilterGroupProperty
class CfnPatchBaseline_PatchFilterGroupPropertyDef(BaseStruct):
    patch_filters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_ssm.CfnPatchBaseline_PatchFilterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The set of patch filters that make up the group.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-patchbaseline-patchfiltergroup.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    patch_filter_group_property = ssm.CfnPatchBaseline.PatchFilterGroupProperty(\n        patch_filters=[ssm.CfnPatchBaseline.PatchFilterProperty(\n            key="key",\n            values=["values"]\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['patch_filters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnPatchBaseline.PatchFilterGroupProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnPatchBaseline.PatchFilterProperty
class CfnPatchBaseline_PatchFilterPropertyDef(BaseStruct):
    key: typing.Optional[str] = pydantic.Field(None, description='The key for the filter. For information about valid keys, see `PatchFilter <https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html>`_ in the *AWS Systems Manager API Reference* .\n')
    values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The value for the filter key. For information about valid values for each key based on operating system type, see `PatchFilter <https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html>`_ in the *AWS Systems Manager API Reference* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-patchbaseline-patchfilter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    patch_filter_property = ssm.CfnPatchBaseline.PatchFilterProperty(\n        key="key",\n        values=["values"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'values']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnPatchBaseline.PatchFilterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnPatchBaseline.PatchSourceProperty
class CfnPatchBaseline_PatchSourcePropertyDef(BaseStruct):
    configuration: typing.Optional[str] = pydantic.Field(None, description='The value of the yum repo configuration. For example:. ``[main]`` ``name=MyCustomRepository`` ``baseurl=https://my-custom-repository`` ``enabled=1`` .. epigraph:: For information about other options available for your yum repository configuration, see `dnf.conf(5) <https://docs.aws.amazon.com/https://man7.org/linux/man-pages/man5/dnf.conf.5.html>`_ .\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name specified to identify the patch source.\n')
    products: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The specific operating system versions a patch repository applies to, such as "Ubuntu16.04", "AmazonLinux2016.09", "RedhatEnterpriseLinux7.2" or "Suse12.7". For lists of supported product values, see `PatchFilter <https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html>`_ in the *AWS Systems Manager API Reference* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-patchbaseline-patchsource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    patch_source_property = ssm.CfnPatchBaseline.PatchSourceProperty(\n        configuration="configuration",\n        name="name",\n        products=["products"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['configuration', 'name', 'products']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnPatchBaseline.PatchSourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnPatchBaseline.RuleGroupProperty
class CfnPatchBaseline_RuleGroupPropertyDef(BaseStruct):
    patch_rules: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_ssm.CfnPatchBaseline_RulePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The rules that make up the rule group.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-patchbaseline-rulegroup.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    rule_group_property = ssm.CfnPatchBaseline.RuleGroupProperty(\n        patch_rules=[ssm.CfnPatchBaseline.RuleProperty(\n            approve_after_days=123,\n            approve_until_date="approveUntilDate",\n            compliance_level="complianceLevel",\n            enable_non_security=False,\n            patch_filter_group=ssm.CfnPatchBaseline.PatchFilterGroupProperty(\n                patch_filters=[ssm.CfnPatchBaseline.PatchFilterProperty(\n                    key="key",\n                    values=["values"]\n                )]\n            )\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['patch_rules']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnPatchBaseline.RuleGroupProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnPatchBaseline.RuleProperty
class CfnPatchBaseline_RulePropertyDef(BaseStruct):
    approve_after_days: typing.Union[int, float, None] = pydantic.Field(None, description='The number of days after the release date of each patch matched by the rule that the patch is marked as approved in the patch baseline. For example, a value of ``7`` means that patches are approved seven days after they are released. You must specify a value for ``ApproveAfterDays`` . Exception: Not supported on Debian Server or Ubuntu Server.\n')
    approve_until_date: typing.Optional[str] = pydantic.Field(None, description='The cutoff date for auto approval of released patches. Any patches released on or before this date are installed automatically. Not supported on Debian Server or Ubuntu Server. Enter dates in the format ``YYYY-MM-DD`` . For example, ``2021-12-31`` .\n')
    compliance_level: typing.Optional[str] = pydantic.Field(None, description='A compliance severity level for all approved patches in a patch baseline. Valid compliance severity levels include the following: ``UNSPECIFIED`` , ``CRITICAL`` , ``HIGH`` , ``MEDIUM`` , ``LOW`` , and ``INFORMATIONAL`` .\n')
    enable_non_security: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='For managed nodes identified by the approval rule filters, enables a patch baseline to apply non-security updates available in the specified repository. The default value is ``false`` . Applies to Linux managed nodes only.\n')
    patch_filter_group: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnPatchBaseline_PatchFilterGroupPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The patch filter group that defines the criteria for the rule.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-patchbaseline-rule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    rule_property = ssm.CfnPatchBaseline.RuleProperty(\n        approve_after_days=123,\n        approve_until_date="approveUntilDate",\n        compliance_level="complianceLevel",\n        enable_non_security=False,\n        patch_filter_group=ssm.CfnPatchBaseline.PatchFilterGroupProperty(\n            patch_filters=[ssm.CfnPatchBaseline.PatchFilterProperty(\n                key="key",\n                values=["values"]\n            )]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['approve_after_days', 'approve_until_date', 'compliance_level', 'enable_non_security', 'patch_filter_group']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnPatchBaseline.RuleProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnResourceDataSync.AwsOrganizationsSourceProperty
class CfnResourceDataSync_AwsOrganizationsSourcePropertyDef(BaseStruct):
    organization_source_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='If an AWS organization is present, this is either ``OrganizationalUnits`` or ``EntireOrganization`` . For ``OrganizationalUnits`` , the data is aggregated from a set of organization units. For ``EntireOrganization`` , the data is aggregated from the entire AWS organization.\n')
    organizational_units: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The AWS Organizations organization units included in the sync.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-resourcedatasync-awsorganizationssource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    aws_organizations_source_property = ssm.CfnResourceDataSync.AwsOrganizationsSourceProperty(\n        organization_source_type="organizationSourceType",\n\n        # the properties below are optional\n        organizational_units=["organizationalUnits"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['organization_source_type', 'organizational_units']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnResourceDataSync.AwsOrganizationsSourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnResourceDataSync.S3DestinationProperty
class CfnResourceDataSync_S3DestinationPropertyDef(BaseStruct):
    bucket_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the S3 bucket where the aggregated data is stored.\n')
    bucket_region: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The AWS Region with the S3 bucket targeted by the resource data sync.\n')
    sync_format: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A supported sync format. The following format is currently supported: JsonSerDe\n')
    bucket_prefix: typing.Optional[str] = pydantic.Field(None, description='An Amazon S3 prefix for the bucket.\n')
    kms_key_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of an encryption key for a destination in Amazon S3. Must belong to the same Region as the destination S3 bucket.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-resourcedatasync-s3destination.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    s3_destination_property = ssm.CfnResourceDataSync.S3DestinationProperty(\n        bucket_name="bucketName",\n        bucket_region="bucketRegion",\n        sync_format="syncFormat",\n\n        # the properties below are optional\n        bucket_prefix="bucketPrefix",\n        kms_key_arn="kmsKeyArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket_name', 'bucket_region', 'sync_format', 'bucket_prefix', 'kms_key_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnResourceDataSync.S3DestinationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnResourceDataSync.SyncSourceProperty
class CfnResourceDataSync_SyncSourcePropertyDef(BaseStruct):
    source_regions: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ``SyncSource`` AWS Regions included in the resource data sync.\n')
    source_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of data source for the resource data sync. ``SourceType`` is either ``AwsOrganizations`` (if an organization is present in AWS Organizations ) or ``SingleAccountMultiRegions`` .\n')
    aws_organizations_source: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnResourceDataSync_AwsOrganizationsSourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about the AwsOrganizationsSource resource data sync source. A sync source of this type can synchronize data from AWS Organizations .\n')
    include_future_regions: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Whether to automatically synchronize and aggregate data from new AWS Regions when those Regions come online.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-resourcedatasync-syncsource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    sync_source_property = ssm.CfnResourceDataSync.SyncSourceProperty(\n        source_regions=["sourceRegions"],\n        source_type="sourceType",\n\n        # the properties below are optional\n        aws_organizations_source=ssm.CfnResourceDataSync.AwsOrganizationsSourceProperty(\n            organization_source_type="organizationSourceType",\n\n            # the properties below are optional\n            organizational_units=["organizationalUnits"]\n        ),\n        include_future_regions=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['source_regions', 'source_type', 'aws_organizations_source', 'include_future_regions']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnResourceDataSync.SyncSourceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CommonStringParameterAttributes
class CommonStringParameterAttributesDef(BaseStruct):
    parameter_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the parameter store value. This value can be a token or a concrete string. If it is a concrete string and includes "/" it must also be prefixed with a "/" (fully-qualified).\n')
    simple_name: typing.Optional[bool] = pydantic.Field(None, description='Indicates if the parameter name is a simple name (i.e. does not include "/" separators). This is required only if ``parameterName`` is a token, which means we are unable to detect if the name is simple or "path-like" for the purpose of rendering SSM parameter ARNs. If ``parameterName`` is not specified, ``simpleName`` must be ``true`` (or undefined) since the name generated by AWS CloudFormation is always a simple name. Default: - auto-detect based on ``parameterName``\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    common_string_parameter_attributes = ssm.CommonStringParameterAttributes(\n        parameter_name="parameterName",\n\n        # the properties below are optional\n        simple_name=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['parameter_name', 'simple_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CommonStringParameterAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.ListParameterAttributes
class ListParameterAttributesDef(BaseStruct):
    parameter_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the parameter store value. This value can be a token or a concrete string. If it is a concrete string and includes "/" it must also be prefixed with a "/" (fully-qualified).\n')
    simple_name: typing.Optional[bool] = pydantic.Field(None, description='Indicates if the parameter name is a simple name (i.e. does not include "/" separators). This is required only if ``parameterName`` is a token, which means we are unable to detect if the name is simple or "path-like" for the purpose of rendering SSM parameter ARNs. If ``parameterName`` is not specified, ``simpleName`` must be ``true`` (or undefined) since the name generated by AWS CloudFormation is always a simple name. Default: - auto-detect based on ``parameterName``\n')
    element_type: typing.Optional[aws_cdk.aws_ssm.ParameterValueType] = pydantic.Field(None, description='The type of the string list parameter value. Using specific types can be helpful in catching invalid values at the start of creating or updating a stack. CloudFormation validates the values against existing values in the account. Note - if you want to allow values from different AWS accounts, use ParameterValueType.STRING Default: ParameterValueType.STRING\n')
    version: typing.Union[int, float, None] = pydantic.Field(None, description='The version number of the value you wish to retrieve. Default: The latest version will be retrieved.\n\n:see: ParameterType\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    list_parameter_attributes = ssm.ListParameterAttributes(\n        parameter_name="parameterName",\n\n        # the properties below are optional\n        element_type=ssm.ParameterValueType.STRING,\n        simple_name=False,\n        version=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['parameter_name', 'simple_name', 'element_type', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.ListParameterAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.ParameterOptions
class ParameterOptionsDef(BaseStruct):
    allowed_pattern: typing.Optional[str] = pydantic.Field(None, description='A regular expression used to validate the parameter value. For example, for String types with values restricted to numbers, you can specify the following: ``^\\d+$`` Default: no validation is performed\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Information about the parameter that you want to add to the system. Default: none\n')
    parameter_name: typing.Optional[str] = pydantic.Field(None, description='The name of the parameter. Default: - a name will be generated by CloudFormation\n')
    simple_name: typing.Optional[bool] = pydantic.Field(None, description='Indicates if the parameter name is a simple name (i.e. does not include "/" separators). This is required only if ``parameterName`` is a token, which means we are unable to detect if the name is simple or "path-like" for the purpose of rendering SSM parameter ARNs. If ``parameterName`` is not specified, ``simpleName`` must be ``true`` (or undefined) since the name generated by AWS CloudFormation is always a simple name. Default: - auto-detect based on ``parameterName``\n')
    tier: typing.Optional[aws_cdk.aws_ssm.ParameterTier] = pydantic.Field(None, description='The tier of the string parameter. Default: - undefined\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    parameter_options = ssm.ParameterOptions(\n        allowed_pattern="allowedPattern",\n        description="description",\n        parameter_name="parameterName",\n        simple_name=False,\n        tier=ssm.ParameterTier.ADVANCED\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allowed_pattern', 'description', 'parameter_name', 'simple_name', 'tier']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.ParameterOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.SecureStringParameterAttributes
class SecureStringParameterAttributesDef(BaseStruct):
    parameter_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the parameter store value. This value can be a token or a concrete string. If it is a concrete string and includes "/" it must also be prefixed with a "/" (fully-qualified).\n')
    simple_name: typing.Optional[bool] = pydantic.Field(None, description='Indicates if the parameter name is a simple name (i.e. does not include "/" separators). This is required only if ``parameterName`` is a token, which means we are unable to detect if the name is simple or "path-like" for the purpose of rendering SSM parameter ARNs. If ``parameterName`` is not specified, ``simpleName`` must be ``true`` (or undefined) since the name generated by AWS CloudFormation is always a simple name. Default: - auto-detect based on ``parameterName``\n')
    encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The encryption key that is used to encrypt this parameter. Default: - default master key\n')
    version: typing.Union[int, float, None] = pydantic.Field(None, description='The version number of the value you wish to retrieve. Default: - AWS CloudFormation uses the latest version of the parameter\n\n:exampleMetadata: infused\n\nExample::\n\n    parameter_version = Token.as_number({"Ref": "MyParameter"})\n\n    # Retrieve the latest value of the non-secret parameter\n    # with name "/My/String/Parameter".\n    string_value = ssm.StringParameter.from_string_parameter_attributes(self, "MyValue",\n        parameter_name="/My/Public/Parameter"\n    ).string_value\n    string_value_version_from_token = ssm.StringParameter.from_string_parameter_attributes(self, "MyValueVersionFromToken",\n        parameter_name="/My/Public/Parameter",\n        # parameter version from token\n        version=parameter_version\n    ).string_value\n\n    # Retrieve a specific version of the secret (SecureString) parameter.\n    # \'version\' is always required.\n    secret_value = ssm.StringParameter.from_secure_string_parameter_attributes(self, "MySecureValue",\n        parameter_name="/My/Secret/Parameter",\n        version=5\n    )\n    secret_value_version_from_token = ssm.StringParameter.from_secure_string_parameter_attributes(self, "MySecureValueVersionFromToken",\n        parameter_name="/My/Secret/Parameter",\n        # parameter version from token\n        version=parameter_version\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['parameter_name', 'simple_name', 'encryption_key', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.SecureStringParameterAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.StringListParameterProps
class StringListParameterPropsDef(BaseStruct):
    allowed_pattern: typing.Optional[str] = pydantic.Field(None, description='A regular expression used to validate the parameter value. For example, for String types with values restricted to numbers, you can specify the following: ``^\\d+$`` Default: no validation is performed\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Information about the parameter that you want to add to the system. Default: none\n')
    parameter_name: typing.Optional[str] = pydantic.Field(None, description='The name of the parameter. Default: - a name will be generated by CloudFormation\n')
    simple_name: typing.Optional[bool] = pydantic.Field(None, description='Indicates if the parameter name is a simple name (i.e. does not include "/" separators). This is required only if ``parameterName`` is a token, which means we are unable to detect if the name is simple or "path-like" for the purpose of rendering SSM parameter ARNs. If ``parameterName`` is not specified, ``simpleName`` must be ``true`` (or undefined) since the name generated by AWS CloudFormation is always a simple name. Default: - auto-detect based on ``parameterName``\n')
    tier: typing.Optional[aws_cdk.aws_ssm.ParameterTier] = pydantic.Field(None, description='The tier of the string parameter. Default: - undefined\n')
    string_list_value: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The values of the parameter. It may not reference another parameter and ``{{}}`` cannot be used in the value.\n\n:exampleMetadata: infused\n\nExample::\n\n    # Grant read access to some Role\n    # role: iam.IRole\n    # Create a new SSM Parameter holding a String\n    param = ssm.StringParameter(self, "StringParameter",\n        # description: \'Some user-friendly description\',\n        # name: \'ParameterName\',\n        string_value="Initial parameter value"\n    )\n    param.grant_read(role)\n\n    # Create a new SSM Parameter holding a StringList\n    list_parameter = ssm.StringListParameter(self, "StringListParameter",\n        # description: \'Some user-friendly description\',\n        # name: \'ParameterName\',\n        string_list_value=["Initial parameter value A", "Initial parameter value B"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allowed_pattern', 'description', 'parameter_name', 'simple_name', 'tier', 'string_list_value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.StringListParameterProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.StringParameterAttributes
class StringParameterAttributesDef(BaseStruct):
    parameter_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the parameter store value. This value can be a token or a concrete string. If it is a concrete string and includes "/" it must also be prefixed with a "/" (fully-qualified).\n')
    simple_name: typing.Optional[bool] = pydantic.Field(None, description='Indicates if the parameter name is a simple name (i.e. does not include "/" separators). This is required only if ``parameterName`` is a token, which means we are unable to detect if the name is simple or "path-like" for the purpose of rendering SSM parameter ARNs. If ``parameterName`` is not specified, ``simpleName`` must be ``true`` (or undefined) since the name generated by AWS CloudFormation is always a simple name. Default: - auto-detect based on ``parameterName``\n')
    force_dynamic_reference: typing.Optional[bool] = pydantic.Field(None, description='Use a dynamic reference as the representation in CloudFormation template level. By default, CDK tries to deduce an appropriate representation based on the parameter value (a CfnParameter or a dynamic reference). Use this flag to override the representation when it does not work. Default: false\n')
    type: typing.Optional[aws_cdk.aws_ssm.ParameterType] = pydantic.Field(None, description='(deprecated) The type of the string parameter. Default: ParameterType.STRING\n')
    value_type: typing.Optional[aws_cdk.aws_ssm.ParameterValueType] = pydantic.Field(None, description='The type of the string parameter value. Using specific types can be helpful in catching invalid values at the start of creating or updating a stack. CloudFormation validates the values against existing values in the account. Note - if you want to allow values from different AWS accounts, use ParameterValueType.STRING Default: ParameterValueType.STRING\n')
    version: typing.Union[int, float, None] = pydantic.Field(None, description='The version number of the value you wish to retrieve. Default: The latest version will be retrieved.\n\n:see: ParameterType\n:exampleMetadata: infused\n\nExample::\n\n    parameter_version = Token.as_number({"Ref": "MyParameter"})\n\n    # Retrieve the latest value of the non-secret parameter\n    # with name "/My/String/Parameter".\n    string_value = ssm.StringParameter.from_string_parameter_attributes(self, "MyValue",\n        parameter_name="/My/Public/Parameter"\n    ).string_value\n    string_value_version_from_token = ssm.StringParameter.from_string_parameter_attributes(self, "MyValueVersionFromToken",\n        parameter_name="/My/Public/Parameter",\n        # parameter version from token\n        version=parameter_version\n    ).string_value\n\n    # Retrieve a specific version of the secret (SecureString) parameter.\n    # \'version\' is always required.\n    secret_value = ssm.StringParameter.from_secure_string_parameter_attributes(self, "MySecureValue",\n        parameter_name="/My/Secret/Parameter",\n        version=5\n    )\n    secret_value_version_from_token = ssm.StringParameter.from_secure_string_parameter_attributes(self, "MySecureValueVersionFromToken",\n        parameter_name="/My/Secret/Parameter",\n        # parameter version from token\n        version=parameter_version\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['parameter_name', 'simple_name', 'force_dynamic_reference', 'type', 'value_type', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.StringParameterAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.StringParameterProps
class StringParameterPropsDef(BaseStruct):
    allowed_pattern: typing.Optional[str] = pydantic.Field(None, description='A regular expression used to validate the parameter value. For example, for String types with values restricted to numbers, you can specify the following: ``^\\d+$`` Default: no validation is performed\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Information about the parameter that you want to add to the system. Default: none\n')
    parameter_name: typing.Optional[str] = pydantic.Field(None, description='The name of the parameter. Default: - a name will be generated by CloudFormation\n')
    simple_name: typing.Optional[bool] = pydantic.Field(None, description='Indicates if the parameter name is a simple name (i.e. does not include "/" separators). This is required only if ``parameterName`` is a token, which means we are unable to detect if the name is simple or "path-like" for the purpose of rendering SSM parameter ARNs. If ``parameterName`` is not specified, ``simpleName`` must be ``true`` (or undefined) since the name generated by AWS CloudFormation is always a simple name. Default: - auto-detect based on ``parameterName``\n')
    tier: typing.Optional[aws_cdk.aws_ssm.ParameterTier] = pydantic.Field(None, description='The tier of the string parameter. Default: - undefined\n')
    string_value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The value of the parameter. It may not reference another parameter and ``{{}}`` cannot be used in the value.\n')
    data_type: typing.Optional[aws_cdk.aws_ssm.ParameterDataType] = pydantic.Field(None, description='The data type of the parameter, such as ``text`` or ``aws:ec2:image``. Default: ParameterDataType.TEXT\n')
    type: typing.Optional[aws_cdk.aws_ssm.ParameterType] = pydantic.Field(None, description='(deprecated) The type of the string parameter. Default: ParameterType.STRING\n\n:exampleMetadata: infused\n\nExample::\n\n    # Grant read access to some Role\n    # role: iam.IRole\n    # Create a new SSM Parameter holding a String\n    param = ssm.StringParameter(self, "StringParameter",\n        # description: \'Some user-friendly description\',\n        # name: \'ParameterName\',\n        string_value="Initial parameter value"\n    )\n    param.grant_read(role)\n\n    # Create a new SSM Parameter holding a StringList\n    list_parameter = ssm.StringListParameter(self, "StringListParameter",\n        # description: \'Some user-friendly description\',\n        # name: \'ParameterName\',\n        string_list_value=["Initial parameter value A", "Initial parameter value B"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allowed_pattern', 'description', 'parameter_name', 'simple_name', 'tier', 'string_value', 'data_type', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.StringParameterProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.ParameterDataType
# skipping emum

#  autogenerated from aws_cdk.aws_ssm.ParameterTier
# skipping emum

#  autogenerated from aws_cdk.aws_ssm.ParameterType
# skipping emum

#  autogenerated from aws_cdk.aws_ssm.ParameterValueType
# skipping emum

#  autogenerated from aws_cdk.aws_ssm.IParameter
#  skipping Interface

#  autogenerated from aws_cdk.aws_ssm.IStringListParameter
#  skipping Interface

#  autogenerated from aws_cdk.aws_ssm.IStringParameter
#  skipping Interface

#  autogenerated from aws_cdk.aws_ssm.CfnAssociation
class CfnAssociationDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the SSM document that contains the configuration information for the instance. You can specify ``Command`` or ``Automation`` documents. The documents can be AWS -predefined documents, documents you created, or a document that is shared with you from another account. For SSM documents that are shared with you from other AWS accounts , you must specify the complete SSM document ARN, in the following format: ``arn:partition:ssm:region:account-id:document/document-name`` For example: ``arn:aws:ssm:us-east-2:12345678912:document/My-Shared-Document`` For AWS -predefined documents and SSM documents you created in your account, you only need to specify the document name. For example, ``AWS -ApplyPatchBaseline`` or ``My-Document`` .\n')
    apply_only_at_cron_interval: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="By default, when you create a new association, the system runs it immediately after it is created and then according to the schedule you specified. Specify this option if you don't want an association to run immediately after you create it. This parameter is not supported for rate expressions.\n")
    association_name: typing.Optional[str] = pydantic.Field(None, description='Specify a descriptive name for the association.\n')
    automation_target_parameter_name: typing.Optional[str] = pydantic.Field(None, description='Choose the parameter that will define how your automation will branch out. This target is required for associations that use an Automation runbook and target resources by using rate controls. Automation is a capability of AWS Systems Manager .\n')
    calendar_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The names or Amazon Resource Names (ARNs) of the Change Calendar type documents your associations are gated under. The associations only run when that Change Calendar is open. For more information, see `AWS Systems Manager Change Calendar <https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar>`_ .\n')
    compliance_severity: typing.Optional[str] = pydantic.Field(None, description='The severity level that is assigned to the association.\n')
    document_version: typing.Optional[str] = pydantic.Field(None, description='The version of the SSM document to associate with the target. .. epigraph:: Note the following important information. - State Manager doesn\'t support running associations that use a new version of a document if that document is shared from another account. State Manager always runs the ``default`` version of a document if shared from another account, even though the Systems Manager console shows that a new version was processed. If you want to run an association using a new version of a document shared form another account, you must set the document version to ``default`` . - ``DocumentVersion`` is not valid for documents owned by AWS , such as ``AWS-RunPatchBaseline`` or ``AWS-UpdateSSMAgent`` . If you specify ``DocumentVersion`` for an AWS document, the system returns the following error: "Error occurred during operation \'CreateAssociation\'." (RequestToken: , HandlerErrorCode: GeneralServiceException).\n')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the instance that the SSM document is associated with. You must specify the ``InstanceId`` or ``Targets`` property. .. epigraph:: ``InstanceId`` has been deprecated. To specify an instance ID for an association, use the ``Targets`` parameter. If you use the parameter ``InstanceId`` , you cannot use the parameters ``AssociationName`` , ``DocumentVersion`` , ``MaxErrors`` , ``MaxConcurrency`` , ``OutputLocation`` , or ``ScheduleExpression`` . To use these parameters, you must use the ``Targets`` parameter.\n')
    max_concurrency: typing.Optional[str] = pydantic.Field(None, description='The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time. If a new managed node starts and attempts to run an association while Systems Manager is running ``MaxConcurrency`` associations, the association is allowed to run. During the next association interval, the new managed node will process its association within the limit specified for ``MaxConcurrency`` .\n')
    max_errors: typing.Optional[str] = pydantic.Field(None, description="The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 managed nodes and set ``MaxError`` to 10%, then the system stops sending the request when the sixth error is received. Executions that are already running an association when ``MaxErrors`` is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set ``MaxConcurrency`` to 1 so that executions proceed one at a time.\n")
    output_location: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnAssociation_InstanceAssociationOutputLocationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An Amazon Simple Storage Service (Amazon S3) bucket where you want to store the output details of the request.\n')
    parameters: typing.Any = pydantic.Field(None, description='Parameter values that the SSM document uses at runtime.\n')
    schedule_expression: typing.Optional[str] = pydantic.Field(None, description='A cron expression that specifies a schedule when the association runs. The schedule runs in Coordinated Universal Time (UTC).\n')
    schedule_offset: typing.Union[int, float, None] = pydantic.Field(None, description='Number of days to wait after the scheduled day to run an association.\n')
    sync_compliance: typing.Optional[str] = pydantic.Field(None, description="The mode for generating association compliance. You can specify ``AUTO`` or ``MANUAL`` . In ``AUTO`` mode, the system uses the status of the association execution to determine the compliance status. If the association execution runs successfully, then the association is ``COMPLIANT`` . If the association execution doesn't run successfully, the association is ``NON-COMPLIANT`` . In ``MANUAL`` mode, you must specify the ``AssociationId`` as a parameter for the PutComplianceItems API action. In this case, compliance data is not managed by State Manager. It is managed by your direct call to the PutComplianceItems API action. By default, all associations use ``AUTO`` mode.\n")
    targets: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_ssm.CfnAssociation_TargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The targets for the association. You must specify the ``InstanceId`` or ``Targets`` property. You can target all instances in an AWS account by specifying the ``InstanceIds`` key with a value of ``*`` . To view a JSON and a YAML example that targets all instances, see "Create an association for all managed instances in an AWS account " on the Examples page.\n')
    wait_for_success_timeout_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The number of seconds the service should wait for the association status to show "Success" before proceeding with the stack execution. If the association status doesn\'t show "Success" after the specified number of seconds, then stack creation fails. .. epigraph:: When you specify a value for the ``WaitForSuccessTimeoutSeconds`` , `drift detection <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html>`_ for your AWS CloudFormation stacks configuration might yield inaccurate results. If drift detection is important in your scenario, we recommend that you dont include ``WaitForSuccessTimeoutSeconds`` in your template.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'apply_only_at_cron_interval', 'association_name', 'automation_target_parameter_name', 'calendar_names', 'compliance_severity', 'document_version', 'instance_id', 'max_concurrency', 'max_errors', 'output_location', 'parameters', 'schedule_expression', 'schedule_offset', 'sync_compliance', 'targets', 'wait_for_success_timeout_seconds']
    _method_names: typing.ClassVar[list[str]] = ['InstanceAssociationOutputLocationProperty', 'S3OutputLocationProperty', 'TargetProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ssm.CfnAssociationDefConfig] = pydantic.Field(None)


class CfnAssociationDefConfig(pydantic.BaseModel):
    InstanceAssociationOutputLocationProperty: typing.Optional[list[models.aws_ssm.CfnAssociationDefInstanceassociationoutputlocationpropertyParams]] = pydantic.Field(None, description='')
    S3OutputLocationProperty: typing.Optional[list[models.aws_ssm.CfnAssociationDefS3OutputlocationpropertyParams]] = pydantic.Field(None, description='')
    TargetProperty: typing.Optional[list[models.aws_ssm.CfnAssociationDefTargetpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_ssm.CfnAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_ssm.CfnAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_ssm.CfnAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_ssm.CfnAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_ssm.CfnAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_ssm.CfnAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_ssm.CfnAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_ssm.CfnAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_ssm.CfnAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_ssm.CfnAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_ssm.CfnAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_ssm.CfnAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_ssm.CfnAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnAssociationDefInstanceassociationoutputlocationpropertyParams(pydantic.BaseModel):
    s3_location: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnAssociation_S3OutputLocationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnAssociationDefS3OutputlocationpropertyParams(pydantic.BaseModel):
    output_s3_bucket_name: typing.Optional[str] = pydantic.Field(None, description='')
    output_s3_key_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    output_s3_region: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAssociationDefTargetpropertyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='')
    values: typing.Sequence[str] = pydantic.Field(..., description='')
    ...

class CfnAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ssm.CfnDocument
class CfnDocumentDef(BaseCfnResource):
    content: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The content for the new SSM document in JSON or YAML. For more information about the schemas for SSM document content, see `SSM document schema features and examples <https://docs.aws.amazon.com/systems-manager/latest/userguide/document-schemas-features.html>`_ in the *AWS Systems Manager User Guide* . .. epigraph:: This parameter also supports ``String`` data types.\n')
    attachments: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_ssm.CfnDocument_AttachmentsSourcePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of key-value pairs that describe attachments to a version of a document.\n')
    document_format: typing.Optional[str] = pydantic.Field(None, description='Specify the document format for the request. JSON is the default format. Default: - "JSON"\n')
    document_type: typing.Optional[str] = pydantic.Field(None, description='The type of document to create.\n')
    name: typing.Optional[str] = pydantic.Field(None, description="A name for the SSM document. .. epigraph:: You can't use the following strings as document name prefixes. These are reserved by AWS for use as document name prefixes: - ``aws`` - ``amazon`` - ``amzn``\n")
    requires: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_ssm.CfnDocument_DocumentRequiresPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of SSM documents required by a document. This parameter is used exclusively by AWS AppConfig . When a user creates an AWS AppConfig configuration in an SSM document, the user must also specify a required document for validation purposes. In this case, an ``ApplicationConfiguration`` document requires an ``ApplicationConfigurationSchema`` document for validation purposes. For more information, see `What is AWS AppConfig ? <https://docs.aws.amazon.com/appconfig/latest/userguide/what-is-appconfig.html>`_ in the *AWS AppConfig User Guide* .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='AWS CloudFormation resource tags to apply to the document. Use tags to help you identify and categorize resources.\n')
    target_type: typing.Optional[str] = pydantic.Field(None, description="Specify a target type to define the kinds of resources the document can run on. For example, to run a document on EC2 instances, specify the following value: ``/AWS::EC2::Instance`` . If you specify a value of '/' the document can run on all types of resources. If you don't specify a value, the document can't run on any resources. For a list of valid resource types, see `AWS resource and property types reference <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html>`_ in the *AWS CloudFormation User Guide* .\n")
    update_method: typing.Optional[str] = pydantic.Field(None, description='If the document resource you specify in your template already exists, this parameter determines whether a new version of the existing document is created, or the existing document is replaced. ``Replace`` is the default method. If you specify ``NewVersion`` for the ``UpdateMethod`` parameter, and the ``Name`` of the document does not match an existing resource, a new document is created. When you specify ``NewVersion`` , the default version of the document is changed to the newly created version. Default: - "Replace"\n')
    version_name: typing.Optional[str] = pydantic.Field(None, description="An optional field specifying the version of the artifact you are creating with the document. For example, ``Release12.1`` . This value is unique across all versions of a document, and can't be changed.")
    _init_params: typing.ClassVar[list[str]] = ['content', 'attachments', 'document_format', 'document_type', 'name', 'requires', 'tags', 'target_type', 'update_method', 'version_name']
    _method_names: typing.ClassVar[list[str]] = ['AttachmentsSourceProperty', 'DocumentRequiresProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnDocument'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ssm.CfnDocumentDefConfig] = pydantic.Field(None)


class CfnDocumentDefConfig(pydantic.BaseModel):
    AttachmentsSourceProperty: typing.Optional[list[models.aws_ssm.CfnDocumentDefAttachmentssourcepropertyParams]] = pydantic.Field(None, description='')
    DocumentRequiresProperty: typing.Optional[list[models.aws_ssm.CfnDocumentDefDocumentrequirespropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_ssm.CfnDocumentDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_ssm.CfnDocumentDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_ssm.CfnDocumentDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_ssm.CfnDocumentDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_ssm.CfnDocumentDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_ssm.CfnDocumentDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_ssm.CfnDocumentDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_ssm.CfnDocumentDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_ssm.CfnDocumentDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_ssm.CfnDocumentDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_ssm.CfnDocumentDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_ssm.CfnDocumentDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_ssm.CfnDocumentDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDocumentDefAttachmentssourcepropertyParams(pydantic.BaseModel):
    key: typing.Optional[str] = pydantic.Field(None, description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnDocumentDefDocumentrequirespropertyParams(pydantic.BaseModel):
    name: typing.Optional[str] = pydantic.Field(None, description='')
    version: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDocumentDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDocumentDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDocumentDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDocumentDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDocumentDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDocumentDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDocumentDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDocumentDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDocumentDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDocumentDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDocumentDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDocumentDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDocumentDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDocumentDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ssm.CfnMaintenanceWindow
class CfnMaintenanceWindowDef(BaseCfnResource):
    allow_unassociated_targets: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='Enables a maintenance window task to run on managed instances, even if you have not registered those instances as targets. If enabled, then you must specify the unregistered instances (by instance ID) when you register a task with the maintenance window.\n')
    cutoff: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The number of hours before the end of the maintenance window that AWS Systems Manager stops scheduling new tasks for execution.\n')
    duration: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The duration of the maintenance window in hours.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the maintenance window.\n')
    schedule: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The schedule of the maintenance window in the form of a cron or rate expression.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the maintenance window.\n')
    end_date: typing.Optional[str] = pydantic.Field(None, description='The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become inactive.\n')
    schedule_offset: typing.Union[int, float, None] = pydantic.Field(None, description='The number of days to wait to run a maintenance window after the scheduled cron expression date and time.\n')
    schedule_timezone: typing.Optional[str] = pydantic.Field(None, description='The time zone that the scheduled maintenance window executions are based on, in Internet Assigned Numbers Authority (IANA) format.\n')
    start_date: typing.Optional[str] = pydantic.Field(None, description='The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become active. StartDate allows you to delay activation of the Maintenance Window until the specified future date.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Optional metadata that you assign to a resource in the form of an arbitrary set of tags (key-value pairs). Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a maintenance window to identify the type of tasks it will run, the types of targets, and the environment it will run in.')
    _init_params: typing.ClassVar[list[str]] = ['allow_unassociated_targets', 'cutoff', 'duration', 'name', 'schedule', 'description', 'end_date', 'schedule_offset', 'schedule_timezone', 'start_date', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnMaintenanceWindow'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ssm.CfnMaintenanceWindowDefConfig] = pydantic.Field(None)


class CfnMaintenanceWindowDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnMaintenanceWindowDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnMaintenanceWindowDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMaintenanceWindowDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnMaintenanceWindowDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMaintenanceWindowDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnMaintenanceWindowDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnMaintenanceWindowDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnMaintenanceWindowDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnMaintenanceWindowDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnMaintenanceWindowDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMaintenanceWindowDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnMaintenanceWindowDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnMaintenanceWindowDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMaintenanceWindowDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ssm.CfnMaintenanceWindowTarget
class CfnMaintenanceWindowTargetDef(BaseCfnResource):
    resource_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of target that is being registered with the maintenance window.\n')
    targets: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_ssm.CfnMaintenanceWindowTarget_TargetsPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The targets to register with the maintenance window. In other words, the instances to run commands on when the maintenance window runs. You must specify targets by using the ``WindowTargetIds`` parameter.\n')
    window_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the maintenance window to register the target with.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the target.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name for the maintenance window target.\n')
    owner_information: typing.Optional[str] = pydantic.Field(None, description='A user-provided value that will be included in any Amazon CloudWatch Events events that are raised while running tasks for these targets in this maintenance window.')
    _init_params: typing.ClassVar[list[str]] = ['resource_type', 'targets', 'window_id', 'description', 'name', 'owner_information']
    _method_names: typing.ClassVar[list[str]] = ['TargetsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnMaintenanceWindowTarget'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ssm.CfnMaintenanceWindowTargetDefConfig] = pydantic.Field(None)


class CfnMaintenanceWindowTargetDefConfig(pydantic.BaseModel):
    TargetsProperty: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTargetDefTargetspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTargetDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTargetDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTargetDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTargetDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTargetDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTargetDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTargetDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTargetDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTargetDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTargetDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTargetDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTargetDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTargetDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnMaintenanceWindowTargetDefTargetspropertyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='')
    values: typing.Sequence[str] = pydantic.Field(..., description='')
    ...

class CfnMaintenanceWindowTargetDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnMaintenanceWindowTargetDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMaintenanceWindowTargetDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnMaintenanceWindowTargetDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMaintenanceWindowTargetDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnMaintenanceWindowTargetDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnMaintenanceWindowTargetDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnMaintenanceWindowTargetDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnMaintenanceWindowTargetDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnMaintenanceWindowTargetDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMaintenanceWindowTargetDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnMaintenanceWindowTargetDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnMaintenanceWindowTargetDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMaintenanceWindowTargetDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ssm.CfnMaintenanceWindowTask
class CfnMaintenanceWindowTaskDef(BaseCfnResource):
    priority: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The priority of the task in the maintenance window. The lower the number, the higher the priority. Tasks that have the same priority are scheduled in parallel.\n')
    task_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The resource that the task uses during execution. For ``RUN_COMMAND`` and ``AUTOMATION`` task types, ``TaskArn`` is the SSM document name or Amazon Resource Name (ARN). For ``LAMBDA`` tasks, ``TaskArn`` is the function name or ARN. For ``STEP_FUNCTIONS`` tasks, ``TaskArn`` is the state machine ARN.\n')
    task_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of task. Valid values: ``RUN_COMMAND`` , ``AUTOMATION`` , ``LAMBDA`` , ``STEP_FUNCTIONS`` .\n')
    window_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the maintenance window where the task is registered.\n')
    cutoff_behavior: typing.Optional[str] = pydantic.Field(None, description='The specification for whether tasks should continue to run after the cutoff time specified in the maintenance windows is reached.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the task.\n')
    logging_info: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnMaintenanceWindowTask_LoggingInfoPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about an Amazon S3 bucket to write Run Command task-level logs to. .. epigraph:: ``LoggingInfo`` has been deprecated. To specify an Amazon S3 bucket to contain logs for Run Command tasks, instead use the ``OutputS3BucketName`` and ``OutputS3KeyPrefix`` options in the ``TaskInvocationParameters`` structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see `AWS ::SSM::MaintenanceWindowTask MaintenanceWindowRunCommandParameters <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-maintenancewindowtask-maintenancewindowruncommandparameters.html>`_ .\n')
    max_concurrency: typing.Optional[str] = pydantic.Field(None, description='The maximum number of targets this task can be run for, in parallel. .. epigraph:: Although this element is listed as "Required: No", a value can be omitted only when you are registering or updating a `targetless task <https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html>`_ You must provide a value in all other cases. For maintenance window tasks without a target specified, you can\'t supply a value for this option. Instead, the system inserts a placeholder value of ``1`` . This value doesn\'t affect the running of your task.\n')
    max_errors: typing.Optional[str] = pydantic.Field(None, description='The maximum number of errors allowed before this task stops being scheduled. .. epigraph:: Although this element is listed as "Required: No", a value can be omitted only when you are registering or updating a `targetless task <https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html>`_ You must provide a value in all other cases. For maintenance window tasks without a target specified, you can\'t supply a value for this option. Instead, the system inserts a placeholder value of ``1`` . This value doesn\'t affect the running of your task.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The task name.\n')
    service_role_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for maintenance window Run Command tasks.\n')
    targets: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_ssm.CfnMaintenanceWindowTask_TargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The targets, either instances or window target IDs. - Specify instances using ``Key=InstanceIds,Values= *instanceid1* , *instanceid2*`` . - Specify window target IDs using ``Key=WindowTargetIds,Values= *window-target-id-1* , *window-target-id-2*`` .\n')
    task_invocation_parameters: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnMaintenanceWindowTask_TaskInvocationParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The parameters to pass to the task when it runs. Populate only the fields that match the task type. All other fields should be empty. .. epigraph:: When you update a maintenance window task that has options specified in ``TaskInvocationParameters`` , you must provide again all the ``TaskInvocationParameters`` values that you want to retain. The values you do not specify again are removed. For example, suppose that when you registered a Run Command task, you specified ``TaskInvocationParameters`` values for ``Comment`` , ``NotificationConfig`` , and ``OutputS3BucketName`` . If you update the maintenance window task and specify only a different ``OutputS3BucketName`` value, the values for ``Comment`` and ``NotificationConfig`` are removed.\n')
    task_parameters: typing.Any = pydantic.Field(None, description='The parameters to pass to the task when it runs. .. epigraph:: ``TaskParameters`` has been deprecated. To specify parameters to pass to a task when it runs, instead use the ``Parameters`` option in the ``TaskInvocationParameters`` structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see `MaintenanceWindowTaskInvocationParameters <https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_MaintenanceWindowTaskInvocationParameters.html>`_ .')
    _init_params: typing.ClassVar[list[str]] = ['priority', 'task_arn', 'task_type', 'window_id', 'cutoff_behavior', 'description', 'logging_info', 'max_concurrency', 'max_errors', 'name', 'service_role_arn', 'targets', 'task_invocation_parameters', 'task_parameters']
    _method_names: typing.ClassVar[list[str]] = ['CloudWatchOutputConfigProperty', 'LoggingInfoProperty', 'MaintenanceWindowAutomationParametersProperty', 'MaintenanceWindowLambdaParametersProperty', 'MaintenanceWindowRunCommandParametersProperty', 'MaintenanceWindowStepFunctionsParametersProperty', 'NotificationConfigProperty', 'TargetProperty', 'TaskInvocationParametersProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnMaintenanceWindowTask'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ssm.CfnMaintenanceWindowTaskDefConfig] = pydantic.Field(None)


class CfnMaintenanceWindowTaskDefConfig(pydantic.BaseModel):
    CloudWatchOutputConfigProperty: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefCloudwatchoutputconfigpropertyParams]] = pydantic.Field(None, description='')
    LoggingInfoProperty: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefLogginginfopropertyParams]] = pydantic.Field(None, description='')
    MaintenanceWindowAutomationParametersProperty: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefMaintenancewindowautomationparameterspropertyParams]] = pydantic.Field(None, description='')
    MaintenanceWindowLambdaParametersProperty: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefMaintenancewindowlambdaparameterspropertyParams]] = pydantic.Field(None, description='')
    MaintenanceWindowRunCommandParametersProperty: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefMaintenancewindowruncommandparameterspropertyParams]] = pydantic.Field(None, description='')
    MaintenanceWindowStepFunctionsParametersProperty: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefMaintenancewindowstepfunctionsparameterspropertyParams]] = pydantic.Field(None, description='')
    NotificationConfigProperty: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefNotificationconfigpropertyParams]] = pydantic.Field(None, description='')
    TargetProperty: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefTargetpropertyParams]] = pydantic.Field(None, description='')
    TaskInvocationParametersProperty: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefTaskinvocationparameterspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_ssm.CfnMaintenanceWindowTaskDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnMaintenanceWindowTaskDefCloudwatchoutputconfigpropertyParams(pydantic.BaseModel):
    cloud_watch_log_group_name: typing.Optional[str] = pydantic.Field(None, description='')
    cloud_watch_output_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnMaintenanceWindowTaskDefLogginginfopropertyParams(pydantic.BaseModel):
    region: str = pydantic.Field(..., description='')
    s3_bucket: str = pydantic.Field(..., description='')
    s3_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnMaintenanceWindowTaskDefMaintenancewindowautomationparameterspropertyParams(pydantic.BaseModel):
    document_version: typing.Optional[str] = pydantic.Field(None, description='')
    parameters: typing.Any = pydantic.Field(None, description='')
    ...

class CfnMaintenanceWindowTaskDefMaintenancewindowlambdaparameterspropertyParams(pydantic.BaseModel):
    client_context: typing.Optional[str] = pydantic.Field(None, description='')
    payload: typing.Optional[str] = pydantic.Field(None, description='')
    qualifier: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnMaintenanceWindowTaskDefMaintenancewindowruncommandparameterspropertyParams(pydantic.BaseModel):
    cloud_watch_output_config: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnMaintenanceWindowTask_CloudWatchOutputConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    comment: typing.Optional[str] = pydantic.Field(None, description='')
    document_hash: typing.Optional[str] = pydantic.Field(None, description='')
    document_hash_type: typing.Optional[str] = pydantic.Field(None, description='')
    document_version: typing.Optional[str] = pydantic.Field(None, description='')
    notification_config: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnMaintenanceWindowTask_NotificationConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    output_s3_bucket_name: typing.Optional[str] = pydantic.Field(None, description='')
    output_s3_key_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    parameters: typing.Any = pydantic.Field(None, description='')
    service_role_arn: typing.Optional[str] = pydantic.Field(None, description='')
    timeout_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnMaintenanceWindowTaskDefMaintenancewindowstepfunctionsparameterspropertyParams(pydantic.BaseModel):
    input: typing.Optional[str] = pydantic.Field(None, description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnMaintenanceWindowTaskDefNotificationconfigpropertyParams(pydantic.BaseModel):
    notification_arn: str = pydantic.Field(..., description='')
    notification_events: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    notification_type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnMaintenanceWindowTaskDefTargetpropertyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='')
    values: typing.Sequence[str] = pydantic.Field(..., description='')
    ...

class CfnMaintenanceWindowTaskDefTaskinvocationparameterspropertyParams(pydantic.BaseModel):
    maintenance_window_automation_parameters: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnMaintenanceWindowTask_MaintenanceWindowAutomationParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    maintenance_window_lambda_parameters: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnMaintenanceWindowTask_MaintenanceWindowLambdaParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    maintenance_window_run_command_parameters: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnMaintenanceWindowTask_MaintenanceWindowRunCommandParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    maintenance_window_step_functions_parameters: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnMaintenanceWindowTask_MaintenanceWindowStepFunctionsParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnMaintenanceWindowTaskDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnMaintenanceWindowTaskDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMaintenanceWindowTaskDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnMaintenanceWindowTaskDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMaintenanceWindowTaskDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnMaintenanceWindowTaskDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnMaintenanceWindowTaskDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnMaintenanceWindowTaskDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnMaintenanceWindowTaskDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnMaintenanceWindowTaskDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnMaintenanceWindowTaskDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnMaintenanceWindowTaskDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnMaintenanceWindowTaskDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnMaintenanceWindowTaskDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ssm.CfnParameter
class CfnParameterDef(BaseCfnResource):
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The type of parameter. .. epigraph:: AWS CloudFormation doesn't support creating a ``SecureString`` parameter type. *Allowed Values* : String | StringList\n")
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The parameter value. .. epigraph:: If type is ``StringList`` , the system returns a comma-separated string with no spaces between commas in the ``Value`` field.\n')
    allowed_pattern: typing.Optional[str] = pydantic.Field(None, description='A regular expression used to validate the parameter value. For example, for String types with values restricted to numbers, you can specify the following: ``AllowedPattern=^\\d+$``\n')
    data_type: typing.Optional[str] = pydantic.Field(None, description='The data type of the parameter, such as ``text`` or ``aws:ec2:image`` . The default is ``text`` .\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Information about the parameter.\n')
    name: typing.Optional[str] = pydantic.Field(None, description="The name of the parameter. .. epigraph:: The maximum length constraint listed below includes capacity for additional system attributes that aren't part of the name. The maximum length for a parameter name, including the full length of the parameter ARN, is 1011 characters. For example, the length of the following parameter name is 65 characters, not 20 characters: ``arn:aws:ssm:us-east-2:111222333444")
    policies: typing.Optional[str] = pydantic.Field(None, description='Information about the policies assigned to a parameter. `Assigning parameter policies <https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-policies.html>`_ in the *AWS Systems Manager User Guide* .\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Optional metadata that you assign to a resource in the form of an arbitrary set of tags (key-value pairs). Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a Systems Manager parameter to identify the type of resource to which it applies, the environment, or the type of configuration data referenced by the parameter.\n')
    tier: typing.Optional[str] = pydantic.Field(None, description='The parameter tier.')
    _init_params: typing.ClassVar[list[str]] = ['type', 'value', 'allowed_pattern', 'data_type', 'description', 'name', 'policies', 'tags', 'tier']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnParameter'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ssm.CfnParameterDefConfig] = pydantic.Field(None)


class CfnParameterDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_ssm.CfnParameterDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_ssm.CfnParameterDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_ssm.CfnParameterDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_ssm.CfnParameterDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_ssm.CfnParameterDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_ssm.CfnParameterDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_ssm.CfnParameterDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_ssm.CfnParameterDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_ssm.CfnParameterDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_ssm.CfnParameterDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_ssm.CfnParameterDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_ssm.CfnParameterDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_ssm.CfnParameterDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnParameterDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnParameterDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnParameterDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnParameterDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnParameterDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnParameterDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnParameterDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnParameterDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnParameterDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnParameterDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnParameterDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnParameterDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnParameterDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnParameterDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ssm.CfnPatchBaseline
class CfnPatchBaselineDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the patch baseline.\n')
    approval_rules: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnPatchBaseline_RuleGroupPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A set of rules used to include patches in the baseline.\n')
    approved_patches: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of explicitly approved patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see `About package name formats for approved and rejected patch lists <https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html>`_ in the *AWS Systems Manager User Guide* .\n')
    approved_patches_compliance_level: typing.Optional[str] = pydantic.Field(None, description='Defines the compliance level for approved patches. When an approved patch is reported as missing, this value describes the severity of the compliance violation. The default value is ``UNSPECIFIED`` .\n')
    approved_patches_enable_non_security: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is ``false`` . Applies to Linux managed nodes only.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the patch baseline.\n')
    global_filters: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnPatchBaseline_PatchFilterGroupPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A set of global filters used to include patches in the baseline.\n')
    operating_system: typing.Optional[str] = pydantic.Field(None, description='Defines the operating system the patch baseline applies to. The default value is ``WINDOWS`` .\n')
    patch_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The name of the patch group to be registered with the patch baseline.\n')
    rejected_patches: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of explicitly rejected patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see `About package name formats for approved and rejected patch lists <https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html>`_ in the *AWS Systems Manager User Guide* .\n')
    rejected_patches_action: typing.Optional[str] = pydantic.Field(None, description="The action for Patch Manager to take on patches included in the ``RejectedPackages`` list. - *``ALLOW_AS_DEPENDENCY``* : A package in the ``Rejected`` patches list is installed only if it is a dependency of another package. It is considered compliant with the patch baseline, and its status is reported as ``InstalledOther`` . This is the default action if no option is specified. - *``BLOCK``* : Packages in the ``RejectedPatches`` list, and packages that include them as dependencies, aren't installed under any circumstances. If a package was installed before it was added to the Rejected patches list, it is considered non-compliant with the patch baseline, and its status is reported as ``InstalledRejected`` .\n")
    sources: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_ssm.CfnPatchBaseline_PatchSourcePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a patch baseline to identify the severity level of patches it specifies and the operating system family it applies to.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'approval_rules', 'approved_patches', 'approved_patches_compliance_level', 'approved_patches_enable_non_security', 'description', 'global_filters', 'operating_system', 'patch_groups', 'rejected_patches', 'rejected_patches_action', 'sources', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['PatchFilterGroupProperty', 'PatchFilterProperty', 'PatchSourceProperty', 'RuleGroupProperty', 'RuleProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnPatchBaseline'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ssm.CfnPatchBaselineDefConfig] = pydantic.Field(None)


class CfnPatchBaselineDefConfig(pydantic.BaseModel):
    PatchFilterGroupProperty: typing.Optional[list[models.aws_ssm.CfnPatchBaselineDefPatchfiltergrouppropertyParams]] = pydantic.Field(None, description='')
    PatchFilterProperty: typing.Optional[list[models.aws_ssm.CfnPatchBaselineDefPatchfilterpropertyParams]] = pydantic.Field(None, description='')
    PatchSourceProperty: typing.Optional[list[models.aws_ssm.CfnPatchBaselineDefPatchsourcepropertyParams]] = pydantic.Field(None, description='')
    RuleGroupProperty: typing.Optional[list[models.aws_ssm.CfnPatchBaselineDefRulegrouppropertyParams]] = pydantic.Field(None, description='')
    RuleProperty: typing.Optional[list[models.aws_ssm.CfnPatchBaselineDefRulepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_ssm.CfnPatchBaselineDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_ssm.CfnPatchBaselineDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_ssm.CfnPatchBaselineDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_ssm.CfnPatchBaselineDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_ssm.CfnPatchBaselineDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_ssm.CfnPatchBaselineDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_ssm.CfnPatchBaselineDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_ssm.CfnPatchBaselineDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_ssm.CfnPatchBaselineDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_ssm.CfnPatchBaselineDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_ssm.CfnPatchBaselineDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_ssm.CfnPatchBaselineDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_ssm.CfnPatchBaselineDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnPatchBaselineDefPatchfiltergrouppropertyParams(pydantic.BaseModel):
    patch_filters: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_ssm.CfnPatchBaseline_PatchFilterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnPatchBaselineDefPatchfilterpropertyParams(pydantic.BaseModel):
    key: typing.Optional[str] = pydantic.Field(None, description='')
    values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnPatchBaselineDefPatchsourcepropertyParams(pydantic.BaseModel):
    configuration: typing.Optional[str] = pydantic.Field(None, description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    products: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnPatchBaselineDefRulegrouppropertyParams(pydantic.BaseModel):
    patch_rules: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_ssm.CfnPatchBaseline_RulePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnPatchBaselineDefRulepropertyParams(pydantic.BaseModel):
    approve_after_days: typing.Union[int, float, None] = pydantic.Field(None, description='')
    approve_until_date: typing.Optional[str] = pydantic.Field(None, description='')
    compliance_level: typing.Optional[str] = pydantic.Field(None, description='')
    enable_non_security: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    patch_filter_group: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnPatchBaseline_PatchFilterGroupPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnPatchBaselineDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPatchBaselineDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPatchBaselineDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPatchBaselineDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPatchBaselineDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPatchBaselineDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPatchBaselineDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPatchBaselineDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPatchBaselineDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPatchBaselineDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPatchBaselineDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnPatchBaselineDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPatchBaselineDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPatchBaselineDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ssm.CfnResourceDataSync
class CfnResourceDataSyncDef(BaseCfnResource):
    sync_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='')
    bucket_name: typing.Optional[str] = pydantic.Field(None, description='The name of the S3 bucket where the aggregated data is stored.\n')
    bucket_prefix: typing.Optional[str] = pydantic.Field(None, description='An Amazon S3 prefix for the bucket.\n')
    bucket_region: typing.Optional[str] = pydantic.Field(None, description='The AWS Region with the S3 bucket targeted by the resource data sync.\n')
    kms_key_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of an encryption key for a destination in Amazon S3 . You can use a KMS key to encrypt inventory data in Amazon S3 . You must specify a key that exist in the same region as the destination Amazon S3 bucket.\n')
    s3_destination: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnResourceDataSync_S3DestinationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configuration information for the target S3 bucket.\n')
    sync_format: typing.Optional[str] = pydantic.Field(None, description='A supported sync format. The following format is currently supported: JsonSerDe\n')
    sync_source: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnResourceDataSync_SyncSourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about the source where the data was synchronized.\n')
    sync_type: typing.Optional[str] = pydantic.Field(None, description='The type of resource data sync. If ``SyncType`` is ``SyncToDestination`` , then the resource data sync synchronizes data to an S3 bucket. If the ``SyncType`` is ``SyncFromSource`` then the resource data sync synchronizes data from AWS Organizations or from multiple AWS Regions .')
    _init_params: typing.ClassVar[list[str]] = ['sync_name', 'bucket_name', 'bucket_prefix', 'bucket_region', 'kms_key_arn', 's3_destination', 'sync_format', 'sync_source', 'sync_type']
    _method_names: typing.ClassVar[list[str]] = ['AwsOrganizationsSourceProperty', 'S3DestinationProperty', 'SyncSourceProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnResourceDataSync'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ssm.CfnResourceDataSyncDefConfig] = pydantic.Field(None)


class CfnResourceDataSyncDefConfig(pydantic.BaseModel):
    AwsOrganizationsSourceProperty: typing.Optional[list[models.aws_ssm.CfnResourceDataSyncDefAwsorganizationssourcepropertyParams]] = pydantic.Field(None, description='')
    S3DestinationProperty: typing.Optional[list[models.aws_ssm.CfnResourceDataSyncDefS3DestinationpropertyParams]] = pydantic.Field(None, description='')
    SyncSourceProperty: typing.Optional[list[models.aws_ssm.CfnResourceDataSyncDefSyncsourcepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_ssm.CfnResourceDataSyncDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_ssm.CfnResourceDataSyncDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_ssm.CfnResourceDataSyncDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_ssm.CfnResourceDataSyncDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_ssm.CfnResourceDataSyncDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_ssm.CfnResourceDataSyncDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_ssm.CfnResourceDataSyncDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_ssm.CfnResourceDataSyncDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_ssm.CfnResourceDataSyncDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_ssm.CfnResourceDataSyncDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_ssm.CfnResourceDataSyncDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_ssm.CfnResourceDataSyncDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_ssm.CfnResourceDataSyncDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnResourceDataSyncDefAwsorganizationssourcepropertyParams(pydantic.BaseModel):
    organization_source_type: str = pydantic.Field(..., description='')
    organizational_units: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnResourceDataSyncDefS3DestinationpropertyParams(pydantic.BaseModel):
    bucket_name: str = pydantic.Field(..., description='')
    bucket_region: str = pydantic.Field(..., description='')
    sync_format: str = pydantic.Field(..., description='')
    bucket_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    kms_key_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnResourceDataSyncDefSyncsourcepropertyParams(pydantic.BaseModel):
    source_regions: typing.Sequence[str] = pydantic.Field(..., description='')
    source_type: str = pydantic.Field(..., description='')
    aws_organizations_source: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnResourceDataSync_AwsOrganizationsSourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    include_future_regions: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnResourceDataSyncDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnResourceDataSyncDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnResourceDataSyncDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnResourceDataSyncDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnResourceDataSyncDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnResourceDataSyncDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnResourceDataSyncDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnResourceDataSyncDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnResourceDataSyncDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnResourceDataSyncDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnResourceDataSyncDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnResourceDataSyncDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnResourceDataSyncDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnResourceDataSyncDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ssm.CfnResourcePolicy
class CfnResourcePolicyDef(BaseCfnResource):
    policy: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A policy you want to associate with a resource.\n')
    resource_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Amazon Resource Name (ARN) of the resource to which you want to attach a policy.')
    _init_params: typing.ClassVar[list[str]] = ['policy', 'resource_arn']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnResourcePolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_ssm.CfnResourcePolicyDefConfig] = pydantic.Field(None)


class CfnResourcePolicyDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_ssm.CfnResourcePolicyDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_ssm.CfnResourcePolicyDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_ssm.CfnResourcePolicyDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_ssm.CfnResourcePolicyDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_ssm.CfnResourcePolicyDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_ssm.CfnResourcePolicyDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_ssm.CfnResourcePolicyDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_ssm.CfnResourcePolicyDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_ssm.CfnResourcePolicyDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_ssm.CfnResourcePolicyDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_ssm.CfnResourcePolicyDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_ssm.CfnResourcePolicyDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_ssm.CfnResourcePolicyDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnResourcePolicyDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnResourcePolicyDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnResourcePolicyDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnResourcePolicyDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnResourcePolicyDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnResourcePolicyDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnResourcePolicyDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnResourcePolicyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnResourcePolicyDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnResourcePolicyDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnResourcePolicyDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnResourcePolicyDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnResourcePolicyDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnResourcePolicyDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ssm.CfnAssociationProps
class CfnAssociationPropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the SSM document that contains the configuration information for the instance. You can specify ``Command`` or ``Automation`` documents. The documents can be AWS -predefined documents, documents you created, or a document that is shared with you from another account. For SSM documents that are shared with you from other AWS accounts , you must specify the complete SSM document ARN, in the following format: ``arn:partition:ssm:region:account-id:document/document-name`` For example: ``arn:aws:ssm:us-east-2:12345678912:document/My-Shared-Document`` For AWS -predefined documents and SSM documents you created in your account, you only need to specify the document name. For example, ``AWS -ApplyPatchBaseline`` or ``My-Document`` .\n')
    apply_only_at_cron_interval: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="By default, when you create a new association, the system runs it immediately after it is created and then according to the schedule you specified. Specify this option if you don't want an association to run immediately after you create it. This parameter is not supported for rate expressions.\n")
    association_name: typing.Optional[str] = pydantic.Field(None, description='Specify a descriptive name for the association.\n')
    automation_target_parameter_name: typing.Optional[str] = pydantic.Field(None, description='Choose the parameter that will define how your automation will branch out. This target is required for associations that use an Automation runbook and target resources by using rate controls. Automation is a capability of AWS Systems Manager .\n')
    calendar_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The names or Amazon Resource Names (ARNs) of the Change Calendar type documents your associations are gated under. The associations only run when that Change Calendar is open. For more information, see `AWS Systems Manager Change Calendar <https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar>`_ .\n')
    compliance_severity: typing.Optional[str] = pydantic.Field(None, description='The severity level that is assigned to the association.\n')
    document_version: typing.Optional[str] = pydantic.Field(None, description='The version of the SSM document to associate with the target. .. epigraph:: Note the following important information. - State Manager doesn\'t support running associations that use a new version of a document if that document is shared from another account. State Manager always runs the ``default`` version of a document if shared from another account, even though the Systems Manager console shows that a new version was processed. If you want to run an association using a new version of a document shared form another account, you must set the document version to ``default`` . - ``DocumentVersion`` is not valid for documents owned by AWS , such as ``AWS-RunPatchBaseline`` or ``AWS-UpdateSSMAgent`` . If you specify ``DocumentVersion`` for an AWS document, the system returns the following error: "Error occurred during operation \'CreateAssociation\'." (RequestToken: , HandlerErrorCode: GeneralServiceException).\n')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the instance that the SSM document is associated with. You must specify the ``InstanceId`` or ``Targets`` property. .. epigraph:: ``InstanceId`` has been deprecated. To specify an instance ID for an association, use the ``Targets`` parameter. If you use the parameter ``InstanceId`` , you cannot use the parameters ``AssociationName`` , ``DocumentVersion`` , ``MaxErrors`` , ``MaxConcurrency`` , ``OutputLocation`` , or ``ScheduleExpression`` . To use these parameters, you must use the ``Targets`` parameter.\n')
    max_concurrency: typing.Optional[str] = pydantic.Field(None, description='The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time. If a new managed node starts and attempts to run an association while Systems Manager is running ``MaxConcurrency`` associations, the association is allowed to run. During the next association interval, the new managed node will process its association within the limit specified for ``MaxConcurrency`` .\n')
    max_errors: typing.Optional[str] = pydantic.Field(None, description="The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 managed nodes and set ``MaxError`` to 10%, then the system stops sending the request when the sixth error is received. Executions that are already running an association when ``MaxErrors`` is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set ``MaxConcurrency`` to 1 so that executions proceed one at a time.\n")
    output_location: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnAssociation_InstanceAssociationOutputLocationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An Amazon Simple Storage Service (Amazon S3) bucket where you want to store the output details of the request.\n')
    parameters: typing.Any = pydantic.Field(None, description='Parameter values that the SSM document uses at runtime.\n')
    schedule_expression: typing.Optional[str] = pydantic.Field(None, description='A cron expression that specifies a schedule when the association runs. The schedule runs in Coordinated Universal Time (UTC).\n')
    schedule_offset: typing.Union[int, float, None] = pydantic.Field(None, description='Number of days to wait after the scheduled day to run an association.\n')
    sync_compliance: typing.Optional[str] = pydantic.Field(None, description="The mode for generating association compliance. You can specify ``AUTO`` or ``MANUAL`` . In ``AUTO`` mode, the system uses the status of the association execution to determine the compliance status. If the association execution runs successfully, then the association is ``COMPLIANT`` . If the association execution doesn't run successfully, the association is ``NON-COMPLIANT`` . In ``MANUAL`` mode, you must specify the ``AssociationId`` as a parameter for the PutComplianceItems API action. In this case, compliance data is not managed by State Manager. It is managed by your direct call to the PutComplianceItems API action. By default, all associations use ``AUTO`` mode.\n")
    targets: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_ssm.CfnAssociation_TargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The targets for the association. You must specify the ``InstanceId`` or ``Targets`` property. You can target all instances in an AWS account by specifying the ``InstanceIds`` key with a value of ``*`` . To view a JSON and a YAML example that targets all instances, see "Create an association for all managed instances in an AWS account " on the Examples page.\n')
    wait_for_success_timeout_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The number of seconds the service should wait for the association status to show "Success" before proceeding with the stack execution. If the association status doesn\'t show "Success" after the specified number of seconds, then stack creation fails. .. epigraph:: When you specify a value for the ``WaitForSuccessTimeoutSeconds`` , `drift detection <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html>`_ for your AWS CloudFormation stacks configuration might yield inaccurate results. If drift detection is important in your scenario, we recommend that you dont include ``WaitForSuccessTimeoutSeconds`` in your template.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-association.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    # parameters: Any\n\n    cfn_association_props = ssm.CfnAssociationProps(\n        name="name",\n\n        # the properties below are optional\n        apply_only_at_cron_interval=False,\n        association_name="associationName",\n        automation_target_parameter_name="automationTargetParameterName",\n        calendar_names=["calendarNames"],\n        compliance_severity="complianceSeverity",\n        document_version="documentVersion",\n        instance_id="instanceId",\n        max_concurrency="maxConcurrency",\n        max_errors="maxErrors",\n        output_location=ssm.CfnAssociation.InstanceAssociationOutputLocationProperty(\n            s3_location=ssm.CfnAssociation.S3OutputLocationProperty(\n                output_s3_bucket_name="outputS3BucketName",\n                output_s3_key_prefix="outputS3KeyPrefix",\n                output_s3_region="outputS3Region"\n            )\n        ),\n        parameters=parameters,\n        schedule_expression="scheduleExpression",\n        schedule_offset=123,\n        sync_compliance="syncCompliance",\n        targets=[ssm.CfnAssociation.TargetProperty(\n            key="key",\n            values=["values"]\n        )],\n        wait_for_success_timeout_seconds=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'apply_only_at_cron_interval', 'association_name', 'automation_target_parameter_name', 'calendar_names', 'compliance_severity', 'document_version', 'instance_id', 'max_concurrency', 'max_errors', 'output_location', 'parameters', 'schedule_expression', 'schedule_offset', 'sync_compliance', 'targets', 'wait_for_success_timeout_seconds']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnDocumentProps
class CfnDocumentPropsDef(BaseCfnProperty):
    content: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The content for the new SSM document in JSON or YAML. For more information about the schemas for SSM document content, see `SSM document schema features and examples <https://docs.aws.amazon.com/systems-manager/latest/userguide/document-schemas-features.html>`_ in the *AWS Systems Manager User Guide* . .. epigraph:: This parameter also supports ``String`` data types.\n')
    attachments: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_ssm.CfnDocument_AttachmentsSourcePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of key-value pairs that describe attachments to a version of a document.\n')
    document_format: typing.Optional[str] = pydantic.Field(None, description='Specify the document format for the request. JSON is the default format. Default: - "JSON"\n')
    document_type: typing.Optional[str] = pydantic.Field(None, description='The type of document to create.\n')
    name: typing.Optional[str] = pydantic.Field(None, description="A name for the SSM document. .. epigraph:: You can't use the following strings as document name prefixes. These are reserved by AWS for use as document name prefixes: - ``aws`` - ``amazon`` - ``amzn``\n")
    requires: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_ssm.CfnDocument_DocumentRequiresPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of SSM documents required by a document. This parameter is used exclusively by AWS AppConfig . When a user creates an AWS AppConfig configuration in an SSM document, the user must also specify a required document for validation purposes. In this case, an ``ApplicationConfiguration`` document requires an ``ApplicationConfigurationSchema`` document for validation purposes. For more information, see `What is AWS AppConfig ? <https://docs.aws.amazon.com/appconfig/latest/userguide/what-is-appconfig.html>`_ in the *AWS AppConfig User Guide* .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='AWS CloudFormation resource tags to apply to the document. Use tags to help you identify and categorize resources.\n')
    target_type: typing.Optional[str] = pydantic.Field(None, description="Specify a target type to define the kinds of resources the document can run on. For example, to run a document on EC2 instances, specify the following value: ``/AWS::EC2::Instance`` . If you specify a value of '/' the document can run on all types of resources. If you don't specify a value, the document can't run on any resources. For a list of valid resource types, see `AWS resource and property types reference <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html>`_ in the *AWS CloudFormation User Guide* .\n")
    update_method: typing.Optional[str] = pydantic.Field(None, description='If the document resource you specify in your template already exists, this parameter determines whether a new version of the existing document is created, or the existing document is replaced. ``Replace`` is the default method. If you specify ``NewVersion`` for the ``UpdateMethod`` parameter, and the ``Name`` of the document does not match an existing resource, a new document is created. When you specify ``NewVersion`` , the default version of the document is changed to the newly created version. Default: - "Replace"\n')
    version_name: typing.Optional[str] = pydantic.Field(None, description='An optional field specifying the version of the artifact you are creating with the document. For example, ``Release12.1`` . This value is unique across all versions of a document, and can\'t be changed.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    # content: Any\n\n    cfn_document_props = ssm.CfnDocumentProps(\n        content=content,\n\n        # the properties below are optional\n        attachments=[ssm.CfnDocument.AttachmentsSourceProperty(\n            key="key",\n            name="name",\n            values=["values"]\n        )],\n        document_format="documentFormat",\n        document_type="documentType",\n        name="name",\n        requires=[ssm.CfnDocument.DocumentRequiresProperty(\n            name="name",\n            version="version"\n        )],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        target_type="targetType",\n        update_method="updateMethod",\n        version_name="versionName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['content', 'attachments', 'document_format', 'document_type', 'name', 'requires', 'tags', 'target_type', 'update_method', 'version_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnDocumentProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnMaintenanceWindowProps
class CfnMaintenanceWindowPropsDef(BaseCfnProperty):
    allow_unassociated_targets: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='Enables a maintenance window task to run on managed instances, even if you have not registered those instances as targets. If enabled, then you must specify the unregistered instances (by instance ID) when you register a task with the maintenance window.\n')
    cutoff: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The number of hours before the end of the maintenance window that AWS Systems Manager stops scheduling new tasks for execution.\n')
    duration: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The duration of the maintenance window in hours.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the maintenance window.\n')
    schedule: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The schedule of the maintenance window in the form of a cron or rate expression.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the maintenance window.\n')
    end_date: typing.Optional[str] = pydantic.Field(None, description='The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become inactive.\n')
    schedule_offset: typing.Union[int, float, None] = pydantic.Field(None, description='The number of days to wait to run a maintenance window after the scheduled cron expression date and time.\n')
    schedule_timezone: typing.Optional[str] = pydantic.Field(None, description='The time zone that the scheduled maintenance window executions are based on, in Internet Assigned Numbers Authority (IANA) format.\n')
    start_date: typing.Optional[str] = pydantic.Field(None, description='The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become active. StartDate allows you to delay activation of the Maintenance Window until the specified future date.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Optional metadata that you assign to a resource in the form of an arbitrary set of tags (key-value pairs). Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a maintenance window to identify the type of tasks it will run, the types of targets, and the environment it will run in.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-maintenancewindow.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    cfn_maintenance_window_props = ssm.CfnMaintenanceWindowProps(\n        allow_unassociated_targets=False,\n        cutoff=123,\n        duration=123,\n        name="name",\n        schedule="schedule",\n\n        # the properties below are optional\n        description="description",\n        end_date="endDate",\n        schedule_offset=123,\n        schedule_timezone="scheduleTimezone",\n        start_date="startDate",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allow_unassociated_targets', 'cutoff', 'duration', 'name', 'schedule', 'description', 'end_date', 'schedule_offset', 'schedule_timezone', 'start_date', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnMaintenanceWindowProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnMaintenanceWindowTargetProps
class CfnMaintenanceWindowTargetPropsDef(BaseCfnProperty):
    resource_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of target that is being registered with the maintenance window.\n')
    targets: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_ssm.CfnMaintenanceWindowTarget_TargetsPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The targets to register with the maintenance window. In other words, the instances to run commands on when the maintenance window runs. You must specify targets by using the ``WindowTargetIds`` parameter.\n')
    window_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the maintenance window to register the target with.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the target.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name for the maintenance window target.\n')
    owner_information: typing.Optional[str] = pydantic.Field(None, description='A user-provided value that will be included in any Amazon CloudWatch Events events that are raised while running tasks for these targets in this maintenance window.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-maintenancewindowtarget.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    cfn_maintenance_window_target_props = ssm.CfnMaintenanceWindowTargetProps(\n        resource_type="resourceType",\n        targets=[ssm.CfnMaintenanceWindowTarget.TargetsProperty(\n            key="key",\n            values=["values"]\n        )],\n        window_id="windowId",\n\n        # the properties below are optional\n        description="description",\n        name="name",\n        owner_information="ownerInformation"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resource_type', 'targets', 'window_id', 'description', 'name', 'owner_information']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnMaintenanceWindowTargetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnMaintenanceWindowTaskProps
class CfnMaintenanceWindowTaskPropsDef(BaseCfnProperty):
    priority: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The priority of the task in the maintenance window. The lower the number, the higher the priority. Tasks that have the same priority are scheduled in parallel.\n')
    task_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The resource that the task uses during execution. For ``RUN_COMMAND`` and ``AUTOMATION`` task types, ``TaskArn`` is the SSM document name or Amazon Resource Name (ARN). For ``LAMBDA`` tasks, ``TaskArn`` is the function name or ARN. For ``STEP_FUNCTIONS`` tasks, ``TaskArn`` is the state machine ARN.\n')
    task_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The type of task. Valid values: ``RUN_COMMAND`` , ``AUTOMATION`` , ``LAMBDA`` , ``STEP_FUNCTIONS`` .\n')
    window_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the maintenance window where the task is registered.\n')
    cutoff_behavior: typing.Optional[str] = pydantic.Field(None, description='The specification for whether tasks should continue to run after the cutoff time specified in the maintenance windows is reached.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the task.\n')
    logging_info: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnMaintenanceWindowTask_LoggingInfoPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about an Amazon S3 bucket to write Run Command task-level logs to. .. epigraph:: ``LoggingInfo`` has been deprecated. To specify an Amazon S3 bucket to contain logs for Run Command tasks, instead use the ``OutputS3BucketName`` and ``OutputS3KeyPrefix`` options in the ``TaskInvocationParameters`` structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see `AWS ::SSM::MaintenanceWindowTask MaintenanceWindowRunCommandParameters <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-maintenancewindowtask-maintenancewindowruncommandparameters.html>`_ .\n')
    max_concurrency: typing.Optional[str] = pydantic.Field(None, description='The maximum number of targets this task can be run for, in parallel. .. epigraph:: Although this element is listed as "Required: No", a value can be omitted only when you are registering or updating a `targetless task <https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html>`_ You must provide a value in all other cases. For maintenance window tasks without a target specified, you can\'t supply a value for this option. Instead, the system inserts a placeholder value of ``1`` . This value doesn\'t affect the running of your task.\n')
    max_errors: typing.Optional[str] = pydantic.Field(None, description='The maximum number of errors allowed before this task stops being scheduled. .. epigraph:: Although this element is listed as "Required: No", a value can be omitted only when you are registering or updating a `targetless task <https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html>`_ You must provide a value in all other cases. For maintenance window tasks without a target specified, you can\'t supply a value for this option. Instead, the system inserts a placeholder value of ``1`` . This value doesn\'t affect the running of your task.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The task name.\n')
    service_role_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for maintenance window Run Command tasks.\n')
    targets: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_ssm.CfnMaintenanceWindowTask_TargetPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The targets, either instances or window target IDs. - Specify instances using ``Key=InstanceIds,Values= *instanceid1* , *instanceid2*`` . - Specify window target IDs using ``Key=WindowTargetIds,Values= *window-target-id-1* , *window-target-id-2*`` .\n')
    task_invocation_parameters: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnMaintenanceWindowTask_TaskInvocationParametersPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The parameters to pass to the task when it runs. Populate only the fields that match the task type. All other fields should be empty. .. epigraph:: When you update a maintenance window task that has options specified in ``TaskInvocationParameters`` , you must provide again all the ``TaskInvocationParameters`` values that you want to retain. The values you do not specify again are removed. For example, suppose that when you registered a Run Command task, you specified ``TaskInvocationParameters`` values for ``Comment`` , ``NotificationConfig`` , and ``OutputS3BucketName`` . If you update the maintenance window task and specify only a different ``OutputS3BucketName`` value, the values for ``Comment`` and ``NotificationConfig`` are removed.\n')
    task_parameters: typing.Any = pydantic.Field(None, description='The parameters to pass to the task when it runs. .. epigraph:: ``TaskParameters`` has been deprecated. To specify parameters to pass to a task when it runs, instead use the ``Parameters`` option in the ``TaskInvocationParameters`` structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see `MaintenanceWindowTaskInvocationParameters <https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_MaintenanceWindowTaskInvocationParameters.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-maintenancewindowtask.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    # parameters: Any\n    # task_parameters: Any\n\n    cfn_maintenance_window_task_props = ssm.CfnMaintenanceWindowTaskProps(\n        priority=123,\n        task_arn="taskArn",\n        task_type="taskType",\n        window_id="windowId",\n\n        # the properties below are optional\n        cutoff_behavior="cutoffBehavior",\n        description="description",\n        logging_info=ssm.CfnMaintenanceWindowTask.LoggingInfoProperty(\n            region="region",\n            s3_bucket="s3Bucket",\n\n            # the properties below are optional\n            s3_prefix="s3Prefix"\n        ),\n        max_concurrency="maxConcurrency",\n        max_errors="maxErrors",\n        name="name",\n        service_role_arn="serviceRoleArn",\n        targets=[ssm.CfnMaintenanceWindowTask.TargetProperty(\n            key="key",\n            values=["values"]\n        )],\n        task_invocation_parameters=ssm.CfnMaintenanceWindowTask.TaskInvocationParametersProperty(\n            maintenance_window_automation_parameters=ssm.CfnMaintenanceWindowTask.MaintenanceWindowAutomationParametersProperty(\n                document_version="documentVersion",\n                parameters=parameters\n            ),\n            maintenance_window_lambda_parameters=ssm.CfnMaintenanceWindowTask.MaintenanceWindowLambdaParametersProperty(\n                client_context="clientContext",\n                payload="payload",\n                qualifier="qualifier"\n            ),\n            maintenance_window_run_command_parameters=ssm.CfnMaintenanceWindowTask.MaintenanceWindowRunCommandParametersProperty(\n                cloud_watch_output_config=ssm.CfnMaintenanceWindowTask.CloudWatchOutputConfigProperty(\n                    cloud_watch_log_group_name="cloudWatchLogGroupName",\n                    cloud_watch_output_enabled=False\n                ),\n                comment="comment",\n                document_hash="documentHash",\n                document_hash_type="documentHashType",\n                document_version="documentVersion",\n                notification_config=ssm.CfnMaintenanceWindowTask.NotificationConfigProperty(\n                    notification_arn="notificationArn",\n\n                    # the properties below are optional\n                    notification_events=["notificationEvents"],\n                    notification_type="notificationType"\n                ),\n                output_s3_bucket_name="outputS3BucketName",\n                output_s3_key_prefix="outputS3KeyPrefix",\n                parameters=parameters,\n                service_role_arn="serviceRoleArn",\n                timeout_seconds=123\n            ),\n            maintenance_window_step_functions_parameters=ssm.CfnMaintenanceWindowTask.MaintenanceWindowStepFunctionsParametersProperty(\n                input="input",\n                name="name"\n            )\n        ),\n        task_parameters=task_parameters\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['priority', 'task_arn', 'task_type', 'window_id', 'cutoff_behavior', 'description', 'logging_info', 'max_concurrency', 'max_errors', 'name', 'service_role_arn', 'targets', 'task_invocation_parameters', 'task_parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnMaintenanceWindowTaskProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnParameterProps
class CfnParameterPropsDef(BaseCfnProperty):
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The type of parameter. .. epigraph:: AWS CloudFormation doesn't support creating a ``SecureString`` parameter type. *Allowed Values* : String | StringList\n")
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The parameter value. .. epigraph:: If type is ``StringList`` , the system returns a comma-separated string with no spaces between commas in the ``Value`` field.\n')
    allowed_pattern: typing.Optional[str] = pydantic.Field(None, description='A regular expression used to validate the parameter value. For example, for String types with values restricted to numbers, you can specify the following: ``AllowedPattern=^\\d+$``\n')
    data_type: typing.Optional[str] = pydantic.Field(None, description='The data type of the parameter, such as ``text`` or ``aws:ec2:image`` . The default is ``text`` .\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Information about the parameter.\n')
    name: typing.Optional[str] = pydantic.Field(None, description="The name of the parameter. .. epigraph:: The maximum length constraint listed below includes capacity for additional system attributes that aren't part of the name. The maximum length for a parameter name, including the full length of the parameter ARN, is 1011 characters. For example, the length of the following parameter name is 65 characters, not 20 characters: ``arn:aws:ssm:us-east-2:111222333444")
    policies: typing.Optional[str] = pydantic.Field(None, description='Information about the policies assigned to a parameter. `Assigning parameter policies <https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-policies.html>`_ in the *AWS Systems Manager User Guide* .\n')
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Optional metadata that you assign to a resource in the form of an arbitrary set of tags (key-value pairs). Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a Systems Manager parameter to identify the type of resource to which it applies, the environment, or the type of configuration data referenced by the parameter.\n')
    tier: typing.Optional[str] = pydantic.Field(None, description='The parameter tier.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-parameter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    cfn_parameter_props = ssm.CfnParameterProps(\n        type="type",\n        value="value",\n\n        # the properties below are optional\n        allowed_pattern="allowedPattern",\n        data_type="dataType",\n        description="description",\n        name="name",\n        policies="policies",\n        tags={\n            "tags_key": "tags"\n        },\n        tier="tier"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'value', 'allowed_pattern', 'data_type', 'description', 'name', 'policies', 'tags', 'tier']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnParameterProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnPatchBaselineProps
class CfnPatchBaselinePropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the patch baseline.\n')
    approval_rules: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnPatchBaseline_RuleGroupPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A set of rules used to include patches in the baseline.\n')
    approved_patches: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of explicitly approved patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see `About package name formats for approved and rejected patch lists <https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html>`_ in the *AWS Systems Manager User Guide* .\n')
    approved_patches_compliance_level: typing.Optional[str] = pydantic.Field(None, description='Defines the compliance level for approved patches. When an approved patch is reported as missing, this value describes the severity of the compliance violation. The default value is ``UNSPECIFIED`` .\n')
    approved_patches_enable_non_security: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is ``false`` . Applies to Linux managed nodes only.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of the patch baseline.\n')
    global_filters: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnPatchBaseline_PatchFilterGroupPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='A set of global filters used to include patches in the baseline.\n')
    operating_system: typing.Optional[str] = pydantic.Field(None, description='Defines the operating system the patch baseline applies to. The default value is ``WINDOWS`` .\n')
    patch_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The name of the patch group to be registered with the patch baseline.\n')
    rejected_patches: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of explicitly rejected patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see `About package name formats for approved and rejected patch lists <https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html>`_ in the *AWS Systems Manager User Guide* .\n')
    rejected_patches_action: typing.Optional[str] = pydantic.Field(None, description="The action for Patch Manager to take on patches included in the ``RejectedPackages`` list. - *``ALLOW_AS_DEPENDENCY``* : A package in the ``Rejected`` patches list is installed only if it is a dependency of another package. It is considered compliant with the patch baseline, and its status is reported as ``InstalledOther`` . This is the default action if no option is specified. - *``BLOCK``* : Packages in the ``RejectedPatches`` list, and packages that include them as dependencies, aren't installed under any circumstances. If a package was installed before it was added to the Rejected patches list, it is considered non-compliant with the patch baseline, and its status is reported as ``InstalledRejected`` .\n")
    sources: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_ssm.CfnPatchBaseline_PatchSourcePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a patch baseline to identify the severity level of patches it specifies and the operating system family it applies to.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-patchbaseline.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    cfn_patch_baseline_props = ssm.CfnPatchBaselineProps(\n        name="name",\n\n        # the properties below are optional\n        approval_rules=ssm.CfnPatchBaseline.RuleGroupProperty(\n            patch_rules=[ssm.CfnPatchBaseline.RuleProperty(\n                approve_after_days=123,\n                approve_until_date="approveUntilDate",\n                compliance_level="complianceLevel",\n                enable_non_security=False,\n                patch_filter_group=ssm.CfnPatchBaseline.PatchFilterGroupProperty(\n                    patch_filters=[ssm.CfnPatchBaseline.PatchFilterProperty(\n                        key="key",\n                        values=["values"]\n                    )]\n                )\n            )]\n        ),\n        approved_patches=["approvedPatches"],\n        approved_patches_compliance_level="approvedPatchesComplianceLevel",\n        approved_patches_enable_non_security=False,\n        description="description",\n        global_filters=ssm.CfnPatchBaseline.PatchFilterGroupProperty(\n            patch_filters=[ssm.CfnPatchBaseline.PatchFilterProperty(\n                key="key",\n                values=["values"]\n            )]\n        ),\n        operating_system="operatingSystem",\n        patch_groups=["patchGroups"],\n        rejected_patches=["rejectedPatches"],\n        rejected_patches_action="rejectedPatchesAction",\n        sources=[ssm.CfnPatchBaseline.PatchSourceProperty(\n            configuration="configuration",\n            name="name",\n            products=["products"]\n        )],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'approval_rules', 'approved_patches', 'approved_patches_compliance_level', 'approved_patches_enable_non_security', 'description', 'global_filters', 'operating_system', 'patch_groups', 'rejected_patches', 'rejected_patches_action', 'sources', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnPatchBaselineProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnResourceDataSyncProps
class CfnResourceDataSyncPropsDef(BaseCfnProperty):
    sync_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='')
    bucket_name: typing.Optional[str] = pydantic.Field(None, description='The name of the S3 bucket where the aggregated data is stored.\n')
    bucket_prefix: typing.Optional[str] = pydantic.Field(None, description='An Amazon S3 prefix for the bucket.\n')
    bucket_region: typing.Optional[str] = pydantic.Field(None, description='The AWS Region with the S3 bucket targeted by the resource data sync.\n')
    kms_key_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of an encryption key for a destination in Amazon S3 . You can use a KMS key to encrypt inventory data in Amazon S3 . You must specify a key that exist in the same region as the destination Amazon S3 bucket.\n')
    s3_destination: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnResourceDataSync_S3DestinationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configuration information for the target S3 bucket.\n')
    sync_format: typing.Optional[str] = pydantic.Field(None, description='A supported sync format. The following format is currently supported: JsonSerDe\n')
    sync_source: typing.Union[models.UnsupportedResource, models.aws_ssm.CfnResourceDataSync_SyncSourcePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about the source where the data was synchronized.\n')
    sync_type: typing.Optional[str] = pydantic.Field(None, description='The type of resource data sync. If ``SyncType`` is ``SyncToDestination`` , then the resource data sync synchronizes data to an S3 bucket. If the ``SyncType`` is ``SyncFromSource`` then the resource data sync synchronizes data from AWS Organizations or from multiple AWS Regions .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-resourcedatasync.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    cfn_resource_data_sync_props = ssm.CfnResourceDataSyncProps(\n        sync_name="syncName",\n\n        # the properties below are optional\n        bucket_name="bucketName",\n        bucket_prefix="bucketPrefix",\n        bucket_region="bucketRegion",\n        kms_key_arn="kmsKeyArn",\n        s3_destination=ssm.CfnResourceDataSync.S3DestinationProperty(\n            bucket_name="bucketName",\n            bucket_region="bucketRegion",\n            sync_format="syncFormat",\n\n            # the properties below are optional\n            bucket_prefix="bucketPrefix",\n            kms_key_arn="kmsKeyArn"\n        ),\n        sync_format="syncFormat",\n        sync_source=ssm.CfnResourceDataSync.SyncSourceProperty(\n            source_regions=["sourceRegions"],\n            source_type="sourceType",\n\n            # the properties below are optional\n            aws_organizations_source=ssm.CfnResourceDataSync.AwsOrganizationsSourceProperty(\n                organization_source_type="organizationSourceType",\n\n                # the properties below are optional\n                organizational_units=["organizationalUnits"]\n            ),\n            include_future_regions=False\n        ),\n        sync_type="syncType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['sync_name', 'bucket_name', 'bucket_prefix', 'bucket_region', 'kms_key_arn', 's3_destination', 'sync_format', 'sync_source', 'sync_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnResourceDataSyncProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ssm.CfnResourcePolicyProps
class CfnResourcePolicyPropsDef(BaseCfnProperty):
    policy: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A policy you want to associate with a resource.\n')
    resource_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Amazon Resource Name (ARN) of the resource to which you want to attach a policy.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-resourcepolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ssm as ssm\n\n    # policy: Any\n\n    cfn_resource_policy_props = ssm.CfnResourcePolicyProps(\n        policy=policy,\n        resource_arn="resourceArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['policy', 'resource_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ssm.CfnResourcePolicyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    StringListParameter: typing.Optional[dict[str, models.aws_ssm.StringListParameterDef]] = pydantic.Field(None)
    StringParameter: typing.Optional[dict[str, models.aws_ssm.StringParameterDef]] = pydantic.Field(None)
    CfnAssociation_InstanceAssociationOutputLocationProperty: typing.Optional[dict[str, models.aws_ssm.CfnAssociation_InstanceAssociationOutputLocationPropertyDef]] = pydantic.Field(None)
    CfnAssociation_S3OutputLocationProperty: typing.Optional[dict[str, models.aws_ssm.CfnAssociation_S3OutputLocationPropertyDef]] = pydantic.Field(None)
    CfnAssociation_TargetProperty: typing.Optional[dict[str, models.aws_ssm.CfnAssociation_TargetPropertyDef]] = pydantic.Field(None)
    CfnDocument_AttachmentsSourceProperty: typing.Optional[dict[str, models.aws_ssm.CfnDocument_AttachmentsSourcePropertyDef]] = pydantic.Field(None)
    CfnDocument_DocumentRequiresProperty: typing.Optional[dict[str, models.aws_ssm.CfnDocument_DocumentRequiresPropertyDef]] = pydantic.Field(None)
    CfnMaintenanceWindowTarget_TargetsProperty: typing.Optional[dict[str, models.aws_ssm.CfnMaintenanceWindowTarget_TargetsPropertyDef]] = pydantic.Field(None)
    CfnMaintenanceWindowTask_CloudWatchOutputConfigProperty: typing.Optional[dict[str, models.aws_ssm.CfnMaintenanceWindowTask_CloudWatchOutputConfigPropertyDef]] = pydantic.Field(None)
    CfnMaintenanceWindowTask_LoggingInfoProperty: typing.Optional[dict[str, models.aws_ssm.CfnMaintenanceWindowTask_LoggingInfoPropertyDef]] = pydantic.Field(None)
    CfnMaintenanceWindowTask_MaintenanceWindowAutomationParametersProperty: typing.Optional[dict[str, models.aws_ssm.CfnMaintenanceWindowTask_MaintenanceWindowAutomationParametersPropertyDef]] = pydantic.Field(None)
    CfnMaintenanceWindowTask_MaintenanceWindowLambdaParametersProperty: typing.Optional[dict[str, models.aws_ssm.CfnMaintenanceWindowTask_MaintenanceWindowLambdaParametersPropertyDef]] = pydantic.Field(None)
    CfnMaintenanceWindowTask_MaintenanceWindowRunCommandParametersProperty: typing.Optional[dict[str, models.aws_ssm.CfnMaintenanceWindowTask_MaintenanceWindowRunCommandParametersPropertyDef]] = pydantic.Field(None)
    CfnMaintenanceWindowTask_MaintenanceWindowStepFunctionsParametersProperty: typing.Optional[dict[str, models.aws_ssm.CfnMaintenanceWindowTask_MaintenanceWindowStepFunctionsParametersPropertyDef]] = pydantic.Field(None)
    CfnMaintenanceWindowTask_NotificationConfigProperty: typing.Optional[dict[str, models.aws_ssm.CfnMaintenanceWindowTask_NotificationConfigPropertyDef]] = pydantic.Field(None)
    CfnMaintenanceWindowTask_TargetProperty: typing.Optional[dict[str, models.aws_ssm.CfnMaintenanceWindowTask_TargetPropertyDef]] = pydantic.Field(None)
    CfnMaintenanceWindowTask_TaskInvocationParametersProperty: typing.Optional[dict[str, models.aws_ssm.CfnMaintenanceWindowTask_TaskInvocationParametersPropertyDef]] = pydantic.Field(None)
    CfnPatchBaseline_PatchFilterGroupProperty: typing.Optional[dict[str, models.aws_ssm.CfnPatchBaseline_PatchFilterGroupPropertyDef]] = pydantic.Field(None)
    CfnPatchBaseline_PatchFilterProperty: typing.Optional[dict[str, models.aws_ssm.CfnPatchBaseline_PatchFilterPropertyDef]] = pydantic.Field(None)
    CfnPatchBaseline_PatchSourceProperty: typing.Optional[dict[str, models.aws_ssm.CfnPatchBaseline_PatchSourcePropertyDef]] = pydantic.Field(None)
    CfnPatchBaseline_RuleGroupProperty: typing.Optional[dict[str, models.aws_ssm.CfnPatchBaseline_RuleGroupPropertyDef]] = pydantic.Field(None)
    CfnPatchBaseline_RuleProperty: typing.Optional[dict[str, models.aws_ssm.CfnPatchBaseline_RulePropertyDef]] = pydantic.Field(None)
    CfnResourceDataSync_AwsOrganizationsSourceProperty: typing.Optional[dict[str, models.aws_ssm.CfnResourceDataSync_AwsOrganizationsSourcePropertyDef]] = pydantic.Field(None)
    CfnResourceDataSync_S3DestinationProperty: typing.Optional[dict[str, models.aws_ssm.CfnResourceDataSync_S3DestinationPropertyDef]] = pydantic.Field(None)
    CfnResourceDataSync_SyncSourceProperty: typing.Optional[dict[str, models.aws_ssm.CfnResourceDataSync_SyncSourcePropertyDef]] = pydantic.Field(None)
    CommonStringParameterAttributes: typing.Optional[dict[str, models.aws_ssm.CommonStringParameterAttributesDef]] = pydantic.Field(None)
    ListParameterAttributes: typing.Optional[dict[str, models.aws_ssm.ListParameterAttributesDef]] = pydantic.Field(None)
    ParameterOptions: typing.Optional[dict[str, models.aws_ssm.ParameterOptionsDef]] = pydantic.Field(None)
    SecureStringParameterAttributes: typing.Optional[dict[str, models.aws_ssm.SecureStringParameterAttributesDef]] = pydantic.Field(None)
    StringListParameterProps: typing.Optional[dict[str, models.aws_ssm.StringListParameterPropsDef]] = pydantic.Field(None)
    StringParameterAttributes: typing.Optional[dict[str, models.aws_ssm.StringParameterAttributesDef]] = pydantic.Field(None)
    StringParameterProps: typing.Optional[dict[str, models.aws_ssm.StringParameterPropsDef]] = pydantic.Field(None)
    CfnAssociation: typing.Optional[dict[str, models.aws_ssm.CfnAssociationDef]] = pydantic.Field(None)
    CfnDocument: typing.Optional[dict[str, models.aws_ssm.CfnDocumentDef]] = pydantic.Field(None)
    CfnMaintenanceWindow: typing.Optional[dict[str, models.aws_ssm.CfnMaintenanceWindowDef]] = pydantic.Field(None)
    CfnMaintenanceWindowTarget: typing.Optional[dict[str, models.aws_ssm.CfnMaintenanceWindowTargetDef]] = pydantic.Field(None)
    CfnMaintenanceWindowTask: typing.Optional[dict[str, models.aws_ssm.CfnMaintenanceWindowTaskDef]] = pydantic.Field(None)
    CfnParameter: typing.Optional[dict[str, models.aws_ssm.CfnParameterDef]] = pydantic.Field(None)
    CfnPatchBaseline: typing.Optional[dict[str, models.aws_ssm.CfnPatchBaselineDef]] = pydantic.Field(None)
    CfnResourceDataSync: typing.Optional[dict[str, models.aws_ssm.CfnResourceDataSyncDef]] = pydantic.Field(None)
    CfnResourcePolicy: typing.Optional[dict[str, models.aws_ssm.CfnResourcePolicyDef]] = pydantic.Field(None)
    CfnAssociationProps: typing.Optional[dict[str, models.aws_ssm.CfnAssociationPropsDef]] = pydantic.Field(None)
    CfnDocumentProps: typing.Optional[dict[str, models.aws_ssm.CfnDocumentPropsDef]] = pydantic.Field(None)
    CfnMaintenanceWindowProps: typing.Optional[dict[str, models.aws_ssm.CfnMaintenanceWindowPropsDef]] = pydantic.Field(None)
    CfnMaintenanceWindowTargetProps: typing.Optional[dict[str, models.aws_ssm.CfnMaintenanceWindowTargetPropsDef]] = pydantic.Field(None)
    CfnMaintenanceWindowTaskProps: typing.Optional[dict[str, models.aws_ssm.CfnMaintenanceWindowTaskPropsDef]] = pydantic.Field(None)
    CfnParameterProps: typing.Optional[dict[str, models.aws_ssm.CfnParameterPropsDef]] = pydantic.Field(None)
    CfnPatchBaselineProps: typing.Optional[dict[str, models.aws_ssm.CfnPatchBaselinePropsDef]] = pydantic.Field(None)
    CfnResourceDataSyncProps: typing.Optional[dict[str, models.aws_ssm.CfnResourceDataSyncPropsDef]] = pydantic.Field(None)
    CfnResourcePolicyProps: typing.Optional[dict[str, models.aws_ssm.CfnResourcePolicyPropsDef]] = pydantic.Field(None)
    ...

import models
