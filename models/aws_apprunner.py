from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams

#  autogenerated from aws_cdk.aws_apprunner.CfnObservabilityConfiguration.TraceConfigurationProperty
class CfnObservabilityConfiguration_TraceConfigurationPropertyDef(BaseStruct):
    vendor: str = pydantic.Field(..., description='The implementation provider chosen for tracing App Runner services.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apprunner-observabilityconfiguration-traceconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    trace_configuration_property = apprunner.CfnObservabilityConfiguration.TraceConfigurationProperty(\n        vendor="vendor"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['vendor']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnObservabilityConfiguration.TraceConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apprunner.CfnService.AuthenticationConfigurationProperty
class CfnService_AuthenticationConfigurationPropertyDef(BaseStruct):
    access_role_arn: typing.Optional[str] = pydantic.Field(None, description="The Amazon Resource Name (ARN) of the IAM role that grants the App Runner service access to a source repository. It's required for ECR image repositories (but not for ECR Public repositories).\n")
    connection_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the App Runner connection that enables the App Runner service to connect to a source repository. It\'s required for GitHub code repositories.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apprunner-service-authenticationconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    authentication_configuration_property = apprunner.CfnService.AuthenticationConfigurationProperty(\n        access_role_arn="accessRoleArn",\n        connection_arn="connectionArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['access_role_arn', 'connection_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnService.AuthenticationConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apprunner.CfnService.CodeConfigurationProperty
class CfnService_CodeConfigurationPropertyDef(BaseStruct):
    configuration_source: str = pydantic.Field(..., description='The source of the App Runner configuration. Values are interpreted as follows:. - ``REPOSITORY`` – App Runner reads configuration values from the ``apprunner.yaml`` file in the source code repository and ignores ``CodeConfigurationValues`` . - ``API`` – App Runner uses configuration values provided in ``CodeConfigurationValues`` and ignores the ``apprunner.yaml`` file in the source code repository.\n')
    code_configuration_values: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_CodeConfigurationValuesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The basic configuration for building and running the App Runner service. Use it to quickly launch an App Runner service without providing a ``apprunner.yaml`` file in the source code repository (or ignoring the file if it exists).\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apprunner-service-codeconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    code_configuration_property = apprunner.CfnService.CodeConfigurationProperty(\n        configuration_source="configurationSource",\n\n        # the properties below are optional\n        code_configuration_values=apprunner.CfnService.CodeConfigurationValuesProperty(\n            runtime="runtime",\n\n            # the properties below are optional\n            build_command="buildCommand",\n            port="port",\n            runtime_environment_secrets=[apprunner.CfnService.KeyValuePairProperty(\n                name="name",\n                value="value"\n            )],\n            runtime_environment_variables=[apprunner.CfnService.KeyValuePairProperty(\n                name="name",\n                value="value"\n            )],\n            start_command="startCommand"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['configuration_source', 'code_configuration_values']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnService.CodeConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apprunner.CfnService.CodeConfigurationValuesProperty
class CfnService_CodeConfigurationValuesPropertyDef(BaseStruct):
    runtime: str = pydantic.Field(..., description='A runtime environment type for building and running an App Runner service. It represents a programming language runtime.\n')
    build_command: typing.Optional[str] = pydantic.Field(None, description='The command App Runner runs to build your application.\n')
    port: typing.Optional[str] = pydantic.Field(None, description='The port that your application listens to in the container. Default: ``8080``\n')
    runtime_environment_secrets: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_KeyValuePairPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='``CfnService.CodeConfigurationValuesProperty.RuntimeEnvironmentSecrets``.\n')
    runtime_environment_variables: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_KeyValuePairPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The environment variables that are available to your running AWS App Runner service. An array of key-value pairs.\n')
    start_command: typing.Optional[str] = pydantic.Field(None, description='The command App Runner runs to start your application.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apprunner-service-codeconfigurationvalues.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    code_configuration_values_property = apprunner.CfnService.CodeConfigurationValuesProperty(\n        runtime="runtime",\n\n        # the properties below are optional\n        build_command="buildCommand",\n        port="port",\n        runtime_environment_secrets=[apprunner.CfnService.KeyValuePairProperty(\n            name="name",\n            value="value"\n        )],\n        runtime_environment_variables=[apprunner.CfnService.KeyValuePairProperty(\n            name="name",\n            value="value"\n        )],\n        start_command="startCommand"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['runtime', 'build_command', 'port', 'runtime_environment_secrets', 'runtime_environment_variables', 'start_command']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnService.CodeConfigurationValuesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apprunner.CfnService.CodeRepositoryProperty
class CfnService_CodeRepositoryPropertyDef(BaseStruct):
    repository_url: str = pydantic.Field(..., description='The location of the repository that contains the source code.\n')
    source_code_version: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_SourceCodeVersionPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The version that should be used within the source code repository.\n')
    code_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_CodeConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configuration for building and running the service from a source code repository. .. epigraph:: ``CodeConfiguration`` is required only for ``CreateService`` request.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apprunner-service-coderepository.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    code_repository_property = apprunner.CfnService.CodeRepositoryProperty(\n        repository_url="repositoryUrl",\n        source_code_version=apprunner.CfnService.SourceCodeVersionProperty(\n            type="type",\n            value="value"\n        ),\n\n        # the properties below are optional\n        code_configuration=apprunner.CfnService.CodeConfigurationProperty(\n            configuration_source="configurationSource",\n\n            # the properties below are optional\n            code_configuration_values=apprunner.CfnService.CodeConfigurationValuesProperty(\n                runtime="runtime",\n\n                # the properties below are optional\n                build_command="buildCommand",\n                port="port",\n                runtime_environment_secrets=[apprunner.CfnService.KeyValuePairProperty(\n                    name="name",\n                    value="value"\n                )],\n                runtime_environment_variables=[apprunner.CfnService.KeyValuePairProperty(\n                    name="name",\n                    value="value"\n                )],\n                start_command="startCommand"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['repository_url', 'source_code_version', 'code_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnService.CodeRepositoryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apprunner.CfnService.EgressConfigurationProperty
class CfnService_EgressConfigurationPropertyDef(BaseStruct):
    egress_type: str = pydantic.Field(..., description='The type of egress configuration. Set to ``DEFAULT`` for access to resources hosted on public networks. Set to ``VPC`` to associate your service to a custom VPC specified by ``VpcConnectorArn`` .\n')
    vpc_connector_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the App Runner VPC connector that you want to associate with your App Runner service. Only valid when ``EgressType = VPC`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apprunner-service-egressconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    egress_configuration_property = apprunner.CfnService.EgressConfigurationProperty(\n        egress_type="egressType",\n\n        # the properties below are optional\n        vpc_connector_arn="vpcConnectorArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['egress_type', 'vpc_connector_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnService.EgressConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apprunner.CfnService.EncryptionConfigurationProperty
class CfnService_EncryptionConfigurationPropertyDef(BaseStruct):
    kms_key: str = pydantic.Field(..., description='The ARN of the KMS key that\'s used for encryption.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apprunner-service-encryptionconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    encryption_configuration_property = apprunner.CfnService.EncryptionConfigurationProperty(\n        kms_key="kmsKey"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['kms_key']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnService.EncryptionConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apprunner.CfnService.HealthCheckConfigurationProperty
class CfnService_HealthCheckConfigurationPropertyDef(BaseStruct):
    healthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The number of consecutive checks that must succeed before App Runner decides that the service is healthy. Default: ``1``\n')
    interval: typing.Union[int, float, None] = pydantic.Field(None, description='The time interval, in seconds, between health checks. Default: ``5``\n')
    path: typing.Optional[str] = pydantic.Field(None, description='The URL that health check requests are sent to. ``Path`` is only applicable when you set ``Protocol`` to ``HTTP`` . Default: ``"/"``\n')
    protocol: typing.Optional[str] = pydantic.Field(None, description='The IP protocol that App Runner uses to perform health checks for your service. If you set ``Protocol`` to ``HTTP`` , App Runner sends health check requests to the HTTP path specified by ``Path`` . Default: ``TCP``\n')
    timeout: typing.Union[int, float, None] = pydantic.Field(None, description='The time, in seconds, to wait for a health check response before deciding it failed. Default: ``2``\n')
    unhealthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='The number of consecutive checks that must fail before App Runner decides that the service is unhealthy. Default: ``5``\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apprunner-service-healthcheckconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    health_check_configuration_property = apprunner.CfnService.HealthCheckConfigurationProperty(\n        healthy_threshold=123,\n        interval=123,\n        path="path",\n        protocol="protocol",\n        timeout=123,\n        unhealthy_threshold=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['healthy_threshold', 'interval', 'path', 'protocol', 'timeout', 'unhealthy_threshold']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnService.HealthCheckConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apprunner.CfnService.ImageConfigurationProperty
class CfnService_ImageConfigurationPropertyDef(BaseStruct):
    port: typing.Optional[str] = pydantic.Field(None, description='The port that your application listens to in the container. Default: ``8080``\n')
    runtime_environment_secrets: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_KeyValuePairPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='``CfnService.ImageConfigurationProperty.RuntimeEnvironmentSecrets``.\n')
    runtime_environment_variables: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_KeyValuePairPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Environment variables that are available to your running App Runner service. An array of key-value pairs.\n')
    start_command: typing.Optional[str] = pydantic.Field(None, description='An optional command that App Runner runs to start the application in the source image. If specified, this command overrides the Docker image’s default start command.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apprunner-service-imageconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    image_configuration_property = apprunner.CfnService.ImageConfigurationProperty(\n        port="port",\n        runtime_environment_secrets=[apprunner.CfnService.KeyValuePairProperty(\n            name="name",\n            value="value"\n        )],\n        runtime_environment_variables=[apprunner.CfnService.KeyValuePairProperty(\n            name="name",\n            value="value"\n        )],\n        start_command="startCommand"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['port', 'runtime_environment_secrets', 'runtime_environment_variables', 'start_command']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnService.ImageConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apprunner.CfnService.ImageRepositoryProperty
class CfnService_ImageRepositoryPropertyDef(BaseStruct):
    image_identifier: str = pydantic.Field(..., description='The identifier of an image. For an image in Amazon Elastic Container Registry (Amazon ECR), this is an image name. For the image name format, see `Pulling an image <https://docs.aws.amazon.com/AmazonECR/latest/userguide/docker-pull-ecr-image.html>`_ in the *Amazon ECR User Guide* .\n')
    image_repository_type: str = pydantic.Field(..., description='The type of the image repository. This reflects the repository provider and whether the repository is private or public.\n')
    image_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_ImageConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configuration for running the identified image.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apprunner-service-imagerepository.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    image_repository_property = apprunner.CfnService.ImageRepositoryProperty(\n        image_identifier="imageIdentifier",\n        image_repository_type="imageRepositoryType",\n\n        # the properties below are optional\n        image_configuration=apprunner.CfnService.ImageConfigurationProperty(\n            port="port",\n            runtime_environment_secrets=[apprunner.CfnService.KeyValuePairProperty(\n                name="name",\n                value="value"\n            )],\n            runtime_environment_variables=[apprunner.CfnService.KeyValuePairProperty(\n                name="name",\n                value="value"\n            )],\n            start_command="startCommand"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['image_identifier', 'image_repository_type', 'image_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnService.ImageRepositoryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apprunner.CfnService.IngressConfigurationProperty
class CfnService_IngressConfigurationPropertyDef(BaseStruct):
    is_publicly_accessible: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='Specifies whether your App Runner service is publicly accessible. To make the service publicly accessible set it to ``True`` . To make the service privately accessible, from only within an Amazon VPC set it to ``False`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apprunner-service-ingressconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    ingress_configuration_property = apprunner.CfnService.IngressConfigurationProperty(\n        is_publicly_accessible=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['is_publicly_accessible']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnService.IngressConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apprunner.CfnService.InstanceConfigurationProperty
class CfnService_InstanceConfigurationPropertyDef(BaseStruct):
    cpu: typing.Optional[str] = pydantic.Field(None, description='The number of CPU units reserved for each instance of your App Runner service. Default: ``1 vCPU``\n')
    instance_role_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of an IAM role that provides permissions to your App Runner service. These are permissions that your code needs when it calls any AWS APIs.\n')
    memory: typing.Optional[str] = pydantic.Field(None, description='The amount of memory, in MB or GB, reserved for each instance of your App Runner service. Default: ``2 GB``\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apprunner-service-instanceconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    instance_configuration_property = apprunner.CfnService.InstanceConfigurationProperty(\n        cpu="cpu",\n        instance_role_arn="instanceRoleArn",\n        memory="memory"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cpu', 'instance_role_arn', 'memory']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnService.InstanceConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apprunner.CfnService.KeyValuePairProperty
class CfnService_KeyValuePairPropertyDef(BaseStruct):
    name: typing.Optional[str] = pydantic.Field(None, description='The key name string to map to a value.\n')
    value: typing.Optional[str] = pydantic.Field(None, description='The value string to which the key name is mapped.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apprunner-service-keyvaluepair.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    key_value_pair_property = apprunner.CfnService.KeyValuePairProperty(\n        name="name",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnService.KeyValuePairProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apprunner.CfnService.NetworkConfigurationProperty
class CfnService_NetworkConfigurationPropertyDef(BaseStruct):
    egress_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_EgressConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Network configuration settings for outbound message traffic.\n')
    ingress_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_IngressConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Network configuration settings for inbound message traffic.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apprunner-service-networkconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    network_configuration_property = apprunner.CfnService.NetworkConfigurationProperty(\n        egress_configuration=apprunner.CfnService.EgressConfigurationProperty(\n            egress_type="egressType",\n\n            # the properties below are optional\n            vpc_connector_arn="vpcConnectorArn"\n        ),\n        ingress_configuration=apprunner.CfnService.IngressConfigurationProperty(\n            is_publicly_accessible=False\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['egress_configuration', 'ingress_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnService.NetworkConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apprunner.CfnService.ServiceObservabilityConfigurationProperty
class CfnService_ServiceObservabilityConfigurationPropertyDef(BaseStruct):
    observability_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='When ``true`` , an observability configuration resource is associated with the service, and an ``ObservabilityConfigurationArn`` is specified.\n')
    observability_configuration_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the observability configuration that is associated with the service. Specified only when ``ObservabilityEnabled`` is ``true`` . Specify an ARN with a name and a revision number to associate that revision. For example: ``arn:aws:apprunner:us-east-1:123456789012:observabilityconfiguration/xray-tracing/3`` Specify just the name to associate the latest revision. For example: ``arn:aws:apprunner:us-east-1:123456789012:observabilityconfiguration/xray-tracing``\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apprunner-service-serviceobservabilityconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    service_observability_configuration_property = apprunner.CfnService.ServiceObservabilityConfigurationProperty(\n        observability_enabled=False,\n\n        # the properties below are optional\n        observability_configuration_arn="observabilityConfigurationArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['observability_enabled', 'observability_configuration_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnService.ServiceObservabilityConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apprunner.CfnService.SourceCodeVersionProperty
class CfnService_SourceCodeVersionPropertyDef(BaseStruct):
    type: str = pydantic.Field(..., description='The type of version identifier. For a git-based repository, branches represent versions.\n')
    value: str = pydantic.Field(..., description='A source code version. For a git-based repository, a branch name maps to a specific version. App Runner uses the most recent commit to the branch.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apprunner-service-sourcecodeversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    source_code_version_property = apprunner.CfnService.SourceCodeVersionProperty(\n        type="type",\n        value="value"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnService.SourceCodeVersionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apprunner.CfnService.SourceConfigurationProperty
class CfnService_SourceConfigurationPropertyDef(BaseStruct):
    authentication_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_AuthenticationConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Describes the resources that are needed to authenticate access to some source repositories.\n')
    auto_deployments_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="If ``true`` , continuous integration from the source repository is enabled for the App Runner service. Each repository change (including any source code commit or new image version) starts a deployment. Default: App Runner sets to ``false`` for a source image that uses an ECR Public repository or an ECR repository that's in an AWS account other than the one that the service is in. App Runner sets to ``true`` in all other cases (which currently include a source code repository or a source image using a same-account ECR repository).\n")
    code_repository: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_CodeRepositoryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The description of a source code repository. You must provide either this member or ``ImageRepository`` (but not both).\n')
    image_repository: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_ImageRepositoryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The description of a source image repository. You must provide either this member or ``CodeRepository`` (but not both).\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apprunner-service-sourceconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    source_configuration_property = apprunner.CfnService.SourceConfigurationProperty(\n        authentication_configuration=apprunner.CfnService.AuthenticationConfigurationProperty(\n            access_role_arn="accessRoleArn",\n            connection_arn="connectionArn"\n        ),\n        auto_deployments_enabled=False,\n        code_repository=apprunner.CfnService.CodeRepositoryProperty(\n            repository_url="repositoryUrl",\n            source_code_version=apprunner.CfnService.SourceCodeVersionProperty(\n                type="type",\n                value="value"\n            ),\n\n            # the properties below are optional\n            code_configuration=apprunner.CfnService.CodeConfigurationProperty(\n                configuration_source="configurationSource",\n\n                # the properties below are optional\n                code_configuration_values=apprunner.CfnService.CodeConfigurationValuesProperty(\n                    runtime="runtime",\n\n                    # the properties below are optional\n                    build_command="buildCommand",\n                    port="port",\n                    runtime_environment_secrets=[apprunner.CfnService.KeyValuePairProperty(\n                        name="name",\n                        value="value"\n                    )],\n                    runtime_environment_variables=[apprunner.CfnService.KeyValuePairProperty(\n                        name="name",\n                        value="value"\n                    )],\n                    start_command="startCommand"\n                )\n            )\n        ),\n        image_repository=apprunner.CfnService.ImageRepositoryProperty(\n            image_identifier="imageIdentifier",\n            image_repository_type="imageRepositoryType",\n\n            # the properties below are optional\n            image_configuration=apprunner.CfnService.ImageConfigurationProperty(\n                port="port",\n                runtime_environment_secrets=[apprunner.CfnService.KeyValuePairProperty(\n                    name="name",\n                    value="value"\n                )],\n                runtime_environment_variables=[apprunner.CfnService.KeyValuePairProperty(\n                    name="name",\n                    value="value"\n                )],\n                start_command="startCommand"\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['authentication_configuration', 'auto_deployments_enabled', 'code_repository', 'image_repository']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnService.SourceConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apprunner.CfnVpcIngressConnection.IngressVpcConfigurationProperty
class CfnVpcIngressConnection_IngressVpcConfigurationPropertyDef(BaseStruct):
    vpc_endpoint_id: str = pydantic.Field(..., description='The ID of the VPC endpoint that your App Runner service connects to.\n')
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC that is used for the VPC endpoint.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apprunner-vpcingressconnection-ingressvpcconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    ingress_vpc_configuration_property = apprunner.CfnVpcIngressConnection.IngressVpcConfigurationProperty(\n        vpc_endpoint_id="vpcEndpointId",\n        vpc_id="vpcId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['vpc_endpoint_id', 'vpc_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnVpcIngressConnection.IngressVpcConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apprunner.CfnObservabilityConfiguration
class CfnObservabilityConfigurationDef(BaseCfnResource):
    observability_configuration_name: typing.Optional[str] = pydantic.Field(None, description="A name for the observability configuration. When you use it for the first time in an AWS Region , App Runner creates revision number ``1`` of this name. When you use the same name in subsequent calls, App Runner creates incremental revisions of the configuration. .. epigraph:: The name ``DefaultConfiguration`` is reserved. You can't use it to create a new observability configuration, and you can't create a revision of it. When you want to use your own observability configuration for your App Runner service, *create a configuration with a different name* , and then provide it when you create or update your service. If you don't specify a name, AWS CloudFormation generates a name for your observability configuration.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of metadata items that you can associate with your observability configuration resource. A tag is a key-value pair.\n')
    trace_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnObservabilityConfiguration_TraceConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The configuration of the tracing feature within this observability configuration. If you don't specify it, App Runner doesn't enable tracing.")
    _init_params: typing.ClassVar[list[str]] = ['observability_configuration_name', 'tags', 'trace_configuration']
    _method_names: typing.ClassVar[list[str]] = ['TraceConfigurationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnObservabilityConfiguration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnObservabilityConfigurationDefConfig] = pydantic.Field(None)


class CfnObservabilityConfigurationDefConfig(pydantic.BaseModel):
    TraceConfigurationProperty: typing.Optional[list[CfnObservabilityConfigurationDefTraceconfigurationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnObservabilityConfigurationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnObservabilityConfigurationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnObservabilityConfigurationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnObservabilityConfigurationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnObservabilityConfigurationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnObservabilityConfigurationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnObservabilityConfigurationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnObservabilityConfigurationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnObservabilityConfigurationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnObservabilityConfigurationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnObservabilityConfigurationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnObservabilityConfigurationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnObservabilityConfigurationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_latest_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnObservabilityConfigurationDefTraceconfigurationpropertyParams(pydantic.BaseModel):
    vendor: str = pydantic.Field(..., description='')
    ...

class CfnObservabilityConfigurationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnObservabilityConfigurationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnObservabilityConfigurationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnObservabilityConfigurationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnObservabilityConfigurationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnObservabilityConfigurationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnObservabilityConfigurationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnObservabilityConfigurationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnObservabilityConfigurationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnObservabilityConfigurationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnObservabilityConfigurationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnObservabilityConfigurationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnObservabilityConfigurationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnObservabilityConfigurationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apprunner.CfnService
class CfnServiceDef(BaseCfnResource):
    source_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_SourceConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The source to deploy to the App Runner service. It can be a code or an image repository.\n')
    auto_scaling_configuration_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of an App Runner automatic scaling configuration resource that you want to associate with your service. If not provided, App Runner associates the latest revision of a default auto scaling configuration. Specify an ARN with a name and a revision number to associate that revision. For example: ``arn:aws:apprunner:us-east-1:123456789012:autoscalingconfiguration/high-availability/3`` Specify just the name to associate the latest revision. For example: ``arn:aws:apprunner:us-east-1:123456789012:autoscalingconfiguration/high-availability``\n')
    encryption_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_EncryptionConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An optional custom encryption key that App Runner uses to encrypt the copy of your source repository that it maintains and your service logs. By default, App Runner uses an AWS managed key .\n')
    health_check_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_HealthCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The settings for the health check that AWS App Runner performs to monitor the health of the App Runner service.\n')
    instance_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_InstanceConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The runtime configuration of instances (scaling units) of your service.\n')
    network_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_NetworkConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configuration settings related to network traffic of the web application that the App Runner service runs.\n')
    observability_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_ServiceObservabilityConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The observability configuration of your service.\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description="A name for the App Runner service. It must be unique across all the running App Runner services in your AWS account in the AWS Region . If you don't specify a name, AWS CloudFormation generates a name for your service.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An optional list of metadata items that you can associate with the App Runner service resource. A tag is a key-value pair.')
    _init_params: typing.ClassVar[list[str]] = ['source_configuration', 'auto_scaling_configuration_arn', 'encryption_configuration', 'health_check_configuration', 'instance_configuration', 'network_configuration', 'observability_configuration', 'service_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['AuthenticationConfigurationProperty', 'CodeConfigurationProperty', 'CodeConfigurationValuesProperty', 'CodeRepositoryProperty', 'EgressConfigurationProperty', 'EncryptionConfigurationProperty', 'HealthCheckConfigurationProperty', 'ImageConfigurationProperty', 'ImageRepositoryProperty', 'IngressConfigurationProperty', 'InstanceConfigurationProperty', 'KeyValuePairProperty', 'NetworkConfigurationProperty', 'ServiceObservabilityConfigurationProperty', 'SourceCodeVersionProperty', 'SourceConfigurationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnService'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnServiceDefConfig] = pydantic.Field(None)


class CfnServiceDefConfig(pydantic.BaseModel):
    AuthenticationConfigurationProperty: typing.Optional[list[CfnServiceDefAuthenticationconfigurationpropertyParams]] = pydantic.Field(None, description='')
    CodeConfigurationProperty: typing.Optional[list[CfnServiceDefCodeconfigurationpropertyParams]] = pydantic.Field(None, description='')
    CodeConfigurationValuesProperty: typing.Optional[list[CfnServiceDefCodeconfigurationvaluespropertyParams]] = pydantic.Field(None, description='')
    CodeRepositoryProperty: typing.Optional[list[CfnServiceDefCoderepositorypropertyParams]] = pydantic.Field(None, description='')
    EgressConfigurationProperty: typing.Optional[list[CfnServiceDefEgressconfigurationpropertyParams]] = pydantic.Field(None, description='')
    EncryptionConfigurationProperty: typing.Optional[list[CfnServiceDefEncryptionconfigurationpropertyParams]] = pydantic.Field(None, description='')
    HealthCheckConfigurationProperty: typing.Optional[list[CfnServiceDefHealthcheckconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ImageConfigurationProperty: typing.Optional[list[CfnServiceDefImageconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ImageRepositoryProperty: typing.Optional[list[CfnServiceDefImagerepositorypropertyParams]] = pydantic.Field(None, description='')
    IngressConfigurationProperty: typing.Optional[list[CfnServiceDefIngressconfigurationpropertyParams]] = pydantic.Field(None, description='')
    InstanceConfigurationProperty: typing.Optional[list[CfnServiceDefInstanceconfigurationpropertyParams]] = pydantic.Field(None, description='')
    KeyValuePairProperty: typing.Optional[list[CfnServiceDefKeyvaluepairpropertyParams]] = pydantic.Field(None, description='')
    NetworkConfigurationProperty: typing.Optional[list[CfnServiceDefNetworkconfigurationpropertyParams]] = pydantic.Field(None, description='')
    ServiceObservabilityConfigurationProperty: typing.Optional[list[CfnServiceDefServiceobservabilityconfigurationpropertyParams]] = pydantic.Field(None, description='')
    SourceCodeVersionProperty: typing.Optional[list[CfnServiceDefSourcecodeversionpropertyParams]] = pydantic.Field(None, description='')
    SourceConfigurationProperty: typing.Optional[list[CfnServiceDefSourceconfigurationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnServiceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnServiceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnServiceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnServiceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnServiceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnServiceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnServiceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnServiceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnServiceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnServiceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnServiceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnServiceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnServiceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnServiceDefAuthenticationconfigurationpropertyParams(pydantic.BaseModel):
    access_role_arn: typing.Optional[str] = pydantic.Field(None, description='')
    connection_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnServiceDefCodeconfigurationpropertyParams(pydantic.BaseModel):
    configuration_source: str = pydantic.Field(..., description='')
    code_configuration_values: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_CodeConfigurationValuesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnServiceDefCodeconfigurationvaluespropertyParams(pydantic.BaseModel):
    runtime: str = pydantic.Field(..., description='')
    build_command: typing.Optional[str] = pydantic.Field(None, description='')
    port: typing.Optional[str] = pydantic.Field(None, description='')
    runtime_environment_secrets: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_KeyValuePairPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    runtime_environment_variables: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_KeyValuePairPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    start_command: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnServiceDefCoderepositorypropertyParams(pydantic.BaseModel):
    repository_url: str = pydantic.Field(..., description='')
    source_code_version: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_SourceCodeVersionPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    code_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_CodeConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnServiceDefEgressconfigurationpropertyParams(pydantic.BaseModel):
    egress_type: str = pydantic.Field(..., description='')
    vpc_connector_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnServiceDefEncryptionconfigurationpropertyParams(pydantic.BaseModel):
    kms_key: str = pydantic.Field(..., description='')
    ...

class CfnServiceDefHealthcheckconfigurationpropertyParams(pydantic.BaseModel):
    healthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='')
    interval: typing.Union[int, float, None] = pydantic.Field(None, description='')
    path: typing.Optional[str] = pydantic.Field(None, description='')
    protocol: typing.Optional[str] = pydantic.Field(None, description='')
    timeout: typing.Union[int, float, None] = pydantic.Field(None, description='')
    unhealthy_threshold: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnServiceDefImageconfigurationpropertyParams(pydantic.BaseModel):
    port: typing.Optional[str] = pydantic.Field(None, description='')
    runtime_environment_secrets: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_KeyValuePairPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    runtime_environment_variables: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_KeyValuePairPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    start_command: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnServiceDefImagerepositorypropertyParams(pydantic.BaseModel):
    image_identifier: str = pydantic.Field(..., description='')
    image_repository_type: str = pydantic.Field(..., description='')
    image_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_ImageConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnServiceDefIngressconfigurationpropertyParams(pydantic.BaseModel):
    is_publicly_accessible: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='')
    ...

class CfnServiceDefInstanceconfigurationpropertyParams(pydantic.BaseModel):
    cpu: typing.Optional[str] = pydantic.Field(None, description='')
    instance_role_arn: typing.Optional[str] = pydantic.Field(None, description='')
    memory: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnServiceDefKeyvaluepairpropertyParams(pydantic.BaseModel):
    name: typing.Optional[str] = pydantic.Field(None, description='')
    value: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnServiceDefNetworkconfigurationpropertyParams(pydantic.BaseModel):
    egress_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_EgressConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ingress_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_IngressConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnServiceDefServiceobservabilityconfigurationpropertyParams(pydantic.BaseModel):
    observability_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='')
    observability_configuration_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnServiceDefSourcecodeversionpropertyParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='')
    value: str = pydantic.Field(..., description='')
    ...

class CfnServiceDefSourceconfigurationpropertyParams(pydantic.BaseModel):
    authentication_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_AuthenticationConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    auto_deployments_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    code_repository: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_CodeRepositoryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    image_repository: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_ImageRepositoryPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnServiceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnServiceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnServiceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnServiceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnServiceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnServiceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnServiceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnServiceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnServiceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnServiceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnServiceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnServiceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnServiceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnServiceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apprunner.CfnVpcConnector
class CfnVpcConnectorDef(BaseCfnResource):
    subnets: typing.Sequence[str] = pydantic.Field(..., description='A list of IDs of subnets that App Runner should use when it associates your service with a custom Amazon VPC. Specify IDs of subnets of a single Amazon VPC. App Runner determines the Amazon VPC from the subnets you specify. .. epigraph:: App Runner currently only provides support for IPv4.\n')
    security_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of IDs of security groups that App Runner should use for access to AWS resources under the specified subnets. If not specified, App Runner uses the default security group of the Amazon VPC. The default security group allows all outbound traffic.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of metadata items that you can associate with your VPC connector resource. A tag is a key-value pair.\n')
    vpc_connector_name: typing.Optional[str] = pydantic.Field(None, description="A name for the VPC connector. If you don't specify a name, AWS CloudFormation generates a name for your VPC connector.")
    _init_params: typing.ClassVar[list[str]] = ['subnets', 'security_groups', 'tags', 'vpc_connector_name']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnVpcConnector'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVpcConnectorDefConfig] = pydantic.Field(None)


class CfnVpcConnectorDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnVpcConnectorDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVpcConnectorDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVpcConnectorDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVpcConnectorDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVpcConnectorDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVpcConnectorDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVpcConnectorDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVpcConnectorDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVpcConnectorDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVpcConnectorDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVpcConnectorDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVpcConnectorDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVpcConnectorDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnVpcConnectorDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVpcConnectorDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVpcConnectorDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVpcConnectorDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVpcConnectorDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVpcConnectorDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVpcConnectorDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVpcConnectorDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVpcConnectorDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVpcConnectorDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVpcConnectorDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVpcConnectorDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVpcConnectorDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVpcConnectorDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apprunner.CfnVpcIngressConnection
class CfnVpcIngressConnectionDef(BaseCfnResource):
    ingress_vpc_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnVpcIngressConnection_IngressVpcConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Specifications for the customer’s Amazon VPC and the related AWS PrivateLink VPC endpoint that are used to create the VPC Ingress Connection resource.\n')
    service_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) for this App Runner service that is used to create the VPC Ingress Connection resource.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An optional list of metadata items that you can associate with the VPC Ingress Connection resource. A tag is a key-value pair.\n')
    vpc_ingress_connection_name: typing.Optional[str] = pydantic.Field(None, description='The customer-provided VPC Ingress Connection name.')
    _init_params: typing.ClassVar[list[str]] = ['ingress_vpc_configuration', 'service_arn', 'tags', 'vpc_ingress_connection_name']
    _method_names: typing.ClassVar[list[str]] = ['IngressVpcConfigurationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnVpcIngressConnection'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVpcIngressConnectionDefConfig] = pydantic.Field(None)


class CfnVpcIngressConnectionDefConfig(pydantic.BaseModel):
    IngressVpcConfigurationProperty: typing.Optional[list[CfnVpcIngressConnectionDefIngressvpcconfigurationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnVpcIngressConnectionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVpcIngressConnectionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVpcIngressConnectionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVpcIngressConnectionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVpcIngressConnectionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVpcIngressConnectionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVpcIngressConnectionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVpcIngressConnectionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVpcIngressConnectionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVpcIngressConnectionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVpcIngressConnectionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVpcIngressConnectionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVpcIngressConnectionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnVpcIngressConnectionDefIngressvpcconfigurationpropertyParams(pydantic.BaseModel):
    vpc_endpoint_id: str = pydantic.Field(..., description='')
    vpc_id: str = pydantic.Field(..., description='')
    ...

class CfnVpcIngressConnectionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVpcIngressConnectionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVpcIngressConnectionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVpcIngressConnectionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVpcIngressConnectionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVpcIngressConnectionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVpcIngressConnectionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVpcIngressConnectionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVpcIngressConnectionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVpcIngressConnectionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVpcIngressConnectionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVpcIngressConnectionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVpcIngressConnectionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVpcIngressConnectionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_apprunner.CfnObservabilityConfigurationProps
class CfnObservabilityConfigurationPropsDef(BaseCfnProperty):
    observability_configuration_name: typing.Optional[str] = pydantic.Field(None, description="A name for the observability configuration. When you use it for the first time in an AWS Region , App Runner creates revision number ``1`` of this name. When you use the same name in subsequent calls, App Runner creates incremental revisions of the configuration. .. epigraph:: The name ``DefaultConfiguration`` is reserved. You can't use it to create a new observability configuration, and you can't create a revision of it. When you want to use your own observability configuration for your App Runner service, *create a configuration with a different name* , and then provide it when you create or update your service. If you don't specify a name, AWS CloudFormation generates a name for your observability configuration.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of metadata items that you can associate with your observability configuration resource. A tag is a key-value pair.\n')
    trace_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnObservabilityConfiguration_TraceConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The configuration of the tracing feature within this observability configuration. If you don\'t specify it, App Runner doesn\'t enable tracing.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apprunner-observabilityconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    cfn_observability_configuration_props = apprunner.CfnObservabilityConfigurationProps(\n        observability_configuration_name="observabilityConfigurationName",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        trace_configuration=apprunner.CfnObservabilityConfiguration.TraceConfigurationProperty(\n            vendor="vendor"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['observability_configuration_name', 'tags', 'trace_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnObservabilityConfigurationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apprunner.CfnServiceProps
class CfnServicePropsDef(BaseCfnProperty):
    source_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_SourceConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The source to deploy to the App Runner service. It can be a code or an image repository.\n')
    auto_scaling_configuration_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of an App Runner automatic scaling configuration resource that you want to associate with your service. If not provided, App Runner associates the latest revision of a default auto scaling configuration. Specify an ARN with a name and a revision number to associate that revision. For example: ``arn:aws:apprunner:us-east-1:123456789012:autoscalingconfiguration/high-availability/3`` Specify just the name to associate the latest revision. For example: ``arn:aws:apprunner:us-east-1:123456789012:autoscalingconfiguration/high-availability``\n')
    encryption_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_EncryptionConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='An optional custom encryption key that App Runner uses to encrypt the copy of your source repository that it maintains and your service logs. By default, App Runner uses an AWS managed key .\n')
    health_check_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_HealthCheckConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The settings for the health check that AWS App Runner performs to monitor the health of the App Runner service.\n')
    instance_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_InstanceConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The runtime configuration of instances (scaling units) of your service.\n')
    network_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_NetworkConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configuration settings related to network traffic of the web application that the App Runner service runs.\n')
    observability_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnService_ServiceObservabilityConfigurationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The observability configuration of your service.\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description="A name for the App Runner service. It must be unique across all the running App Runner services in your AWS account in the AWS Region . If you don't specify a name, AWS CloudFormation generates a name for your service.\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An optional list of metadata items that you can associate with the App Runner service resource. A tag is a key-value pair.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apprunner-service.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    cfn_service_props = apprunner.CfnServiceProps(\n        source_configuration=apprunner.CfnService.SourceConfigurationProperty(\n            authentication_configuration=apprunner.CfnService.AuthenticationConfigurationProperty(\n                access_role_arn="accessRoleArn",\n                connection_arn="connectionArn"\n            ),\n            auto_deployments_enabled=False,\n            code_repository=apprunner.CfnService.CodeRepositoryProperty(\n                repository_url="repositoryUrl",\n                source_code_version=apprunner.CfnService.SourceCodeVersionProperty(\n                    type="type",\n                    value="value"\n                ),\n\n                # the properties below are optional\n                code_configuration=apprunner.CfnService.CodeConfigurationProperty(\n                    configuration_source="configurationSource",\n\n                    # the properties below are optional\n                    code_configuration_values=apprunner.CfnService.CodeConfigurationValuesProperty(\n                        runtime="runtime",\n\n                        # the properties below are optional\n                        build_command="buildCommand",\n                        port="port",\n                        runtime_environment_secrets=[apprunner.CfnService.KeyValuePairProperty(\n                            name="name",\n                            value="value"\n                        )],\n                        runtime_environment_variables=[apprunner.CfnService.KeyValuePairProperty(\n                            name="name",\n                            value="value"\n                        )],\n                        start_command="startCommand"\n                    )\n                )\n            ),\n            image_repository=apprunner.CfnService.ImageRepositoryProperty(\n                image_identifier="imageIdentifier",\n                image_repository_type="imageRepositoryType",\n\n                # the properties below are optional\n                image_configuration=apprunner.CfnService.ImageConfigurationProperty(\n                    port="port",\n                    runtime_environment_secrets=[apprunner.CfnService.KeyValuePairProperty(\n                        name="name",\n                        value="value"\n                    )],\n                    runtime_environment_variables=[apprunner.CfnService.KeyValuePairProperty(\n                        name="name",\n                        value="value"\n                    )],\n                    start_command="startCommand"\n                )\n            )\n        ),\n\n        # the properties below are optional\n        auto_scaling_configuration_arn="autoScalingConfigurationArn",\n        encryption_configuration=apprunner.CfnService.EncryptionConfigurationProperty(\n            kms_key="kmsKey"\n        ),\n        health_check_configuration=apprunner.CfnService.HealthCheckConfigurationProperty(\n            healthy_threshold=123,\n            interval=123,\n            path="path",\n            protocol="protocol",\n            timeout=123,\n            unhealthy_threshold=123\n        ),\n        instance_configuration=apprunner.CfnService.InstanceConfigurationProperty(\n            cpu="cpu",\n            instance_role_arn="instanceRoleArn",\n            memory="memory"\n        ),\n        network_configuration=apprunner.CfnService.NetworkConfigurationProperty(\n            egress_configuration=apprunner.CfnService.EgressConfigurationProperty(\n                egress_type="egressType",\n\n                # the properties below are optional\n                vpc_connector_arn="vpcConnectorArn"\n            ),\n            ingress_configuration=apprunner.CfnService.IngressConfigurationProperty(\n                is_publicly_accessible=False\n            )\n        ),\n        observability_configuration=apprunner.CfnService.ServiceObservabilityConfigurationProperty(\n            observability_enabled=False,\n\n            # the properties below are optional\n            observability_configuration_arn="observabilityConfigurationArn"\n        ),\n        service_name="serviceName",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['source_configuration', 'auto_scaling_configuration_arn', 'encryption_configuration', 'health_check_configuration', 'instance_configuration', 'network_configuration', 'observability_configuration', 'service_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnServiceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apprunner.CfnVpcConnectorProps
class CfnVpcConnectorPropsDef(BaseCfnProperty):
    subnets: typing.Sequence[str] = pydantic.Field(..., description='A list of IDs of subnets that App Runner should use when it associates your service with a custom Amazon VPC. Specify IDs of subnets of a single Amazon VPC. App Runner determines the Amazon VPC from the subnets you specify. .. epigraph:: App Runner currently only provides support for IPv4.\n')
    security_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of IDs of security groups that App Runner should use for access to AWS resources under the specified subnets. If not specified, App Runner uses the default security group of the Amazon VPC. The default security group allows all outbound traffic.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A list of metadata items that you can associate with your VPC connector resource. A tag is a key-value pair.\n')
    vpc_connector_name: typing.Optional[str] = pydantic.Field(None, description='A name for the VPC connector. If you don\'t specify a name, AWS CloudFormation generates a name for your VPC connector.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apprunner-vpcconnector.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    cfn_vpc_connector_props = apprunner.CfnVpcConnectorProps(\n        subnets=["subnets"],\n\n        # the properties below are optional\n        security_groups=["securityGroups"],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        vpc_connector_name="vpcConnectorName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['subnets', 'security_groups', 'tags', 'vpc_connector_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnVpcConnectorProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_apprunner.CfnVpcIngressConnectionProps
class CfnVpcIngressConnectionPropsDef(BaseCfnProperty):
    ingress_vpc_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_apprunner.CfnVpcIngressConnection_IngressVpcConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Specifications for the customer’s Amazon VPC and the related AWS PrivateLink VPC endpoint that are used to create the VPC Ingress Connection resource.\n')
    service_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) for this App Runner service that is used to create the VPC Ingress Connection resource.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An optional list of metadata items that you can associate with the VPC Ingress Connection resource. A tag is a key-value pair.\n')
    vpc_ingress_connection_name: typing.Optional[str] = pydantic.Field(None, description='The customer-provided VPC Ingress Connection name.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apprunner-vpcingressconnection.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_apprunner as apprunner\n\n    cfn_vpc_ingress_connection_props = apprunner.CfnVpcIngressConnectionProps(\n        ingress_vpc_configuration=apprunner.CfnVpcIngressConnection.IngressVpcConfigurationProperty(\n            vpc_endpoint_id="vpcEndpointId",\n            vpc_id="vpcId"\n        ),\n        service_arn="serviceArn",\n\n        # the properties below are optional\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        vpc_ingress_connection_name="vpcIngressConnectionName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ingress_vpc_configuration', 'service_arn', 'tags', 'vpc_ingress_connection_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_apprunner.CfnVpcIngressConnectionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    CfnObservabilityConfiguration_TraceConfigurationProperty: typing.Optional[dict[str, CfnObservabilityConfiguration_TraceConfigurationPropertyDef]] = pydantic.Field(None)
    CfnService_AuthenticationConfigurationProperty: typing.Optional[dict[str, CfnService_AuthenticationConfigurationPropertyDef]] = pydantic.Field(None)
    CfnService_CodeConfigurationProperty: typing.Optional[dict[str, CfnService_CodeConfigurationPropertyDef]] = pydantic.Field(None)
    CfnService_CodeConfigurationValuesProperty: typing.Optional[dict[str, CfnService_CodeConfigurationValuesPropertyDef]] = pydantic.Field(None)
    CfnService_CodeRepositoryProperty: typing.Optional[dict[str, CfnService_CodeRepositoryPropertyDef]] = pydantic.Field(None)
    CfnService_EgressConfigurationProperty: typing.Optional[dict[str, CfnService_EgressConfigurationPropertyDef]] = pydantic.Field(None)
    CfnService_EncryptionConfigurationProperty: typing.Optional[dict[str, CfnService_EncryptionConfigurationPropertyDef]] = pydantic.Field(None)
    CfnService_HealthCheckConfigurationProperty: typing.Optional[dict[str, CfnService_HealthCheckConfigurationPropertyDef]] = pydantic.Field(None)
    CfnService_ImageConfigurationProperty: typing.Optional[dict[str, CfnService_ImageConfigurationPropertyDef]] = pydantic.Field(None)
    CfnService_ImageRepositoryProperty: typing.Optional[dict[str, CfnService_ImageRepositoryPropertyDef]] = pydantic.Field(None)
    CfnService_IngressConfigurationProperty: typing.Optional[dict[str, CfnService_IngressConfigurationPropertyDef]] = pydantic.Field(None)
    CfnService_InstanceConfigurationProperty: typing.Optional[dict[str, CfnService_InstanceConfigurationPropertyDef]] = pydantic.Field(None)
    CfnService_KeyValuePairProperty: typing.Optional[dict[str, CfnService_KeyValuePairPropertyDef]] = pydantic.Field(None)
    CfnService_NetworkConfigurationProperty: typing.Optional[dict[str, CfnService_NetworkConfigurationPropertyDef]] = pydantic.Field(None)
    CfnService_ServiceObservabilityConfigurationProperty: typing.Optional[dict[str, CfnService_ServiceObservabilityConfigurationPropertyDef]] = pydantic.Field(None)
    CfnService_SourceCodeVersionProperty: typing.Optional[dict[str, CfnService_SourceCodeVersionPropertyDef]] = pydantic.Field(None)
    CfnService_SourceConfigurationProperty: typing.Optional[dict[str, CfnService_SourceConfigurationPropertyDef]] = pydantic.Field(None)
    CfnVpcIngressConnection_IngressVpcConfigurationProperty: typing.Optional[dict[str, CfnVpcIngressConnection_IngressVpcConfigurationPropertyDef]] = pydantic.Field(None)
    CfnObservabilityConfiguration: typing.Optional[dict[str, CfnObservabilityConfigurationDef]] = pydantic.Field(None)
    CfnService: typing.Optional[dict[str, CfnServiceDef]] = pydantic.Field(None)
    CfnVpcConnector: typing.Optional[dict[str, CfnVpcConnectorDef]] = pydantic.Field(None)
    CfnVpcIngressConnection: typing.Optional[dict[str, CfnVpcIngressConnectionDef]] = pydantic.Field(None)
    CfnObservabilityConfigurationProps: typing.Optional[dict[str, CfnObservabilityConfigurationPropsDef]] = pydantic.Field(None)
    CfnServiceProps: typing.Optional[dict[str, CfnServicePropsDef]] = pydantic.Field(None)
    CfnVpcConnectorProps: typing.Optional[dict[str, CfnVpcConnectorPropsDef]] = pydantic.Field(None)
    CfnVpcIngressConnectionProps: typing.Optional[dict[str, CfnVpcIngressConnectionPropsDef]] = pydantic.Field(None)
    ...
