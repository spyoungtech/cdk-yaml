from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_s3objectlambda.CfnAccessPoint.AliasProperty
class CfnAccessPoint_AliasPropertyDef(BaseStruct):
    value: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The alias value of the Object Lambda Access Point.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='The status of the Object Lambda Access Point alias. If the status is ``PROVISIONING`` , the Object Lambda Access Point is provisioning the alias and the alias is not ready for use yet. If the status is ``READY`` , the Object Lambda Access Point alias is successfully provisioned and ready for use.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3objectlambda-accesspoint-alias.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_s3objectlambda as s3objectlambda\n\n    alias_property = s3objectlambda.CfnAccessPoint.AliasProperty(\n        value="value",\n\n        # the properties below are optional\n        status="status"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['value', 'status']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_s3objectlambda.CfnAccessPoint.AliasProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_s3objectlambda.CfnAccessPoint.AwsLambdaProperty
class CfnAccessPoint_AwsLambdaPropertyDef(BaseStruct):
    function_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='')
    function_payload: typing.Optional[str] = pydantic.Field(None, description='')
    _init_params: typing.ClassVar[list[str]] = ['function_arn', 'function_payload']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_s3objectlambda.CfnAccessPoint.AwsLambdaProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_s3objectlambda.CfnAccessPoint.ContentTransformationProperty
class CfnAccessPoint_ContentTransformationPropertyDef(BaseStruct):
    aws_lambda: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_s3objectlambda.CfnAccessPoint_AwsLambdaPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='')
    _init_params: typing.ClassVar[list[str]] = ['aws_lambda']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_s3objectlambda.CfnAccessPoint.ContentTransformationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_s3objectlambda.CfnAccessPoint.ObjectLambdaConfigurationProperty
class CfnAccessPoint_ObjectLambdaConfigurationPropertyDef(BaseStruct):
    supporting_access_point: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Standard access point associated with the Object Lambda Access Point.\n')
    transformation_configurations: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_s3objectlambda.CfnAccessPoint_TransformationConfigurationPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A container for transformation configurations for an Object Lambda Access Point.\n')
    allowed_features: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A container for allowed features. Valid inputs are ``GetObject-Range`` , ``GetObject-PartNumber`` , ``HeadObject-Range`` , and ``HeadObject-PartNumber`` .\n')
    cloud_watch_metrics_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='A container for whether the CloudWatch metrics configuration is enabled.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3objectlambda-accesspoint-objectlambdaconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_s3objectlambda as s3objectlambda\n\n    # content_transformation: Any\n\n    object_lambda_configuration_property = s3objectlambda.CfnAccessPoint.ObjectLambdaConfigurationProperty(\n        supporting_access_point="supportingAccessPoint",\n        transformation_configurations=[s3objectlambda.CfnAccessPoint.TransformationConfigurationProperty(\n            actions=["actions"],\n            content_transformation=content_transformation\n        )],\n\n        # the properties below are optional\n        allowed_features=["allowedFeatures"],\n        cloud_watch_metrics_enabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['supporting_access_point', 'transformation_configurations', 'allowed_features', 'cloud_watch_metrics_enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_s3objectlambda.CfnAccessPoint.ObjectLambdaConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_s3objectlambda.CfnAccessPoint.PolicyStatusProperty
class CfnAccessPoint_PolicyStatusPropertyDef(BaseStruct):
    is_public: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Specifies whether the Object lambda Access Point Policy is Public or not. Object lambda Access Points are private by default.')
    _init_params: typing.ClassVar[list[str]] = ['is_public']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_s3objectlambda.CfnAccessPoint.PolicyStatusProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_s3objectlambda.CfnAccessPoint.PublicAccessBlockConfigurationProperty
class CfnAccessPoint_PublicAccessBlockConfigurationPropertyDef(BaseStruct):
    block_public_acls: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in this account. Setting this element to ``TRUE`` causes the following behavior: - ``PutBucketAcl`` and ``PutObjectAcl`` calls fail if the specified ACL is public. - PUT Object calls fail if the request includes a public ACL. - PUT Bucket calls fail if the request includes a public ACL. Enabling this setting doesn't affect existing policies or ACLs. This property is not supported for Amazon S3 on Outposts.\n")
    block_public_policy: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to ``TRUE`` causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access. Enabling this setting doesn't affect existing bucket policies. This property is not supported for Amazon S3 on Outposts.\n")
    ignore_public_acls: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to ``TRUE`` causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain. Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set. This property is not supported for Amazon S3 on Outposts.\n")
    restrict_public_buckets: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description="Specifies whether Amazon S3 should restrict public bucket policies for buckets in this account. Setting this element to ``TRUE`` restricts access to buckets with public policies to only AWS service principals and authorized users within this account. Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked. This property is not supported for Amazon S3 on Outposts.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3objectlambda-accesspoint-publicaccessblockconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_s3objectlambda as s3objectlambda\n\n    public_access_block_configuration_property = s3objectlambda.CfnAccessPoint.PublicAccessBlockConfigurationProperty(\n        block_public_acls=False,\n        block_public_policy=False,\n        ignore_public_acls=False,\n        restrict_public_buckets=False\n    )\n")
    _init_params: typing.ClassVar[list[str]] = ['block_public_acls', 'block_public_policy', 'ignore_public_acls', 'restrict_public_buckets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_s3objectlambda.CfnAccessPoint.PublicAccessBlockConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_s3objectlambda.CfnAccessPoint.TransformationConfigurationProperty
class CfnAccessPoint_TransformationConfigurationPropertyDef(BaseStruct):
    actions: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A container for the action of an Object Lambda Access Point configuration. Valid inputs are ``GetObject`` , ``HeadObject`` , ``ListObject`` , and ``ListObjectV2`` .\n')
    content_transformation: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A container for the content transformation of an Object Lambda Access Point configuration. Can include the FunctionArn and FunctionPayload. For more information, see `AwsLambdaTransformation <https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_AwsLambdaTransformation.html>`_ in the *Amazon S3 API Reference* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3objectlambda-accesspoint-transformationconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_s3objectlambda as s3objectlambda\n\n    # content_transformation: Any\n\n    transformation_configuration_property = s3objectlambda.CfnAccessPoint.TransformationConfigurationProperty(\n        actions=["actions"],\n        content_transformation=content_transformation\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['actions', 'content_transformation']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_s3objectlambda.CfnAccessPoint.TransformationConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_s3objectlambda.CfnAccessPoint
class CfnAccessPointDef(BaseCfnResource):
    object_lambda_configuration: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_s3objectlambda.CfnAccessPoint_ObjectLambdaConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A configuration used when creating an Object Lambda Access Point.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of this access point.')
    _init_params: typing.ClassVar[list[str]] = ['object_lambda_configuration', 'name']
    _method_names: typing.ClassVar[list[str]] = ['AliasProperty', 'AwsLambdaProperty', 'ContentTransformationProperty', 'ObjectLambdaConfigurationProperty', 'PolicyStatusProperty', 'PublicAccessBlockConfigurationProperty', 'TransformationConfigurationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_s3objectlambda.CfnAccessPoint'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_s3objectlambda.CfnAccessPointDefConfig] = pydantic.Field(None)


class CfnAccessPointDefConfig(pydantic.BaseModel):
    AliasProperty: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointDefAliaspropertyParams]] = pydantic.Field(None, description='')
    AwsLambdaProperty: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointDefAwslambdapropertyParams]] = pydantic.Field(None, description='')
    ContentTransformationProperty: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointDefContenttransformationpropertyParams]] = pydantic.Field(None, description='')
    ObjectLambdaConfigurationProperty: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointDefObjectlambdaconfigurationpropertyParams]] = pydantic.Field(None, description='')
    PolicyStatusProperty: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointDefPolicystatuspropertyParams]] = pydantic.Field(None, description='')
    PublicAccessBlockConfigurationProperty: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointDefPublicaccessblockconfigurationpropertyParams]] = pydantic.Field(None, description='')
    TransformationConfigurationProperty: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointDefTransformationconfigurationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_alias_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_policy_status_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_policy_status_is_public_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_public_access_block_configuration_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_public_access_block_configuration_block_public_acls_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_public_access_block_configuration_block_public_policy_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_public_access_block_configuration_ignore_public_acls_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_public_access_block_configuration_restrict_public_buckets_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)

class CfnAccessPointDefAliaspropertyParams(pydantic.BaseModel):
    value: str = pydantic.Field(..., description='')
    status: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAccessPointDefAwslambdapropertyParams(pydantic.BaseModel):
    function_arn: str = pydantic.Field(..., description='')
    function_payload: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnAccessPointDefContenttransformationpropertyParams(pydantic.BaseModel):
    aws_lambda: typing.Union[models.UnsupportedResource, models.aws_s3objectlambda.CfnAccessPoint_AwsLambdaPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnAccessPointDefObjectlambdaconfigurationpropertyParams(pydantic.BaseModel):
    supporting_access_point: str = pydantic.Field(..., description='')
    transformation_configurations: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_s3objectlambda.CfnAccessPoint_TransformationConfigurationPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    allowed_features: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    cloud_watch_metrics_enabled: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnAccessPointDefPolicystatuspropertyParams(pydantic.BaseModel):
    is_public: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnAccessPointDefPublicaccessblockconfigurationpropertyParams(pydantic.BaseModel):
    block_public_acls: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    block_public_policy: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ignore_public_acls: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    restrict_public_buckets: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnAccessPointDefTransformationconfigurationpropertyParams(pydantic.BaseModel):
    actions: typing.Sequence[str] = pydantic.Field(..., description='')
    content_transformation: typing.Any = pydantic.Field(..., description='')
    ...

class CfnAccessPointDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAccessPointDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAccessPointDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAccessPointDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAccessPointDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAccessPointDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAccessPointDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAccessPointDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAccessPointDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAccessPointDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAccessPointDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnAccessPointDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAccessPointDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAccessPointDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_s3objectlambda.CfnAccessPointPolicy
class CfnAccessPointPolicyDef(BaseCfnResource):
    object_lambda_access_point: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='An access point with an attached AWS Lambda function used to access transformed data from an Amazon S3 bucket.\n')
    policy_document: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Object Lambda Access Point resource policy document.')
    _init_params: typing.ClassVar[list[str]] = ['object_lambda_access_point', 'policy_document']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_s3objectlambda.CfnAccessPointPolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_s3objectlambda.CfnAccessPointPolicyDefConfig] = pydantic.Field(None)


class CfnAccessPointPolicyDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointPolicyDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointPolicyDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointPolicyDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointPolicyDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointPolicyDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointPolicyDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointPolicyDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointPolicyDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointPolicyDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointPolicyDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointPolicyDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointPolicyDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_s3objectlambda.CfnAccessPointPolicyDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnAccessPointPolicyDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnAccessPointPolicyDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAccessPointPolicyDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnAccessPointPolicyDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAccessPointPolicyDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnAccessPointPolicyDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnAccessPointPolicyDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnAccessPointPolicyDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnAccessPointPolicyDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnAccessPointPolicyDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnAccessPointPolicyDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnAccessPointPolicyDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnAccessPointPolicyDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnAccessPointPolicyDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_s3objectlambda.CfnAccessPointPolicyProps
class CfnAccessPointPolicyPropsDef(BaseCfnProperty):
    object_lambda_access_point: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='An access point with an attached AWS Lambda function used to access transformed data from an Amazon S3 bucket.\n')
    policy_document: typing.Union[typing.Any, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Object Lambda Access Point resource policy document.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3objectlambda-accesspointpolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_s3objectlambda as s3objectlambda\n\n    # policy_document: Any\n\n    cfn_access_point_policy_props = s3objectlambda.CfnAccessPointPolicyProps(\n        object_lambda_access_point="objectLambdaAccessPoint",\n        policy_document=policy_document\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['object_lambda_access_point', 'policy_document']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_s3objectlambda.CfnAccessPointPolicyProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_s3objectlambda.CfnAccessPointProps
class CfnAccessPointPropsDef(BaseCfnProperty):
    object_lambda_configuration: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_s3objectlambda.CfnAccessPoint_ObjectLambdaConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A configuration used when creating an Object Lambda Access Point.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of this access point.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-s3objectlambda-accesspoint.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_s3objectlambda as s3objectlambda\n\n    # content_transformation: Any\n\n    cfn_access_point_props = s3objectlambda.CfnAccessPointProps(\n        object_lambda_configuration=s3objectlambda.CfnAccessPoint.ObjectLambdaConfigurationProperty(\n            supporting_access_point="supportingAccessPoint",\n            transformation_configurations=[s3objectlambda.CfnAccessPoint.TransformationConfigurationProperty(\n                actions=["actions"],\n                content_transformation=content_transformation\n            )],\n\n            # the properties below are optional\n            allowed_features=["allowedFeatures"],\n            cloud_watch_metrics_enabled=False\n        ),\n\n        # the properties below are optional\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['object_lambda_configuration', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_s3objectlambda.CfnAccessPointProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    CfnAccessPoint_AliasProperty: typing.Optional[dict[str, models.aws_s3objectlambda.CfnAccessPoint_AliasPropertyDef]] = pydantic.Field(None)
    CfnAccessPoint_AwsLambdaProperty: typing.Optional[dict[str, models.aws_s3objectlambda.CfnAccessPoint_AwsLambdaPropertyDef]] = pydantic.Field(None)
    CfnAccessPoint_ContentTransformationProperty: typing.Optional[dict[str, models.aws_s3objectlambda.CfnAccessPoint_ContentTransformationPropertyDef]] = pydantic.Field(None)
    CfnAccessPoint_ObjectLambdaConfigurationProperty: typing.Optional[dict[str, models.aws_s3objectlambda.CfnAccessPoint_ObjectLambdaConfigurationPropertyDef]] = pydantic.Field(None)
    CfnAccessPoint_PolicyStatusProperty: typing.Optional[dict[str, models.aws_s3objectlambda.CfnAccessPoint_PolicyStatusPropertyDef]] = pydantic.Field(None)
    CfnAccessPoint_PublicAccessBlockConfigurationProperty: typing.Optional[dict[str, models.aws_s3objectlambda.CfnAccessPoint_PublicAccessBlockConfigurationPropertyDef]] = pydantic.Field(None)
    CfnAccessPoint_TransformationConfigurationProperty: typing.Optional[dict[str, models.aws_s3objectlambda.CfnAccessPoint_TransformationConfigurationPropertyDef]] = pydantic.Field(None)
    CfnAccessPoint: typing.Optional[dict[str, models.aws_s3objectlambda.CfnAccessPointDef]] = pydantic.Field(None)
    CfnAccessPointPolicy: typing.Optional[dict[str, models.aws_s3objectlambda.CfnAccessPointPolicyDef]] = pydantic.Field(None)
    CfnAccessPointPolicyProps: typing.Optional[dict[str, models.aws_s3objectlambda.CfnAccessPointPolicyPropsDef]] = pydantic.Field(None)
    CfnAccessPointProps: typing.Optional[dict[str, models.aws_s3objectlambda.CfnAccessPointPropsDef]] = pydantic.Field(None)
    ...

import models
