from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams

#  autogenerated from aws_cdk.cx_api.AssetManifestArtifact
class AssetManifestArtifactDef(BaseClass):
    assembly: models.cx_api.CloudAssemblyDef = pydantic.Field(..., description='-')
    name: str = pydantic.Field(..., description='-\n')
    type: aws_cdk.cloud_assembly_schema.ArtifactType = pydantic.Field(..., description='The type of artifact.\n')
    dependencies: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='IDs of artifacts that must be deployed before this artifact. Default: - no dependencies.\n')
    display_name: typing.Optional[str] = pydantic.Field(None, description='A string that represents this artifact. Should only be used in user interfaces. Default: - no display name\n')
    environment: typing.Optional[str] = pydantic.Field(None, description='The environment into which this artifact is deployed. Default: - no envrionment.\n')
    metadata: typing.Optional[typing.Mapping[str, typing.Sequence[typing.Union[models.cloud_assembly_schema.MetadataEntryDef, dict[str, typing.Any]]]]] = pydantic.Field(None, description='Associated metadata. Default: - no metadata.\n')
    properties: typing.Union[models.cloud_assembly_schema.AwsCloudFormationStackPropertiesDef, dict[str, typing.Any], models.cloud_assembly_schema.AssetManifestPropertiesDef, models.cloud_assembly_schema.TreeArtifactPropertiesDef, models.cloud_assembly_schema.NestedCloudAssemblyPropertiesDef, None] = pydantic.Field(None, description='The set of properties for this artifact (depends on type). Default: - no properties.')
    _init_params: typing.ClassVar[list[str]] = ['assembly', 'name', 'type', 'dependencies', 'display_name', 'environment', 'metadata', 'properties']
    _method_names: typing.ClassVar[list[str]] = ['find_metadata_by_type']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_manifest']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.AssetManifestArtifact'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_manifest']
    ...


    from_manifest: typing.Optional[AssetManifestArtifactDefFromManifestParams] = pydantic.Field(None, description='Returns a subclass of ``CloudArtifact`` based on the artifact type defined in the artifact manifest.')
    resource_config: typing.Optional[AssetManifestArtifactDefConfig] = pydantic.Field(None)


class AssetManifestArtifactDefConfig(pydantic.BaseModel):
    find_metadata_by_type: typing.Optional[list[AssetManifestArtifactDefFindMetadataByTypeParams]] = pydantic.Field(None, description=':return: all the metadata entries of a specific type in this artifact.')

class AssetManifestArtifactDefFindMetadataByTypeParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='-')
    ...

class AssetManifestArtifactDefFromManifestParams(pydantic.BaseModel):
    assembly: models.cx_api.CloudAssemblyDef = pydantic.Field(..., description='The cloud assembly from which to load the artifact.\n')
    id: str = pydantic.Field(..., description='The artifact ID.\n')
    type: aws_cdk.cloud_assembly_schema.ArtifactType = pydantic.Field(..., description='The type of artifact.\n')
    dependencies: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='IDs of artifacts that must be deployed before this artifact. Default: - no dependencies.\n')
    display_name: typing.Optional[str] = pydantic.Field(None, description='A string that represents this artifact. Should only be used in user interfaces. Default: - no display name\n')
    environment: typing.Optional[str] = pydantic.Field(None, description='The environment into which this artifact is deployed. Default: - no envrionment.\n')
    metadata: typing.Optional[typing.Mapping[str, typing.Sequence[typing.Union[models.cloud_assembly_schema.MetadataEntryDef, dict[str, typing.Any]]]]] = pydantic.Field(None, description='Associated metadata. Default: - no metadata.\n')
    properties: typing.Union[models.cloud_assembly_schema.AwsCloudFormationStackPropertiesDef, dict[str, typing.Any], models.cloud_assembly_schema.AssetManifestPropertiesDef, models.cloud_assembly_schema.TreeArtifactPropertiesDef, models.cloud_assembly_schema.NestedCloudAssemblyPropertiesDef, None] = pydantic.Field(None, description='The set of properties for this artifact (depends on type). Default: - no properties.\n')
    ...


#  autogenerated from aws_cdk.cx_api.CloudArtifact
class CloudArtifactDef(BaseClass):
    assembly: models.cx_api.CloudAssemblyDef = pydantic.Field(..., description='-')
    type: aws_cdk.cloud_assembly_schema.ArtifactType = pydantic.Field(..., description='The type of artifact.\n')
    dependencies: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='IDs of artifacts that must be deployed before this artifact. Default: - no dependencies.\n')
    display_name: typing.Optional[str] = pydantic.Field(None, description='A string that represents this artifact. Should only be used in user interfaces. Default: - no display name\n')
    environment: typing.Optional[str] = pydantic.Field(None, description='The environment into which this artifact is deployed. Default: - no envrionment.\n')
    metadata: typing.Optional[typing.Mapping[str, typing.Sequence[typing.Union[models.cloud_assembly_schema.MetadataEntryDef, dict[str, typing.Any]]]]] = pydantic.Field(None, description='Associated metadata. Default: - no metadata.\n')
    properties: typing.Union[models.cloud_assembly_schema.AwsCloudFormationStackPropertiesDef, dict[str, typing.Any], models.cloud_assembly_schema.AssetManifestPropertiesDef, models.cloud_assembly_schema.TreeArtifactPropertiesDef, models.cloud_assembly_schema.NestedCloudAssemblyPropertiesDef, None] = pydantic.Field(None, description='The set of properties for this artifact (depends on type). Default: - no properties.')
    _init_params: typing.ClassVar[list[str]] = ['assembly', 'type', 'dependencies', 'display_name', 'environment', 'metadata', 'properties']
    _method_names: typing.ClassVar[list[str]] = ['find_metadata_by_type']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_manifest']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.CloudArtifact'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_manifest']
    ...


    from_manifest: typing.Optional[CloudArtifactDefFromManifestParams] = pydantic.Field(None, description='Returns a subclass of ``CloudArtifact`` based on the artifact type defined in the artifact manifest.')
    resource_config: typing.Optional[CloudArtifactDefConfig] = pydantic.Field(None)


class CloudArtifactDefConfig(pydantic.BaseModel):
    find_metadata_by_type: typing.Optional[list[CloudArtifactDefFindMetadataByTypeParams]] = pydantic.Field(None, description=':return: all the metadata entries of a specific type in this artifact.')

class CloudArtifactDefFindMetadataByTypeParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='-')
    ...

class CloudArtifactDefFromManifestParams(pydantic.BaseModel):
    assembly: models.cx_api.CloudAssemblyDef = pydantic.Field(..., description='The cloud assembly from which to load the artifact.\n')
    id: str = pydantic.Field(..., description='The artifact ID.\n')
    type: aws_cdk.cloud_assembly_schema.ArtifactType = pydantic.Field(..., description='The type of artifact.\n')
    dependencies: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='IDs of artifacts that must be deployed before this artifact. Default: - no dependencies.\n')
    display_name: typing.Optional[str] = pydantic.Field(None, description='A string that represents this artifact. Should only be used in user interfaces. Default: - no display name\n')
    environment: typing.Optional[str] = pydantic.Field(None, description='The environment into which this artifact is deployed. Default: - no envrionment.\n')
    metadata: typing.Optional[typing.Mapping[str, typing.Sequence[typing.Union[models.cloud_assembly_schema.MetadataEntryDef, dict[str, typing.Any]]]]] = pydantic.Field(None, description='Associated metadata. Default: - no metadata.\n')
    properties: typing.Union[models.cloud_assembly_schema.AwsCloudFormationStackPropertiesDef, dict[str, typing.Any], models.cloud_assembly_schema.AssetManifestPropertiesDef, models.cloud_assembly_schema.TreeArtifactPropertiesDef, models.cloud_assembly_schema.NestedCloudAssemblyPropertiesDef, None] = pydantic.Field(None, description='The set of properties for this artifact (depends on type). Default: - no properties.\n')
    ...


#  autogenerated from aws_cdk.cx_api.CloudAssembly
class CloudAssemblyDef(BaseClass):
    directory: str = pydantic.Field(..., description='The root directory of the assembly.\n')
    skip_enum_check: typing.Optional[bool] = pydantic.Field(None, description="Skip enum checks. This means you may read enum values you don't know about yet. Make sure to always check the values of enums you encounter in the manifest. Default: false\n")
    skip_version_check: typing.Optional[bool] = pydantic.Field(None, description='Skip the version check. This means you may read a newer cloud assembly than the CX API is designed to support, and your application may not be aware of all features that in use in the Cloud Assembly. Default: false\n')
    topo_sort: typing.Optional[bool] = pydantic.Field(None, description='Topologically sort all artifacts. This parameter is only respected by the constructor of ``CloudAssembly``. The property lives here for backwards compatibility reasons. Default: true')
    _init_params: typing.ClassVar[list[str]] = ['directory', 'skip_enum_check', 'skip_version_check', 'topo_sort']
    _method_names: typing.ClassVar[list[str]] = ['get_nested_assembly', 'get_nested_assembly_artifact', 'get_stack_artifact', 'get_stack_by_name', 'tree', 'try_get_artifact']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.CloudAssembly'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CloudAssemblyDefConfig] = pydantic.Field(None)


class CloudAssemblyDefConfig(pydantic.BaseModel):
    get_nested_assembly: typing.Optional[list[CloudAssemblyDefGetNestedAssemblyParams]] = pydantic.Field(None, description='Returns a nested assembly.')
    get_nested_assembly_artifact: typing.Optional[list[CloudAssemblyDefGetNestedAssemblyArtifactParams]] = pydantic.Field(None, description='Returns a nested assembly artifact.')
    get_stack_artifact: typing.Optional[list[CloudAssemblyDefGetStackArtifactParams]] = pydantic.Field(None, description='Returns a CloudFormation stack artifact from this assembly.')
    get_stack_by_name: typing.Optional[list[CloudAssemblyDefGetStackByNameParams]] = pydantic.Field(None, description='Returns a CloudFormation stack artifact from this assembly.\nWill only search the current assembly.')
    tree: typing.Optional[bool] = pydantic.Field(None, description='Returns the tree metadata artifact from this assembly.\n:return: a ``TreeCloudArtifact`` object if there is one defined in the manifest, ``undefined`` otherwise.\n\n:throws: if there is no metadata artifact by that name')
    try_get_artifact: typing.Optional[list[CloudAssemblyDefTryGetArtifactParams]] = pydantic.Field(None, description='Attempts to find an artifact with a specific identity.')

class CloudAssemblyDefGetNestedAssemblyParams(pydantic.BaseModel):
    artifact_id: str = pydantic.Field(..., description='The artifact ID of the nested assembly.')
    return_config: typing.Optional[list[models.cx_api.CloudAssemblyDefConfig]] = pydantic.Field(None)
    ...

class CloudAssemblyDefGetNestedAssemblyArtifactParams(pydantic.BaseModel):
    artifact_id: str = pydantic.Field(..., description='The artifact ID of the nested assembly.')
    return_config: typing.Optional[list[models.cx_api.NestedCloudAssemblyArtifactDefConfig]] = pydantic.Field(None)
    ...

class CloudAssemblyDefGetStackArtifactParams(pydantic.BaseModel):
    artifact_id: str = pydantic.Field(..., description='the artifact id of the stack (can be obtained through ``stack.artifactId``).\n')
    return_config: typing.Optional[list[models.cx_api.CloudFormationStackArtifactDefConfig]] = pydantic.Field(None)
    ...

class CloudAssemblyDefGetStackByNameParams(pydantic.BaseModel):
    stack_name: str = pydantic.Field(..., description='the name of the CloudFormation stack.\n')
    return_config: typing.Optional[list[models.cx_api.CloudFormationStackArtifactDefConfig]] = pydantic.Field(None)
    ...

class CloudAssemblyDefTryGetArtifactParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='The artifact ID.\n')
    ...


#  autogenerated from aws_cdk.cx_api.CloudAssemblyBuilder
class CloudAssemblyBuilderDef(BaseClass):
    outdir: typing.Optional[str] = pydantic.Field(None, description='The output directory, uses temporary directory if undefined.\n')
    asset_outdir: typing.Optional[str] = pydantic.Field(None, description='Use the given asset output directory. Default: - Same as the manifest outdir\n')
    parent_builder: typing.Optional[models.cx_api.CloudAssemblyBuilderDef] = pydantic.Field(None, description='If this builder is for a nested assembly, the parent assembly builder. Default: - This is a root assembly')
    _init_params: typing.ClassVar[list[str]] = ['outdir', 'asset_outdir', 'parent_builder']
    _method_names: typing.ClassVar[list[str]] = ['add_artifact', 'add_missing', 'build_assembly', 'create_nested_assembly', 'delete']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.CloudAssemblyBuilder'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CloudAssemblyBuilderDefConfig] = pydantic.Field(None)


class CloudAssemblyBuilderDefConfig(pydantic.BaseModel):
    add_artifact: typing.Optional[list[CloudAssemblyBuilderDefAddArtifactParams]] = pydantic.Field(None, description='Adds an artifact into the cloud assembly.')
    add_missing: typing.Optional[list[CloudAssemblyBuilderDefAddMissingParams]] = pydantic.Field(None, description='Reports that some context is missing in order for this cloud assembly to be fully synthesized.')
    build_assembly: typing.Optional[list[CloudAssemblyBuilderDefBuildAssemblyParams]] = pydantic.Field(None, description='Finalizes the cloud assembly into the output directory returns a ``CloudAssembly`` object that can be used to inspect the assembly.')
    create_nested_assembly: typing.Optional[list[CloudAssemblyBuilderDefCreateNestedAssemblyParams]] = pydantic.Field(None, description='Creates a nested cloud assembly.')
    delete: typing.Optional[bool] = pydantic.Field(None, description='Delete the cloud assembly directory.')

class CloudAssemblyBuilderDefAddArtifactParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='The ID of the artifact.\n')
    type: aws_cdk.cloud_assembly_schema.ArtifactType = pydantic.Field(..., description='The type of artifact.\n')
    dependencies: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='IDs of artifacts that must be deployed before this artifact. Default: - no dependencies.\n')
    display_name: typing.Optional[str] = pydantic.Field(None, description='A string that represents this artifact. Should only be used in user interfaces. Default: - no display name\n')
    environment: typing.Optional[str] = pydantic.Field(None, description='The environment into which this artifact is deployed. Default: - no envrionment.\n')
    metadata: typing.Optional[typing.Mapping[str, typing.Sequence[typing.Union[models.cloud_assembly_schema.MetadataEntryDef, dict[str, typing.Any]]]]] = pydantic.Field(None, description='Associated metadata. Default: - no metadata.\n')
    properties: typing.Union[models.cloud_assembly_schema.AwsCloudFormationStackPropertiesDef, dict[str, typing.Any], models.cloud_assembly_schema.AssetManifestPropertiesDef, models.cloud_assembly_schema.TreeArtifactPropertiesDef, models.cloud_assembly_schema.NestedCloudAssemblyPropertiesDef, None] = pydantic.Field(None, description='The set of properties for this artifact (depends on type). Default: - no properties.')
    ...

class CloudAssemblyBuilderDefAddMissingParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='The missing context key.\n')
    props: typing.Union[models.cloud_assembly_schema.AmiContextQueryDef, dict[str, typing.Any], models.cloud_assembly_schema.AvailabilityZonesContextQueryDef, models.cloud_assembly_schema.HostedZoneContextQueryDef, models.cloud_assembly_schema.SSMParameterContextQueryDef, models.cloud_assembly_schema.VpcContextQueryDef, models.cloud_assembly_schema.EndpointServiceAvailabilityZonesContextQueryDef, models.cloud_assembly_schema.LoadBalancerContextQueryDef, models.cloud_assembly_schema.LoadBalancerListenerContextQueryDef, models.cloud_assembly_schema.SecurityGroupContextQueryDef, models.cloud_assembly_schema.KeyContextQueryDef, models.cloud_assembly_schema.PluginContextQueryDef] = pydantic.Field(..., description='A set of provider-specific options.\n')
    provider: aws_cdk.cloud_assembly_schema.ContextProvider = pydantic.Field(..., description='The provider from which we expect this context key to be obtained.')
    ...

class CloudAssemblyBuilderDefBuildAssemblyParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.cx_api.CloudAssemblyDefConfig]] = pydantic.Field(None)
    ...

class CloudAssemblyBuilderDefCreateNestedAssemblyParams(pydantic.BaseModel):
    artifact_id: str = pydantic.Field(..., description='-\n')
    display_name: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.cx_api.CloudAssemblyBuilderDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.cx_api.CloudFormationStackArtifact
class CloudFormationStackArtifactDef(BaseClass):
    assembly: models.cx_api.CloudAssemblyDef = pydantic.Field(..., description='-')
    artifact_id: str = pydantic.Field(..., description='-\n')
    type: aws_cdk.cloud_assembly_schema.ArtifactType = pydantic.Field(..., description='The type of artifact.\n')
    dependencies: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='IDs of artifacts that must be deployed before this artifact. Default: - no dependencies.\n')
    display_name: typing.Optional[str] = pydantic.Field(None, description='A string that represents this artifact. Should only be used in user interfaces. Default: - no display name\n')
    environment: typing.Optional[str] = pydantic.Field(None, description='The environment into which this artifact is deployed. Default: - no envrionment.\n')
    metadata: typing.Optional[typing.Mapping[str, typing.Sequence[typing.Union[models.cloud_assembly_schema.MetadataEntryDef, dict[str, typing.Any]]]]] = pydantic.Field(None, description='Associated metadata. Default: - no metadata.\n')
    properties: typing.Union[models.cloud_assembly_schema.AwsCloudFormationStackPropertiesDef, dict[str, typing.Any], models.cloud_assembly_schema.AssetManifestPropertiesDef, models.cloud_assembly_schema.TreeArtifactPropertiesDef, models.cloud_assembly_schema.NestedCloudAssemblyPropertiesDef, None] = pydantic.Field(None, description='The set of properties for this artifact (depends on type). Default: - no properties.')
    _init_params: typing.ClassVar[list[str]] = ['assembly', 'artifact_id', 'type', 'dependencies', 'display_name', 'environment', 'metadata', 'properties']
    _method_names: typing.ClassVar[list[str]] = ['find_metadata_by_type']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_manifest']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.CloudFormationStackArtifact'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_manifest']
    ...


    from_manifest: typing.Optional[CloudFormationStackArtifactDefFromManifestParams] = pydantic.Field(None, description='Returns a subclass of ``CloudArtifact`` based on the artifact type defined in the artifact manifest.')
    resource_config: typing.Optional[CloudFormationStackArtifactDefConfig] = pydantic.Field(None)


class CloudFormationStackArtifactDefConfig(pydantic.BaseModel):
    find_metadata_by_type: typing.Optional[list[CloudFormationStackArtifactDefFindMetadataByTypeParams]] = pydantic.Field(None, description=':return: all the metadata entries of a specific type in this artifact.')

class CloudFormationStackArtifactDefFindMetadataByTypeParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='-')
    ...

class CloudFormationStackArtifactDefFromManifestParams(pydantic.BaseModel):
    assembly: models.cx_api.CloudAssemblyDef = pydantic.Field(..., description='The cloud assembly from which to load the artifact.\n')
    id: str = pydantic.Field(..., description='The artifact ID.\n')
    type: aws_cdk.cloud_assembly_schema.ArtifactType = pydantic.Field(..., description='The type of artifact.\n')
    dependencies: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='IDs of artifacts that must be deployed before this artifact. Default: - no dependencies.\n')
    display_name: typing.Optional[str] = pydantic.Field(None, description='A string that represents this artifact. Should only be used in user interfaces. Default: - no display name\n')
    environment: typing.Optional[str] = pydantic.Field(None, description='The environment into which this artifact is deployed. Default: - no envrionment.\n')
    metadata: typing.Optional[typing.Mapping[str, typing.Sequence[typing.Union[models.cloud_assembly_schema.MetadataEntryDef, dict[str, typing.Any]]]]] = pydantic.Field(None, description='Associated metadata. Default: - no metadata.\n')
    properties: typing.Union[models.cloud_assembly_schema.AwsCloudFormationStackPropertiesDef, dict[str, typing.Any], models.cloud_assembly_schema.AssetManifestPropertiesDef, models.cloud_assembly_schema.TreeArtifactPropertiesDef, models.cloud_assembly_schema.NestedCloudAssemblyPropertiesDef, None] = pydantic.Field(None, description='The set of properties for this artifact (depends on type). Default: - no properties.\n')
    ...


#  autogenerated from aws_cdk.cx_api.EnvironmentPlaceholders
class EnvironmentPlaceholdersDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['replace', 'replace_async']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.EnvironmentPlaceholders'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[EnvironmentPlaceholdersDefConfig] = pydantic.Field(None)


class EnvironmentPlaceholdersDefConfig(pydantic.BaseModel):
    replace: typing.Optional[list[EnvironmentPlaceholdersDefReplaceParams]] = pydantic.Field(None, description="Replace the environment placeholders in all strings found in a complex object.\nDuplicated between cdk-assets and aws-cdk CLI because we don't have a good single place to put it\n(they're nominally independent tools).")
    replace_async: typing.Optional[list[EnvironmentPlaceholdersDefReplaceAsyncParams]] = pydantic.Field(None, description="Like 'replace', but asynchronous.")

class EnvironmentPlaceholdersDefReplaceParams(pydantic.BaseModel):
    object: typing.Any = pydantic.Field(..., description='-\n')
    account_id: str = pydantic.Field(..., description='Return the account.\n')
    partition: str = pydantic.Field(..., description='Return the partition.\n')
    region: str = pydantic.Field(..., description='Return the region.')
    ...

class EnvironmentPlaceholdersDefReplaceAsyncParams(pydantic.BaseModel):
    object: typing.Any = pydantic.Field(..., description='-\n')
    provider: models.UnsupportedResource = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.cx_api.EnvironmentUtils
class EnvironmentUtilsDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['format', 'make', 'parse']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.EnvironmentUtils'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['make', 'parse']
    ...


    make: typing.Optional[EnvironmentUtilsDefMakeParams] = pydantic.Field(None, description='Build an environment object from an account and region.')
    parse: typing.Optional[EnvironmentUtilsDefParseParams] = pydantic.Field(None, description='')
    resource_config: typing.Optional[EnvironmentUtilsDefConfig] = pydantic.Field(None)


class EnvironmentUtilsDefConfig(pydantic.BaseModel):
    format: typing.Optional[list[EnvironmentUtilsDefFormatParams]] = pydantic.Field(None, description='Format an environment string from an account and region.')

class EnvironmentUtilsDefFormatParams(pydantic.BaseModel):
    account: str = pydantic.Field(..., description='-\n')
    region: str = pydantic.Field(..., description='-')
    ...

class EnvironmentUtilsDefMakeParams(pydantic.BaseModel):
    account: str = pydantic.Field(..., description='-\n')
    region: str = pydantic.Field(..., description='-')
    ...

class EnvironmentUtilsDefParseParams(pydantic.BaseModel):
    environment: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.cx_api.NestedCloudAssemblyArtifact
class NestedCloudAssemblyArtifactDef(BaseClass):
    assembly: models.cx_api.CloudAssemblyDef = pydantic.Field(..., description='-')
    name: str = pydantic.Field(..., description='-\n')
    type: aws_cdk.cloud_assembly_schema.ArtifactType = pydantic.Field(..., description='The type of artifact.\n')
    dependencies: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='IDs of artifacts that must be deployed before this artifact. Default: - no dependencies.\n')
    display_name: typing.Optional[str] = pydantic.Field(None, description='A string that represents this artifact. Should only be used in user interfaces. Default: - no display name\n')
    environment: typing.Optional[str] = pydantic.Field(None, description='The environment into which this artifact is deployed. Default: - no envrionment.\n')
    metadata: typing.Optional[typing.Mapping[str, typing.Sequence[typing.Union[models.cloud_assembly_schema.MetadataEntryDef, dict[str, typing.Any]]]]] = pydantic.Field(None, description='Associated metadata. Default: - no metadata.\n')
    properties: typing.Union[models.cloud_assembly_schema.AwsCloudFormationStackPropertiesDef, dict[str, typing.Any], models.cloud_assembly_schema.AssetManifestPropertiesDef, models.cloud_assembly_schema.TreeArtifactPropertiesDef, models.cloud_assembly_schema.NestedCloudAssemblyPropertiesDef, None] = pydantic.Field(None, description='The set of properties for this artifact (depends on type). Default: - no properties.')
    _init_params: typing.ClassVar[list[str]] = ['assembly', 'name', 'type', 'dependencies', 'display_name', 'environment', 'metadata', 'properties']
    _method_names: typing.ClassVar[list[str]] = ['find_metadata_by_type']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_manifest']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.NestedCloudAssemblyArtifact'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_manifest']
    ...


    from_manifest: typing.Optional[NestedCloudAssemblyArtifactDefFromManifestParams] = pydantic.Field(None, description='Returns a subclass of ``CloudArtifact`` based on the artifact type defined in the artifact manifest.')
    resource_config: typing.Optional[NestedCloudAssemblyArtifactDefConfig] = pydantic.Field(None)


class NestedCloudAssemblyArtifactDefConfig(pydantic.BaseModel):
    find_metadata_by_type: typing.Optional[list[NestedCloudAssemblyArtifactDefFindMetadataByTypeParams]] = pydantic.Field(None, description=':return: all the metadata entries of a specific type in this artifact.')
    nested_assembly_config: typing.Optional[models.cx_api.CloudAssemblyDefConfig] = pydantic.Field(None)

class NestedCloudAssemblyArtifactDefFindMetadataByTypeParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='-')
    ...

class NestedCloudAssemblyArtifactDefFromManifestParams(pydantic.BaseModel):
    assembly: models.cx_api.CloudAssemblyDef = pydantic.Field(..., description='The cloud assembly from which to load the artifact.\n')
    id: str = pydantic.Field(..., description='The artifact ID.\n')
    type: aws_cdk.cloud_assembly_schema.ArtifactType = pydantic.Field(..., description='The type of artifact.\n')
    dependencies: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='IDs of artifacts that must be deployed before this artifact. Default: - no dependencies.\n')
    display_name: typing.Optional[str] = pydantic.Field(None, description='A string that represents this artifact. Should only be used in user interfaces. Default: - no display name\n')
    environment: typing.Optional[str] = pydantic.Field(None, description='The environment into which this artifact is deployed. Default: - no envrionment.\n')
    metadata: typing.Optional[typing.Mapping[str, typing.Sequence[typing.Union[models.cloud_assembly_schema.MetadataEntryDef, dict[str, typing.Any]]]]] = pydantic.Field(None, description='Associated metadata. Default: - no metadata.\n')
    properties: typing.Union[models.cloud_assembly_schema.AwsCloudFormationStackPropertiesDef, dict[str, typing.Any], models.cloud_assembly_schema.AssetManifestPropertiesDef, models.cloud_assembly_schema.TreeArtifactPropertiesDef, models.cloud_assembly_schema.NestedCloudAssemblyPropertiesDef, None] = pydantic.Field(None, description='The set of properties for this artifact (depends on type). Default: - no properties.\n')
    ...


#  autogenerated from aws_cdk.cx_api.TreeCloudArtifact
class TreeCloudArtifactDef(BaseClass):
    assembly: models.cx_api.CloudAssemblyDef = pydantic.Field(..., description='-')
    name: str = pydantic.Field(..., description='-\n')
    type: aws_cdk.cloud_assembly_schema.ArtifactType = pydantic.Field(..., description='The type of artifact.\n')
    dependencies: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='IDs of artifacts that must be deployed before this artifact. Default: - no dependencies.\n')
    display_name: typing.Optional[str] = pydantic.Field(None, description='A string that represents this artifact. Should only be used in user interfaces. Default: - no display name\n')
    environment: typing.Optional[str] = pydantic.Field(None, description='The environment into which this artifact is deployed. Default: - no envrionment.\n')
    metadata: typing.Optional[typing.Mapping[str, typing.Sequence[typing.Union[models.cloud_assembly_schema.MetadataEntryDef, dict[str, typing.Any]]]]] = pydantic.Field(None, description='Associated metadata. Default: - no metadata.\n')
    properties: typing.Union[models.cloud_assembly_schema.AwsCloudFormationStackPropertiesDef, dict[str, typing.Any], models.cloud_assembly_schema.AssetManifestPropertiesDef, models.cloud_assembly_schema.TreeArtifactPropertiesDef, models.cloud_assembly_schema.NestedCloudAssemblyPropertiesDef, None] = pydantic.Field(None, description='The set of properties for this artifact (depends on type). Default: - no properties.')
    _init_params: typing.ClassVar[list[str]] = ['assembly', 'name', 'type', 'dependencies', 'display_name', 'environment', 'metadata', 'properties']
    _method_names: typing.ClassVar[list[str]] = ['find_metadata_by_type']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_manifest']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.TreeCloudArtifact'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_manifest']
    ...


    from_manifest: typing.Optional[TreeCloudArtifactDefFromManifestParams] = pydantic.Field(None, description='Returns a subclass of ``CloudArtifact`` based on the artifact type defined in the artifact manifest.')
    resource_config: typing.Optional[TreeCloudArtifactDefConfig] = pydantic.Field(None)


class TreeCloudArtifactDefConfig(pydantic.BaseModel):
    find_metadata_by_type: typing.Optional[list[TreeCloudArtifactDefFindMetadataByTypeParams]] = pydantic.Field(None, description=':return: all the metadata entries of a specific type in this artifact.')

class TreeCloudArtifactDefFindMetadataByTypeParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='-')
    ...

class TreeCloudArtifactDefFromManifestParams(pydantic.BaseModel):
    assembly: models.cx_api.CloudAssemblyDef = pydantic.Field(..., description='The cloud assembly from which to load the artifact.\n')
    id: str = pydantic.Field(..., description='The artifact ID.\n')
    type: aws_cdk.cloud_assembly_schema.ArtifactType = pydantic.Field(..., description='The type of artifact.\n')
    dependencies: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='IDs of artifacts that must be deployed before this artifact. Default: - no dependencies.\n')
    display_name: typing.Optional[str] = pydantic.Field(None, description='A string that represents this artifact. Should only be used in user interfaces. Default: - no display name\n')
    environment: typing.Optional[str] = pydantic.Field(None, description='The environment into which this artifact is deployed. Default: - no envrionment.\n')
    metadata: typing.Optional[typing.Mapping[str, typing.Sequence[typing.Union[models.cloud_assembly_schema.MetadataEntryDef, dict[str, typing.Any]]]]] = pydantic.Field(None, description='Associated metadata. Default: - no metadata.\n')
    properties: typing.Union[models.cloud_assembly_schema.AwsCloudFormationStackPropertiesDef, dict[str, typing.Any], models.cloud_assembly_schema.AssetManifestPropertiesDef, models.cloud_assembly_schema.TreeArtifactPropertiesDef, models.cloud_assembly_schema.NestedCloudAssemblyPropertiesDef, None] = pydantic.Field(None, description='The set of properties for this artifact (depends on type). Default: - no properties.\n')
    ...


#  autogenerated from aws_cdk.cx_api.AssemblyBuildOptions
class AssemblyBuildOptionsDef(BaseStruct):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.AssemblyBuildOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cx_api.AwsCloudFormationStackProperties
class AwsCloudFormationStackPropertiesDef(BaseStruct):
    template_file: str = pydantic.Field(..., description='A file relative to the assembly root which contains the CloudFormation template for this stack.\n')
    parameters: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Values for CloudFormation stack parameters that should be passed when the stack is deployed.\n')
    stack_name: typing.Optional[str] = pydantic.Field(None, description='The name to use for the CloudFormation stack. Default: - name derived from artifact ID\n')
    termination_protection: typing.Optional[bool] = pydantic.Field(None, description='Whether to enable termination protection for this stack. Default: false\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cx_api\n\n    aws_cloud_formation_stack_properties = cx_api.AwsCloudFormationStackProperties(\n        template_file="templateFile",\n\n        # the properties below are optional\n        parameters={\n            "parameters_key": "parameters"\n        },\n        stack_name="stackName",\n        termination_protection=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['template_file', 'parameters', 'stack_name', 'termination_protection']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.AwsCloudFormationStackProperties'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cx_api.CloudAssemblyBuilderProps
class CloudAssemblyBuilderPropsDef(BaseStruct):
    asset_outdir: typing.Optional[str] = pydantic.Field(None, description='Use the given asset output directory. Default: - Same as the manifest outdir\n')
    parent_builder: typing.Optional[models.cx_api.CloudAssemblyBuilderDef] = pydantic.Field(None, description='If this builder is for a nested assembly, the parent assembly builder. Default: - This is a root assembly\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cx_api\n\n    # cloud_assembly_builder: cx_api.CloudAssemblyBuilder\n\n    cloud_assembly_builder_props = cx_api.CloudAssemblyBuilderProps(\n        asset_outdir="assetOutdir",\n        parent_builder=cloud_assembly_builder\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['asset_outdir', 'parent_builder']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.CloudAssemblyBuilderProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cx_api.EndpointServiceAvailabilityZonesContextQuery
class EndpointServiceAvailabilityZonesContextQueryDef(BaseStruct):
    account: typing.Optional[str] = pydantic.Field(None, description='Query account.\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Query region.\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='Query service name.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cx_api\n\n    endpoint_service_availability_zones_context_query = cx_api.EndpointServiceAvailabilityZonesContextQuery(\n        account="account",\n        region="region",\n        service_name="serviceName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account', 'region', 'service_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.EndpointServiceAvailabilityZonesContextQuery'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cx_api.Environment
class EnvironmentDef(BaseStruct):
    account: str = pydantic.Field(..., description='The AWS account this environment deploys into.\n')
    name: str = pydantic.Field(..., description='The arbitrary name of this environment (user-set, or at least user-meaningful).\n')
    region: str = pydantic.Field(..., description='The AWS region name where this environment deploys into.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cx_api\n\n    environment = cx_api.Environment(\n        account="account",\n        name="name",\n        region="region"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account', 'name', 'region']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.Environment'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cx_api.EnvironmentPlaceholderValues
class EnvironmentPlaceholderValuesDef(BaseStruct):
    account_id: str = pydantic.Field(..., description='Return the account.\n')
    partition: str = pydantic.Field(..., description='Return the partition.\n')
    region: str = pydantic.Field(..., description='Return the region.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cx_api\n\n    environment_placeholder_values = cx_api.EnvironmentPlaceholderValues(\n        account_id="accountId",\n        partition="partition",\n        region="region"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['account_id', 'partition', 'region']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.EnvironmentPlaceholderValues'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cx_api.KeyContextResponse
class KeyContextResponseDef(BaseStruct):
    key_id: str = pydantic.Field(..., description='Id of the key.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cx_api\n\n    key_context_response = cx_api.KeyContextResponse(\n        key_id="keyId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.KeyContextResponse'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cx_api.LoadBalancerContextResponse
class LoadBalancerContextResponseDef(BaseStruct):
    ip_address_type: aws_cdk.cx_api.LoadBalancerIpAddressType = pydantic.Field(..., description='Type of IP address.\n')
    load_balancer_arn: str = pydantic.Field(..., description='The ARN of the load balancer.\n')
    load_balancer_canonical_hosted_zone_id: str = pydantic.Field(..., description="The hosted zone ID of the load balancer's name.\n")
    load_balancer_dns_name: str = pydantic.Field(..., description="Load balancer's DNS name.\n")
    security_group_ids: typing.Sequence[str] = pydantic.Field(..., description="Load balancer's security groups.\n")
    vpc_id: str = pydantic.Field(..., description='Load balancer\'s VPC.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cx_api\n\n    load_balancer_context_response = cx_api.LoadBalancerContextResponse(\n        ip_address_type=cx_api.LoadBalancerIpAddressType.IPV4,\n        load_balancer_arn="loadBalancerArn",\n        load_balancer_canonical_hosted_zone_id="loadBalancerCanonicalHostedZoneId",\n        load_balancer_dns_name="loadBalancerDnsName",\n        security_group_ids=["securityGroupIds"],\n        vpc_id="vpcId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ip_address_type', 'load_balancer_arn', 'load_balancer_canonical_hosted_zone_id', 'load_balancer_dns_name', 'security_group_ids', 'vpc_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.LoadBalancerContextResponse'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cx_api.LoadBalancerListenerContextResponse
class LoadBalancerListenerContextResponseDef(BaseStruct):
    listener_arn: str = pydantic.Field(..., description='The ARN of the listener.\n')
    listener_port: typing.Union[int, float] = pydantic.Field(..., description='The port the listener is listening on.\n')
    security_group_ids: typing.Sequence[str] = pydantic.Field(..., description='The security groups of the load balancer.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cx_api\n\n    load_balancer_listener_context_response = cx_api.LoadBalancerListenerContextResponse(\n        listener_arn="listenerArn",\n        listener_port=123,\n        security_group_ids=["securityGroupIds"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['listener_arn', 'listener_port', 'security_group_ids']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.LoadBalancerListenerContextResponse'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cx_api.MetadataEntryResult
class MetadataEntryResultDef(BaseStruct):
    type: str = pydantic.Field(..., description='The type of the metadata entry.')
    data: typing.Union[str, models.cloud_assembly_schema.FileAssetMetadataEntryDef, dict[str, typing.Any], models.cloud_assembly_schema.ContainerImageAssetMetadataEntryDef, typing.Sequence[typing.Union[models.cloud_assembly_schema.TagDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The data. Default: - no data.\n')
    trace: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A stack trace for when the entry was created. Default: - no trace.\n')
    path: str = pydantic.Field(..., description='The path in which this entry was defined.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cx_api\n\n    metadata_entry_result = cx_api.MetadataEntryResult(\n        path="path",\n        type="type",\n\n        # the properties below are optional\n        data="data",\n        trace=["trace"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'data', 'trace', 'path']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.MetadataEntryResult'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cx_api.SecurityGroupContextResponse
class SecurityGroupContextResponseDef(BaseStruct):
    allow_all_outbound: bool = pydantic.Field(..., description='Whether the security group allows all outbound traffic. This will be true when the security group has all-protocol egress permissions to access both ``0.0.0.0/0`` and ``::/0``.\n')
    security_group_id: str = pydantic.Field(..., description='The security group\'s id.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cx_api\n\n    security_group_context_response = cx_api.SecurityGroupContextResponse(\n        allow_all_outbound=False,\n        security_group_id="securityGroupId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allow_all_outbound', 'security_group_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.SecurityGroupContextResponse'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cx_api.SynthesisMessage
class SynthesisMessageDef(BaseStruct):
    entry: typing.Union[models.cloud_assembly_schema.MetadataEntryDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    level: aws_cdk.cx_api.SynthesisMessageLevel = pydantic.Field(..., description='')
    _init_params: typing.ClassVar[list[str]] = ['entry', 'level']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.SynthesisMessage'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cx_api.VpcContextResponse
class VpcContextResponseDef(BaseStruct):
    availability_zones: typing.Sequence[str] = pydantic.Field(..., description='AZs.\n')
    vpc_id: str = pydantic.Field(..., description='VPC id.\n')
    isolated_subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='IDs of all isolated subnets. Element count: #(availabilityZones) · #(isolatedGroups)\n')
    isolated_subnet_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Name of isolated subnet groups. Element count: #(isolatedGroups)\n')
    isolated_subnet_route_table_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Route Table IDs of isolated subnet groups. Element count: #(availabilityZones) · #(isolatedGroups)\n')
    owner_account_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the AWS account that owns the VPC. Default: the account id of the parent stack\n')
    private_subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='IDs of all private subnets. Element count: #(availabilityZones) · #(privateGroups)\n')
    private_subnet_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Name of private subnet groups. Element count: #(privateGroups)\n')
    private_subnet_route_table_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Route Table IDs of private subnet groups. Element count: #(availabilityZones) · #(privateGroups)\n')
    public_subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='IDs of all public subnets. Element count: #(availabilityZones) · #(publicGroups)\n')
    public_subnet_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Name of public subnet groups. Element count: #(publicGroups)\n')
    public_subnet_route_table_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Route Table IDs of public subnet groups. Element count: #(availabilityZones) · #(publicGroups)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region in which the VPC is in. Default: - Region of the parent stack\n')
    subnet_groups: typing.Optional[typing.Sequence[typing.Union[models.cx_api.VpcSubnetGroupDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The subnet groups discovered for the given VPC. Unlike the above properties, this will include asymmetric subnets, if the VPC has any. This property will only be populated if ``VpcContextQuery.returnAsymmetricSubnets`` is true. Default: - no subnet groups will be returned unless ``VpcContextQuery.returnAsymmetricSubnets`` is true\n')
    vpc_cidr_block: typing.Optional[str] = pydantic.Field(None, description='VPC cidr. Default: - CIDR information not available\n')
    vpn_gateway_id: typing.Optional[str] = pydantic.Field(None, description='The VPN gateway ID.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cx_api\n\n    vpc_context_response = cx_api.VpcContextResponse(\n        availability_zones=["availabilityZones"],\n        vpc_id="vpcId",\n\n        # the properties below are optional\n        isolated_subnet_ids=["isolatedSubnetIds"],\n        isolated_subnet_names=["isolatedSubnetNames"],\n        isolated_subnet_route_table_ids=["isolatedSubnetRouteTableIds"],\n        owner_account_id="ownerAccountId",\n        private_subnet_ids=["privateSubnetIds"],\n        private_subnet_names=["privateSubnetNames"],\n        private_subnet_route_table_ids=["privateSubnetRouteTableIds"],\n        public_subnet_ids=["publicSubnetIds"],\n        public_subnet_names=["publicSubnetNames"],\n        public_subnet_route_table_ids=["publicSubnetRouteTableIds"],\n        region="region",\n        subnet_groups=[cx_api.VpcSubnetGroup(\n            name="name",\n            subnets=[cx_api.VpcSubnet(\n                availability_zone="availabilityZone",\n                route_table_id="routeTableId",\n                subnet_id="subnetId",\n\n                # the properties below are optional\n                cidr="cidr"\n            )],\n            type=cx_api.VpcSubnetGroupType.PUBLIC\n        )],\n        vpc_cidr_block="vpcCidrBlock",\n        vpn_gateway_id="vpnGatewayId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zones', 'vpc_id', 'isolated_subnet_ids', 'isolated_subnet_names', 'isolated_subnet_route_table_ids', 'owner_account_id', 'private_subnet_ids', 'private_subnet_names', 'private_subnet_route_table_ids', 'public_subnet_ids', 'public_subnet_names', 'public_subnet_route_table_ids', 'region', 'subnet_groups', 'vpc_cidr_block', 'vpn_gateway_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.VpcContextResponse'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cx_api.VpcSubnet
class VpcSubnetDef(BaseStruct):
    availability_zone: str = pydantic.Field(..., description="The code of the availability zone this subnet is in (for example, 'us-west-2a').\n")
    route_table_id: str = pydantic.Field(..., description='The identifier of the route table for this subnet.\n')
    subnet_id: str = pydantic.Field(..., description='The identifier of the subnet.\n')
    cidr: typing.Optional[str] = pydantic.Field(None, description='CIDR range of the subnet. Default: - CIDR information not available\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cx_api\n\n    vpc_subnet = cx_api.VpcSubnet(\n        availability_zone="availabilityZone",\n        route_table_id="routeTableId",\n        subnet_id="subnetId",\n\n        # the properties below are optional\n        cidr="cidr"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'route_table_id', 'subnet_id', 'cidr']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.VpcSubnet'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cx_api.VpcSubnetGroup
class VpcSubnetGroupDef(BaseStruct):
    name: str = pydantic.Field(..., description='The name of the subnet group, determined by looking at the tags of of the subnets that belong to it.\n')
    subnets: typing.Sequence[typing.Union[models.cx_api.VpcSubnetDef, dict[str, typing.Any]]] = pydantic.Field(..., description='The subnets that are part of this group. There is no condition that the subnets have to be symmetric in the group.\n')
    type: aws_cdk.cx_api.VpcSubnetGroupType = pydantic.Field(..., description='The type of the subnet group.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import cx_api\n\n    vpc_subnet_group = cx_api.VpcSubnetGroup(\n        name="name",\n        subnets=[cx_api.VpcSubnet(\n            availability_zone="availabilityZone",\n            route_table_id="routeTableId",\n            subnet_id="subnetId",\n\n            # the properties below are optional\n            cidr="cidr"\n        )],\n        type=cx_api.VpcSubnetGroupType.PUBLIC\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'subnets', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.cx_api.VpcSubnetGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.cx_api.LoadBalancerIpAddressType
# skipping emum

#  autogenerated from aws_cdk.cx_api.SynthesisMessageLevel
# skipping emum

#  autogenerated from aws_cdk.cx_api.VpcSubnetGroupType
# skipping emum

#  autogenerated from aws_cdk.cx_api.IEnvironmentPlaceholderProvider
#  skipping Interface

import models

class ModuleModel(pydantic.BaseModel):
    AssetManifestArtifact: typing.Optional[dict[str, AssetManifestArtifactDef]] = pydantic.Field(None)
    CloudArtifact: typing.Optional[dict[str, CloudArtifactDef]] = pydantic.Field(None)
    CloudAssembly: typing.Optional[dict[str, CloudAssemblyDef]] = pydantic.Field(None)
    CloudAssemblyBuilder: typing.Optional[dict[str, CloudAssemblyBuilderDef]] = pydantic.Field(None)
    CloudFormationStackArtifact: typing.Optional[dict[str, CloudFormationStackArtifactDef]] = pydantic.Field(None)
    EnvironmentPlaceholders: typing.Optional[dict[str, EnvironmentPlaceholdersDef]] = pydantic.Field(None)
    EnvironmentUtils: typing.Optional[dict[str, EnvironmentUtilsDef]] = pydantic.Field(None)
    NestedCloudAssemblyArtifact: typing.Optional[dict[str, NestedCloudAssemblyArtifactDef]] = pydantic.Field(None)
    TreeCloudArtifact: typing.Optional[dict[str, TreeCloudArtifactDef]] = pydantic.Field(None)
    AssemblyBuildOptions: typing.Optional[dict[str, AssemblyBuildOptionsDef]] = pydantic.Field(None)
    AwsCloudFormationStackProperties: typing.Optional[dict[str, AwsCloudFormationStackPropertiesDef]] = pydantic.Field(None)
    CloudAssemblyBuilderProps: typing.Optional[dict[str, CloudAssemblyBuilderPropsDef]] = pydantic.Field(None)
    EndpointServiceAvailabilityZonesContextQuery: typing.Optional[dict[str, EndpointServiceAvailabilityZonesContextQueryDef]] = pydantic.Field(None)
    Environment: typing.Optional[dict[str, EnvironmentDef]] = pydantic.Field(None)
    EnvironmentPlaceholderValues: typing.Optional[dict[str, EnvironmentPlaceholderValuesDef]] = pydantic.Field(None)
    KeyContextResponse: typing.Optional[dict[str, KeyContextResponseDef]] = pydantic.Field(None)
    LoadBalancerContextResponse: typing.Optional[dict[str, LoadBalancerContextResponseDef]] = pydantic.Field(None)
    LoadBalancerListenerContextResponse: typing.Optional[dict[str, LoadBalancerListenerContextResponseDef]] = pydantic.Field(None)
    MetadataEntryResult: typing.Optional[dict[str, MetadataEntryResultDef]] = pydantic.Field(None)
    SecurityGroupContextResponse: typing.Optional[dict[str, SecurityGroupContextResponseDef]] = pydantic.Field(None)
    SynthesisMessage: typing.Optional[dict[str, SynthesisMessageDef]] = pydantic.Field(None)
    VpcContextResponse: typing.Optional[dict[str, VpcContextResponseDef]] = pydantic.Field(None)
    VpcSubnet: typing.Optional[dict[str, VpcSubnetDef]] = pydantic.Field(None)
    VpcSubnetGroup: typing.Optional[dict[str, VpcSubnetGroupDef]] = pydantic.Field(None)
    ...
