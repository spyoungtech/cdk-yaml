from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams

#  autogenerated from aws_cdk.aws_codepipeline.Action
class ActionDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind', 'on_state_change']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.Action'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ActionDefConfig] = pydantic.Field(None)


class ActionDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[ActionDefBindParams]] = pydantic.Field(None, description='The callback invoked when this Action is added to a Pipeline.')
    on_state_change: typing.Optional[list[ActionDefOnStateChangeParams]] = pydantic.Field(None, description='Creates an Event that will be triggered whenever the state of this Action changes.')

class ActionDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    stage: models.UnsupportedResource = pydantic.Field(..., description='-\n')
    bucket: typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef] = pydantic.Field(..., description='')
    role: typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef] = pydantic.Field(..., description='')
    ...

class ActionDefOnStateChangeParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='-\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='-\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the rule is enabled. Default: true\n')
    event_bus: typing.Optional[typing.Union[models.aws_events.EventBusDef]] = pydantic.Field(None, description='The event bus to associate with this rule. Default: - The default event bus.\n')
    schedule: typing.Optional[models.aws_events.ScheduleDef] = pydantic.Field(None, description='The schedule or rate (frequency) that determines when EventBridge runs the rule. You must specify this property, the ``eventPattern`` property, or both. For more information, see Schedule Expression Syntax for Rules in the Amazon EventBridge User Guide. Default: - None.\n')
    targets: typing.Optional[typing.Sequence[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]]] = pydantic.Field(None, description='Targets to invoke when this rule matches an event. Input will be the full matched event. If you wish to specify custom target input, use ``addTarget(target[, inputOptions])``. Default: - No targets.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_codepipeline.Artifact
class ArtifactDef(BaseClass):
    artifact_name: typing.Optional[str] = pydantic.Field(None, description='-')
    _init_params: typing.ClassVar[list[str]] = ['artifact_name']
    _method_names: typing.ClassVar[list[str]] = ['at_path', 'get_metadata', 'get_param', 'set_metadata']
    _classmethod_names: typing.ClassVar[list[str]] = ['artifact']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.Artifact'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ArtifactDefConfig] = pydantic.Field(None)


class ArtifactDefConfig(pydantic.BaseModel):
    artifact: typing.Optional[list[ArtifactDefArtifactParams]] = pydantic.Field(None, description='A static factory method used to create instances of the Artifact class.\nMainly meant to be used from ``decdk``.')
    at_path: typing.Optional[list[ArtifactDefAtPathParams]] = pydantic.Field(None, description='Returns an ArtifactPath for a file within this artifact.\nCfnOutput is in the form "::"')
    get_metadata: typing.Optional[list[ArtifactDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve the metadata stored in this artifact under the given key.\nIf there is no metadata stored under the given key,\nnull will be returned.')
    get_param: typing.Optional[list[ArtifactDefGetParamParams]] = pydantic.Field(None, description='Returns a token for a value inside a JSON file within this artifact.')
    set_metadata: typing.Optional[list[ArtifactDefSetMetadataParams]] = pydantic.Field(None, description='Add arbitrary extra payload to the artifact under a given key.\nThis can be used by CodePipeline actions to communicate data between themselves.\nIf metadata was already present under the given key,\nit will be overwritten with the new value.')

class ArtifactDefArtifactParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='the (required) name of the Artifact.')
    return_config: typing.Optional[list[models.aws_codepipeline.ArtifactDefConfig]] = pydantic.Field(None)
    ...

class ArtifactDefAtPathParams(pydantic.BaseModel):
    file_name: str = pydantic.Field(..., description='The name of the file.')
    return_config: typing.Optional[list[models.aws_codepipeline.ArtifactPathDefConfig]] = pydantic.Field(None)
    ...

class ArtifactDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-')
    ...

class ArtifactDefGetParamParams(pydantic.BaseModel):
    json_file: str = pydantic.Field(..., description='The JSON file name.\n')
    key_name: str = pydantic.Field(..., description='The hash key.')
    ...

class ArtifactDefSetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_codepipeline.ArtifactPath
class ArtifactPathDef(BaseClass):
    artifact: models.aws_codepipeline.ArtifactDef = pydantic.Field(..., description='-')
    file_name: str = pydantic.Field(..., description='-')
    _init_params: typing.ClassVar[list[str]] = ['artifact', 'file_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['artifact_path']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.ArtifactPath'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ArtifactPathDefConfig] = pydantic.Field(None)


class ArtifactPathDefConfig(pydantic.BaseModel):
    artifact_path: typing.Optional[list[ArtifactPathDefArtifactPathParams]] = pydantic.Field(None, description='')
    artifact_config: typing.Optional[models.aws_codepipeline.ArtifactDefConfig] = pydantic.Field(None)

class ArtifactPathDefArtifactPathParams(pydantic.BaseModel):
    artifact_name: str = pydantic.Field(..., description='-')
    file_name: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_codepipeline.ArtifactPathDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_codepipeline.GlobalVariables
class GlobalVariablesDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.GlobalVariables'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CustomActionRegistration
class CustomActionRegistrationDef(BaseConstruct):
    artifact_bounds: typing.Union[models.aws_codepipeline.ActionArtifactBoundsDef, dict[str, typing.Any]] = pydantic.Field(..., description='The artifact bounds of the Action.\n')
    category: aws_cdk.aws_codepipeline.ActionCategory = pydantic.Field(..., description='The category of the Action.\n')
    provider: str = pydantic.Field(..., description="The provider of the Action. For example, ``'MyCustomActionProvider'``\n")
    action_properties: typing.Optional[typing.Sequence[typing.Union[models.aws_codepipeline.CustomActionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The properties used for customizing the instance of your Action. Default: []\n')
    entity_url: typing.Optional[str] = pydantic.Field(None, description='The URL shown for the entire Action in the Pipeline UI. Default: none\n')
    execution_url: typing.Optional[str] = pydantic.Field(None, description='The URL shown for a particular execution of an Action in the Pipeline UI. Default: none\n')
    version: typing.Optional[str] = pydantic.Field(None, description="The version of your Action. Default: '1'")
    _init_params: typing.ClassVar[list[str]] = ['artifact_bounds', 'category', 'provider', 'action_properties', 'entity_url', 'execution_url', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CustomActionRegistration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.Pipeline
class PipelineDef(BaseConstruct):
    artifact_bucket: typing.Optional[typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef]] = pydantic.Field(None, description='The S3 bucket used by this Pipeline to store artifacts. Default: - A new S3 bucket will be created.\n')
    cross_account_keys: typing.Optional[bool] = pydantic.Field(None, description='Create KMS keys for cross-account deployments. This controls whether the pipeline is enabled for cross-account deployments. By default cross-account deployments are enabled, but this feature requires that KMS Customer Master Keys are created which have a cost of $1/month. If you do not need cross-account deployments, you can set this to ``false`` to not create those keys and save on that cost (the artifact bucket will be encrypted with an AWS-managed key). However, cross-account deployments will no longer be possible. Default: true\n')
    cross_region_replication_buckets: typing.Optional[typing.Mapping[str, typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef]]] = pydantic.Field(None, description="A map of region to S3 bucket name used for cross-region CodePipeline. For every Action that you specify targeting a different region than the Pipeline itself, if you don't provide an explicit Bucket for that region using this property, the construct will automatically create a Stack containing an S3 Bucket in that region. Default: - None.\n")
    enable_key_rotation: typing.Optional[bool] = pydantic.Field(None, description='Enable KMS key rotation for the generated KMS keys. By default KMS key rotation is disabled, but will add an additional $1/month for each year the key exists when enabled. Default: - false (key rotation is disabled)\n')
    pipeline_name: typing.Optional[str] = pydantic.Field(None, description='Name of the pipeline. Default: - AWS CloudFormation generates an ID and uses that for the pipeline name.\n')
    restart_execution_on_update: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to rerun the AWS CodePipeline pipeline after you update it. Default: false\n')
    reuse_cross_region_support_stacks: typing.Optional[bool] = pydantic.Field(None, description='Reuse the same cross region support stack for all pipelines in the App. Default: - true (Use the same support stack for all pipelines in App)\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The IAM role to be assumed by this Pipeline. Default: a new IAM role will be created.\n')
    stages: typing.Optional[typing.Sequence[typing.Union[models.aws_codepipeline.StagePropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The list of Stages, in order, to create this Pipeline with. You can always add more Stages later by calling ``Pipeline#addStage``. Default: - None.')
    _init_params: typing.ClassVar[list[str]] = ['artifact_bucket', 'cross_account_keys', 'cross_region_replication_buckets', 'enable_key_rotation', 'pipeline_name', 'restart_execution_on_update', 'reuse_cross_region_support_stacks', 'role', 'stages']
    _method_names: typing.ClassVar[list[str]] = ['add_stage', 'add_to_role_policy', 'apply_removal_policy', 'bind_as_notification_rule_source', 'notify_on', 'notify_on_any_action_state_change', 'notify_on_any_manual_approval_state_change', 'notify_on_any_stage_state_change', 'notify_on_execution_state_change', 'on_event', 'on_state_change', 'stage']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_pipeline_arn']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.Pipeline'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_pipeline_arn']
    ...


    from_pipeline_arn: typing.Optional[PipelineDefFromPipelineArnParams] = pydantic.Field(None, description='Import a pipeline into this app.')
    resource_config: typing.Optional[PipelineDefConfig] = pydantic.Field(None)


class PipelineDefConfig(pydantic.BaseModel):
    add_stage: typing.Optional[list[PipelineDefAddStageParams]] = pydantic.Field(None, description='Creates a new Stage, and adds it to this Pipeline.')
    add_to_role_policy: typing.Optional[list[PipelineDefAddToRolePolicyParams]] = pydantic.Field(None, description='Adds a statement to the pipeline role.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    bind_as_notification_rule_source: typing.Optional[list[PipelineDefBindAsNotificationRuleSourceParams]] = pydantic.Field(None, description='Returns a source configuration for notification rule.')
    notify_on: typing.Optional[list[PipelineDefNotifyOnParams]] = pydantic.Field(None, description='Defines a CodeStar notification rule triggered when the pipeline events emitted by you specified, it very similar to ``onEvent`` API.\nYou can also use the methods ``notifyOnExecutionStateChange``, ``notifyOnAnyStageStateChange``,\n``notifyOnAnyActionStateChange`` and ``notifyOnAnyManualApprovalStateChange``\nto define rules for these specific event emitted.')
    notify_on_any_action_state_change: typing.Optional[list[PipelineDefNotifyOnAnyActionStateChangeParams]] = pydantic.Field(None, description='Define an notification rule triggered by the set of the "Action execution" events emitted from this pipeline.')
    notify_on_any_manual_approval_state_change: typing.Optional[list[PipelineDefNotifyOnAnyManualApprovalStateChangeParams]] = pydantic.Field(None, description='Define an notification rule triggered by the set of the "Manual approval" events emitted from this pipeline.')
    notify_on_any_stage_state_change: typing.Optional[list[PipelineDefNotifyOnAnyStageStateChangeParams]] = pydantic.Field(None, description='Define an notification rule triggered by the set of the "Stage execution" events emitted from this pipeline.')
    notify_on_execution_state_change: typing.Optional[list[PipelineDefNotifyOnExecutionStateChangeParams]] = pydantic.Field(None, description='Define an notification rule triggered by the set of the "Pipeline execution" events emitted from this pipeline.')
    on_event: typing.Optional[list[PipelineDefOnEventParams]] = pydantic.Field(None, description='Defines an event rule triggered by this CodePipeline.')
    on_state_change: typing.Optional[list[PipelineDefOnStateChangeParams]] = pydantic.Field(None, description='Defines an event rule triggered by the "CodePipeline Pipeline Execution State Change" event emitted from this pipeline.')
    stage: typing.Optional[list[PipelineDefStageParams]] = pydantic.Field(None, description="Access one of the pipeline's stages by stage name.")
    artifact_bucket_config: typing.Optional[models._interface_methods.AwsS3IBucketDefConfig] = pydantic.Field(None)
    role_config: typing.Optional[models._interface_methods.AwsIamIRoleDefConfig] = pydantic.Field(None)

class PipelineDefAddStageParams(pydantic.BaseModel):
    placement: typing.Union[models.aws_codepipeline.StagePlacementDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    stage_name: str = pydantic.Field(..., description='The physical, human-readable name to assign to this Pipeline Stage.\n')
    actions: typing.Optional[typing.Sequence[typing.Union[models.aws_codepipeline.ActionDef, models.aws_codepipeline_actions.ActionDef, models.aws_codepipeline_actions.AlexaSkillDeployActionDef, models.aws_codepipeline_actions.CloudFormationCreateReplaceChangeSetActionDef, models.aws_codepipeline_actions.CloudFormationCreateUpdateStackActionDef, models.aws_codepipeline_actions.CloudFormationDeleteStackActionDef, models.aws_codepipeline_actions.CloudFormationDeployStackInstancesActionDef, models.aws_codepipeline_actions.CloudFormationDeployStackSetActionDef, models.aws_codepipeline_actions.CloudFormationExecuteChangeSetActionDef, models.aws_codepipeline_actions.CodeBuildActionDef, models.aws_codepipeline_actions.CodeCommitSourceActionDef, models.aws_codepipeline_actions.CodeDeployEcsDeployActionDef, models.aws_codepipeline_actions.CodeDeployServerDeployActionDef, models.aws_codepipeline_actions.CodeStarConnectionsSourceActionDef, models.aws_codepipeline_actions.EcrSourceActionDef, models.aws_codepipeline_actions.EcsDeployActionDef, models.aws_codepipeline_actions.ElasticBeanstalkDeployActionDef, models.aws_codepipeline_actions.GitHubSourceActionDef, models.aws_codepipeline_actions.JenkinsActionDef, models.aws_codepipeline_actions.LambdaInvokeActionDef, models.aws_codepipeline_actions.ManualApprovalActionDef, models.aws_codepipeline_actions.S3DeployActionDef, models.aws_codepipeline_actions.S3SourceActionDef, models.aws_codepipeline_actions.ServiceCatalogDeployActionBeta1Def, models.aws_codepipeline_actions.StepFunctionInvokeActionDef]]] = pydantic.Field(None, description='The list of Actions to create this Stage with. You can always add more Actions later by calling ``IStage#addAction``.\n')
    transition_disabled_reason: typing.Optional[str] = pydantic.Field(None, description="The reason for disabling transition to this stage. Only applicable if ``transitionToEnabled`` is set to ``false``. Default: 'Transition disabled'\n")
    transition_to_enabled: typing.Optional[bool] = pydantic.Field(None, description='Whether to enable transition to this stage. Default: true\n')
    return_config: typing.Optional[list[models._interface_methods.AwsCodepipelineIStageDefConfig]] = pydantic.Field(None)
    ...

class PipelineDefAddToRolePolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class PipelineDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class PipelineDefBindAsNotificationRuleSourceParams(pydantic.BaseModel):
    _scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class PipelineDefFromPipelineArnParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the scope into which to import this pipeline.\n')
    id: str = pydantic.Field(..., description='the logical ID of the returned pipeline construct.\n')
    pipeline_arn: str = pydantic.Field(..., description='The ARN of the pipeline (e.g. ``arn:aws:codepipeline:us-east-1:123456789012:MyDemoPipeline``).')
    ...

class PipelineDefNotifyOnParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: models.UnsupportedResource = pydantic.Field(..., description='-\n')
    events: typing.Sequence[aws_cdk.aws_codepipeline.PipelineNotificationEvents] = pydantic.Field(..., description='A list of event types associated with this notification rule for CodePipeline Pipeline. For a complete list of event types and IDs, see Notification concepts in the Developer Tools Console User Guide.\n')
    detail_type: typing.Optional[aws_cdk.aws_codestarnotifications.DetailType] = pydantic.Field(None, description='The level of detail to include in the notifications for this resource. BASIC will include only the contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created. Default: DetailType.FULL\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description="The status of the notification rule. If the enabled is set to DISABLED, notifications aren't sent for the notification rule. Default: true\n")
    notification_rule_name: typing.Optional[str] = pydantic.Field(None, description='The name for the notification rule. Notification rule names must be unique in your AWS account. Default: - generated from the ``id``')
    return_config: typing.Optional[list[models._interface_methods.AwsCodestarnotificationsINotificationRuleDefConfig]] = pydantic.Field(None)
    ...

class PipelineDefNotifyOnAnyActionStateChangeParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: models.UnsupportedResource = pydantic.Field(..., description='-\n')
    detail_type: typing.Optional[aws_cdk.aws_codestarnotifications.DetailType] = pydantic.Field(None, description='The level of detail to include in the notifications for this resource. BASIC will include only the contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created. Default: DetailType.FULL\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description="The status of the notification rule. If the enabled is set to DISABLED, notifications aren't sent for the notification rule. Default: true\n")
    notification_rule_name: typing.Optional[str] = pydantic.Field(None, description='The name for the notification rule. Notification rule names must be unique in your AWS account. Default: - generated from the ``id``')
    return_config: typing.Optional[list[models._interface_methods.AwsCodestarnotificationsINotificationRuleDefConfig]] = pydantic.Field(None)
    ...

class PipelineDefNotifyOnAnyManualApprovalStateChangeParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: models.UnsupportedResource = pydantic.Field(..., description='-\n')
    detail_type: typing.Optional[aws_cdk.aws_codestarnotifications.DetailType] = pydantic.Field(None, description='The level of detail to include in the notifications for this resource. BASIC will include only the contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created. Default: DetailType.FULL\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description="The status of the notification rule. If the enabled is set to DISABLED, notifications aren't sent for the notification rule. Default: true\n")
    notification_rule_name: typing.Optional[str] = pydantic.Field(None, description='The name for the notification rule. Notification rule names must be unique in your AWS account. Default: - generated from the ``id``')
    return_config: typing.Optional[list[models._interface_methods.AwsCodestarnotificationsINotificationRuleDefConfig]] = pydantic.Field(None)
    ...

class PipelineDefNotifyOnAnyStageStateChangeParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: models.UnsupportedResource = pydantic.Field(..., description='-\n')
    detail_type: typing.Optional[aws_cdk.aws_codestarnotifications.DetailType] = pydantic.Field(None, description='The level of detail to include in the notifications for this resource. BASIC will include only the contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created. Default: DetailType.FULL\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description="The status of the notification rule. If the enabled is set to DISABLED, notifications aren't sent for the notification rule. Default: true\n")
    notification_rule_name: typing.Optional[str] = pydantic.Field(None, description='The name for the notification rule. Notification rule names must be unique in your AWS account. Default: - generated from the ``id``')
    return_config: typing.Optional[list[models._interface_methods.AwsCodestarnotificationsINotificationRuleDefConfig]] = pydantic.Field(None)
    ...

class PipelineDefNotifyOnExecutionStateChangeParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    target: models.UnsupportedResource = pydantic.Field(..., description='-\n')
    detail_type: typing.Optional[aws_cdk.aws_codestarnotifications.DetailType] = pydantic.Field(None, description='The level of detail to include in the notifications for this resource. BASIC will include only the contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created. Default: DetailType.FULL\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description="The status of the notification rule. If the enabled is set to DISABLED, notifications aren't sent for the notification rule. Default: true\n")
    notification_rule_name: typing.Optional[str] = pydantic.Field(None, description='The name for the notification rule. Notification rule names must be unique in your AWS account. Default: - generated from the ``id``')
    return_config: typing.Optional[list[models._interface_methods.AwsCodestarnotificationsINotificationRuleDefConfig]] = pydantic.Field(None)
    ...

class PipelineDefOnEventParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='Identifier for this event handler.\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class PipelineDefOnStateChangeParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='Identifier for this event handler.\n')
    target: typing.Optional[typing.Union[models.aws_events_targets.ApiDestinationDef, models.aws_events_targets.ApiGatewayDef, models.aws_events_targets.AwsApiDef, models.aws_events_targets.BatchJobDef, models.aws_events_targets.CloudWatchLogGroupDef, models.aws_events_targets.CodeBuildProjectDef, models.aws_events_targets.CodePipelineDef, models.aws_events_targets.EcsTaskDef, models.aws_events_targets.EventBusDef, models.aws_events_targets.KinesisFirehoseStreamDef, models.aws_events_targets.KinesisStreamDef, models.aws_events_targets.LambdaFunctionDef, models.aws_events_targets.SfnStateMachineDef, models.aws_events_targets.SnsTopicDef, models.aws_events_targets.SqsQueueDef]] = pydantic.Field(None, description='The target to register for the event. Default: - No target is added to the rule. Use ``addTarget()`` to add a target.\n')
    cross_stack_scope: typing.Optional[models.constructs.ConstructDef] = pydantic.Field(None, description='The scope to use if the source of the rule and its target are in different Stacks (but in the same account & region). This helps dealing with cycles that often arise in these situations. Default: - none (the main scope will be used, even for cross-stack Events)\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the rule's purpose. Default: - No description\n")
    event_pattern: typing.Union[models.aws_events.EventPatternDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Additional restrictions for the event to route to the specified target. The method that generates the rule probably imposes some type of event filtering. The filtering implied by what you pass here is added on top of that filtering. Default: - No additional filtering based on an event pattern.\n')
    rule_name: typing.Optional[str] = pydantic.Field(None, description='A name for the rule. Default: AWS CloudFormation generates a unique physical ID.')
    return_config: typing.Optional[list[models.aws_events.RuleDefConfig]] = pydantic.Field(None)
    ...

class PipelineDefStageParams(pydantic.BaseModel):
    stage_name: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models._interface_methods.AwsCodepipelineIStageDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_codepipeline.ActionArtifactBounds
class ActionArtifactBoundsDef(BaseStruct):
    max_inputs: typing.Union[int, float] = pydantic.Field(..., description='')
    max_outputs: typing.Union[int, float] = pydantic.Field(..., description='')
    min_inputs: typing.Union[int, float] = pydantic.Field(..., description='')
    min_outputs: typing.Union[int, float] = pydantic.Field(..., description='')
    _init_params: typing.ClassVar[list[str]] = ['max_inputs', 'max_outputs', 'min_inputs', 'min_outputs']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.ActionArtifactBounds'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.ActionBindOptions
class ActionBindOptionsDef(BaseStruct):
    bucket: typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef] = pydantic.Field(..., description='')
    role: typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef] = pydantic.Field(..., description='')
    _init_params: typing.ClassVar[list[str]] = ['bucket', 'role']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.ActionBindOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ActionBindOptionsDefConfig] = pydantic.Field(None)


class ActionBindOptionsDefConfig(pydantic.BaseModel):
    bucket_config: typing.Optional[models._interface_methods.AwsS3IBucketDefConfig] = pydantic.Field(None)
    role_config: typing.Optional[models._interface_methods.AwsIamIRoleDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_codepipeline.ActionConfig
class ActionConfigDef(BaseStruct):
    configuration: typing.Any = pydantic.Field(None, description='')
    _init_params: typing.ClassVar[list[str]] = ['configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.ActionConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.ActionProperties
class ActionPropertiesDef(BaseStruct):
    action_name: str = pydantic.Field(..., description='')
    artifact_bounds: typing.Union[models.aws_codepipeline.ActionArtifactBoundsDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    category: aws_cdk.aws_codepipeline.ActionCategory = pydantic.Field(..., description='The category of the action. The category defines which action type the owner (the entity that performs the action) performs.\n')
    provider: str = pydantic.Field(..., description='The service provider that the action calls.\n')
    account: typing.Optional[str] = pydantic.Field(None, description='The account the Action is supposed to live in. For Actions backed by resources, this is inferred from the Stack ``resource`` is part of. However, some Actions, like the CloudFormation ones, are not backed by any resource, and they still might want to be cross-account. In general, a concrete Action class should specify either ``resource``, or ``account`` - but not both.\n')
    inputs: typing.Optional[typing.Sequence[models.aws_codepipeline.ArtifactDef]] = pydantic.Field(None, description='')
    outputs: typing.Optional[typing.Sequence[models.aws_codepipeline.ArtifactDef]] = pydantic.Field(None, description='')
    owner: typing.Optional[str] = pydantic.Field(None, description='')
    region: typing.Optional[str] = pydantic.Field(None, description="The AWS region the given Action resides in. Note that a cross-region Pipeline requires replication buckets to function correctly. You can provide their names with the ``PipelineProps#crossRegionReplicationBuckets`` property. If you don't, the CodePipeline Construct will create new Stacks in your CDK app containing those buckets, that you will need to ``cdk deploy`` before deploying the main, Pipeline-containing Stack. Default: the Action resides in the same region as the Pipeline\n")
    resource: typing.Optional[models.AnyResource] = pydantic.Field(None, description='The optional resource that is backing this Action. This is used for automatically handling Actions backed by resources from a different account and/or region.\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='')
    run_order: typing.Union[int, float, None] = pydantic.Field(None, description='The order in which AWS CodePipeline runs this action. For more information, see the AWS CodePipeline User Guide. https://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html#action-requirements\n')
    variables_namespace: typing.Optional[str] = pydantic.Field(None, description='The name of the namespace to use for variables emitted by this action. Default: - a name will be generated, based on the stage and action names\n')
    version: typing.Optional[str] = pydantic.Field(None, description='')
    _init_params: typing.ClassVar[list[str]] = ['action_name', 'artifact_bounds', 'category', 'provider', 'account', 'inputs', 'outputs', 'owner', 'region', 'resource', 'role', 'run_order', 'variables_namespace', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.ActionProperties'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CfnCustomActionType.ArtifactDetailsProperty
class CfnCustomActionType_ArtifactDetailsPropertyDef(BaseStruct):
    maximum_count: typing.Union[int, float] = pydantic.Field(..., description='The maximum number of artifacts allowed for the action type.\n')
    minimum_count: typing.Union[int, float] = pydantic.Field(..., description='The minimum number of artifacts allowed for the action type.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codepipeline-customactiontype-artifactdetails.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n\n    artifact_details_property = codepipeline.CfnCustomActionType.ArtifactDetailsProperty(\n        maximum_count=123,\n        minimum_count=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['maximum_count', 'minimum_count']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CfnCustomActionType.ArtifactDetailsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CfnCustomActionType.ConfigurationPropertiesProperty
class CfnCustomActionType_ConfigurationPropertiesPropertyDef(BaseStruct):
    key: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='Whether the configuration property is a key.\n')
    name: str = pydantic.Field(..., description='The name of the action configuration property.\n')
    required: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='Whether the configuration property is a required value.\n')
    secret: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='Whether the configuration property is secret. Secrets are hidden from all calls except for ``GetJobDetails`` , ``GetThirdPartyJobDetails`` , ``PollForJobs`` , and ``PollForThirdPartyJobs`` . When updating a pipeline, passing * * * * * without changing any other values of the action preserves the previous value of the secret.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the action configuration property that is displayed to users.\n')
    queryable: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates that the property is used with ``PollForJobs`` . When creating a custom action, an action can have up to one queryable property. If it has one, that property must be both required and not secret. If you create a pipeline with a custom action type, and that custom action contains a queryable property, the value for that configuration property is subject to other restrictions. The value must be less than or equal to twenty (20) characters. The value can contain only alphanumeric characters, underscores, and hyphens.\n')
    type: typing.Optional[str] = pydantic.Field(None, description='The type of the configuration property.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codepipeline-customactiontype-configurationproperties.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n\n    configuration_properties_property = codepipeline.CfnCustomActionType.ConfigurationPropertiesProperty(\n        key=False,\n        name="name",\n        required=False,\n        secret=False,\n\n        # the properties below are optional\n        description="description",\n        queryable=False,\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'name', 'required', 'secret', 'description', 'queryable', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CfnCustomActionType.ConfigurationPropertiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CfnCustomActionType.SettingsProperty
class CfnCustomActionType_SettingsPropertyDef(BaseStruct):
    entity_url_template: typing.Optional[str] = pydantic.Field(None, description='The URL returned to the CodePipeline console that provides a deep link to the resources of the external system, such as the configuration page for a CodeDeploy deployment group. This link is provided as part of the action display in the pipeline.\n')
    execution_url_template: typing.Optional[str] = pydantic.Field(None, description='The URL returned to the CodePipeline console that contains a link to the top-level landing page for the external system, such as the console page for CodeDeploy. This link is shown on the pipeline view page in the CodePipeline console and provides a link to the execution entity of the external action.\n')
    revision_url_template: typing.Optional[str] = pydantic.Field(None, description='The URL returned to the CodePipeline console that contains a link to the page where customers can update or change the configuration of the external action.\n')
    third_party_configuration_url: typing.Optional[str] = pydantic.Field(None, description='The URL of a sign-up page where users can sign up for an external service and perform initial configuration of the action provided by that service.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codepipeline-customactiontype-settings.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n\n    settings_property = codepipeline.CfnCustomActionType.SettingsProperty(\n        entity_url_template="entityUrlTemplate",\n        execution_url_template="executionUrlTemplate",\n        revision_url_template="revisionUrlTemplate",\n        third_party_configuration_url="thirdPartyConfigurationUrl"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['entity_url_template', 'execution_url_template', 'revision_url_template', 'third_party_configuration_url']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CfnCustomActionType.SettingsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CfnPipeline.ActionDeclarationProperty
class CfnPipeline_ActionDeclarationPropertyDef(BaseStruct):
    action_type_id: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_ActionTypeIdPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Specifies the action type and the provider of the action.\n')
    name: str = pydantic.Field(..., description="The action declaration's name.\n")
    configuration: typing.Any = pydantic.Field(None, description='The action\'s configuration. These are key-value pairs that specify input values for an action. For more information, see `Action Structure Requirements in CodePipeline <https://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html#action-requirements>`_ . For the list of configuration properties for the AWS CloudFormation action type in CodePipeline, see `Configuration Properties Reference <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-action-reference.html>`_ in the *AWS CloudFormation User Guide* . For template snippets with examples, see `Using Parameter Override Functions with CodePipeline Pipelines <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-parameter-override-functions.html>`_ in the *AWS CloudFormation User Guide* . The values can be represented in either JSON or YAML format. For example, the JSON configuration item format is as follows: *JSON:* ``"Configuration" : { Key : Value },``\n')
    input_artifacts: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_InputArtifactPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The name or ID of the artifact consumed by the action, such as a test or build artifact. While the field is not a required parameter, most actions have an action configuration that requires a specified quantity of input artifacts. To refer to the action configuration specification by action provider, see the `Action structure reference <https://docs.aws.amazon.com/codepipeline/latest/userguide/action-reference.html>`_ in the *AWS CodePipeline User Guide* . .. epigraph:: For a CodeBuild action with multiple input artifacts, one of your input sources must be designated the PrimarySource. For more information, see the `CodeBuild action reference page <https://docs.aws.amazon.com/codepipeline/latest/userguide/action-reference-CodeBuild.html>`_ in the *AWS CodePipeline User Guide* .\n')
    namespace: typing.Optional[str] = pydantic.Field(None, description='The variable namespace associated with the action. All variables produced as output by this action fall under this namespace.\n')
    output_artifacts: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_OutputArtifactPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The name or ID of the result of the action declaration, such as a test or build artifact. While the field is not a required parameter, most actions have an action configuration that requires a specified quantity of output artifacts. To refer to the action configuration specification by action provider, see the `Action structure reference <https://docs.aws.amazon.com/codepipeline/latest/userguide/action-reference.html>`_ in the *AWS CodePipeline User Guide* .\n')
    region: typing.Optional[str] = pydantic.Field(None, description="The action declaration's AWS Region, such as us-east-1.\n")
    role_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the IAM service role that performs the declared action. This is assumed through the roleArn for the pipeline.\n')
    run_order: typing.Union[int, float, None] = pydantic.Field(None, description='The order in which actions are run.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codepipeline-pipeline-stages-actions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n\n    # configuration: Any\n\n    action_declaration_property = codepipeline.CfnPipeline.ActionDeclarationProperty(\n        action_type_id=codepipeline.CfnPipeline.ActionTypeIdProperty(\n            category="category",\n            owner="owner",\n            provider="provider",\n            version="version"\n        ),\n        name="name",\n\n        # the properties below are optional\n        configuration=configuration,\n        input_artifacts=[codepipeline.CfnPipeline.InputArtifactProperty(\n            name="name"\n        )],\n        namespace="namespace",\n        output_artifacts=[codepipeline.CfnPipeline.OutputArtifactProperty(\n            name="name"\n        )],\n        region="region",\n        role_arn="roleArn",\n        run_order=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action_type_id', 'name', 'configuration', 'input_artifacts', 'namespace', 'output_artifacts', 'region', 'role_arn', 'run_order']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CfnPipeline.ActionDeclarationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CfnPipeline.ActionTypeIdProperty
class CfnPipeline_ActionTypeIdPropertyDef(BaseStruct):
    category: str = pydantic.Field(..., description='A category defines what kind of action can be taken in the stage, and constrains the provider type for the action. Valid categories are limited to one of the values below. - ``Source`` - ``Build`` - ``Test`` - ``Deploy`` - ``Invoke`` - ``Approval``\n')
    owner: str = pydantic.Field(..., description='The creator of the action being called. There are three valid values for the ``Owner`` field in the action category section within your pipeline structure: ``AWS`` , ``ThirdParty`` , and ``Custom`` . For more information, see `Valid Action Types and Providers in CodePipeline <https://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html#actions-valid-providers>`_ .\n')
    provider: str = pydantic.Field(..., description='The provider of the service being called by the action. Valid providers are determined by the action category. For example, an action in the Deploy category type might have a provider of CodeDeploy, which would be specified as ``CodeDeploy`` . For more information, see `Valid Action Types and Providers in CodePipeline <https://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html#actions-valid-providers>`_ .\n')
    version: str = pydantic.Field(..., description='A string that describes the action version.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codepipeline-pipeline-stages-actions-actiontypeid.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n\n    action_type_id_property = codepipeline.CfnPipeline.ActionTypeIdProperty(\n        category="category",\n        owner="owner",\n        provider="provider",\n        version="version"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['category', 'owner', 'provider', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CfnPipeline.ActionTypeIdProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CfnPipeline.ArtifactStoreMapProperty
class CfnPipeline_ArtifactStoreMapPropertyDef(BaseStruct):
    artifact_store: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_ArtifactStorePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Represents information about the S3 bucket where artifacts are stored for the pipeline. .. epigraph:: You must include either ``artifactStore`` or ``artifactStores`` in your pipeline, but you cannot use both. If you create a cross-region action in your pipeline, you must use ``artifactStores`` .\n')
    region: str = pydantic.Field(..., description='The action declaration\'s AWS Region, such as us-east-1.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codepipeline-pipeline-artifactstoremap.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n\n    artifact_store_map_property = codepipeline.CfnPipeline.ArtifactStoreMapProperty(\n        artifact_store=codepipeline.CfnPipeline.ArtifactStoreProperty(\n            location="location",\n            type="type",\n\n            # the properties below are optional\n            encryption_key=codepipeline.CfnPipeline.EncryptionKeyProperty(\n                id="id",\n                type="type"\n            )\n        ),\n        region="region"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['artifact_store', 'region']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CfnPipeline.ArtifactStoreMapProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CfnPipeline.ArtifactStoreProperty
class CfnPipeline_ArtifactStorePropertyDef(BaseStruct):
    location: str = pydantic.Field(..., description='The S3 bucket used for storing the artifacts for a pipeline. You can specify the name of an S3 bucket but not a folder in the bucket. A folder to contain the pipeline artifacts is created for you based on the name of the pipeline. You can use any S3 bucket in the same AWS Region as the pipeline to store your pipeline artifacts.\n')
    type: str = pydantic.Field(..., description='The type of the artifact store, such as S3.\n')
    encryption_key: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_EncryptionKeyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The encryption key used to encrypt the data in the artifact store, such as an AWS Key Management Service ( AWS KMS) key. If this is undefined, the default key for Amazon S3 is used. To see an example artifact store encryption key field, see the example structure here: `AWS::CodePipeline::Pipeline <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codepipeline-pipeline.html>`_ .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codepipeline-pipeline-artifactstore.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n\n    artifact_store_property = codepipeline.CfnPipeline.ArtifactStoreProperty(\n        location="location",\n        type="type",\n\n        # the properties below are optional\n        encryption_key=codepipeline.CfnPipeline.EncryptionKeyProperty(\n            id="id",\n            type="type"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['location', 'type', 'encryption_key']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CfnPipeline.ArtifactStoreProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CfnPipeline.BlockerDeclarationProperty
class CfnPipeline_BlockerDeclarationPropertyDef(BaseStruct):
    name: str = pydantic.Field(..., description='Reserved for future use.\n')
    type: str = pydantic.Field(..., description='Reserved for future use.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codepipeline-pipeline-stages-blockers.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n\n    blocker_declaration_property = codepipeline.CfnPipeline.BlockerDeclarationProperty(\n        name="name",\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CfnPipeline.BlockerDeclarationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CfnPipeline.EncryptionKeyProperty
class CfnPipeline_EncryptionKeyPropertyDef(BaseStruct):
    type: str = pydantic.Field(..., description='The type of encryption key, such as an AWS KMS key. When creating or updating a pipeline, the value must be set to \'KMS\'.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codepipeline-pipeline-artifactstore-encryptionkey.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n\n    encryption_key_property = codepipeline.CfnPipeline.EncryptionKeyProperty(\n        id="id",\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CfnPipeline.EncryptionKeyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CfnPipeline.InputArtifactProperty
class CfnPipeline_InputArtifactPropertyDef(BaseStruct):
    name: str = pydantic.Field(..., description='The name of the artifact to be worked on (for example, "My App"). Artifacts are the files that are worked on by actions in the pipeline. See the action configuration for each action for details about artifact parameters. For example, the S3 source action input artifact is a file name (or file path), and the files are generally provided as a ZIP file. Example artifact name: SampleApp_Windows.zip The input artifact of an action must exactly match the output artifact declared in a preceding action, but the input artifact does not have to be the next action in strict sequence from the action that provided the output artifact. Actions in parallel can declare different output artifacts, which are in turn consumed by different following actions.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codepipeline-pipeline-stages-actions-inputartifacts.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n\n    input_artifact_property = codepipeline.CfnPipeline.InputArtifactProperty(\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CfnPipeline.InputArtifactProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CfnPipeline.OutputArtifactProperty
class CfnPipeline_OutputArtifactPropertyDef(BaseStruct):
    name: str = pydantic.Field(..., description='The name of the output of an artifact, such as "My App". The output artifact name must exactly match the input artifact declared for a downstream action. However, the downstream action\'s input artifact does not have to be the next action in strict sequence from the action that provided the output artifact. Actions in parallel can declare different output artifacts, which are in turn consumed by different following actions. Output artifact names must be unique within a pipeline.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codepipeline-pipeline-stages-actions-outputartifacts.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n\n    output_artifact_property = codepipeline.CfnPipeline.OutputArtifactProperty(\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CfnPipeline.OutputArtifactProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CfnPipeline.StageDeclarationProperty
class CfnPipeline_StageDeclarationPropertyDef(BaseStruct):
    actions: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_ActionDeclarationPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='The actions included in a stage.\n')
    name: str = pydantic.Field(..., description='The name of the stage.\n')
    blockers: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_BlockerDeclarationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Reserved for future use.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codepipeline-pipeline-stages.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n\n    # configuration: Any\n\n    stage_declaration_property = codepipeline.CfnPipeline.StageDeclarationProperty(\n        actions=[codepipeline.CfnPipeline.ActionDeclarationProperty(\n            action_type_id=codepipeline.CfnPipeline.ActionTypeIdProperty(\n                category="category",\n                owner="owner",\n                provider="provider",\n                version="version"\n            ),\n            name="name",\n\n            # the properties below are optional\n            configuration=configuration,\n            input_artifacts=[codepipeline.CfnPipeline.InputArtifactProperty(\n                name="name"\n            )],\n            namespace="namespace",\n            output_artifacts=[codepipeline.CfnPipeline.OutputArtifactProperty(\n                name="name"\n            )],\n            region="region",\n            role_arn="roleArn",\n            run_order=123\n        )],\n        name="name",\n\n        # the properties below are optional\n        blockers=[codepipeline.CfnPipeline.BlockerDeclarationProperty(\n            name="name",\n            type="type"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['actions', 'name', 'blockers']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CfnPipeline.StageDeclarationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CfnPipeline.StageTransitionProperty
class CfnPipeline_StageTransitionPropertyDef(BaseStruct):
    reason: str = pydantic.Field(..., description='The reason given to the user that a stage is disabled, such as waiting for manual approval or manual tests. This message is displayed in the pipeline console UI.\n')
    stage_name: str = pydantic.Field(..., description='The name of the stage where you want to disable the inbound or outbound transition of artifacts.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codepipeline-pipeline-disableinboundstagetransitions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n\n    stage_transition_property = codepipeline.CfnPipeline.StageTransitionProperty(\n        reason="reason",\n        stage_name="stageName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['reason', 'stage_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CfnPipeline.StageTransitionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CfnWebhook.WebhookAuthConfigurationProperty
class CfnWebhook_WebhookAuthConfigurationPropertyDef(BaseStruct):
    allowed_ip_range: typing.Optional[str] = pydantic.Field(None, description='The property used to configure acceptance of webhooks in an IP address range. For IP, only the ``AllowedIPRange`` property must be set. This property must be set to a valid CIDR range.\n')
    secret_token: typing.Optional[str] = pydantic.Field(None, description='The property used to configure GitHub authentication. For GITHUB_HMAC, only the ``SecretToken`` property must be set.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codepipeline-webhook-webhookauthconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n\n    webhook_auth_configuration_property = codepipeline.CfnWebhook.WebhookAuthConfigurationProperty(\n        allowed_ip_range="allowedIpRange",\n        secret_token="secretToken"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allowed_ip_range', 'secret_token']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CfnWebhook.WebhookAuthConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CfnWebhook.WebhookFilterRuleProperty
class CfnWebhook_WebhookFilterRulePropertyDef(BaseStruct):
    json_path: str = pydantic.Field(..., description='A JsonPath expression that is applied to the body/payload of the webhook. The value selected by the JsonPath expression must match the value specified in the ``MatchEquals`` field. Otherwise, the request is ignored. For more information, see `Java JsonPath implementation <https://docs.aws.amazon.com/https://github.com/json-path/JsonPath>`_ in GitHub.\n')
    match_equals: typing.Optional[str] = pydantic.Field(None, description='The value selected by the ``JsonPath`` expression must match what is supplied in the ``MatchEquals`` field. Otherwise, the request is ignored. Properties from the target action configuration can be included as placeholders in this value by surrounding the action configuration key with curly brackets. For example, if the value supplied here is "refs/heads/{Branch}" and the target action has an action configuration property called "Branch" with a value of "main", the ``MatchEquals`` value is evaluated as "refs/heads/main". For a list of action configuration properties for built-in action types, see `Pipeline Structure Reference Action Requirements <https://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html#action-requirements>`_ .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codepipeline-webhook-webhookfilterrule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n\n    webhook_filter_rule_property = codepipeline.CfnWebhook.WebhookFilterRuleProperty(\n        json_path="jsonPath",\n\n        # the properties below are optional\n        match_equals="matchEquals"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['json_path', 'match_equals']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CfnWebhook.WebhookFilterRuleProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CommonActionProps
class CommonActionPropsDef(BaseStruct):
    action_name: str = pydantic.Field(..., description='The physical, human-readable name of the Action. Note that Action names must be unique within a single Stage.\n')
    run_order: typing.Union[int, float, None] = pydantic.Field(None, description='The runOrder property for this Action. RunOrder determines the relative order in which multiple Actions in the same Stage execute. Default: 1\n')
    variables_namespace: typing.Optional[str] = pydantic.Field(None, description='The name of the namespace to use for variables emitted by this action. Default: - a name will be generated, based on the stage and action names, if any of the action\'s variables were referenced - otherwise, no namespace will be set\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n\n    common_action_props = codepipeline.CommonActionProps(\n        action_name="actionName",\n\n        # the properties below are optional\n        run_order=123,\n        variables_namespace="variablesNamespace"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action_name', 'run_order', 'variables_namespace']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CommonActionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CommonAwsActionProps
class CommonAwsActionPropsDef(BaseStruct):
    action_name: str = pydantic.Field(..., description='The physical, human-readable name of the Action. Note that Action names must be unique within a single Stage.\n')
    run_order: typing.Union[int, float, None] = pydantic.Field(None, description='The runOrder property for this Action. RunOrder determines the relative order in which multiple Actions in the same Stage execute. Default: 1\n')
    variables_namespace: typing.Optional[str] = pydantic.Field(None, description="The name of the namespace to use for variables emitted by this action. Default: - a name will be generated, based on the stage and action names, if any of the action's variables were referenced - otherwise, no namespace will be set\n")
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The Role in which context\'s this Action will be executing in. The Pipeline\'s Role will assume this Role (the required permissions for that will be granted automatically) right before executing this Action. This Action will be passed into your ``IAction.bind`` method in the ``ActionBindOptions.role`` property. Default: a new Role will be generated\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n    from aws_cdk import aws_iam as iam\n\n    # role: iam.Role\n\n    common_aws_action_props = codepipeline.CommonAwsActionProps(\n        action_name="actionName",\n\n        # the properties below are optional\n        role=role,\n        run_order=123,\n        variables_namespace="variablesNamespace"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action_name', 'run_order', 'variables_namespace', 'role']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CommonAwsActionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CrossRegionSupport
class CrossRegionSupportDef(BaseStruct):
    replication_bucket: typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef] = pydantic.Field(..., description='The replication Bucket used by CodePipeline to operate in this region. Belongs to ``stack``.\n')
    stack: models.StackDef = pydantic.Field(..., description='The Stack that has been created to house the replication Bucket required for this region.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_codepipeline as codepipeline\n    from aws_cdk import aws_s3 as s3\n\n    # bucket: s3.Bucket\n    # stack: cdk.Stack\n\n    cross_region_support = codepipeline.CrossRegionSupport(\n        replication_bucket=bucket,\n        stack=stack\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['replication_bucket', 'stack']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CrossRegionSupport'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CrossRegionSupportDefConfig] = pydantic.Field(None)


class CrossRegionSupportDefConfig(pydantic.BaseModel):
    replication_bucket_config: typing.Optional[models._interface_methods.AwsS3IBucketDefConfig] = pydantic.Field(None)
    stack_config: typing.Optional[models.core.StackDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_codepipeline.CustomActionProperty
class CustomActionPropertyDef(BaseStruct):
    name: str = pydantic.Field(..., description='The name of the property. You use this name in the ``configuration`` attribute when defining your custom Action class.\n')
    required: bool = pydantic.Field(..., description='Whether this property is required.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the property. Default: the description will be empty\n')
    key: typing.Optional[bool] = pydantic.Field(None, description='Whether this property is a key. Default: false\n')
    queryable: typing.Optional[bool] = pydantic.Field(None, description='Whether this property is queryable. Note that only a single property of a custom Action can be queryable. Default: false\n')
    secret: typing.Optional[bool] = pydantic.Field(None, description='Whether this property is secret, like a password, or access key. Default: false\n')
    type: typing.Optional[str] = pydantic.Field(None, description='The type of the property, like \'String\', \'Number\', or \'Boolean\'. Default: \'String\'\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n\n    custom_action_property = codepipeline.CustomActionProperty(\n        name="name",\n        required=False,\n\n        # the properties below are optional\n        description="description",\n        key=False,\n        queryable=False,\n        secret=False,\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'required', 'description', 'key', 'queryable', 'secret', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CustomActionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CustomActionRegistrationProps
class CustomActionRegistrationPropsDef(BaseStruct):
    artifact_bounds: typing.Union[models.aws_codepipeline.ActionArtifactBoundsDef, dict[str, typing.Any]] = pydantic.Field(..., description='The artifact bounds of the Action.\n')
    category: aws_cdk.aws_codepipeline.ActionCategory = pydantic.Field(..., description='The category of the Action.\n')
    provider: str = pydantic.Field(..., description="The provider of the Action. For example, ``'MyCustomActionProvider'``\n")
    action_properties: typing.Optional[typing.Sequence[typing.Union[models.aws_codepipeline.CustomActionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The properties used for customizing the instance of your Action. Default: []\n')
    entity_url: typing.Optional[str] = pydantic.Field(None, description='The URL shown for the entire Action in the Pipeline UI. Default: none\n')
    execution_url: typing.Optional[str] = pydantic.Field(None, description='The URL shown for a particular execution of an Action in the Pipeline UI. Default: none\n')
    version: typing.Optional[str] = pydantic.Field(None, description='The version of your Action. Default: \'1\'\n\n:exampleMetadata: infused\n\nExample::\n\n    # Make a custom CodePipeline Action\n    codepipeline.CustomActionRegistration(self, "GenericGitSourceProviderResource",\n        category=codepipeline.ActionCategory.SOURCE,\n        artifact_bounds=codepipeline.ActionArtifactBounds(min_inputs=0, max_inputs=0, min_outputs=1, max_outputs=1),\n        provider="GenericGitSource",\n        version="1",\n        entity_url="https://docs.aws.amazon.com/codepipeline/latest/userguide/actions-create-custom-action.html",\n        execution_url="https://docs.aws.amazon.com/codepipeline/latest/userguide/actions-create-custom-action.html",\n        action_properties=[codepipeline.CustomActionProperty(\n            name="Branch",\n            required=True,\n            key=False,\n            secret=False,\n            queryable=False,\n            description="Git branch to pull",\n            type="String"\n        ), codepipeline.CustomActionProperty(\n            name="GitUrl",\n            required=True,\n            key=False,\n            secret=False,\n            queryable=False,\n            description="SSH git clone URL",\n            type="String"\n        )\n        ]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['artifact_bounds', 'category', 'provider', 'action_properties', 'entity_url', 'execution_url', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CustomActionRegistrationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.PipelineNotifyOnOptions
class PipelineNotifyOnOptionsDef(BaseStruct):
    detail_type: typing.Optional[aws_cdk.aws_codestarnotifications.DetailType] = pydantic.Field(None, description='The level of detail to include in the notifications for this resource. BASIC will include only the contents of the event as it would appear in AWS CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created. Default: DetailType.FULL\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description="The status of the notification rule. If the enabled is set to DISABLED, notifications aren't sent for the notification rule. Default: true\n")
    notification_rule_name: typing.Optional[str] = pydantic.Field(None, description='The name for the notification rule. Notification rule names must be unique in your AWS account. Default: - generated from the ``id``\n')
    events: typing.Sequence[aws_cdk.aws_codepipeline.PipelineNotificationEvents] = pydantic.Field(..., description='A list of event types associated with this notification rule for CodePipeline Pipeline. For a complete list of event types and IDs, see Notification concepts in the Developer Tools Console User Guide.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n    from aws_cdk import aws_codestarnotifications as codestarnotifications\n\n    pipeline_notify_on_options = codepipeline.PipelineNotifyOnOptions(\n        events=[codepipeline.PipelineNotificationEvents.PIPELINE_EXECUTION_FAILED],\n\n        # the properties below are optional\n        detail_type=codestarnotifications.DetailType.BASIC,\n        enabled=False,\n        notification_rule_name="notificationRuleName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['detail_type', 'enabled', 'notification_rule_name', 'events']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.PipelineNotifyOnOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.PipelineProps
class PipelinePropsDef(BaseStruct):
    artifact_bucket: typing.Optional[typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef]] = pydantic.Field(None, description='The S3 bucket used by this Pipeline to store artifacts. Default: - A new S3 bucket will be created.')
    cross_account_keys: typing.Optional[bool] = pydantic.Field(None, description='Create KMS keys for cross-account deployments. This controls whether the pipeline is enabled for cross-account deployments. By default cross-account deployments are enabled, but this feature requires that KMS Customer Master Keys are created which have a cost of $1/month. If you do not need cross-account deployments, you can set this to ``false`` to not create those keys and save on that cost (the artifact bucket will be encrypted with an AWS-managed key). However, cross-account deployments will no longer be possible. Default: true\n')
    cross_region_replication_buckets: typing.Optional[typing.Mapping[str, typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef]]] = pydantic.Field(None, description="A map of region to S3 bucket name used for cross-region CodePipeline. For every Action that you specify targeting a different region than the Pipeline itself, if you don't provide an explicit Bucket for that region using this property, the construct will automatically create a Stack containing an S3 Bucket in that region. Default: - None.\n")
    enable_key_rotation: typing.Optional[bool] = pydantic.Field(None, description='Enable KMS key rotation for the generated KMS keys. By default KMS key rotation is disabled, but will add an additional $1/month for each year the key exists when enabled. Default: - false (key rotation is disabled)\n')
    pipeline_name: typing.Optional[str] = pydantic.Field(None, description='Name of the pipeline. Default: - AWS CloudFormation generates an ID and uses that for the pipeline name.\n')
    restart_execution_on_update: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to rerun the AWS CodePipeline pipeline after you update it. Default: false\n')
    reuse_cross_region_support_stacks: typing.Optional[bool] = pydantic.Field(None, description='Reuse the same cross region support stack for all pipelines in the App. Default: - true (Use the same support stack for all pipelines in App)\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The IAM role to be assumed by this Pipeline. Default: a new IAM role will be created.\n')
    stages: typing.Optional[typing.Sequence[typing.Union[models.aws_codepipeline.StagePropsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The list of Stages, in order, to create this Pipeline with. You can always add more Stages later by calling ``Pipeline#addStage``. Default: - None.\n\n:exampleMetadata: infused\n\nExample::\n\n    # project: codebuild.PipelineProject\n\n    repository = codecommit.Repository(self, "MyRepository",\n        repository_name="MyRepository"\n    )\n    project = codebuild.PipelineProject(self, "MyProject")\n\n    source_output = codepipeline.Artifact()\n    source_action = codepipeline_actions.CodeCommitSourceAction(\n        action_name="CodeCommit",\n        repository=repository,\n        output=source_output\n    )\n    build_action = codepipeline_actions.CodeBuildAction(\n        action_name="CodeBuild",\n        project=project,\n        input=source_output,\n        outputs=[codepipeline.Artifact()],  # optional\n        execute_batch_build=True,  # optional, defaults to false\n        combine_batch_build_artifacts=True\n    )\n\n    codepipeline.Pipeline(self, "MyPipeline",\n        stages=[codepipeline.StageProps(\n            stage_name="Source",\n            actions=[source_action]\n        ), codepipeline.StageProps(\n            stage_name="Build",\n            actions=[build_action]\n        )\n        ]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['artifact_bucket', 'cross_account_keys', 'cross_region_replication_buckets', 'enable_key_rotation', 'pipeline_name', 'restart_execution_on_update', 'reuse_cross_region_support_stacks', 'role', 'stages']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.PipelineProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.StageOptions
class StageOptionsDef(BaseStruct):
    stage_name: str = pydantic.Field(..., description='The physical, human-readable name to assign to this Pipeline Stage.')
    actions: typing.Optional[typing.Sequence[typing.Union[models.aws_codepipeline.ActionDef, models.aws_codepipeline_actions.ActionDef, models.aws_codepipeline_actions.AlexaSkillDeployActionDef, models.aws_codepipeline_actions.CloudFormationCreateReplaceChangeSetActionDef, models.aws_codepipeline_actions.CloudFormationCreateUpdateStackActionDef, models.aws_codepipeline_actions.CloudFormationDeleteStackActionDef, models.aws_codepipeline_actions.CloudFormationDeployStackInstancesActionDef, models.aws_codepipeline_actions.CloudFormationDeployStackSetActionDef, models.aws_codepipeline_actions.CloudFormationExecuteChangeSetActionDef, models.aws_codepipeline_actions.CodeBuildActionDef, models.aws_codepipeline_actions.CodeCommitSourceActionDef, models.aws_codepipeline_actions.CodeDeployEcsDeployActionDef, models.aws_codepipeline_actions.CodeDeployServerDeployActionDef, models.aws_codepipeline_actions.CodeStarConnectionsSourceActionDef, models.aws_codepipeline_actions.EcrSourceActionDef, models.aws_codepipeline_actions.EcsDeployActionDef, models.aws_codepipeline_actions.ElasticBeanstalkDeployActionDef, models.aws_codepipeline_actions.GitHubSourceActionDef, models.aws_codepipeline_actions.JenkinsActionDef, models.aws_codepipeline_actions.LambdaInvokeActionDef, models.aws_codepipeline_actions.ManualApprovalActionDef, models.aws_codepipeline_actions.S3DeployActionDef, models.aws_codepipeline_actions.S3SourceActionDef, models.aws_codepipeline_actions.ServiceCatalogDeployActionBeta1Def, models.aws_codepipeline_actions.StepFunctionInvokeActionDef]]] = pydantic.Field(None, description='The list of Actions to create this Stage with. You can always add more Actions later by calling ``IStage#addAction``.\n')
    transition_disabled_reason: typing.Optional[str] = pydantic.Field(None, description="The reason for disabling transition to this stage. Only applicable if ``transitionToEnabled`` is set to ``false``. Default: 'Transition disabled'\n")
    transition_to_enabled: typing.Optional[bool] = pydantic.Field(None, description='Whether to enable transition to this stage. Default: true\n')
    placement: typing.Union[models.aws_codepipeline.StagePlacementDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    _init_params: typing.ClassVar[list[str]] = ['stage_name', 'actions', 'transition_disabled_reason', 'transition_to_enabled', 'placement']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.StageOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.StagePlacement
class StagePlacementDef(BaseStruct):
    just_after: typing.Optional[models.UnsupportedResource] = pydantic.Field(None, description='Inserts the new Stage as a child of the given Stage (changing its current child Stage, if it had one).\n')
    right_before: typing.Optional[models.UnsupportedResource] = pydantic.Field(None, description='Inserts the new Stage as a parent of the given Stage (changing its current parent Stage, if it had one).\n\n:see: #justAfter\n:exampleMetadata: infused\n\nExample::\n\n    # Insert a new Stage at an arbitrary point\n    # pipeline: codepipeline.Pipeline\n    # another_stage: codepipeline.IStage\n    # yet_another_stage: codepipeline.IStage\n\n\n    some_stage = pipeline.add_stage(\n        stage_name="SomeStage",\n        placement=codepipeline.StagePlacement(\n            # note: you can only specify one of the below properties\n            right_before=another_stage,\n            just_after=yet_another_stage\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['just_after', 'right_before']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.StagePlacement'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.StageProps
class StagePropsDef(BaseStruct):
    stage_name: str = pydantic.Field(..., description='The physical, human-readable name to assign to this Pipeline Stage.\n')
    actions: typing.Optional[typing.Sequence[typing.Union[models.aws_codepipeline.ActionDef, models.aws_codepipeline_actions.ActionDef, models.aws_codepipeline_actions.AlexaSkillDeployActionDef, models.aws_codepipeline_actions.CloudFormationCreateReplaceChangeSetActionDef, models.aws_codepipeline_actions.CloudFormationCreateUpdateStackActionDef, models.aws_codepipeline_actions.CloudFormationDeleteStackActionDef, models.aws_codepipeline_actions.CloudFormationDeployStackInstancesActionDef, models.aws_codepipeline_actions.CloudFormationDeployStackSetActionDef, models.aws_codepipeline_actions.CloudFormationExecuteChangeSetActionDef, models.aws_codepipeline_actions.CodeBuildActionDef, models.aws_codepipeline_actions.CodeCommitSourceActionDef, models.aws_codepipeline_actions.CodeDeployEcsDeployActionDef, models.aws_codepipeline_actions.CodeDeployServerDeployActionDef, models.aws_codepipeline_actions.CodeStarConnectionsSourceActionDef, models.aws_codepipeline_actions.EcrSourceActionDef, models.aws_codepipeline_actions.EcsDeployActionDef, models.aws_codepipeline_actions.ElasticBeanstalkDeployActionDef, models.aws_codepipeline_actions.GitHubSourceActionDef, models.aws_codepipeline_actions.JenkinsActionDef, models.aws_codepipeline_actions.LambdaInvokeActionDef, models.aws_codepipeline_actions.ManualApprovalActionDef, models.aws_codepipeline_actions.S3DeployActionDef, models.aws_codepipeline_actions.S3SourceActionDef, models.aws_codepipeline_actions.ServiceCatalogDeployActionBeta1Def, models.aws_codepipeline_actions.StepFunctionInvokeActionDef]]] = pydantic.Field(None, description='The list of Actions to create this Stage with. You can always add more Actions later by calling ``IStage#addAction``.\n')
    transition_disabled_reason: typing.Optional[str] = pydantic.Field(None, description="The reason for disabling transition to this stage. Only applicable if ``transitionToEnabled`` is set to ``false``. Default: 'Transition disabled'\n")
    transition_to_enabled: typing.Optional[bool] = pydantic.Field(None, description='Whether to enable transition to this stage. Default: true\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n\n    # action: codepipeline.Action\n\n    stage_props = codepipeline.StageProps(\n        stage_name="stageName",\n\n        # the properties below are optional\n        actions=[action],\n        transition_disabled_reason="transitionDisabledReason",\n        transition_to_enabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['stage_name', 'actions', 'transition_disabled_reason', 'transition_to_enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.StageProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.ActionCategory
# skipping emum

#  autogenerated from aws_cdk.aws_codepipeline.PipelineNotificationEvents
# skipping emum

#  autogenerated from aws_cdk.aws_codepipeline.IAction
#  skipping Interface

#  autogenerated from aws_cdk.aws_codepipeline.IPipeline
#  skipping Interface

#  autogenerated from aws_cdk.aws_codepipeline.IStage
#  skipping Interface

#  autogenerated from aws_cdk.aws_codepipeline.CfnCustomActionType
class CfnCustomActionTypeDef(BaseCfnResource):
    category: str = pydantic.Field(..., description='The category of the custom action, such as a build action or a test action.\n')
    input_artifact_details: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnCustomActionType_ArtifactDetailsPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The details of the input artifact for the action, such as its commit ID.\n')
    output_artifact_details: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnCustomActionType_ArtifactDetailsPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The details of the output artifact of the action, such as its commit ID.\n')
    provider: str = pydantic.Field(..., description='The provider of the service used in the custom action, such as CodeDeploy.\n')
    version: str = pydantic.Field(..., description='The version identifier of the custom action.\n')
    configuration_properties: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnCustomActionType_ConfigurationPropertiesPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The configuration properties for the custom action. .. epigraph:: You can refer to a name in the configuration properties of the custom action within the URL templates by following the format of {Config:name}, as long as the configuration property is both required and not secret. For more information, see `Create a Custom Action for a Pipeline <https://docs.aws.amazon.com/codepipeline/latest/userguide/how-to-create-custom-action.html>`_ .\n')
    settings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnCustomActionType_SettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='URLs that provide users information about this custom action.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the custom action.')
    _init_params: typing.ClassVar[list[str]] = ['category', 'input_artifact_details', 'output_artifact_details', 'provider', 'version', 'configuration_properties', 'settings', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['ArtifactDetailsProperty', 'ConfigurationPropertiesProperty', 'SettingsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CfnCustomActionType'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnCustomActionTypeDefConfig] = pydantic.Field(None)


class CfnCustomActionTypeDefConfig(pydantic.BaseModel):
    ArtifactDetailsProperty: typing.Optional[list[CfnCustomActionTypeDefArtifactdetailspropertyParams]] = pydantic.Field(None, description='')
    ConfigurationPropertiesProperty: typing.Optional[list[CfnCustomActionTypeDefConfigurationpropertiespropertyParams]] = pydantic.Field(None, description='')
    SettingsProperty: typing.Optional[list[CfnCustomActionTypeDefSettingspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnCustomActionTypeDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnCustomActionTypeDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnCustomActionTypeDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnCustomActionTypeDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnCustomActionTypeDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnCustomActionTypeDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnCustomActionTypeDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnCustomActionTypeDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnCustomActionTypeDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnCustomActionTypeDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnCustomActionTypeDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnCustomActionTypeDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnCustomActionTypeDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnCustomActionTypeDefArtifactdetailspropertyParams(pydantic.BaseModel):
    maximum_count: typing.Union[int, float] = pydantic.Field(..., description='')
    minimum_count: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnCustomActionTypeDefConfigurationpropertiespropertyParams(pydantic.BaseModel):
    key: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='')
    name: str = pydantic.Field(..., description='')
    required: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='')
    secret: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    queryable: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnCustomActionTypeDefSettingspropertyParams(pydantic.BaseModel):
    entity_url_template: typing.Optional[str] = pydantic.Field(None, description='')
    execution_url_template: typing.Optional[str] = pydantic.Field(None, description='')
    revision_url_template: typing.Optional[str] = pydantic.Field(None, description='')
    third_party_configuration_url: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnCustomActionTypeDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnCustomActionTypeDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCustomActionTypeDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnCustomActionTypeDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCustomActionTypeDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnCustomActionTypeDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnCustomActionTypeDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnCustomActionTypeDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnCustomActionTypeDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnCustomActionTypeDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCustomActionTypeDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnCustomActionTypeDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnCustomActionTypeDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCustomActionTypeDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_codepipeline.CfnPipeline
class CfnPipelineDef(BaseCfnResource):
    role_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) for CodePipeline to use to either perform actions with no ``actionRoleArn`` , or to use to assume roles for actions with an ``actionRoleArn`` .\n')
    stages: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_StageDeclarationPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='Represents information about a stage and its definition.\n')
    artifact_store: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_ArtifactStorePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The S3 bucket where artifacts for the pipeline are stored. .. epigraph:: You must include either ``artifactStore`` or ``artifactStores`` in your pipeline, but you cannot use both. If you create a cross-region action in your pipeline, you must use ``artifactStores`` .\n')
    artifact_stores: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_ArtifactStoreMapPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A mapping of ``artifactStore`` objects and their corresponding AWS Regions. There must be an artifact store for the pipeline Region and for each cross-region action in the pipeline. .. epigraph:: You must include either ``artifactStore`` or ``artifactStores`` in your pipeline, but you cannot use both. If you create a cross-region action in your pipeline, you must use ``artifactStores`` .\n')
    disable_inbound_stage_transitions: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_StageTransitionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Represents the input of a ``DisableStageTransition`` action.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the pipeline.\n')
    restart_execution_on_update: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to rerun the CodePipeline pipeline after you update it.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Specifies the tags applied to the pipeline.')
    _init_params: typing.ClassVar[list[str]] = ['role_arn', 'stages', 'artifact_store', 'artifact_stores', 'disable_inbound_stage_transitions', 'name', 'restart_execution_on_update', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['ActionDeclarationProperty', 'ActionTypeIdProperty', 'ArtifactStoreMapProperty', 'ArtifactStoreProperty', 'BlockerDeclarationProperty', 'EncryptionKeyProperty', 'InputArtifactProperty', 'OutputArtifactProperty', 'StageDeclarationProperty', 'StageTransitionProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CfnPipeline'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnPipelineDefConfig] = pydantic.Field(None)


class CfnPipelineDefConfig(pydantic.BaseModel):
    ActionDeclarationProperty: typing.Optional[list[CfnPipelineDefActiondeclarationpropertyParams]] = pydantic.Field(None, description='')
    ActionTypeIdProperty: typing.Optional[list[CfnPipelineDefActiontypeidpropertyParams]] = pydantic.Field(None, description='')
    ArtifactStoreMapProperty: typing.Optional[list[CfnPipelineDefArtifactstoremappropertyParams]] = pydantic.Field(None, description='')
    ArtifactStoreProperty: typing.Optional[list[CfnPipelineDefArtifactstorepropertyParams]] = pydantic.Field(None, description='')
    BlockerDeclarationProperty: typing.Optional[list[CfnPipelineDefBlockerdeclarationpropertyParams]] = pydantic.Field(None, description='')
    EncryptionKeyProperty: typing.Optional[list[CfnPipelineDefEncryptionkeypropertyParams]] = pydantic.Field(None, description='')
    InputArtifactProperty: typing.Optional[list[CfnPipelineDefInputartifactpropertyParams]] = pydantic.Field(None, description='')
    OutputArtifactProperty: typing.Optional[list[CfnPipelineDefOutputartifactpropertyParams]] = pydantic.Field(None, description='')
    StageDeclarationProperty: typing.Optional[list[CfnPipelineDefStagedeclarationpropertyParams]] = pydantic.Field(None, description='')
    StageTransitionProperty: typing.Optional[list[CfnPipelineDefStagetransitionpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnPipelineDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnPipelineDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnPipelineDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnPipelineDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnPipelineDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnPipelineDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnPipelineDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnPipelineDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnPipelineDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnPipelineDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnPipelineDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnPipelineDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnPipelineDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnPipelineDefActiondeclarationpropertyParams(pydantic.BaseModel):
    action_type_id: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_ActionTypeIdPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    name: str = pydantic.Field(..., description='')
    configuration: typing.Any = pydantic.Field(None, description='')
    input_artifacts: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_InputArtifactPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    namespace: typing.Optional[str] = pydantic.Field(None, description='')
    output_artifacts: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_OutputArtifactPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    region: typing.Optional[str] = pydantic.Field(None, description='')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='')
    run_order: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnPipelineDefActiontypeidpropertyParams(pydantic.BaseModel):
    category: str = pydantic.Field(..., description='')
    owner: str = pydantic.Field(..., description='')
    provider: str = pydantic.Field(..., description='')
    version: str = pydantic.Field(..., description='')
    ...

class CfnPipelineDefArtifactstoremappropertyParams(pydantic.BaseModel):
    artifact_store: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_ArtifactStorePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    region: str = pydantic.Field(..., description='')
    ...

class CfnPipelineDefArtifactstorepropertyParams(pydantic.BaseModel):
    location: str = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    encryption_key: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_EncryptionKeyPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnPipelineDefBlockerdeclarationpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    ...

class CfnPipelineDefEncryptionkeypropertyParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    ...

class CfnPipelineDefInputartifactpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    ...

class CfnPipelineDefOutputartifactpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    ...

class CfnPipelineDefStagedeclarationpropertyParams(pydantic.BaseModel):
    actions: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_ActionDeclarationPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    name: str = pydantic.Field(..., description='')
    blockers: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_BlockerDeclarationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnPipelineDefStagetransitionpropertyParams(pydantic.BaseModel):
    reason: str = pydantic.Field(..., description='')
    stage_name: str = pydantic.Field(..., description='')
    ...

class CfnPipelineDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPipelineDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPipelineDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPipelineDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPipelineDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPipelineDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPipelineDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPipelineDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPipelineDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPipelineDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPipelineDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnPipelineDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPipelineDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPipelineDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_codepipeline.CfnWebhook
class CfnWebhookDef(BaseCfnResource):
    authentication: str = pydantic.Field(..., description='Supported options are GITHUB_HMAC, IP, and UNAUTHENTICATED. - For information about the authentication scheme implemented by GITHUB_HMAC, see `Securing your webhooks <https://docs.aws.amazon.com/https://developer.github.com/webhooks/securing/>`_ on the GitHub Developer website. - IP rejects webhooks trigger requests unless they originate from an IP address in the IP range whitelisted in the authentication configuration. - UNAUTHENTICATED accepts all webhook trigger requests regardless of origin.\n')
    authentication_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnWebhook_WebhookAuthConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Properties that configure the authentication applied to incoming webhook trigger requests. The required properties depend on the authentication type. For GITHUB_HMAC, only the ``SecretToken`` property must be set. For IP, only the ``AllowedIPRange`` property must be set to a valid CIDR range. For UNAUTHENTICATED, no properties can be set.\n')
    filters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnWebhook_WebhookFilterRulePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='A list of rules applied to the body/payload sent in the POST request to a webhook URL. All defined rules must pass for the request to be accepted and the pipeline started.\n')
    target_action: str = pydantic.Field(..., description='The name of the action in a pipeline you want to connect to the webhook. The action must be from the source (first) stage of the pipeline.\n')
    target_pipeline: str = pydantic.Field(..., description='The name of the pipeline you want to connect to the webhook.\n')
    target_pipeline_version: typing.Union[int, float] = pydantic.Field(..., description='The version number of the pipeline to be connected to the trigger request. Required: Yes Type: Integer Update requires: `No interruption <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-no-interrupt>`_\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the webhook.\n')
    register_with_third_party: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Configures a connection between the webhook that was created and the external tool with events to be detected.')
    _init_params: typing.ClassVar[list[str]] = ['authentication', 'authentication_configuration', 'filters', 'target_action', 'target_pipeline', 'target_pipeline_version', 'name', 'register_with_third_party']
    _method_names: typing.ClassVar[list[str]] = ['WebhookAuthConfigurationProperty', 'WebhookFilterRuleProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CfnWebhook'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnWebhookDefConfig] = pydantic.Field(None)


class CfnWebhookDefConfig(pydantic.BaseModel):
    WebhookAuthConfigurationProperty: typing.Optional[list[CfnWebhookDefWebhookauthconfigurationpropertyParams]] = pydantic.Field(None, description='')
    WebhookFilterRuleProperty: typing.Optional[list[CfnWebhookDefWebhookfilterrulepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnWebhookDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnWebhookDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnWebhookDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnWebhookDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnWebhookDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnWebhookDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnWebhookDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnWebhookDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnWebhookDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnWebhookDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnWebhookDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnWebhookDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnWebhookDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnWebhookDefWebhookauthconfigurationpropertyParams(pydantic.BaseModel):
    allowed_ip_range: typing.Optional[str] = pydantic.Field(None, description='')
    secret_token: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnWebhookDefWebhookfilterrulepropertyParams(pydantic.BaseModel):
    json_path: str = pydantic.Field(..., description='')
    match_equals: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnWebhookDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnWebhookDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnWebhookDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnWebhookDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnWebhookDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnWebhookDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnWebhookDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnWebhookDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnWebhookDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnWebhookDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnWebhookDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnWebhookDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnWebhookDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnWebhookDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_codepipeline.CfnCustomActionTypeProps
class CfnCustomActionTypePropsDef(BaseCfnProperty):
    category: str = pydantic.Field(..., description='The category of the custom action, such as a build action or a test action.\n')
    input_artifact_details: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnCustomActionType_ArtifactDetailsPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The details of the input artifact for the action, such as its commit ID.\n')
    output_artifact_details: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnCustomActionType_ArtifactDetailsPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The details of the output artifact of the action, such as its commit ID.\n')
    provider: str = pydantic.Field(..., description='The provider of the service used in the custom action, such as CodeDeploy.\n')
    version: str = pydantic.Field(..., description='The version identifier of the custom action.\n')
    configuration_properties: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnCustomActionType_ConfigurationPropertiesPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The configuration properties for the custom action. .. epigraph:: You can refer to a name in the configuration properties of the custom action within the URL templates by following the format of {Config:name}, as long as the configuration property is both required and not secret. For more information, see `Create a Custom Action for a Pipeline <https://docs.aws.amazon.com/codepipeline/latest/userguide/how-to-create-custom-action.html>`_ .\n')
    settings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnCustomActionType_SettingsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='URLs that provide users information about this custom action.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the custom action.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codepipeline-customactiontype.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n\n    cfn_custom_action_type_props = codepipeline.CfnCustomActionTypeProps(\n        category="category",\n        input_artifact_details=codepipeline.CfnCustomActionType.ArtifactDetailsProperty(\n            maximum_count=123,\n            minimum_count=123\n        ),\n        output_artifact_details=codepipeline.CfnCustomActionType.ArtifactDetailsProperty(\n            maximum_count=123,\n            minimum_count=123\n        ),\n        provider="provider",\n        version="version",\n\n        # the properties below are optional\n        configuration_properties=[codepipeline.CfnCustomActionType.ConfigurationPropertiesProperty(\n            key=False,\n            name="name",\n            required=False,\n            secret=False,\n\n            # the properties below are optional\n            description="description",\n            queryable=False,\n            type="type"\n        )],\n        settings=codepipeline.CfnCustomActionType.SettingsProperty(\n            entity_url_template="entityUrlTemplate",\n            execution_url_template="executionUrlTemplate",\n            revision_url_template="revisionUrlTemplate",\n            third_party_configuration_url="thirdPartyConfigurationUrl"\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['category', 'input_artifact_details', 'output_artifact_details', 'provider', 'version', 'configuration_properties', 'settings', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CfnCustomActionTypeProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CfnPipelineProps
class CfnPipelinePropsDef(BaseCfnProperty):
    role_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) for CodePipeline to use to either perform actions with no ``actionRoleArn`` , or to use to assume roles for actions with an ``actionRoleArn`` .\n')
    stages: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_StageDeclarationPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='Represents information about a stage and its definition.\n')
    artifact_store: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_ArtifactStorePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The S3 bucket where artifacts for the pipeline are stored. .. epigraph:: You must include either ``artifactStore`` or ``artifactStores`` in your pipeline, but you cannot use both. If you create a cross-region action in your pipeline, you must use ``artifactStores`` .\n')
    artifact_stores: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_ArtifactStoreMapPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A mapping of ``artifactStore`` objects and their corresponding AWS Regions. There must be an artifact store for the pipeline Region and for each cross-region action in the pipeline. .. epigraph:: You must include either ``artifactStore`` or ``artifactStores`` in your pipeline, but you cannot use both. If you create a cross-region action in your pipeline, you must use ``artifactStores`` .\n')
    disable_inbound_stage_transitions: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnPipeline_StageTransitionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Represents the input of a ``DisableStageTransition`` action.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the pipeline.\n')
    restart_execution_on_update: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to rerun the CodePipeline pipeline after you update it.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Specifies the tags applied to the pipeline.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codepipeline-pipeline.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n\n    # configuration: Any\n\n    cfn_pipeline_props = codepipeline.CfnPipelineProps(\n        role_arn="roleArn",\n        stages=[codepipeline.CfnPipeline.StageDeclarationProperty(\n            actions=[codepipeline.CfnPipeline.ActionDeclarationProperty(\n                action_type_id=codepipeline.CfnPipeline.ActionTypeIdProperty(\n                    category="category",\n                    owner="owner",\n                    provider="provider",\n                    version="version"\n                ),\n                name="name",\n\n                # the properties below are optional\n                configuration=configuration,\n                input_artifacts=[codepipeline.CfnPipeline.InputArtifactProperty(\n                    name="name"\n                )],\n                namespace="namespace",\n                output_artifacts=[codepipeline.CfnPipeline.OutputArtifactProperty(\n                    name="name"\n                )],\n                region="region",\n                role_arn="roleArn",\n                run_order=123\n            )],\n            name="name",\n\n            # the properties below are optional\n            blockers=[codepipeline.CfnPipeline.BlockerDeclarationProperty(\n                name="name",\n                type="type"\n            )]\n        )],\n\n        # the properties below are optional\n        artifact_store=codepipeline.CfnPipeline.ArtifactStoreProperty(\n            location="location",\n            type="type",\n\n            # the properties below are optional\n            encryption_key=codepipeline.CfnPipeline.EncryptionKeyProperty(\n                id="id",\n                type="type"\n            )\n        ),\n        artifact_stores=[codepipeline.CfnPipeline.ArtifactStoreMapProperty(\n            artifact_store=codepipeline.CfnPipeline.ArtifactStoreProperty(\n                location="location",\n                type="type",\n\n                # the properties below are optional\n                encryption_key=codepipeline.CfnPipeline.EncryptionKeyProperty(\n                    id="id",\n                    type="type"\n                )\n            ),\n            region="region"\n        )],\n        disable_inbound_stage_transitions=[codepipeline.CfnPipeline.StageTransitionProperty(\n            reason="reason",\n            stage_name="stageName"\n        )],\n        name="name",\n        restart_execution_on_update=False,\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['role_arn', 'stages', 'artifact_store', 'artifact_stores', 'disable_inbound_stage_transitions', 'name', 'restart_execution_on_update', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CfnPipelineProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_codepipeline.CfnWebhookProps
class CfnWebhookPropsDef(BaseCfnProperty):
    authentication: str = pydantic.Field(..., description='Supported options are GITHUB_HMAC, IP, and UNAUTHENTICATED. - For information about the authentication scheme implemented by GITHUB_HMAC, see `Securing your webhooks <https://docs.aws.amazon.com/https://developer.github.com/webhooks/securing/>`_ on the GitHub Developer website. - IP rejects webhooks trigger requests unless they originate from an IP address in the IP range whitelisted in the authentication configuration. - UNAUTHENTICATED accepts all webhook trigger requests regardless of origin.\n')
    authentication_configuration: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnWebhook_WebhookAuthConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Properties that configure the authentication applied to incoming webhook trigger requests. The required properties depend on the authentication type. For GITHUB_HMAC, only the ``SecretToken`` property must be set. For IP, only the ``AllowedIPRange`` property must be set to a valid CIDR range. For UNAUTHENTICATED, no properties can be set.\n')
    filters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_codepipeline.CfnWebhook_WebhookFilterRulePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='A list of rules applied to the body/payload sent in the POST request to a webhook URL. All defined rules must pass for the request to be accepted and the pipeline started.\n')
    target_action: str = pydantic.Field(..., description='The name of the action in a pipeline you want to connect to the webhook. The action must be from the source (first) stage of the pipeline.\n')
    target_pipeline: str = pydantic.Field(..., description='The name of the pipeline you want to connect to the webhook.\n')
    target_pipeline_version: typing.Union[int, float] = pydantic.Field(..., description='The version number of the pipeline to be connected to the trigger request. Required: Yes Type: Integer Update requires: `No interruption <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-no-interrupt>`_\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the webhook.\n')
    register_with_third_party: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Configures a connection between the webhook that was created and the external tool with events to be detected.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codepipeline-webhook.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_codepipeline as codepipeline\n\n    cfn_webhook_props = codepipeline.CfnWebhookProps(\n        authentication="authentication",\n        authentication_configuration=codepipeline.CfnWebhook.WebhookAuthConfigurationProperty(\n            allowed_ip_range="allowedIpRange",\n            secret_token="secretToken"\n        ),\n        filters=[codepipeline.CfnWebhook.WebhookFilterRuleProperty(\n            json_path="jsonPath",\n\n            # the properties below are optional\n            match_equals="matchEquals"\n        )],\n        target_action="targetAction",\n        target_pipeline="targetPipeline",\n        target_pipeline_version=123,\n\n        # the properties below are optional\n        name="name",\n        register_with_third_party=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['authentication', 'authentication_configuration', 'filters', 'target_action', 'target_pipeline', 'target_pipeline_version', 'name', 'register_with_third_party']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_codepipeline.CfnWebhookProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    Action: typing.Optional[dict[str, ActionDef]] = pydantic.Field(None)
    Artifact: typing.Optional[dict[str, ArtifactDef]] = pydantic.Field(None)
    ArtifactPath: typing.Optional[dict[str, ArtifactPathDef]] = pydantic.Field(None)
    GlobalVariables: typing.Optional[dict[str, GlobalVariablesDef]] = pydantic.Field(None)
    CustomActionRegistration: typing.Optional[dict[str, CustomActionRegistrationDef]] = pydantic.Field(None)
    Pipeline: typing.Optional[dict[str, PipelineDef]] = pydantic.Field(None)
    ActionArtifactBounds: typing.Optional[dict[str, ActionArtifactBoundsDef]] = pydantic.Field(None)
    ActionBindOptions: typing.Optional[dict[str, ActionBindOptionsDef]] = pydantic.Field(None)
    ActionConfig: typing.Optional[dict[str, ActionConfigDef]] = pydantic.Field(None)
    ActionProperties: typing.Optional[dict[str, ActionPropertiesDef]] = pydantic.Field(None)
    CfnCustomActionType_ArtifactDetailsProperty: typing.Optional[dict[str, CfnCustomActionType_ArtifactDetailsPropertyDef]] = pydantic.Field(None)
    CfnCustomActionType_ConfigurationPropertiesProperty: typing.Optional[dict[str, CfnCustomActionType_ConfigurationPropertiesPropertyDef]] = pydantic.Field(None)
    CfnCustomActionType_SettingsProperty: typing.Optional[dict[str, CfnCustomActionType_SettingsPropertyDef]] = pydantic.Field(None)
    CfnPipeline_ActionDeclarationProperty: typing.Optional[dict[str, CfnPipeline_ActionDeclarationPropertyDef]] = pydantic.Field(None)
    CfnPipeline_ActionTypeIdProperty: typing.Optional[dict[str, CfnPipeline_ActionTypeIdPropertyDef]] = pydantic.Field(None)
    CfnPipeline_ArtifactStoreMapProperty: typing.Optional[dict[str, CfnPipeline_ArtifactStoreMapPropertyDef]] = pydantic.Field(None)
    CfnPipeline_ArtifactStoreProperty: typing.Optional[dict[str, CfnPipeline_ArtifactStorePropertyDef]] = pydantic.Field(None)
    CfnPipeline_BlockerDeclarationProperty: typing.Optional[dict[str, CfnPipeline_BlockerDeclarationPropertyDef]] = pydantic.Field(None)
    CfnPipeline_EncryptionKeyProperty: typing.Optional[dict[str, CfnPipeline_EncryptionKeyPropertyDef]] = pydantic.Field(None)
    CfnPipeline_InputArtifactProperty: typing.Optional[dict[str, CfnPipeline_InputArtifactPropertyDef]] = pydantic.Field(None)
    CfnPipeline_OutputArtifactProperty: typing.Optional[dict[str, CfnPipeline_OutputArtifactPropertyDef]] = pydantic.Field(None)
    CfnPipeline_StageDeclarationProperty: typing.Optional[dict[str, CfnPipeline_StageDeclarationPropertyDef]] = pydantic.Field(None)
    CfnPipeline_StageTransitionProperty: typing.Optional[dict[str, CfnPipeline_StageTransitionPropertyDef]] = pydantic.Field(None)
    CfnWebhook_WebhookAuthConfigurationProperty: typing.Optional[dict[str, CfnWebhook_WebhookAuthConfigurationPropertyDef]] = pydantic.Field(None)
    CfnWebhook_WebhookFilterRuleProperty: typing.Optional[dict[str, CfnWebhook_WebhookFilterRulePropertyDef]] = pydantic.Field(None)
    CommonActionProps: typing.Optional[dict[str, CommonActionPropsDef]] = pydantic.Field(None)
    CommonAwsActionProps: typing.Optional[dict[str, CommonAwsActionPropsDef]] = pydantic.Field(None)
    CrossRegionSupport: typing.Optional[dict[str, CrossRegionSupportDef]] = pydantic.Field(None)
    CustomActionProperty: typing.Optional[dict[str, CustomActionPropertyDef]] = pydantic.Field(None)
    CustomActionRegistrationProps: typing.Optional[dict[str, CustomActionRegistrationPropsDef]] = pydantic.Field(None)
    PipelineNotifyOnOptions: typing.Optional[dict[str, PipelineNotifyOnOptionsDef]] = pydantic.Field(None)
    PipelineProps: typing.Optional[dict[str, PipelinePropsDef]] = pydantic.Field(None)
    StageOptions: typing.Optional[dict[str, StageOptionsDef]] = pydantic.Field(None)
    StagePlacement: typing.Optional[dict[str, StagePlacementDef]] = pydantic.Field(None)
    StageProps: typing.Optional[dict[str, StagePropsDef]] = pydantic.Field(None)
    CfnCustomActionType: typing.Optional[dict[str, CfnCustomActionTypeDef]] = pydantic.Field(None)
    CfnPipeline: typing.Optional[dict[str, CfnPipelineDef]] = pydantic.Field(None)
    CfnWebhook: typing.Optional[dict[str, CfnWebhookDef]] = pydantic.Field(None)
    CfnCustomActionTypeProps: typing.Optional[dict[str, CfnCustomActionTypePropsDef]] = pydantic.Field(None)
    CfnPipelineProps: typing.Optional[dict[str, CfnPipelinePropsDef]] = pydantic.Field(None)
    CfnWebhookProps: typing.Optional[dict[str, CfnWebhookPropsDef]] = pydantic.Field(None)
    ...
