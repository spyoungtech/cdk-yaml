from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_iotfleetwise.CfnCampaign.CollectionSchemeProperty
class CfnCampaign_CollectionSchemePropertyDef(BaseStruct):
    condition_based_collection_scheme: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnCampaign_ConditionBasedCollectionSchemePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(Optional) Information about a collection scheme that uses a simple logical expression to recognize what data to collect.\n')
    time_based_collection_scheme: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnCampaign_TimeBasedCollectionSchemePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(Optional) Information about a collection scheme that uses a time period to decide how often to collect data.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iotfleetwise-campaign-collectionscheme.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    collection_scheme_property = iotfleetwise.CfnCampaign.CollectionSchemeProperty(\n        condition_based_collection_scheme=iotfleetwise.CfnCampaign.ConditionBasedCollectionSchemeProperty(\n            expression="expression",\n\n            # the properties below are optional\n            condition_language_version=123,\n            minimum_trigger_interval_ms=123,\n            trigger_mode="triggerMode"\n        ),\n        time_based_collection_scheme=iotfleetwise.CfnCampaign.TimeBasedCollectionSchemeProperty(\n            period_ms=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['condition_based_collection_scheme', 'time_based_collection_scheme']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnCampaign.CollectionSchemeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnCampaign.ConditionBasedCollectionSchemeProperty
class CfnCampaign_ConditionBasedCollectionSchemePropertyDef(BaseStruct):
    expression: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The logical expression used to recognize what data to collect. For example, ``$variable.Vehicle.OutsideAirTemperature >= 105.0`` .\n')
    condition_language_version: typing.Union[int, float, None] = pydantic.Field(None, description='(Optional) Specifies the version of the conditional expression language.\n')
    minimum_trigger_interval_ms: typing.Union[int, float, None] = pydantic.Field(None, description='(Optional) The minimum duration of time between two triggering events to collect data, in milliseconds. .. epigraph:: If a signal changes often, you might want to collect data at a slower rate.\n')
    trigger_mode: typing.Optional[str] = pydantic.Field(None, description='(Optional) Whether to collect data for all triggering events ( ``ALWAYS`` ). Specify ( ``RISING_EDGE`` ), or specify only when the condition first evaluates to false. For example, triggering on "AirbagDeployed"; Users aren\'t interested on triggering when the airbag is already exploded; they only care about the change from not deployed => deployed.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iotfleetwise-campaign-conditionbasedcollectionscheme.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    condition_based_collection_scheme_property = iotfleetwise.CfnCampaign.ConditionBasedCollectionSchemeProperty(\n        expression="expression",\n\n        # the properties below are optional\n        condition_language_version=123,\n        minimum_trigger_interval_ms=123,\n        trigger_mode="triggerMode"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['expression', 'condition_language_version', 'minimum_trigger_interval_ms', 'trigger_mode']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnCampaign.ConditionBasedCollectionSchemeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnCampaign.DataDestinationConfigProperty
class CfnCampaign_DataDestinationConfigPropertyDef(BaseStruct):
    s3_config: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnCampaign_S3ConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(Optional) The Amazon S3 bucket where the AWS IoT FleetWise campaign sends data.\n')
    timestream_config: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnCampaign_TimestreamConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(Optional) The Amazon Timestream table where the campaign sends data.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iotfleetwise-campaign-datadestinationconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    data_destination_config_property = iotfleetwise.CfnCampaign.DataDestinationConfigProperty(\n        s3_config=iotfleetwise.CfnCampaign.S3ConfigProperty(\n            bucket_arn="bucketArn",\n\n            # the properties below are optional\n            data_format="dataFormat",\n            prefix="prefix",\n            storage_compression_format="storageCompressionFormat"\n        ),\n        timestream_config=iotfleetwise.CfnCampaign.TimestreamConfigProperty(\n            execution_role_arn="executionRoleArn",\n            timestream_table_arn="timestreamTableArn"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['s3_config', 'timestream_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnCampaign.DataDestinationConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnCampaign.S3ConfigProperty
class CfnCampaign_S3ConfigPropertyDef(BaseStruct):
    bucket_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the Amazon S3 bucket.\n')
    data_format: typing.Optional[str] = pydantic.Field(None, description='(Optional) Specify the format that files are saved in the Amazon S3 bucket. You can save files in an Apache Parquet or JSON format. - Parquet - Store data in a columnar storage file format. Parquet is optimal for fast data retrieval and can reduce costs. This option is selected by default. - JSON - Store data in a standard text-based JSON file format.\n')
    prefix: typing.Optional[str] = pydantic.Field(None, description='(Optional) Enter an S3 bucket prefix. The prefix is the string of characters after the bucket name and before the object name. You can use the prefix to organize data stored in Amazon S3 buckets. For more information, see `Organizing objects using prefixes <https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html>`_ in the *Amazon Simple Storage Service User Guide* . By default, AWS IoT FleetWise sets the prefix ``processed-data/year=YY/month=MM/date=DD/hour=HH/`` (in UTC) to data it delivers to Amazon S3 . You can enter a prefix to append it to this default prefix. For example, if you enter the prefix ``vehicles`` , the prefix will be ``vehicles/processed-data/year=YY/month=MM/date=DD/hour=HH/`` .\n')
    storage_compression_format: typing.Optional[str] = pydantic.Field(None, description='(Optional) By default, stored data is compressed as a .gzip file. Compressed files have a reduced file size, which can optimize the cost of data storage.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iotfleetwise-campaign-s3config.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    s3_config_property = iotfleetwise.CfnCampaign.S3ConfigProperty(\n        bucket_arn="bucketArn",\n\n        # the properties below are optional\n        data_format="dataFormat",\n        prefix="prefix",\n        storage_compression_format="storageCompressionFormat"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket_arn', 'data_format', 'prefix', 'storage_compression_format']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnCampaign.S3ConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnCampaign.SignalInformationProperty
class CfnCampaign_SignalInformationPropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the signal.\n')
    max_sample_count: typing.Union[int, float, None] = pydantic.Field(None, description='(Optional) The maximum number of samples to collect.\n')
    minimum_sampling_interval_ms: typing.Union[int, float, None] = pydantic.Field(None, description='(Optional) The minimum duration of time (in milliseconds) between two triggering events to collect data. .. epigraph:: If a signal changes often, you might want to collect data at a slower rate.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iotfleetwise-campaign-signalinformation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    signal_information_property = iotfleetwise.CfnCampaign.SignalInformationProperty(\n        name="name",\n\n        # the properties below are optional\n        max_sample_count=123,\n        minimum_sampling_interval_ms=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'max_sample_count', 'minimum_sampling_interval_ms']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnCampaign.SignalInformationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnCampaign.TimeBasedCollectionSchemeProperty
class CfnCampaign_TimeBasedCollectionSchemePropertyDef(BaseStruct):
    period_ms: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='The time period (in milliseconds) to decide how often to collect data. For example, if the time period is ``60000`` , the Edge Agent software collects data once every minute.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iotfleetwise-campaign-timebasedcollectionscheme.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    time_based_collection_scheme_property = iotfleetwise.CfnCampaign.TimeBasedCollectionSchemeProperty(\n        period_ms=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['period_ms']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnCampaign.TimeBasedCollectionSchemeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnCampaign.TimestreamConfigProperty
class CfnCampaign_TimestreamConfigPropertyDef(BaseStruct):
    execution_role_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the task execution role that grants AWS IoT FleetWise permission to deliver data to the Amazon Timestream table.\n')
    timestream_table_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the Amazon Timestream table.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iotfleetwise-campaign-timestreamconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    timestream_config_property = iotfleetwise.CfnCampaign.TimestreamConfigProperty(\n        execution_role_arn="executionRoleArn",\n        timestream_table_arn="timestreamTableArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['execution_role_arn', 'timestream_table_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnCampaign.TimestreamConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnDecoderManifest.CanInterfaceProperty
class CfnDecoderManifest_CanInterfacePropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique name of the interface.\n')
    protocol_name: typing.Optional[str] = pydantic.Field(None, description='(Optional) The name of the communication protocol for the interface.\n')
    protocol_version: typing.Optional[str] = pydantic.Field(None, description='(Optional) The version of the communication protocol for the interface.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iotfleetwise-decodermanifest-caninterface.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    can_interface_property = iotfleetwise.CfnDecoderManifest.CanInterfaceProperty(\n        name="name",\n\n        # the properties below are optional\n        protocol_name="protocolName",\n        protocol_version="protocolVersion"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'protocol_name', 'protocol_version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnDecoderManifest.CanInterfaceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnDecoderManifest.CanNetworkInterfaceProperty
class CfnDecoderManifest_CanNetworkInterfacePropertyDef(BaseStruct):
    can_interface: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_iotfleetwise.CfnDecoderManifest_CanInterfacePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Information about a network interface specified by the Controller Area Network (CAN) protocol.\n')
    interface_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the network interface.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The network protocol for the vehicle. For example, ``CAN_SIGNAL`` specifies a protocol that defines how data is communicated between electronic control units (ECUs). ``OBD_SIGNAL`` specifies a protocol that defines how self-diagnostic data is communicated between ECUs.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iotfleetwise-decodermanifest-cannetworkinterface.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    can_network_interface_property = iotfleetwise.CfnDecoderManifest.CanNetworkInterfaceProperty(\n        can_interface=iotfleetwise.CfnDecoderManifest.CanInterfaceProperty(\n            name="name",\n\n            # the properties below are optional\n            protocol_name="protocolName",\n            protocol_version="protocolVersion"\n        ),\n        interface_id="interfaceId",\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['can_interface', 'interface_id', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnDecoderManifest.CanNetworkInterfaceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnDecoderManifest.CanSignalDecoderProperty
class CfnDecoderManifest_CanSignalDecoderPropertyDef(BaseStruct):
    can_signal: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_iotfleetwise.CfnDecoderManifest_CanSignalPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Information about a single controller area network (CAN) signal and the messages it receives and transmits.\n')
    fully_qualified_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The fully qualified name of a signal decoder as defined in a vehicle model.\n')
    interface_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of a network interface that specifies what network protocol a vehicle follows.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The network protocol for the vehicle. For example, ``CAN_SIGNAL`` specifies a protocol that defines how data is communicated between electronic control units (ECUs). ``OBD_SIGNAL`` specifies a protocol that defines how self-diagnostic data is communicated between ECUs.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iotfleetwise-decodermanifest-cansignaldecoder.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    can_signal_decoder_property = iotfleetwise.CfnDecoderManifest.CanSignalDecoderProperty(\n        can_signal=iotfleetwise.CfnDecoderManifest.CanSignalProperty(\n            factor="factor",\n            is_big_endian="isBigEndian",\n            is_signed="isSigned",\n            length="length",\n            message_id="messageId",\n            offset="offset",\n            start_bit="startBit",\n\n            # the properties below are optional\n            name="name"\n        ),\n        fully_qualified_name="fullyQualifiedName",\n        interface_id="interfaceId",\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['can_signal', 'fully_qualified_name', 'interface_id', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnDecoderManifest.CanSignalDecoderProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnDecoderManifest.CanSignalProperty
class CfnDecoderManifest_CanSignalPropertyDef(BaseStruct):
    factor: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A multiplier used to decode the CAN message.\n')
    is_big_endian: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Whether the byte ordering of a CAN message is big-endian.\n')
    is_signed: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Whether the message data is specified as a signed value.\n')
    length: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='How many bytes of data are in the message.\n')
    message_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the message.\n')
    offset: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The offset used to calculate the signal value. Combined with factor, the calculation is ``value = raw_value * factor + offset`` .\n')
    start_bit: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Indicates the beginning of the CAN message.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='(Optional) The name of the signal.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iotfleetwise-decodermanifest-cansignal.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    can_signal_property = iotfleetwise.CfnDecoderManifest.CanSignalProperty(\n        factor="factor",\n        is_big_endian="isBigEndian",\n        is_signed="isSigned",\n        length="length",\n        message_id="messageId",\n        offset="offset",\n        start_bit="startBit",\n\n        # the properties below are optional\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['factor', 'is_big_endian', 'is_signed', 'length', 'message_id', 'offset', 'start_bit', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnDecoderManifest.CanSignalProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnDecoderManifest.NetworkInterfacesItemsProperty
class CfnDecoderManifest_NetworkInterfacesItemsPropertyDef(BaseStruct):
    interface_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='')
    can_interface: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnDecoderManifest_CanInterfacePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    obd_interface: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnDecoderManifest_ObdInterfacePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    _init_params: typing.ClassVar[list[str]] = ['interface_id', 'type', 'can_interface', 'obd_interface']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnDecoderManifest.NetworkInterfacesItemsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnDecoderManifest.ObdInterfaceProperty
class CfnDecoderManifest_ObdInterfacePropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the interface.\n')
    request_message_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the message requesting vehicle data.\n')
    dtc_request_interval_seconds: typing.Optional[str] = pydantic.Field(None, description='(Optional) The maximum number message requests per diagnostic trouble code per second.\n')
    has_transmission_ecu: typing.Optional[str] = pydantic.Field(None, description='(Optional) Whether the vehicle has a transmission control module (TCM).\n')
    obd_standard: typing.Optional[str] = pydantic.Field(None, description='(Optional) The standard OBD II PID.\n')
    pid_request_interval_seconds: typing.Optional[str] = pydantic.Field(None, description='(Optional) The maximum number message requests per second.\n')
    use_extended_ids: typing.Optional[str] = pydantic.Field(None, description='(Optional) Whether to use extended IDs in the message.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iotfleetwise-decodermanifest-obdinterface.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    obd_interface_property = iotfleetwise.CfnDecoderManifest.ObdInterfaceProperty(\n        name="name",\n        request_message_id="requestMessageId",\n\n        # the properties below are optional\n        dtc_request_interval_seconds="dtcRequestIntervalSeconds",\n        has_transmission_ecu="hasTransmissionEcu",\n        obd_standard="obdStandard",\n        pid_request_interval_seconds="pidRequestIntervalSeconds",\n        use_extended_ids="useExtendedIds"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'request_message_id', 'dtc_request_interval_seconds', 'has_transmission_ecu', 'obd_standard', 'pid_request_interval_seconds', 'use_extended_ids']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnDecoderManifest.ObdInterfaceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnDecoderManifest.ObdNetworkInterfaceProperty
class CfnDecoderManifest_ObdNetworkInterfacePropertyDef(BaseStruct):
    interface_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the network interface.\n')
    obd_interface: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_iotfleetwise.CfnDecoderManifest_ObdInterfacePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='(Optional) Information about a network interface specified by the On-board diagnostic (OBD) II protocol.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The network protocol for the vehicle. For example, ``CAN_SIGNAL`` specifies a protocol that defines how data is communicated between electronic control units (ECUs). ``OBD_SIGNAL`` specifies a protocol that defines how self-diagnostic data is communicated between ECUs.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iotfleetwise-decodermanifest-obdnetworkinterface.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    obd_network_interface_property = iotfleetwise.CfnDecoderManifest.ObdNetworkInterfaceProperty(\n        interface_id="interfaceId",\n        obd_interface=iotfleetwise.CfnDecoderManifest.ObdInterfaceProperty(\n            name="name",\n            request_message_id="requestMessageId",\n\n            # the properties below are optional\n            dtc_request_interval_seconds="dtcRequestIntervalSeconds",\n            has_transmission_ecu="hasTransmissionEcu",\n            obd_standard="obdStandard",\n            pid_request_interval_seconds="pidRequestIntervalSeconds",\n            use_extended_ids="useExtendedIds"\n        ),\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['interface_id', 'obd_interface', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnDecoderManifest.ObdNetworkInterfaceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnDecoderManifest.ObdSignalDecoderProperty
class CfnDecoderManifest_ObdSignalDecoderPropertyDef(BaseStruct):
    fully_qualified_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='')
    interface_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='')
    obd_signal: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_iotfleetwise.CfnDecoderManifest_ObdSignalPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Information about signal messages using the on-board diagnostics (OBD) II protocol in a vehicle.\n')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='')
    _init_params: typing.ClassVar[list[str]] = ['fully_qualified_name', 'interface_id', 'obd_signal', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnDecoderManifest.ObdSignalDecoderProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnDecoderManifest.ObdSignalProperty
class CfnDecoderManifest_ObdSignalPropertyDef(BaseStruct):
    byte_length: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The length of a message.\n')
    offset: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The offset used to calculate the signal value. Combined with scaling, the calculation is ``value = raw_value * scaling + offset`` .\n')
    pid: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The diagnostic code used to request data from a vehicle for this signal.\n')
    pid_response_length: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The length of the requested data.\n')
    scaling: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='A multiplier used to decode the message.\n')
    service_mode: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The mode of operation (diagnostic service) in a message.\n')
    start_byte: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Indicates the beginning of the message.\n')
    bit_mask_length: typing.Optional[str] = pydantic.Field(None, description='(Optional) The number of bits to mask in a message.\n')
    bit_right_shift: typing.Optional[str] = pydantic.Field(None, description='(Optional) The number of positions to shift bits in the message.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iotfleetwise-decodermanifest-obdsignal.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    obd_signal_property = iotfleetwise.CfnDecoderManifest.ObdSignalProperty(\n        byte_length="byteLength",\n        offset="offset",\n        pid="pid",\n        pid_response_length="pidResponseLength",\n        scaling="scaling",\n        service_mode="serviceMode",\n        start_byte="startByte",\n\n        # the properties below are optional\n        bit_mask_length="bitMaskLength",\n        bit_right_shift="bitRightShift"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['byte_length', 'offset', 'pid', 'pid_response_length', 'scaling', 'service_mode', 'start_byte', 'bit_mask_length', 'bit_right_shift']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnDecoderManifest.ObdSignalProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnDecoderManifest.SignalDecodersItemsProperty
class CfnDecoderManifest_SignalDecodersItemsPropertyDef(BaseStruct):
    fully_qualified_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='')
    interface_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='')
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='')
    can_signal: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnDecoderManifest_CanSignalPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    obd_signal: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnDecoderManifest_ObdSignalPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    _init_params: typing.ClassVar[list[str]] = ['fully_qualified_name', 'interface_id', 'type', 'can_signal', 'obd_signal']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnDecoderManifest.SignalDecodersItemsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnSignalCatalog.ActuatorProperty
class CfnSignalCatalog_ActuatorPropertyDef(BaseStruct):
    data_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The specified data type of the actuator.\n')
    fully_qualified_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The fully qualified name of the actuator. For example, the fully qualified name of an actuator might be ``Vehicle.Front.Left.Door.Lock`` .\n')
    allowed_values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='(Optional) A list of possible values an actuator can take.\n')
    assigned_value: typing.Optional[str] = pydantic.Field(None, description='(Optional) A specified value for the actuator.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='(Optional) A brief description of the actuator.\n')
    max: typing.Union[int, float, None] = pydantic.Field(None, description='(Optional) The specified possible maximum value of an actuator.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='(Optional) The specified possible minimum value of an actuator.\n')
    unit: typing.Optional[str] = pydantic.Field(None, description='(Optional) The scientific unit for the actuator.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iotfleetwise-signalcatalog-actuator.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    actuator_property = iotfleetwise.CfnSignalCatalog.ActuatorProperty(\n        data_type="dataType",\n        fully_qualified_name="fullyQualifiedName",\n\n        # the properties below are optional\n        allowed_values=["allowedValues"],\n        assigned_value="assignedValue",\n        description="description",\n        max=123,\n        min=123,\n        unit="unit"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['data_type', 'fully_qualified_name', 'allowed_values', 'assigned_value', 'description', 'max', 'min', 'unit']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnSignalCatalog.ActuatorProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnSignalCatalog.AttributeProperty
class CfnSignalCatalog_AttributePropertyDef(BaseStruct):
    data_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The specified data type of the attribute.\n')
    fully_qualified_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The fully qualified name of the attribute. For example, the fully qualified name of an attribute might be ``Vehicle.Body.Engine.Type`` .\n')
    allowed_values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='(Optional) A list of possible values an attribute can be assigned.\n')
    assigned_value: typing.Optional[str] = pydantic.Field(None, description='(Optional) A specified value for the attribute.\n')
    default_value: typing.Optional[str] = pydantic.Field(None, description='(Optional) The default value of the attribute.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='(Optional) A brief description of the attribute.\n')
    max: typing.Union[int, float, None] = pydantic.Field(None, description='(Optional) The specified possible maximum value of the attribute.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='(Optional) The specified possible minimum value of the attribute.\n')
    unit: typing.Optional[str] = pydantic.Field(None, description='(Optional) The scientific unit for the attribute.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iotfleetwise-signalcatalog-attribute.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    attribute_property = iotfleetwise.CfnSignalCatalog.AttributeProperty(\n        data_type="dataType",\n        fully_qualified_name="fullyQualifiedName",\n\n        # the properties below are optional\n        allowed_values=["allowedValues"],\n        assigned_value="assignedValue",\n        default_value="defaultValue",\n        description="description",\n        max=123,\n        min=123,\n        unit="unit"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['data_type', 'fully_qualified_name', 'allowed_values', 'assigned_value', 'default_value', 'description', 'max', 'min', 'unit']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnSignalCatalog.AttributeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnSignalCatalog.BranchProperty
class CfnSignalCatalog_BranchPropertyDef(BaseStruct):
    fully_qualified_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The fully qualified name of the branch. For example, the fully qualified name of a branch might be ``Vehicle.Body.Engine`` .\n')
    description: typing.Optional[str] = pydantic.Field(None, description='(Optional) A brief description of the branch.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iotfleetwise-signalcatalog-branch.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    branch_property = iotfleetwise.CfnSignalCatalog.BranchProperty(\n        fully_qualified_name="fullyQualifiedName",\n\n        # the properties below are optional\n        description="description"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['fully_qualified_name', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnSignalCatalog.BranchProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnSignalCatalog.NodeCountsProperty
class CfnSignalCatalog_NodeCountsPropertyDef(BaseStruct):
    total_actuators: typing.Union[int, float, None] = pydantic.Field(None, description='(Optional) The total number of nodes in a vehicle network that represent actuators.\n')
    total_attributes: typing.Union[int, float, None] = pydantic.Field(None, description='(Optional) The total number of nodes in a vehicle network that represent attributes.\n')
    total_branches: typing.Union[int, float, None] = pydantic.Field(None, description='(Optional) The total number of nodes in a vehicle network that represent branches.\n')
    total_nodes: typing.Union[int, float, None] = pydantic.Field(None, description='(Optional) The total number of nodes in a vehicle network.\n')
    total_sensors: typing.Union[int, float, None] = pydantic.Field(None, description='(Optional) The total number of nodes in a vehicle network that represent sensors.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iotfleetwise-signalcatalog-nodecounts.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    node_counts_property = iotfleetwise.CfnSignalCatalog.NodeCountsProperty(\n        total_actuators=123,\n        total_attributes=123,\n        total_branches=123,\n        total_nodes=123,\n        total_sensors=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['total_actuators', 'total_attributes', 'total_branches', 'total_nodes', 'total_sensors']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnSignalCatalog.NodeCountsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnSignalCatalog.NodeProperty
class CfnSignalCatalog_NodePropertyDef(BaseStruct):
    actuator: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnSignalCatalog_ActuatorPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(Optional) Information about a node specified as an actuator. .. epigraph:: An actuator is a digital representation of a vehicle device.\n')
    attribute: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnSignalCatalog_AttributePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(Optional) Information about a node specified as an attribute. .. epigraph:: An attribute represents static information about a vehicle.\n')
    branch: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnSignalCatalog_BranchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(Optional) Information about a node specified as a branch. .. epigraph:: A group of signals that are defined in a hierarchical structure.\n')
    sensor: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnSignalCatalog_SensorPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(Optional) An input component that reports the environmental condition of a vehicle. .. epigraph:: You can collect data about fluid levels, temperatures, vibrations, or battery voltage from sensors.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iotfleetwise-signalcatalog-node.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    node_property = iotfleetwise.CfnSignalCatalog.NodeProperty(\n        actuator=iotfleetwise.CfnSignalCatalog.ActuatorProperty(\n            data_type="dataType",\n            fully_qualified_name="fullyQualifiedName",\n\n            # the properties below are optional\n            allowed_values=["allowedValues"],\n            assigned_value="assignedValue",\n            description="description",\n            max=123,\n            min=123,\n            unit="unit"\n        ),\n        attribute=iotfleetwise.CfnSignalCatalog.AttributeProperty(\n            data_type="dataType",\n            fully_qualified_name="fullyQualifiedName",\n\n            # the properties below are optional\n            allowed_values=["allowedValues"],\n            assigned_value="assignedValue",\n            default_value="defaultValue",\n            description="description",\n            max=123,\n            min=123,\n            unit="unit"\n        ),\n        branch=iotfleetwise.CfnSignalCatalog.BranchProperty(\n            fully_qualified_name="fullyQualifiedName",\n\n            # the properties below are optional\n            description="description"\n        ),\n        sensor=iotfleetwise.CfnSignalCatalog.SensorProperty(\n            data_type="dataType",\n            fully_qualified_name="fullyQualifiedName",\n\n            # the properties below are optional\n            allowed_values=["allowedValues"],\n            description="description",\n            max=123,\n            min=123,\n            unit="unit"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['actuator', 'attribute', 'branch', 'sensor']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnSignalCatalog.NodeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnSignalCatalog.SensorProperty
class CfnSignalCatalog_SensorPropertyDef(BaseStruct):
    data_type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The specified data type of the sensor.\n')
    fully_qualified_name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The fully qualified name of the sensor. For example, the fully qualified name of a sensor might be ``Vehicle.Body.Engine.Battery`` .\n')
    allowed_values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='(Optional) A list of possible values a sensor can take.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='(Optional) A brief description of a sensor.\n')
    max: typing.Union[int, float, None] = pydantic.Field(None, description='(Optional) The specified possible maximum value of the sensor.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='(Optional) The specified possible minimum value of the sensor.\n')
    unit: typing.Optional[str] = pydantic.Field(None, description='(Optional) The scientific unit of measurement for data collected by the sensor.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iotfleetwise-signalcatalog-sensor.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    sensor_property = iotfleetwise.CfnSignalCatalog.SensorProperty(\n        data_type="dataType",\n        fully_qualified_name="fullyQualifiedName",\n\n        # the properties below are optional\n        allowed_values=["allowedValues"],\n        description="description",\n        max=123,\n        min=123,\n        unit="unit"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['data_type', 'fully_qualified_name', 'allowed_values', 'description', 'max', 'min', 'unit']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnSignalCatalog.SensorProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnCampaign
class CfnCampaignDef(BaseCfnResource):
    action: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies how to update a campaign. The action can be one of the following:. - ``APPROVE`` - To approve delivering a data collection scheme to vehicles. - ``SUSPEND`` - To suspend collecting signal data. The campaign is deleted from vehicles and all vehicles in the suspended campaign will stop sending data. - ``RESUME`` - To reactivate the ``SUSPEND`` campaign. The campaign is redeployed to all vehicles and the vehicles will resume sending data. - ``UPDATE`` - To update a campaign.\n')
    collection_scheme: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_iotfleetwise.CfnCampaign_CollectionSchemePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The data collection scheme associated with the campaign. You can specify a scheme that collects data based on time or an event.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of a campaign.\n')
    signal_catalog_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the signal catalog associated with the campaign.\n')
    target_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of a vehicle or fleet to which the campaign is deployed.\n')
    compression: typing.Optional[str] = pydantic.Field(None, description='(Optional) Whether to compress signals before transmitting data to AWS IoT FleetWise . If you don\'t want to compress the signals, use ``OFF`` . If it\'s not specified, ``SNAPPY`` is used. Default: ``SNAPPY`` Default: - "OFF"\n')
    data_destination_configs: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnCampaign_DataDestinationConfigPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='(Optional) The destination where the campaign sends data. You can choose to send data to be stored in Amazon S3 or Amazon Timestream . Amazon S3 optimizes the cost of data storage and provides additional mechanisms to use vehicle data, such as data lakes, centralized data storage, data processing pipelines, and analytics. AWS IoT FleetWise supports at-least-once file delivery to S3. Your vehicle data is stored on multiple AWS IoT FleetWise servers for redundancy and high availability. You can use Amazon Timestream to access and analyze time series data, and Timestream to query vehicle data so that you can identify trends and patterns.\n')
    data_extra_dimensions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='(Optional) A list of vehicle attributes to associate with a campaign. Enrich the data with specified vehicle attributes. For example, add ``make`` and ``model`` to the campaign, and AWS IoT FleetWise will associate the data with those attributes as dimensions in Amazon Timestream . You can then query the data against ``make`` and ``model`` . Default: An empty array\n')
    description: typing.Optional[str] = pydantic.Field(None, description='(Optional) The description of the campaign.\n')
    diagnostics_mode: typing.Optional[str] = pydantic.Field(None, description='(Optional) Option for a vehicle to send diagnostic trouble codes to AWS IoT FleetWise . If you want to send diagnostic trouble codes, use ``SEND_ACTIVE_DTCS`` . If it\'s not specified, ``OFF`` is used. Default: ``OFF`` Default: - "OFF"\n')
    expiry_time: typing.Optional[str] = pydantic.Field(None, description='(Optional) The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data isn\'t collected after the campaign expires. Default: 253402214400 (December 31, 9999, 00:00:00 UTC) Default: - "253402214400"\n')
    post_trigger_collection_duration: typing.Union[int, float, None] = pydantic.Field(None, description="(Optional) How long (in milliseconds) to collect raw data after a triggering event initiates the collection. If it's not specified, ``0`` is used. Default: ``0`` Default: - 0\n")
    priority: typing.Union[int, float, None] = pydantic.Field(None, description="(Optional) A number indicating the priority of one campaign over another campaign for a certain vehicle or fleet. A campaign with the lowest value is deployed to vehicles before any other campaigns. If it's not specified, ``0`` is used. Default: ``0`` Default: - 0\n")
    signals_to_collect: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnCampaign_SignalInformationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='(Optional) A list of information about signals to collect.\n')
    spooling_mode: typing.Optional[str] = pydantic.Field(None, description='(Optional) Whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to AWS IoT FleetWise . If you want to store collected data when a vehicle loses connection with the cloud, use ``TO_DISK`` . If it\'s not specified, ``OFF`` is used. Default: ``OFF`` Default: - "OFF"\n')
    start_time: typing.Optional[str] = pydantic.Field(None, description='(Optional) The time, in milliseconds, to deliver a campaign after it was approved. If it\'s not specified, ``0`` is used. Default: ``0`` Default: - "0"\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='(Optional) Metadata that can be used to manage the campaign.')
    _init_params: typing.ClassVar[list[str]] = ['action', 'collection_scheme', 'name', 'signal_catalog_arn', 'target_arn', 'compression', 'data_destination_configs', 'data_extra_dimensions', 'description', 'diagnostics_mode', 'expiry_time', 'post_trigger_collection_duration', 'priority', 'signals_to_collect', 'spooling_mode', 'start_time', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['CollectionSchemeProperty', 'ConditionBasedCollectionSchemeProperty', 'DataDestinationConfigProperty', 'S3ConfigProperty', 'SignalInformationProperty', 'TimeBasedCollectionSchemeProperty', 'TimestreamConfigProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnCampaign'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnCampaignDefConfig] = pydantic.Field(None)


class CfnCampaignDefConfig(pydantic.BaseModel):
    CollectionSchemeProperty: typing.Optional[list[CfnCampaignDefCollectionschemepropertyParams]] = pydantic.Field(None, description='')
    ConditionBasedCollectionSchemeProperty: typing.Optional[list[CfnCampaignDefConditionbasedcollectionschemepropertyParams]] = pydantic.Field(None, description='')
    DataDestinationConfigProperty: typing.Optional[list[CfnCampaignDefDatadestinationconfigpropertyParams]] = pydantic.Field(None, description='')
    S3ConfigProperty: typing.Optional[list[CfnCampaignDefS3ConfigpropertyParams]] = pydantic.Field(None, description='')
    SignalInformationProperty: typing.Optional[list[CfnCampaignDefSignalinformationpropertyParams]] = pydantic.Field(None, description='')
    TimeBasedCollectionSchemeProperty: typing.Optional[list[CfnCampaignDefTimebasedcollectionschemepropertyParams]] = pydantic.Field(None, description='')
    TimestreamConfigProperty: typing.Optional[list[CfnCampaignDefTimestreamconfigpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnCampaignDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnCampaignDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnCampaignDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnCampaignDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnCampaignDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnCampaignDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnCampaignDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnCampaignDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnCampaignDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnCampaignDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnCampaignDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnCampaignDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnCampaignDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnCampaignDefCollectionschemepropertyParams(pydantic.BaseModel):
    condition_based_collection_scheme: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnCampaign_ConditionBasedCollectionSchemePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    time_based_collection_scheme: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnCampaign_TimeBasedCollectionSchemePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnCampaignDefConditionbasedcollectionschemepropertyParams(pydantic.BaseModel):
    expression: str = pydantic.Field(..., description='')
    condition_language_version: typing.Union[int, float, None] = pydantic.Field(None, description='')
    minimum_trigger_interval_ms: typing.Union[int, float, None] = pydantic.Field(None, description='')
    trigger_mode: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnCampaignDefDatadestinationconfigpropertyParams(pydantic.BaseModel):
    s3_config: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnCampaign_S3ConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    timestream_config: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnCampaign_TimestreamConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnCampaignDefS3ConfigpropertyParams(pydantic.BaseModel):
    bucket_arn: str = pydantic.Field(..., description='')
    data_format: typing.Optional[str] = pydantic.Field(None, description='')
    prefix: typing.Optional[str] = pydantic.Field(None, description='')
    storage_compression_format: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnCampaignDefSignalinformationpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    max_sample_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    minimum_sampling_interval_ms: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnCampaignDefTimebasedcollectionschemepropertyParams(pydantic.BaseModel):
    period_ms: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnCampaignDefTimestreamconfigpropertyParams(pydantic.BaseModel):
    execution_role_arn: str = pydantic.Field(..., description='')
    timestream_table_arn: str = pydantic.Field(..., description='')
    ...

class CfnCampaignDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnCampaignDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCampaignDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnCampaignDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCampaignDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnCampaignDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnCampaignDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnCampaignDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnCampaignDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnCampaignDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCampaignDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnCampaignDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnCampaignDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCampaignDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iotfleetwise.CfnDecoderManifest
class CfnDecoderManifestDef(BaseCfnResource):
    model_manifest_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of a vehicle model (model manifest) associated with the decoder manifest.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the decoder manifest.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='(Optional) A brief description of the decoder manifest.\n')
    network_interfaces: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnDecoderManifest_NetworkInterfacesItemsPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='(Optional) A list of information about available network interfaces.\n')
    signal_decoders: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnDecoderManifest_SignalDecodersItemsPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='(Optional) A list of information about signal decoders.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='(Optional) The state of the decoder manifest. If the status is ``ACTIVE`` , the decoder manifest can\'t be edited. If the status is marked ``DRAFT`` , you can edit the decoder manifest. Default: - "DRAFT"\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='(Optional) Metadata that can be used to manage the decoder manifest.')
    _init_params: typing.ClassVar[list[str]] = ['model_manifest_arn', 'name', 'description', 'network_interfaces', 'signal_decoders', 'status', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['CanInterfaceProperty', 'CanNetworkInterfaceProperty', 'CanSignalDecoderProperty', 'CanSignalProperty', 'NetworkInterfacesItemsProperty', 'ObdInterfaceProperty', 'ObdNetworkInterfaceProperty', 'ObdSignalDecoderProperty', 'ObdSignalProperty', 'SignalDecodersItemsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnDecoderManifest'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnDecoderManifestDefConfig] = pydantic.Field(None)


class CfnDecoderManifestDefConfig(pydantic.BaseModel):
    CanInterfaceProperty: typing.Optional[list[CfnDecoderManifestDefCaninterfacepropertyParams]] = pydantic.Field(None, description='')
    CanNetworkInterfaceProperty: typing.Optional[list[CfnDecoderManifestDefCannetworkinterfacepropertyParams]] = pydantic.Field(None, description='')
    CanSignalDecoderProperty: typing.Optional[list[CfnDecoderManifestDefCansignaldecoderpropertyParams]] = pydantic.Field(None, description='')
    CanSignalProperty: typing.Optional[list[CfnDecoderManifestDefCansignalpropertyParams]] = pydantic.Field(None, description='')
    NetworkInterfacesItemsProperty: typing.Optional[list[CfnDecoderManifestDefNetworkinterfacesitemspropertyParams]] = pydantic.Field(None, description='')
    ObdInterfaceProperty: typing.Optional[list[CfnDecoderManifestDefObdinterfacepropertyParams]] = pydantic.Field(None, description='')
    ObdNetworkInterfaceProperty: typing.Optional[list[CfnDecoderManifestDefObdnetworkinterfacepropertyParams]] = pydantic.Field(None, description='')
    ObdSignalDecoderProperty: typing.Optional[list[CfnDecoderManifestDefObdsignaldecoderpropertyParams]] = pydantic.Field(None, description='')
    ObdSignalProperty: typing.Optional[list[CfnDecoderManifestDefObdsignalpropertyParams]] = pydantic.Field(None, description='')
    SignalDecodersItemsProperty: typing.Optional[list[CfnDecoderManifestDefSignaldecodersitemspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnDecoderManifestDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnDecoderManifestDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnDecoderManifestDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnDecoderManifestDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnDecoderManifestDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnDecoderManifestDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnDecoderManifestDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnDecoderManifestDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnDecoderManifestDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnDecoderManifestDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnDecoderManifestDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnDecoderManifestDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnDecoderManifestDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDecoderManifestDefCaninterfacepropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    protocol_name: typing.Optional[str] = pydantic.Field(None, description='')
    protocol_version: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDecoderManifestDefCannetworkinterfacepropertyParams(pydantic.BaseModel):
    can_interface: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnDecoderManifest_CanInterfacePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    interface_id: str = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    ...

class CfnDecoderManifestDefCansignaldecoderpropertyParams(pydantic.BaseModel):
    can_signal: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnDecoderManifest_CanSignalPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    fully_qualified_name: str = pydantic.Field(..., description='')
    interface_id: str = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    ...

class CfnDecoderManifestDefCansignalpropertyParams(pydantic.BaseModel):
    factor: str = pydantic.Field(..., description='')
    is_big_endian: str = pydantic.Field(..., description='')
    is_signed: str = pydantic.Field(..., description='')
    length: str = pydantic.Field(..., description='')
    message_id: str = pydantic.Field(..., description='')
    offset: str = pydantic.Field(..., description='')
    start_bit: str = pydantic.Field(..., description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDecoderManifestDefNetworkinterfacesitemspropertyParams(pydantic.BaseModel):
    interface_id: str = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    can_interface: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnDecoderManifest_CanInterfacePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    obd_interface: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnDecoderManifest_ObdInterfacePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnDecoderManifestDefObdinterfacepropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    request_message_id: str = pydantic.Field(..., description='')
    dtc_request_interval_seconds: typing.Optional[str] = pydantic.Field(None, description='')
    has_transmission_ecu: typing.Optional[str] = pydantic.Field(None, description='')
    obd_standard: typing.Optional[str] = pydantic.Field(None, description='')
    pid_request_interval_seconds: typing.Optional[str] = pydantic.Field(None, description='')
    use_extended_ids: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDecoderManifestDefObdnetworkinterfacepropertyParams(pydantic.BaseModel):
    interface_id: str = pydantic.Field(..., description='')
    obd_interface: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnDecoderManifest_ObdInterfacePropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    ...

class CfnDecoderManifestDefObdsignaldecoderpropertyParams(pydantic.BaseModel):
    fully_qualified_name: str = pydantic.Field(..., description='')
    interface_id: str = pydantic.Field(..., description='')
    obd_signal: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnDecoderManifest_ObdSignalPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    ...

class CfnDecoderManifestDefObdsignalpropertyParams(pydantic.BaseModel):
    byte_length: str = pydantic.Field(..., description='')
    offset: str = pydantic.Field(..., description='')
    pid: str = pydantic.Field(..., description='')
    pid_response_length: str = pydantic.Field(..., description='')
    scaling: str = pydantic.Field(..., description='')
    service_mode: str = pydantic.Field(..., description='')
    start_byte: str = pydantic.Field(..., description='')
    bit_mask_length: typing.Optional[str] = pydantic.Field(None, description='')
    bit_right_shift: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnDecoderManifestDefSignaldecodersitemspropertyParams(pydantic.BaseModel):
    fully_qualified_name: str = pydantic.Field(..., description='')
    interface_id: str = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    can_signal: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnDecoderManifest_CanSignalPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    obd_signal: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnDecoderManifest_ObdSignalPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnDecoderManifestDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDecoderManifestDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDecoderManifestDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDecoderManifestDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDecoderManifestDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDecoderManifestDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDecoderManifestDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDecoderManifestDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDecoderManifestDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDecoderManifestDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDecoderManifestDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDecoderManifestDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDecoderManifestDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDecoderManifestDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iotfleetwise.CfnFleet
class CfnFleetDef(BaseCfnResource):
    id_: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Construct identifier for this resource (unique in its scope).\n')
    signal_catalog_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the signal catalog associated with the fleet.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='(Optional) A brief description of the fleet.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='(Optional) Metadata that can be used to manage the fleet.')
    _init_params: typing.ClassVar[list[str]] = ['id_', 'signal_catalog_arn', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnFleet'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnFleetDefConfig] = pydantic.Field(None)


class CfnFleetDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnFleetDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnFleetDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnFleetDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnFleetDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnFleetDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnFleetDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnFleetDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnFleetDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnFleetDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnFleetDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnFleetDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnFleetDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnFleetDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnFleetDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnFleetDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFleetDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnFleetDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFleetDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnFleetDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnFleetDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnFleetDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnFleetDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnFleetDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFleetDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnFleetDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnFleetDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFleetDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iotfleetwise.CfnModelManifest
class CfnModelManifestDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the vehicle model.\n')
    signal_catalog_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the signal catalog associated with the vehicle model.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='(Optional) A brief description of the vehicle model.\n')
    nodes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='(Optional) A list of nodes, which are a general abstraction of signals.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='(Optional) The state of the vehicle model. If the status is ``ACTIVE`` , the vehicle model can\'t be edited. If the status is ``DRAFT`` , you can edit the vehicle model. Default: - "DRAFT"\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='(Optional) Metadata that can be used to manage the vehicle model.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'signal_catalog_arn', 'description', 'nodes', 'status', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnModelManifest'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnModelManifestDefConfig] = pydantic.Field(None)


class CfnModelManifestDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnModelManifestDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnModelManifestDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnModelManifestDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnModelManifestDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnModelManifestDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnModelManifestDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnModelManifestDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnModelManifestDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnModelManifestDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnModelManifestDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnModelManifestDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnModelManifestDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnModelManifestDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnModelManifestDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnModelManifestDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnModelManifestDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnModelManifestDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnModelManifestDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnModelManifestDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnModelManifestDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnModelManifestDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnModelManifestDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnModelManifestDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnModelManifestDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnModelManifestDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnModelManifestDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnModelManifestDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iotfleetwise.CfnSignalCatalog
class CfnSignalCatalogDef(BaseCfnResource):
    description: typing.Optional[str] = pydantic.Field(None, description='(Optional) A brief description of the signal catalog.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='(Optional) The name of the signal catalog.\n')
    node_counts: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnSignalCatalog_NodeCountsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(Optional) Information about the number of nodes and node types in a vehicle network.\n')
    nodes: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnSignalCatalog_NodePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='(Optional) A list of information about nodes, which are a general abstraction of signals.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='(Optional) Metadata that can be used to manage the signal catalog.')
    _init_params: typing.ClassVar[list[str]] = ['description', 'name', 'node_counts', 'nodes', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['ActuatorProperty', 'AttributeProperty', 'BranchProperty', 'NodeCountsProperty', 'NodeProperty', 'SensorProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnSignalCatalog'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnSignalCatalogDefConfig] = pydantic.Field(None)


class CfnSignalCatalogDefConfig(pydantic.BaseModel):
    ActuatorProperty: typing.Optional[list[CfnSignalCatalogDefActuatorpropertyParams]] = pydantic.Field(None, description='')
    AttributeProperty: typing.Optional[list[CfnSignalCatalogDefAttributepropertyParams]] = pydantic.Field(None, description='')
    BranchProperty: typing.Optional[list[CfnSignalCatalogDefBranchpropertyParams]] = pydantic.Field(None, description='')
    NodeCountsProperty: typing.Optional[list[CfnSignalCatalogDefNodecountspropertyParams]] = pydantic.Field(None, description='')
    NodeProperty: typing.Optional[list[CfnSignalCatalogDefNodepropertyParams]] = pydantic.Field(None, description='')
    SensorProperty: typing.Optional[list[CfnSignalCatalogDefSensorpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnSignalCatalogDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnSignalCatalogDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnSignalCatalogDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnSignalCatalogDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnSignalCatalogDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnSignalCatalogDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnSignalCatalogDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnSignalCatalogDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnSignalCatalogDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnSignalCatalogDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnSignalCatalogDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnSignalCatalogDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnSignalCatalogDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_node_counts_total_actuators_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_node_counts_total_attributes_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_node_counts_total_branches_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_node_counts_total_nodes_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_node_counts_total_sensors_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnSignalCatalogDefActuatorpropertyParams(pydantic.BaseModel):
    data_type: str = pydantic.Field(..., description='')
    fully_qualified_name: str = pydantic.Field(..., description='')
    allowed_values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    assigned_value: typing.Optional[str] = pydantic.Field(None, description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    unit: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSignalCatalogDefAttributepropertyParams(pydantic.BaseModel):
    data_type: str = pydantic.Field(..., description='')
    fully_qualified_name: str = pydantic.Field(..., description='')
    allowed_values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    assigned_value: typing.Optional[str] = pydantic.Field(None, description='')
    default_value: typing.Optional[str] = pydantic.Field(None, description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    unit: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSignalCatalogDefBranchpropertyParams(pydantic.BaseModel):
    fully_qualified_name: str = pydantic.Field(..., description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSignalCatalogDefNodecountspropertyParams(pydantic.BaseModel):
    total_actuators: typing.Union[int, float, None] = pydantic.Field(None, description='')
    total_attributes: typing.Union[int, float, None] = pydantic.Field(None, description='')
    total_branches: typing.Union[int, float, None] = pydantic.Field(None, description='')
    total_nodes: typing.Union[int, float, None] = pydantic.Field(None, description='')
    total_sensors: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnSignalCatalogDefNodepropertyParams(pydantic.BaseModel):
    actuator: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnSignalCatalog_ActuatorPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    attribute: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnSignalCatalog_AttributePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    branch: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnSignalCatalog_BranchPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    sensor: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnSignalCatalog_SensorPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnSignalCatalogDefSensorpropertyParams(pydantic.BaseModel):
    data_type: str = pydantic.Field(..., description='')
    fully_qualified_name: str = pydantic.Field(..., description='')
    allowed_values: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    unit: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSignalCatalogDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSignalCatalogDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSignalCatalogDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSignalCatalogDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSignalCatalogDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSignalCatalogDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSignalCatalogDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSignalCatalogDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSignalCatalogDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSignalCatalogDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSignalCatalogDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnSignalCatalogDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSignalCatalogDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSignalCatalogDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iotfleetwise.CfnVehicle
class CfnVehicleDef(BaseCfnResource):
    decoder_manifest_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of a decoder manifest associated with the vehicle to create.\n')
    model_manifest_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the vehicle model (model manifest) to create the vehicle from.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique ID of the vehicle.\n')
    association_behavior: typing.Optional[str] = pydantic.Field(None, description='(Optional) An option to create a new AWS IoT thing when creating a vehicle, or to validate an existing thing as a vehicle.\n')
    attributes: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='(Optional) Static information about a vehicle in a key-value pair. For example: ``"engine Type"`` : ``"v6"``\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='(Optional) Metadata which can be used to manage the vehicle.')
    _init_params: typing.ClassVar[list[str]] = ['decoder_manifest_arn', 'model_manifest_arn', 'name', 'association_behavior', 'attributes', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnVehicle'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVehicleDefConfig] = pydantic.Field(None)


class CfnVehicleDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnVehicleDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVehicleDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVehicleDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVehicleDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVehicleDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVehicleDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVehicleDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVehicleDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVehicleDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVehicleDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVehicleDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVehicleDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVehicleDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnVehicleDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVehicleDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVehicleDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVehicleDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVehicleDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVehicleDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVehicleDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVehicleDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVehicleDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVehicleDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVehicleDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnVehicleDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVehicleDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVehicleDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_iotfleetwise.CfnCampaignProps
class CfnCampaignPropsDef(BaseCfnProperty):
    action: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='Specifies how to update a campaign. The action can be one of the following:. - ``APPROVE`` - To approve delivering a data collection scheme to vehicles. - ``SUSPEND`` - To suspend collecting signal data. The campaign is deleted from vehicles and all vehicles in the suspended campaign will stop sending data. - ``RESUME`` - To reactivate the ``SUSPEND`` campaign. The campaign is redeployed to all vehicles and the vehicles will resume sending data. - ``UPDATE`` - To update a campaign.\n')
    collection_scheme: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_iotfleetwise.CfnCampaign_CollectionSchemePropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The data collection scheme associated with the campaign. You can specify a scheme that collects data based on time or an event.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of a campaign.\n')
    signal_catalog_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the signal catalog associated with the campaign.\n')
    target_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of a vehicle or fleet to which the campaign is deployed.\n')
    compression: typing.Optional[str] = pydantic.Field(None, description='(Optional) Whether to compress signals before transmitting data to AWS IoT FleetWise . If you don\'t want to compress the signals, use ``OFF`` . If it\'s not specified, ``SNAPPY`` is used. Default: ``SNAPPY`` Default: - "OFF"\n')
    data_destination_configs: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnCampaign_DataDestinationConfigPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='(Optional) The destination where the campaign sends data. You can choose to send data to be stored in Amazon S3 or Amazon Timestream . Amazon S3 optimizes the cost of data storage and provides additional mechanisms to use vehicle data, such as data lakes, centralized data storage, data processing pipelines, and analytics. AWS IoT FleetWise supports at-least-once file delivery to S3. Your vehicle data is stored on multiple AWS IoT FleetWise servers for redundancy and high availability. You can use Amazon Timestream to access and analyze time series data, and Timestream to query vehicle data so that you can identify trends and patterns.\n')
    data_extra_dimensions: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='(Optional) A list of vehicle attributes to associate with a campaign. Enrich the data with specified vehicle attributes. For example, add ``make`` and ``model`` to the campaign, and AWS IoT FleetWise will associate the data with those attributes as dimensions in Amazon Timestream . You can then query the data against ``make`` and ``model`` . Default: An empty array\n')
    description: typing.Optional[str] = pydantic.Field(None, description='(Optional) The description of the campaign.\n')
    diagnostics_mode: typing.Optional[str] = pydantic.Field(None, description='(Optional) Option for a vehicle to send diagnostic trouble codes to AWS IoT FleetWise . If you want to send diagnostic trouble codes, use ``SEND_ACTIVE_DTCS`` . If it\'s not specified, ``OFF`` is used. Default: ``OFF`` Default: - "OFF"\n')
    expiry_time: typing.Optional[str] = pydantic.Field(None, description='(Optional) The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data isn\'t collected after the campaign expires. Default: 253402214400 (December 31, 9999, 00:00:00 UTC) Default: - "253402214400"\n')
    post_trigger_collection_duration: typing.Union[int, float, None] = pydantic.Field(None, description="(Optional) How long (in milliseconds) to collect raw data after a triggering event initiates the collection. If it's not specified, ``0`` is used. Default: ``0`` Default: - 0\n")
    priority: typing.Union[int, float, None] = pydantic.Field(None, description="(Optional) A number indicating the priority of one campaign over another campaign for a certain vehicle or fleet. A campaign with the lowest value is deployed to vehicles before any other campaigns. If it's not specified, ``0`` is used. Default: ``0`` Default: - 0\n")
    signals_to_collect: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnCampaign_SignalInformationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='(Optional) A list of information about signals to collect.\n')
    spooling_mode: typing.Optional[str] = pydantic.Field(None, description='(Optional) Whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to AWS IoT FleetWise . If you want to store collected data when a vehicle loses connection with the cloud, use ``TO_DISK`` . If it\'s not specified, ``OFF`` is used. Default: ``OFF`` Default: - "OFF"\n')
    start_time: typing.Optional[str] = pydantic.Field(None, description='(Optional) The time, in milliseconds, to deliver a campaign after it was approved. If it\'s not specified, ``0`` is used. Default: ``0`` Default: - "0"\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='(Optional) Metadata that can be used to manage the campaign.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iotfleetwise-campaign.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    cfn_campaign_props = iotfleetwise.CfnCampaignProps(\n        action="action",\n        collection_scheme=iotfleetwise.CfnCampaign.CollectionSchemeProperty(\n            condition_based_collection_scheme=iotfleetwise.CfnCampaign.ConditionBasedCollectionSchemeProperty(\n                expression="expression",\n\n                # the properties below are optional\n                condition_language_version=123,\n                minimum_trigger_interval_ms=123,\n                trigger_mode="triggerMode"\n            ),\n            time_based_collection_scheme=iotfleetwise.CfnCampaign.TimeBasedCollectionSchemeProperty(\n                period_ms=123\n            )\n        ),\n        name="name",\n        signal_catalog_arn="signalCatalogArn",\n        target_arn="targetArn",\n\n        # the properties below are optional\n        compression="compression",\n        data_destination_configs=[iotfleetwise.CfnCampaign.DataDestinationConfigProperty(\n            s3_config=iotfleetwise.CfnCampaign.S3ConfigProperty(\n                bucket_arn="bucketArn",\n\n                # the properties below are optional\n                data_format="dataFormat",\n                prefix="prefix",\n                storage_compression_format="storageCompressionFormat"\n            ),\n            timestream_config=iotfleetwise.CfnCampaign.TimestreamConfigProperty(\n                execution_role_arn="executionRoleArn",\n                timestream_table_arn="timestreamTableArn"\n            )\n        )],\n        data_extra_dimensions=["dataExtraDimensions"],\n        description="description",\n        diagnostics_mode="diagnosticsMode",\n        expiry_time="expiryTime",\n        post_trigger_collection_duration=123,\n        priority=123,\n        signals_to_collect=[iotfleetwise.CfnCampaign.SignalInformationProperty(\n            name="name",\n\n            # the properties below are optional\n            max_sample_count=123,\n            minimum_sampling_interval_ms=123\n        )],\n        spooling_mode="spoolingMode",\n        start_time="startTime",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action', 'collection_scheme', 'name', 'signal_catalog_arn', 'target_arn', 'compression', 'data_destination_configs', 'data_extra_dimensions', 'description', 'diagnostics_mode', 'expiry_time', 'post_trigger_collection_duration', 'priority', 'signals_to_collect', 'spooling_mode', 'start_time', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnCampaignProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnDecoderManifestProps
class CfnDecoderManifestPropsDef(BaseCfnProperty):
    model_manifest_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of a vehicle model (model manifest) associated with the decoder manifest.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the decoder manifest.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='(Optional) A brief description of the decoder manifest.\n')
    network_interfaces: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnDecoderManifest_NetworkInterfacesItemsPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='(Optional) A list of information about available network interfaces.\n')
    signal_decoders: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnDecoderManifest_SignalDecodersItemsPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='(Optional) A list of information about signal decoders.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='(Optional) The state of the decoder manifest. If the status is ``ACTIVE`` , the decoder manifest can\'t be edited. If the status is marked ``DRAFT`` , you can edit the decoder manifest. Default: - "DRAFT"\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='(Optional) Metadata that can be used to manage the decoder manifest.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iotfleetwise-decodermanifest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    cfn_decoder_manifest_props = iotfleetwise.CfnDecoderManifestProps(\n        model_manifest_arn="modelManifestArn",\n        name="name",\n\n        # the properties below are optional\n        description="description",\n        network_interfaces=[iotfleetwise.CfnDecoderManifest.NetworkInterfacesItemsProperty(\n            interface_id="interfaceId",\n            type="type",\n\n            # the properties below are optional\n            can_interface=iotfleetwise.CfnDecoderManifest.CanInterfaceProperty(\n                name="name",\n\n                # the properties below are optional\n                protocol_name="protocolName",\n                protocol_version="protocolVersion"\n            ),\n            obd_interface=iotfleetwise.CfnDecoderManifest.ObdInterfaceProperty(\n                name="name",\n                request_message_id="requestMessageId",\n\n                # the properties below are optional\n                dtc_request_interval_seconds="dtcRequestIntervalSeconds",\n                has_transmission_ecu="hasTransmissionEcu",\n                obd_standard="obdStandard",\n                pid_request_interval_seconds="pidRequestIntervalSeconds",\n                use_extended_ids="useExtendedIds"\n            )\n        )],\n        signal_decoders=[iotfleetwise.CfnDecoderManifest.SignalDecodersItemsProperty(\n            fully_qualified_name="fullyQualifiedName",\n            interface_id="interfaceId",\n            type="type",\n\n            # the properties below are optional\n            can_signal=iotfleetwise.CfnDecoderManifest.CanSignalProperty(\n                factor="factor",\n                is_big_endian="isBigEndian",\n                is_signed="isSigned",\n                length="length",\n                message_id="messageId",\n                offset="offset",\n                start_bit="startBit",\n\n                # the properties below are optional\n                name="name"\n            ),\n            obd_signal=iotfleetwise.CfnDecoderManifest.ObdSignalProperty(\n                byte_length="byteLength",\n                offset="offset",\n                pid="pid",\n                pid_response_length="pidResponseLength",\n                scaling="scaling",\n                service_mode="serviceMode",\n                start_byte="startByte",\n\n                # the properties below are optional\n                bit_mask_length="bitMaskLength",\n                bit_right_shift="bitRightShift"\n            )\n        )],\n        status="status",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['model_manifest_arn', 'name', 'description', 'network_interfaces', 'signal_decoders', 'status', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnDecoderManifestProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnFleetProps
class CfnFleetPropsDef(BaseCfnProperty):
    signal_catalog_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the signal catalog associated with the fleet.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='(Optional) A brief description of the fleet.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='(Optional) Metadata that can be used to manage the fleet.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iotfleetwise-fleet.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    cfn_fleet_props = iotfleetwise.CfnFleetProps(\n        id="id",\n        signal_catalog_arn="signalCatalogArn",\n\n        # the properties below are optional\n        description="description",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['signal_catalog_arn', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnFleetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnModelManifestProps
class CfnModelManifestPropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the vehicle model.\n')
    signal_catalog_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the signal catalog associated with the vehicle model.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='(Optional) A brief description of the vehicle model.\n')
    nodes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='(Optional) A list of nodes, which are a general abstraction of signals.\n')
    status: typing.Optional[str] = pydantic.Field(None, description='(Optional) The state of the vehicle model. If the status is ``ACTIVE`` , the vehicle model can\'t be edited. If the status is ``DRAFT`` , you can edit the vehicle model. Default: - "DRAFT"\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='(Optional) Metadata that can be used to manage the vehicle model.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iotfleetwise-modelmanifest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    cfn_model_manifest_props = iotfleetwise.CfnModelManifestProps(\n        name="name",\n        signal_catalog_arn="signalCatalogArn",\n\n        # the properties below are optional\n        description="description",\n        nodes=["nodes"],\n        status="status",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'signal_catalog_arn', 'description', 'nodes', 'status', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnModelManifestProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnSignalCatalogProps
class CfnSignalCatalogPropsDef(BaseCfnProperty):
    description: typing.Optional[str] = pydantic.Field(None, description='(Optional) A brief description of the signal catalog.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='(Optional) The name of the signal catalog.\n')
    node_counts: typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnSignalCatalog_NodeCountsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='(Optional) Information about the number of nodes and node types in a vehicle network.\n')
    nodes: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_iotfleetwise.CfnSignalCatalog_NodePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='(Optional) A list of information about nodes, which are a general abstraction of signals.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='(Optional) Metadata that can be used to manage the signal catalog.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iotfleetwise-signalcatalog.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    cfn_signal_catalog_props = iotfleetwise.CfnSignalCatalogProps(\n        description="description",\n        name="name",\n        node_counts=iotfleetwise.CfnSignalCatalog.NodeCountsProperty(\n            total_actuators=123,\n            total_attributes=123,\n            total_branches=123,\n            total_nodes=123,\n            total_sensors=123\n        ),\n        nodes=[iotfleetwise.CfnSignalCatalog.NodeProperty(\n            actuator=iotfleetwise.CfnSignalCatalog.ActuatorProperty(\n                data_type="dataType",\n                fully_qualified_name="fullyQualifiedName",\n\n                # the properties below are optional\n                allowed_values=["allowedValues"],\n                assigned_value="assignedValue",\n                description="description",\n                max=123,\n                min=123,\n                unit="unit"\n            ),\n            attribute=iotfleetwise.CfnSignalCatalog.AttributeProperty(\n                data_type="dataType",\n                fully_qualified_name="fullyQualifiedName",\n\n                # the properties below are optional\n                allowed_values=["allowedValues"],\n                assigned_value="assignedValue",\n                default_value="defaultValue",\n                description="description",\n                max=123,\n                min=123,\n                unit="unit"\n            ),\n            branch=iotfleetwise.CfnSignalCatalog.BranchProperty(\n                fully_qualified_name="fullyQualifiedName",\n\n                # the properties below are optional\n                description="description"\n            ),\n            sensor=iotfleetwise.CfnSignalCatalog.SensorProperty(\n                data_type="dataType",\n                fully_qualified_name="fullyQualifiedName",\n\n                # the properties below are optional\n                allowed_values=["allowedValues"],\n                description="description",\n                max=123,\n                min=123,\n                unit="unit"\n            )\n        )],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'name', 'node_counts', 'nodes', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnSignalCatalogProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_iotfleetwise.CfnVehicleProps
class CfnVehiclePropsDef(BaseCfnProperty):
    decoder_manifest_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of a decoder manifest associated with the vehicle to create.\n')
    model_manifest_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the vehicle model (model manifest) to create the vehicle from.\n')
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The unique ID of the vehicle.\n')
    association_behavior: typing.Optional[str] = pydantic.Field(None, description='(Optional) An option to create a new AWS IoT thing when creating a vehicle, or to validate an existing thing as a vehicle.\n')
    attributes: typing.Union[models.UnsupportedResource, typing.Mapping[str, str], None] = pydantic.Field(None, description='(Optional) Static information about a vehicle in a key-value pair. For example: ``"engine Type"`` : ``"v6"``\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='(Optional) Metadata which can be used to manage the vehicle.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iotfleetwise-vehicle.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_iotfleetwise as iotfleetwise\n\n    cfn_vehicle_props = iotfleetwise.CfnVehicleProps(\n        decoder_manifest_arn="decoderManifestArn",\n        model_manifest_arn="modelManifestArn",\n        name="name",\n\n        # the properties below are optional\n        association_behavior="associationBehavior",\n        attributes={\n            "attributes_key": "attributes"\n        },\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['decoder_manifest_arn', 'model_manifest_arn', 'name', 'association_behavior', 'attributes', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_iotfleetwise.CfnVehicleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    CfnCampaign_CollectionSchemeProperty: typing.Optional[dict[str, CfnCampaign_CollectionSchemePropertyDef]] = pydantic.Field(None)
    CfnCampaign_ConditionBasedCollectionSchemeProperty: typing.Optional[dict[str, CfnCampaign_ConditionBasedCollectionSchemePropertyDef]] = pydantic.Field(None)
    CfnCampaign_DataDestinationConfigProperty: typing.Optional[dict[str, CfnCampaign_DataDestinationConfigPropertyDef]] = pydantic.Field(None)
    CfnCampaign_S3ConfigProperty: typing.Optional[dict[str, CfnCampaign_S3ConfigPropertyDef]] = pydantic.Field(None)
    CfnCampaign_SignalInformationProperty: typing.Optional[dict[str, CfnCampaign_SignalInformationPropertyDef]] = pydantic.Field(None)
    CfnCampaign_TimeBasedCollectionSchemeProperty: typing.Optional[dict[str, CfnCampaign_TimeBasedCollectionSchemePropertyDef]] = pydantic.Field(None)
    CfnCampaign_TimestreamConfigProperty: typing.Optional[dict[str, CfnCampaign_TimestreamConfigPropertyDef]] = pydantic.Field(None)
    CfnDecoderManifest_CanInterfaceProperty: typing.Optional[dict[str, CfnDecoderManifest_CanInterfacePropertyDef]] = pydantic.Field(None)
    CfnDecoderManifest_CanNetworkInterfaceProperty: typing.Optional[dict[str, CfnDecoderManifest_CanNetworkInterfacePropertyDef]] = pydantic.Field(None)
    CfnDecoderManifest_CanSignalDecoderProperty: typing.Optional[dict[str, CfnDecoderManifest_CanSignalDecoderPropertyDef]] = pydantic.Field(None)
    CfnDecoderManifest_CanSignalProperty: typing.Optional[dict[str, CfnDecoderManifest_CanSignalPropertyDef]] = pydantic.Field(None)
    CfnDecoderManifest_NetworkInterfacesItemsProperty: typing.Optional[dict[str, CfnDecoderManifest_NetworkInterfacesItemsPropertyDef]] = pydantic.Field(None)
    CfnDecoderManifest_ObdInterfaceProperty: typing.Optional[dict[str, CfnDecoderManifest_ObdInterfacePropertyDef]] = pydantic.Field(None)
    CfnDecoderManifest_ObdNetworkInterfaceProperty: typing.Optional[dict[str, CfnDecoderManifest_ObdNetworkInterfacePropertyDef]] = pydantic.Field(None)
    CfnDecoderManifest_ObdSignalDecoderProperty: typing.Optional[dict[str, CfnDecoderManifest_ObdSignalDecoderPropertyDef]] = pydantic.Field(None)
    CfnDecoderManifest_ObdSignalProperty: typing.Optional[dict[str, CfnDecoderManifest_ObdSignalPropertyDef]] = pydantic.Field(None)
    CfnDecoderManifest_SignalDecodersItemsProperty: typing.Optional[dict[str, CfnDecoderManifest_SignalDecodersItemsPropertyDef]] = pydantic.Field(None)
    CfnSignalCatalog_ActuatorProperty: typing.Optional[dict[str, CfnSignalCatalog_ActuatorPropertyDef]] = pydantic.Field(None)
    CfnSignalCatalog_AttributeProperty: typing.Optional[dict[str, CfnSignalCatalog_AttributePropertyDef]] = pydantic.Field(None)
    CfnSignalCatalog_BranchProperty: typing.Optional[dict[str, CfnSignalCatalog_BranchPropertyDef]] = pydantic.Field(None)
    CfnSignalCatalog_NodeCountsProperty: typing.Optional[dict[str, CfnSignalCatalog_NodeCountsPropertyDef]] = pydantic.Field(None)
    CfnSignalCatalog_NodeProperty: typing.Optional[dict[str, CfnSignalCatalog_NodePropertyDef]] = pydantic.Field(None)
    CfnSignalCatalog_SensorProperty: typing.Optional[dict[str, CfnSignalCatalog_SensorPropertyDef]] = pydantic.Field(None)
    CfnCampaign: typing.Optional[dict[str, CfnCampaignDef]] = pydantic.Field(None)
    CfnDecoderManifest: typing.Optional[dict[str, CfnDecoderManifestDef]] = pydantic.Field(None)
    CfnFleet: typing.Optional[dict[str, CfnFleetDef]] = pydantic.Field(None)
    CfnModelManifest: typing.Optional[dict[str, CfnModelManifestDef]] = pydantic.Field(None)
    CfnSignalCatalog: typing.Optional[dict[str, CfnSignalCatalogDef]] = pydantic.Field(None)
    CfnVehicle: typing.Optional[dict[str, CfnVehicleDef]] = pydantic.Field(None)
    CfnCampaignProps: typing.Optional[dict[str, CfnCampaignPropsDef]] = pydantic.Field(None)
    CfnDecoderManifestProps: typing.Optional[dict[str, CfnDecoderManifestPropsDef]] = pydantic.Field(None)
    CfnFleetProps: typing.Optional[dict[str, CfnFleetPropsDef]] = pydantic.Field(None)
    CfnModelManifestProps: typing.Optional[dict[str, CfnModelManifestPropsDef]] = pydantic.Field(None)
    CfnSignalCatalogProps: typing.Optional[dict[str, CfnSignalCatalogPropsDef]] = pydantic.Field(None)
    CfnVehicleProps: typing.Optional[dict[str, CfnVehiclePropsDef]] = pydantic.Field(None)
    ...
