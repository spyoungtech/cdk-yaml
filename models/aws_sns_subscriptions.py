from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_sns_subscriptions.EmailSubscription
class EmailSubscriptionDef(BaseClass):
    email_address: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='-')
    json_: typing.Optional[bool] = pydantic.Field(None, description='Indicates if the full notification JSON should be sent to the email address or just the message text. Default: false (Message text)\n', alias='json')
    dead_letter_queue: typing.Optional[typing.Union[models.aws_sqs.QueueBaseDef, models.aws_sqs.QueueDef]] = pydantic.Field(None, description='Queue to be used as dead letter queue. If not passed no dead letter queue is enabled. Default: - No dead letter queue enabled.\n')
    filter_policy: typing.Optional[typing.Mapping[str, models.aws_sns.SubscriptionFilterDef]] = pydantic.Field(None, description='The filter policy. Default: - all messages are delivered\n')
    filter_policy_with_message_body: typing.Optional[typing.Mapping[str, models.aws_sns.FilterOrPolicyDef]] = pydantic.Field(None, description='The filter policy that is applied on the message body. To apply a filter policy to the message attributes, use ``filterPolicy``. A maximum of one of ``filterPolicyWithMessageBody`` and ``filterPolicy`` may be used. Default: - all messages are delivered')
    _init_params: typing.ClassVar[list[str]] = ['email_address', 'json', 'dead_letter_queue', 'filter_policy', 'filter_policy_with_message_body']
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_sns_subscriptions.EmailSubscription'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_sns_subscriptions.EmailSubscriptionDefConfig] = pydantic.Field(None)


class EmailSubscriptionDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[models.aws_sns_subscriptions.EmailSubscriptionDefBindParams]] = pydantic.Field(None, description='Returns a configuration for an email address to subscribe to an SNS topic.')

class EmailSubscriptionDefBindParams(pydantic.BaseModel):
    ...


#  autogenerated from aws_cdk.aws_sns_subscriptions.LambdaSubscription
class LambdaSubscriptionDef(BaseClass):
    fn: typing.Union[_REQUIRED_INIT_PARAM, models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='-')
    dead_letter_queue: typing.Optional[typing.Union[models.aws_sqs.QueueBaseDef, models.aws_sqs.QueueDef]] = pydantic.Field(None, description='Queue to be used as dead letter queue. If not passed no dead letter queue is enabled. Default: - No dead letter queue enabled.\n')
    filter_policy: typing.Optional[typing.Mapping[str, models.aws_sns.SubscriptionFilterDef]] = pydantic.Field(None, description='The filter policy. Default: - all messages are delivered\n')
    filter_policy_with_message_body: typing.Optional[typing.Mapping[str, models.aws_sns.FilterOrPolicyDef]] = pydantic.Field(None, description='The filter policy that is applied on the message body. To apply a filter policy to the message attributes, use ``filterPolicy``. A maximum of one of ``filterPolicyWithMessageBody`` and ``filterPolicy`` may be used. Default: - all messages are delivered')
    _init_params: typing.ClassVar[list[str]] = ['fn', 'dead_letter_queue', 'filter_policy', 'filter_policy_with_message_body']
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_sns_subscriptions.LambdaSubscription'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_sns_subscriptions.LambdaSubscriptionDefConfig] = pydantic.Field(None)


class LambdaSubscriptionDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[models.aws_sns_subscriptions.LambdaSubscriptionDefBindParams]] = pydantic.Field(None, description='Returns a configuration for a Lambda function to subscribe to an SNS topic.')

class LambdaSubscriptionDefBindParams(pydantic.BaseModel):
    topic: typing.Union[models.aws_sns.TopicBaseDef, models.aws_sns.TopicDef] = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_sns_subscriptions.SmsSubscription
class SmsSubscriptionDef(BaseClass):
    phone_number: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='-')
    dead_letter_queue: typing.Optional[typing.Union[models.aws_sqs.QueueBaseDef, models.aws_sqs.QueueDef]] = pydantic.Field(None, description='Queue to be used as dead letter queue. If not passed no dead letter queue is enabled. Default: - No dead letter queue enabled.\n')
    filter_policy: typing.Optional[typing.Mapping[str, models.aws_sns.SubscriptionFilterDef]] = pydantic.Field(None, description='The filter policy. Default: - all messages are delivered\n')
    filter_policy_with_message_body: typing.Optional[typing.Mapping[str, models.aws_sns.FilterOrPolicyDef]] = pydantic.Field(None, description='The filter policy that is applied on the message body. To apply a filter policy to the message attributes, use ``filterPolicy``. A maximum of one of ``filterPolicyWithMessageBody`` and ``filterPolicy`` may be used. Default: - all messages are delivered')
    _init_params: typing.ClassVar[list[str]] = ['phone_number', 'dead_letter_queue', 'filter_policy', 'filter_policy_with_message_body']
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_sns_subscriptions.SmsSubscription'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_sns_subscriptions.SmsSubscriptionDefConfig] = pydantic.Field(None)


class SmsSubscriptionDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[models.aws_sns_subscriptions.SmsSubscriptionDefBindParams]] = pydantic.Field(None, description='Returns a configuration used to subscribe to an SNS topic.')

class SmsSubscriptionDefBindParams(pydantic.BaseModel):
    ...


#  autogenerated from aws_cdk.aws_sns_subscriptions.SqsSubscription
class SqsSubscriptionDef(BaseClass):
    queue: typing.Union[_REQUIRED_INIT_PARAM, models.aws_sqs.QueueBaseDef, models.aws_sqs.QueueDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='-')
    raw_message_delivery: typing.Optional[bool] = pydantic.Field(None, description='The message to the queue is the same as it was sent to the topic. If false, the message will be wrapped in an SNS envelope. Default: false\n')
    dead_letter_queue: typing.Optional[typing.Union[models.aws_sqs.QueueBaseDef, models.aws_sqs.QueueDef]] = pydantic.Field(None, description='Queue to be used as dead letter queue. If not passed no dead letter queue is enabled. Default: - No dead letter queue enabled.\n')
    filter_policy: typing.Optional[typing.Mapping[str, models.aws_sns.SubscriptionFilterDef]] = pydantic.Field(None, description='The filter policy. Default: - all messages are delivered\n')
    filter_policy_with_message_body: typing.Optional[typing.Mapping[str, models.aws_sns.FilterOrPolicyDef]] = pydantic.Field(None, description='The filter policy that is applied on the message body. To apply a filter policy to the message attributes, use ``filterPolicy``. A maximum of one of ``filterPolicyWithMessageBody`` and ``filterPolicy`` may be used. Default: - all messages are delivered')
    _init_params: typing.ClassVar[list[str]] = ['queue', 'raw_message_delivery', 'dead_letter_queue', 'filter_policy', 'filter_policy_with_message_body']
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_sns_subscriptions.SqsSubscription'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_sns_subscriptions.SqsSubscriptionDefConfig] = pydantic.Field(None)


class SqsSubscriptionDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[models.aws_sns_subscriptions.SqsSubscriptionDefBindParams]] = pydantic.Field(None, description='Returns a configuration for an SQS queue to subscribe to an SNS topic.')

class SqsSubscriptionDefBindParams(pydantic.BaseModel):
    topic: typing.Union[models.aws_sns.TopicBaseDef, models.aws_sns.TopicDef] = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_sns_subscriptions.UrlSubscription
class UrlSubscriptionDef(BaseClass):
    url: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='-')
    protocol: typing.Optional[aws_cdk.aws_sns.SubscriptionProtocol] = pydantic.Field(None, description="The subscription's protocol. Default: - Protocol is derived from url\n")
    raw_message_delivery: typing.Optional[bool] = pydantic.Field(None, description='The message to the queue is the same as it was sent to the topic. If false, the message will be wrapped in an SNS envelope. Default: false\n')
    dead_letter_queue: typing.Optional[typing.Union[models.aws_sqs.QueueBaseDef, models.aws_sqs.QueueDef]] = pydantic.Field(None, description='Queue to be used as dead letter queue. If not passed no dead letter queue is enabled. Default: - No dead letter queue enabled.\n')
    filter_policy: typing.Optional[typing.Mapping[str, models.aws_sns.SubscriptionFilterDef]] = pydantic.Field(None, description='The filter policy. Default: - all messages are delivered\n')
    filter_policy_with_message_body: typing.Optional[typing.Mapping[str, models.aws_sns.FilterOrPolicyDef]] = pydantic.Field(None, description='The filter policy that is applied on the message body. To apply a filter policy to the message attributes, use ``filterPolicy``. A maximum of one of ``filterPolicyWithMessageBody`` and ``filterPolicy`` may be used. Default: - all messages are delivered')
    _init_params: typing.ClassVar[list[str]] = ['url', 'protocol', 'raw_message_delivery', 'dead_letter_queue', 'filter_policy', 'filter_policy_with_message_body']
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_sns_subscriptions.UrlSubscription'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_sns_subscriptions.UrlSubscriptionDefConfig] = pydantic.Field(None)


class UrlSubscriptionDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[models.aws_sns_subscriptions.UrlSubscriptionDefBindParams]] = pydantic.Field(None, description='Returns a configuration for a URL to subscribe to an SNS topic.')

class UrlSubscriptionDefBindParams(pydantic.BaseModel):
    ...


#  autogenerated from aws_cdk.aws_sns_subscriptions.EmailSubscriptionProps
class EmailSubscriptionPropsDef(BaseStruct):
    dead_letter_queue: typing.Optional[typing.Union[models.aws_sqs.QueueBaseDef, models.aws_sqs.QueueDef]] = pydantic.Field(None, description='Queue to be used as dead letter queue. If not passed no dead letter queue is enabled. Default: - No dead letter queue enabled.\n')
    filter_policy: typing.Optional[typing.Mapping[str, models.aws_sns.SubscriptionFilterDef]] = pydantic.Field(None, description='The filter policy. Default: - all messages are delivered\n')
    filter_policy_with_message_body: typing.Optional[typing.Mapping[str, models.aws_sns.FilterOrPolicyDef]] = pydantic.Field(None, description='The filter policy that is applied on the message body. To apply a filter policy to the message attributes, use ``filterPolicy``. A maximum of one of ``filterPolicyWithMessageBody`` and ``filterPolicy`` may be used. Default: - all messages are delivered\n')
    json_: typing.Optional[bool] = pydantic.Field(None, description='Indicates if the full notification JSON should be sent to the email address or just the message text. Default: false (Message text)\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_sns as sns\n    from aws_cdk import aws_sns_subscriptions as sns_subscriptions\n    from aws_cdk import aws_sqs as sqs\n\n    # filter_or_policy: sns.FilterOrPolicy\n    # queue: sqs.Queue\n    # subscription_filter: sns.SubscriptionFilter\n\n    email_subscription_props = sns_subscriptions.EmailSubscriptionProps(\n        dead_letter_queue=queue,\n        filter_policy={\n            "filter_policy_key": subscription_filter\n        },\n        filter_policy_with_message_body={\n            "filter_policy_with_message_body_key": filter_or_policy\n        },\n        json=False\n    )\n', alias='json')
    _init_params: typing.ClassVar[list[str]] = ['dead_letter_queue', 'filter_policy', 'filter_policy_with_message_body', 'json']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_sns_subscriptions.EmailSubscriptionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_sns_subscriptions.LambdaSubscriptionProps
class LambdaSubscriptionPropsDef(BaseStruct):
    dead_letter_queue: typing.Optional[typing.Union[models.aws_sqs.QueueBaseDef, models.aws_sqs.QueueDef]] = pydantic.Field(None, description='Queue to be used as dead letter queue. If not passed no dead letter queue is enabled. Default: - No dead letter queue enabled.\n')
    filter_policy: typing.Optional[typing.Mapping[str, models.aws_sns.SubscriptionFilterDef]] = pydantic.Field(None, description='The filter policy. Default: - all messages are delivered\n')
    filter_policy_with_message_body: typing.Optional[typing.Mapping[str, models.aws_sns.FilterOrPolicyDef]] = pydantic.Field(None, description='The filter policy that is applied on the message body. To apply a filter policy to the message attributes, use ``filterPolicy``. A maximum of one of ``filterPolicyWithMessageBody`` and ``filterPolicy`` may be used. Default: - all messages are delivered\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_lambda as lambda_\n    # fn: lambda.Function\n\n\n    my_topic = sns.Topic(self, "MyTopic")\n\n    # Lambda should receive only message matching the following conditions on attributes:\n    # color: \'red\' or \'orange\' or begins with \'bl\'\n    # size: anything but \'small\' or \'medium\'\n    # price: between 100 and 200 or greater than 300\n    # store: attribute must be present\n    my_topic.add_subscription(subscriptions.LambdaSubscription(fn,\n        filter_policy={\n            "color": sns.SubscriptionFilter.string_filter(\n                allowlist=["red", "orange"],\n                match_prefixes=["bl"]\n            ),\n            "size": sns.SubscriptionFilter.string_filter(\n                denylist=["small", "medium"]\n            ),\n            "price": sns.SubscriptionFilter.numeric_filter(\n                between=sns.BetweenCondition(start=100, stop=200),\n                greater_than=300\n            ),\n            "store": sns.SubscriptionFilter.exists_filter()\n        }\n    ))\n')
    _init_params: typing.ClassVar[list[str]] = ['dead_letter_queue', 'filter_policy', 'filter_policy_with_message_body']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_sns_subscriptions.LambdaSubscriptionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_sns_subscriptions.SmsSubscriptionProps
class SmsSubscriptionPropsDef(BaseStruct):
    dead_letter_queue: typing.Optional[typing.Union[models.aws_sqs.QueueBaseDef, models.aws_sqs.QueueDef]] = pydantic.Field(None, description='Queue to be used as dead letter queue. If not passed no dead letter queue is enabled. Default: - No dead letter queue enabled.\n')
    filter_policy: typing.Optional[typing.Mapping[str, models.aws_sns.SubscriptionFilterDef]] = pydantic.Field(None, description='The filter policy. Default: - all messages are delivered\n')
    filter_policy_with_message_body: typing.Optional[typing.Mapping[str, models.aws_sns.FilterOrPolicyDef]] = pydantic.Field(None, description='The filter policy that is applied on the message body. To apply a filter policy to the message attributes, use ``filterPolicy``. A maximum of one of ``filterPolicyWithMessageBody`` and ``filterPolicy`` may be used. Default: - all messages are delivered\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_sns as sns\n    from aws_cdk import aws_sns_subscriptions as sns_subscriptions\n    from aws_cdk import aws_sqs as sqs\n\n    # filter_or_policy: sns.FilterOrPolicy\n    # queue: sqs.Queue\n    # subscription_filter: sns.SubscriptionFilter\n\n    sms_subscription_props = sns_subscriptions.SmsSubscriptionProps(\n        dead_letter_queue=queue,\n        filter_policy={\n            "filter_policy_key": subscription_filter\n        },\n        filter_policy_with_message_body={\n            "filter_policy_with_message_body_key": filter_or_policy\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['dead_letter_queue', 'filter_policy', 'filter_policy_with_message_body']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_sns_subscriptions.SmsSubscriptionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_sns_subscriptions.SqsSubscriptionProps
class SqsSubscriptionPropsDef(BaseStruct):
    dead_letter_queue: typing.Optional[typing.Union[models.aws_sqs.QueueBaseDef, models.aws_sqs.QueueDef]] = pydantic.Field(None, description='Queue to be used as dead letter queue. If not passed no dead letter queue is enabled. Default: - No dead letter queue enabled.\n')
    filter_policy: typing.Optional[typing.Mapping[str, models.aws_sns.SubscriptionFilterDef]] = pydantic.Field(None, description='The filter policy. Default: - all messages are delivered\n')
    filter_policy_with_message_body: typing.Optional[typing.Mapping[str, models.aws_sns.FilterOrPolicyDef]] = pydantic.Field(None, description='The filter policy that is applied on the message body. To apply a filter policy to the message attributes, use ``filterPolicy``. A maximum of one of ``filterPolicyWithMessageBody`` and ``filterPolicy`` may be used. Default: - all messages are delivered\n')
    raw_message_delivery: typing.Optional[bool] = pydantic.Field(None, description='The message to the queue is the same as it was sent to the topic. If false, the message will be wrapped in an SNS envelope. Default: false\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_sns as sns\n    from aws_cdk import aws_sns_subscriptions as sns_subscriptions\n    from aws_cdk import aws_sqs as sqs\n\n    # filter_or_policy: sns.FilterOrPolicy\n    # queue: sqs.Queue\n    # subscription_filter: sns.SubscriptionFilter\n\n    sqs_subscription_props = sns_subscriptions.SqsSubscriptionProps(\n        dead_letter_queue=queue,\n        filter_policy={\n            "filter_policy_key": subscription_filter\n        },\n        filter_policy_with_message_body={\n            "filter_policy_with_message_body_key": filter_or_policy\n        },\n        raw_message_delivery=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['dead_letter_queue', 'filter_policy', 'filter_policy_with_message_body', 'raw_message_delivery']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_sns_subscriptions.SqsSubscriptionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_sns_subscriptions.SubscriptionProps
class SubscriptionPropsDef(BaseStruct):
    dead_letter_queue: typing.Optional[typing.Union[models.aws_sqs.QueueBaseDef, models.aws_sqs.QueueDef]] = pydantic.Field(None, description='Queue to be used as dead letter queue. If not passed no dead letter queue is enabled. Default: - No dead letter queue enabled.\n')
    filter_policy: typing.Optional[typing.Mapping[str, models.aws_sns.SubscriptionFilterDef]] = pydantic.Field(None, description='The filter policy. Default: - all messages are delivered\n')
    filter_policy_with_message_body: typing.Optional[typing.Mapping[str, models.aws_sns.FilterOrPolicyDef]] = pydantic.Field(None, description='The filter policy that is applied on the message body. To apply a filter policy to the message attributes, use ``filterPolicy``. A maximum of one of ``filterPolicyWithMessageBody`` and ``filterPolicy`` may be used. Default: - all messages are delivered\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_sns as sns\n    from aws_cdk import aws_sns_subscriptions as sns_subscriptions\n    from aws_cdk import aws_sqs as sqs\n\n    # filter_or_policy: sns.FilterOrPolicy\n    # queue: sqs.Queue\n    # subscription_filter: sns.SubscriptionFilter\n\n    subscription_props = sns_subscriptions.SubscriptionProps(\n        dead_letter_queue=queue,\n        filter_policy={\n            "filter_policy_key": subscription_filter\n        },\n        filter_policy_with_message_body={\n            "filter_policy_with_message_body_key": filter_or_policy\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['dead_letter_queue', 'filter_policy', 'filter_policy_with_message_body']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_sns_subscriptions.SubscriptionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_sns_subscriptions.UrlSubscriptionProps
class UrlSubscriptionPropsDef(BaseStruct):
    dead_letter_queue: typing.Optional[typing.Union[models.aws_sqs.QueueBaseDef, models.aws_sqs.QueueDef]] = pydantic.Field(None, description='Queue to be used as dead letter queue. If not passed no dead letter queue is enabled. Default: - No dead letter queue enabled.\n')
    filter_policy: typing.Optional[typing.Mapping[str, models.aws_sns.SubscriptionFilterDef]] = pydantic.Field(None, description='The filter policy. Default: - all messages are delivered\n')
    filter_policy_with_message_body: typing.Optional[typing.Mapping[str, models.aws_sns.FilterOrPolicyDef]] = pydantic.Field(None, description='The filter policy that is applied on the message body. To apply a filter policy to the message attributes, use ``filterPolicy``. A maximum of one of ``filterPolicyWithMessageBody`` and ``filterPolicy`` may be used. Default: - all messages are delivered\n')
    protocol: typing.Optional[aws_cdk.aws_sns.SubscriptionProtocol] = pydantic.Field(None, description="The subscription's protocol. Default: - Protocol is derived from url\n")
    raw_message_delivery: typing.Optional[bool] = pydantic.Field(None, description='The message to the queue is the same as it was sent to the topic. If false, the message will be wrapped in an SNS envelope. Default: false\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_sns as sns\n    from aws_cdk import aws_sns_subscriptions as sns_subscriptions\n    from aws_cdk import aws_sqs as sqs\n\n    # filter_or_policy: sns.FilterOrPolicy\n    # queue: sqs.Queue\n    # subscription_filter: sns.SubscriptionFilter\n\n    url_subscription_props = sns_subscriptions.UrlSubscriptionProps(\n        dead_letter_queue=queue,\n        filter_policy={\n            "filter_policy_key": subscription_filter\n        },\n        filter_policy_with_message_body={\n            "filter_policy_with_message_body_key": filter_or_policy\n        },\n        protocol=sns.SubscriptionProtocol.HTTP,\n        raw_message_delivery=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['dead_letter_queue', 'filter_policy', 'filter_policy_with_message_body', 'protocol', 'raw_message_delivery']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_sns_subscriptions.UrlSubscriptionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    EmailSubscription: typing.Optional[dict[str, models.aws_sns_subscriptions.EmailSubscriptionDef]] = pydantic.Field(None)
    LambdaSubscription: typing.Optional[dict[str, models.aws_sns_subscriptions.LambdaSubscriptionDef]] = pydantic.Field(None)
    SmsSubscription: typing.Optional[dict[str, models.aws_sns_subscriptions.SmsSubscriptionDef]] = pydantic.Field(None)
    SqsSubscription: typing.Optional[dict[str, models.aws_sns_subscriptions.SqsSubscriptionDef]] = pydantic.Field(None)
    UrlSubscription: typing.Optional[dict[str, models.aws_sns_subscriptions.UrlSubscriptionDef]] = pydantic.Field(None)
    EmailSubscriptionProps: typing.Optional[dict[str, models.aws_sns_subscriptions.EmailSubscriptionPropsDef]] = pydantic.Field(None)
    LambdaSubscriptionProps: typing.Optional[dict[str, models.aws_sns_subscriptions.LambdaSubscriptionPropsDef]] = pydantic.Field(None)
    SmsSubscriptionProps: typing.Optional[dict[str, models.aws_sns_subscriptions.SmsSubscriptionPropsDef]] = pydantic.Field(None)
    SqsSubscriptionProps: typing.Optional[dict[str, models.aws_sns_subscriptions.SqsSubscriptionPropsDef]] = pydantic.Field(None)
    SubscriptionProps: typing.Optional[dict[str, models.aws_sns_subscriptions.SubscriptionPropsDef]] = pydantic.Field(None)
    UrlSubscriptionProps: typing.Optional[dict[str, models.aws_sns_subscriptions.UrlSubscriptionPropsDef]] = pydantic.Field(None)
    ...

import models
