from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.custom_resources.AwsCustomResourcePolicy
class AwsCustomResourcePolicyDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_sdk_calls', 'from_statements']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.custom_resources.AwsCustomResourcePolicy'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_sdk_calls', 'from_statements']
    ...


    from_sdk_calls: typing.Optional[models.custom_resources.AwsCustomResourcePolicyDefFromSdkCallsParams] = pydantic.Field(None, description="Generate IAM Policy Statements from the configured SDK calls.\nEach SDK call with be translated to an IAM Policy Statement in the form of: ``call.service:call.action`` (e.g ``s3:PutObject``).\n\nThis policy generator assumes the IAM policy name has the same name as the API\ncall. This is true in 99% of cases, but there are exceptions (for example,\nS3's ``PutBucketLifecycleConfiguration`` requires\n``s3:PutLifecycleConfiguration`` permissions, Lambda's ``Invoke`` requires\n``lambda:InvokeFunction`` permissions). Use ``fromStatements`` if you want to\ndo a call that requires different IAM action names.")
    from_statements: typing.Optional[models.custom_resources.AwsCustomResourcePolicyDefFromStatementsParams] = pydantic.Field(None, description='Explicit IAM Policy Statements.')

class AwsCustomResourcePolicyDefFromSdkCallsParams(pydantic.BaseModel):
    resources: typing.Sequence[str] = pydantic.Field(..., description="The resources that the calls will have access to. It is best to use specific resource ARN's when possible. However, you can also use ``AwsCustomResourcePolicy.ANY_RESOURCE`` to allow access to all resources. For example, when ``onCreate`` is used to create a resource which you don't know the physical name of in advance. Note that will apply to ALL SDK calls.")
    ...

class AwsCustomResourcePolicyDefFromStatementsParams(pydantic.BaseModel):
    statements: typing.Sequence[models.aws_iam.PolicyStatementDef] = pydantic.Field(..., description='the statements to propagate to the SDK calls.')
    ...


#  autogenerated from aws_cdk.custom_resources.Logging
class LoggingDef(BaseClass):
    log_api_response_data: typing.Optional[bool] = pydantic.Field(None, description='Whether or not to log data associated with the API call response. Default: true')
    _init_params: typing.ClassVar[list[str]] = ['log_api_response_data']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['all', 'with_data_hidden']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.custom_resources.Logging'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.custom_resources.LoggingDefConfig] = pydantic.Field(None)


class LoggingDefConfig(pydantic.BaseModel):
    all: typing.Optional[list[models.custom_resources.LoggingDefAllParams]] = pydantic.Field(None, description='Enables logging of all logged data in the lambda handler.\nThis includes the event object, the API call response, all fields in the response object\nreturned by the lambda, and any errors encountered.')
    with_data_hidden: typing.Optional[list[models.custom_resources.LoggingDefWithDataHiddenParams]] = pydantic.Field(None, description='Hides logging of data associated with the API call response.\nThis includes hiding the raw API\ncall response and the ``Data`` field associated with the lambda handler response.')

class LoggingDefAllParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.custom_resources.LoggingDefConfig]] = pydantic.Field(None)
    ...

class LoggingDefWithDataHiddenParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.custom_resources.LoggingDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.custom_resources.PhysicalResourceId
class PhysicalResourceIdDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_response', 'of']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.custom_resources.PhysicalResourceId'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_response']
    ...


    from_response: typing.Optional[models.custom_resources.PhysicalResourceIdDefFromResponseParams] = pydantic.Field(None, description='Extract the physical resource id from the path (dot notation) to the data in the API call response.')
    resource_config: typing.Optional[models.custom_resources.PhysicalResourceIdDefConfig] = pydantic.Field(None)


class PhysicalResourceIdDefConfig(pydantic.BaseModel):
    of: typing.Optional[list[models.custom_resources.PhysicalResourceIdDefOfParams]] = pydantic.Field(None, description='Explicit physical resource id.')

class PhysicalResourceIdDefFromResponseParams(pydantic.BaseModel):
    response_path: str = pydantic.Field(..., description='-')
    ...

class PhysicalResourceIdDefOfParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.custom_resources.PhysicalResourceIdDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.custom_resources.PhysicalResourceIdReference
class PhysicalResourceIdReferenceDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['resolve']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.custom_resources.PhysicalResourceIdReference'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.custom_resources.PhysicalResourceIdReferenceDefConfig] = pydantic.Field(None)


class PhysicalResourceIdReferenceDefConfig(pydantic.BaseModel):
    resolve: typing.Optional[bool] = pydantic.Field(None, description="Produce the Token's value at resolution time.")


#  autogenerated from aws_cdk.custom_resources.AwsCustomResource
class AwsCustomResourceDef(BaseConstruct):
    function_name: typing.Optional[str] = pydantic.Field(None, description="A name for the singleton Lambda function implementing this custom resource. The function name will remain the same after the first AwsCustomResource is created in a stack. Default: - AWS CloudFormation generates a unique physical ID and uses that ID for the function's name. For more information, see Name Type.\n")
    install_latest_aws_sdk: typing.Optional[bool] = pydantic.Field(None, description="Whether to install the latest AWS SDK v2. If not specified, this uses whatever JavaScript SDK version is the default in AWS Lambda at the time of execution. Otherwise, installs the latest version from 'npmjs.com'. The installation takes around 60 seconds and requires internet connectivity. The default can be controlled using the context key ``@aws-cdk/customresources:installLatestAwsSdkDefault`` is. Default: - The value of ``@aws-cdk/customresources:installLatestAwsSdkDefault``, otherwise ``true``\n")
    log_group: typing.Optional[typing.Union[models.aws_logs.LogGroupDef]] = pydantic.Field(None, description="The Log Group used for logging of events emitted by the custom resource's lambda function. Providing a user-controlled log group was rolled out to commercial regions on 2023-11-16. If you are deploying to another type of region, please check regional availability first. Default: - a default log group created by AWS Lambda\n")
    log_retention: typing.Optional[aws_cdk.aws_logs.RetentionDays] = pydantic.Field(None, description='The number of days log events of the singleton Lambda function implementing this custom resource are kept in CloudWatch Logs. This is a legacy API and we strongly recommend you migrate to ``logGroup`` if you can. ``logGroup`` allows you to create a fully customizable log group and instruct the Lambda function to send logs to it. Default: logs.RetentionDays.INFINITE\n')
    memory_size: typing.Union[int, float, None] = pydantic.Field(None, description='The memory size for the singleton Lambda function implementing this custom resource. Default: 512 mega in case if installLatestAwsSdk is false.\n')
    on_create: typing.Union[models.custom_resources.AwsSdkCallDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The AWS SDK call to make when the resource is created. Default: - the call when the resource is updated\n')
    on_delete: typing.Union[models.custom_resources.AwsSdkCallDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The AWS SDK call to make when the resource is deleted. Default: - no call\n')
    on_update: typing.Union[models.custom_resources.AwsSdkCallDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The AWS SDK call to make when the resource is updated. Default: - no call\n')
    policy: typing.Optional[models.custom_resources.AwsCustomResourcePolicyDef] = pydantic.Field(None, description="The policy that will be added to the execution role of the Lambda function implementing this custom resource provider. The custom resource also implements ``iam.IGrantable``, making it possible to use the ``grantXxx()`` methods. As this custom resource uses a singleton Lambda function, it's important to note the that function's role will eventually accumulate the permissions/grants from all resources. Note that a policy must be specified if ``role`` is not provided, as by default a new role is created which requires policy changes to access resources. Default: - no policy added\n")
    removal_policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='The policy to apply when this resource is removed from the application. Default: cdk.RemovalPolicy.Destroy\n')
    resource_type: typing.Optional[str] = pydantic.Field(None, description='Cloudformation Resource type. Default: - Custom::AWS\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The execution role for the singleton Lambda function implementing this custom resource provider. This role will apply to all ``AwsCustomResource`` instances in the stack. The role must be assumable by the ``lambda.amazonaws.com`` service principal. Default: - a new role is created\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The timeout for the singleton Lambda function implementing this custom resource. Default: Duration.minutes(2)\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The vpc to provision the lambda function in. Default: - the function is not provisioned inside a vpc.\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Which subnets from the VPC to place the lambda function in. Only used if 'vpc' is supplied. Note: internet access for Lambdas requires a NAT gateway, so picking Public subnets is not allowed. Default: - the Vpc default strategy if not specified")
    _init_params: typing.ClassVar[list[str]] = ['function_name', 'install_latest_aws_sdk', 'log_group', 'log_retention', 'memory_size', 'on_create', 'on_delete', 'on_update', 'policy', 'removal_policy', 'resource_type', 'role', 'timeout', 'vpc', 'vpc_subnets']
    _method_names: typing.ClassVar[list[str]] = ['get_response_field', 'get_response_field_reference']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.custom_resources.AwsCustomResource'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.custom_resources.AwsCustomResourceDefConfig] = pydantic.Field(None)


class AwsCustomResourceDefConfig(pydantic.BaseModel):
    get_response_field: typing.Optional[list[models.custom_resources.AwsCustomResourceDefGetResponseFieldParams]] = pydantic.Field(None, description="Returns response data for the AWS SDK call as string.\nExample for S3 / listBucket : 'Buckets.0.Name'\n\nNote that you cannot use this method if ``ignoreErrorCodesMatching``\nis configured for any of the SDK calls. This is because in such a case,\nthe response data might not exist, and will cause a CloudFormation deploy time error.")
    get_response_field_reference: typing.Optional[list[models.custom_resources.AwsCustomResourceDefGetResponseFieldReferenceParams]] = pydantic.Field(None, description="Returns response data for the AWS SDK call.\nExample for S3 / listBucket : 'Buckets.0.Name'\n\nUse ``Token.asXxx`` to encode the returned ``Reference`` as a specific type or\nuse the convenience ``getDataString`` for string attributes.\n\nNote that you cannot use this method if ``ignoreErrorCodesMatching``\nis configured for any of the SDK calls. This is because in such a case,\nthe response data might not exist, and will cause a CloudFormation deploy time error.")
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class AwsCustomResourceDefGetResponseFieldParams(pydantic.BaseModel):
    data_path: str = pydantic.Field(..., description='the path to the data.')
    ...

class AwsCustomResourceDefGetResponseFieldReferenceParams(pydantic.BaseModel):
    data_path: str = pydantic.Field(..., description='the path to the data.')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.custom_resources.Provider
class ProviderDef(BaseConstruct):
    on_event_handler: typing.Union[_REQUIRED_INIT_PARAM, models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The AWS Lambda function to invoke for all resource lifecycle operations (CREATE/UPDATE/DELETE). This function is responsible to begin the requested resource operation (CREATE/UPDATE/DELETE) and return any additional properties to add to the event, which will later be passed to ``isComplete``. The ``PhysicalResourceId`` property must be included in the response.\n')
    disable_waiter_state_machine_logging: typing.Optional[bool] = pydantic.Field(None, description='Whether logging for the waiter state machine is disabled. Default: - false\n')
    is_complete_handler: typing.Optional[typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef]] = pydantic.Field(None, description='The AWS Lambda function to invoke in order to determine if the operation is complete. This function will be called immediately after ``onEvent`` and then periodically based on the configured query interval as long as it returns ``false``. If the function still returns ``false`` and the alloted timeout has passed, the operation will fail. Default: - provider is synchronous. This means that the ``onEvent`` handler is expected to finish all lifecycle operations within the initial invocation.\n')
    log_group: typing.Optional[typing.Union[models.aws_logs.LogGroupDef]] = pydantic.Field(None, description="The Log Group used for logging of events emitted by the custom resource's lambda function. Providing a user-controlled log group was rolled out to commercial regions on 2023-11-16. If you are deploying to another type of region, please check regional availability first. Default: - a default log group created by AWS Lambda\n")
    log_retention: typing.Optional[aws_cdk.aws_logs.RetentionDays] = pydantic.Field(None, description="The number of days framework log events are kept in CloudWatch Logs. When updating this property, unsetting it doesn't remove the log retention policy. To remove the retention policy, set the value to ``INFINITE``. This is a legacy API and we strongly recommend you migrate to ``logGroup`` if you can. ``logGroup`` allows you to create a fully customizable log group and instruct the Lambda function to send logs to it. Default: logs.RetentionDays.INFINITE\n")
    provider_function_env_encryption: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description="AWS KMS key used to encrypt provider lambda's environment variables. Default: - AWS Lambda creates and uses an AWS managed customer master key (CMK)\n")
    provider_function_name: typing.Optional[str] = pydantic.Field(None, description='Provider Lambda name. The provider lambda function name. Default: - CloudFormation default name from unique physical ID\n')
    query_interval: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Time between calls to the ``isComplete`` handler which determines if the resource has been stabilized. The first ``isComplete`` will be called immediately after ``handler`` and then every ``queryInterval`` seconds, and until ``timeout`` has been reached or until ``isComplete`` returns ``true``. Default: Duration.seconds(5)\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description="AWS Lambda execution role. The role that will be assumed by the AWS Lambda. Must be assumable by the 'lambda.amazonaws.com' service principal. Default: - A default role will be created.\n")
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description="Security groups to attach to the provider functions. Only used if 'vpc' is supplied Default: - If ``vpc`` is not supplied, no security groups are attached. Otherwise, a dedicated security group is created for each function.\n")
    total_timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Total timeout for the entire operation. The maximum timeout is 1 hour (yes, it can exceed the AWS Lambda 15 minutes) Default: Duration.minutes(30)\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The vpc to provision the lambda functions in. Default: - functions are not provisioned inside a vpc.\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Which subnets from the VPC to place the lambda functions in. Only used if 'vpc' is supplied. Note: internet access for Lambdas requires a NAT gateway, so picking Public subnets is not allowed. Default: - the Vpc default strategy if not specified\n")
    waiter_state_machine_log_options: typing.Union[models.custom_resources.LogOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Defines what execution history events of the waiter state machine are logged and where they are logged. Default: - A default log group will be created if logging for the waiter state machine is enabled.')
    _init_params: typing.ClassVar[list[str]] = ['on_event_handler', 'disable_waiter_state_machine_logging', 'is_complete_handler', 'log_group', 'log_retention', 'provider_function_env_encryption', 'provider_function_name', 'query_interval', 'role', 'security_groups', 'total_timeout', 'vpc', 'vpc_subnets', 'waiter_state_machine_log_options']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.custom_resources.Provider'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.custom_resources.ProviderDefConfig] = pydantic.Field(None)


class ProviderDefConfig(pydantic.BaseModel):
    on_event_handler_config: typing.Optional[models._interface_methods.AwsLambdaIFunctionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.custom_resources.WaiterStateMachine
class WaiterStateMachineDef(BaseConstruct):
    backoff_rate: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='Backoff between attempts.\n')
    interval: typing.Union[models.DurationDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The interval to wait between attempts.\n')
    is_complete_handler: typing.Union[_REQUIRED_INIT_PARAM, models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(REQUIRED_INIT_PARAM, description="The main handler that notifies if the waiter to decide 'complete' or 'incomplete'.\n")
    max_attempts: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='Number of attempts.\n')
    timeout_handler: typing.Union[_REQUIRED_INIT_PARAM, models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The handler to call if the waiter times out and is incomplete.\n')
    disable_logging: typing.Optional[bool] = pydantic.Field(None, description='Whether logging for the state machine is disabled. Default: - false\n')
    log_options: typing.Union[models.custom_resources.LogOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Defines what execution history events are logged and where they are logged. Default: - A default log group will be created if logging is enabled.')
    _init_params: typing.ClassVar[list[str]] = ['backoff_rate', 'interval', 'is_complete_handler', 'max_attempts', 'timeout_handler', 'disable_logging', 'log_options']
    _method_names: typing.ClassVar[list[str]] = ['grant_start_execution']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.custom_resources.WaiterStateMachine'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.custom_resources.WaiterStateMachineDefConfig] = pydantic.Field(None)


class WaiterStateMachineDefConfig(pydantic.BaseModel):
    grant_start_execution: typing.Optional[list[models.custom_resources.WaiterStateMachineDefGrantStartExecutionParams]] = pydantic.Field(None, description='Grant the given identity permissions on StartExecution of the state machine.')

class WaiterStateMachineDefGrantStartExecutionParams(pydantic.BaseModel):
    identity: models.AnyResource = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.custom_resources.AwsCustomResourceProps
class AwsCustomResourcePropsDef(BaseStruct):
    function_name: typing.Optional[str] = pydantic.Field(None, description="A name for the singleton Lambda function implementing this custom resource. The function name will remain the same after the first AwsCustomResource is created in a stack. Default: - AWS CloudFormation generates a unique physical ID and uses that ID for the function's name. For more information, see Name Type.\n")
    install_latest_aws_sdk: typing.Optional[bool] = pydantic.Field(None, description="Whether to install the latest AWS SDK v2. If not specified, this uses whatever JavaScript SDK version is the default in AWS Lambda at the time of execution. Otherwise, installs the latest version from 'npmjs.com'. The installation takes around 60 seconds and requires internet connectivity. The default can be controlled using the context key ``@aws-cdk/customresources:installLatestAwsSdkDefault`` is. Default: - The value of ``@aws-cdk/customresources:installLatestAwsSdkDefault``, otherwise ``true``\n")
    log_group: typing.Optional[typing.Union[models.aws_logs.LogGroupDef]] = pydantic.Field(None, description="The Log Group used for logging of events emitted by the custom resource's lambda function. Providing a user-controlled log group was rolled out to commercial regions on 2023-11-16. If you are deploying to another type of region, please check regional availability first. Default: - a default log group created by AWS Lambda\n")
    log_retention: typing.Optional[aws_cdk.aws_logs.RetentionDays] = pydantic.Field(None, description='The number of days log events of the singleton Lambda function implementing this custom resource are kept in CloudWatch Logs. This is a legacy API and we strongly recommend you migrate to ``logGroup`` if you can. ``logGroup`` allows you to create a fully customizable log group and instruct the Lambda function to send logs to it. Default: logs.RetentionDays.INFINITE\n')
    memory_size: typing.Union[int, float, None] = pydantic.Field(None, description='The memory size for the singleton Lambda function implementing this custom resource. Default: 512 mega in case if installLatestAwsSdk is false.\n')
    on_create: typing.Union[models.custom_resources.AwsSdkCallDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The AWS SDK call to make when the resource is created. Default: - the call when the resource is updated\n')
    on_delete: typing.Union[models.custom_resources.AwsSdkCallDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The AWS SDK call to make when the resource is deleted. Default: - no call\n')
    on_update: typing.Union[models.custom_resources.AwsSdkCallDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The AWS SDK call to make when the resource is updated. Default: - no call\n')
    policy: typing.Optional[models.custom_resources.AwsCustomResourcePolicyDef] = pydantic.Field(None, description="The policy that will be added to the execution role of the Lambda function implementing this custom resource provider. The custom resource also implements ``iam.IGrantable``, making it possible to use the ``grantXxx()`` methods. As this custom resource uses a singleton Lambda function, it's important to note the that function's role will eventually accumulate the permissions/grants from all resources. Note that a policy must be specified if ``role`` is not provided, as by default a new role is created which requires policy changes to access resources. Default: - no policy added\n")
    removal_policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='The policy to apply when this resource is removed from the application. Default: cdk.RemovalPolicy.Destroy\n')
    resource_type: typing.Optional[str] = pydantic.Field(None, description='Cloudformation Resource type. Default: - Custom::AWS\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The execution role for the singleton Lambda function implementing this custom resource provider. This role will apply to all ``AwsCustomResource`` instances in the stack. The role must be assumable by the ``lambda.amazonaws.com`` service principal. Default: - a new role is created\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The timeout for the singleton Lambda function implementing this custom resource. Default: Duration.minutes(2)\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The vpc to provision the lambda function in. Default: - the function is not provisioned inside a vpc.\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Which subnets from the VPC to place the lambda function in. Only used if \'vpc\' is supplied. Note: internet access for Lambdas requires a NAT gateway, so picking Public subnets is not allowed. Default: - the Vpc default strategy if not specified\n\n:exampleMetadata: infused\n\nExample::\n\n    get_parameter = cr.AwsCustomResource(self, "GetParameter",\n        on_update=cr.AwsSdkCall( # will also be called for a CREATE event\n            service="SSM",\n            action="GetParameter",\n            parameters={\n                "Name": "my-parameter",\n                "WithDecryption": True\n            },\n            physical_resource_id=cr.PhysicalResourceId.of(Date.now().to_string())),\n        policy=cr.AwsCustomResourcePolicy.from_sdk_calls(\n            resources=cr.AwsCustomResourcePolicy.ANY_RESOURCE\n        )\n    )\n\n    # Use the value in another construct with\n    get_parameter.get_response_field("Parameter.Value")\n')
    _init_params: typing.ClassVar[list[str]] = ['function_name', 'install_latest_aws_sdk', 'log_group', 'log_retention', 'memory_size', 'on_create', 'on_delete', 'on_update', 'policy', 'removal_policy', 'resource_type', 'role', 'timeout', 'vpc', 'vpc_subnets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.custom_resources.AwsCustomResourceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.custom_resources.AwsSdkCall
class AwsSdkCallDef(BaseStruct):
    action: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The service action to call. This is the name of an AWS API call, in one of the following forms: - An API call name as found in the API Reference documentation (``GetObject``) - The API call name starting with a lowercase letter (``getObject``) - The AWS SDK for JavaScript v3 command class name (``GetObjectCommand``)\n')
    service: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The service to call. This is the name of an AWS service, in one of the following forms: - An AWS SDK for JavaScript v3 package name (``@aws-sdk/client-api-gateway``) - An AWS SDK for JavaScript v3 client name (``api-gateway``) - An AWS SDK for JavaScript v2 constructor name (``APIGateway``) - A lowercase AWS SDK for JavaScript v2 constructor name (``apigateway``)\n')
    api_version: typing.Optional[str] = pydantic.Field(None, description='API version to use for the service. Default: - use latest available API version\n')
    assumed_role_arn: typing.Optional[str] = pydantic.Field(None, description='Used for running the SDK calls in underlying lambda with a different role. Can be used primarily for cross-account requests to for example connect hostedzone with a shared vpc. Region controls where assumeRole call is made. Example for Route53 / associateVPCWithHostedZone Default: - run without assuming role\n')
    ignore_error_codes_matching: typing.Optional[str] = pydantic.Field(None, description='The regex pattern to use to catch API errors. The ``code`` property of the ``Error`` object will be tested against this pattern. If there is a match an error will not be thrown. Default: - do not catch errors\n')
    logging: typing.Optional[models.custom_resources.LoggingDef] = pydantic.Field(None, description='A property used to configure logging during lambda function execution. Note: The default Logging configuration is all. This configuration will enable logging on all logged data in the lambda handler. This includes: - The event object that is received by the lambda handler - The response received after making a API call - The response object that the lambda handler will return - SDK versioning information - Caught and uncaught errors Default: Logging.all()\n')
    output_paths: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="Restrict the data returned by the custom resource to specific paths in the API response. Use this to limit the data returned by the custom resource if working with API calls that could potentially result in custom response objects exceeding the hard limit of 4096 bytes. Example for ECS / updateService: ['service.deploymentConfiguration.maximumPercent'] Default: - return all data\n")
    parameters: typing.Any = pydantic.Field(None, description='The parameters for the service action. Default: - no parameters\n')
    physical_resource_id: typing.Optional[models.custom_resources.PhysicalResourceIdDef] = pydantic.Field(None, description='The physical resource id of the custom resource for this call. Mandatory for onCreate call. In onUpdate, you can omit this to passthrough it from request. Default: - no physical resource id\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region to send service requests to. **Note: Cross-region operations are generally considered an anti-pattern.** **Consider first deploying a stack in that region.** Default: - the region where this custom resource is deployed\n\nExample::\n\n    cr.AwsCustomResource(self, "GetParameterCustomResource",\n        on_update=cr.AwsSdkCall( # will also be called for a CREATE event\n            service="SSM",\n            action="getParameter",\n            parameters={\n                "Name": "my-parameter",\n                "WithDecryption": True\n            },\n            physical_resource_id=cr.PhysicalResourceId.from_response("Parameter.ARN")),\n        policy=cr.AwsCustomResourcePolicy.from_sdk_calls(\n            resources=cr.AwsCustomResourcePolicy.ANY_RESOURCE\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['action', 'service', 'api_version', 'assumed_role_arn', 'ignore_error_codes_matching', 'logging', 'output_paths', 'parameters', 'physical_resource_id', 'region']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.custom_resources.AwsSdkCall'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.custom_resources.LoggingProps
class LoggingPropsDef(BaseStruct):
    log_api_response_data: typing.Optional[bool] = pydantic.Field(None, description='Whether or not to log data associated with the API call response. Default: true\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import custom_resources\n\n    logging_props = custom_resources.LoggingProps(\n        log_api_response_data=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['log_api_response_data']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.custom_resources.LoggingProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.custom_resources.LogOptions
class LogOptionsDef(BaseStruct):
    destination: typing.Optional[typing.Union[models.aws_logs.LogGroupDef]] = pydantic.Field(None, description='The log group where the execution history events will be logged. Default: - a new log group will be created\n')
    include_execution_data: typing.Optional[bool] = pydantic.Field(None, description='Determines whether execution data is included in your log. Default: - false\n')
    level: typing.Optional[aws_cdk.aws_stepfunctions.LogLevel] = pydantic.Field(None, description='Defines which category of execution history events are logged. Default: - ERROR\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_logs as logs\n    from aws_cdk import aws_stepfunctions as stepfunctions\n    from aws_cdk import custom_resources\n\n    # log_group: logs.LogGroup\n\n    log_options = custom_resources.LogOptions(\n        destination=log_group,\n        include_execution_data=False,\n        level=stepfunctions.LogLevel.OFF\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination', 'include_execution_data', 'level']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.custom_resources.LogOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.custom_resources.ProviderProps
class ProviderPropsDef(BaseStruct):
    on_event_handler: typing.Union[_REQUIRED_INIT_PARAM, models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The AWS Lambda function to invoke for all resource lifecycle operations (CREATE/UPDATE/DELETE). This function is responsible to begin the requested resource operation (CREATE/UPDATE/DELETE) and return any additional properties to add to the event, which will later be passed to ``isComplete``. The ``PhysicalResourceId`` property must be included in the response.\n')
    disable_waiter_state_machine_logging: typing.Optional[bool] = pydantic.Field(None, description='Whether logging for the waiter state machine is disabled. Default: - false\n')
    is_complete_handler: typing.Optional[typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef]] = pydantic.Field(None, description='The AWS Lambda function to invoke in order to determine if the operation is complete. This function will be called immediately after ``onEvent`` and then periodically based on the configured query interval as long as it returns ``false``. If the function still returns ``false`` and the alloted timeout has passed, the operation will fail. Default: - provider is synchronous. This means that the ``onEvent`` handler is expected to finish all lifecycle operations within the initial invocation.\n')
    log_group: typing.Optional[typing.Union[models.aws_logs.LogGroupDef]] = pydantic.Field(None, description="The Log Group used for logging of events emitted by the custom resource's lambda function. Providing a user-controlled log group was rolled out to commercial regions on 2023-11-16. If you are deploying to another type of region, please check regional availability first. Default: - a default log group created by AWS Lambda\n")
    log_retention: typing.Optional[aws_cdk.aws_logs.RetentionDays] = pydantic.Field(None, description="The number of days framework log events are kept in CloudWatch Logs. When updating this property, unsetting it doesn't remove the log retention policy. To remove the retention policy, set the value to ``INFINITE``. This is a legacy API and we strongly recommend you migrate to ``logGroup`` if you can. ``logGroup`` allows you to create a fully customizable log group and instruct the Lambda function to send logs to it. Default: logs.RetentionDays.INFINITE\n")
    provider_function_env_encryption: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description="AWS KMS key used to encrypt provider lambda's environment variables. Default: - AWS Lambda creates and uses an AWS managed customer master key (CMK)\n")
    provider_function_name: typing.Optional[str] = pydantic.Field(None, description='Provider Lambda name. The provider lambda function name. Default: - CloudFormation default name from unique physical ID\n')
    query_interval: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Time between calls to the ``isComplete`` handler which determines if the resource has been stabilized. The first ``isComplete`` will be called immediately after ``handler`` and then every ``queryInterval`` seconds, and until ``timeout`` has been reached or until ``isComplete`` returns ``true``. Default: Duration.seconds(5)\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description="AWS Lambda execution role. The role that will be assumed by the AWS Lambda. Must be assumable by the 'lambda.amazonaws.com' service principal. Default: - A default role will be created.\n")
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description="Security groups to attach to the provider functions. Only used if 'vpc' is supplied Default: - If ``vpc`` is not supplied, no security groups are attached. Otherwise, a dedicated security group is created for each function.\n")
    total_timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Total timeout for the entire operation. The maximum timeout is 1 hour (yes, it can exceed the AWS Lambda 15 minutes) Default: Duration.minutes(30)\n')
    vpc: typing.Optional[typing.Union[models.aws_ec2.VpcDef]] = pydantic.Field(None, description='The vpc to provision the lambda functions in. Default: - functions are not provisioned inside a vpc.\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Which subnets from the VPC to place the lambda functions in. Only used if 'vpc' is supplied. Note: internet access for Lambdas requires a NAT gateway, so picking Public subnets is not allowed. Default: - the Vpc default strategy if not specified\n")
    waiter_state_machine_log_options: typing.Union[models.custom_resources.LogOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Defines what execution history events of the waiter state machine are logged and where they are logged. Default: - A default log group will be created if logging for the waiter state machine is enabled.\n\n:exampleMetadata: infused\n\nExample::\n\n    # on_event: lambda.Function\n    # is_complete: lambda.Function\n    # my_role: iam.Role\n\n    my_provider = cr.Provider(self, "MyProvider",\n        on_event_handler=on_event,\n        is_complete_handler=is_complete,\n        log_group=logs.LogGroup(self, "MyProviderLogs",\n            retention=logs.RetentionDays.ONE_DAY\n        ),\n        role=my_role,\n        provider_function_name="the-lambda-name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['on_event_handler', 'disable_waiter_state_machine_logging', 'is_complete_handler', 'log_group', 'log_retention', 'provider_function_env_encryption', 'provider_function_name', 'query_interval', 'role', 'security_groups', 'total_timeout', 'vpc', 'vpc_subnets', 'waiter_state_machine_log_options']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.custom_resources.ProviderProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.custom_resources.ProviderPropsDefConfig] = pydantic.Field(None)


class ProviderPropsDefConfig(pydantic.BaseModel):
    on_event_handler_config: typing.Optional[models._interface_methods.AwsLambdaIFunctionDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.custom_resources.SdkCallsPolicyOptions
class SdkCallsPolicyOptionsDef(BaseStruct):
    resources: typing.Union[typing.Sequence[str], _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The resources that the calls will have access to. It is best to use specific resource ARN\'s when possible. However, you can also use ``AwsCustomResourcePolicy.ANY_RESOURCE`` to allow access to all resources. For example, when ``onCreate`` is used to create a resource which you don\'t know the physical name of in advance. Note that will apply to ALL SDK calls.\n\n:exampleMetadata: infused\n\nExample::\n\n    get_parameter = cr.AwsCustomResource(self, "GetParameter",\n        on_update=cr.AwsSdkCall( # will also be called for a CREATE event\n            service="SSM",\n            action="GetParameter",\n            parameters={\n                "Name": "my-parameter",\n                "WithDecryption": True\n            },\n            physical_resource_id=cr.PhysicalResourceId.of(Date.now().to_string())),\n        policy=cr.AwsCustomResourcePolicy.from_sdk_calls(\n            resources=cr.AwsCustomResourcePolicy.ANY_RESOURCE\n        )\n    )\n\n    # Use the value in another construct with\n    get_parameter.get_response_field("Parameter.Value")\n')
    _init_params: typing.ClassVar[list[str]] = ['resources']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.custom_resources.SdkCallsPolicyOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.custom_resources.WaiterStateMachineProps
class WaiterStateMachinePropsDef(BaseStruct):
    backoff_rate: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='Backoff between attempts.\n')
    interval: typing.Union[models.DurationDef, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The interval to wait between attempts.\n')
    is_complete_handler: typing.Union[_REQUIRED_INIT_PARAM, models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(REQUIRED_INIT_PARAM, description="The main handler that notifies if the waiter to decide 'complete' or 'incomplete'.\n")
    max_attempts: typing.Union[_REQUIRED_INIT_PARAM, int, float] = pydantic.Field(REQUIRED_INIT_PARAM, description='Number of attempts.\n')
    timeout_handler: typing.Union[_REQUIRED_INIT_PARAM, models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef] = pydantic.Field(REQUIRED_INIT_PARAM, description='The handler to call if the waiter times out and is incomplete.\n')
    disable_logging: typing.Optional[bool] = pydantic.Field(None, description='Whether logging for the state machine is disabled. Default: - false\n')
    log_options: typing.Union[models.custom_resources.LogOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Defines what execution history events are logged and where they are logged. Default: - A default log group will be created if logging is enabled.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_lambda as lambda_\n    from aws_cdk import aws_logs as logs\n    from aws_cdk import aws_stepfunctions as stepfunctions\n    from aws_cdk import custom_resources\n\n    # function_: lambda.Function\n    # log_group: logs.LogGroup\n\n    waiter_state_machine_props = custom_resources.WaiterStateMachineProps(\n        backoff_rate=123,\n        interval=cdk.Duration.minutes(30),\n        is_complete_handler=function_,\n        max_attempts=123,\n        timeout_handler=function_,\n\n        # the properties below are optional\n        disable_logging=False,\n        log_options=custom_resources.LogOptions(\n            destination=log_group,\n            include_execution_data=False,\n            level=stepfunctions.LogLevel.OFF\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['backoff_rate', 'interval', 'is_complete_handler', 'max_attempts', 'timeout_handler', 'disable_logging', 'log_options']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.custom_resources.WaiterStateMachineProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.custom_resources.WaiterStateMachinePropsDefConfig] = pydantic.Field(None)


class WaiterStateMachinePropsDefConfig(pydantic.BaseModel):
    interval_config: typing.Optional[models.core.DurationDefConfig] = pydantic.Field(None)
    is_complete_handler_config: typing.Optional[models._interface_methods.AwsLambdaIFunctionDefConfig] = pydantic.Field(None)
    timeout_handler_config: typing.Optional[models._interface_methods.AwsLambdaIFunctionDefConfig] = pydantic.Field(None)


class ModuleModel(pydantic.BaseModel):
    AwsCustomResourcePolicy: typing.Optional[dict[str, models.custom_resources.AwsCustomResourcePolicyDef]] = pydantic.Field(None)
    Logging: typing.Optional[dict[str, models.custom_resources.LoggingDef]] = pydantic.Field(None)
    PhysicalResourceId: typing.Optional[dict[str, models.custom_resources.PhysicalResourceIdDef]] = pydantic.Field(None)
    PhysicalResourceIdReference: typing.Optional[dict[str, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(None)
    AwsCustomResource: typing.Optional[dict[str, models.custom_resources.AwsCustomResourceDef]] = pydantic.Field(None)
    Provider: typing.Optional[dict[str, models.custom_resources.ProviderDef]] = pydantic.Field(None)
    WaiterStateMachine: typing.Optional[dict[str, models.custom_resources.WaiterStateMachineDef]] = pydantic.Field(None)
    AwsCustomResourceProps: typing.Optional[dict[str, models.custom_resources.AwsCustomResourcePropsDef]] = pydantic.Field(None)
    AwsSdkCall: typing.Optional[dict[str, models.custom_resources.AwsSdkCallDef]] = pydantic.Field(None)
    LoggingProps: typing.Optional[dict[str, models.custom_resources.LoggingPropsDef]] = pydantic.Field(None)
    LogOptions: typing.Optional[dict[str, models.custom_resources.LogOptionsDef]] = pydantic.Field(None)
    ProviderProps: typing.Optional[dict[str, models.custom_resources.ProviderPropsDef]] = pydantic.Field(None)
    SdkCallsPolicyOptions: typing.Optional[dict[str, models.custom_resources.SdkCallsPolicyOptionsDef]] = pydantic.Field(None)
    WaiterStateMachineProps: typing.Optional[dict[str, models.custom_resources.WaiterStateMachinePropsDef]] = pydantic.Field(None)
    ...

import models
