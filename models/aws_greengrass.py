from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams, REQUIRED_INIT_PARAM, _REQUIRED_INIT_PARAM

#  autogenerated from aws_cdk.aws_greengrass.CfnConnectorDefinition.ConnectorDefinitionVersionProperty
class CfnConnectorDefinition_ConnectorDefinitionVersionPropertyDef(BaseStruct):
    connectors: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnConnectorDefinition_ConnectorPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The connectors in this version. Only one instance of a given connector can be added to a connector definition version at a time.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-connectordefinition-connectordefinitionversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    # parameters: Any\n\n    connector_definition_version_property = greengrass.CfnConnectorDefinition.ConnectorDefinitionVersionProperty(\n        connectors=[greengrass.CfnConnectorDefinition.ConnectorProperty(\n            connector_arn="connectorArn",\n            id="id",\n\n            # the properties below are optional\n            parameters=parameters\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connectors']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnConnectorDefinition.ConnectorDefinitionVersionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnConnectorDefinition.ConnectorProperty
class CfnConnectorDefinition_ConnectorPropertyDef(BaseStruct):
    connector_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the connector. For more information about connectors provided by AWS , see `Greengrass Connectors Provided by AWS <https://docs.aws.amazon.com/greengrass/latest/developerguide/connectors-list.html>`_ .\n')
    parameters: typing.Any = pydantic.Field(None, description='The parameters or configuration used by the connector. For more information about connectors provided by AWS , see `Greengrass Connectors Provided by AWS <https://docs.aws.amazon.com/greengrass/latest/developerguide/connectors-list.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-connectordefinition-connector.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    # parameters: Any\n\n    connector_property = greengrass.CfnConnectorDefinition.ConnectorProperty(\n        connector_arn="connectorArn",\n        id="id",\n\n        # the properties below are optional\n        parameters=parameters\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connector_arn', 'parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnConnectorDefinition.ConnectorProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnConnectorDefinitionVersion.ConnectorProperty
class CfnConnectorDefinitionVersion_ConnectorPropertyDef(BaseStruct):
    connector_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the connector. For more information about connectors provided by AWS , see `Greengrass Connectors Provided by AWS <https://docs.aws.amazon.com/greengrass/latest/developerguide/connectors-list.html>`_ .\n')
    parameters: typing.Any = pydantic.Field(None, description='The parameters or configuration that the connector uses. For more information about connectors provided by AWS , see `Greengrass Connectors Provided by AWS <https://docs.aws.amazon.com/greengrass/latest/developerguide/connectors-list.html>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-connectordefinitionversion-connector.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    # parameters: Any\n\n    connector_property = greengrass.CfnConnectorDefinitionVersion.ConnectorProperty(\n        connector_arn="connectorArn",\n        id="id",\n\n        # the properties below are optional\n        parameters=parameters\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connector_arn', 'parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnConnectorDefinitionVersion.ConnectorProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnCoreDefinition.CoreDefinitionVersionProperty
class CfnCoreDefinition_CoreDefinitionVersionPropertyDef(BaseStruct):
    cores: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnCoreDefinition_CorePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Greengrass core in this version. Currently, the ``Cores`` property for a core definition version can contain only one core.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-coredefinition-coredefinitionversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    core_definition_version_property = greengrass.CfnCoreDefinition.CoreDefinitionVersionProperty(\n        cores=[greengrass.CfnCoreDefinition.CoreProperty(\n            certificate_arn="certificateArn",\n            id="id",\n            thing_arn="thingArn",\n\n            # the properties below are optional\n            sync_shadow=False\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cores']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnCoreDefinition.CoreDefinitionVersionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnCoreDefinition.CoreProperty
class CfnCoreDefinition_CorePropertyDef(BaseStruct):
    certificate_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the device certificate for the core. This X.509 certificate is used to authenticate the core with AWS IoT and AWS IoT Greengrass services.\n')
    thing_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the core, which is an AWS IoT device (thing).\n')
    sync_shadow: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether the core\'s local shadow is synced with the cloud automatically. The default is false.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-coredefinition-core.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    core_property = greengrass.CfnCoreDefinition.CoreProperty(\n        certificate_arn="certificateArn",\n        id="id",\n        thing_arn="thingArn",\n\n        # the properties below are optional\n        sync_shadow=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate_arn', 'thing_arn', 'sync_shadow']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnCoreDefinition.CoreProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnCoreDefinitionVersion.CoreProperty
class CfnCoreDefinitionVersion_CorePropertyDef(BaseStruct):
    certificate_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the device certificate for the core. This X.509 certificate is used to authenticate the core with AWS IoT and AWS IoT Greengrass services.\n')
    thing_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the core, which is an AWS IoT device (thing).\n')
    sync_shadow: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether the core\'s local shadow is synced with the cloud automatically. The default is false.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-coredefinitionversion-core.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    core_property = greengrass.CfnCoreDefinitionVersion.CoreProperty(\n        certificate_arn="certificateArn",\n        id="id",\n        thing_arn="thingArn",\n\n        # the properties below are optional\n        sync_shadow=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate_arn', 'thing_arn', 'sync_shadow']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnCoreDefinitionVersion.CoreProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnDeviceDefinition.DeviceDefinitionVersionProperty
class CfnDeviceDefinition_DeviceDefinitionVersionPropertyDef(BaseStruct):
    devices: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnDeviceDefinition_DevicePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The devices in this version.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-devicedefinition-devicedefinitionversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    device_definition_version_property = greengrass.CfnDeviceDefinition.DeviceDefinitionVersionProperty(\n        devices=[greengrass.CfnDeviceDefinition.DeviceProperty(\n            certificate_arn="certificateArn",\n            id="id",\n            thing_arn="thingArn",\n\n            # the properties below are optional\n            sync_shadow=False\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['devices']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnDeviceDefinition.DeviceDefinitionVersionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnDeviceDefinition.DeviceProperty
class CfnDeviceDefinition_DevicePropertyDef(BaseStruct):
    certificate_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the device certificate for the device. This X.509 certificate is used to authenticate the device with AWS IoT and AWS IoT Greengrass services.\n')
    thing_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the device, which is an AWS IoT device (thing).\n')
    sync_shadow: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether the device\'s local shadow is synced with the cloud automatically.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-devicedefinition-device.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    device_property = greengrass.CfnDeviceDefinition.DeviceProperty(\n        certificate_arn="certificateArn",\n        id="id",\n        thing_arn="thingArn",\n\n        # the properties below are optional\n        sync_shadow=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate_arn', 'thing_arn', 'sync_shadow']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnDeviceDefinition.DeviceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnDeviceDefinitionVersion.DeviceProperty
class CfnDeviceDefinitionVersion_DevicePropertyDef(BaseStruct):
    certificate_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ARN of the device certificate for the device. This X.509 certificate is used to authenticate the device with AWS IoT and AWS IoT Greengrass services.\n')
    thing_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the device, which is an AWS IoT device (thing).\n')
    sync_shadow: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether the device\'s local shadow is synced with the cloud automatically.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-devicedefinitionversion-device.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    device_property = greengrass.CfnDeviceDefinitionVersion.DeviceProperty(\n        certificate_arn="certificateArn",\n        id="id",\n        thing_arn="thingArn",\n\n        # the properties below are optional\n        sync_shadow=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate_arn', 'thing_arn', 'sync_shadow']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnDeviceDefinitionVersion.DeviceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnFunctionDefinition.DefaultConfigProperty
class CfnFunctionDefinition_DefaultConfigPropertyDef(BaseStruct):
    execution: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinition_ExecutionPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Configuration settings for the Lambda execution environment on the AWS IoT Greengrass core.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinition-defaultconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    default_config_property = greengrass.CfnFunctionDefinition.DefaultConfigProperty(\n        execution=greengrass.CfnFunctionDefinition.ExecutionProperty(\n            isolation_mode="isolationMode",\n            run_as=greengrass.CfnFunctionDefinition.RunAsProperty(\n                gid=123,\n                uid=123\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['execution']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnFunctionDefinition.DefaultConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnFunctionDefinition.EnvironmentProperty
class CfnFunctionDefinition_EnvironmentPropertyDef(BaseStruct):
    access_sysfs: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether the function is allowed to access the ``/sys`` directory on the core device, which allows the read device information from ``/sys`` . .. epigraph:: This property applies only to Lambda functions that run in a Greengrass container.\n')
    execution: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinition_ExecutionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for the Lambda execution environment in AWS IoT Greengrass .\n')
    resource_access_policies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinition_ResourceAccessPolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of the `resources <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinitionversion-resourceinstance.html>`_ in the group that the function can access, with the corresponding read-only or read-write permissions. The maximum is 10 resources. .. epigraph:: This property applies only for Lambda functions that run in a Greengrass container.\n')
    variables: typing.Any = pydantic.Field(None, description='Environment variables for the Lambda function.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinition-environment.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    # variables: Any\n\n    environment_property = greengrass.CfnFunctionDefinition.EnvironmentProperty(\n        access_sysfs=False,\n        execution=greengrass.CfnFunctionDefinition.ExecutionProperty(\n            isolation_mode="isolationMode",\n            run_as=greengrass.CfnFunctionDefinition.RunAsProperty(\n                gid=123,\n                uid=123\n            )\n        ),\n        resource_access_policies=[greengrass.CfnFunctionDefinition.ResourceAccessPolicyProperty(\n            resource_id="resourceId",\n\n            # the properties below are optional\n            permission="permission"\n        )],\n        variables=variables\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['access_sysfs', 'execution', 'resource_access_policies', 'variables']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnFunctionDefinition.EnvironmentProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnFunctionDefinition.ExecutionProperty
class CfnFunctionDefinition_ExecutionPropertyDef(BaseStruct):
    isolation_mode: typing.Optional[str] = pydantic.Field(None, description='The containerization that the Lambda function runs in. Valid values are ``GreengrassContainer`` or ``NoContainer`` . Typically, this is ``GreengrassContainer`` . For more information, see `Containerization <https://docs.aws.amazon.com/greengrass/latest/developerguide/lambda-group-config.html#lambda-function-containerization>`_ in the *Developer Guide* . - When set on the ```DefaultConfig`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinitionversion-defaultconfig.html>`_ property of a function definition version, this setting is used as the default containerization for all Lambda functions in the function definition version. - When set on the ```Environment`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinitionversion-environment.html>`_ property of a function, this setting applies to the individual function and overrides the default. Omit this value to run the function with the default containerization. .. epigraph:: We recommend that you run in a Greengrass container unless your business case requires that you run without containerization.\n')
    run_as: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinition_RunAsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The user and group permissions used to run the Lambda function. Typically, this is the ggc_user and ggc_group. For more information, see `Run as <https://docs.aws.amazon.com/greengrass/latest/developerguide/lambda-group-config.html#lambda-access-identity.html>`_ in the *Developer Guide* . - When set on the ```DefaultConfig`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinitionversion-defaultconfig.html>`_ property of a function definition version, this setting is used as the default access identity for all Lambda functions in the function definition version. - When set on the ```Environment`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinitionversion-environment.html>`_ property of a function, this setting applies to the individual function and overrides the default. You can override the user, group, or both. Omit this value to run the function with the default permissions. .. epigraph:: Running as the root user increases risks to your data and device. Do not run as root (UID/GID=0) unless your business case requires it. For more information and requirements, see `Running a Lambda Function as Root <https://docs.aws.amazon.com/greengrass/latest/developerguide/lambda-group-config.html#lambda-running-as-root>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinition-execution.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    execution_property = greengrass.CfnFunctionDefinition.ExecutionProperty(\n        isolation_mode="isolationMode",\n        run_as=greengrass.CfnFunctionDefinition.RunAsProperty(\n            gid=123,\n            uid=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['isolation_mode', 'run_as']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnFunctionDefinition.ExecutionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnFunctionDefinition.FunctionConfigurationProperty
class CfnFunctionDefinition_FunctionConfigurationPropertyDef(BaseStruct):
    encoding_type: typing.Optional[str] = pydantic.Field(None, description='The expected encoding type of the input payload for the function. Valid values are ``json`` (default) and ``binary`` .\n')
    environment: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinition_EnvironmentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The environment configuration of the function.\n')
    exec_args: typing.Optional[str] = pydantic.Field(None, description='The execution arguments.\n')
    executable: typing.Optional[str] = pydantic.Field(None, description='The name of the function executable.\n')
    memory_size: typing.Union[int, float, None] = pydantic.Field(None, description='The memory size (in KB) required by the function. .. epigraph:: This property applies only to Lambda functions that run in a Greengrass container.\n')
    pinned: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether the function is pinned (or *long-lived* ). Pinned functions start when the core starts and process all requests in the same container. The default value is false.\n')
    timeout: typing.Union[int, float, None] = pydantic.Field(None, description='The allowed execution time (in seconds) after which the function should terminate. For pinned functions, this timeout applies for each request.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinition-functionconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    # variables: Any\n\n    function_configuration_property = greengrass.CfnFunctionDefinition.FunctionConfigurationProperty(\n        encoding_type="encodingType",\n        environment=greengrass.CfnFunctionDefinition.EnvironmentProperty(\n            access_sysfs=False,\n            execution=greengrass.CfnFunctionDefinition.ExecutionProperty(\n                isolation_mode="isolationMode",\n                run_as=greengrass.CfnFunctionDefinition.RunAsProperty(\n                    gid=123,\n                    uid=123\n                )\n            ),\n            resource_access_policies=[greengrass.CfnFunctionDefinition.ResourceAccessPolicyProperty(\n                resource_id="resourceId",\n\n                # the properties below are optional\n                permission="permission"\n            )],\n            variables=variables\n        ),\n        exec_args="execArgs",\n        executable="executable",\n        memory_size=123,\n        pinned=False,\n        timeout=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['encoding_type', 'environment', 'exec_args', 'executable', 'memory_size', 'pinned', 'timeout']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnFunctionDefinition.FunctionConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnFunctionDefinition.FunctionDefinitionVersionProperty
class CfnFunctionDefinition_FunctionDefinitionVersionPropertyDef(BaseStruct):
    functions: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinition_FunctionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The functions in this version.\n')
    default_config: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinition_DefaultConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The default configuration that applies to all Lambda functions in the group. Individual Lambda functions can override these settings.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinition-functiondefinitionversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    # variables: Any\n\n    function_definition_version_property = greengrass.CfnFunctionDefinition.FunctionDefinitionVersionProperty(\n        functions=[greengrass.CfnFunctionDefinition.FunctionProperty(\n            function_arn="functionArn",\n            function_configuration=greengrass.CfnFunctionDefinition.FunctionConfigurationProperty(\n                encoding_type="encodingType",\n                environment=greengrass.CfnFunctionDefinition.EnvironmentProperty(\n                    access_sysfs=False,\n                    execution=greengrass.CfnFunctionDefinition.ExecutionProperty(\n                        isolation_mode="isolationMode",\n                        run_as=greengrass.CfnFunctionDefinition.RunAsProperty(\n                            gid=123,\n                            uid=123\n                        )\n                    ),\n                    resource_access_policies=[greengrass.CfnFunctionDefinition.ResourceAccessPolicyProperty(\n                        resource_id="resourceId",\n\n                        # the properties below are optional\n                        permission="permission"\n                    )],\n                    variables=variables\n                ),\n                exec_args="execArgs",\n                executable="executable",\n                memory_size=123,\n                pinned=False,\n                timeout=123\n            ),\n            id="id"\n        )],\n\n        # the properties below are optional\n        default_config=greengrass.CfnFunctionDefinition.DefaultConfigProperty(\n            execution=greengrass.CfnFunctionDefinition.ExecutionProperty(\n                isolation_mode="isolationMode",\n                run_as=greengrass.CfnFunctionDefinition.RunAsProperty(\n                    gid=123,\n                    uid=123\n                )\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['functions', 'default_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnFunctionDefinition.FunctionDefinitionVersionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnFunctionDefinition.FunctionProperty
class CfnFunctionDefinition_FunctionPropertyDef(BaseStruct):
    function_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the alias (recommended) or version of the referenced Lambda function.\n')
    function_configuration: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinition_FunctionConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description="The group-specific settings of the Lambda function. These settings configure the function's behavior in the Greengrass group.\n")
    _init_params: typing.ClassVar[list[str]] = ['function_arn', 'function_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnFunctionDefinition.FunctionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnFunctionDefinition.ResourceAccessPolicyProperty
class CfnFunctionDefinition_ResourceAccessPolicyPropertyDef(BaseStruct):
    resource_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the resource. This ID is assigned to the resource when you create the resource definition.\n')
    permission: typing.Optional[str] = pydantic.Field(None, description='The read-only or read-write access that the Lambda function has to the resource. Valid values are ``ro`` or ``rw`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinition-resourceaccesspolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    resource_access_policy_property = greengrass.CfnFunctionDefinition.ResourceAccessPolicyProperty(\n        resource_id="resourceId",\n\n        # the properties below are optional\n        permission="permission"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resource_id', 'permission']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnFunctionDefinition.ResourceAccessPolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnFunctionDefinition.RunAsProperty
class CfnFunctionDefinition_RunAsPropertyDef(BaseStruct):
    gid: typing.Union[int, float, None] = pydantic.Field(None, description='The group ID whose permissions are used to run the Lambda function. You can use the ``getent group`` command on your core device to look up the group ID.\n')
    uid: typing.Union[int, float, None] = pydantic.Field(None, description='The user ID whose permissions are used to run the Lambda function. You can use the ``getent passwd`` command on your core device to look up the user ID.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinition-runas.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    run_as_property = greengrass.CfnFunctionDefinition.RunAsProperty(\n        gid=123,\n        uid=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['gid', 'uid']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnFunctionDefinition.RunAsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnFunctionDefinitionVersion.DefaultConfigProperty
class CfnFunctionDefinitionVersion_DefaultConfigPropertyDef(BaseStruct):
    execution: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinitionVersion_ExecutionPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='Configuration settings for the Lambda execution environment on the AWS IoT Greengrass core.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinitionversion-defaultconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    default_config_property = greengrass.CfnFunctionDefinitionVersion.DefaultConfigProperty(\n        execution=greengrass.CfnFunctionDefinitionVersion.ExecutionProperty(\n            isolation_mode="isolationMode",\n            run_as=greengrass.CfnFunctionDefinitionVersion.RunAsProperty(\n                gid=123,\n                uid=123\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['execution']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnFunctionDefinitionVersion.DefaultConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnFunctionDefinitionVersion.EnvironmentProperty
class CfnFunctionDefinitionVersion_EnvironmentPropertyDef(BaseStruct):
    access_sysfs: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether the function is allowed to access the ``/sys`` directory on the core device, which allows the read device information from ``/sys`` . .. epigraph:: This property applies only to Lambda functions that run in a Greengrass container.\n')
    execution: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinitionVersion_ExecutionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for the Lambda execution environment in AWS IoT Greengrass .\n')
    resource_access_policies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinitionVersion_ResourceAccessPolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='A list of the `resources <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinitionversion-resourceinstance.html>`_ in the group that the function can access, with the corresponding read-only or read-write permissions. The maximum is 10 resources. .. epigraph:: This property applies only to Lambda functions that run in a Greengrass container.\n')
    variables: typing.Any = pydantic.Field(None, description='Environment variables for the Lambda function.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinitionversion-environment.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    # variables: Any\n\n    environment_property = greengrass.CfnFunctionDefinitionVersion.EnvironmentProperty(\n        access_sysfs=False,\n        execution=greengrass.CfnFunctionDefinitionVersion.ExecutionProperty(\n            isolation_mode="isolationMode",\n            run_as=greengrass.CfnFunctionDefinitionVersion.RunAsProperty(\n                gid=123,\n                uid=123\n            )\n        ),\n        resource_access_policies=[greengrass.CfnFunctionDefinitionVersion.ResourceAccessPolicyProperty(\n            resource_id="resourceId",\n\n            # the properties below are optional\n            permission="permission"\n        )],\n        variables=variables\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['access_sysfs', 'execution', 'resource_access_policies', 'variables']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnFunctionDefinitionVersion.EnvironmentProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnFunctionDefinitionVersion.ExecutionProperty
class CfnFunctionDefinitionVersion_ExecutionPropertyDef(BaseStruct):
    isolation_mode: typing.Optional[str] = pydantic.Field(None, description='The containerization that the Lambda function runs in. Valid values are ``GreengrassContainer`` or ``NoContainer`` . Typically, this is ``GreengrassContainer`` . For more information, see `Containerization <https://docs.aws.amazon.com/greengrass/latest/developerguide/lambda-group-config.html#lambda-function-containerization>`_ in the *Developer Guide* . - When set on the ```DefaultConfig`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinitionversion-defaultconfig.html>`_ property of a function definition version, this setting is used as the default containerization for all Lambda functions in the function definition version. - When set on the ```Environment`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinitionversion-environment.html>`_ property of a function, this setting applies to the individual function and overrides the default. Omit this value to run the function with the default containerization. .. epigraph:: We recommend that you run in a Greengrass container unless your business case requires that you run without containerization.\n')
    run_as: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinitionVersion_RunAsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The user and group permissions used to run the Lambda function. Typically, this is the ggc_user and ggc_group. For more information, see `Run as <https://docs.aws.amazon.com/greengrass/latest/developerguide/lambda-group-config.html#lambda-access-identity.html>`_ in the *Developer Guide* . - When set on the ```DefaultConfig`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinitionversion-defaultconfig.html>`_ property of a function definition version, this setting is used as the default access identity for all Lambda functions in the function definition version. - When set on the ```Environment`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinitionversion-environment.html>`_ property of a function, this setting applies to the individual function and overrides the default. You can override the user, group, or both. Omit this value to run the function with the default permissions. .. epigraph:: Running as the root user increases risks to your data and device. Do not run as root (UID/GID=0) unless your business case requires it. For more information and requirements, see `Running a Lambda Function as Root <https://docs.aws.amazon.com/greengrass/latest/developerguide/lambda-group-config.html#lambda-running-as-root>`_ .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinitionversion-execution.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    execution_property = greengrass.CfnFunctionDefinitionVersion.ExecutionProperty(\n        isolation_mode="isolationMode",\n        run_as=greengrass.CfnFunctionDefinitionVersion.RunAsProperty(\n            gid=123,\n            uid=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['isolation_mode', 'run_as']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnFunctionDefinitionVersion.ExecutionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnFunctionDefinitionVersion.FunctionConfigurationProperty
class CfnFunctionDefinitionVersion_FunctionConfigurationPropertyDef(BaseStruct):
    encoding_type: typing.Optional[str] = pydantic.Field(None, description='The expected encoding type of the input payload for the function. Valid values are ``json`` (default) and ``binary`` .\n')
    environment: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinitionVersion_EnvironmentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The environment configuration of the function.\n')
    exec_args: typing.Optional[str] = pydantic.Field(None, description='The execution arguments.\n')
    executable: typing.Optional[str] = pydantic.Field(None, description='The name of the function executable.\n')
    memory_size: typing.Union[int, float, None] = pydantic.Field(None, description='The memory size (in KB) required by the function. .. epigraph:: This property applies only to Lambda functions that run in a Greengrass container.\n')
    pinned: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='Indicates whether the function is pinned (or *long-lived* ). Pinned functions start when the core starts and process all requests in the same container. The default value is false.\n')
    timeout: typing.Union[int, float, None] = pydantic.Field(None, description='The allowed execution time (in seconds) after which the function should terminate. For pinned functions, this timeout applies for each request.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinitionversion-functionconfiguration.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    # variables: Any\n\n    function_configuration_property = greengrass.CfnFunctionDefinitionVersion.FunctionConfigurationProperty(\n        encoding_type="encodingType",\n        environment=greengrass.CfnFunctionDefinitionVersion.EnvironmentProperty(\n            access_sysfs=False,\n            execution=greengrass.CfnFunctionDefinitionVersion.ExecutionProperty(\n                isolation_mode="isolationMode",\n                run_as=greengrass.CfnFunctionDefinitionVersion.RunAsProperty(\n                    gid=123,\n                    uid=123\n                )\n            ),\n            resource_access_policies=[greengrass.CfnFunctionDefinitionVersion.ResourceAccessPolicyProperty(\n                resource_id="resourceId",\n\n                # the properties below are optional\n                permission="permission"\n            )],\n            variables=variables\n        ),\n        exec_args="execArgs",\n        executable="executable",\n        memory_size=123,\n        pinned=False,\n        timeout=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['encoding_type', 'environment', 'exec_args', 'executable', 'memory_size', 'pinned', 'timeout']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnFunctionDefinitionVersion.FunctionConfigurationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnFunctionDefinitionVersion.FunctionProperty
class CfnFunctionDefinitionVersion_FunctionPropertyDef(BaseStruct):
    function_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the alias (recommended) or version of the referenced Lambda function.\n')
    function_configuration: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinitionVersion_FunctionConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description="The group-specific settings of the Lambda function. These settings configure the function's behavior in the Greengrass group.\n")
    _init_params: typing.ClassVar[list[str]] = ['function_arn', 'function_configuration']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnFunctionDefinitionVersion.FunctionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnFunctionDefinitionVersion.ResourceAccessPolicyProperty
class CfnFunctionDefinitionVersion_ResourceAccessPolicyPropertyDef(BaseStruct):
    resource_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the resource. This ID is assigned to the resource when you create the resource definition.\n')
    permission: typing.Optional[str] = pydantic.Field(None, description='The read-only or read-write access that the Lambda function has to the resource. Valid values are ``ro`` or ``rw`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinitionversion-resourceaccesspolicy.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    resource_access_policy_property = greengrass.CfnFunctionDefinitionVersion.ResourceAccessPolicyProperty(\n        resource_id="resourceId",\n\n        # the properties below are optional\n        permission="permission"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resource_id', 'permission']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnFunctionDefinitionVersion.ResourceAccessPolicyProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnFunctionDefinitionVersion.RunAsProperty
class CfnFunctionDefinitionVersion_RunAsPropertyDef(BaseStruct):
    gid: typing.Union[int, float, None] = pydantic.Field(None, description='The group ID whose permissions are used to run the Lambda function. You can use the ``getent group`` command on your core device to look up the group ID.\n')
    uid: typing.Union[int, float, None] = pydantic.Field(None, description='The user ID whose permissions are used to run the Lambda function. You can use the ``getent passwd`` command on your core device to look up the user ID.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinitionversion-runas.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    run_as_property = greengrass.CfnFunctionDefinitionVersion.RunAsProperty(\n        gid=123,\n        uid=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['gid', 'uid']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnFunctionDefinitionVersion.RunAsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnGroup.GroupVersionProperty
class CfnGroup_GroupVersionPropertyDef(BaseStruct):
    connector_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the connector definition version that contains the connectors you want to deploy with the group version.\n')
    core_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the core definition version that contains the core you want to deploy with the group version. Currently, the core definition version can contain only one core.\n')
    device_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the device definition version that contains the devices you want to deploy with the group version.\n')
    function_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the function definition version that contains the functions you want to deploy with the group version.\n')
    logger_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the logger definition version that contains the loggers you want to deploy with the group version.\n')
    resource_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the resource definition version that contains the resources you want to deploy with the group version.\n')
    subscription_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the subscription definition version that contains the subscriptions you want to deploy with the group version.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-group-groupversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    group_version_property = greengrass.CfnGroup.GroupVersionProperty(\n        connector_definition_version_arn="connectorDefinitionVersionArn",\n        core_definition_version_arn="coreDefinitionVersionArn",\n        device_definition_version_arn="deviceDefinitionVersionArn",\n        function_definition_version_arn="functionDefinitionVersionArn",\n        logger_definition_version_arn="loggerDefinitionVersionArn",\n        resource_definition_version_arn="resourceDefinitionVersionArn",\n        subscription_definition_version_arn="subscriptionDefinitionVersionArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connector_definition_version_arn', 'core_definition_version_arn', 'device_definition_version_arn', 'function_definition_version_arn', 'logger_definition_version_arn', 'resource_definition_version_arn', 'subscription_definition_version_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnGroup.GroupVersionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnLoggerDefinition.LoggerDefinitionVersionProperty
class CfnLoggerDefinition_LoggerDefinitionVersionPropertyDef(BaseStruct):
    loggers: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnLoggerDefinition_LoggerPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The loggers in this version.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-loggerdefinition-loggerdefinitionversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    logger_definition_version_property = greengrass.CfnLoggerDefinition.LoggerDefinitionVersionProperty(\n        loggers=[greengrass.CfnLoggerDefinition.LoggerProperty(\n            component="component",\n            id="id",\n            level="level",\n            type="type",\n\n            # the properties below are optional\n            space=123\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['loggers']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnLoggerDefinition.LoggerDefinitionVersionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnLoggerDefinition.LoggerProperty
class CfnLoggerDefinition_LoggerPropertyDef(BaseStruct):
    component: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The source of the log event. Valid values are ``GreengrassSystem`` or ``Lambda`` . When ``GreengrassSystem`` is used, events from Greengrass system components are logged. When ``Lambda`` is used, events from user-defined Lambda functions are logged.\n')
    level: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The log-level threshold. Log events below this threshold are filtered out and aren't stored. Valid values are ``DEBUG`` , ``INFO`` (recommended), ``WARN`` , ``ERROR`` , or ``FATAL`` .\n")
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The storage mechanism for log events. Valid values are ``FileSystem`` or ``AWSCloudWatch`` . When ``AWSCloudWatch`` is used, log events are sent to CloudWatch Logs . When ``FileSystem`` is used, log events are stored on the local file system.\n')
    space: typing.Union[int, float, None] = pydantic.Field(None, description='The amount of file space (in KB) to use when writing logs to the local file system. This property does not apply for CloudWatch Logs .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-loggerdefinition-logger.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    logger_property = greengrass.CfnLoggerDefinition.LoggerProperty(\n        component="component",\n        id="id",\n        level="level",\n        type="type",\n\n        # the properties below are optional\n        space=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['component', 'level', 'type', 'space']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnLoggerDefinition.LoggerProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnLoggerDefinitionVersion.LoggerProperty
class CfnLoggerDefinitionVersion_LoggerPropertyDef(BaseStruct):
    component: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The source of the log event. Valid values are ``GreengrassSystem`` or ``Lambda`` . When ``GreengrassSystem`` is used, events from Greengrass system components are logged. When ``Lambda`` is used, events from user-defined Lambda functions are logged.\n')
    level: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The log-level threshold. Log events below this threshold are filtered out and aren't stored. Valid values are ``DEBUG`` , ``INFO`` (recommended), ``WARN`` , ``ERROR`` , or ``FATAL`` .\n")
    type: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The storage mechanism for log events. Valid values are ``FileSystem`` or ``AWSCloudWatch`` . When ``AWSCloudWatch`` is used, log events are sent to CloudWatch Logs . When ``FileSystem`` is used, log events are stored on the local file system.\n')
    space: typing.Union[int, float, None] = pydantic.Field(None, description='The amount of file space (in KB) to use when writing logs to the local file system. This property does not apply for CloudWatch Logs .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-loggerdefinitionversion-logger.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    logger_property = greengrass.CfnLoggerDefinitionVersion.LoggerProperty(\n        component="component",\n        id="id",\n        level="level",\n        type="type",\n\n        # the properties below are optional\n        space=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['component', 'level', 'type', 'space']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnLoggerDefinitionVersion.LoggerProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinition.GroupOwnerSettingProperty
class CfnResourceDefinition_GroupOwnerSettingPropertyDef(BaseStruct):
    auto_add_group_owner: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='Indicates whether to give the privileges of the Linux group that owns the resource to the Lambda process. This gives the Lambda process the file access permissions of the Linux group.\n')
    group_owner: typing.Optional[str] = pydantic.Field(None, description='The name of the Linux group whose privileges you want to add to the Lambda process. This value is ignored if ``AutoAddGroupOwner`` is true.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinition-groupownersetting.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    group_owner_setting_property = greengrass.CfnResourceDefinition.GroupOwnerSettingProperty(\n        auto_add_group_owner=False,\n\n        # the properties below are optional\n        group_owner="groupOwner"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['auto_add_group_owner', 'group_owner']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinition.GroupOwnerSettingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinition.LocalDeviceResourceDataProperty
class CfnResourceDefinition_LocalDeviceResourceDataPropertyDef(BaseStruct):
    source_path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The local absolute path of the device resource. The source path for a device resource can refer only to a character device or block device under ``/dev`` .\n')
    group_owner_setting: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_GroupOwnerSettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings that define additional Linux OS group permissions to give to the Lambda function process.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinition-localdeviceresourcedata.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    local_device_resource_data_property = greengrass.CfnResourceDefinition.LocalDeviceResourceDataProperty(\n        source_path="sourcePath",\n\n        # the properties below are optional\n        group_owner_setting=greengrass.CfnResourceDefinition.GroupOwnerSettingProperty(\n            auto_add_group_owner=False,\n\n            # the properties below are optional\n            group_owner="groupOwner"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['source_path', 'group_owner_setting']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinition.LocalDeviceResourceDataProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinition.LocalVolumeResourceDataProperty
class CfnResourceDefinition_LocalVolumeResourceDataPropertyDef(BaseStruct):
    destination_path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The absolute local path of the resource in the Lambda environment.\n')
    source_path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The local absolute path of the volume resource on the host. The source path for a volume resource type cannot start with ``/sys`` .\n')
    group_owner_setting: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_GroupOwnerSettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings that define additional Linux OS group permissions to give to the Lambda function process.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinition-localvolumeresourcedata.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    local_volume_resource_data_property = greengrass.CfnResourceDefinition.LocalVolumeResourceDataProperty(\n        destination_path="destinationPath",\n        source_path="sourcePath",\n\n        # the properties below are optional\n        group_owner_setting=greengrass.CfnResourceDefinition.GroupOwnerSettingProperty(\n            auto_add_group_owner=False,\n\n            # the properties below are optional\n            group_owner="groupOwner"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_path', 'source_path', 'group_owner_setting']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinition.LocalVolumeResourceDataProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinition.ResourceDataContainerProperty
class CfnResourceDefinition_ResourceDataContainerPropertyDef(BaseStruct):
    local_device_resource_data: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_LocalDeviceResourceDataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for a local device resource.\n')
    local_volume_resource_data: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_LocalVolumeResourceDataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for a local volume resource.\n')
    s3_machine_learning_model_resource_data: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_S3MachineLearningModelResourceDataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for a machine learning resource stored in Amazon S3 .\n')
    sage_maker_machine_learning_model_resource_data: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_SageMakerMachineLearningModelResourceDataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for a machine learning resource saved as an SageMaker training job.\n')
    secrets_manager_secret_resource_data: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_SecretsManagerSecretResourceDataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for a secret resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinition-resourcedatacontainer.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    resource_data_container_property = greengrass.CfnResourceDefinition.ResourceDataContainerProperty(\n        local_device_resource_data=greengrass.CfnResourceDefinition.LocalDeviceResourceDataProperty(\n            source_path="sourcePath",\n\n            # the properties below are optional\n            group_owner_setting=greengrass.CfnResourceDefinition.GroupOwnerSettingProperty(\n                auto_add_group_owner=False,\n\n                # the properties below are optional\n                group_owner="groupOwner"\n            )\n        ),\n        local_volume_resource_data=greengrass.CfnResourceDefinition.LocalVolumeResourceDataProperty(\n            destination_path="destinationPath",\n            source_path="sourcePath",\n\n            # the properties below are optional\n            group_owner_setting=greengrass.CfnResourceDefinition.GroupOwnerSettingProperty(\n                auto_add_group_owner=False,\n\n                # the properties below are optional\n                group_owner="groupOwner"\n            )\n        ),\n        s3_machine_learning_model_resource_data=greengrass.CfnResourceDefinition.S3MachineLearningModelResourceDataProperty(\n            destination_path="destinationPath",\n            s3_uri="s3Uri",\n\n            # the properties below are optional\n            owner_setting=greengrass.CfnResourceDefinition.ResourceDownloadOwnerSettingProperty(\n                group_owner="groupOwner",\n                group_permission="groupPermission"\n            )\n        ),\n        sage_maker_machine_learning_model_resource_data=greengrass.CfnResourceDefinition.SageMakerMachineLearningModelResourceDataProperty(\n            destination_path="destinationPath",\n            sage_maker_job_arn="sageMakerJobArn",\n\n            # the properties below are optional\n            owner_setting=greengrass.CfnResourceDefinition.ResourceDownloadOwnerSettingProperty(\n                group_owner="groupOwner",\n                group_permission="groupPermission"\n            )\n        ),\n        secrets_manager_secret_resource_data=greengrass.CfnResourceDefinition.SecretsManagerSecretResourceDataProperty(\n            arn="arn",\n\n            # the properties below are optional\n            additional_staging_labels_to_download=["additionalStagingLabelsToDownload"]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['local_device_resource_data', 'local_volume_resource_data', 's3_machine_learning_model_resource_data', 'sage_maker_machine_learning_model_resource_data', 'secrets_manager_secret_resource_data']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinition.ResourceDataContainerProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinition.ResourceDefinitionVersionProperty
class CfnResourceDefinition_ResourceDefinitionVersionPropertyDef(BaseStruct):
    resources: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_ResourceInstancePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The resources in this version.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinition-resourcedefinitionversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    resource_definition_version_property = greengrass.CfnResourceDefinition.ResourceDefinitionVersionProperty(\n        resources=[greengrass.CfnResourceDefinition.ResourceInstanceProperty(\n            id="id",\n            name="name",\n            resource_data_container=greengrass.CfnResourceDefinition.ResourceDataContainerProperty(\n                local_device_resource_data=greengrass.CfnResourceDefinition.LocalDeviceResourceDataProperty(\n                    source_path="sourcePath",\n\n                    # the properties below are optional\n                    group_owner_setting=greengrass.CfnResourceDefinition.GroupOwnerSettingProperty(\n                        auto_add_group_owner=False,\n\n                        # the properties below are optional\n                        group_owner="groupOwner"\n                    )\n                ),\n                local_volume_resource_data=greengrass.CfnResourceDefinition.LocalVolumeResourceDataProperty(\n                    destination_path="destinationPath",\n                    source_path="sourcePath",\n\n                    # the properties below are optional\n                    group_owner_setting=greengrass.CfnResourceDefinition.GroupOwnerSettingProperty(\n                        auto_add_group_owner=False,\n\n                        # the properties below are optional\n                        group_owner="groupOwner"\n                    )\n                ),\n                s3_machine_learning_model_resource_data=greengrass.CfnResourceDefinition.S3MachineLearningModelResourceDataProperty(\n                    destination_path="destinationPath",\n                    s3_uri="s3Uri",\n\n                    # the properties below are optional\n                    owner_setting=greengrass.CfnResourceDefinition.ResourceDownloadOwnerSettingProperty(\n                        group_owner="groupOwner",\n                        group_permission="groupPermission"\n                    )\n                ),\n                sage_maker_machine_learning_model_resource_data=greengrass.CfnResourceDefinition.SageMakerMachineLearningModelResourceDataProperty(\n                    destination_path="destinationPath",\n                    sage_maker_job_arn="sageMakerJobArn",\n\n                    # the properties below are optional\n                    owner_setting=greengrass.CfnResourceDefinition.ResourceDownloadOwnerSettingProperty(\n                        group_owner="groupOwner",\n                        group_permission="groupPermission"\n                    )\n                ),\n                secrets_manager_secret_resource_data=greengrass.CfnResourceDefinition.SecretsManagerSecretResourceDataProperty(\n                    arn="arn",\n\n                    # the properties below are optional\n                    additional_staging_labels_to_download=["additionalStagingLabelsToDownload"]\n                )\n            )\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resources']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinition.ResourceDefinitionVersionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinition.ResourceDownloadOwnerSettingProperty
class CfnResourceDefinition_ResourceDownloadOwnerSettingPropertyDef(BaseStruct):
    group_owner: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The group owner of the machine learning resource. This is the group ID (GID) of an existing Linux OS group on the system. The group's permissions are added to the Lambda process.\n")
    group_permission: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The permissions that the group owner has to the machine learning resource. Valid values are ``rw`` (read-write) or ``ro`` (read-only).\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinition-resourcedownloadownersetting.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    resource_download_owner_setting_property = greengrass.CfnResourceDefinition.ResourceDownloadOwnerSettingProperty(\n        group_owner="groupOwner",\n        group_permission="groupPermission"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['group_owner', 'group_permission']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinition.ResourceDownloadOwnerSettingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinition.ResourceInstanceProperty
class CfnResourceDefinition_ResourceInstancePropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The descriptive resource name, which is displayed on the AWS IoT Greengrass console. Maximum length 128 characters with pattern [a-zA-Z0-9:_-]+. This must be unique within a Greengrass group.\n')
    resource_data_container: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_ResourceDataContainerPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A container for resource data. The container takes only one of the following supported resource data types: ``LocalDeviceResourceData`` , ``LocalVolumeResourceData`` , ``SageMakerMachineLearningModelResourceData`` , ``S3MachineLearningModelResourceData`` , or ``SecretsManagerSecretResourceData`` . .. epigraph:: Only one resource type can be defined for a ``ResourceDataContainer`` instance.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinition-resourceinstance.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    resource_instance_property = greengrass.CfnResourceDefinition.ResourceInstanceProperty(\n        id="id",\n        name="name",\n        resource_data_container=greengrass.CfnResourceDefinition.ResourceDataContainerProperty(\n            local_device_resource_data=greengrass.CfnResourceDefinition.LocalDeviceResourceDataProperty(\n                source_path="sourcePath",\n\n                # the properties below are optional\n                group_owner_setting=greengrass.CfnResourceDefinition.GroupOwnerSettingProperty(\n                    auto_add_group_owner=False,\n\n                    # the properties below are optional\n                    group_owner="groupOwner"\n                )\n            ),\n            local_volume_resource_data=greengrass.CfnResourceDefinition.LocalVolumeResourceDataProperty(\n                destination_path="destinationPath",\n                source_path="sourcePath",\n\n                # the properties below are optional\n                group_owner_setting=greengrass.CfnResourceDefinition.GroupOwnerSettingProperty(\n                    auto_add_group_owner=False,\n\n                    # the properties below are optional\n                    group_owner="groupOwner"\n                )\n            ),\n            s3_machine_learning_model_resource_data=greengrass.CfnResourceDefinition.S3MachineLearningModelResourceDataProperty(\n                destination_path="destinationPath",\n                s3_uri="s3Uri",\n\n                # the properties below are optional\n                owner_setting=greengrass.CfnResourceDefinition.ResourceDownloadOwnerSettingProperty(\n                    group_owner="groupOwner",\n                    group_permission="groupPermission"\n                )\n            ),\n            sage_maker_machine_learning_model_resource_data=greengrass.CfnResourceDefinition.SageMakerMachineLearningModelResourceDataProperty(\n                destination_path="destinationPath",\n                sage_maker_job_arn="sageMakerJobArn",\n\n                # the properties below are optional\n                owner_setting=greengrass.CfnResourceDefinition.ResourceDownloadOwnerSettingProperty(\n                    group_owner="groupOwner",\n                    group_permission="groupPermission"\n                )\n            ),\n            secrets_manager_secret_resource_data=greengrass.CfnResourceDefinition.SecretsManagerSecretResourceDataProperty(\n                arn="arn",\n\n                # the properties below are optional\n                additional_staging_labels_to_download=["additionalStagingLabelsToDownload"]\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'resource_data_container']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinition.ResourceInstanceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinition.S3MachineLearningModelResourceDataProperty
class CfnResourceDefinition_S3MachineLearningModelResourceDataPropertyDef(BaseStruct):
    destination_path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The absolute local path of the resource inside the Lambda environment.\n')
    s3_uri: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The URI of the source model in an Amazon S3 bucket. The model package must be in ``tar.gz`` or ``.zip`` format.\n')
    owner_setting: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_ResourceDownloadOwnerSettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The owner setting for the downloaded machine learning resource. For more information, see `Access Machine Learning Resources from Lambda Functions <https://docs.aws.amazon.com/greengrass/latest/developerguide/access-ml-resources.html>`_ in the *Developer Guide* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinition-s3machinelearningmodelresourcedata.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    s3_machine_learning_model_resource_data_property = greengrass.CfnResourceDefinition.S3MachineLearningModelResourceDataProperty(\n        destination_path="destinationPath",\n        s3_uri="s3Uri",\n\n        # the properties below are optional\n        owner_setting=greengrass.CfnResourceDefinition.ResourceDownloadOwnerSettingProperty(\n            group_owner="groupOwner",\n            group_permission="groupPermission"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_path', 's3_uri', 'owner_setting']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinition.S3MachineLearningModelResourceDataProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinition.SageMakerMachineLearningModelResourceDataProperty
class CfnResourceDefinition_SageMakerMachineLearningModelResourceDataPropertyDef(BaseStruct):
    destination_path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The absolute local path of the resource inside the Lambda environment.\n')
    sage_maker_job_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the Amazon SageMaker training job that represents the source model.\n')
    owner_setting: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_ResourceDownloadOwnerSettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The owner setting for the downloaded machine learning resource. For more information, see `Access Machine Learning Resources from Lambda Functions <https://docs.aws.amazon.com/greengrass/latest/developerguide/access-ml-resources.html>`_ in the *Developer Guide* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinition-sagemakermachinelearningmodelresourcedata.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    sage_maker_machine_learning_model_resource_data_property = greengrass.CfnResourceDefinition.SageMakerMachineLearningModelResourceDataProperty(\n        destination_path="destinationPath",\n        sage_maker_job_arn="sageMakerJobArn",\n\n        # the properties below are optional\n        owner_setting=greengrass.CfnResourceDefinition.ResourceDownloadOwnerSettingProperty(\n            group_owner="groupOwner",\n            group_permission="groupPermission"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_path', 'sage_maker_job_arn', 'owner_setting']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinition.SageMakerMachineLearningModelResourceDataProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinition.SecretsManagerSecretResourceDataProperty
class CfnResourceDefinition_SecretsManagerSecretResourceDataPropertyDef(BaseStruct):
    arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The Amazon Resource Name (ARN) of the Secrets Manager secret to make available on the core. The value of the secret's latest version (represented by the ``AWSCURRENT`` staging label) is included by default.\n")
    additional_staging_labels_to_download: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The staging labels whose values you want to make available on the core, in addition to ``AWSCURRENT`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinition-secretsmanagersecretresourcedata.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    secrets_manager_secret_resource_data_property = greengrass.CfnResourceDefinition.SecretsManagerSecretResourceDataProperty(\n        arn="arn",\n\n        # the properties below are optional\n        additional_staging_labels_to_download=["additionalStagingLabelsToDownload"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['arn', 'additional_staging_labels_to_download']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinition.SecretsManagerSecretResourceDataProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinitionVersion.GroupOwnerSettingProperty
class CfnResourceDefinitionVersion_GroupOwnerSettingPropertyDef(BaseStruct):
    auto_add_group_owner: typing.Union[_REQUIRED_INIT_PARAM, bool, models.UnsupportedResource] = pydantic.Field(REQUIRED_INIT_PARAM, description='Indicates whether to give the privileges of the Linux group that owns the resource to the Lambda process. This gives the Lambda process the file access permissions of the Linux group.\n')
    group_owner: typing.Optional[str] = pydantic.Field(None, description='The name of the Linux group whose privileges you want to add to the Lambda process. This value is ignored if ``AutoAddGroupOwner`` is true.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinitionversion-groupownersetting.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    group_owner_setting_property = greengrass.CfnResourceDefinitionVersion.GroupOwnerSettingProperty(\n        auto_add_group_owner=False,\n\n        # the properties below are optional\n        group_owner="groupOwner"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['auto_add_group_owner', 'group_owner']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinitionVersion.GroupOwnerSettingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinitionVersion.LocalDeviceResourceDataProperty
class CfnResourceDefinitionVersion_LocalDeviceResourceDataPropertyDef(BaseStruct):
    source_path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The local absolute path of the device resource. The source path for a device resource can refer only to a character device or block device under ``/dev`` .\n')
    group_owner_setting: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_GroupOwnerSettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings that define additional Linux OS group permissions to give to the Lambda function process.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinitionversion-localdeviceresourcedata.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    local_device_resource_data_property = greengrass.CfnResourceDefinitionVersion.LocalDeviceResourceDataProperty(\n        source_path="sourcePath",\n\n        # the properties below are optional\n        group_owner_setting=greengrass.CfnResourceDefinitionVersion.GroupOwnerSettingProperty(\n            auto_add_group_owner=False,\n\n            # the properties below are optional\n            group_owner="groupOwner"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['source_path', 'group_owner_setting']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinitionVersion.LocalDeviceResourceDataProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinitionVersion.LocalVolumeResourceDataProperty
class CfnResourceDefinitionVersion_LocalVolumeResourceDataPropertyDef(BaseStruct):
    destination_path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The absolute local path of the resource in the Lambda environment.\n')
    source_path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The local absolute path of the volume resource on the host. The source path for a volume resource type cannot start with ``/sys`` .\n')
    group_owner_setting: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_GroupOwnerSettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings that define additional Linux OS group permissions to give to the Lambda function process.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinitionversion-localvolumeresourcedata.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    local_volume_resource_data_property = greengrass.CfnResourceDefinitionVersion.LocalVolumeResourceDataProperty(\n        destination_path="destinationPath",\n        source_path="sourcePath",\n\n        # the properties below are optional\n        group_owner_setting=greengrass.CfnResourceDefinitionVersion.GroupOwnerSettingProperty(\n            auto_add_group_owner=False,\n\n            # the properties below are optional\n            group_owner="groupOwner"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_path', 'source_path', 'group_owner_setting']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinitionVersion.LocalVolumeResourceDataProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinitionVersion.ResourceDataContainerProperty
class CfnResourceDefinitionVersion_ResourceDataContainerPropertyDef(BaseStruct):
    local_device_resource_data: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_LocalDeviceResourceDataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for a local device resource.\n')
    local_volume_resource_data: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_LocalVolumeResourceDataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for a local volume resource.\n')
    s3_machine_learning_model_resource_data: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_S3MachineLearningModelResourceDataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for a machine learning resource stored in Amazon S3 .\n')
    sage_maker_machine_learning_model_resource_data: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_SageMakerMachineLearningModelResourceDataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for a machine learning resource saved as an SageMaker training job.\n')
    secrets_manager_secret_resource_data: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_SecretsManagerSecretResourceDataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Settings for a secret resource.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinitionversion-resourcedatacontainer.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    resource_data_container_property = greengrass.CfnResourceDefinitionVersion.ResourceDataContainerProperty(\n        local_device_resource_data=greengrass.CfnResourceDefinitionVersion.LocalDeviceResourceDataProperty(\n            source_path="sourcePath",\n\n            # the properties below are optional\n            group_owner_setting=greengrass.CfnResourceDefinitionVersion.GroupOwnerSettingProperty(\n                auto_add_group_owner=False,\n\n                # the properties below are optional\n                group_owner="groupOwner"\n            )\n        ),\n        local_volume_resource_data=greengrass.CfnResourceDefinitionVersion.LocalVolumeResourceDataProperty(\n            destination_path="destinationPath",\n            source_path="sourcePath",\n\n            # the properties below are optional\n            group_owner_setting=greengrass.CfnResourceDefinitionVersion.GroupOwnerSettingProperty(\n                auto_add_group_owner=False,\n\n                # the properties below are optional\n                group_owner="groupOwner"\n            )\n        ),\n        s3_machine_learning_model_resource_data=greengrass.CfnResourceDefinitionVersion.S3MachineLearningModelResourceDataProperty(\n            destination_path="destinationPath",\n            s3_uri="s3Uri",\n\n            # the properties below are optional\n            owner_setting=greengrass.CfnResourceDefinitionVersion.ResourceDownloadOwnerSettingProperty(\n                group_owner="groupOwner",\n                group_permission="groupPermission"\n            )\n        ),\n        sage_maker_machine_learning_model_resource_data=greengrass.CfnResourceDefinitionVersion.SageMakerMachineLearningModelResourceDataProperty(\n            destination_path="destinationPath",\n            sage_maker_job_arn="sageMakerJobArn",\n\n            # the properties below are optional\n            owner_setting=greengrass.CfnResourceDefinitionVersion.ResourceDownloadOwnerSettingProperty(\n                group_owner="groupOwner",\n                group_permission="groupPermission"\n            )\n        ),\n        secrets_manager_secret_resource_data=greengrass.CfnResourceDefinitionVersion.SecretsManagerSecretResourceDataProperty(\n            arn="arn",\n\n            # the properties below are optional\n            additional_staging_labels_to_download=["additionalStagingLabelsToDownload"]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['local_device_resource_data', 'local_volume_resource_data', 's3_machine_learning_model_resource_data', 'sage_maker_machine_learning_model_resource_data', 'secrets_manager_secret_resource_data']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinitionVersion.ResourceDataContainerProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinitionVersion.ResourceDownloadOwnerSettingProperty
class CfnResourceDefinitionVersion_ResourceDownloadOwnerSettingPropertyDef(BaseStruct):
    group_owner: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The group owner of the machine learning resource. This is the group ID (GID) of an existing Linux OS group on the system. The group's permissions are added to the Lambda process.\n")
    group_permission: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The permissions that the group owner has to the machine learning resource. Valid values are ``rw`` (read-write) or ``ro`` (read-only).\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinitionversion-resourcedownloadownersetting.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    resource_download_owner_setting_property = greengrass.CfnResourceDefinitionVersion.ResourceDownloadOwnerSettingProperty(\n        group_owner="groupOwner",\n        group_permission="groupPermission"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['group_owner', 'group_permission']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinitionVersion.ResourceDownloadOwnerSettingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinitionVersion.ResourceInstanceProperty
class CfnResourceDefinitionVersion_ResourceInstancePropertyDef(BaseStruct):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The descriptive resource name, which is displayed on the AWS IoT Greengrass console. Maximum length 128 characters with pattern [a-zA-Z0-9:_-]+. This must be unique within a Greengrass group.\n')
    resource_data_container: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_ResourceDataContainerPropertyDef, dict[str, typing.Any]] = pydantic.Field(REQUIRED_INIT_PARAM, description='A container for resource data. The container takes only one of the following supported resource data types: ``LocalDeviceResourceData`` , ``LocalVolumeResourceData`` , ``SageMakerMachineLearningModelResourceData`` , ``S3MachineLearningModelResourceData`` , or ``SecretsManagerSecretResourceData`` . .. epigraph:: Only one resource type can be defined for a ``ResourceDataContainer`` instance.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinitionversion-resourceinstance.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    resource_instance_property = greengrass.CfnResourceDefinitionVersion.ResourceInstanceProperty(\n        id="id",\n        name="name",\n        resource_data_container=greengrass.CfnResourceDefinitionVersion.ResourceDataContainerProperty(\n            local_device_resource_data=greengrass.CfnResourceDefinitionVersion.LocalDeviceResourceDataProperty(\n                source_path="sourcePath",\n\n                # the properties below are optional\n                group_owner_setting=greengrass.CfnResourceDefinitionVersion.GroupOwnerSettingProperty(\n                    auto_add_group_owner=False,\n\n                    # the properties below are optional\n                    group_owner="groupOwner"\n                )\n            ),\n            local_volume_resource_data=greengrass.CfnResourceDefinitionVersion.LocalVolumeResourceDataProperty(\n                destination_path="destinationPath",\n                source_path="sourcePath",\n\n                # the properties below are optional\n                group_owner_setting=greengrass.CfnResourceDefinitionVersion.GroupOwnerSettingProperty(\n                    auto_add_group_owner=False,\n\n                    # the properties below are optional\n                    group_owner="groupOwner"\n                )\n            ),\n            s3_machine_learning_model_resource_data=greengrass.CfnResourceDefinitionVersion.S3MachineLearningModelResourceDataProperty(\n                destination_path="destinationPath",\n                s3_uri="s3Uri",\n\n                # the properties below are optional\n                owner_setting=greengrass.CfnResourceDefinitionVersion.ResourceDownloadOwnerSettingProperty(\n                    group_owner="groupOwner",\n                    group_permission="groupPermission"\n                )\n            ),\n            sage_maker_machine_learning_model_resource_data=greengrass.CfnResourceDefinitionVersion.SageMakerMachineLearningModelResourceDataProperty(\n                destination_path="destinationPath",\n                sage_maker_job_arn="sageMakerJobArn",\n\n                # the properties below are optional\n                owner_setting=greengrass.CfnResourceDefinitionVersion.ResourceDownloadOwnerSettingProperty(\n                    group_owner="groupOwner",\n                    group_permission="groupPermission"\n                )\n            ),\n            secrets_manager_secret_resource_data=greengrass.CfnResourceDefinitionVersion.SecretsManagerSecretResourceDataProperty(\n                arn="arn",\n\n                # the properties below are optional\n                additional_staging_labels_to_download=["additionalStagingLabelsToDownload"]\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'resource_data_container']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinitionVersion.ResourceInstanceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinitionVersion.S3MachineLearningModelResourceDataProperty
class CfnResourceDefinitionVersion_S3MachineLearningModelResourceDataPropertyDef(BaseStruct):
    destination_path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The absolute local path of the resource inside the Lambda environment.\n')
    s3_uri: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The URI of the source model in an Amazon S3 bucket. The model package must be in ``tar.gz`` or ``.zip`` format.\n')
    owner_setting: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_ResourceDownloadOwnerSettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The owner setting for the downloaded machine learning resource. For more information, see `Access Machine Learning Resources from Lambda Functions <https://docs.aws.amazon.com/greengrass/latest/developerguide/access-ml-resources.html>`_ in the *Developer Guide* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinitionversion-s3machinelearningmodelresourcedata.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    s3_machine_learning_model_resource_data_property = greengrass.CfnResourceDefinitionVersion.S3MachineLearningModelResourceDataProperty(\n        destination_path="destinationPath",\n        s3_uri="s3Uri",\n\n        # the properties below are optional\n        owner_setting=greengrass.CfnResourceDefinitionVersion.ResourceDownloadOwnerSettingProperty(\n            group_owner="groupOwner",\n            group_permission="groupPermission"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_path', 's3_uri', 'owner_setting']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinitionVersion.S3MachineLearningModelResourceDataProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinitionVersion.SageMakerMachineLearningModelResourceDataProperty
class CfnResourceDefinitionVersion_SageMakerMachineLearningModelResourceDataPropertyDef(BaseStruct):
    destination_path: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The absolute local path of the resource inside the Lambda environment.\n')
    sage_maker_job_arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Amazon Resource Name (ARN) of the Amazon SageMaker training job that represents the source model.\n')
    owner_setting: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_ResourceDownloadOwnerSettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The owner setting for the downloaded machine learning resource. For more information, see `Access Machine Learning Resources from Lambda Functions <https://docs.aws.amazon.com/greengrass/latest/developerguide/access-ml-resources.html>`_ in the *Developer Guide* .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinitionversion-sagemakermachinelearningmodelresourcedata.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    sage_maker_machine_learning_model_resource_data_property = greengrass.CfnResourceDefinitionVersion.SageMakerMachineLearningModelResourceDataProperty(\n        destination_path="destinationPath",\n        sage_maker_job_arn="sageMakerJobArn",\n\n        # the properties below are optional\n        owner_setting=greengrass.CfnResourceDefinitionVersion.ResourceDownloadOwnerSettingProperty(\n            group_owner="groupOwner",\n            group_permission="groupPermission"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_path', 'sage_maker_job_arn', 'owner_setting']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinitionVersion.SageMakerMachineLearningModelResourceDataProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinitionVersion.SecretsManagerSecretResourceDataProperty
class CfnResourceDefinitionVersion_SecretsManagerSecretResourceDataPropertyDef(BaseStruct):
    arn: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description="The Amazon Resource Name (ARN) of the Secrets Manager secret to make available on the core. The value of the secret's latest version (represented by the ``AWSCURRENT`` staging label) is included by default.\n")
    additional_staging_labels_to_download: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The staging labels whose values you want to make available on the core, in addition to ``AWSCURRENT`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinitionversion-secretsmanagersecretresourcedata.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    secrets_manager_secret_resource_data_property = greengrass.CfnResourceDefinitionVersion.SecretsManagerSecretResourceDataProperty(\n        arn="arn",\n\n        # the properties below are optional\n        additional_staging_labels_to_download=["additionalStagingLabelsToDownload"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['arn', 'additional_staging_labels_to_download']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinitionVersion.SecretsManagerSecretResourceDataProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnSubscriptionDefinition.SubscriptionDefinitionVersionProperty
class CfnSubscriptionDefinition_SubscriptionDefinitionVersionPropertyDef(BaseStruct):
    subscriptions: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnSubscriptionDefinition_SubscriptionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The subscriptions in this version.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-subscriptiondefinition-subscriptiondefinitionversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    subscription_definition_version_property = greengrass.CfnSubscriptionDefinition.SubscriptionDefinitionVersionProperty(\n        subscriptions=[greengrass.CfnSubscriptionDefinition.SubscriptionProperty(\n            id="id",\n            source="source",\n            subject="subject",\n            target="target"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['subscriptions']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnSubscriptionDefinition.SubscriptionDefinitionVersionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnSubscriptionDefinition.SubscriptionProperty
class CfnSubscriptionDefinition_SubscriptionPropertyDef(BaseStruct):
    source: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The originator of the message. The value can be a thing ARN, the ARN of a Lambda function alias (recommended) or version, a connector ARN, ``cloud`` (which represents the AWS IoT cloud), or ``GGShadowService`` .\n')
    subject: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The MQTT topic used to route the message.\n')
    target: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The destination of the message. The value can be a thing ARN, the ARN of a Lambda function alias (recommended) or version, a connector ARN, ``cloud`` (which represents the AWS IoT cloud), or ``GGShadowService`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-subscriptiondefinition-subscription.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    subscription_property = greengrass.CfnSubscriptionDefinition.SubscriptionProperty(\n        id="id",\n        source="source",\n        subject="subject",\n        target="target"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['source', 'subject', 'target']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnSubscriptionDefinition.SubscriptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnSubscriptionDefinitionVersion.SubscriptionProperty
class CfnSubscriptionDefinitionVersion_SubscriptionPropertyDef(BaseStruct):
    source: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The originator of the message. The value can be a thing ARN, the ARN of a Lambda function alias (recommended) or version, a connector ARN, ``cloud`` (which represents the AWS IoT cloud), or ``GGShadowService`` .\n')
    subject: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The MQTT topic used to route the message.\n')
    target: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The destination of the message. The value can be a thing ARN, the ARN of a Lambda function alias (recommended) or version, a connector ARN, ``cloud`` (which represents the AWS IoT cloud), or ``GGShadowService`` .\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-subscriptiondefinitionversion-subscription.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    subscription_property = greengrass.CfnSubscriptionDefinitionVersion.SubscriptionProperty(\n        id="id",\n        source="source",\n        subject="subject",\n        target="target"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['source', 'subject', 'target']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnSubscriptionDefinitionVersion.SubscriptionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnConnectorDefinition
class CfnConnectorDefinitionDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the connector definition.\n')
    initial_version: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnConnectorDefinition_ConnectorDefinitionVersionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The connector definition version to include when the connector definition is created. A connector definition version contains a list of ```connector`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-connectordefinition-connector.html>`_ property types. .. epigraph:: To associate a connector definition version after the connector definition is created, create an ```AWS::Greengrass::ConnectorDefinitionVersion`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-connectordefinitionversion.html>`_ resource and specify the ID of this connector definition.\n')
    tags: typing.Any = pydantic.Field(None, description='Application-specific metadata to attach to the connector definition. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see `Tagging Your AWS IoT Greengrass Resources <https://docs.aws.amazon.com/greengrass/latest/developerguide/tagging.html>`_ in the *Developer Guide* . This ``Json`` property type is processed as a map of key-value pairs. It uses the following format, which is different from most ``Tags`` implementations in AWS CloudFormation templates:: "Tags": { "KeyName0": "value", "KeyName1": "value", "KeyName2": "value" }')
    _init_params: typing.ClassVar[list[str]] = ['name', 'initial_version', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['ConnectorDefinitionVersionProperty', 'ConnectorProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnConnectorDefinition'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_greengrass.CfnConnectorDefinitionDefConfig] = pydantic.Field(None)


class CfnConnectorDefinitionDefConfig(pydantic.BaseModel):
    ConnectorDefinitionVersionProperty: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionDefConnectordefinitionversionpropertyParams]] = pydantic.Field(None, description='')
    ConnectorProperty: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionDefConnectorpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnConnectorDefinitionDefConnectordefinitionversionpropertyParams(pydantic.BaseModel):
    connectors: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnConnectorDefinition_ConnectorPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnConnectorDefinitionDefConnectorpropertyParams(pydantic.BaseModel):
    connector_arn: str = pydantic.Field(..., description='')
    id: str = pydantic.Field(..., description='')
    parameters: typing.Any = pydantic.Field(None, description='')
    ...

class CfnConnectorDefinitionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnConnectorDefinitionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConnectorDefinitionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnConnectorDefinitionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConnectorDefinitionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnConnectorDefinitionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnConnectorDefinitionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnConnectorDefinitionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnConnectorDefinitionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnConnectorDefinitionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConnectorDefinitionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnConnectorDefinitionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnConnectorDefinitionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConnectorDefinitionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_greengrass.CfnConnectorDefinitionVersion
class CfnConnectorDefinitionVersionDef(BaseCfnResource):
    connector_definition_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the connector definition associated with this version. This value is a GUID.\n')
    connectors: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnConnectorDefinitionVersion_ConnectorPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The connectors in this version. Only one instance of a given connector can be added to the connector definition version at a time.')
    _init_params: typing.ClassVar[list[str]] = ['connector_definition_id', 'connectors']
    _method_names: typing.ClassVar[list[str]] = ['ConnectorProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnConnectorDefinitionVersion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_greengrass.CfnConnectorDefinitionVersionDefConfig] = pydantic.Field(None)


class CfnConnectorDefinitionVersionDefConfig(pydantic.BaseModel):
    ConnectorProperty: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionVersionDefConnectorpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionVersionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionVersionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionVersionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionVersionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionVersionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionVersionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionVersionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionVersionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionVersionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionVersionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionVersionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionVersionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_greengrass.CfnConnectorDefinitionVersionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnConnectorDefinitionVersionDefConnectorpropertyParams(pydantic.BaseModel):
    connector_arn: str = pydantic.Field(..., description='')
    id: str = pydantic.Field(..., description='')
    parameters: typing.Any = pydantic.Field(None, description='')
    ...

class CfnConnectorDefinitionVersionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnConnectorDefinitionVersionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConnectorDefinitionVersionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnConnectorDefinitionVersionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConnectorDefinitionVersionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnConnectorDefinitionVersionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnConnectorDefinitionVersionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnConnectorDefinitionVersionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnConnectorDefinitionVersionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnConnectorDefinitionVersionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnConnectorDefinitionVersionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnConnectorDefinitionVersionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnConnectorDefinitionVersionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnConnectorDefinitionVersionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_greengrass.CfnCoreDefinition
class CfnCoreDefinitionDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the core definition.\n')
    initial_version: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnCoreDefinition_CoreDefinitionVersionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The core definition version to include when the core definition is created. Currently, a core definition version can contain only one ```core`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-coredefinition-core.html>`_ . .. epigraph:: To associate a core definition version after the core definition is created, create an ```AWS::Greengrass::CoreDefinitionVersion`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-coredefinitionversion.html>`_ resource and specify the ID of this core definition.\n')
    tags: typing.Any = pydantic.Field(None, description='Application-specific metadata to attach to the core definition. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see `Tagging Your AWS IoT Greengrass Resources <https://docs.aws.amazon.com/greengrass/latest/developerguide/tagging.html>`_ in the *Developer Guide* . This ``Json`` property type is processed as a map of key-value pairs. It uses the following format, which is different from most ``Tags`` implementations in AWS CloudFormation templates:: "Tags": { "KeyName0": "value", "KeyName1": "value", "KeyName2": "value" }')
    _init_params: typing.ClassVar[list[str]] = ['name', 'initial_version', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['CoreDefinitionVersionProperty', 'CoreProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnCoreDefinition'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_greengrass.CfnCoreDefinitionDefConfig] = pydantic.Field(None)


class CfnCoreDefinitionDefConfig(pydantic.BaseModel):
    CoreDefinitionVersionProperty: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionDefCoredefinitionversionpropertyParams]] = pydantic.Field(None, description='')
    CoreProperty: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionDefCorepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnCoreDefinitionDefCoredefinitionversionpropertyParams(pydantic.BaseModel):
    cores: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnCoreDefinition_CorePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnCoreDefinitionDefCorepropertyParams(pydantic.BaseModel):
    certificate_arn: str = pydantic.Field(..., description='')
    id: str = pydantic.Field(..., description='')
    thing_arn: str = pydantic.Field(..., description='')
    sync_shadow: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnCoreDefinitionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnCoreDefinitionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCoreDefinitionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnCoreDefinitionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCoreDefinitionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnCoreDefinitionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnCoreDefinitionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnCoreDefinitionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnCoreDefinitionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnCoreDefinitionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCoreDefinitionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnCoreDefinitionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnCoreDefinitionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCoreDefinitionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_greengrass.CfnCoreDefinitionVersion
class CfnCoreDefinitionVersionDef(BaseCfnResource):
    core_definition_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the core definition associated with this version. This value is a GUID.\n')
    cores: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnCoreDefinitionVersion_CorePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Greengrass core in this version. Currently, the ``Cores`` property for a core definition version can contain only one core.')
    _init_params: typing.ClassVar[list[str]] = ['core_definition_id', 'cores']
    _method_names: typing.ClassVar[list[str]] = ['CoreProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnCoreDefinitionVersion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_greengrass.CfnCoreDefinitionVersionDefConfig] = pydantic.Field(None)


class CfnCoreDefinitionVersionDefConfig(pydantic.BaseModel):
    CoreProperty: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionVersionDefCorepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionVersionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionVersionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionVersionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionVersionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionVersionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionVersionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionVersionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionVersionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionVersionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionVersionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionVersionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionVersionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_greengrass.CfnCoreDefinitionVersionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnCoreDefinitionVersionDefCorepropertyParams(pydantic.BaseModel):
    certificate_arn: str = pydantic.Field(..., description='')
    id: str = pydantic.Field(..., description='')
    thing_arn: str = pydantic.Field(..., description='')
    sync_shadow: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnCoreDefinitionVersionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnCoreDefinitionVersionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCoreDefinitionVersionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnCoreDefinitionVersionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCoreDefinitionVersionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnCoreDefinitionVersionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnCoreDefinitionVersionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnCoreDefinitionVersionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnCoreDefinitionVersionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnCoreDefinitionVersionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCoreDefinitionVersionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnCoreDefinitionVersionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnCoreDefinitionVersionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCoreDefinitionVersionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_greengrass.CfnDeviceDefinition
class CfnDeviceDefinitionDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the device definition.\n')
    initial_version: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnDeviceDefinition_DeviceDefinitionVersionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The device definition version to include when the device definition is created. A device definition version contains a list of ```device`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-devicedefinition-device.html>`_ property types. .. epigraph:: To associate a device definition version after the device definition is created, create an ```AWS::Greengrass::DeviceDefinitionVersion`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-devicedefinitionversion.html>`_ resource and specify the ID of this device definition.\n')
    tags: typing.Any = pydantic.Field(None, description='Application-specific metadata to attach to the device definition. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see `Tagging Your AWS IoT Greengrass Resources <https://docs.aws.amazon.com/greengrass/latest/developerguide/tagging.html>`_ in the *Developer Guide* . This ``Json`` property type is processed as a map of key-value pairs. It uses the following format, which is different from most ``Tags`` implementations in AWS CloudFormation templates:: "Tags": { "KeyName0": "value", "KeyName1": "value", "KeyName2": "value" }')
    _init_params: typing.ClassVar[list[str]] = ['name', 'initial_version', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['DeviceDefinitionVersionProperty', 'DeviceProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnDeviceDefinition'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_greengrass.CfnDeviceDefinitionDefConfig] = pydantic.Field(None)


class CfnDeviceDefinitionDefConfig(pydantic.BaseModel):
    DeviceDefinitionVersionProperty: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionDefDevicedefinitionversionpropertyParams]] = pydantic.Field(None, description='')
    DeviceProperty: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionDefDevicepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDeviceDefinitionDefDevicedefinitionversionpropertyParams(pydantic.BaseModel):
    devices: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnDeviceDefinition_DevicePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnDeviceDefinitionDefDevicepropertyParams(pydantic.BaseModel):
    certificate_arn: str = pydantic.Field(..., description='')
    id: str = pydantic.Field(..., description='')
    thing_arn: str = pydantic.Field(..., description='')
    sync_shadow: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnDeviceDefinitionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDeviceDefinitionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDeviceDefinitionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDeviceDefinitionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDeviceDefinitionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDeviceDefinitionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDeviceDefinitionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDeviceDefinitionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDeviceDefinitionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDeviceDefinitionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDeviceDefinitionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDeviceDefinitionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDeviceDefinitionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDeviceDefinitionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_greengrass.CfnDeviceDefinitionVersion
class CfnDeviceDefinitionVersionDef(BaseCfnResource):
    device_definition_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the device definition associated with this version. This value is a GUID.\n')
    devices: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnDeviceDefinitionVersion_DevicePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The devices in this version.')
    _init_params: typing.ClassVar[list[str]] = ['device_definition_id', 'devices']
    _method_names: typing.ClassVar[list[str]] = ['DeviceProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnDeviceDefinitionVersion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_greengrass.CfnDeviceDefinitionVersionDefConfig] = pydantic.Field(None)


class CfnDeviceDefinitionVersionDefConfig(pydantic.BaseModel):
    DeviceProperty: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionVersionDefDevicepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionVersionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionVersionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionVersionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionVersionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionVersionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionVersionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionVersionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionVersionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionVersionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionVersionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionVersionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionVersionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_greengrass.CfnDeviceDefinitionVersionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnDeviceDefinitionVersionDefDevicepropertyParams(pydantic.BaseModel):
    certificate_arn: str = pydantic.Field(..., description='')
    id: str = pydantic.Field(..., description='')
    thing_arn: str = pydantic.Field(..., description='')
    sync_shadow: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    ...

class CfnDeviceDefinitionVersionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDeviceDefinitionVersionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDeviceDefinitionVersionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDeviceDefinitionVersionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDeviceDefinitionVersionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDeviceDefinitionVersionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDeviceDefinitionVersionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDeviceDefinitionVersionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDeviceDefinitionVersionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDeviceDefinitionVersionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDeviceDefinitionVersionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnDeviceDefinitionVersionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDeviceDefinitionVersionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDeviceDefinitionVersionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_greengrass.CfnFunctionDefinition
class CfnFunctionDefinitionDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the function definition.\n')
    initial_version: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinition_FunctionDefinitionVersionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The function definition version to include when the function definition is created. A function definition version contains a list of ```function`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinition-function.html>`_ property types. .. epigraph:: To associate a function definition version after the function definition is created, create an ```AWS::Greengrass::FunctionDefinitionVersion`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-functiondefinitionversion.html>`_ resource and specify the ID of this function definition.\n')
    tags: typing.Any = pydantic.Field(None, description='Application-specific metadata to attach to the function definition. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see `Tagging Your AWS IoT Greengrass Resources <https://docs.aws.amazon.com/greengrass/latest/developerguide/tagging.html>`_ in the *Developer Guide* . This ``Json`` property type is processed as a map of key-value pairs. It uses the following format, which is different from most ``Tags`` implementations in AWS CloudFormation templates:: "Tags": { "KeyName0": "value", "KeyName1": "value", "KeyName2": "value" }')
    _init_params: typing.ClassVar[list[str]] = ['name', 'initial_version', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['DefaultConfigProperty', 'EnvironmentProperty', 'ExecutionProperty', 'FunctionConfigurationProperty', 'FunctionDefinitionVersionProperty', 'FunctionProperty', 'ResourceAccessPolicyProperty', 'RunAsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnFunctionDefinition'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_greengrass.CfnFunctionDefinitionDefConfig] = pydantic.Field(None)


class CfnFunctionDefinitionDefConfig(pydantic.BaseModel):
    DefaultConfigProperty: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionDefDefaultconfigpropertyParams]] = pydantic.Field(None, description='')
    EnvironmentProperty: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionDefEnvironmentpropertyParams]] = pydantic.Field(None, description='')
    ExecutionProperty: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionDefExecutionpropertyParams]] = pydantic.Field(None, description='')
    FunctionConfigurationProperty: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionDefFunctionconfigurationpropertyParams]] = pydantic.Field(None, description='')
    FunctionDefinitionVersionProperty: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionDefFunctiondefinitionversionpropertyParams]] = pydantic.Field(None, description='')
    FunctionProperty: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionDefFunctionpropertyParams]] = pydantic.Field(None, description='')
    ResourceAccessPolicyProperty: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionDefResourceaccesspolicypropertyParams]] = pydantic.Field(None, description='')
    RunAsProperty: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionDefRunaspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnFunctionDefinitionDefDefaultconfigpropertyParams(pydantic.BaseModel):
    execution: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinition_ExecutionPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnFunctionDefinitionDefEnvironmentpropertyParams(pydantic.BaseModel):
    access_sysfs: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    execution: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinition_ExecutionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    resource_access_policies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinition_ResourceAccessPolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    variables: typing.Any = pydantic.Field(None, description='')
    ...

class CfnFunctionDefinitionDefExecutionpropertyParams(pydantic.BaseModel):
    isolation_mode: typing.Optional[str] = pydantic.Field(None, description='')
    run_as: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinition_RunAsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnFunctionDefinitionDefFunctionconfigurationpropertyParams(pydantic.BaseModel):
    encoding_type: typing.Optional[str] = pydantic.Field(None, description='')
    environment: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinition_EnvironmentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    exec_args: typing.Optional[str] = pydantic.Field(None, description='')
    executable: typing.Optional[str] = pydantic.Field(None, description='')
    memory_size: typing.Union[int, float, None] = pydantic.Field(None, description='')
    pinned: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    timeout: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnFunctionDefinitionDefFunctiondefinitionversionpropertyParams(pydantic.BaseModel):
    functions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinition_FunctionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    default_config: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinition_DefaultConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnFunctionDefinitionDefFunctionpropertyParams(pydantic.BaseModel):
    function_arn: str = pydantic.Field(..., description='')
    function_configuration: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinition_FunctionConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    id: str = pydantic.Field(..., description='')
    ...

class CfnFunctionDefinitionDefResourceaccesspolicypropertyParams(pydantic.BaseModel):
    resource_id: str = pydantic.Field(..., description='')
    permission: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnFunctionDefinitionDefRunaspropertyParams(pydantic.BaseModel):
    gid: typing.Union[int, float, None] = pydantic.Field(None, description='')
    uid: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnFunctionDefinitionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnFunctionDefinitionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFunctionDefinitionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnFunctionDefinitionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFunctionDefinitionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnFunctionDefinitionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnFunctionDefinitionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnFunctionDefinitionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnFunctionDefinitionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnFunctionDefinitionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFunctionDefinitionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnFunctionDefinitionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnFunctionDefinitionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFunctionDefinitionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_greengrass.CfnFunctionDefinitionVersion
class CfnFunctionDefinitionVersionDef(BaseCfnResource):
    function_definition_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the function definition associated with this version. This value is a GUID.\n')
    functions: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinitionVersion_FunctionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The functions in this version.\n')
    default_config: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinitionVersion_DefaultConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The default configuration that applies to all Lambda functions in the group. Individual Lambda functions can override these settings.')
    _init_params: typing.ClassVar[list[str]] = ['function_definition_id', 'functions', 'default_config']
    _method_names: typing.ClassVar[list[str]] = ['DefaultConfigProperty', 'EnvironmentProperty', 'ExecutionProperty', 'FunctionConfigurationProperty', 'FunctionProperty', 'ResourceAccessPolicyProperty', 'RunAsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnFunctionDefinitionVersion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_greengrass.CfnFunctionDefinitionVersionDefConfig] = pydantic.Field(None)


class CfnFunctionDefinitionVersionDefConfig(pydantic.BaseModel):
    DefaultConfigProperty: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionVersionDefDefaultconfigpropertyParams]] = pydantic.Field(None, description='')
    EnvironmentProperty: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionVersionDefEnvironmentpropertyParams]] = pydantic.Field(None, description='')
    ExecutionProperty: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionVersionDefExecutionpropertyParams]] = pydantic.Field(None, description='')
    FunctionConfigurationProperty: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionVersionDefFunctionconfigurationpropertyParams]] = pydantic.Field(None, description='')
    FunctionProperty: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionVersionDefFunctionpropertyParams]] = pydantic.Field(None, description='')
    ResourceAccessPolicyProperty: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionVersionDefResourceaccesspolicypropertyParams]] = pydantic.Field(None, description='')
    RunAsProperty: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionVersionDefRunaspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionVersionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionVersionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionVersionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionVersionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionVersionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionVersionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionVersionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionVersionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionVersionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionVersionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionVersionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionVersionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_greengrass.CfnFunctionDefinitionVersionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnFunctionDefinitionVersionDefDefaultconfigpropertyParams(pydantic.BaseModel):
    execution: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinitionVersion_ExecutionPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnFunctionDefinitionVersionDefEnvironmentpropertyParams(pydantic.BaseModel):
    access_sysfs: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    execution: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinitionVersion_ExecutionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    resource_access_policies: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinitionVersion_ResourceAccessPolicyPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    variables: typing.Any = pydantic.Field(None, description='')
    ...

class CfnFunctionDefinitionVersionDefExecutionpropertyParams(pydantic.BaseModel):
    isolation_mode: typing.Optional[str] = pydantic.Field(None, description='')
    run_as: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinitionVersion_RunAsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnFunctionDefinitionVersionDefFunctionconfigurationpropertyParams(pydantic.BaseModel):
    encoding_type: typing.Optional[str] = pydantic.Field(None, description='')
    environment: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinitionVersion_EnvironmentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    exec_args: typing.Optional[str] = pydantic.Field(None, description='')
    executable: typing.Optional[str] = pydantic.Field(None, description='')
    memory_size: typing.Union[int, float, None] = pydantic.Field(None, description='')
    pinned: typing.Union[bool, models.UnsupportedResource, None] = pydantic.Field(None, description='')
    timeout: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnFunctionDefinitionVersionDefFunctionpropertyParams(pydantic.BaseModel):
    function_arn: str = pydantic.Field(..., description='')
    function_configuration: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinitionVersion_FunctionConfigurationPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    id: str = pydantic.Field(..., description='')
    ...

class CfnFunctionDefinitionVersionDefResourceaccesspolicypropertyParams(pydantic.BaseModel):
    resource_id: str = pydantic.Field(..., description='')
    permission: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnFunctionDefinitionVersionDefRunaspropertyParams(pydantic.BaseModel):
    gid: typing.Union[int, float, None] = pydantic.Field(None, description='')
    uid: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnFunctionDefinitionVersionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnFunctionDefinitionVersionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFunctionDefinitionVersionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnFunctionDefinitionVersionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFunctionDefinitionVersionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnFunctionDefinitionVersionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnFunctionDefinitionVersionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnFunctionDefinitionVersionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnFunctionDefinitionVersionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnFunctionDefinitionVersionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFunctionDefinitionVersionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnFunctionDefinitionVersionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnFunctionDefinitionVersionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFunctionDefinitionVersionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_greengrass.CfnGroup
class CfnGroupDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the group.\n')
    initial_version: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnGroup_GroupVersionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The group version to include when the group is created. A group version references the Amazon Resource Name (ARN) of a core definition version, device definition version, subscription definition version, and other version types. The group version must reference a core definition version that contains one core. Other version types are optionally included, depending on your business need. .. epigraph:: To associate a group version after the group is created, create an ```AWS::Greengrass::GroupVersion`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-groupversion.html>`_ resource and specify the ID of this group.\n')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the IAM role attached to the group. This role contains the permissions that Lambda functions and connectors use to interact with other AWS services.\n')
    tags: typing.Any = pydantic.Field(None, description='Application-specific metadata to attach to the group. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see `Tagging Your AWS IoT Greengrass Resources <https://docs.aws.amazon.com/greengrass/latest/developerguide/tagging.html>`_ in the *Developer Guide* . This ``Json`` property type is processed as a map of key-value pairs. It uses the following format, which is different from most ``Tags`` implementations in AWS CloudFormation templates:: "Tags": { "KeyName0": "value", "KeyName1": "value", "KeyName2": "value" }')
    _init_params: typing.ClassVar[list[str]] = ['name', 'initial_version', 'role_arn', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['GroupVersionProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_greengrass.CfnGroupDefConfig] = pydantic.Field(None)


class CfnGroupDefConfig(pydantic.BaseModel):
    GroupVersionProperty: typing.Optional[list[models.aws_greengrass.CfnGroupDefGroupversionpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_greengrass.CfnGroupDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_greengrass.CfnGroupDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_greengrass.CfnGroupDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_greengrass.CfnGroupDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_greengrass.CfnGroupDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_greengrass.CfnGroupDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_greengrass.CfnGroupDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_greengrass.CfnGroupDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_greengrass.CfnGroupDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_greengrass.CfnGroupDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_greengrass.CfnGroupDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_greengrass.CfnGroupDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_greengrass.CfnGroupDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnGroupDefGroupversionpropertyParams(pydantic.BaseModel):
    connector_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='')
    core_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='')
    device_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='')
    function_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='')
    logger_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='')
    resource_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='')
    subscription_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnGroupDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnGroupDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGroupDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnGroupDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGroupDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnGroupDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnGroupDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnGroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnGroupDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnGroupDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGroupDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnGroupDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnGroupDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGroupDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_greengrass.CfnGroupVersion
class CfnGroupVersionDef(BaseCfnResource):
    group_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the group associated with this version. This value is a GUID.\n')
    connector_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the connector definition version that contains the connectors you want to deploy with the group version.\n')
    core_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the core definition version that contains the core you want to deploy with the group version. Currently, the core definition version can contain only one core.\n')
    device_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the device definition version that contains the devices you want to deploy with the group version.\n')
    function_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the function definition version that contains the functions you want to deploy with the group version.\n')
    logger_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the logger definition version that contains the loggers you want to deploy with the group version.\n')
    resource_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the resource definition version that contains the resources you want to deploy with the group version.\n')
    subscription_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the subscription definition version that contains the subscriptions you want to deploy with the group version.')
    _init_params: typing.ClassVar[list[str]] = ['group_id', 'connector_definition_version_arn', 'core_definition_version_arn', 'device_definition_version_arn', 'function_definition_version_arn', 'logger_definition_version_arn', 'resource_definition_version_arn', 'subscription_definition_version_arn']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnGroupVersion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_greengrass.CfnGroupVersionDefConfig] = pydantic.Field(None)


class CfnGroupVersionDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[models.aws_greengrass.CfnGroupVersionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_greengrass.CfnGroupVersionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_greengrass.CfnGroupVersionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_greengrass.CfnGroupVersionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_greengrass.CfnGroupVersionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_greengrass.CfnGroupVersionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_greengrass.CfnGroupVersionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_greengrass.CfnGroupVersionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_greengrass.CfnGroupVersionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_greengrass.CfnGroupVersionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_greengrass.CfnGroupVersionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_greengrass.CfnGroupVersionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_greengrass.CfnGroupVersionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnGroupVersionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnGroupVersionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGroupVersionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnGroupVersionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGroupVersionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnGroupVersionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnGroupVersionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnGroupVersionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnGroupVersionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnGroupVersionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGroupVersionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnGroupVersionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnGroupVersionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGroupVersionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_greengrass.CfnLoggerDefinition
class CfnLoggerDefinitionDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the logger definition.\n')
    initial_version: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnLoggerDefinition_LoggerDefinitionVersionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The logger definition version to include when the logger definition is created. A logger definition version contains a list of ```logger`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-loggerdefinition-logger.html>`_ property types. .. epigraph:: To associate a logger definition version after the logger definition is created, create an ```AWS::Greengrass::LoggerDefinitionVersion`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-loggerdefinitionversion.html>`_ resource and specify the ID of this logger definition.\n')
    tags: typing.Any = pydantic.Field(None, description='Application-specific metadata to attach to the logger definition. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see `Tagging Your AWS IoT Greengrass Resources <https://docs.aws.amazon.com/greengrass/latest/developerguide/tagging.html>`_ in the *Developer Guide* . This ``Json`` property type is processed as a map of key-value pairs. It uses the following format, which is different from most ``Tags`` implementations in AWS CloudFormation templates:: "Tags": { "KeyName0": "value", "KeyName1": "value", "KeyName2": "value" }')
    _init_params: typing.ClassVar[list[str]] = ['name', 'initial_version', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['LoggerDefinitionVersionProperty', 'LoggerProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnLoggerDefinition'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_greengrass.CfnLoggerDefinitionDefConfig] = pydantic.Field(None)


class CfnLoggerDefinitionDefConfig(pydantic.BaseModel):
    LoggerDefinitionVersionProperty: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionDefLoggerdefinitionversionpropertyParams]] = pydantic.Field(None, description='')
    LoggerProperty: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionDefLoggerpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnLoggerDefinitionDefLoggerdefinitionversionpropertyParams(pydantic.BaseModel):
    loggers: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnLoggerDefinition_LoggerPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnLoggerDefinitionDefLoggerpropertyParams(pydantic.BaseModel):
    component: str = pydantic.Field(..., description='')
    id: str = pydantic.Field(..., description='')
    level: str = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    space: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnLoggerDefinitionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnLoggerDefinitionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLoggerDefinitionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnLoggerDefinitionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLoggerDefinitionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnLoggerDefinitionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnLoggerDefinitionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnLoggerDefinitionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnLoggerDefinitionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnLoggerDefinitionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLoggerDefinitionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnLoggerDefinitionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnLoggerDefinitionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLoggerDefinitionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_greengrass.CfnLoggerDefinitionVersion
class CfnLoggerDefinitionVersionDef(BaseCfnResource):
    logger_definition_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the logger definition associated with this version. This value is a GUID.\n')
    loggers: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnLoggerDefinitionVersion_LoggerPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The loggers in this version.')
    _init_params: typing.ClassVar[list[str]] = ['logger_definition_id', 'loggers']
    _method_names: typing.ClassVar[list[str]] = ['LoggerProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnLoggerDefinitionVersion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_greengrass.CfnLoggerDefinitionVersionDefConfig] = pydantic.Field(None)


class CfnLoggerDefinitionVersionDefConfig(pydantic.BaseModel):
    LoggerProperty: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionVersionDefLoggerpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionVersionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionVersionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionVersionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionVersionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionVersionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionVersionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionVersionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionVersionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionVersionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionVersionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionVersionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionVersionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_greengrass.CfnLoggerDefinitionVersionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnLoggerDefinitionVersionDefLoggerpropertyParams(pydantic.BaseModel):
    component: str = pydantic.Field(..., description='')
    id: str = pydantic.Field(..., description='')
    level: str = pydantic.Field(..., description='')
    type: str = pydantic.Field(..., description='')
    space: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnLoggerDefinitionVersionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnLoggerDefinitionVersionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLoggerDefinitionVersionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnLoggerDefinitionVersionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLoggerDefinitionVersionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnLoggerDefinitionVersionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnLoggerDefinitionVersionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnLoggerDefinitionVersionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnLoggerDefinitionVersionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnLoggerDefinitionVersionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLoggerDefinitionVersionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnLoggerDefinitionVersionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnLoggerDefinitionVersionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLoggerDefinitionVersionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinition
class CfnResourceDefinitionDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the resource definition.\n')
    initial_version: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_ResourceDefinitionVersionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The resource definition version to include when the resource definition is created. A resource definition version contains a list of ```resource instance`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinition-resourceinstance.html>`_ property types. .. epigraph:: To associate a resource definition version after the resource definition is created, create an ```AWS::Greengrass::ResourceDefinitionVersion`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-resourcedefinitionversion.html>`_ resource and specify the ID of this resource definition.\n')
    tags: typing.Any = pydantic.Field(None, description='Application-specific metadata to attach to the resource definition. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see `Tagging Your AWS IoT Greengrass Resources <https://docs.aws.amazon.com/greengrass/latest/developerguide/tagging.html>`_ in the *Developer Guide* . This ``Json`` property type is processed as a map of key-value pairs. It uses the following format, which is different from most ``Tags`` implementations in AWS CloudFormation templates:: "Tags": { "KeyName0": "value", "KeyName1": "value", "KeyName2": "value" }')
    _init_params: typing.ClassVar[list[str]] = ['name', 'initial_version', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['GroupOwnerSettingProperty', 'LocalDeviceResourceDataProperty', 'LocalVolumeResourceDataProperty', 'ResourceDataContainerProperty', 'ResourceDefinitionVersionProperty', 'ResourceDownloadOwnerSettingProperty', 'ResourceInstanceProperty', 'S3MachineLearningModelResourceDataProperty', 'SageMakerMachineLearningModelResourceDataProperty', 'SecretsManagerSecretResourceDataProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinition'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_greengrass.CfnResourceDefinitionDefConfig] = pydantic.Field(None)


class CfnResourceDefinitionDefConfig(pydantic.BaseModel):
    GroupOwnerSettingProperty: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefGroupownersettingpropertyParams]] = pydantic.Field(None, description='')
    LocalDeviceResourceDataProperty: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefLocaldeviceresourcedatapropertyParams]] = pydantic.Field(None, description='')
    LocalVolumeResourceDataProperty: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefLocalvolumeresourcedatapropertyParams]] = pydantic.Field(None, description='')
    ResourceDataContainerProperty: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefResourcedatacontainerpropertyParams]] = pydantic.Field(None, description='')
    ResourceDefinitionVersionProperty: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefResourcedefinitionversionpropertyParams]] = pydantic.Field(None, description='')
    ResourceDownloadOwnerSettingProperty: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefResourcedownloadownersettingpropertyParams]] = pydantic.Field(None, description='')
    ResourceInstanceProperty: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefResourceinstancepropertyParams]] = pydantic.Field(None, description='')
    S3MachineLearningModelResourceDataProperty: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefS3MachinelearningmodelresourcedatapropertyParams]] = pydantic.Field(None, description='')
    SageMakerMachineLearningModelResourceDataProperty: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefSagemakermachinelearningmodelresourcedatapropertyParams]] = pydantic.Field(None, description='')
    SecretsManagerSecretResourceDataProperty: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefSecretsmanagersecretresourcedatapropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnResourceDefinitionDefGroupownersettingpropertyParams(pydantic.BaseModel):
    auto_add_group_owner: typing.Union[bool, models.UnsupportedResource] = pydantic.Field(..., description='')
    group_owner: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnResourceDefinitionDefLocaldeviceresourcedatapropertyParams(pydantic.BaseModel):
    source_path: str = pydantic.Field(..., description='')
    group_owner_setting: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_GroupOwnerSettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnResourceDefinitionDefLocalvolumeresourcedatapropertyParams(pydantic.BaseModel):
    destination_path: str = pydantic.Field(..., description='')
    source_path: str = pydantic.Field(..., description='')
    group_owner_setting: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_GroupOwnerSettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnResourceDefinitionDefResourcedatacontainerpropertyParams(pydantic.BaseModel):
    local_device_resource_data: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_LocalDeviceResourceDataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    local_volume_resource_data: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_LocalVolumeResourceDataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    s3_machine_learning_model_resource_data: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_S3MachineLearningModelResourceDataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    sage_maker_machine_learning_model_resource_data: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_SageMakerMachineLearningModelResourceDataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    secrets_manager_secret_resource_data: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_SecretsManagerSecretResourceDataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnResourceDefinitionDefResourcedefinitionversionpropertyParams(pydantic.BaseModel):
    resources: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_ResourceInstancePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnResourceDefinitionDefResourcedownloadownersettingpropertyParams(pydantic.BaseModel):
    group_owner: str = pydantic.Field(..., description='')
    group_permission: str = pydantic.Field(..., description='')
    ...

class CfnResourceDefinitionDefResourceinstancepropertyParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='')
    name: str = pydantic.Field(..., description='')
    resource_data_container: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_ResourceDataContainerPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnResourceDefinitionDefS3MachinelearningmodelresourcedatapropertyParams(pydantic.BaseModel):
    destination_path: str = pydantic.Field(..., description='')
    s3_uri: str = pydantic.Field(..., description='')
    owner_setting: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_ResourceDownloadOwnerSettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnResourceDefinitionDefSagemakermachinelearningmodelresourcedatapropertyParams(pydantic.BaseModel):
    destination_path: str = pydantic.Field(..., description='')
    sage_maker_job_arn: str = pydantic.Field(..., description='')
    owner_setting: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_ResourceDownloadOwnerSettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnResourceDefinitionDefSecretsmanagersecretresourcedatapropertyParams(pydantic.BaseModel):
    arn: str = pydantic.Field(..., description='')
    additional_staging_labels_to_download: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnResourceDefinitionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnResourceDefinitionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnResourceDefinitionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnResourceDefinitionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnResourceDefinitionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnResourceDefinitionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnResourceDefinitionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnResourceDefinitionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnResourceDefinitionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnResourceDefinitionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnResourceDefinitionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnResourceDefinitionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnResourceDefinitionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnResourceDefinitionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinitionVersion
class CfnResourceDefinitionVersionDef(BaseCfnResource):
    resource_definition_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the resource definition associated with this version. This value is a GUID.\n')
    resources: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_ResourceInstancePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The resources in this version.')
    _init_params: typing.ClassVar[list[str]] = ['resource_definition_id', 'resources']
    _method_names: typing.ClassVar[list[str]] = ['GroupOwnerSettingProperty', 'LocalDeviceResourceDataProperty', 'LocalVolumeResourceDataProperty', 'ResourceDataContainerProperty', 'ResourceDownloadOwnerSettingProperty', 'ResourceInstanceProperty', 'S3MachineLearningModelResourceDataProperty', 'SageMakerMachineLearningModelResourceDataProperty', 'SecretsManagerSecretResourceDataProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinitionVersion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_greengrass.CfnResourceDefinitionVersionDefConfig] = pydantic.Field(None)


class CfnResourceDefinitionVersionDefConfig(pydantic.BaseModel):
    GroupOwnerSettingProperty: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefGroupownersettingpropertyParams]] = pydantic.Field(None, description='')
    LocalDeviceResourceDataProperty: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefLocaldeviceresourcedatapropertyParams]] = pydantic.Field(None, description='')
    LocalVolumeResourceDataProperty: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefLocalvolumeresourcedatapropertyParams]] = pydantic.Field(None, description='')
    ResourceDataContainerProperty: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefResourcedatacontainerpropertyParams]] = pydantic.Field(None, description='')
    ResourceDownloadOwnerSettingProperty: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefResourcedownloadownersettingpropertyParams]] = pydantic.Field(None, description='')
    ResourceInstanceProperty: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefResourceinstancepropertyParams]] = pydantic.Field(None, description='')
    S3MachineLearningModelResourceDataProperty: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefS3MachinelearningmodelresourcedatapropertyParams]] = pydantic.Field(None, description='')
    SageMakerMachineLearningModelResourceDataProperty: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefSagemakermachinelearningmodelresourcedatapropertyParams]] = pydantic.Field(None, description='')
    SecretsManagerSecretResourceDataProperty: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefSecretsmanagersecretresourcedatapropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_greengrass.CfnResourceDefinitionVersionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnResourceDefinitionVersionDefGroupownersettingpropertyParams(pydantic.BaseModel):
    auto_add_group_owner: typing.Union[bool, models.UnsupportedResource] = pydantic.Field(..., description='')
    group_owner: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnResourceDefinitionVersionDefLocaldeviceresourcedatapropertyParams(pydantic.BaseModel):
    source_path: str = pydantic.Field(..., description='')
    group_owner_setting: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_GroupOwnerSettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnResourceDefinitionVersionDefLocalvolumeresourcedatapropertyParams(pydantic.BaseModel):
    destination_path: str = pydantic.Field(..., description='')
    source_path: str = pydantic.Field(..., description='')
    group_owner_setting: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_GroupOwnerSettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnResourceDefinitionVersionDefResourcedatacontainerpropertyParams(pydantic.BaseModel):
    local_device_resource_data: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_LocalDeviceResourceDataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    local_volume_resource_data: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_LocalVolumeResourceDataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    s3_machine_learning_model_resource_data: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_S3MachineLearningModelResourceDataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    sage_maker_machine_learning_model_resource_data: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_SageMakerMachineLearningModelResourceDataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    secrets_manager_secret_resource_data: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_SecretsManagerSecretResourceDataPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnResourceDefinitionVersionDefResourcedownloadownersettingpropertyParams(pydantic.BaseModel):
    group_owner: str = pydantic.Field(..., description='')
    group_permission: str = pydantic.Field(..., description='')
    ...

class CfnResourceDefinitionVersionDefResourceinstancepropertyParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='')
    name: str = pydantic.Field(..., description='')
    resource_data_container: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_ResourceDataContainerPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='')
    ...

class CfnResourceDefinitionVersionDefS3MachinelearningmodelresourcedatapropertyParams(pydantic.BaseModel):
    destination_path: str = pydantic.Field(..., description='')
    s3_uri: str = pydantic.Field(..., description='')
    owner_setting: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_ResourceDownloadOwnerSettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnResourceDefinitionVersionDefSagemakermachinelearningmodelresourcedatapropertyParams(pydantic.BaseModel):
    destination_path: str = pydantic.Field(..., description='')
    sage_maker_job_arn: str = pydantic.Field(..., description='')
    owner_setting: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_ResourceDownloadOwnerSettingPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnResourceDefinitionVersionDefSecretsmanagersecretresourcedatapropertyParams(pydantic.BaseModel):
    arn: str = pydantic.Field(..., description='')
    additional_staging_labels_to_download: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnResourceDefinitionVersionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnResourceDefinitionVersionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnResourceDefinitionVersionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnResourceDefinitionVersionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnResourceDefinitionVersionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnResourceDefinitionVersionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnResourceDefinitionVersionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnResourceDefinitionVersionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnResourceDefinitionVersionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnResourceDefinitionVersionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnResourceDefinitionVersionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnResourceDefinitionVersionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnResourceDefinitionVersionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnResourceDefinitionVersionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_greengrass.CfnSubscriptionDefinition
class CfnSubscriptionDefinitionDef(BaseCfnResource):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the subscription definition.\n')
    initial_version: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnSubscriptionDefinition_SubscriptionDefinitionVersionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The subscription definition version to include when the subscription definition is created. A subscription definition version contains a list of ```subscription`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-subscriptiondefinition-subscription.html>`_ property types. .. epigraph:: To associate a subscription definition version after the subscription definition is created, create an ```AWS::Greengrass::SubscriptionDefinitionVersion`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-subscriptiondefinitionversion.html>`_ resource and specify the ID of this subscription definition.\n')
    tags: typing.Any = pydantic.Field(None, description='Application-specific metadata to attach to the subscription definition. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see `Tagging Your AWS IoT Greengrass Resources <https://docs.aws.amazon.com/greengrass/latest/developerguide/tagging.html>`_ in the *Developer Guide* . This ``Json`` property type is processed as a map of key-value pairs. It uses the following format, which is different from most ``Tags`` implementations in AWS CloudFormation templates:: "Tags": { "KeyName0": "value", "KeyName1": "value", "KeyName2": "value" }')
    _init_params: typing.ClassVar[list[str]] = ['name', 'initial_version', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['SubscriptionDefinitionVersionProperty', 'SubscriptionProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnSubscriptionDefinition'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_greengrass.CfnSubscriptionDefinitionDefConfig] = pydantic.Field(None)


class CfnSubscriptionDefinitionDefConfig(pydantic.BaseModel):
    SubscriptionDefinitionVersionProperty: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionDefSubscriptiondefinitionversionpropertyParams]] = pydantic.Field(None, description='')
    SubscriptionProperty: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionDefSubscriptionpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnSubscriptionDefinitionDefSubscriptiondefinitionversionpropertyParams(pydantic.BaseModel):
    subscriptions: typing.Union[models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnSubscriptionDefinition_SubscriptionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnSubscriptionDefinitionDefSubscriptionpropertyParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='')
    source: str = pydantic.Field(..., description='')
    subject: str = pydantic.Field(..., description='')
    target: str = pydantic.Field(..., description='')
    ...

class CfnSubscriptionDefinitionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSubscriptionDefinitionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSubscriptionDefinitionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSubscriptionDefinitionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSubscriptionDefinitionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSubscriptionDefinitionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSubscriptionDefinitionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSubscriptionDefinitionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSubscriptionDefinitionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSubscriptionDefinitionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSubscriptionDefinitionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnSubscriptionDefinitionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSubscriptionDefinitionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSubscriptionDefinitionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_greengrass.CfnSubscriptionDefinitionVersion
class CfnSubscriptionDefinitionVersionDef(BaseCfnResource):
    subscription_definition_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the subscription definition associated with this version. This value is a GUID.\n')
    subscriptions: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnSubscriptionDefinitionVersion_SubscriptionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The subscriptions in this version.')
    _init_params: typing.ClassVar[list[str]] = ['subscription_definition_id', 'subscriptions']
    _method_names: typing.ClassVar[list[str]] = ['SubscriptionProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnSubscriptionDefinitionVersion'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[models.aws_greengrass.CfnSubscriptionDefinitionVersionDefConfig] = pydantic.Field(None)


class CfnSubscriptionDefinitionVersionDefConfig(pydantic.BaseModel):
    SubscriptionProperty: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionVersionDefSubscriptionpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionVersionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionVersionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionVersionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionVersionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionVersionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionVersionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionVersionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionVersionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionVersionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionVersionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionVersionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionVersionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[models.aws_greengrass.CfnSubscriptionDefinitionVersionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnSubscriptionDefinitionVersionDefSubscriptionpropertyParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='')
    source: str = pydantic.Field(..., description='')
    subject: str = pydantic.Field(..., description='')
    target: str = pydantic.Field(..., description='')
    ...

class CfnSubscriptionDefinitionVersionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSubscriptionDefinitionVersionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSubscriptionDefinitionVersionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSubscriptionDefinitionVersionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSubscriptionDefinitionVersionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSubscriptionDefinitionVersionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSubscriptionDefinitionVersionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSubscriptionDefinitionVersionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSubscriptionDefinitionVersionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSubscriptionDefinitionVersionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSubscriptionDefinitionVersionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='tree inspector to collect and process attributes.')
    ...

class CfnSubscriptionDefinitionVersionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSubscriptionDefinitionVersionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSubscriptionDefinitionVersionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_greengrass.CfnConnectorDefinitionProps
class CfnConnectorDefinitionPropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the connector definition.\n')
    initial_version: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnConnectorDefinition_ConnectorDefinitionVersionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The connector definition version to include when the connector definition is created. A connector definition version contains a list of ```connector`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-connectordefinition-connector.html>`_ property types. .. epigraph:: To associate a connector definition version after the connector definition is created, create an ```AWS::Greengrass::ConnectorDefinitionVersion`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-connectordefinitionversion.html>`_ resource and specify the ID of this connector definition.\n')
    tags: typing.Any = pydantic.Field(None, description='Application-specific metadata to attach to the connector definition. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see `Tagging Your AWS IoT Greengrass Resources <https://docs.aws.amazon.com/greengrass/latest/developerguide/tagging.html>`_ in the *Developer Guide* . This ``Json`` property type is processed as a map of key-value pairs. It uses the following format, which is different from most ``Tags`` implementations in AWS CloudFormation templates:: "Tags": { "KeyName0": "value", "KeyName1": "value", "KeyName2": "value" }\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-connectordefinition.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    # parameters: Any\n    # tags: Any\n\n    cfn_connector_definition_props = greengrass.CfnConnectorDefinitionProps(\n        name="name",\n\n        # the properties below are optional\n        initial_version=greengrass.CfnConnectorDefinition.ConnectorDefinitionVersionProperty(\n            connectors=[greengrass.CfnConnectorDefinition.ConnectorProperty(\n                connector_arn="connectorArn",\n                id="id",\n\n                # the properties below are optional\n                parameters=parameters\n            )]\n        ),\n        tags=tags\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'initial_version', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnConnectorDefinitionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnConnectorDefinitionVersionProps
class CfnConnectorDefinitionVersionPropsDef(BaseCfnProperty):
    connector_definition_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the connector definition associated with this version. This value is a GUID.\n')
    connectors: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnConnectorDefinitionVersion_ConnectorPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The connectors in this version. Only one instance of a given connector can be added to the connector definition version at a time.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-connectordefinitionversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    # parameters: Any\n\n    cfn_connector_definition_version_props = greengrass.CfnConnectorDefinitionVersionProps(\n        connector_definition_id="connectorDefinitionId",\n        connectors=[greengrass.CfnConnectorDefinitionVersion.ConnectorProperty(\n            connector_arn="connectorArn",\n            id="id",\n\n            # the properties below are optional\n            parameters=parameters\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connector_definition_id', 'connectors']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnConnectorDefinitionVersionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnCoreDefinitionProps
class CfnCoreDefinitionPropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the core definition.\n')
    initial_version: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnCoreDefinition_CoreDefinitionVersionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The core definition version to include when the core definition is created. Currently, a core definition version can contain only one ```core`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-coredefinition-core.html>`_ . .. epigraph:: To associate a core definition version after the core definition is created, create an ```AWS::Greengrass::CoreDefinitionVersion`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-coredefinitionversion.html>`_ resource and specify the ID of this core definition.\n')
    tags: typing.Any = pydantic.Field(None, description='Application-specific metadata to attach to the core definition. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see `Tagging Your AWS IoT Greengrass Resources <https://docs.aws.amazon.com/greengrass/latest/developerguide/tagging.html>`_ in the *Developer Guide* . This ``Json`` property type is processed as a map of key-value pairs. It uses the following format, which is different from most ``Tags`` implementations in AWS CloudFormation templates:: "Tags": { "KeyName0": "value", "KeyName1": "value", "KeyName2": "value" }\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-coredefinition.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    # tags: Any\n\n    cfn_core_definition_props = greengrass.CfnCoreDefinitionProps(\n        name="name",\n\n        # the properties below are optional\n        initial_version=greengrass.CfnCoreDefinition.CoreDefinitionVersionProperty(\n            cores=[greengrass.CfnCoreDefinition.CoreProperty(\n                certificate_arn="certificateArn",\n                id="id",\n                thing_arn="thingArn",\n\n                # the properties below are optional\n                sync_shadow=False\n            )]\n        ),\n        tags=tags\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'initial_version', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnCoreDefinitionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnCoreDefinitionVersionProps
class CfnCoreDefinitionVersionPropsDef(BaseCfnProperty):
    core_definition_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the core definition associated with this version. This value is a GUID.\n')
    cores: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnCoreDefinitionVersion_CorePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The Greengrass core in this version. Currently, the ``Cores`` property for a core definition version can contain only one core.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-coredefinitionversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    cfn_core_definition_version_props = greengrass.CfnCoreDefinitionVersionProps(\n        core_definition_id="coreDefinitionId",\n        cores=[greengrass.CfnCoreDefinitionVersion.CoreProperty(\n            certificate_arn="certificateArn",\n            id="id",\n            thing_arn="thingArn",\n\n            # the properties below are optional\n            sync_shadow=False\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['core_definition_id', 'cores']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnCoreDefinitionVersionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnDeviceDefinitionProps
class CfnDeviceDefinitionPropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the device definition.\n')
    initial_version: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnDeviceDefinition_DeviceDefinitionVersionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The device definition version to include when the device definition is created. A device definition version contains a list of ```device`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-devicedefinition-device.html>`_ property types. .. epigraph:: To associate a device definition version after the device definition is created, create an ```AWS::Greengrass::DeviceDefinitionVersion`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-devicedefinitionversion.html>`_ resource and specify the ID of this device definition.\n')
    tags: typing.Any = pydantic.Field(None, description='Application-specific metadata to attach to the device definition. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see `Tagging Your AWS IoT Greengrass Resources <https://docs.aws.amazon.com/greengrass/latest/developerguide/tagging.html>`_ in the *Developer Guide* . This ``Json`` property type is processed as a map of key-value pairs. It uses the following format, which is different from most ``Tags`` implementations in AWS CloudFormation templates:: "Tags": { "KeyName0": "value", "KeyName1": "value", "KeyName2": "value" }\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-devicedefinition.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    # tags: Any\n\n    cfn_device_definition_props = greengrass.CfnDeviceDefinitionProps(\n        name="name",\n\n        # the properties below are optional\n        initial_version=greengrass.CfnDeviceDefinition.DeviceDefinitionVersionProperty(\n            devices=[greengrass.CfnDeviceDefinition.DeviceProperty(\n                certificate_arn="certificateArn",\n                id="id",\n                thing_arn="thingArn",\n\n                # the properties below are optional\n                sync_shadow=False\n            )]\n        ),\n        tags=tags\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'initial_version', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnDeviceDefinitionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnDeviceDefinitionVersionProps
class CfnDeviceDefinitionVersionPropsDef(BaseCfnProperty):
    device_definition_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the device definition associated with this version. This value is a GUID.\n')
    devices: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnDeviceDefinitionVersion_DevicePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The devices in this version.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-devicedefinitionversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    cfn_device_definition_version_props = greengrass.CfnDeviceDefinitionVersionProps(\n        device_definition_id="deviceDefinitionId",\n        devices=[greengrass.CfnDeviceDefinitionVersion.DeviceProperty(\n            certificate_arn="certificateArn",\n            id="id",\n            thing_arn="thingArn",\n\n            # the properties below are optional\n            sync_shadow=False\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['device_definition_id', 'devices']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnDeviceDefinitionVersionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnFunctionDefinitionProps
class CfnFunctionDefinitionPropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the function definition.\n')
    initial_version: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinition_FunctionDefinitionVersionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The function definition version to include when the function definition is created. A function definition version contains a list of ```function`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-functiondefinition-function.html>`_ property types. .. epigraph:: To associate a function definition version after the function definition is created, create an ```AWS::Greengrass::FunctionDefinitionVersion`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-functiondefinitionversion.html>`_ resource and specify the ID of this function definition.\n')
    tags: typing.Any = pydantic.Field(None, description='Application-specific metadata to attach to the function definition. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see `Tagging Your AWS IoT Greengrass Resources <https://docs.aws.amazon.com/greengrass/latest/developerguide/tagging.html>`_ in the *Developer Guide* . This ``Json`` property type is processed as a map of key-value pairs. It uses the following format, which is different from most ``Tags`` implementations in AWS CloudFormation templates:: "Tags": { "KeyName0": "value", "KeyName1": "value", "KeyName2": "value" }\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-functiondefinition.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    # tags: Any\n    # variables: Any\n\n    cfn_function_definition_props = greengrass.CfnFunctionDefinitionProps(\n        name="name",\n\n        # the properties below are optional\n        initial_version=greengrass.CfnFunctionDefinition.FunctionDefinitionVersionProperty(\n            functions=[greengrass.CfnFunctionDefinition.FunctionProperty(\n                function_arn="functionArn",\n                function_configuration=greengrass.CfnFunctionDefinition.FunctionConfigurationProperty(\n                    encoding_type="encodingType",\n                    environment=greengrass.CfnFunctionDefinition.EnvironmentProperty(\n                        access_sysfs=False,\n                        execution=greengrass.CfnFunctionDefinition.ExecutionProperty(\n                            isolation_mode="isolationMode",\n                            run_as=greengrass.CfnFunctionDefinition.RunAsProperty(\n                                gid=123,\n                                uid=123\n                            )\n                        ),\n                        resource_access_policies=[greengrass.CfnFunctionDefinition.ResourceAccessPolicyProperty(\n                            resource_id="resourceId",\n\n                            # the properties below are optional\n                            permission="permission"\n                        )],\n                        variables=variables\n                    ),\n                    exec_args="execArgs",\n                    executable="executable",\n                    memory_size=123,\n                    pinned=False,\n                    timeout=123\n                ),\n                id="id"\n            )],\n\n            # the properties below are optional\n            default_config=greengrass.CfnFunctionDefinition.DefaultConfigProperty(\n                execution=greengrass.CfnFunctionDefinition.ExecutionProperty(\n                    isolation_mode="isolationMode",\n                    run_as=greengrass.CfnFunctionDefinition.RunAsProperty(\n                        gid=123,\n                        uid=123\n                    )\n                )\n            )\n        ),\n        tags=tags\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'initial_version', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnFunctionDefinitionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnFunctionDefinitionVersionProps
class CfnFunctionDefinitionVersionPropsDef(BaseCfnProperty):
    function_definition_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the function definition associated with this version. This value is a GUID.\n')
    functions: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinitionVersion_FunctionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The functions in this version.\n')
    default_config: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnFunctionDefinitionVersion_DefaultConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The default configuration that applies to all Lambda functions in the group. Individual Lambda functions can override these settings.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-functiondefinitionversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    # variables: Any\n\n    cfn_function_definition_version_props = greengrass.CfnFunctionDefinitionVersionProps(\n        function_definition_id="functionDefinitionId",\n        functions=[greengrass.CfnFunctionDefinitionVersion.FunctionProperty(\n            function_arn="functionArn",\n            function_configuration=greengrass.CfnFunctionDefinitionVersion.FunctionConfigurationProperty(\n                encoding_type="encodingType",\n                environment=greengrass.CfnFunctionDefinitionVersion.EnvironmentProperty(\n                    access_sysfs=False,\n                    execution=greengrass.CfnFunctionDefinitionVersion.ExecutionProperty(\n                        isolation_mode="isolationMode",\n                        run_as=greengrass.CfnFunctionDefinitionVersion.RunAsProperty(\n                            gid=123,\n                            uid=123\n                        )\n                    ),\n                    resource_access_policies=[greengrass.CfnFunctionDefinitionVersion.ResourceAccessPolicyProperty(\n                        resource_id="resourceId",\n\n                        # the properties below are optional\n                        permission="permission"\n                    )],\n                    variables=variables\n                ),\n                exec_args="execArgs",\n                executable="executable",\n                memory_size=123,\n                pinned=False,\n                timeout=123\n            ),\n            id="id"\n        )],\n\n        # the properties below are optional\n        default_config=greengrass.CfnFunctionDefinitionVersion.DefaultConfigProperty(\n            execution=greengrass.CfnFunctionDefinitionVersion.ExecutionProperty(\n                isolation_mode="isolationMode",\n                run_as=greengrass.CfnFunctionDefinitionVersion.RunAsProperty(\n                    gid=123,\n                    uid=123\n                )\n            )\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['function_definition_id', 'functions', 'default_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnFunctionDefinitionVersionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnGroupProps
class CfnGroupPropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the group.\n')
    initial_version: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnGroup_GroupVersionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The group version to include when the group is created. A group version references the Amazon Resource Name (ARN) of a core definition version, device definition version, subscription definition version, and other version types. The group version must reference a core definition version that contains one core. Other version types are optionally included, depending on your business need. .. epigraph:: To associate a group version after the group is created, create an ```AWS::Greengrass::GroupVersion`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-groupversion.html>`_ resource and specify the ID of this group.\n')
    role_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the IAM role attached to the group. This role contains the permissions that Lambda functions and connectors use to interact with other AWS services.\n')
    tags: typing.Any = pydantic.Field(None, description='Application-specific metadata to attach to the group. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see `Tagging Your AWS IoT Greengrass Resources <https://docs.aws.amazon.com/greengrass/latest/developerguide/tagging.html>`_ in the *Developer Guide* . This ``Json`` property type is processed as a map of key-value pairs. It uses the following format, which is different from most ``Tags`` implementations in AWS CloudFormation templates:: "Tags": { "KeyName0": "value", "KeyName1": "value", "KeyName2": "value" }\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-group.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    # tags: Any\n\n    cfn_group_props = greengrass.CfnGroupProps(\n        name="name",\n\n        # the properties below are optional\n        initial_version=greengrass.CfnGroup.GroupVersionProperty(\n            connector_definition_version_arn="connectorDefinitionVersionArn",\n            core_definition_version_arn="coreDefinitionVersionArn",\n            device_definition_version_arn="deviceDefinitionVersionArn",\n            function_definition_version_arn="functionDefinitionVersionArn",\n            logger_definition_version_arn="loggerDefinitionVersionArn",\n            resource_definition_version_arn="resourceDefinitionVersionArn",\n            subscription_definition_version_arn="subscriptionDefinitionVersionArn"\n        ),\n        role_arn="roleArn",\n        tags=tags\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'initial_version', 'role_arn', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnGroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnGroupVersionProps
class CfnGroupVersionPropsDef(BaseCfnProperty):
    group_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the group associated with this version. This value is a GUID.\n')
    connector_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the connector definition version that contains the connectors you want to deploy with the group version.\n')
    core_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the core definition version that contains the core you want to deploy with the group version. Currently, the core definition version can contain only one core.\n')
    device_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the device definition version that contains the devices you want to deploy with the group version.\n')
    function_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the function definition version that contains the functions you want to deploy with the group version.\n')
    logger_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the logger definition version that contains the loggers you want to deploy with the group version.\n')
    resource_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the resource definition version that contains the resources you want to deploy with the group version.\n')
    subscription_definition_version_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the subscription definition version that contains the subscriptions you want to deploy with the group version.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-groupversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    cfn_group_version_props = greengrass.CfnGroupVersionProps(\n        group_id="groupId",\n\n        # the properties below are optional\n        connector_definition_version_arn="connectorDefinitionVersionArn",\n        core_definition_version_arn="coreDefinitionVersionArn",\n        device_definition_version_arn="deviceDefinitionVersionArn",\n        function_definition_version_arn="functionDefinitionVersionArn",\n        logger_definition_version_arn="loggerDefinitionVersionArn",\n        resource_definition_version_arn="resourceDefinitionVersionArn",\n        subscription_definition_version_arn="subscriptionDefinitionVersionArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['group_id', 'connector_definition_version_arn', 'core_definition_version_arn', 'device_definition_version_arn', 'function_definition_version_arn', 'logger_definition_version_arn', 'resource_definition_version_arn', 'subscription_definition_version_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnGroupVersionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnLoggerDefinitionProps
class CfnLoggerDefinitionPropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the logger definition.\n')
    initial_version: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnLoggerDefinition_LoggerDefinitionVersionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The logger definition version to include when the logger definition is created. A logger definition version contains a list of ```logger`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-loggerdefinition-logger.html>`_ property types. .. epigraph:: To associate a logger definition version after the logger definition is created, create an ```AWS::Greengrass::LoggerDefinitionVersion`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-loggerdefinitionversion.html>`_ resource and specify the ID of this logger definition.\n')
    tags: typing.Any = pydantic.Field(None, description='Application-specific metadata to attach to the logger definition. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see `Tagging Your AWS IoT Greengrass Resources <https://docs.aws.amazon.com/greengrass/latest/developerguide/tagging.html>`_ in the *Developer Guide* . This ``Json`` property type is processed as a map of key-value pairs. It uses the following format, which is different from most ``Tags`` implementations in AWS CloudFormation templates:: "Tags": { "KeyName0": "value", "KeyName1": "value", "KeyName2": "value" }\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-loggerdefinition.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    # tags: Any\n\n    cfn_logger_definition_props = greengrass.CfnLoggerDefinitionProps(\n        name="name",\n\n        # the properties below are optional\n        initial_version=greengrass.CfnLoggerDefinition.LoggerDefinitionVersionProperty(\n            loggers=[greengrass.CfnLoggerDefinition.LoggerProperty(\n                component="component",\n                id="id",\n                level="level",\n                type="type",\n\n                # the properties below are optional\n                space=123\n            )]\n        ),\n        tags=tags\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'initial_version', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnLoggerDefinitionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnLoggerDefinitionVersionProps
class CfnLoggerDefinitionVersionPropsDef(BaseCfnProperty):
    logger_definition_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the logger definition associated with this version. This value is a GUID.\n')
    loggers: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnLoggerDefinitionVersion_LoggerPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The loggers in this version.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-loggerdefinitionversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    cfn_logger_definition_version_props = greengrass.CfnLoggerDefinitionVersionProps(\n        logger_definition_id="loggerDefinitionId",\n        loggers=[greengrass.CfnLoggerDefinitionVersion.LoggerProperty(\n            component="component",\n            id="id",\n            level="level",\n            type="type",\n\n            # the properties below are optional\n            space=123\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['logger_definition_id', 'loggers']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnLoggerDefinitionVersionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinitionProps
class CfnResourceDefinitionPropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the resource definition.\n')
    initial_version: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinition_ResourceDefinitionVersionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The resource definition version to include when the resource definition is created. A resource definition version contains a list of ```resource instance`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-resourcedefinition-resourceinstance.html>`_ property types. .. epigraph:: To associate a resource definition version after the resource definition is created, create an ```AWS::Greengrass::ResourceDefinitionVersion`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-resourcedefinitionversion.html>`_ resource and specify the ID of this resource definition.\n')
    tags: typing.Any = pydantic.Field(None, description='Application-specific metadata to attach to the resource definition. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see `Tagging Your AWS IoT Greengrass Resources <https://docs.aws.amazon.com/greengrass/latest/developerguide/tagging.html>`_ in the *Developer Guide* . This ``Json`` property type is processed as a map of key-value pairs. It uses the following format, which is different from most ``Tags`` implementations in AWS CloudFormation templates:: "Tags": { "KeyName0": "value", "KeyName1": "value", "KeyName2": "value" }\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-resourcedefinition.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    # tags: Any\n\n    cfn_resource_definition_props = greengrass.CfnResourceDefinitionProps(\n        name="name",\n\n        # the properties below are optional\n        initial_version=greengrass.CfnResourceDefinition.ResourceDefinitionVersionProperty(\n            resources=[greengrass.CfnResourceDefinition.ResourceInstanceProperty(\n                id="id",\n                name="name",\n                resource_data_container=greengrass.CfnResourceDefinition.ResourceDataContainerProperty(\n                    local_device_resource_data=greengrass.CfnResourceDefinition.LocalDeviceResourceDataProperty(\n                        source_path="sourcePath",\n\n                        # the properties below are optional\n                        group_owner_setting=greengrass.CfnResourceDefinition.GroupOwnerSettingProperty(\n                            auto_add_group_owner=False,\n\n                            # the properties below are optional\n                            group_owner="groupOwner"\n                        )\n                    ),\n                    local_volume_resource_data=greengrass.CfnResourceDefinition.LocalVolumeResourceDataProperty(\n                        destination_path="destinationPath",\n                        source_path="sourcePath",\n\n                        # the properties below are optional\n                        group_owner_setting=greengrass.CfnResourceDefinition.GroupOwnerSettingProperty(\n                            auto_add_group_owner=False,\n\n                            # the properties below are optional\n                            group_owner="groupOwner"\n                        )\n                    ),\n                    s3_machine_learning_model_resource_data=greengrass.CfnResourceDefinition.S3MachineLearningModelResourceDataProperty(\n                        destination_path="destinationPath",\n                        s3_uri="s3Uri",\n\n                        # the properties below are optional\n                        owner_setting=greengrass.CfnResourceDefinition.ResourceDownloadOwnerSettingProperty(\n                            group_owner="groupOwner",\n                            group_permission="groupPermission"\n                        )\n                    ),\n                    sage_maker_machine_learning_model_resource_data=greengrass.CfnResourceDefinition.SageMakerMachineLearningModelResourceDataProperty(\n                        destination_path="destinationPath",\n                        sage_maker_job_arn="sageMakerJobArn",\n\n                        # the properties below are optional\n                        owner_setting=greengrass.CfnResourceDefinition.ResourceDownloadOwnerSettingProperty(\n                            group_owner="groupOwner",\n                            group_permission="groupPermission"\n                        )\n                    ),\n                    secrets_manager_secret_resource_data=greengrass.CfnResourceDefinition.SecretsManagerSecretResourceDataProperty(\n                        arn="arn",\n\n                        # the properties below are optional\n                        additional_staging_labels_to_download=["additionalStagingLabelsToDownload"]\n                    )\n                )\n            )]\n        ),\n        tags=tags\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'initial_version', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinitionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnResourceDefinitionVersionProps
class CfnResourceDefinitionVersionPropsDef(BaseCfnProperty):
    resource_definition_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the resource definition associated with this version. This value is a GUID.\n')
    resources: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnResourceDefinitionVersion_ResourceInstancePropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The resources in this version.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-resourcedefinitionversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    cfn_resource_definition_version_props = greengrass.CfnResourceDefinitionVersionProps(\n        resource_definition_id="resourceDefinitionId",\n        resources=[greengrass.CfnResourceDefinitionVersion.ResourceInstanceProperty(\n            id="id",\n            name="name",\n            resource_data_container=greengrass.CfnResourceDefinitionVersion.ResourceDataContainerProperty(\n                local_device_resource_data=greengrass.CfnResourceDefinitionVersion.LocalDeviceResourceDataProperty(\n                    source_path="sourcePath",\n\n                    # the properties below are optional\n                    group_owner_setting=greengrass.CfnResourceDefinitionVersion.GroupOwnerSettingProperty(\n                        auto_add_group_owner=False,\n\n                        # the properties below are optional\n                        group_owner="groupOwner"\n                    )\n                ),\n                local_volume_resource_data=greengrass.CfnResourceDefinitionVersion.LocalVolumeResourceDataProperty(\n                    destination_path="destinationPath",\n                    source_path="sourcePath",\n\n                    # the properties below are optional\n                    group_owner_setting=greengrass.CfnResourceDefinitionVersion.GroupOwnerSettingProperty(\n                        auto_add_group_owner=False,\n\n                        # the properties below are optional\n                        group_owner="groupOwner"\n                    )\n                ),\n                s3_machine_learning_model_resource_data=greengrass.CfnResourceDefinitionVersion.S3MachineLearningModelResourceDataProperty(\n                    destination_path="destinationPath",\n                    s3_uri="s3Uri",\n\n                    # the properties below are optional\n                    owner_setting=greengrass.CfnResourceDefinitionVersion.ResourceDownloadOwnerSettingProperty(\n                        group_owner="groupOwner",\n                        group_permission="groupPermission"\n                    )\n                ),\n                sage_maker_machine_learning_model_resource_data=greengrass.CfnResourceDefinitionVersion.SageMakerMachineLearningModelResourceDataProperty(\n                    destination_path="destinationPath",\n                    sage_maker_job_arn="sageMakerJobArn",\n\n                    # the properties below are optional\n                    owner_setting=greengrass.CfnResourceDefinitionVersion.ResourceDownloadOwnerSettingProperty(\n                        group_owner="groupOwner",\n                        group_permission="groupPermission"\n                    )\n                ),\n                secrets_manager_secret_resource_data=greengrass.CfnResourceDefinitionVersion.SecretsManagerSecretResourceDataProperty(\n                    arn="arn",\n\n                    # the properties below are optional\n                    additional_staging_labels_to_download=["additionalStagingLabelsToDownload"]\n                )\n            )\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resource_definition_id', 'resources']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnResourceDefinitionVersionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnSubscriptionDefinitionProps
class CfnSubscriptionDefinitionPropsDef(BaseCfnProperty):
    name: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The name of the subscription definition.\n')
    initial_version: typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnSubscriptionDefinition_SubscriptionDefinitionVersionPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The subscription definition version to include when the subscription definition is created. A subscription definition version contains a list of ```subscription`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-greengrass-subscriptiondefinition-subscription.html>`_ property types. .. epigraph:: To associate a subscription definition version after the subscription definition is created, create an ```AWS::Greengrass::SubscriptionDefinitionVersion`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-subscriptiondefinitionversion.html>`_ resource and specify the ID of this subscription definition.\n')
    tags: typing.Any = pydantic.Field(None, description='Application-specific metadata to attach to the subscription definition. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see `Tagging Your AWS IoT Greengrass Resources <https://docs.aws.amazon.com/greengrass/latest/developerguide/tagging.html>`_ in the *Developer Guide* . This ``Json`` property type is processed as a map of key-value pairs. It uses the following format, which is different from most ``Tags`` implementations in AWS CloudFormation templates:: "Tags": { "KeyName0": "value", "KeyName1": "value", "KeyName2": "value" }\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-subscriptiondefinition.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    # tags: Any\n\n    cfn_subscription_definition_props = greengrass.CfnSubscriptionDefinitionProps(\n        name="name",\n\n        # the properties below are optional\n        initial_version=greengrass.CfnSubscriptionDefinition.SubscriptionDefinitionVersionProperty(\n            subscriptions=[greengrass.CfnSubscriptionDefinition.SubscriptionProperty(\n                id="id",\n                source="source",\n                subject="subject",\n                target="target"\n            )]\n        ),\n        tags=tags\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'initial_version', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnSubscriptionDefinitionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_greengrass.CfnSubscriptionDefinitionVersionProps
class CfnSubscriptionDefinitionVersionPropsDef(BaseCfnProperty):
    subscription_definition_id: typing.Union[str, _REQUIRED_INIT_PARAM] = pydantic.Field(REQUIRED_INIT_PARAM, description='The ID of the subscription definition associated with this version. This value is a GUID.\n')
    subscriptions: typing.Union[_REQUIRED_INIT_PARAM, models.UnsupportedResource, typing.Sequence[typing.Union[models.UnsupportedResource, models.aws_greengrass.CfnSubscriptionDefinitionVersion_SubscriptionPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(REQUIRED_INIT_PARAM, description='The subscriptions in this version.\n\n:see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-greengrass-subscriptiondefinitionversion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_greengrass as greengrass\n\n    cfn_subscription_definition_version_props = greengrass.CfnSubscriptionDefinitionVersionProps(\n        subscription_definition_id="subscriptionDefinitionId",\n        subscriptions=[greengrass.CfnSubscriptionDefinitionVersion.SubscriptionProperty(\n            id="id",\n            source="source",\n            subject="subject",\n            target="target"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['subscription_definition_id', 'subscriptions']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_greengrass.CfnSubscriptionDefinitionVersionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




class ModuleModel(pydantic.BaseModel):
    CfnConnectorDefinition_ConnectorDefinitionVersionProperty: typing.Optional[dict[str, models.aws_greengrass.CfnConnectorDefinition_ConnectorDefinitionVersionPropertyDef]] = pydantic.Field(None)
    CfnConnectorDefinition_ConnectorProperty: typing.Optional[dict[str, models.aws_greengrass.CfnConnectorDefinition_ConnectorPropertyDef]] = pydantic.Field(None)
    CfnConnectorDefinitionVersion_ConnectorProperty: typing.Optional[dict[str, models.aws_greengrass.CfnConnectorDefinitionVersion_ConnectorPropertyDef]] = pydantic.Field(None)
    CfnCoreDefinition_CoreDefinitionVersionProperty: typing.Optional[dict[str, models.aws_greengrass.CfnCoreDefinition_CoreDefinitionVersionPropertyDef]] = pydantic.Field(None)
    CfnCoreDefinition_CoreProperty: typing.Optional[dict[str, models.aws_greengrass.CfnCoreDefinition_CorePropertyDef]] = pydantic.Field(None)
    CfnCoreDefinitionVersion_CoreProperty: typing.Optional[dict[str, models.aws_greengrass.CfnCoreDefinitionVersion_CorePropertyDef]] = pydantic.Field(None)
    CfnDeviceDefinition_DeviceDefinitionVersionProperty: typing.Optional[dict[str, models.aws_greengrass.CfnDeviceDefinition_DeviceDefinitionVersionPropertyDef]] = pydantic.Field(None)
    CfnDeviceDefinition_DeviceProperty: typing.Optional[dict[str, models.aws_greengrass.CfnDeviceDefinition_DevicePropertyDef]] = pydantic.Field(None)
    CfnDeviceDefinitionVersion_DeviceProperty: typing.Optional[dict[str, models.aws_greengrass.CfnDeviceDefinitionVersion_DevicePropertyDef]] = pydantic.Field(None)
    CfnFunctionDefinition_DefaultConfigProperty: typing.Optional[dict[str, models.aws_greengrass.CfnFunctionDefinition_DefaultConfigPropertyDef]] = pydantic.Field(None)
    CfnFunctionDefinition_EnvironmentProperty: typing.Optional[dict[str, models.aws_greengrass.CfnFunctionDefinition_EnvironmentPropertyDef]] = pydantic.Field(None)
    CfnFunctionDefinition_ExecutionProperty: typing.Optional[dict[str, models.aws_greengrass.CfnFunctionDefinition_ExecutionPropertyDef]] = pydantic.Field(None)
    CfnFunctionDefinition_FunctionConfigurationProperty: typing.Optional[dict[str, models.aws_greengrass.CfnFunctionDefinition_FunctionConfigurationPropertyDef]] = pydantic.Field(None)
    CfnFunctionDefinition_FunctionDefinitionVersionProperty: typing.Optional[dict[str, models.aws_greengrass.CfnFunctionDefinition_FunctionDefinitionVersionPropertyDef]] = pydantic.Field(None)
    CfnFunctionDefinition_FunctionProperty: typing.Optional[dict[str, models.aws_greengrass.CfnFunctionDefinition_FunctionPropertyDef]] = pydantic.Field(None)
    CfnFunctionDefinition_ResourceAccessPolicyProperty: typing.Optional[dict[str, models.aws_greengrass.CfnFunctionDefinition_ResourceAccessPolicyPropertyDef]] = pydantic.Field(None)
    CfnFunctionDefinition_RunAsProperty: typing.Optional[dict[str, models.aws_greengrass.CfnFunctionDefinition_RunAsPropertyDef]] = pydantic.Field(None)
    CfnFunctionDefinitionVersion_DefaultConfigProperty: typing.Optional[dict[str, models.aws_greengrass.CfnFunctionDefinitionVersion_DefaultConfigPropertyDef]] = pydantic.Field(None)
    CfnFunctionDefinitionVersion_EnvironmentProperty: typing.Optional[dict[str, models.aws_greengrass.CfnFunctionDefinitionVersion_EnvironmentPropertyDef]] = pydantic.Field(None)
    CfnFunctionDefinitionVersion_ExecutionProperty: typing.Optional[dict[str, models.aws_greengrass.CfnFunctionDefinitionVersion_ExecutionPropertyDef]] = pydantic.Field(None)
    CfnFunctionDefinitionVersion_FunctionConfigurationProperty: typing.Optional[dict[str, models.aws_greengrass.CfnFunctionDefinitionVersion_FunctionConfigurationPropertyDef]] = pydantic.Field(None)
    CfnFunctionDefinitionVersion_FunctionProperty: typing.Optional[dict[str, models.aws_greengrass.CfnFunctionDefinitionVersion_FunctionPropertyDef]] = pydantic.Field(None)
    CfnFunctionDefinitionVersion_ResourceAccessPolicyProperty: typing.Optional[dict[str, models.aws_greengrass.CfnFunctionDefinitionVersion_ResourceAccessPolicyPropertyDef]] = pydantic.Field(None)
    CfnFunctionDefinitionVersion_RunAsProperty: typing.Optional[dict[str, models.aws_greengrass.CfnFunctionDefinitionVersion_RunAsPropertyDef]] = pydantic.Field(None)
    CfnGroup_GroupVersionProperty: typing.Optional[dict[str, models.aws_greengrass.CfnGroup_GroupVersionPropertyDef]] = pydantic.Field(None)
    CfnLoggerDefinition_LoggerDefinitionVersionProperty: typing.Optional[dict[str, models.aws_greengrass.CfnLoggerDefinition_LoggerDefinitionVersionPropertyDef]] = pydantic.Field(None)
    CfnLoggerDefinition_LoggerProperty: typing.Optional[dict[str, models.aws_greengrass.CfnLoggerDefinition_LoggerPropertyDef]] = pydantic.Field(None)
    CfnLoggerDefinitionVersion_LoggerProperty: typing.Optional[dict[str, models.aws_greengrass.CfnLoggerDefinitionVersion_LoggerPropertyDef]] = pydantic.Field(None)
    CfnResourceDefinition_GroupOwnerSettingProperty: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinition_GroupOwnerSettingPropertyDef]] = pydantic.Field(None)
    CfnResourceDefinition_LocalDeviceResourceDataProperty: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinition_LocalDeviceResourceDataPropertyDef]] = pydantic.Field(None)
    CfnResourceDefinition_LocalVolumeResourceDataProperty: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinition_LocalVolumeResourceDataPropertyDef]] = pydantic.Field(None)
    CfnResourceDefinition_ResourceDataContainerProperty: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinition_ResourceDataContainerPropertyDef]] = pydantic.Field(None)
    CfnResourceDefinition_ResourceDefinitionVersionProperty: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinition_ResourceDefinitionVersionPropertyDef]] = pydantic.Field(None)
    CfnResourceDefinition_ResourceDownloadOwnerSettingProperty: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinition_ResourceDownloadOwnerSettingPropertyDef]] = pydantic.Field(None)
    CfnResourceDefinition_ResourceInstanceProperty: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinition_ResourceInstancePropertyDef]] = pydantic.Field(None)
    CfnResourceDefinition_S3MachineLearningModelResourceDataProperty: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinition_S3MachineLearningModelResourceDataPropertyDef]] = pydantic.Field(None)
    CfnResourceDefinition_SageMakerMachineLearningModelResourceDataProperty: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinition_SageMakerMachineLearningModelResourceDataPropertyDef]] = pydantic.Field(None)
    CfnResourceDefinition_SecretsManagerSecretResourceDataProperty: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinition_SecretsManagerSecretResourceDataPropertyDef]] = pydantic.Field(None)
    CfnResourceDefinitionVersion_GroupOwnerSettingProperty: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinitionVersion_GroupOwnerSettingPropertyDef]] = pydantic.Field(None)
    CfnResourceDefinitionVersion_LocalDeviceResourceDataProperty: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinitionVersion_LocalDeviceResourceDataPropertyDef]] = pydantic.Field(None)
    CfnResourceDefinitionVersion_LocalVolumeResourceDataProperty: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinitionVersion_LocalVolumeResourceDataPropertyDef]] = pydantic.Field(None)
    CfnResourceDefinitionVersion_ResourceDataContainerProperty: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinitionVersion_ResourceDataContainerPropertyDef]] = pydantic.Field(None)
    CfnResourceDefinitionVersion_ResourceDownloadOwnerSettingProperty: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinitionVersion_ResourceDownloadOwnerSettingPropertyDef]] = pydantic.Field(None)
    CfnResourceDefinitionVersion_ResourceInstanceProperty: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinitionVersion_ResourceInstancePropertyDef]] = pydantic.Field(None)
    CfnResourceDefinitionVersion_S3MachineLearningModelResourceDataProperty: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinitionVersion_S3MachineLearningModelResourceDataPropertyDef]] = pydantic.Field(None)
    CfnResourceDefinitionVersion_SageMakerMachineLearningModelResourceDataProperty: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinitionVersion_SageMakerMachineLearningModelResourceDataPropertyDef]] = pydantic.Field(None)
    CfnResourceDefinitionVersion_SecretsManagerSecretResourceDataProperty: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinitionVersion_SecretsManagerSecretResourceDataPropertyDef]] = pydantic.Field(None)
    CfnSubscriptionDefinition_SubscriptionDefinitionVersionProperty: typing.Optional[dict[str, models.aws_greengrass.CfnSubscriptionDefinition_SubscriptionDefinitionVersionPropertyDef]] = pydantic.Field(None)
    CfnSubscriptionDefinition_SubscriptionProperty: typing.Optional[dict[str, models.aws_greengrass.CfnSubscriptionDefinition_SubscriptionPropertyDef]] = pydantic.Field(None)
    CfnSubscriptionDefinitionVersion_SubscriptionProperty: typing.Optional[dict[str, models.aws_greengrass.CfnSubscriptionDefinitionVersion_SubscriptionPropertyDef]] = pydantic.Field(None)
    CfnConnectorDefinition: typing.Optional[dict[str, models.aws_greengrass.CfnConnectorDefinitionDef]] = pydantic.Field(None)
    CfnConnectorDefinitionVersion: typing.Optional[dict[str, models.aws_greengrass.CfnConnectorDefinitionVersionDef]] = pydantic.Field(None)
    CfnCoreDefinition: typing.Optional[dict[str, models.aws_greengrass.CfnCoreDefinitionDef]] = pydantic.Field(None)
    CfnCoreDefinitionVersion: typing.Optional[dict[str, models.aws_greengrass.CfnCoreDefinitionVersionDef]] = pydantic.Field(None)
    CfnDeviceDefinition: typing.Optional[dict[str, models.aws_greengrass.CfnDeviceDefinitionDef]] = pydantic.Field(None)
    CfnDeviceDefinitionVersion: typing.Optional[dict[str, models.aws_greengrass.CfnDeviceDefinitionVersionDef]] = pydantic.Field(None)
    CfnFunctionDefinition: typing.Optional[dict[str, models.aws_greengrass.CfnFunctionDefinitionDef]] = pydantic.Field(None)
    CfnFunctionDefinitionVersion: typing.Optional[dict[str, models.aws_greengrass.CfnFunctionDefinitionVersionDef]] = pydantic.Field(None)
    CfnGroup: typing.Optional[dict[str, models.aws_greengrass.CfnGroupDef]] = pydantic.Field(None)
    CfnGroupVersion: typing.Optional[dict[str, models.aws_greengrass.CfnGroupVersionDef]] = pydantic.Field(None)
    CfnLoggerDefinition: typing.Optional[dict[str, models.aws_greengrass.CfnLoggerDefinitionDef]] = pydantic.Field(None)
    CfnLoggerDefinitionVersion: typing.Optional[dict[str, models.aws_greengrass.CfnLoggerDefinitionVersionDef]] = pydantic.Field(None)
    CfnResourceDefinition: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinitionDef]] = pydantic.Field(None)
    CfnResourceDefinitionVersion: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinitionVersionDef]] = pydantic.Field(None)
    CfnSubscriptionDefinition: typing.Optional[dict[str, models.aws_greengrass.CfnSubscriptionDefinitionDef]] = pydantic.Field(None)
    CfnSubscriptionDefinitionVersion: typing.Optional[dict[str, models.aws_greengrass.CfnSubscriptionDefinitionVersionDef]] = pydantic.Field(None)
    CfnConnectorDefinitionProps: typing.Optional[dict[str, models.aws_greengrass.CfnConnectorDefinitionPropsDef]] = pydantic.Field(None)
    CfnConnectorDefinitionVersionProps: typing.Optional[dict[str, models.aws_greengrass.CfnConnectorDefinitionVersionPropsDef]] = pydantic.Field(None)
    CfnCoreDefinitionProps: typing.Optional[dict[str, models.aws_greengrass.CfnCoreDefinitionPropsDef]] = pydantic.Field(None)
    CfnCoreDefinitionVersionProps: typing.Optional[dict[str, models.aws_greengrass.CfnCoreDefinitionVersionPropsDef]] = pydantic.Field(None)
    CfnDeviceDefinitionProps: typing.Optional[dict[str, models.aws_greengrass.CfnDeviceDefinitionPropsDef]] = pydantic.Field(None)
    CfnDeviceDefinitionVersionProps: typing.Optional[dict[str, models.aws_greengrass.CfnDeviceDefinitionVersionPropsDef]] = pydantic.Field(None)
    CfnFunctionDefinitionProps: typing.Optional[dict[str, models.aws_greengrass.CfnFunctionDefinitionPropsDef]] = pydantic.Field(None)
    CfnFunctionDefinitionVersionProps: typing.Optional[dict[str, models.aws_greengrass.CfnFunctionDefinitionVersionPropsDef]] = pydantic.Field(None)
    CfnGroupProps: typing.Optional[dict[str, models.aws_greengrass.CfnGroupPropsDef]] = pydantic.Field(None)
    CfnGroupVersionProps: typing.Optional[dict[str, models.aws_greengrass.CfnGroupVersionPropsDef]] = pydantic.Field(None)
    CfnLoggerDefinitionProps: typing.Optional[dict[str, models.aws_greengrass.CfnLoggerDefinitionPropsDef]] = pydantic.Field(None)
    CfnLoggerDefinitionVersionProps: typing.Optional[dict[str, models.aws_greengrass.CfnLoggerDefinitionVersionPropsDef]] = pydantic.Field(None)
    CfnResourceDefinitionProps: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinitionPropsDef]] = pydantic.Field(None)
    CfnResourceDefinitionVersionProps: typing.Optional[dict[str, models.aws_greengrass.CfnResourceDefinitionVersionPropsDef]] = pydantic.Field(None)
    CfnSubscriptionDefinitionProps: typing.Optional[dict[str, models.aws_greengrass.CfnSubscriptionDefinitionPropsDef]] = pydantic.Field(None)
    CfnSubscriptionDefinitionVersionProps: typing.Optional[dict[str, models.aws_greengrass.CfnSubscriptionDefinitionVersionPropsDef]] = pydantic.Field(None)
    ...

import models
