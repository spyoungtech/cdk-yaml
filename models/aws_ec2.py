from __future__ import annotations
import typing
import aws_cdk
import constructs
import pydantic
import datetime
from ._base import BaseConstruct, BaseClass, BaseStruct, BaseCfnResource, BaseCfnProperty, ConnectableMixin, BaseMethodParams, GenericApplyRemovalPolicyParams

#  autogenerated from aws_cdk.aws_ec2.AclCidr
class AclCidrDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['any_ipv4', 'any_ipv6', 'ipv4', 'ipv6']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AclCidr'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AclCidrDefConfig] = pydantic.Field(None)


class AclCidrDefConfig(pydantic.BaseModel):
    any_ipv4: typing.Optional[list[AclCidrDefAnyIpv4Params]] = pydantic.Field(None, description='The CIDR containing all IPv4 addresses (i.e., 0.0.0.0/0).')
    any_ipv6: typing.Optional[list[AclCidrDefAnyIpv6Params]] = pydantic.Field(None, description='The CIDR containing all IPv6 addresses (i.e., ::/0).')
    ipv4: typing.Optional[list[AclCidrDefIpv4Params]] = pydantic.Field(None, description='An IP network range in CIDR notation (for example, 172.16.0.0/24).')
    ipv6: typing.Optional[list[AclCidrDefIpv6Params]] = pydantic.Field(None, description='An IPv6 network range in CIDR notation (for example, 2001:db8::/48).')

class AclCidrDefAnyIpv4Params(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_ec2.AclCidrDefConfig]] = pydantic.Field(None)
    ...

class AclCidrDefAnyIpv6Params(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_ec2.AclCidrDefConfig]] = pydantic.Field(None)
    ...

class AclCidrDefIpv4Params(pydantic.BaseModel):
    ipv4_cidr: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.AclCidrDefConfig]] = pydantic.Field(None)
    ...

class AclCidrDefIpv6Params(pydantic.BaseModel):
    ipv6_cidr: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.AclCidrDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_ec2.AclTraffic
class AclTrafficDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['all_traffic', 'icmp', 'icmpv6', 'tcp_port', 'tcp_port_range', 'udp_port', 'udp_port_range']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AclTraffic'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AclTrafficDefConfig] = pydantic.Field(None)


class AclTrafficDefConfig(pydantic.BaseModel):
    all_traffic: typing.Optional[list[AclTrafficDefAllTrafficParams]] = pydantic.Field(None, description='Apply the ACL entry to all traffic.')
    icmp: typing.Optional[list[AclTrafficDefIcmpParams]] = pydantic.Field(None, description='Apply the ACL entry to ICMP traffic of given type and code.')
    icmpv6: typing.Optional[list[AclTrafficDefIcmpv6Params]] = pydantic.Field(None, description='Apply the ACL entry to ICMPv6 traffic of given type and code.\nRequires an IPv6 CIDR block.')
    tcp_port: typing.Optional[list[AclTrafficDefTcpPortParams]] = pydantic.Field(None, description='Apply the ACL entry to TCP traffic on a given port.')
    tcp_port_range: typing.Optional[list[AclTrafficDefTcpPortRangeParams]] = pydantic.Field(None, description='Apply the ACL entry to TCP traffic on a given port range.')
    udp_port: typing.Optional[list[AclTrafficDefUdpPortParams]] = pydantic.Field(None, description='Apply the ACL entry to UDP traffic on a given port.')
    udp_port_range: typing.Optional[list[AclTrafficDefUdpPortRangeParams]] = pydantic.Field(None, description='Apply the ACL entry to UDP traffic on a given port range.')

class AclTrafficDefAllTrafficParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_ec2.AclTrafficDefConfig]] = pydantic.Field(None)
    ...

class AclTrafficDefIcmpParams(pydantic.BaseModel):
    code: typing.Union[int, float, None] = pydantic.Field(None, description='The Internet Control Message Protocol (ICMP) code. You can use -1 to specify all ICMP codes for the given ICMP type. Requirement is conditional: Required if you specify 1 (ICMP) for the protocol parameter.\n')
    type: typing.Union[int, float, None] = pydantic.Field(None, description='The Internet Control Message Protocol (ICMP) type. You can use -1 to specify all ICMP types. Conditional requirement: Required if you specify 1 (ICMP) for the CreateNetworkAclEntry protocol parameter.')
    return_config: typing.Optional[list[models.aws_ec2.AclTrafficDefConfig]] = pydantic.Field(None)
    ...

class AclTrafficDefIcmpv6Params(pydantic.BaseModel):
    code: typing.Union[int, float, None] = pydantic.Field(None, description='The Internet Control Message Protocol (ICMP) code. You can use -1 to specify all ICMP codes for the given ICMP type. Requirement is conditional: Required if you specify 1 (ICMP) for the protocol parameter.\n')
    type: typing.Union[int, float, None] = pydantic.Field(None, description='The Internet Control Message Protocol (ICMP) type. You can use -1 to specify all ICMP types. Conditional requirement: Required if you specify 1 (ICMP) for the CreateNetworkAclEntry protocol parameter.')
    return_config: typing.Optional[list[models.aws_ec2.AclTrafficDefConfig]] = pydantic.Field(None)
    ...

class AclTrafficDefTcpPortParams(pydantic.BaseModel):
    port: typing.Union[int, float] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.AclTrafficDefConfig]] = pydantic.Field(None)
    ...

class AclTrafficDefTcpPortRangeParams(pydantic.BaseModel):
    start_port: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    end_port: typing.Union[int, float] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.AclTrafficDefConfig]] = pydantic.Field(None)
    ...

class AclTrafficDefUdpPortParams(pydantic.BaseModel):
    port: typing.Union[int, float] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.AclTrafficDefConfig]] = pydantic.Field(None)
    ...

class AclTrafficDefUdpPortRangeParams(pydantic.BaseModel):
    start_port: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    end_port: typing.Union[int, float] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.AclTrafficDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_ec2.AmazonLinux2022ImageSsmParameter
class AmazonLinux2022ImageSsmParameterDef(BaseClass):
    kernel: typing.Optional[models.aws_ec2.AmazonLinux2022KernelDef] = pydantic.Field(None, description='What kernel version of Amazon Linux to use. Default: AmazonLinux2022Kernel.DEFAULT')
    cpu_type: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxCpuType] = pydantic.Field(None, description='CPU Type. Default: AmazonLinuxCpuType.X86_64\n')
    edition: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxEdition] = pydantic.Field(None, description='What edition of Amazon Linux to use. Default: AmazonLinuxEdition.Standard\n')
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false\n")
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines')
    _init_params: typing.ClassVar[list[str]] = ['kernel', 'cpu_type', 'edition', 'cached_in_context', 'user_data']
    _method_names: typing.ClassVar[list[str]] = ['get_image']
    _classmethod_names: typing.ClassVar[list[str]] = ['ssm_parameter_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AmazonLinux2022ImageSsmParameter'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AmazonLinux2022ImageSsmParameterDefConfig] = pydantic.Field(None)


class AmazonLinux2022ImageSsmParameterDefConfig(pydantic.BaseModel):
    get_image: typing.Optional[list[AmazonLinux2022ImageSsmParameterDefGetImageParams]] = pydantic.Field(None, description='Return the image to use in the given context.')
    ssm_parameter_name: typing.Optional[list[AmazonLinux2022ImageSsmParameterDefSsmParameterNameParams]] = pydantic.Field(None, description='Generates a SSM Parameter name for a specific amazon linux 2022 AMI.\nExample values::\n\n   "/aws/service/ami-amazon-linux-latest/al2022-ami-kernel-5.15-x86_64",\n   "/aws/service/ami-amazon-linux-latest/al2022-ami-kernel-default-x86_64",\n   "/aws/service/ami-amazon-linux-latest/al2022-ami-minimal-kernel-5.15-arm64",\n   "/aws/service/ami-amazon-linux-latest/al2022-ami-minimal-kernel-5.15-x86_64",\n   "/aws/service/ami-amazon-linux-latest/al2022-ami-kernel-5.15-arm64",\n   "/aws/service/ami-amazon-linux-latest/al2022-ami-minimal-kernel-default-arm64",\n   "/aws/service/ami-amazon-linux-latest/al2022-ami-minimal-kernel-default-x86_64",\n   "/aws/service/ami-amazon-linux-latest/al2022-ami-kernel-default-arm64",')

class AmazonLinux2022ImageSsmParameterDefGetImageParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class AmazonLinux2022ImageSsmParameterDefSsmParameterNameParams(pydantic.BaseModel):
    kernel: typing.Optional[models.aws_ec2.AmazonLinux2022KernelDef] = pydantic.Field(None, description='What kernel version of Amazon Linux to use. Default: AmazonLinux2022Kernel.DEFAULT\n')
    cpu_type: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxCpuType] = pydantic.Field(None, description='CPU Type. Default: AmazonLinuxCpuType.X86_64\n')
    edition: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxEdition] = pydantic.Field(None, description='What edition of Amazon Linux to use. Default: AmazonLinuxEdition.Standard\n')
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false\n")
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines')
    ...


#  autogenerated from aws_cdk.aws_ec2.AmazonLinux2022Kernel
class AmazonLinux2022KernelDef(BaseClass):
    version: str = pydantic.Field(..., description='-')
    _init_params: typing.ClassVar[list[str]] = ['version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AmazonLinux2022Kernel'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.AmazonLinux2023ImageSsmParameter
class AmazonLinux2023ImageSsmParameterDef(BaseClass):
    kernel: typing.Optional[models.aws_ec2.AmazonLinux2023KernelDef] = pydantic.Field(None, description='What kernel version of Amazon Linux to use. Default: AmazonLinux2023Kernel.DEFAULT')
    cpu_type: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxCpuType] = pydantic.Field(None, description='CPU Type. Default: AmazonLinuxCpuType.X86_64\n')
    edition: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxEdition] = pydantic.Field(None, description='What edition of Amazon Linux to use. Default: AmazonLinuxEdition.Standard\n')
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false\n")
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines')
    _init_params: typing.ClassVar[list[str]] = ['kernel', 'cpu_type', 'edition', 'cached_in_context', 'user_data']
    _method_names: typing.ClassVar[list[str]] = ['get_image']
    _classmethod_names: typing.ClassVar[list[str]] = ['ssm_parameter_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AmazonLinux2023ImageSsmParameter'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AmazonLinux2023ImageSsmParameterDefConfig] = pydantic.Field(None)


class AmazonLinux2023ImageSsmParameterDefConfig(pydantic.BaseModel):
    get_image: typing.Optional[list[AmazonLinux2023ImageSsmParameterDefGetImageParams]] = pydantic.Field(None, description='Return the image to use in the given context.')
    ssm_parameter_name: typing.Optional[list[AmazonLinux2023ImageSsmParameterDefSsmParameterNameParams]] = pydantic.Field(None, description='Generates a SSM Parameter name for a specific amazon linux 2022 AMI.\nExample values::\n\n   "/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-6.1-arm64",\n   "/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-6.1-x86_64",\n   "/aws/service/ami-amazon-linux-latest/al2023-ami-minimal-kernel-6.1-arm64",\n   "/aws/service/ami-amazon-linux-latest/al2023-ami-minimal-kernel-6.1-x86_64",\n   "/aws/service/ami-amazon-linux-latest/al2023-ami-minimal-kernel-default-arm64",\n   "/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-x86_64",\n   "/aws/service/ami-amazon-linux-latest/al2023-ami-minimal-kernel-default-x86_64",\n   "/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-arm64",')

class AmazonLinux2023ImageSsmParameterDefGetImageParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class AmazonLinux2023ImageSsmParameterDefSsmParameterNameParams(pydantic.BaseModel):
    kernel: typing.Optional[models.aws_ec2.AmazonLinux2023KernelDef] = pydantic.Field(None, description='What kernel version of Amazon Linux to use. Default: AmazonLinux2023Kernel.DEFAULT\n')
    cpu_type: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxCpuType] = pydantic.Field(None, description='CPU Type. Default: AmazonLinuxCpuType.X86_64\n')
    edition: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxEdition] = pydantic.Field(None, description='What edition of Amazon Linux to use. Default: AmazonLinuxEdition.Standard\n')
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false\n")
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines')
    ...


#  autogenerated from aws_cdk.aws_ec2.AmazonLinux2023Kernel
class AmazonLinux2023KernelDef(BaseClass):
    version: str = pydantic.Field(..., description='-')
    _init_params: typing.ClassVar[list[str]] = ['version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AmazonLinux2023Kernel'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.AmazonLinux2ImageSsmParameter
class AmazonLinux2ImageSsmParameterDef(BaseClass):
    kernel: typing.Optional[models.aws_ec2.AmazonLinux2KernelDef] = pydantic.Field(None, description='What kernel version of Amazon Linux to use. Default: -')
    storage: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxStorage] = pydantic.Field(None, description='What storage backed image to use. Default: GeneralPurpose\n')
    virtualization: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxVirt] = pydantic.Field(None, description='Virtualization type. Default: HVM\n')
    cpu_type: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxCpuType] = pydantic.Field(None, description='CPU Type. Default: AmazonLinuxCpuType.X86_64\n')
    edition: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxEdition] = pydantic.Field(None, description='What edition of Amazon Linux to use. Default: AmazonLinuxEdition.Standard\n')
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false\n")
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines')
    _init_params: typing.ClassVar[list[str]] = ['kernel', 'storage', 'virtualization', 'cpu_type', 'edition', 'cached_in_context', 'user_data']
    _method_names: typing.ClassVar[list[str]] = ['get_image']
    _classmethod_names: typing.ClassVar[list[str]] = ['ssm_parameter_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AmazonLinux2ImageSsmParameter'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AmazonLinux2ImageSsmParameterDefConfig] = pydantic.Field(None)


class AmazonLinux2ImageSsmParameterDefConfig(pydantic.BaseModel):
    get_image: typing.Optional[list[AmazonLinux2ImageSsmParameterDefGetImageParams]] = pydantic.Field(None, description='Return the image to use in the given context.')
    ssm_parameter_name: typing.Optional[list[AmazonLinux2ImageSsmParameterDefSsmParameterNameParams]] = pydantic.Field(None, description='Generates a SSM Parameter name for a specific amazon linux 2 AMI.\nExample values::\n\n   "/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-ebs",\n   "/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2",\n   "/aws/service/ami-amazon-linux-latest/amzn2-ami-kernel-5.10-hvm-x86_64-ebs",\n   "/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-arm64-gp2",\n   "/aws/service/ami-amazon-linux-latest/amzn2-ami-minimal-hvm-arm64-ebs",\n   "/aws/service/ami-amazon-linux-latest/amzn2-ami-kernel-5.10-hvm-arm64-gp2",\n   "/aws/service/ami-amazon-linux-latest/amzn2-ami-kernel-5.10-hvm-x86_64-gp2",\n   "/aws/service/ami-amazon-linux-latest/amzn2-ami-minimal-hvm-x86_64-ebs"')

class AmazonLinux2ImageSsmParameterDefGetImageParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class AmazonLinux2ImageSsmParameterDefSsmParameterNameParams(pydantic.BaseModel):
    kernel: typing.Optional[models.aws_ec2.AmazonLinux2KernelDef] = pydantic.Field(None, description='What kernel version of Amazon Linux to use. Default: -\n')
    storage: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxStorage] = pydantic.Field(None, description='What storage backed image to use. Default: GeneralPurpose\n')
    virtualization: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxVirt] = pydantic.Field(None, description='Virtualization type. Default: HVM\n')
    cpu_type: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxCpuType] = pydantic.Field(None, description='CPU Type. Default: AmazonLinuxCpuType.X86_64\n')
    edition: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxEdition] = pydantic.Field(None, description='What edition of Amazon Linux to use. Default: AmazonLinuxEdition.Standard\n')
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false\n")
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines')
    ...


#  autogenerated from aws_cdk.aws_ec2.AmazonLinux2Kernel
class AmazonLinux2KernelDef(BaseClass):
    version: str = pydantic.Field(..., description='-')
    _init_params: typing.ClassVar[list[str]] = ['version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AmazonLinux2Kernel'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.AmazonLinuxImage
class AmazonLinuxImageDef(BaseClass):
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false")
    cpu_type: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxCpuType] = pydantic.Field(None, description='CPU Type. Default: X86_64\n')
    edition: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxEdition] = pydantic.Field(None, description='What edition of Amazon Linux to use. Default: Standard\n')
    generation: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxGeneration] = pydantic.Field(None, description='What generation of Amazon Linux to use. Default: AmazonLinux\n')
    kernel: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxKernel] = pydantic.Field(None, description='What kernel version of Amazon Linux to use. Default: -\n')
    storage: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxStorage] = pydantic.Field(None, description='What storage backed image to use. Default: GeneralPurpose\n')
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines\n')
    virtualization: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxVirt] = pydantic.Field(None, description='Virtualization type. Default: HVM')
    _init_params: typing.ClassVar[list[str]] = ['cached_in_context', 'cpu_type', 'edition', 'generation', 'kernel', 'storage', 'user_data', 'virtualization']
    _method_names: typing.ClassVar[list[str]] = ['get_image']
    _classmethod_names: typing.ClassVar[list[str]] = ['ssm_parameter_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AmazonLinuxImage'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AmazonLinuxImageDefConfig] = pydantic.Field(None)


class AmazonLinuxImageDefConfig(pydantic.BaseModel):
    get_image: typing.Optional[list[AmazonLinuxImageDefGetImageParams]] = pydantic.Field(None, description='Return the image to use in the given context.')
    ssm_parameter_name: typing.Optional[list[AmazonLinuxImageDefSsmParameterNameParams]] = pydantic.Field(None, description='Return the SSM parameter name that will contain the Amazon Linux image with the given attributes.')

class AmazonLinuxImageDefGetImageParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...

class AmazonLinuxImageDefSsmParameterNameParams(pydantic.BaseModel):
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false\n")
    cpu_type: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxCpuType] = pydantic.Field(None, description='CPU Type. Default: X86_64\n')
    edition: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxEdition] = pydantic.Field(None, description='What edition of Amazon Linux to use. Default: Standard\n')
    generation: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxGeneration] = pydantic.Field(None, description='What generation of Amazon Linux to use. Default: AmazonLinux\n')
    kernel: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxKernel] = pydantic.Field(None, description='What kernel version of Amazon Linux to use. Default: -\n')
    storage: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxStorage] = pydantic.Field(None, description='What storage backed image to use. Default: GeneralPurpose\n')
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines\n')
    virtualization: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxVirt] = pydantic.Field(None, description='Virtualization type. Default: HVM')
    ...


#  autogenerated from aws_cdk.aws_ec2.AmazonLinuxImageSsmParameterBase
class AmazonLinuxImageSsmParameterBaseDef(BaseClass):
    parameter_name: str = pydantic.Field(..., description='The name of the SSM parameter that contains the AMI value.')
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false\n")
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines')
    _init_params: typing.ClassVar[list[str]] = ['parameter_name', 'cached_in_context', 'user_data']
    _method_names: typing.ClassVar[list[str]] = ['get_image']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AmazonLinuxImageSsmParameterBase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AmazonLinuxImageSsmParameterBaseDefConfig] = pydantic.Field(None)


class AmazonLinuxImageSsmParameterBaseDefConfig(pydantic.BaseModel):
    get_image: typing.Optional[list[AmazonLinuxImageSsmParameterBaseDefGetImageParams]] = pydantic.Field(None, description='Return the image to use in the given context.')

class AmazonLinuxImageSsmParameterBaseDefGetImageParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.BlockDeviceVolume
class BlockDeviceVolumeDef(BaseClass):
    ebs_device: typing.Union[models.aws_ec2.EbsDevicePropsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='EBS device info.')
    virtual_name: typing.Optional[str] = pydantic.Field(None, description='Virtual device name.')
    _init_params: typing.ClassVar[list[str]] = ['ebs_device', 'virtual_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['ebs', 'ebs_from_snapshot', 'ephemeral']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.BlockDeviceVolume'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[BlockDeviceVolumeDefConfig] = pydantic.Field(None)


class BlockDeviceVolumeDefConfig(pydantic.BaseModel):
    ebs: typing.Optional[list[BlockDeviceVolumeDefEbsParams]] = pydantic.Field(None, description='Creates a new Elastic Block Storage device.')
    ebs_from_snapshot: typing.Optional[list[BlockDeviceVolumeDefEbsFromSnapshotParams]] = pydantic.Field(None, description='Creates a new Elastic Block Storage device from an existing snapshot.')
    ephemeral: typing.Optional[list[BlockDeviceVolumeDefEphemeralParams]] = pydantic.Field(None, description='Creates a virtual, ephemeral device.\nThe name will be in the form ephemeral{volumeIndex}.')

class BlockDeviceVolumeDefEbsParams(pydantic.BaseModel):
    volume_size: typing.Union[int, float] = pydantic.Field(..., description='The volume size, in Gibibytes (GiB).\n')
    encrypted: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether the EBS volume is encrypted. Encrypted EBS volumes can only be attached to instances that support Amazon EBS encryption Default: false\n')
    kms_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The ARN of the AWS Key Management Service (AWS KMS) CMK used for encryption. You have to ensure that the KMS CMK has the correct permissions to be used by the service launching the ec2 instances. Default: - If encrypted is true, the default aws/ebs KMS key will be used.\n')
    delete_on_termination: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to delete the volume when the instance is terminated. Default: - true for Amazon EC2 Auto Scaling, false otherwise (e.g. EBS)\n')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='The number of I/O operations per second (IOPS) to provision for the volume. Must only be set for ``volumeType``: ``EbsDeviceVolumeType.IO1`` The maximum ratio of IOPS to volume size (in GiB) is 50:1, so for 5,000 provisioned IOPS, you need at least 100 GiB storage on the volume. Default: - none, required for ``EbsDeviceVolumeType.IO1``\n')
    volume_type: typing.Optional[aws_cdk.aws_ec2.EbsDeviceVolumeType] = pydantic.Field(None, description='The EBS volume type. Default: ``EbsDeviceVolumeType.GP2``')
    return_config: typing.Optional[list[models.aws_ec2.BlockDeviceVolumeDefConfig]] = pydantic.Field(None)
    ...

class BlockDeviceVolumeDefEbsFromSnapshotParams(pydantic.BaseModel):
    snapshot_id: str = pydantic.Field(..., description='The snapshot ID of the volume to use.\n')
    volume_size: typing.Union[int, float, None] = pydantic.Field(None, description='The volume size, in Gibibytes (GiB). If you specify volumeSize, it must be equal or greater than the size of the snapshot. Default: - The snapshot size\n')
    delete_on_termination: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to delete the volume when the instance is terminated. Default: - true for Amazon EC2 Auto Scaling, false otherwise (e.g. EBS)\n')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='The number of I/O operations per second (IOPS) to provision for the volume. Must only be set for ``volumeType``: ``EbsDeviceVolumeType.IO1`` The maximum ratio of IOPS to volume size (in GiB) is 50:1, so for 5,000 provisioned IOPS, you need at least 100 GiB storage on the volume. Default: - none, required for ``EbsDeviceVolumeType.IO1``\n')
    volume_type: typing.Optional[aws_cdk.aws_ec2.EbsDeviceVolumeType] = pydantic.Field(None, description='The EBS volume type. Default: ``EbsDeviceVolumeType.GP2``')
    return_config: typing.Optional[list[models.aws_ec2.BlockDeviceVolumeDefConfig]] = pydantic.Field(None)
    ...

class BlockDeviceVolumeDefEphemeralParams(pydantic.BaseModel):
    volume_index: typing.Union[int, float] = pydantic.Field(..., description='the volume index. Must be equal or greater than 0')
    return_config: typing.Optional[list[models.aws_ec2.BlockDeviceVolumeDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_ec2.ClientVpnRouteTarget
class ClientVpnRouteTargetDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['local', 'subnet']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.ClientVpnRouteTarget'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ClientVpnRouteTargetDefConfig] = pydantic.Field(None)


class ClientVpnRouteTargetDefConfig(pydantic.BaseModel):
    local: typing.Optional[list[ClientVpnRouteTargetDefLocalParams]] = pydantic.Field(None, description='Local network.')
    subnet: typing.Optional[list[ClientVpnRouteTargetDefSubnetParams]] = pydantic.Field(None, description='Subnet.\nThe specified subnet must be an existing target network of the client VPN\nendpoint.')

class ClientVpnRouteTargetDefLocalParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_ec2.ClientVpnRouteTargetDefConfig]] = pydantic.Field(None)
    ...

class ClientVpnRouteTargetDefSubnetParams(pydantic.BaseModel):
    subnet: typing.Union[models.aws_ec2.PrivateSubnetDef, models.aws_ec2.PublicSubnetDef, models.aws_ec2.SubnetDef] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.ClientVpnRouteTargetDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_ec2.ClientVpnUserBasedAuthentication
class ClientVpnUserBasedAuthenticationDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['render']
    _classmethod_names: typing.ClassVar[list[str]] = ['active_directory', 'federated']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.ClientVpnUserBasedAuthentication'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ClientVpnUserBasedAuthenticationDefConfig] = pydantic.Field(None)


class ClientVpnUserBasedAuthenticationDefConfig(pydantic.BaseModel):
    active_directory: typing.Optional[list[ClientVpnUserBasedAuthenticationDefActiveDirectoryParams]] = pydantic.Field(None, description='Active Directory authentication.')
    federated: typing.Optional[list[ClientVpnUserBasedAuthenticationDefFederatedParams]] = pydantic.Field(None, description='Federated authentication.')
    render: typing.Optional[bool] = pydantic.Field(None, description='Renders the user based authentication.')

class ClientVpnUserBasedAuthenticationDefActiveDirectoryParams(pydantic.BaseModel):
    directory_id: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.ClientVpnUserBasedAuthenticationDefConfig]] = pydantic.Field(None)
    ...

class ClientVpnUserBasedAuthenticationDefFederatedParams(pydantic.BaseModel):
    saml_provider: typing.Union[models.aws_iam.SamlProviderDef] = pydantic.Field(..., description='-\n')
    self_service_saml_provider: typing.Optional[typing.Union[models.aws_iam.SamlProviderDef]] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_ec2.ClientVpnUserBasedAuthenticationDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_ec2.CloudFormationInit
class CloudFormationInitDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['add_config', 'add_config_set', 'attach']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_config', 'from_config_sets', 'from_elements']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CloudFormationInit'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_config', 'from_config_sets', 'from_elements']
    ...


    from_config: typing.Optional[CloudFormationInitDefFromConfigParams] = pydantic.Field(None, description='Use an existing InitConfig object as the default and only config.')
    from_config_sets: typing.Optional[CloudFormationInitDefFromConfigSetsParams] = pydantic.Field(None, description='Build a CloudFormationInit from config sets.')
    from_elements: typing.Optional[CloudFormationInitDefFromElementsParams] = pydantic.Field(None, description='Build a new config from a set of Init Elements.')
    resource_config: typing.Optional[CloudFormationInitDefConfig] = pydantic.Field(None)


class CloudFormationInitDefConfig(pydantic.BaseModel):
    add_config: typing.Optional[list[CloudFormationInitDefAddConfigParams]] = pydantic.Field(None, description='Add a config with the given name to this CloudFormationInit object.')
    add_config_set: typing.Optional[list[CloudFormationInitDefAddConfigSetParams]] = pydantic.Field(None, description='Add a config set with the given name to this CloudFormationInit object.\nThe new configset will reference the given configs in the given order.')
    attach: typing.Optional[list[CloudFormationInitDefAttachParams]] = pydantic.Field(None, description="Attach the CloudFormation Init config to the given resource.\nAs an app builder, use ``instance.applyCloudFormationInit()`` or\n``autoScalingGroup.applyCloudFormationInit()`` to trigger this method.\n\nThis method does the following:\n\n- Renders the ``AWS::CloudFormation::Init`` object to the given resource's\n  metadata, potentially adding a ``AWS::CloudFormation::Authentication`` object\n  next to it if required.\n- Updates the instance role policy to be able to call the APIs required for\n  ``cfn-init`` and ``cfn-signal`` to work, and potentially add permissions to download\n  referenced asset and bucket resources.\n- Updates the given UserData with commands to execute the ``cfn-init`` script.")

class CloudFormationInitDefAddConfigParams(pydantic.BaseModel):
    config_name: str = pydantic.Field(..., description='-\n')
    config: models.aws_ec2.InitConfigDef = pydantic.Field(..., description='-')
    ...

class CloudFormationInitDefAddConfigSetParams(pydantic.BaseModel):
    config_set_name: str = pydantic.Field(..., description='-\n')
    config_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='-')
    ...

class CloudFormationInitDefAttachParams(pydantic.BaseModel):
    attached_resource: models.CfnResourceDef = pydantic.Field(..., description='-\n')
    instance_role: typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef] = pydantic.Field(..., description='Instance role of the consuming instance or fleet.\n')
    platform: aws_cdk.aws_ec2.OperatingSystemType = pydantic.Field(..., description='OS Platform the init config will be used for.\n')
    user_data: models.aws_ec2.UserDataDef = pydantic.Field(..., description='UserData to add commands to.\n')
    config_sets: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="ConfigSet to activate. Default: ['default']\n")
    embed_fingerprint: typing.Optional[bool] = pydantic.Field(None, description='Whether to embed a hash into the userData. If ``true`` (the default), a hash of the config will be embedded into the UserData, so that if the config changes, the UserData changes and the instance will be replaced. If ``false``, no such hash will be embedded, and if the CloudFormation Init config changes nothing will happen to the running instance. Default: true\n')
    ignore_failures: typing.Optional[bool] = pydantic.Field(None, description="Don't fail the instance creation when cfn-init fails. You can use this to prevent CloudFormation from rolling back when instances fail to start up, to help in debugging. Default: false\n")
    include_role: typing.Optional[bool] = pydantic.Field(None, description='Include --role argument when running cfn-init and cfn-signal commands. This will be the IAM instance profile attached to the EC2 instance Default: false\n')
    include_url: typing.Optional[bool] = pydantic.Field(None, description='Include --url argument when running cfn-init and cfn-signal commands. This will be the cloudformation endpoint in the deployed region e.g. https://cloudformation.us-east-1.amazonaws.com Default: false\n')
    print_log: typing.Optional[bool] = pydantic.Field(None, description='Print the results of running cfn-init to the Instance System Log. By default, the output of running cfn-init is written to a log file on the instance. Set this to ``true`` to print it to the System Log (visible from the EC2 Console), ``false`` to not print it. (Be aware that the system log is refreshed at certain points in time of the instance life cycle, and successful execution may not always show up). Default: true\n')
    signal_resource: typing.Optional[models.CfnResourceDef] = pydantic.Field(None, description='When provided, signals this resource instead of the attached resource. You can use this to support signaling LaunchTemplate while attaching AutoScalingGroup Default: - if this property is undefined cfn-signal signals the attached resource')
    ...

class CloudFormationInitDefFromConfigParams(pydantic.BaseModel):
    config: models.aws_ec2.InitConfigDef = pydantic.Field(..., description='-')
    ...

class CloudFormationInitDefFromConfigSetsParams(pydantic.BaseModel):
    configs: typing.Mapping[str, models.aws_ec2.InitConfigDef] = pydantic.Field(..., description='The sets of configs to pick from.\n')
    config_sets: typing.Mapping[str, typing.Sequence[str]] = pydantic.Field(..., description='The definitions of each config set.')
    ...

class CloudFormationInitDefFromElementsParams(pydantic.BaseModel):
    elements: list[models.aws_ec2.InitElementDef] = pydantic.Field(...)
    ...


#  autogenerated from aws_cdk.aws_ec2.Connections
class ConnectionsDef(BaseClass, ConnectableMixin):
    default_port: typing.Optional[models.aws_ec2.PortDef] = pydantic.Field(None, description='Default port range for initiating connections to and from this object. Default: - No default port')
    peer: typing.Optional[models.UnsupportedResource] = pydantic.Field(None, description='Class that represents the rule by which others can connect to this connectable. This object is required, but will be derived from securityGroup if that is passed. Default: Derived from securityGroup if set.\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='What securityGroup(s) this object is managing connections for. Default: No security groups')
    _init_params: typing.ClassVar[list[str]] = ['default_port', 'peer', 'security_groups']
    _method_names: typing.ClassVar[list[str]] = ['add_security_group', 'allow_default_port_from', 'allow_default_port_from_any_ipv4', 'allow_default_port_internally', 'allow_default_port_to', 'allow_from', 'allow_from_any_ipv4', 'allow_internally', 'allow_to', 'allow_to_any_ipv4', 'allow_to_default_port']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.Connections'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ConnectionsDefConfig] = pydantic.Field(None)


class ConnectionsDefConfig(pydantic.BaseModel):
    add_security_group: typing.Optional[list[ConnectionsDefAddSecurityGroupParams]] = pydantic.Field(None, description='Add a security group to the list of security groups managed by this object.')
    allow_default_port_from: typing.Optional[list[ConnectionsDefAllowDefaultPortFromParams]] = pydantic.Field(None, description='Allow connections from the peer on our default port.\nEven if the peer has a default port, we will always use our default port.')
    allow_default_port_from_any_ipv4: typing.Optional[list[ConnectionsDefAllowDefaultPortFromAnyIpv4Params]] = pydantic.Field(None, description='Allow default connections from all IPv4 ranges.')
    allow_default_port_internally: typing.Optional[list[ConnectionsDefAllowDefaultPortInternallyParams]] = pydantic.Field(None, description='Allow hosts inside the security group to connect to each other.')
    allow_default_port_to: typing.Optional[list[ConnectionsDefAllowDefaultPortToParams]] = pydantic.Field(None, description='Allow connections from the peer on our default port.\nEven if the peer has a default port, we will always use our default port.')
    allow_from: typing.Optional[list[ConnectionsDefAllowFromParams]] = pydantic.Field(None, description='Allow connections from the peer on the given port.')
    allow_from_any_ipv4: typing.Optional[list[ConnectionsDefAllowFromAnyIpv4Params]] = pydantic.Field(None, description='Allow from any IPv4 ranges.')
    allow_internally: typing.Optional[list[ConnectionsDefAllowInternallyParams]] = pydantic.Field(None, description='Allow hosts inside the security group to connect to each other on the given port.')
    allow_to: typing.Optional[list[ConnectionsDefAllowToParams]] = pydantic.Field(None, description='Allow connections to the peer on the given port.')
    allow_to_any_ipv4: typing.Optional[list[ConnectionsDefAllowToAnyIpv4Params]] = pydantic.Field(None, description='Allow to all IPv4 ranges.')
    allow_to_default_port: typing.Optional[list[ConnectionsDefAllowToDefaultPortParams]] = pydantic.Field(None, description='Allow connections to the security group on their default port.')

class ConnectionsDefAddSecurityGroupParams(pydantic.BaseModel):
    security_groups: list[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(...)
    ...

class ConnectionsDefAllowDefaultPortFromParams(pydantic.BaseModel):
    other: typing.Union[models.aws_autoscaling.AutoScalingGroupDef, models.aws_ec2.ConnectionsDef, models.aws_ec2.NatInstanceProviderDef, models.aws_ec2.LaunchTemplateDef, models.aws_elasticloadbalancing.ListenerPortDef, models.aws_elasticloadbalancing.LoadBalancerDef, models.aws_elasticsearch.DomainDef, models.aws_opensearchservice.DomainDef, models.aws_rds.DatabaseProxyDef, models.aws_secretsmanager.HostedRotationDef, models.aws_stepfunctions_tasks.EcsRunTaskDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='-')
    ...

class ConnectionsDefAllowDefaultPortFromAnyIpv4Params(pydantic.BaseModel):
    description: typing.Optional[str] = pydantic.Field(None, description='-')
    ...

class ConnectionsDefAllowDefaultPortInternallyParams(pydantic.BaseModel):
    description: typing.Optional[str] = pydantic.Field(None, description='-')
    ...

class ConnectionsDefAllowDefaultPortToParams(pydantic.BaseModel):
    other: typing.Union[models.aws_autoscaling.AutoScalingGroupDef, models.aws_ec2.ConnectionsDef, models.aws_ec2.NatInstanceProviderDef, models.aws_ec2.LaunchTemplateDef, models.aws_elasticloadbalancing.ListenerPortDef, models.aws_elasticloadbalancing.LoadBalancerDef, models.aws_elasticsearch.DomainDef, models.aws_opensearchservice.DomainDef, models.aws_rds.DatabaseProxyDef, models.aws_secretsmanager.HostedRotationDef, models.aws_stepfunctions_tasks.EcsRunTaskDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='-')
    ...

class ConnectionsDefAllowFromParams(pydantic.BaseModel):
    other: typing.Union[models.aws_autoscaling.AutoScalingGroupDef, models.aws_ec2.ConnectionsDef, models.aws_ec2.NatInstanceProviderDef, models.aws_ec2.LaunchTemplateDef, models.aws_elasticloadbalancing.ListenerPortDef, models.aws_elasticloadbalancing.LoadBalancerDef, models.aws_elasticsearch.DomainDef, models.aws_opensearchservice.DomainDef, models.aws_rds.DatabaseProxyDef, models.aws_secretsmanager.HostedRotationDef, models.aws_stepfunctions_tasks.EcsRunTaskDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef] = pydantic.Field(..., description='-\n')
    port_range: models.aws_ec2.PortDef = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='-')
    ...

class ConnectionsDefAllowFromAnyIpv4Params(pydantic.BaseModel):
    port_range: models.aws_ec2.PortDef = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='-')
    ...

class ConnectionsDefAllowInternallyParams(pydantic.BaseModel):
    port_range: models.aws_ec2.PortDef = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='-')
    ...

class ConnectionsDefAllowToParams(pydantic.BaseModel):
    other: typing.Union[models.aws_autoscaling.AutoScalingGroupDef, models.aws_ec2.ConnectionsDef, models.aws_ec2.NatInstanceProviderDef, models.aws_ec2.LaunchTemplateDef, models.aws_elasticloadbalancing.ListenerPortDef, models.aws_elasticloadbalancing.LoadBalancerDef, models.aws_elasticsearch.DomainDef, models.aws_opensearchservice.DomainDef, models.aws_rds.DatabaseProxyDef, models.aws_secretsmanager.HostedRotationDef, models.aws_stepfunctions_tasks.EcsRunTaskDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef] = pydantic.Field(..., description='-\n')
    port_range: models.aws_ec2.PortDef = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='-')
    ...

class ConnectionsDefAllowToAnyIpv4Params(pydantic.BaseModel):
    port_range: models.aws_ec2.PortDef = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='-')
    ...

class ConnectionsDefAllowToDefaultPortParams(pydantic.BaseModel):
    other: typing.Union[models.aws_autoscaling.AutoScalingGroupDef, models.aws_ec2.ConnectionsDef, models.aws_ec2.NatInstanceProviderDef, models.aws_ec2.LaunchTemplateDef, models.aws_elasticloadbalancing.ListenerPortDef, models.aws_elasticloadbalancing.LoadBalancerDef, models.aws_elasticsearch.DomainDef, models.aws_opensearchservice.DomainDef, models.aws_rds.DatabaseProxyDef, models.aws_secretsmanager.HostedRotationDef, models.aws_stepfunctions_tasks.EcsRunTaskDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef] = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.FlowLogDestination
class FlowLogDestinationDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['bind']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.FlowLogDestination'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[FlowLogDestinationDefConfig] = pydantic.Field(None)


class FlowLogDestinationDefConfig(pydantic.BaseModel):
    bind: typing.Optional[list[FlowLogDestinationDefBindParams]] = pydantic.Field(None, description='Generates a flow log destination configuration.')

class FlowLogDestinationDefBindParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    flow_log: models.aws_ec2.FlowLogDef = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.FlowLogResourceType
class FlowLogResourceTypeDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_network_interface_id', 'from_subnet', 'from_vpc']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.FlowLogResourceType'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_network_interface_id', 'from_subnet', 'from_vpc']
    ...


    from_network_interface_id: typing.Optional[FlowLogResourceTypeDefFromNetworkInterfaceIdParams] = pydantic.Field(None, description='The Network Interface to attach the Flow Log to.')
    from_subnet: typing.Optional[FlowLogResourceTypeDefFromSubnetParams] = pydantic.Field(None, description='The subnet to attach the Flow Log to.')
    from_vpc: typing.Optional[FlowLogResourceTypeDefFromVpcParams] = pydantic.Field(None, description='The VPC to attach the Flow Log to.')

class FlowLogResourceTypeDefFromNetworkInterfaceIdParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-')
    ...

class FlowLogResourceTypeDefFromSubnetParams(pydantic.BaseModel):
    subnet: typing.Union[models.aws_ec2.PrivateSubnetDef, models.aws_ec2.PublicSubnetDef, models.aws_ec2.SubnetDef] = pydantic.Field(..., description='-')
    ...

class FlowLogResourceTypeDefFromVpcParams(pydantic.BaseModel):
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.GatewayVpcEndpointAwsService
class GatewayVpcEndpointAwsServiceDef(BaseClass):
    name: str = pydantic.Field(..., description='The name of the service.')
    prefix: typing.Optional[str] = pydantic.Field(None, description='-')
    _init_params: typing.ClassVar[list[str]] = ['name', 'prefix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.GatewayVpcEndpointAwsService'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.GenericLinuxImage
class GenericLinuxImageDef(BaseClass):
    ami_map: typing.Mapping[str, str] = pydantic.Field(..., description='-')
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines')
    _init_params: typing.ClassVar[list[str]] = ['ami_map', 'user_data']
    _method_names: typing.ClassVar[list[str]] = ['get_image']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.GenericLinuxImage'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[GenericLinuxImageDefConfig] = pydantic.Field(None)


class GenericLinuxImageDefConfig(pydantic.BaseModel):
    get_image: typing.Optional[list[GenericLinuxImageDefGetImageParams]] = pydantic.Field(None, description='Return the image to use in the given context.')

class GenericLinuxImageDefGetImageParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.GenericSSMParameterImage
class GenericSSMParameterImageDef(BaseClass):
    parameter_name: str = pydantic.Field(..., description='-')
    os: aws_cdk.aws_ec2.OperatingSystemType = pydantic.Field(..., description='-\n')
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='-')
    _init_params: typing.ClassVar[list[str]] = ['parameter_name', 'os', 'user_data']
    _method_names: typing.ClassVar[list[str]] = ['get_image']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.GenericSSMParameterImage'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[GenericSSMParameterImageDefConfig] = pydantic.Field(None)


class GenericSSMParameterImageDefConfig(pydantic.BaseModel):
    get_image: typing.Optional[list[GenericSSMParameterImageDefGetImageParams]] = pydantic.Field(None, description='Return the image to use in the given context.')

class GenericSSMParameterImageDefGetImageParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.GenericWindowsImage
class GenericWindowsImageDef(BaseClass):
    ami_map: typing.Mapping[str, str] = pydantic.Field(..., description='-')
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Windows machines')
    _init_params: typing.ClassVar[list[str]] = ['ami_map', 'user_data']
    _method_names: typing.ClassVar[list[str]] = ['get_image']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.GenericWindowsImage'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[GenericWindowsImageDefConfig] = pydantic.Field(None)


class GenericWindowsImageDefConfig(pydantic.BaseModel):
    get_image: typing.Optional[list[GenericWindowsImageDefGetImageParams]] = pydantic.Field(None, description='Return the image to use in the given context.')

class GenericWindowsImageDefGetImageParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.InitCommand
class InitCommandDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['argv_command', 'shell_command']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InitCommand'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[InitCommandDefConfig] = pydantic.Field(None)


class InitCommandDefConfig(pydantic.BaseModel):
    argv_command: typing.Optional[list[InitCommandDefArgvCommandParams]] = pydantic.Field(None, description='Run a command from an argv array.\nYou do not need to escape space characters or enclose command parameters in quotes.')
    shell_command: typing.Optional[list[InitCommandDefShellCommandParams]] = pydantic.Field(None, description='Run a shell command.\nRemember that some characters like ``&``, ``|``, ``;``, ``>`` etc. have special meaning in a shell and\nneed to be preceded by a ``\\`` if you want to treat them as part of a filename.')

class InitCommandDefArgvCommandParams(pydantic.BaseModel):
    argv: typing.Sequence[str] = pydantic.Field(..., description='-\n')
    cwd: typing.Optional[str] = pydantic.Field(None, description='The working directory. Default: - Use default working directory\n')
    env: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Sets environment variables for the command. This property overwrites, rather than appends, the existing environment. Default: - Use current environment\n')
    ignore_errors: typing.Optional[bool] = pydantic.Field(None, description='Continue running if this command fails. Default: false\n')
    key: typing.Optional[str] = pydantic.Field(None, description='Identifier key for this command. Commands are executed in lexicographical order of their key names. Default: - Automatically generated based on index\n')
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given service(s) after this command has run. Default: - Do not restart any service\n')
    test_cmd: typing.Optional[str] = pydantic.Field(None, description='Command to determine whether this command should be run. If the test passes (exits with error code of 0), the command is run. Default: - Always run the command\n')
    wait_after_completion: typing.Optional[models.aws_ec2.InitCommandWaitDurationDef] = pydantic.Field(None, description='The duration to wait after a command has finished in case the command causes a reboot. Set this value to ``InitCommandWaitDuration.none()`` if you do not want to wait for every command; ``InitCommandWaitDuration.forever()`` directs cfn-init to exit and resume only after the reboot is complete. For Windows systems only. Default: - 60 seconds')
    return_config: typing.Optional[list[models.aws_ec2.InitCommandDefConfig]] = pydantic.Field(None)
    ...

class InitCommandDefShellCommandParams(pydantic.BaseModel):
    shell_command: str = pydantic.Field(..., description='-\n')
    cwd: typing.Optional[str] = pydantic.Field(None, description='The working directory. Default: - Use default working directory\n')
    env: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Sets environment variables for the command. This property overwrites, rather than appends, the existing environment. Default: - Use current environment\n')
    ignore_errors: typing.Optional[bool] = pydantic.Field(None, description='Continue running if this command fails. Default: false\n')
    key: typing.Optional[str] = pydantic.Field(None, description='Identifier key for this command. Commands are executed in lexicographical order of their key names. Default: - Automatically generated based on index\n')
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given service(s) after this command has run. Default: - Do not restart any service\n')
    test_cmd: typing.Optional[str] = pydantic.Field(None, description='Command to determine whether this command should be run. If the test passes (exits with error code of 0), the command is run. Default: - Always run the command\n')
    wait_after_completion: typing.Optional[models.aws_ec2.InitCommandWaitDurationDef] = pydantic.Field(None, description='The duration to wait after a command has finished in case the command causes a reboot. Set this value to ``InitCommandWaitDuration.none()`` if you do not want to wait for every command; ``InitCommandWaitDuration.forever()`` directs cfn-init to exit and resume only after the reboot is complete. For Windows systems only. Default: - 60 seconds')
    return_config: typing.Optional[list[models.aws_ec2.InitCommandDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_ec2.InitCommandWaitDuration
class InitCommandWaitDurationDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['forever', 'none', 'of']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InitCommandWaitDuration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[InitCommandWaitDurationDefConfig] = pydantic.Field(None)


class InitCommandWaitDurationDefConfig(pydantic.BaseModel):
    forever: typing.Optional[list[InitCommandWaitDurationDefForeverParams]] = pydantic.Field(None, description='cfn-init will exit and resume only after a reboot.')
    none: typing.Optional[list[InitCommandWaitDurationDefNoneParams]] = pydantic.Field(None, description='Do not wait for this command.')
    of: typing.Optional[list[InitCommandWaitDurationDefOfParams]] = pydantic.Field(None, description='Wait for a specified duration after a command.')

class InitCommandWaitDurationDefForeverParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_ec2.InitCommandWaitDurationDefConfig]] = pydantic.Field(None)
    ...

class InitCommandWaitDurationDefNoneParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_ec2.InitCommandWaitDurationDefConfig]] = pydantic.Field(None)
    ...

class InitCommandWaitDurationDefOfParams(pydantic.BaseModel):
    duration: models.DurationDef = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.InitCommandWaitDurationDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_ec2.InitConfig
class InitConfigDef(BaseClass):
    elements: typing.Sequence[models.aws_ec2.InitElementDef] = pydantic.Field(..., description='-')
    _init_params: typing.ClassVar[list[str]] = ['elements']
    _method_names: typing.ClassVar[list[str]] = ['add']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InitConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[InitConfigDefConfig] = pydantic.Field(None)


class InitConfigDefConfig(pydantic.BaseModel):
    add: typing.Optional[list[InitConfigDefAddParams]] = pydantic.Field(None, description='Add one or more elements to the config.')

class InitConfigDefAddParams(pydantic.BaseModel):
    elements: list[models.aws_ec2.InitElementDef] = pydantic.Field(...)
    ...


#  autogenerated from aws_cdk.aws_ec2.InitElement
class InitElementDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InitElement'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.InitFile
class InitFileDef(BaseClass):
    file_name: str = pydantic.Field(..., description='-')
    base64_encoded: typing.Optional[bool] = pydantic.Field(None, description='True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false\n')
    group: typing.Optional[str] = pydantic.Field(None, description="The name of the owning group for this file. Not supported for Windows systems. Default: 'root'\n")
    mode: typing.Optional[str] = pydantic.Field(None, description="A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'\n")
    owner: typing.Optional[str] = pydantic.Field(None, description="The name of the owning user for this file. Not supported for Windows systems. Default: 'root'\n")
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given service after this file has been written. Default: - Do not restart any service')
    _init_params: typing.ClassVar[list[str]] = ['file_name', 'base64_encoded', 'group', 'mode', 'owner', 'service_restart_handles']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_asset', 'from_existing_asset', 'from_file_inline', 'from_object', 'from_s3_object', 'from_string', 'from_url', 'symlink']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InitFile'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_asset', 'from_existing_asset', 'from_file_inline', 'from_object', 'from_s3_object', 'from_string', 'from_url']
    ...


    from_asset: typing.Optional[InitFileDefFromAssetParams] = pydantic.Field(None, description='Create an asset from the given file.\nThis is appropriate for files that are too large to embed into the template.')
    from_existing_asset: typing.Optional[InitFileDefFromExistingAssetParams] = pydantic.Field(None, description='Use a file from an asset at instance startup time.')
    from_file_inline: typing.Optional[InitFileDefFromFileInlineParams] = pydantic.Field(None, description="Read a file from disk and use its contents.\nThe file will be embedded in the template, so care should be taken to not\nexceed the template size.\n\nIf options.base64encoded is set to true, this will base64-encode the file's contents.")
    from_object: typing.Optional[InitFileDefFromObjectParams] = pydantic.Field(None, description='Use a JSON-compatible object as the file content, write it to a JSON file.\nMay contain tokens.')
    from_s3_object: typing.Optional[InitFileDefFromS3ObjectParams] = pydantic.Field(None, description='Download a file from an S3 bucket at instance startup time.')
    from_string: typing.Optional[InitFileDefFromStringParams] = pydantic.Field(None, description='Use a literal string as the file content.')
    from_url: typing.Optional[InitFileDefFromUrlParams] = pydantic.Field(None, description='Download from a URL at instance startup time.')
    resource_config: typing.Optional[InitFileDefConfig] = pydantic.Field(None)


class InitFileDefConfig(pydantic.BaseModel):
    symlink: typing.Optional[list[InitFileDefSymlinkParams]] = pydantic.Field(None, description='Write a symlink with the given symlink target.')

class InitFileDefFromAssetParams(pydantic.BaseModel):
    target_file_name: str = pydantic.Field(..., description='-\n')
    path: str = pydantic.Field(..., description='-\n')
    base64_encoded: typing.Optional[bool] = pydantic.Field(None, description='True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false\n')
    group: typing.Optional[str] = pydantic.Field(None, description="The name of the owning group for this file. Not supported for Windows systems. Default: 'root'\n")
    mode: typing.Optional[str] = pydantic.Field(None, description="A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'\n")
    owner: typing.Optional[str] = pydantic.Field(None, description="The name of the owning user for this file. Not supported for Windows systems. Default: 'root'\n")
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given service after this file has been written. Default: - Do not restart any service\n')
    deploy_time: typing.Optional[bool] = pydantic.Field(None, description='Whether or not the asset needs to exist beyond deployment time; i.e. are copied over to a different location and not needed afterwards. Setting this property to true has an impact on the lifecycle of the asset, because we will assume that it is safe to delete after the CloudFormation deployment succeeds. For example, Lambda Function assets are copied over to Lambda during deployment. Therefore, it is not necessary to store the asset in S3, so we consider those deployTime assets. Default: false\n')
    readers: typing.Optional[typing.Sequence[typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef]]] = pydantic.Field(None, description='A list of principals that should be able to read this asset from S3. You can use ``asset.grantRead(principal)`` to grant read permissions later. Default: - No principals that can read file asset.\n')
    asset_hash: typing.Optional[str] = pydantic.Field(None, description='Specify a custom hash for this asset. If ``assetHashType`` is set it must be set to ``AssetHashType.CUSTOM``. For consistency, this custom hash will be SHA256 hashed and encoded as hex. The resulting hash will be the asset hash. NOTE: the hash is used in order to identify a specific revision of the asset, and used for optimizing and caching deployment activities related to this asset such as packaging, uploading to Amazon S3, etc. If you chose to customize the hash, you will need to make sure it is updated every time the asset changes, or otherwise it is possible that some deployments will not be invalidated. Default: - based on ``assetHashType``\n')
    asset_hash_type: typing.Optional[aws_cdk.AssetHashType] = pydantic.Field(None, description='Specifies the type of hash to calculate for this asset. If ``assetHash`` is configured, this option must be ``undefined`` or ``AssetHashType.CUSTOM``. Default: - the default is ``AssetHashType.SOURCE``, but if ``assetHash`` is explicitly specified this value defaults to ``AssetHashType.CUSTOM``.\n')
    bundling: typing.Union[models.BundlingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Bundle the asset by executing a command in a Docker container or a custom bundling provider. The asset path will be mounted at ``/asset-input``. The Docker container is responsible for putting content at ``/asset-output``. The content at ``/asset-output`` will be zipped and used as the final asset. Default: - uploaded as-is to S3 if the asset is a regular file or a .zip file, archived into a .zip file and uploaded to S3 otherwise\n')
    exclude: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='File paths matching the patterns will be excluded. See ``ignoreMode`` to set the matching behavior. Has no effect on Assets bundled using the ``bundling`` property. Default: - nothing is excluded\n')
    follow_symlinks: typing.Optional[aws_cdk.SymlinkFollowMode] = pydantic.Field(None, description='A strategy for how to handle symlinks. Default: SymlinkFollowMode.NEVER\n')
    ignore_mode: typing.Optional[aws_cdk.IgnoreMode] = pydantic.Field(None, description='The ignore behavior to use for ``exclude`` patterns. Default: IgnoreMode.GLOB')
    ...

class InitFileDefFromExistingAssetParams(pydantic.BaseModel):
    target_file_name: str = pydantic.Field(..., description='-\n')
    asset: models.aws_s3_assets.AssetDef = pydantic.Field(..., description='-\n')
    base64_encoded: typing.Optional[bool] = pydantic.Field(None, description='True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false\n')
    group: typing.Optional[str] = pydantic.Field(None, description="The name of the owning group for this file. Not supported for Windows systems. Default: 'root'\n")
    mode: typing.Optional[str] = pydantic.Field(None, description="A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'\n")
    owner: typing.Optional[str] = pydantic.Field(None, description="The name of the owning user for this file. Not supported for Windows systems. Default: 'root'\n")
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given service after this file has been written. Default: - Do not restart any service')
    ...

class InitFileDefFromFileInlineParams(pydantic.BaseModel):
    target_file_name: str = pydantic.Field(..., description='-\n')
    source_file_name: str = pydantic.Field(..., description='-\n')
    base64_encoded: typing.Optional[bool] = pydantic.Field(None, description='True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false\n')
    group: typing.Optional[str] = pydantic.Field(None, description="The name of the owning group for this file. Not supported for Windows systems. Default: 'root'\n")
    mode: typing.Optional[str] = pydantic.Field(None, description="A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'\n")
    owner: typing.Optional[str] = pydantic.Field(None, description="The name of the owning user for this file. Not supported for Windows systems. Default: 'root'\n")
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given service after this file has been written. Default: - Do not restart any service')
    ...

class InitFileDefFromObjectParams(pydantic.BaseModel):
    file_name: str = pydantic.Field(..., description='-\n')
    obj: typing.Mapping[str, typing.Any] = pydantic.Field(..., description='-\n')
    base64_encoded: typing.Optional[bool] = pydantic.Field(None, description='True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false\n')
    group: typing.Optional[str] = pydantic.Field(None, description="The name of the owning group for this file. Not supported for Windows systems. Default: 'root'\n")
    mode: typing.Optional[str] = pydantic.Field(None, description="A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'\n")
    owner: typing.Optional[str] = pydantic.Field(None, description="The name of the owning user for this file. Not supported for Windows systems. Default: 'root'\n")
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given service after this file has been written. Default: - Do not restart any service')
    ...

class InitFileDefFromS3ObjectParams(pydantic.BaseModel):
    file_name: str = pydantic.Field(..., description='-\n')
    bucket: typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef] = pydantic.Field(..., description='-\n')
    key: str = pydantic.Field(..., description='-\n')
    base64_encoded: typing.Optional[bool] = pydantic.Field(None, description='True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false\n')
    group: typing.Optional[str] = pydantic.Field(None, description="The name of the owning group for this file. Not supported for Windows systems. Default: 'root'\n")
    mode: typing.Optional[str] = pydantic.Field(None, description="A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'\n")
    owner: typing.Optional[str] = pydantic.Field(None, description="The name of the owning user for this file. Not supported for Windows systems. Default: 'root'\n")
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given service after this file has been written. Default: - Do not restart any service')
    ...

class InitFileDefFromStringParams(pydantic.BaseModel):
    file_name: str = pydantic.Field(..., description='-\n')
    content: str = pydantic.Field(..., description='-\n')
    base64_encoded: typing.Optional[bool] = pydantic.Field(None, description='True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false\n')
    group: typing.Optional[str] = pydantic.Field(None, description="The name of the owning group for this file. Not supported for Windows systems. Default: 'root'\n")
    mode: typing.Optional[str] = pydantic.Field(None, description="A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'\n")
    owner: typing.Optional[str] = pydantic.Field(None, description="The name of the owning user for this file. Not supported for Windows systems. Default: 'root'\n")
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given service after this file has been written. Default: - Do not restart any service')
    ...

class InitFileDefFromUrlParams(pydantic.BaseModel):
    file_name: str = pydantic.Field(..., description='-\n')
    url: str = pydantic.Field(..., description='-\n')
    base64_encoded: typing.Optional[bool] = pydantic.Field(None, description='True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false\n')
    group: typing.Optional[str] = pydantic.Field(None, description="The name of the owning group for this file. Not supported for Windows systems. Default: 'root'\n")
    mode: typing.Optional[str] = pydantic.Field(None, description="A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'\n")
    owner: typing.Optional[str] = pydantic.Field(None, description="The name of the owning user for this file. Not supported for Windows systems. Default: 'root'\n")
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given service after this file has been written. Default: - Do not restart any service')
    ...

class InitFileDefSymlinkParams(pydantic.BaseModel):
    file_name: str = pydantic.Field(..., description='-\n')
    target: str = pydantic.Field(..., description='-\n')
    base64_encoded: typing.Optional[bool] = pydantic.Field(None, description='True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false\n')
    group: typing.Optional[str] = pydantic.Field(None, description="The name of the owning group for this file. Not supported for Windows systems. Default: 'root'\n")
    mode: typing.Optional[str] = pydantic.Field(None, description="A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'\n")
    owner: typing.Optional[str] = pydantic.Field(None, description="The name of the owning user for this file. Not supported for Windows systems. Default: 'root'\n")
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given service after this file has been written. Default: - Do not restart any service')
    return_config: typing.Optional[list[models.aws_ec2.InitFileDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_ec2.InitGroup
class InitGroupDef(BaseClass):
    group_name: str = pydantic.Field(..., description='-')
    group_id: typing.Union[int, float, None] = pydantic.Field(None, description='-')
    _init_params: typing.ClassVar[list[str]] = ['group_name', 'group_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InitGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_name']
    ...


    from_name: typing.Optional[InitGroupDefFromNameParams] = pydantic.Field(None, description='Create a group from its name, and optionally, group id.')

class InitGroupDefFromNameParams(pydantic.BaseModel):
    group_name: str = pydantic.Field(..., description='-\n')
    group_id: typing.Union[int, float, None] = pydantic.Field(None, description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.InitPackage
class InitPackageDef(BaseClass):
    type: str = pydantic.Field(..., description='-')
    versions: typing.Sequence[str] = pydantic.Field(..., description='-\n')
    package_name: typing.Optional[str] = pydantic.Field(None, description='-\n')
    service_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='-')
    _init_params: typing.ClassVar[list[str]] = ['type', 'versions', 'package_name', 'service_handles']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['apt', 'msi', 'python', 'rpm', 'ruby_gem', 'yum']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InitPackage'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[InitPackageDefConfig] = pydantic.Field(None)


class InitPackageDefConfig(pydantic.BaseModel):
    apt: typing.Optional[list[InitPackageDefAptParams]] = pydantic.Field(None, description='Install a package using APT.')
    msi: typing.Optional[list[InitPackageDefMsiParams]] = pydantic.Field(None, description='Install an MSI package from an HTTP URL or a location on disk.')
    python: typing.Optional[list[InitPackageDefPythonParams]] = pydantic.Field(None, description='Install a package from PyPI.')
    rpm: typing.Optional[list[InitPackageDefRpmParams]] = pydantic.Field(None, description='Install an RPM from an HTTP URL or a location on disk.')
    ruby_gem: typing.Optional[list[InitPackageDefRubyGemParams]] = pydantic.Field(None, description='Install a package from RubyGems.')
    yum: typing.Optional[list[InitPackageDefYumParams]] = pydantic.Field(None, description='Install a package using Yum.')

class InitPackageDefAptParams(pydantic.BaseModel):
    package_name: str = pydantic.Field(..., description='-\n')
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given services after this command has run. Default: - Do not restart any service\n')
    version: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Specify the versions to install. Default: - Install the latest version')
    return_config: typing.Optional[list[models.aws_ec2.InitPackageDefConfig]] = pydantic.Field(None)
    ...

class InitPackageDefMsiParams(pydantic.BaseModel):
    location: str = pydantic.Field(..., description='-\n')
    key: typing.Optional[str] = pydantic.Field(None, description='Identifier key for this package. You can use this to order package installs. Default: - Automatically generated\n')
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given service after this command has run. Default: - Do not restart any service')
    return_config: typing.Optional[list[models.aws_ec2.InitPackageDefConfig]] = pydantic.Field(None)
    ...

class InitPackageDefPythonParams(pydantic.BaseModel):
    package_name: str = pydantic.Field(..., description='-\n')
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given services after this command has run. Default: - Do not restart any service\n')
    version: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Specify the versions to install. Default: - Install the latest version')
    return_config: typing.Optional[list[models.aws_ec2.InitPackageDefConfig]] = pydantic.Field(None)
    ...

class InitPackageDefRpmParams(pydantic.BaseModel):
    location: str = pydantic.Field(..., description='-\n')
    key: typing.Optional[str] = pydantic.Field(None, description='Identifier key for this package. You can use this to order package installs. Default: - Automatically generated\n')
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given service after this command has run. Default: - Do not restart any service')
    return_config: typing.Optional[list[models.aws_ec2.InitPackageDefConfig]] = pydantic.Field(None)
    ...

class InitPackageDefRubyGemParams(pydantic.BaseModel):
    gem_name: str = pydantic.Field(..., description='-\n')
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given services after this command has run. Default: - Do not restart any service\n')
    version: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Specify the versions to install. Default: - Install the latest version')
    return_config: typing.Optional[list[models.aws_ec2.InitPackageDefConfig]] = pydantic.Field(None)
    ...

class InitPackageDefYumParams(pydantic.BaseModel):
    package_name: str = pydantic.Field(..., description='-\n')
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given services after this command has run. Default: - Do not restart any service\n')
    version: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Specify the versions to install. Default: - Install the latest version')
    return_config: typing.Optional[list[models.aws_ec2.InitPackageDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_ec2.InitService
class InitServiceDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['disable', 'enable', 'systemd_config_file']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InitService'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['systemd_config_file']
    ...


    systemd_config_file: typing.Optional[InitServiceDefSystemdConfigFileParams] = pydantic.Field(None, description='Install a systemd-compatible config file for the given service.\nThis is a helper function to create a simple systemd configuration\nfile that will allow running a service on the machine using ``InitService.enable()``.\n\nSystemd allows many configuration options; this function does not pretend\nto expose all of them. If you need advanced configuration options, you\ncan use ``InitFile`` to create exactly the configuration file you need\nat ``/etc/systemd/system/${serviceName}.service``.')
    resource_config: typing.Optional[InitServiceDefConfig] = pydantic.Field(None)


class InitServiceDefConfig(pydantic.BaseModel):
    disable: typing.Optional[list[InitServiceDefDisableParams]] = pydantic.Field(None, description='Disable and stop the given service.')
    enable: typing.Optional[list[InitServiceDefEnableParams]] = pydantic.Field(None, description='Enable and start the given service, optionally restarting it.')

class InitServiceDefDisableParams(pydantic.BaseModel):
    service_name: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.InitServiceDefConfig]] = pydantic.Field(None)
    ...

class InitServiceDefEnableParams(pydantic.BaseModel):
    service_name: str = pydantic.Field(..., description='-\n')
    enabled: typing.Optional[bool] = pydantic.Field(None, description='Enable or disable this service. Set to true to ensure that the service will be started automatically upon boot. Set to false to ensure that the service will not be started automatically upon boot. Default: - true if used in ``InitService.enable()``, no change to service state if used in ``InitService.fromOptions()``.\n')
    ensure_running: typing.Optional[bool] = pydantic.Field(None, description='Make sure this service is running or not running after cfn-init finishes. Set to true to ensure that the service is running after cfn-init finishes. Set to false to ensure that the service is not running after cfn-init finishes. Default: - same value as ``enabled``.\n')
    service_manager: typing.Optional[aws_cdk.aws_ec2.ServiceManager] = pydantic.Field(None, description='What service manager to use. This needs to match the actual service manager on your Operating System. For example, Amazon Linux 1 uses SysVinit, but Amazon Linux 2 uses Systemd. Default: ServiceManager.SYSVINIT for Linux images, ServiceManager.WINDOWS for Windows images\n')
    service_restart_handle: typing.Optional[models.aws_ec2.InitServiceRestartHandleDef] = pydantic.Field(None, description='Restart service when the actions registered into the restartHandle have been performed. Register actions into the restartHandle by passing it to ``InitFile``, ``InitCommand``, ``InitPackage`` and ``InitSource`` objects. Default: - No files trigger restart')
    return_config: typing.Optional[list[models.aws_ec2.InitServiceDefConfig]] = pydantic.Field(None)
    ...

class InitServiceDefSystemdConfigFileParams(pydantic.BaseModel):
    service_name: str = pydantic.Field(..., description='-\n')
    command: str = pydantic.Field(..., description='The command to run to start this service.\n')
    after_network: typing.Optional[bool] = pydantic.Field(None, description='Start the service after the networking part of the OS comes up. Default: true\n')
    cwd: typing.Optional[str] = pydantic.Field(None, description='The working directory for the command. Default: Root directory or home directory of specified user\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of this service. Default: - No description\n')
    group: typing.Optional[str] = pydantic.Field(None, description='The group to execute the process under. Default: root\n')
    keep_running: typing.Optional[bool] = pydantic.Field(None, description='Keep the process running all the time. Restarts the process when it exits for any reason other than the machine shutting down. Default: true\n')
    user: typing.Optional[str] = pydantic.Field(None, description='The user to execute the process under. Default: root')
    ...


#  autogenerated from aws_cdk.aws_ec2.InitServiceRestartHandle
class InitServiceRestartHandleDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InitServiceRestartHandle'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.InitSource
class InitSourceDef(BaseClass):
    target_directory: str = pydantic.Field(..., description='-')
    service_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='-')
    _init_params: typing.ClassVar[list[str]] = ['target_directory', 'service_handles']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_asset', 'from_existing_asset', 'from_git_hub', 'from_s3_object', 'from_url']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InitSource'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_asset', 'from_existing_asset', 'from_git_hub', 'from_s3_object', 'from_url']
    ...


    from_asset: typing.Optional[InitSourceDefFromAssetParams] = pydantic.Field(None, description='Create an InitSource from an asset created from the given path.')
    from_existing_asset: typing.Optional[InitSourceDefFromExistingAssetParams] = pydantic.Field(None, description='Extract a directory from an existing directory asset.')
    from_git_hub: typing.Optional[InitSourceDefFromGitHubParams] = pydantic.Field(None, description='Extract a GitHub branch into a given directory.')
    from_s3_object: typing.Optional[InitSourceDefFromS3ObjectParams] = pydantic.Field(None, description='Extract an archive stored in an S3 bucket into the given directory.')
    from_url: typing.Optional[InitSourceDefFromUrlParams] = pydantic.Field(None, description='Retrieve a URL and extract it into the given directory.')

class InitSourceDefFromAssetParams(pydantic.BaseModel):
    target_directory: str = pydantic.Field(..., description='-\n')
    path: str = pydantic.Field(..., description='-\n')
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given services after this archive has been extracted. Default: - Do not restart any service\n')
    deploy_time: typing.Optional[bool] = pydantic.Field(None, description='Whether or not the asset needs to exist beyond deployment time; i.e. are copied over to a different location and not needed afterwards. Setting this property to true has an impact on the lifecycle of the asset, because we will assume that it is safe to delete after the CloudFormation deployment succeeds. For example, Lambda Function assets are copied over to Lambda during deployment. Therefore, it is not necessary to store the asset in S3, so we consider those deployTime assets. Default: false\n')
    readers: typing.Optional[typing.Sequence[typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef]]] = pydantic.Field(None, description='A list of principals that should be able to read this asset from S3. You can use ``asset.grantRead(principal)`` to grant read permissions later. Default: - No principals that can read file asset.\n')
    asset_hash: typing.Optional[str] = pydantic.Field(None, description='Specify a custom hash for this asset. If ``assetHashType`` is set it must be set to ``AssetHashType.CUSTOM``. For consistency, this custom hash will be SHA256 hashed and encoded as hex. The resulting hash will be the asset hash. NOTE: the hash is used in order to identify a specific revision of the asset, and used for optimizing and caching deployment activities related to this asset such as packaging, uploading to Amazon S3, etc. If you chose to customize the hash, you will need to make sure it is updated every time the asset changes, or otherwise it is possible that some deployments will not be invalidated. Default: - based on ``assetHashType``\n')
    asset_hash_type: typing.Optional[aws_cdk.AssetHashType] = pydantic.Field(None, description='Specifies the type of hash to calculate for this asset. If ``assetHash`` is configured, this option must be ``undefined`` or ``AssetHashType.CUSTOM``. Default: - the default is ``AssetHashType.SOURCE``, but if ``assetHash`` is explicitly specified this value defaults to ``AssetHashType.CUSTOM``.\n')
    bundling: typing.Union[models.BundlingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Bundle the asset by executing a command in a Docker container or a custom bundling provider. The asset path will be mounted at ``/asset-input``. The Docker container is responsible for putting content at ``/asset-output``. The content at ``/asset-output`` will be zipped and used as the final asset. Default: - uploaded as-is to S3 if the asset is a regular file or a .zip file, archived into a .zip file and uploaded to S3 otherwise\n')
    exclude: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='File paths matching the patterns will be excluded. See ``ignoreMode`` to set the matching behavior. Has no effect on Assets bundled using the ``bundling`` property. Default: - nothing is excluded\n')
    follow_symlinks: typing.Optional[aws_cdk.SymlinkFollowMode] = pydantic.Field(None, description='A strategy for how to handle symlinks. Default: SymlinkFollowMode.NEVER\n')
    ignore_mode: typing.Optional[aws_cdk.IgnoreMode] = pydantic.Field(None, description='The ignore behavior to use for ``exclude`` patterns. Default: IgnoreMode.GLOB')
    ...

class InitSourceDefFromExistingAssetParams(pydantic.BaseModel):
    target_directory: str = pydantic.Field(..., description='-\n')
    asset: models.aws_s3_assets.AssetDef = pydantic.Field(..., description='-\n')
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given services after this archive has been extracted. Default: - Do not restart any service')
    ...

class InitSourceDefFromGitHubParams(pydantic.BaseModel):
    target_directory: str = pydantic.Field(..., description='-\n')
    owner: str = pydantic.Field(..., description='-\n')
    repo: str = pydantic.Field(..., description='-\n')
    ref_spec: typing.Optional[str] = pydantic.Field(None, description='-\n')
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given services after this archive has been extracted. Default: - Do not restart any service')
    ...

class InitSourceDefFromS3ObjectParams(pydantic.BaseModel):
    target_directory: str = pydantic.Field(..., description='-\n')
    bucket: typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef] = pydantic.Field(..., description='-\n')
    key: str = pydantic.Field(..., description='-\n')
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given services after this archive has been extracted. Default: - Do not restart any service')
    ...

class InitSourceDefFromUrlParams(pydantic.BaseModel):
    target_directory: str = pydantic.Field(..., description='-\n')
    url: str = pydantic.Field(..., description='-\n')
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given services after this archive has been extracted. Default: - Do not restart any service')
    ...


#  autogenerated from aws_cdk.aws_ec2.InitUser
class InitUserDef(BaseClass):
    user_name: str = pydantic.Field(..., description='-')
    groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of group names. The user will be added to each group in the list. Default: the user is not associated with any groups.\n')
    home_dir: typing.Optional[str] = pydantic.Field(None, description="The user's home directory. Default: assigned by the OS\n")
    user_id: typing.Union[int, float, None] = pydantic.Field(None, description='A user ID. The creation process fails if the user name exists with a different user ID. If the user ID is already assigned to an existing user the operating system may reject the creation request. Default: assigned by the OS')
    _init_params: typing.ClassVar[list[str]] = ['user_name', 'groups', 'home_dir', 'user_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InitUser'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_name']
    ...


    from_name: typing.Optional[InitUserDefFromNameParams] = pydantic.Field(None, description='Create a user from user name.')

class InitUserDefFromNameParams(pydantic.BaseModel):
    user_name: str = pydantic.Field(..., description='-\n')
    groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of group names. The user will be added to each group in the list. Default: the user is not associated with any groups.\n')
    home_dir: typing.Optional[str] = pydantic.Field(None, description="The user's home directory. Default: assigned by the OS\n")
    user_id: typing.Union[int, float, None] = pydantic.Field(None, description='A user ID. The creation process fails if the user name exists with a different user ID. If the user ID is already assigned to an existing user the operating system may reject the creation request. Default: assigned by the OS')
    ...


#  autogenerated from aws_cdk.aws_ec2.InstanceRequireImdsv2Aspect
class InstanceRequireImdsv2AspectDef(BaseClass):
    suppress_launch_template_warning: typing.Optional[bool] = pydantic.Field(None, description='Whether warnings that would be raised when an Instance is associated with an existing Launch Template should be suppressed or not. You can set this to ``true`` if ``LaunchTemplateImdsAspect`` is being used alongside this Aspect to suppress false-positive warnings because any Launch Templates associated with Instances will still be covered. Default: - false')
    suppress_warnings: typing.Optional[bool] = pydantic.Field(None, description='Whether warning annotations from this Aspect should be suppressed or not. Default: - false')
    _init_params: typing.ClassVar[list[str]] = ['suppress_launch_template_warning', 'suppress_warnings']
    _method_names: typing.ClassVar[list[str]] = ['visit']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InstanceRequireImdsv2Aspect'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[InstanceRequireImdsv2AspectDefConfig] = pydantic.Field(None)


class InstanceRequireImdsv2AspectDefConfig(pydantic.BaseModel):
    visit: typing.Optional[list[InstanceRequireImdsv2AspectDefVisitParams]] = pydantic.Field(None, description='All aspects can visit an IConstruct.')

class InstanceRequireImdsv2AspectDefVisitParams(pydantic.BaseModel):
    node: models.AnyResource = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.InstanceType
class InstanceTypeDef(BaseClass):
    instance_type_identifier: str = pydantic.Field(..., description='-')
    _init_params: typing.ClassVar[list[str]] = ['instance_type_identifier']
    _method_names: typing.ClassVar[list[str]] = ['same_instance_class_as']
    _classmethod_names: typing.ClassVar[list[str]] = ['of']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InstanceType'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[InstanceTypeDefConfig] = pydantic.Field(None)


class InstanceTypeDefConfig(pydantic.BaseModel):
    of: typing.Optional[list[InstanceTypeDefOfParams]] = pydantic.Field(None, description='Instance type for EC2 instances.\nThis class takes a combination of a class and size.\n\nBe aware that not all combinations of class and size are available, and not all\nclasses are available in all regions.')
    same_instance_class_as: typing.Optional[list[InstanceTypeDefSameInstanceClassAsParams]] = pydantic.Field(None, description='')

class InstanceTypeDefOfParams(pydantic.BaseModel):
    instance_class: aws_cdk.aws_ec2.InstanceClass = pydantic.Field(..., description='-\n')
    instance_size: aws_cdk.aws_ec2.InstanceSize = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.InstanceTypeDefConfig]] = pydantic.Field(None)
    ...

class InstanceTypeDefSameInstanceClassAsParams(pydantic.BaseModel):
    other: models.aws_ec2.InstanceTypeDef = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.InterfaceVpcEndpointAwsService
class InterfaceVpcEndpointAwsServiceDef(BaseClass):
    name: str = pydantic.Field(..., description='The name of the service.')
    prefix: typing.Optional[str] = pydantic.Field(None, description='-\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The port of the service.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'prefix', 'port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InterfaceVpcEndpointAwsService'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.InterfaceVpcEndpointService
class InterfaceVpcEndpointServiceDef(BaseClass):
    name: str = pydantic.Field(..., description='The name of the service.')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The port of the service.')
    _init_params: typing.ClassVar[list[str]] = ['name', 'port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InterfaceVpcEndpointService'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.IpAddresses
class IpAddressesDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['aws_ipam_allocation', 'cidr']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.IpAddresses'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['aws_ipam_allocation', 'cidr']
    ...


    aws_ipam_allocation: typing.Optional[IpAddressesDefAwsIpamAllocationParams] = pydantic.Field(None, description='Used to provide centralized Ip Address Management services for your VPC.\nUses VPC Cidr allocations from AWS IPAM')
    cidr: typing.Optional[IpAddressesDefCidrParams] = pydantic.Field(None, description='Used to provide local Ip Address Management services for your VPC.\nVPC Cidr is supplied at creation and subnets are calculated locally')

class IpAddressesDefAwsIpamAllocationParams(pydantic.BaseModel):
    ipv4_ipam_pool_id: str = pydantic.Field(..., description='Ipam Pool Id for ipv4 allocation.\n')
    ipv4_netmask_length: typing.Union[int, float] = pydantic.Field(..., description='Netmask length for Vpc.\n')
    default_subnet_ipv4_netmask_length: typing.Union[int, float, None] = pydantic.Field(None, description='Default length for Subnet ipv4 Network mask. Specify this option only if you do not specify all Subnets using SubnetConfiguration with a cidrMask Default: - Default ipv4 Subnet Mask for subnets in Vpc\n\n:see: https://docs.aws.amazon.com/vpc/latest/ipam/what-it-is-ipam.html\n')
    ...

class IpAddressesDefCidrParams(pydantic.BaseModel):
    cidr_block: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.LaunchTemplateRequireImdsv2Aspect
class LaunchTemplateRequireImdsv2AspectDef(BaseClass):
    suppress_warnings: typing.Optional[bool] = pydantic.Field(None, description='Whether warning annotations from this Aspect should be suppressed or not. Default: - false')
    _init_params: typing.ClassVar[list[str]] = ['suppress_warnings']
    _method_names: typing.ClassVar[list[str]] = ['visit']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.LaunchTemplateRequireImdsv2Aspect'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[LaunchTemplateRequireImdsv2AspectDefConfig] = pydantic.Field(None)


class LaunchTemplateRequireImdsv2AspectDefConfig(pydantic.BaseModel):
    visit: typing.Optional[list[LaunchTemplateRequireImdsv2AspectDefVisitParams]] = pydantic.Field(None, description='All aspects can visit an IConstruct.')

class LaunchTemplateRequireImdsv2AspectDefVisitParams(pydantic.BaseModel):
    node: models.AnyResource = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.LaunchTemplateSpecialVersions
class LaunchTemplateSpecialVersionsDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.LaunchTemplateSpecialVersions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.LogFormat
class LogFormatDef(BaseClass):
    value: str = pydantic.Field(..., description='-')
    _init_params: typing.ClassVar[list[str]] = ['value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['custom', 'field']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.LogFormat'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[LogFormatDefConfig] = pydantic.Field(None)


class LogFormatDefConfig(pydantic.BaseModel):
    custom: typing.Optional[list[LogFormatDefCustomParams]] = pydantic.Field(None, description='A custom format string.\nGives full control over the format string fragment.')
    field: typing.Optional[list[LogFormatDefFieldParams]] = pydantic.Field(None, description='A custom field name.\nIf there is no ready-made constant for a new field yet, you can use this.\nThe field name will automatically be wrapped in ``${ ... }``.')

class LogFormatDefCustomParams(pydantic.BaseModel):
    format_string: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.LogFormatDefConfig]] = pydantic.Field(None)
    ...

class LogFormatDefFieldParams(pydantic.BaseModel):
    field: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.LogFormatDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_ec2.LookupMachineImage
class LookupMachineImageDef(BaseClass):
    name: str = pydantic.Field(..., description='Name of the image (may contain wildcards).')
    filters: typing.Optional[typing.Mapping[str, typing.Sequence[str]]] = pydantic.Field(None, description='Additional filters on the AMI. Default: - No additional filters\n')
    owners: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Owner account IDs or aliases. Default: - All owners\n')
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Custom userdata for this image. Default: - Empty user data appropriate for the platform type\n')
    windows: typing.Optional[bool] = pydantic.Field(None, description='Look for Windows images. Default: false')
    _init_params: typing.ClassVar[list[str]] = ['name', 'filters', 'owners', 'user_data', 'windows']
    _method_names: typing.ClassVar[list[str]] = ['get_image']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.LookupMachineImage'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[LookupMachineImageDefConfig] = pydantic.Field(None)


class LookupMachineImageDefConfig(pydantic.BaseModel):
    get_image: typing.Optional[list[LookupMachineImageDefGetImageParams]] = pydantic.Field(None, description='Return the image to use in the given context.')

class LookupMachineImageDefGetImageParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.MachineImage
class MachineImageDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['from_ssm_parameter', 'generic_linux', 'generic_windows', 'latest_amazon_linux', 'latest_amazon_linux2', 'latest_amazon_linux2022', 'latest_amazon_linux2023', 'latest_windows', 'lookup']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.MachineImage'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_ssm_parameter', 'generic_linux', 'generic_windows', 'latest_amazon_linux', 'latest_amazon_linux2', 'latest_amazon_linux2022', 'latest_amazon_linux2023', 'latest_windows', 'lookup']
    ...


    from_ssm_parameter: typing.Optional[MachineImageDefFromSsmParameterParams] = pydantic.Field(None, description='An image specified in SSM parameter store.\nBy default, the SSM parameter is refreshed at every deployment,\ncausing your instances to be replaced whenever a new version of the AMI\nis released.\n\nPass ``{ cachedInContext: true }`` to keep the AMI ID stable. If you do, you\nwill have to remember to periodically invalidate the context to refresh\nto the newest AMI ID.')
    generic_linux: typing.Optional[MachineImageDefGenericLinuxParams] = pydantic.Field(None, description='A Linux image where you specify the AMI ID for every region.')
    generic_windows: typing.Optional[MachineImageDefGenericWindowsParams] = pydantic.Field(None, description='A Windows image where you specify the AMI ID for every region.')
    latest_amazon_linux: typing.Optional[MachineImageDefLatestAmazonLinuxParams] = pydantic.Field(None, description='(deprecated) An Amazon Linux image that is automatically kept up-to-date.\nThis Machine Image automatically updates to the latest version on every\ndeployment. Be aware this will cause your instances to be replaced when a\nnew version of the image becomes available. Do not store stateful information\non the instance if you are using this image.\n\nN.B.: "latest" in the name of this function indicates that it always uses the most recent\nimage of a particular generation of Amazon Linux, not that it uses the "latest generation".\nFor backwards compatibility, this function uses Amazon Linux 1 if no generation\nis specified.\n\nSpecify the desired generation using the ``generation`` property::\n\n   ec2.MachineImage.latest_amazon_linux(\n       # Use Amazon Linux 2\n       generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX_2\n   )')
    latest_amazon_linux2: typing.Optional[MachineImageDefLatestAmazonLinux2Params] = pydantic.Field(None, description='An Amazon Linux 2 image that is automatically kept up-to-date.\nThis Machine Image automatically updates to the latest version on every\ndeployment. Be aware this will cause your instances to be replaced when a\nnew version of the image becomes available. Do not store stateful information\non the instance if you are using this image.')
    latest_amazon_linux2022: typing.Optional[MachineImageDefLatestAmazonLinux2022Params] = pydantic.Field(None, description='An Amazon Linux 2022 image that is automatically kept up-to-date.\nThis Machine Image automatically updates to the latest version on every\ndeployment. Be aware this will cause your instances to be replaced when a\nnew version of the image becomes available. Do not store stateful information\non the instance if you are using this image.')
    latest_amazon_linux2023: typing.Optional[MachineImageDefLatestAmazonLinux2023Params] = pydantic.Field(None, description='An Amazon Linux 2023 image that is automatically kept up-to-date.\nThis Machine Image automatically updates to the latest version on every\ndeployment. Be aware this will cause your instances to be replaced when a\nnew version of the image becomes available. Do not store stateful information\non the instance if you are using this image.')
    latest_windows: typing.Optional[MachineImageDefLatestWindowsParams] = pydantic.Field(None, description='A Windows image that is automatically kept up-to-date.\nThis Machine Image automatically updates to the latest version on every\ndeployment. Be aware this will cause your instances to be replaced when a\nnew version of the image becomes available. Do not store stateful information\non the instance if you are using this image.')
    lookup: typing.Optional[MachineImageDefLookupParams] = pydantic.Field(None, description='Look up a shared Machine Image using DescribeImages.\nThe most recent, available, launchable image matching the given filter\ncriteria will be used. Looking up AMIs may take a long time; specify\nas many filter criteria as possible to narrow down the search.\n\nThe AMI selected will be cached in ``cdk.context.json`` and the same value\nwill be used on future runs. To refresh the AMI lookup, you will have to\nevict the value from the cache using the ``cdk context`` command. See\nhttps://docs.aws.amazon.com/cdk/latest/guide/context.html for more information.\n\nThis function can not be used in environment-agnostic stacks.')

class MachineImageDefFromSsmParameterParams(pydantic.BaseModel):
    parameter_name: str = pydantic.Field(..., description='-\n')
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false\n")
    os: typing.Optional[aws_cdk.aws_ec2.OperatingSystemType] = pydantic.Field(None, description='Operating system. Default: OperatingSystemType.LINUX\n')
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Custom UserData. Default: - UserData appropriate for the OS')
    ...

class MachineImageDefGenericLinuxParams(pydantic.BaseModel):
    ami_map: typing.Mapping[str, str] = pydantic.Field(..., description='For every region where you are deploying the stack, specify the AMI ID for that region.\n')
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines')
    ...

class MachineImageDefGenericWindowsParams(pydantic.BaseModel):
    ami_map: typing.Mapping[str, str] = pydantic.Field(..., description='For every region where you are deploying the stack, specify the AMI ID for that region.\n')
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Windows machines')
    ...

class MachineImageDefLatestAmazonLinuxParams(pydantic.BaseModel):
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false\n")
    cpu_type: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxCpuType] = pydantic.Field(None, description='CPU Type. Default: X86_64\n')
    edition: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxEdition] = pydantic.Field(None, description='What edition of Amazon Linux to use. Default: Standard\n')
    generation: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxGeneration] = pydantic.Field(None, description='What generation of Amazon Linux to use. Default: AmazonLinux\n')
    kernel: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxKernel] = pydantic.Field(None, description='What kernel version of Amazon Linux to use. Default: -\n')
    storage: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxStorage] = pydantic.Field(None, description='What storage backed image to use. Default: GeneralPurpose\n')
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines\n')
    virtualization: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxVirt] = pydantic.Field(None, description='Virtualization type. Default: HVM\n\n:deprecated: use MachineImage.latestAmazonLinux2 instead\n\n:stability: deprecated\n')
    ...

class MachineImageDefLatestAmazonLinux2Params(pydantic.BaseModel):
    kernel: typing.Optional[models.aws_ec2.AmazonLinux2KernelDef] = pydantic.Field(None, description='What kernel version of Amazon Linux to use. Default: -\n')
    storage: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxStorage] = pydantic.Field(None, description='What storage backed image to use. Default: GeneralPurpose\n')
    virtualization: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxVirt] = pydantic.Field(None, description='Virtualization type. Default: HVM\n')
    cpu_type: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxCpuType] = pydantic.Field(None, description='CPU Type. Default: AmazonLinuxCpuType.X86_64\n')
    edition: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxEdition] = pydantic.Field(None, description='What edition of Amazon Linux to use. Default: AmazonLinuxEdition.Standard\n')
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false\n")
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines')
    ...

class MachineImageDefLatestAmazonLinux2022Params(pydantic.BaseModel):
    kernel: typing.Optional[models.aws_ec2.AmazonLinux2022KernelDef] = pydantic.Field(None, description='What kernel version of Amazon Linux to use. Default: AmazonLinux2022Kernel.DEFAULT\n')
    cpu_type: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxCpuType] = pydantic.Field(None, description='CPU Type. Default: AmazonLinuxCpuType.X86_64\n')
    edition: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxEdition] = pydantic.Field(None, description='What edition of Amazon Linux to use. Default: AmazonLinuxEdition.Standard\n')
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false\n")
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines')
    ...

class MachineImageDefLatestAmazonLinux2023Params(pydantic.BaseModel):
    kernel: typing.Optional[models.aws_ec2.AmazonLinux2023KernelDef] = pydantic.Field(None, description='What kernel version of Amazon Linux to use. Default: AmazonLinux2023Kernel.DEFAULT\n')
    cpu_type: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxCpuType] = pydantic.Field(None, description='CPU Type. Default: AmazonLinuxCpuType.X86_64\n')
    edition: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxEdition] = pydantic.Field(None, description='What edition of Amazon Linux to use. Default: AmazonLinuxEdition.Standard\n')
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false\n")
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines')
    ...

class MachineImageDefLatestWindowsParams(pydantic.BaseModel):
    version: aws_cdk.aws_ec2.WindowsVersion = pydantic.Field(..., description='-\n')
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Windows machines')
    ...

class MachineImageDefLookupParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='Name of the image (may contain wildcards).\n')
    filters: typing.Optional[typing.Mapping[str, typing.Sequence[str]]] = pydantic.Field(None, description='Additional filters on the AMI. Default: - No additional filters\n')
    owners: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Owner account IDs or aliases. Default: - All owners\n')
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Custom userdata for this image. Default: - Empty user data appropriate for the platform type\n')
    windows: typing.Optional[bool] = pydantic.Field(None, description='Look for Windows images. Default: false')
    ...


#  autogenerated from aws_cdk.aws_ec2.MultipartBody
class MultipartBodyDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['render_body_part']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_raw_body', 'from_user_data']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.MultipartBody'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_raw_body', 'from_user_data']
    ...


    from_raw_body: typing.Optional[MultipartBodyDefFromRawBodyParams] = pydantic.Field(None, description="Constructs the raw ``MultipartBody`` using specified body, content type and transfer encoding.\nWhen transfer encoding is specified (typically as Base64), it's caller responsibility to convert body to\nBase64 either by wrapping with ``Fn.base64`` or by converting it by other converters.")
    from_user_data: typing.Optional[MultipartBodyDefFromUserDataParams] = pydantic.Field(None, description='Constructs the new ``MultipartBody`` wrapping existing ``UserData``. Modification to ``UserData`` are reflected in subsequent renders of the part.\nFor more information about content types see ``MultipartBodyOptions.contentType``.')
    resource_config: typing.Optional[MultipartBodyDefConfig] = pydantic.Field(None)


class MultipartBodyDefConfig(pydantic.BaseModel):
    render_body_part: typing.Optional[bool] = pydantic.Field(None, description='Render body part as the string.\nSubclasses should not add leading nor trailing new line characters (\\r \\n)')

class MultipartBodyDefFromRawBodyParams(pydantic.BaseModel):
    content_type: str = pydantic.Field(..., description='``Content-Type`` header of this part. Some examples of content types: - ``text/x-shellscript; charset="utf-8"`` (shell script) - ``text/cloud-boothook; charset="utf-8"`` (shell script executed during boot phase) For Linux shell scripts use ``text/x-shellscript``.\n')
    body: typing.Optional[str] = pydantic.Field(None, description='The body of message. Default: undefined - body will not be added to part\n')
    transfer_encoding: typing.Optional[str] = pydantic.Field(None, description='``Content-Transfer-Encoding`` header specifying part encoding. Default: undefined - body is not encoded')
    ...

class MultipartBodyDefFromUserDataParams(pydantic.BaseModel):
    user_data: models.aws_ec2.UserDataDef = pydantic.Field(..., description='user data to wrap into body part.\n')
    content_type: typing.Optional[str] = pydantic.Field(None, description='optional content type, if default one should not be used.')
    ...


#  autogenerated from aws_cdk.aws_ec2.MultipartUserData
class MultipartUserDataDef(BaseClass):
    parts_separator: typing.Optional[str] = pydantic.Field(None, description="The string used to separate parts in multipart user data archive (it's like MIME boundary). This string should contain [a-zA-Z0-9()+,-./:=?] characters only, and should not be present in any part, or in text content of archive. Default: ``+AWS+CDK+User+Data+Separator==``")
    _init_params: typing.ClassVar[list[str]] = ['parts_separator']
    _method_names: typing.ClassVar[list[str]] = ['add_commands', 'add_execute_file_command', 'add_on_exit_commands', 'add_part', 'add_s3_download_command', 'add_signal_on_exit_command', 'add_user_data_part', 'render']
    _classmethod_names: typing.ClassVar[list[str]] = ['custom', 'for_linux', 'for_operating_system', 'for_windows']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.MultipartUserData'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[MultipartUserDataDefConfig] = pydantic.Field(None)


class MultipartUserDataDefConfig(pydantic.BaseModel):
    add_commands: typing.Optional[list[MultipartUserDataDefAddCommandsParams]] = pydantic.Field(None, description='Add one or more commands to the user data.')
    add_execute_file_command: typing.Optional[list[MultipartUserDataDefAddExecuteFileCommandParams]] = pydantic.Field(None, description='Adds commands to execute a file.')
    add_on_exit_commands: typing.Optional[list[MultipartUserDataDefAddOnExitCommandsParams]] = pydantic.Field(None, description='Add one or more commands to the user data that will run when the script exits.')
    add_part: typing.Optional[list[MultipartUserDataDefAddPartParams]] = pydantic.Field(None, description='Adds a part to the list of parts.')
    add_s3_download_command: typing.Optional[list[MultipartUserDataDefAddS3DownloadCommandParams]] = pydantic.Field(None, description='Adds commands to download a file from S3.')
    add_signal_on_exit_command: typing.Optional[list[MultipartUserDataDefAddSignalOnExitCommandParams]] = pydantic.Field(None, description='Adds a command which will send a cfn-signal when the user data script ends.')
    add_user_data_part: typing.Optional[list[MultipartUserDataDefAddUserDataPartParams]] = pydantic.Field(None, description='Adds a multipart part based on a UserData object.\nIf ``makeDefault`` is true, then the UserData added by this method\nwill also be the target of calls to the ``add*Command`` methods on\nthis MultipartUserData object.\n\nIf ``makeDefault`` is false, then this is the same as calling::\n\n   # multi_part: ec2.MultipartUserData\n   # user_data: ec2.UserData\n   # content_type: str\n\n\n   multi_part.add_part(ec2.MultipartBody.from_user_data(user_data, content_type))\n\nAn undefined ``makeDefault`` defaults to either:\n\n- ``true`` if no default UserData has been set yet; or\n- ``false`` if there is no default UserData set.')
    custom: typing.Optional[list[MultipartUserDataDefCustomParams]] = pydantic.Field(None, description='Create a userdata object with custom content.')
    for_linux: typing.Optional[list[MultipartUserDataDefForLinuxParams]] = pydantic.Field(None, description='Create a userdata object for Linux hosts.')
    for_operating_system: typing.Optional[list[MultipartUserDataDefForOperatingSystemParams]] = pydantic.Field(None, description='')
    for_windows: typing.Optional[list[MultipartUserDataDefForWindowsParams]] = pydantic.Field(None, description='Create a userdata object for Windows hosts.')
    render: typing.Optional[bool] = pydantic.Field(None, description='Render the UserData for use in a construct.')

class MultipartUserDataDefAddCommandsParams(pydantic.BaseModel):
    commands: list[str] = pydantic.Field(...)
    ...

class MultipartUserDataDefAddExecuteFileCommandParams(pydantic.BaseModel):
    file_path: str = pydantic.Field(..., description='The path to the file.\n')
    arguments: typing.Optional[str] = pydantic.Field(None, description='The arguments to be passed to the file. Default: No arguments are passed to the file.')
    ...

class MultipartUserDataDefAddOnExitCommandsParams(pydantic.BaseModel):
    commands: list[str] = pydantic.Field(...)
    ...

class MultipartUserDataDefAddPartParams(pydantic.BaseModel):
    part: models.aws_ec2.MultipartBodyDef = pydantic.Field(..., description='-')
    ...

class MultipartUserDataDefAddS3DownloadCommandParams(pydantic.BaseModel):
    bucket: typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef] = pydantic.Field(..., description='Name of the S3 bucket to download from.\n')
    bucket_key: str = pydantic.Field(..., description='The key of the file to download.\n')
    local_file: typing.Optional[str] = pydantic.Field(None, description='The name of the local file. Default: Linux - /tmp/bucketKey Windows - %TEMP%/bucketKey\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region of the S3 Bucket (needed for access via VPC Gateway). Default: none')
    ...

class MultipartUserDataDefAddSignalOnExitCommandParams(pydantic.BaseModel):
    resource: models.ResourceDef = pydantic.Field(..., description='-')
    ...

class MultipartUserDataDefAddUserDataPartParams(pydantic.BaseModel):
    user_data: models.aws_ec2.UserDataDef = pydantic.Field(..., description='-\n')
    content_type: typing.Optional[str] = pydantic.Field(None, description='-\n')
    make_default: typing.Optional[bool] = pydantic.Field(None, description='-')
    ...

class MultipartUserDataDefCustomParams(pydantic.BaseModel):
    content: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.UserDataDefConfig]] = pydantic.Field(None)
    ...

class MultipartUserDataDefForLinuxParams(pydantic.BaseModel):
    shebang: typing.Optional[str] = pydantic.Field(None, description='Shebang for the UserData script. Default: "#!/bin/bash"')
    return_config: typing.Optional[list[models.aws_ec2.UserDataDefConfig]] = pydantic.Field(None)
    ...

class MultipartUserDataDefForOperatingSystemParams(pydantic.BaseModel):
    os: aws_cdk.aws_ec2.OperatingSystemType = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.UserDataDefConfig]] = pydantic.Field(None)
    ...

class MultipartUserDataDefForWindowsParams(pydantic.BaseModel):
    persist: typing.Optional[bool] = pydantic.Field(None, description='Set to true to set this userdata to persist through an instance reboot; allowing it to run on every instance start. By default, UserData is run only once during the first instance launch. For more information, see: https://aws.amazon.com/premiumsupport/knowledge-center/execute-user-data-ec2/ https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html#user-data-scripts Default: false')
    return_config: typing.Optional[list[models.aws_ec2.UserDataDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_ec2.NatInstanceImage
class NatInstanceImageDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['get_image']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.NatInstanceImage'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[NatInstanceImageDefConfig] = pydantic.Field(None)


class NatInstanceImageDefConfig(pydantic.BaseModel):
    get_image: typing.Optional[list[NatInstanceImageDefGetImageParams]] = pydantic.Field(None, description='Return the image to use in the given context.')

class NatInstanceImageDefGetImageParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.NatInstanceProvider
class NatInstanceProviderDef(BaseClass, ConnectableMixin):
    instance_type: models.aws_ec2.InstanceTypeDef = pydantic.Field(..., description='Instance type of the NAT instance.')
    default_allowed_traffic: typing.Optional[aws_cdk.aws_ec2.NatTrafficDirection] = pydantic.Field(None, description="Direction to allow all traffic through the NAT instance by default. By default, inbound and outbound traffic is allowed. If you set this to another value than INBOUND_AND_OUTBOUND, you must configure the NAT instance's security groups in another way, either by passing in a fully configured Security Group using the ``securityGroup`` property, or by configuring it using the ``.securityGroup`` or ``.connections`` members after passing the NAT Instance Provider to a Vpc. Default: NatTrafficDirection.INBOUND_AND_OUTBOUND\n")
    key_name: typing.Optional[str] = pydantic.Field(None, description='Name of SSH keypair to grant access to instance. Default: - No SSH access will be possible.\n')
    machine_image: typing.Optional[typing.Union[models.aws_ec2.AmazonLinux2022ImageSsmParameterDef, models.aws_ec2.AmazonLinux2023ImageSsmParameterDef, models.aws_ec2.AmazonLinux2ImageSsmParameterDef, models.aws_ec2.AmazonLinuxImageDef, models.aws_ec2.AmazonLinuxImageSsmParameterBaseDef, models.aws_ec2.GenericLinuxImageDef, models.aws_ec2.GenericSSMParameterImageDef, models.aws_ec2.GenericWindowsImageDef, models.aws_ec2.LookupMachineImageDef, models.aws_ec2.NatInstanceImageDef, models.aws_ec2.WindowsImageDef, models.aws_ecs.BottleRocketImageDef, models.aws_ecs.EcsOptimizedImageDef, models.aws_eks.EksOptimizedImageDef]] = pydantic.Field(None, description="The machine image (AMI) to use. By default, will do an AMI lookup for the latest NAT instance image. If you have a specific AMI ID you want to use, pass a ``GenericLinuxImage``. For example:: ec2.NatProvider.instance({ instanceType: new ec2.InstanceType('t3.micro'), machineImage: new ec2.GenericLinuxImage({ 'us-east-2': 'ami-0f9c61b5a562a16af' }) }) Default: - Latest NAT instance image\n")
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='Security Group for NAT instances. Default: - A new security group will be created')
    _init_params: typing.ClassVar[list[str]] = ['instance_type', 'default_allowed_traffic', 'key_name', 'machine_image', 'security_group']
    _method_names: typing.ClassVar[list[str]] = ['configure_nat', 'configure_subnet']
    _classmethod_names: typing.ClassVar[list[str]] = ['gateway', 'instance']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.NatInstanceProvider'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[NatInstanceProviderDefConfig] = pydantic.Field(None)


class NatInstanceProviderDefConfig(pydantic.BaseModel):
    configure_nat: typing.Optional[list[NatInstanceProviderDefConfigureNatParams]] = pydantic.Field(None, description="Called by the VPC to configure NAT.\nDon't call this directly, the VPC will call it automatically.")
    configure_subnet: typing.Optional[list[NatInstanceProviderDefConfigureSubnetParams]] = pydantic.Field(None, description="Configures subnet with the gateway.\nDon't call this directly, the VPC will call it automatically.")
    gateway: typing.Optional[list[NatInstanceProviderDefGatewayParams]] = pydantic.Field(None, description='Use NAT Gateways to provide NAT services for your VPC.\nNAT gateways are managed by AWS.')
    instance: typing.Optional[list[NatInstanceProviderDefInstanceParams]] = pydantic.Field(None, description='Use NAT instances to provide NAT services for your VPC.\nNAT instances are managed by you, but in return allow more configuration.\n\nBe aware that instances created using this provider will not be\nautomatically replaced if they are stopped for any reason. You should implement\nyour own NatProvider based on AutoScaling groups if you need that.')
    connections_config: typing.Optional[models.aws_ec2.ConnectionsDefConfig] = pydantic.Field(None)
    security_group_config: typing.Optional[models._interface_methods.AwsEc2ISecurityGroupDefConfig] = pydantic.Field(None)

class NatInstanceProviderDefConfigureNatParams(pydantic.BaseModel):
    nat_subnets: typing.Sequence[models.aws_ec2.PublicSubnetDef] = pydantic.Field(..., description='The public subnets where the NAT providers need to be placed.\n')
    private_subnets: typing.Sequence[models.aws_ec2.PrivateSubnetDef] = pydantic.Field(..., description='The private subnets that need to route through the NAT providers. There may be more private subnets than public subnets with NAT providers.\n')
    vpc: models.aws_ec2.VpcDef = pydantic.Field(..., description="The VPC we're configuring NAT for.")
    ...

class NatInstanceProviderDefConfigureSubnetParams(pydantic.BaseModel):
    subnet: models.aws_ec2.PrivateSubnetDef = pydantic.Field(..., description='-')
    ...

class NatInstanceProviderDefGatewayParams(pydantic.BaseModel):
    eip_allocation_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='EIP allocation IDs for the NAT gateways. Default: - No fixed EIPs allocated for the NAT gateways\n\n:see: https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html\n')
    return_config: typing.Optional[list[models.aws_ec2.NatProviderDefConfig]] = pydantic.Field(None)
    ...

class NatInstanceProviderDefInstanceParams(pydantic.BaseModel):
    instance_type: models.aws_ec2.InstanceTypeDef = pydantic.Field(..., description='Instance type of the NAT instance.\n')
    default_allowed_traffic: typing.Optional[aws_cdk.aws_ec2.NatTrafficDirection] = pydantic.Field(None, description="Direction to allow all traffic through the NAT instance by default. By default, inbound and outbound traffic is allowed. If you set this to another value than INBOUND_AND_OUTBOUND, you must configure the NAT instance's security groups in another way, either by passing in a fully configured Security Group using the ``securityGroup`` property, or by configuring it using the ``.securityGroup`` or ``.connections`` members after passing the NAT Instance Provider to a Vpc. Default: NatTrafficDirection.INBOUND_AND_OUTBOUND\n")
    key_name: typing.Optional[str] = pydantic.Field(None, description='Name of SSH keypair to grant access to instance. Default: - No SSH access will be possible.\n')
    machine_image: typing.Optional[typing.Union[models.aws_ec2.AmazonLinux2022ImageSsmParameterDef, models.aws_ec2.AmazonLinux2023ImageSsmParameterDef, models.aws_ec2.AmazonLinux2ImageSsmParameterDef, models.aws_ec2.AmazonLinuxImageDef, models.aws_ec2.AmazonLinuxImageSsmParameterBaseDef, models.aws_ec2.GenericLinuxImageDef, models.aws_ec2.GenericSSMParameterImageDef, models.aws_ec2.GenericWindowsImageDef, models.aws_ec2.LookupMachineImageDef, models.aws_ec2.NatInstanceImageDef, models.aws_ec2.WindowsImageDef, models.aws_ecs.BottleRocketImageDef, models.aws_ecs.EcsOptimizedImageDef, models.aws_eks.EksOptimizedImageDef]] = pydantic.Field(None, description="The machine image (AMI) to use. By default, will do an AMI lookup for the latest NAT instance image. If you have a specific AMI ID you want to use, pass a ``GenericLinuxImage``. For example:: ec2.NatProvider.instance({ instanceType: new ec2.InstanceType('t3.micro'), machineImage: new ec2.GenericLinuxImage({ 'us-east-2': 'ami-0f9c61b5a562a16af' }) }) Default: - Latest NAT instance image\n")
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='Security Group for NAT instances. Default: - A new security group will be created\n\n:see: https://docs.aws.amazon.com/vpc/latest/userguide/VPC_NAT_Instance.html\n')
    return_config: typing.Optional[list[models.aws_ec2.NatInstanceProviderDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_ec2.NatProvider
class NatProviderDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['configure_nat', 'configure_subnet']
    _classmethod_names: typing.ClassVar[list[str]] = ['gateway', 'instance']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.NatProvider'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[NatProviderDefConfig] = pydantic.Field(None)


class NatProviderDefConfig(pydantic.BaseModel):
    configure_nat: typing.Optional[list[NatProviderDefConfigureNatParams]] = pydantic.Field(None, description="Called by the VPC to configure NAT.\nDon't call this directly, the VPC will call it automatically.")
    configure_subnet: typing.Optional[list[NatProviderDefConfigureSubnetParams]] = pydantic.Field(None, description="Configures subnet with the gateway.\nDon't call this directly, the VPC will call it automatically.")
    gateway: typing.Optional[list[NatProviderDefGatewayParams]] = pydantic.Field(None, description='Use NAT Gateways to provide NAT services for your VPC.\nNAT gateways are managed by AWS.')
    instance: typing.Optional[list[NatProviderDefInstanceParams]] = pydantic.Field(None, description='Use NAT instances to provide NAT services for your VPC.\nNAT instances are managed by you, but in return allow more configuration.\n\nBe aware that instances created using this provider will not be\nautomatically replaced if they are stopped for any reason. You should implement\nyour own NatProvider based on AutoScaling groups if you need that.')

class NatProviderDefConfigureNatParams(pydantic.BaseModel):
    nat_subnets: typing.Sequence[models.aws_ec2.PublicSubnetDef] = pydantic.Field(..., description='The public subnets where the NAT providers need to be placed.\n')
    private_subnets: typing.Sequence[models.aws_ec2.PrivateSubnetDef] = pydantic.Field(..., description='The private subnets that need to route through the NAT providers. There may be more private subnets than public subnets with NAT providers.\n')
    vpc: models.aws_ec2.VpcDef = pydantic.Field(..., description="The VPC we're configuring NAT for.")
    ...

class NatProviderDefConfigureSubnetParams(pydantic.BaseModel):
    subnet: models.aws_ec2.PrivateSubnetDef = pydantic.Field(..., description='-')
    ...

class NatProviderDefGatewayParams(pydantic.BaseModel):
    eip_allocation_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='EIP allocation IDs for the NAT gateways. Default: - No fixed EIPs allocated for the NAT gateways\n\n:see: https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html\n')
    return_config: typing.Optional[list[models.aws_ec2.NatProviderDefConfig]] = pydantic.Field(None)
    ...

class NatProviderDefInstanceParams(pydantic.BaseModel):
    instance_type: models.aws_ec2.InstanceTypeDef = pydantic.Field(..., description='Instance type of the NAT instance.\n')
    default_allowed_traffic: typing.Optional[aws_cdk.aws_ec2.NatTrafficDirection] = pydantic.Field(None, description="Direction to allow all traffic through the NAT instance by default. By default, inbound and outbound traffic is allowed. If you set this to another value than INBOUND_AND_OUTBOUND, you must configure the NAT instance's security groups in another way, either by passing in a fully configured Security Group using the ``securityGroup`` property, or by configuring it using the ``.securityGroup`` or ``.connections`` members after passing the NAT Instance Provider to a Vpc. Default: NatTrafficDirection.INBOUND_AND_OUTBOUND\n")
    key_name: typing.Optional[str] = pydantic.Field(None, description='Name of SSH keypair to grant access to instance. Default: - No SSH access will be possible.\n')
    machine_image: typing.Optional[typing.Union[models.aws_ec2.AmazonLinux2022ImageSsmParameterDef, models.aws_ec2.AmazonLinux2023ImageSsmParameterDef, models.aws_ec2.AmazonLinux2ImageSsmParameterDef, models.aws_ec2.AmazonLinuxImageDef, models.aws_ec2.AmazonLinuxImageSsmParameterBaseDef, models.aws_ec2.GenericLinuxImageDef, models.aws_ec2.GenericSSMParameterImageDef, models.aws_ec2.GenericWindowsImageDef, models.aws_ec2.LookupMachineImageDef, models.aws_ec2.NatInstanceImageDef, models.aws_ec2.WindowsImageDef, models.aws_ecs.BottleRocketImageDef, models.aws_ecs.EcsOptimizedImageDef, models.aws_eks.EksOptimizedImageDef]] = pydantic.Field(None, description="The machine image (AMI) to use. By default, will do an AMI lookup for the latest NAT instance image. If you have a specific AMI ID you want to use, pass a ``GenericLinuxImage``. For example:: ec2.NatProvider.instance({ instanceType: new ec2.InstanceType('t3.micro'), machineImage: new ec2.GenericLinuxImage({ 'us-east-2': 'ami-0f9c61b5a562a16af' }) }) Default: - Latest NAT instance image\n")
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='Security Group for NAT instances. Default: - A new security group will be created\n\n:see: https://docs.aws.amazon.com/vpc/latest/userguide/VPC_NAT_Instance.html\n')
    return_config: typing.Optional[list[models.aws_ec2.NatInstanceProviderDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_ec2.Peer
class PeerDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['any_ipv4', 'any_ipv6', 'ipv4', 'ipv6', 'prefix_list', 'security_group_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.Peer'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['any_ipv4', 'any_ipv6', 'ipv4', 'ipv6', 'prefix_list', 'security_group_id']
    ...


    any_ipv4: typing.Optional[PeerDefAnyIpv4Params] = pydantic.Field(None, description='Any IPv4 address.')
    any_ipv6: typing.Optional[PeerDefAnyIpv6Params] = pydantic.Field(None, description='Any IPv6 address.')
    ipv4: typing.Optional[PeerDefIpv4Params] = pydantic.Field(None, description='Create an IPv4 peer from a CIDR.')
    ipv6: typing.Optional[PeerDefIpv6Params] = pydantic.Field(None, description='Create an IPv6 peer from a CIDR.')
    prefix_list: typing.Optional[PeerDefPrefixListParams] = pydantic.Field(None, description='A prefix list.')
    security_group_id: typing.Optional[PeerDefSecurityGroupIdParams] = pydantic.Field(None, description='A security group ID.')

class PeerDefAnyIpv4Params(pydantic.BaseModel):
    ...

class PeerDefAnyIpv6Params(pydantic.BaseModel):
    ...

class PeerDefIpv4Params(pydantic.BaseModel):
    cidr_ip: str = pydantic.Field(..., description='-')
    ...

class PeerDefIpv6Params(pydantic.BaseModel):
    cidr_ip: str = pydantic.Field(..., description='-')
    ...

class PeerDefPrefixListParams(pydantic.BaseModel):
    prefix_list_id: str = pydantic.Field(..., description='-')
    ...

class PeerDefSecurityGroupIdParams(pydantic.BaseModel):
    security_group_id: str = pydantic.Field(..., description='-\n')
    source_security_group_owner_id: typing.Optional[str] = pydantic.Field(None, description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.Port
class PortDef(BaseClass):
    protocol: aws_cdk.aws_ec2.Protocol = pydantic.Field(..., description='The protocol for the range.')
    string_representation: str = pydantic.Field(..., description='String representation for this object.\n')
    from_port: typing.Union[int, float, None] = pydantic.Field(None, description='The starting port for the range. Default: - Not included in the rule\n')
    to_port: typing.Union[int, float, None] = pydantic.Field(None, description='The ending port for the range. Default: - Not included in the rule')
    _init_params: typing.ClassVar[list[str]] = ['protocol', 'string_representation', 'from_port', 'to_port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = ['ah', 'all_icmp', 'all_icmp_v6', 'all_tcp', 'all_traffic', 'all_udp', 'esp', 'icmp_ping', 'icmp_type', 'icmp_type_and_code', 'tcp', 'tcp_range', 'udp', 'udp_range']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.Port'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[PortDefConfig] = pydantic.Field(None)


class PortDefConfig(pydantic.BaseModel):
    ah: typing.Optional[list[PortDefAhParams]] = pydantic.Field(None, description='A single AH port.')
    all_icmp: typing.Optional[list[PortDefAllIcmpParams]] = pydantic.Field(None, description='All ICMP traffic.')
    all_icmp_v6: typing.Optional[list[PortDefAllIcmpV6Params]] = pydantic.Field(None, description='All ICMPv6 traffic.')
    all_tcp: typing.Optional[list[PortDefAllTcpParams]] = pydantic.Field(None, description='Any TCP traffic.')
    all_traffic: typing.Optional[list[PortDefAllTrafficParams]] = pydantic.Field(None, description='All traffic.')
    all_udp: typing.Optional[list[PortDefAllUdpParams]] = pydantic.Field(None, description='Any UDP traffic.')
    esp: typing.Optional[list[PortDefEspParams]] = pydantic.Field(None, description='A single ESP port.')
    icmp_ping: typing.Optional[list[PortDefIcmpPingParams]] = pydantic.Field(None, description='ICMP ping (echo) traffic.')
    icmp_type: typing.Optional[list[PortDefIcmpTypeParams]] = pydantic.Field(None, description='All codes for a single ICMP type.')
    icmp_type_and_code: typing.Optional[list[PortDefIcmpTypeAndCodeParams]] = pydantic.Field(None, description='A specific combination of ICMP type and code.')
    tcp: typing.Optional[list[PortDefTcpParams]] = pydantic.Field(None, description='A single TCP port.')
    tcp_range: typing.Optional[list[PortDefTcpRangeParams]] = pydantic.Field(None, description='A TCP port range.')
    udp: typing.Optional[list[PortDefUdpParams]] = pydantic.Field(None, description='A single UDP port.')
    udp_range: typing.Optional[list[PortDefUdpRangeParams]] = pydantic.Field(None, description='A UDP port range.')

class PortDefAhParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_ec2.PortDefConfig]] = pydantic.Field(None)
    ...

class PortDefAllIcmpParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_ec2.PortDefConfig]] = pydantic.Field(None)
    ...

class PortDefAllIcmpV6Params(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_ec2.PortDefConfig]] = pydantic.Field(None)
    ...

class PortDefAllTcpParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_ec2.PortDefConfig]] = pydantic.Field(None)
    ...

class PortDefAllTrafficParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_ec2.PortDefConfig]] = pydantic.Field(None)
    ...

class PortDefAllUdpParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_ec2.PortDefConfig]] = pydantic.Field(None)
    ...

class PortDefEspParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_ec2.PortDefConfig]] = pydantic.Field(None)
    ...

class PortDefIcmpPingParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_ec2.PortDefConfig]] = pydantic.Field(None)
    ...

class PortDefIcmpTypeParams(pydantic.BaseModel):
    type: typing.Union[int, float] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.PortDefConfig]] = pydantic.Field(None)
    ...

class PortDefIcmpTypeAndCodeParams(pydantic.BaseModel):
    type: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    code: typing.Union[int, float] = pydantic.Field(..., description='-\n\n:see: https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml\n')
    return_config: typing.Optional[list[models.aws_ec2.PortDefConfig]] = pydantic.Field(None)
    ...

class PortDefTcpParams(pydantic.BaseModel):
    port: typing.Union[int, float] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.PortDefConfig]] = pydantic.Field(None)
    ...

class PortDefTcpRangeParams(pydantic.BaseModel):
    start_port: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    end_port: typing.Union[int, float] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.PortDefConfig]] = pydantic.Field(None)
    ...

class PortDefUdpParams(pydantic.BaseModel):
    port: typing.Union[int, float] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.PortDefConfig]] = pydantic.Field(None)
    ...

class PortDefUdpRangeParams(pydantic.BaseModel):
    start_port: typing.Union[int, float] = pydantic.Field(..., description='-\n')
    end_port: typing.Union[int, float] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.PortDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_ec2.SubnetFilter
class SubnetFilterDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['select_subnets']
    _classmethod_names: typing.ClassVar[list[str]] = ['availability_zones', 'by_cidr_mask', 'by_ids', 'contains_ip_addresses', 'one_per_az']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.SubnetFilter'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[SubnetFilterDefConfig] = pydantic.Field(None)


class SubnetFilterDefConfig(pydantic.BaseModel):
    availability_zones: typing.Optional[list[SubnetFilterDefAvailabilityZonesParams]] = pydantic.Field(None, description='Chooses subnets which are in one of the given availability zones.')
    by_cidr_mask: typing.Optional[list[SubnetFilterDefByCidrMaskParams]] = pydantic.Field(None, description='Chooses subnets which have the provided CIDR netmask.')
    by_ids: typing.Optional[list[SubnetFilterDefByIdsParams]] = pydantic.Field(None, description='Chooses subnets by id.')
    contains_ip_addresses: typing.Optional[list[SubnetFilterDefContainsIpAddressesParams]] = pydantic.Field(None, description='Chooses subnets which contain any of the specified IP addresses.')
    one_per_az: typing.Optional[list[SubnetFilterDefOnePerAzParams]] = pydantic.Field(None, description='Chooses subnets such that there is at most one per availability zone.')
    select_subnets: typing.Optional[list[SubnetFilterDefSelectSubnetsParams]] = pydantic.Field(None, description='Executes the subnet filtering logic, returning a filtered set of subnets.')

class SubnetFilterDefAvailabilityZonesParams(pydantic.BaseModel):
    availability_zones: typing.Sequence[str] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.SubnetFilterDefConfig]] = pydantic.Field(None)
    ...

class SubnetFilterDefByCidrMaskParams(pydantic.BaseModel):
    mask: typing.Union[int, float] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.SubnetFilterDefConfig]] = pydantic.Field(None)
    ...

class SubnetFilterDefByIdsParams(pydantic.BaseModel):
    subnet_ids: typing.Sequence[str] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.SubnetFilterDefConfig]] = pydantic.Field(None)
    ...

class SubnetFilterDefContainsIpAddressesParams(pydantic.BaseModel):
    ipv4addrs: typing.Sequence[str] = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.SubnetFilterDefConfig]] = pydantic.Field(None)
    ...

class SubnetFilterDefOnePerAzParams(pydantic.BaseModel):
    return_config: typing.Optional[list[models.aws_ec2.SubnetFilterDefConfig]] = pydantic.Field(None)
    ...

class SubnetFilterDefSelectSubnetsParams(pydantic.BaseModel):
    _subnets: typing.Sequence[typing.Union[models.aws_ec2.PrivateSubnetDef, models.aws_ec2.PublicSubnetDef, models.aws_ec2.SubnetDef]] = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.UserData
class UserDataDef(BaseClass):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = ['add_commands', 'add_execute_file_command', 'add_on_exit_commands', 'add_s3_download_command', 'add_signal_on_exit_command', 'render']
    _classmethod_names: typing.ClassVar[list[str]] = ['custom', 'for_linux', 'for_operating_system', 'for_windows']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.UserData'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[UserDataDefConfig] = pydantic.Field(None)


class UserDataDefConfig(pydantic.BaseModel):
    add_commands: typing.Optional[list[UserDataDefAddCommandsParams]] = pydantic.Field(None, description='Add one or more commands to the user data.')
    add_execute_file_command: typing.Optional[list[UserDataDefAddExecuteFileCommandParams]] = pydantic.Field(None, description='Adds commands to execute a file.')
    add_on_exit_commands: typing.Optional[list[UserDataDefAddOnExitCommandsParams]] = pydantic.Field(None, description='Add one or more commands to the user data that will run when the script exits.')
    add_s3_download_command: typing.Optional[list[UserDataDefAddS3DownloadCommandParams]] = pydantic.Field(None, description='Adds commands to download a file from S3.')
    add_signal_on_exit_command: typing.Optional[list[UserDataDefAddSignalOnExitCommandParams]] = pydantic.Field(None, description='Adds a command which will send a cfn-signal when the user data script ends.')
    custom: typing.Optional[list[UserDataDefCustomParams]] = pydantic.Field(None, description='Create a userdata object with custom content.')
    for_linux: typing.Optional[list[UserDataDefForLinuxParams]] = pydantic.Field(None, description='Create a userdata object for Linux hosts.')
    for_operating_system: typing.Optional[list[UserDataDefForOperatingSystemParams]] = pydantic.Field(None, description='')
    for_windows: typing.Optional[list[UserDataDefForWindowsParams]] = pydantic.Field(None, description='Create a userdata object for Windows hosts.')
    render: typing.Optional[bool] = pydantic.Field(None, description='Render the UserData for use in a construct.')

class UserDataDefAddCommandsParams(pydantic.BaseModel):
    commands: list[str] = pydantic.Field(...)
    ...

class UserDataDefAddExecuteFileCommandParams(pydantic.BaseModel):
    file_path: str = pydantic.Field(..., description='The path to the file.\n')
    arguments: typing.Optional[str] = pydantic.Field(None, description='The arguments to be passed to the file. Default: No arguments are passed to the file.')
    ...

class UserDataDefAddOnExitCommandsParams(pydantic.BaseModel):
    commands: list[str] = pydantic.Field(...)
    ...

class UserDataDefAddS3DownloadCommandParams(pydantic.BaseModel):
    bucket: typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef] = pydantic.Field(..., description='Name of the S3 bucket to download from.\n')
    bucket_key: str = pydantic.Field(..., description='The key of the file to download.\n')
    local_file: typing.Optional[str] = pydantic.Field(None, description='The name of the local file. Default: Linux - /tmp/bucketKey Windows - %TEMP%/bucketKey\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region of the S3 Bucket (needed for access via VPC Gateway). Default: none\n')
    ...

class UserDataDefAddSignalOnExitCommandParams(pydantic.BaseModel):
    resource: models.ResourceDef = pydantic.Field(..., description='-')
    ...

class UserDataDefCustomParams(pydantic.BaseModel):
    content: str = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.UserDataDefConfig]] = pydantic.Field(None)
    ...

class UserDataDefForLinuxParams(pydantic.BaseModel):
    shebang: typing.Optional[str] = pydantic.Field(None, description='Shebang for the UserData script. Default: "#!/bin/bash"')
    return_config: typing.Optional[list[models.aws_ec2.UserDataDefConfig]] = pydantic.Field(None)
    ...

class UserDataDefForOperatingSystemParams(pydantic.BaseModel):
    os: aws_cdk.aws_ec2.OperatingSystemType = pydantic.Field(..., description='-')
    return_config: typing.Optional[list[models.aws_ec2.UserDataDefConfig]] = pydantic.Field(None)
    ...

class UserDataDefForWindowsParams(pydantic.BaseModel):
    persist: typing.Optional[bool] = pydantic.Field(None, description='Set to true to set this userdata to persist through an instance reboot; allowing it to run on every instance start. By default, UserData is run only once during the first instance launch. For more information, see: https://aws.amazon.com/premiumsupport/knowledge-center/execute-user-data-ec2/ https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html#user-data-scripts Default: false')
    return_config: typing.Optional[list[models.aws_ec2.UserDataDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_ec2.VpcEndpoint
class VpcEndpointDef(BaseClass):
    account: typing.Optional[str] = pydantic.Field(None, description='The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to\n')
    environment_from_arn: typing.Optional[str] = pydantic.Field(None, description='ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.\n')
    physical_name: typing.Optional[str] = pydantic.Field(None, description='The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to')
    _init_params: typing.ClassVar[list[str]] = ['account', 'environment_from_arn', 'physical_name', 'region']
    _method_names: typing.ClassVar[list[str]] = ['add_to_policy', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.VpcEndpoint'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[VpcEndpointDefConfig] = pydantic.Field(None)


class VpcEndpointDefConfig(pydantic.BaseModel):
    add_to_policy: typing.Optional[list[VpcEndpointDefAddToPolicyParams]] = pydantic.Field(None, description='Adds a statement to the policy document of the VPC endpoint. The statement must have a Principal.\nNot all interface VPC endpoints support policy. For more information\nsee https://docs.aws.amazon.com/vpc/latest/userguide/vpce-interface.html')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class VpcEndpointDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='the IAM statement to add.')
    ...

class VpcEndpointDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.VpnConnectionBase
class VpnConnectionBaseDef(BaseClass):
    account: typing.Optional[str] = pydantic.Field(None, description='The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to\n')
    environment_from_arn: typing.Optional[str] = pydantic.Field(None, description='ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.\n')
    physical_name: typing.Optional[str] = pydantic.Field(None, description='The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to')
    _init_params: typing.ClassVar[list[str]] = ['account', 'environment_from_arn', 'physical_name', 'region']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'metric', 'metric_tunnel_data_in', 'metric_tunnel_data_out', 'metric_tunnel_state']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.VpnConnectionBase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[VpnConnectionBaseDefConfig] = pydantic.Field(None)


class VpnConnectionBaseDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    metric: typing.Optional[list[VpnConnectionBaseDefMetricParams]] = pydantic.Field(None, description='Return the given named metric for this VPNConnection.')
    metric_tunnel_data_in: typing.Optional[list[VpnConnectionBaseDefMetricTunnelDataInParams]] = pydantic.Field(None, description='The bytes received through the VPN tunnel.\nSum over 5 minutes')
    metric_tunnel_data_out: typing.Optional[list[VpnConnectionBaseDefMetricTunnelDataOutParams]] = pydantic.Field(None, description='The bytes sent through the VPN tunnel.\nSum over 5 minutes')
    metric_tunnel_state: typing.Optional[list[VpnConnectionBaseDefMetricTunnelStateParams]] = pydantic.Field(None, description='The state of the tunnel. 0 indicates DOWN and 1 indicates UP.\nAverage over 5 minutes')

class VpnConnectionBaseDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class VpnConnectionBaseDefMetricParams(pydantic.BaseModel):
    metric_name: str = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class VpnConnectionBaseDefMetricTunnelDataInParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class VpnConnectionBaseDefMetricTunnelDataOutParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class VpnConnectionBaseDefMetricTunnelStateParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_ec2.WindowsImage
class WindowsImageDef(BaseClass):
    version: aws_cdk.aws_ec2.WindowsVersion = pydantic.Field(..., description='-')
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Windows machines')
    _init_params: typing.ClassVar[list[str]] = ['version', 'user_data']
    _method_names: typing.ClassVar[list[str]] = ['get_image']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.WindowsImage'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[WindowsImageDefConfig] = pydantic.Field(None)


class WindowsImageDefConfig(pydantic.BaseModel):
    get_image: typing.Optional[list[WindowsImageDefGetImageParams]] = pydantic.Field(None, description='Return the image to use in the given context.')

class WindowsImageDefGetImageParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.BastionHostLinux
class BastionHostLinuxDef(BaseConstruct):
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='VPC to launch the instance in.\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='In which AZ to place the instance within the VPC. Default: - Random zone.\n')
    block_devices: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.BlockDeviceDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Specifies how block devices are exposed to the instance. You can specify virtual devices and EBS volumes. Each instance that is launched has an associated root device volume, either an Amazon EBS volume or an instance store volume. You can use block device mappings to specify additional EBS volumes or instance store volumes to attach to an instance when it is launched. Default: - Uses the block device mapping of the AMI\n')
    init: typing.Optional[models.aws_ec2.CloudFormationInitDef] = pydantic.Field(None, description='Apply the given CloudFormation Init configuration to the instance at startup. Default: - no CloudFormation init\n')
    init_options: typing.Union[models.aws_ec2.ApplyCloudFormationInitOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Use the given options for applying CloudFormation Init. Describes the configsets to use and the timeout to wait Default: - default options\n')
    instance_name: typing.Optional[str] = pydantic.Field(None, description="The name of the instance. Default: 'BastionHost'\n")
    instance_type: typing.Optional[models.aws_ec2.InstanceTypeDef] = pydantic.Field(None, description="Type of instance to launch. Default: 't3.nano'\n")
    machine_image: typing.Optional[typing.Union[models.aws_ec2.AmazonLinux2022ImageSsmParameterDef, models.aws_ec2.AmazonLinux2023ImageSsmParameterDef, models.aws_ec2.AmazonLinux2ImageSsmParameterDef, models.aws_ec2.AmazonLinuxImageDef, models.aws_ec2.AmazonLinuxImageSsmParameterBaseDef, models.aws_ec2.GenericLinuxImageDef, models.aws_ec2.GenericSSMParameterImageDef, models.aws_ec2.GenericWindowsImageDef, models.aws_ec2.LookupMachineImageDef, models.aws_ec2.NatInstanceImageDef, models.aws_ec2.WindowsImageDef, models.aws_ecs.BottleRocketImageDef, models.aws_ecs.EcsOptimizedImageDef, models.aws_eks.EksOptimizedImageDef]] = pydantic.Field(None, description='The machine image to use, assumed to have SSM Agent preinstalled. Default: - An Amazon Linux 2 image which is kept up-to-date automatically (the instance may be replaced on every deployment) and already has SSM Agent installed.\n')
    require_imdsv2: typing.Optional[bool] = pydantic.Field(None, description='Whether IMDSv2 should be required on this instance. Default: - false\n')
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='Security Group to assign to this instance. Default: - create new security group with no inbound and all outbound traffic allowed\n')
    subnet_selection: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Select the subnets to run the bastion host in. Set this to PUBLIC if you need to connect to this instance via the internet and cannot use SSM. You have to allow port 22 manually by using the connections field Default: - private subnets of the supplied VPC')
    _init_params: typing.ClassVar[list[str]] = ['vpc', 'availability_zone', 'block_devices', 'init', 'init_options', 'instance_name', 'instance_type', 'machine_image', 'require_imdsv2', 'security_group', 'subnet_selection']
    _method_names: typing.ClassVar[list[str]] = ['allow_ssh_access_from', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.BastionHostLinux'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[BastionHostLinuxDefConfig] = pydantic.Field(None)


class BastionHostLinuxDefConfig(pydantic.BaseModel):
    allow_ssh_access_from: typing.Optional[list[BastionHostLinuxDefAllowSshAccessFromParams]] = pydantic.Field(None, description='Allow SSH access from the given peer or peers.\nNecessary if you want to connect to the instance using ssh. If not\ncalled, you should use SSM Session Manager to connect to the instance.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)
    instance_config: typing.Optional[models.aws_ec2.InstanceDefConfig] = pydantic.Field(None)
    role_config: typing.Optional[models._interface_methods.AwsIamIRoleDefConfig] = pydantic.Field(None)
    stack_config: typing.Optional[models.core.StackDefConfig] = pydantic.Field(None)

class BastionHostLinuxDefAllowSshAccessFromParams(pydantic.BaseModel):
    peer: list[models.UnsupportedResource] = pydantic.Field(...)
    ...

class BastionHostLinuxDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.ClientVpnAuthorizationRule
class ClientVpnAuthorizationRuleDef(BaseConstruct):
    client_vpn_endpoint: typing.Optional[typing.Union[models.aws_ec2.ClientVpnEndpointDef]] = pydantic.Field(None, description='The client VPN endpoint to which to add the rule. Default: clientVpnEndpoint is required\n')
    cidr: str = pydantic.Field(..., description='The IPv4 address range, in CIDR notation, of the network for which access is being authorized.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A brief description of the authorization rule. Default: - no description\n')
    group_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group. Default: - authorize all groups')
    _init_params: typing.ClassVar[list[str]] = ['client_vpn_endpoint', 'cidr', 'description', 'group_id']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.ClientVpnAuthorizationRule'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ClientVpnAuthorizationRuleDefConfig] = pydantic.Field(None)


class ClientVpnAuthorizationRuleDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class ClientVpnAuthorizationRuleDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.ClientVpnEndpoint
class ClientVpnEndpointDef(BaseConstruct):
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='The VPC to connect to.\n')
    cidr: str = pydantic.Field(..., description='The IPv4 address range, in CIDR notation, from which to assign client IP addresses. The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. Changing the address range will replace the Client VPN endpoint. The CIDR block should be /22 or greater.\n')
    server_certificate_arn: str = pydantic.Field(..., description='The ARN of the server certificate.\n')
    authorize_all_users_to_vpc_cidr: typing.Optional[bool] = pydantic.Field(None, description='Whether to authorize all users to the VPC CIDR. This automatically creates an authorization rule. Set this to ``false`` and use ``addAuthorizationRule()`` to create your own rules instead. Default: true\n')
    client_certificate_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the client certificate for mutual authentication. The certificate must be signed by a certificate authority (CA) and it must be provisioned in AWS Certificate Manager (ACM). Default: - use user-based authentication\n')
    client_connection_handler: typing.Optional[typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef]] = pydantic.Field(None, description='The AWS Lambda function used for connection authorization. The name of the Lambda function must begin with the ``AWSClientVPN-`` prefix Default: - no connection handler\n')
    client_login_banner: typing.Optional[str] = pydantic.Field(None, description='Customizable text that will be displayed in a banner on AWS provided clients when a VPN session is established. UTF-8 encoded characters only. Maximum of 1400 characters. Default: - no banner is presented to the client\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A brief description of the Client VPN endpoint. Default: - no description\n')
    dns_servers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Information about the DNS servers to be used for DNS resolution. A Client VPN endpoint can have up to two DNS servers. Default: - use the DNS address configured on the device\n')
    logging: typing.Optional[bool] = pydantic.Field(None, description='Whether to enable connections logging. Default: true\n')
    log_group: typing.Optional[typing.Union[models.aws_logs.LogGroupDef]] = pydantic.Field(None, description='A CloudWatch Logs log group for connection logging. Default: - a new group is created\n')
    log_stream: typing.Optional[typing.Union[models.aws_logs.LogStreamDef]] = pydantic.Field(None, description='A CloudWatch Logs log stream for connection logging. Default: - a new stream is created\n')
    port: typing.Optional[aws_cdk.aws_ec2.VpnPort] = pydantic.Field(None, description='The port number to assign to the Client VPN endpoint for TCP and UDP traffic. Default: VpnPort.HTTPS\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='The security groups to apply to the target network. Default: - a new security group is created\n')
    self_service_portal: typing.Optional[bool] = pydantic.Field(None, description='Specify whether to enable the self-service portal for the Client VPN endpoint. Default: true\n')
    session_timeout: typing.Optional[aws_cdk.aws_ec2.ClientVpnSessionTimeout] = pydantic.Field(None, description='The maximum VPN session duration time. Default: ClientVpnSessionTimeout.TWENTY_FOUR_HOURS\n')
    split_tunnel: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint. Default: false\n')
    transport_protocol: typing.Optional[aws_cdk.aws_ec2.TransportProtocol] = pydantic.Field(None, description='The transport protocol to be used by the VPN session. Default: TransportProtocol.UDP\n')
    user_based_authentication: typing.Optional[models.aws_ec2.ClientVpnUserBasedAuthenticationDef] = pydantic.Field(None, description='The type of user-based authentication to use. Default: - use mutual authentication\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Subnets to associate to the client VPN endpoint. Default: - the VPC default strategy')
    _init_params: typing.ClassVar[list[str]] = ['vpc', 'cidr', 'server_certificate_arn', 'authorize_all_users_to_vpc_cidr', 'client_certificate_arn', 'client_connection_handler', 'client_login_banner', 'description', 'dns_servers', 'logging', 'log_group', 'log_stream', 'port', 'security_groups', 'self_service_portal', 'session_timeout', 'split_tunnel', 'transport_protocol', 'user_based_authentication', 'vpc_subnets']
    _method_names: typing.ClassVar[list[str]] = ['add_authorization_rule', 'add_route', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_endpoint_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.ClientVpnEndpoint'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_endpoint_attributes']
    ...


    from_endpoint_attributes: typing.Optional[ClientVpnEndpointDefFromEndpointAttributesParams] = pydantic.Field(None, description='Import an existing client VPN endpoint.')
    resource_config: typing.Optional[ClientVpnEndpointDefConfig] = pydantic.Field(None)


class ClientVpnEndpointDefConfig(pydantic.BaseModel):
    add_authorization_rule: typing.Optional[list[ClientVpnEndpointDefAddAuthorizationRuleParams]] = pydantic.Field(None, description='Adds an authorization rule to this endpoint.')
    add_route: typing.Optional[list[ClientVpnEndpointDefAddRouteParams]] = pydantic.Field(None, description='Adds a route to this endpoint.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    connections_config: typing.Optional[models.aws_ec2.ConnectionsDefConfig] = pydantic.Field(None)

class ClientVpnEndpointDefAddAuthorizationRuleParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    cidr: str = pydantic.Field(..., description='The IPv4 address range, in CIDR notation, of the network for which access is being authorized.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A brief description of the authorization rule. Default: - no description\n')
    group_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group. Default: - authorize all groups')
    return_config: typing.Optional[list[models.aws_ec2.ClientVpnAuthorizationRuleDefConfig]] = pydantic.Field(None)
    ...

class ClientVpnEndpointDefAddRouteParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    cidr: str = pydantic.Field(..., description="The IPv4 address range, in CIDR notation, of the route destination. For example: - To add a route for Internet access, enter 0.0.0.0/0 - To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range - To add a route for an on-premises network, enter the AWS Site-to-Site VPN connection's IPv4 CIDR range - To add a route for the local network, enter the client CIDR range\n")
    target: models.aws_ec2.ClientVpnRouteTargetDef = pydantic.Field(..., description='The target for the route.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A brief description of the authorization rule. Default: - no description')
    return_config: typing.Optional[list[models.aws_ec2.ClientVpnRouteDefConfig]] = pydantic.Field(None)
    ...

class ClientVpnEndpointDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class ClientVpnEndpointDefFromEndpointAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    endpoint_id: str = pydantic.Field(..., description='The endpoint ID.\n')
    security_groups: typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(..., description='The security groups associated with the endpoint.')
    ...


#  autogenerated from aws_cdk.aws_ec2.ClientVpnRoute
class ClientVpnRouteDef(BaseConstruct):
    client_vpn_endpoint: typing.Optional[typing.Union[models.aws_ec2.ClientVpnEndpointDef]] = pydantic.Field(None, description='The client VPN endpoint to which to add the route. Default: clientVpnEndpoint is required\n')
    cidr: str = pydantic.Field(..., description="The IPv4 address range, in CIDR notation, of the route destination. For example: - To add a route for Internet access, enter 0.0.0.0/0 - To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range - To add a route for an on-premises network, enter the AWS Site-to-Site VPN connection's IPv4 CIDR range - To add a route for the local network, enter the client CIDR range\n")
    target: models.aws_ec2.ClientVpnRouteTargetDef = pydantic.Field(..., description='The target for the route.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A brief description of the authorization rule. Default: - no description')
    _init_params: typing.ClassVar[list[str]] = ['client_vpn_endpoint', 'cidr', 'target', 'description']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.ClientVpnRoute'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[ClientVpnRouteDefConfig] = pydantic.Field(None)


class ClientVpnRouteDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class ClientVpnRouteDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.FlowLog
class FlowLogDef(BaseConstruct):
    resource_type: models.aws_ec2.FlowLogResourceTypeDef = pydantic.Field(..., description='The type of resource for which to create the flow log.\n')
    flow_log_name: typing.Optional[str] = pydantic.Field(None, description="The name of the FlowLog. It is not recommended to use an explicit name. Default: If you don't specify a flowLogName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.\n")
    destination: typing.Optional[models.aws_ec2.FlowLogDestinationDef] = pydantic.Field(None, description='Specifies the type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3 Default: FlowLogDestinationType.toCloudWatchLogs()\n')
    log_format: typing.Optional[typing.Sequence[models.aws_ec2.LogFormatDef]] = pydantic.Field(None, description='The fields to include in the flow log record, in the order in which they should appear. If multiple fields are specified, they will be separated by spaces. For full control over the literal log format string, pass a single field constructed with ``LogFormat.custom()``. See https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-log-records Default: - default log format is used.\n')
    max_aggregation_interval: typing.Optional[aws_cdk.aws_ec2.FlowLogMaxAggregationInterval] = pydantic.Field(None, description='The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record. Default: FlowLogMaxAggregationInterval.TEN_MINUTES\n')
    traffic_type: typing.Optional[aws_cdk.aws_ec2.FlowLogTrafficType] = pydantic.Field(None, description='The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic. Default: ALL')
    _init_params: typing.ClassVar[list[str]] = ['resource_type', 'flow_log_name', 'destination', 'log_format', 'max_aggregation_interval', 'traffic_type']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_flow_log_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.FlowLog'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_flow_log_id']
    ...


    from_flow_log_id: typing.Optional[FlowLogDefFromFlowLogIdParams] = pydantic.Field(None, description="Import a Flow Log by it's Id.")
    resource_config: typing.Optional[FlowLogDefConfig] = pydantic.Field(None)


class FlowLogDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class FlowLogDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class FlowLogDefFromFlowLogIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    flow_log_id: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.GatewayVpcEndpoint
class GatewayVpcEndpointDef(BaseConstruct):
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='The VPC network in which the gateway endpoint will be used.\n')
    service: typing.Union[models.aws_ec2.GatewayVpcEndpointAwsServiceDef] = pydantic.Field(..., description='The service to use for this gateway VPC endpoint.\n')
    subnets: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Where to add endpoint routing. By default, this endpoint will be routable from all subnets in the VPC. Specify a list of subnet selection objects here to be more specific. Default: - All subnets in the VPC')
    _init_params: typing.ClassVar[list[str]] = ['vpc', 'service', 'subnets']
    _method_names: typing.ClassVar[list[str]] = ['add_to_policy', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_gateway_vpc_endpoint_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.GatewayVpcEndpoint'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_gateway_vpc_endpoint_id']
    ...


    from_gateway_vpc_endpoint_id: typing.Optional[GatewayVpcEndpointDefFromGatewayVpcEndpointIdParams] = pydantic.Field(None, description='')
    resource_config: typing.Optional[GatewayVpcEndpointDefConfig] = pydantic.Field(None)


class GatewayVpcEndpointDefConfig(pydantic.BaseModel):
    add_to_policy: typing.Optional[list[GatewayVpcEndpointDefAddToPolicyParams]] = pydantic.Field(None, description='Adds a statement to the policy document of the VPC endpoint. The statement must have a Principal.\nNot all interface VPC endpoints support policy. For more information\nsee https://docs.aws.amazon.com/vpc/latest/userguide/vpce-interface.html')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class GatewayVpcEndpointDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='the IAM statement to add.')
    ...

class GatewayVpcEndpointDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class GatewayVpcEndpointDefFromGatewayVpcEndpointIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    id: str = pydantic.Field(..., description='-\n')
    gateway_vpc_endpoint_id: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.Instance
class InstanceDef(BaseConstruct):
    instance_type: models.aws_ec2.InstanceTypeDef = pydantic.Field(..., description='Type of instance to launch.\n')
    machine_image: typing.Union[models.aws_ec2.AmazonLinux2022ImageSsmParameterDef, models.aws_ec2.AmazonLinux2023ImageSsmParameterDef, models.aws_ec2.AmazonLinux2ImageSsmParameterDef, models.aws_ec2.AmazonLinuxImageDef, models.aws_ec2.AmazonLinuxImageSsmParameterBaseDef, models.aws_ec2.GenericLinuxImageDef, models.aws_ec2.GenericSSMParameterImageDef, models.aws_ec2.GenericWindowsImageDef, models.aws_ec2.LookupMachineImageDef, models.aws_ec2.NatInstanceImageDef, models.aws_ec2.WindowsImageDef, models.aws_ecs.BottleRocketImageDef, models.aws_ecs.EcsOptimizedImageDef, models.aws_eks.EksOptimizedImageDef] = pydantic.Field(..., description='AMI to launch.\n')
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='VPC to launch the instance in.\n')
    allow_all_outbound: typing.Optional[bool] = pydantic.Field(None, description='Whether the instance could initiate connections to anywhere by default. This property is only used when you do not provide a security group. Default: true\n')
    associate_public_ip_address: typing.Optional[bool] = pydantic.Field(None, description='Whether to associate a public IP address to the primary network interface attached to this instance. Default: - public IP address is automatically assigned based on default behavior\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='In which AZ to place the instance within the VPC. Default: - Random zone.\n')
    block_devices: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.BlockDeviceDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Specifies how block devices are exposed to the instance. You can specify virtual devices and EBS volumes. Each instance that is launched has an associated root device volume, either an Amazon EBS volume or an instance store volume. You can use block device mappings to specify additional EBS volumes or instance store volumes to attach to an instance when it is launched. Default: - Uses the block device mapping of the AMI\n')
    detailed_monitoring: typing.Optional[bool] = pydantic.Field(None, description='Whether "Detailed Monitoring" is enabled for this instance Keep in mind that Detailed Monitoring results in extra charges. Default: - false\n')
    init: typing.Optional[models.aws_ec2.CloudFormationInitDef] = pydantic.Field(None, description='Apply the given CloudFormation Init configuration to the instance at startup. Default: - no CloudFormation init\n')
    init_options: typing.Union[models.aws_ec2.ApplyCloudFormationInitOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Use the given options for applying CloudFormation Init. Describes the configsets to use and the timeout to wait Default: - default options\n')
    instance_name: typing.Optional[str] = pydantic.Field(None, description='The name of the instance. Default: - CDK generated name\n')
    key_name: typing.Optional[str] = pydantic.Field(None, description='Name of SSH keypair to grant access to instance. Default: - No SSH access will be possible.\n')
    private_ip_address: typing.Optional[str] = pydantic.Field(None, description='Defines a private IP address to associate with an instance. Private IP should be available within the VPC that the instance is build within. Default: - no association\n')
    propagate_tags_to_volume_on_creation: typing.Optional[bool] = pydantic.Field(None, description='Propagate the EC2 instance tags to the EBS volumes. Default: - false\n')
    require_imdsv2: typing.Optional[bool] = pydantic.Field(None, description='Whether IMDSv2 should be required on this instance. Default: - false\n')
    resource_signal_timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The length of time to wait for the resourceSignalCount. The maximum value is 43200 (12 hours). Default: Duration.minutes(5)\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role to associate with the instance profile assigned to this Auto Scaling Group. The role must be assumable by the service principal ``ec2.amazonaws.com``: Default: - A role will automatically be created, it can be accessed via the ``role`` property\n')
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='Security Group to assign to this instance. Default: - create new security group\n')
    source_dest_check: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable an instance launched in a VPC to perform NAT. This controls whether source/destination checking is enabled on the instance. A value of true means that checking is enabled, and false means that checking is disabled. The value must be false for the instance to perform NAT. Default: true\n')
    ssm_session_permissions: typing.Optional[bool] = pydantic.Field(None, description='Add SSM session permissions to the instance role. Setting this to ``true`` adds the necessary permissions to connect to the instance using SSM Session Manager. You can do this from the AWS Console. NOTE: Setting this flag to ``true`` may not be enough by itself. You must also use an AMI that comes with the SSM Agent, or install the SSM Agent yourself. See `Working with SSM Agent <https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-agent.html>`_ in the SSM Developer Guide. Default: false\n')
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description="Specific UserData to use. The UserData may still be mutated after creation. Default: - A UserData object appropriate for the MachineImage's Operating System is created.\n")
    user_data_causes_replacement: typing.Optional[bool] = pydantic.Field(None, description="Changes to the UserData force replacement. Depending the EC2 instance type, changing UserData either restarts the instance or replaces the instance. - Instance store-backed instances are replaced. - EBS-backed instances are restarted. By default, restarting does not execute the new UserData so you will need a different mechanism to ensure the instance is restarted. Setting this to ``true`` will make the instance's Logical ID depend on the UserData, which will cause CloudFormation to replace it if the UserData changes. Default: - true iff ``initOptions`` is specified, false otherwise.\n")
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Where to place the instance within the VPC. Default: - Private subnets.')
    _init_params: typing.ClassVar[list[str]] = ['instance_type', 'machine_image', 'vpc', 'allow_all_outbound', 'associate_public_ip_address', 'availability_zone', 'block_devices', 'detailed_monitoring', 'init', 'init_options', 'instance_name', 'key_name', 'private_ip_address', 'propagate_tags_to_volume_on_creation', 'require_imdsv2', 'resource_signal_timeout', 'role', 'security_group', 'source_dest_check', 'ssm_session_permissions', 'user_data', 'user_data_causes_replacement', 'vpc_subnets']
    _method_names: typing.ClassVar[list[str]] = ['add_security_group', 'add_to_role_policy', 'add_user_data', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.Instance'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[InstanceDefConfig] = pydantic.Field(None)


class InstanceDefConfig(pydantic.BaseModel):
    add_security_group: typing.Optional[list[InstanceDefAddSecurityGroupParams]] = pydantic.Field(None, description='Add the security group to the instance.')
    add_to_role_policy: typing.Optional[list[InstanceDefAddToRolePolicyParams]] = pydantic.Field(None, description='Adds a statement to the IAM role assumed by the instance.')
    add_user_data: typing.Optional[list[InstanceDefAddUserDataParams]] = pydantic.Field(None, description="Add command to the startup script of the instance.\nThe command must be in the scripting language supported by the instance's OS (i.e. Linux/Windows).")
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)
    instance_config: typing.Optional[models.aws_ec2.CfnInstanceDefConfig] = pydantic.Field(None)
    role_config: typing.Optional[models._interface_methods.AwsIamIRoleDefConfig] = pydantic.Field(None)

class InstanceDefAddSecurityGroupParams(pydantic.BaseModel):
    security_group: typing.Union[models.aws_ec2.SecurityGroupDef] = pydantic.Field(..., description=': The security group to add.')
    ...

class InstanceDefAddToRolePolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='-')
    ...

class InstanceDefAddUserDataParams(pydantic.BaseModel):
    commands: list[str] = pydantic.Field(...)
    ...

class InstanceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.InterfaceVpcEndpoint
class InterfaceVpcEndpointDef(BaseConstruct):
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='The VPC network in which the interface endpoint will be used.\n')
    service: typing.Union[models.aws_ec2.InterfaceVpcEndpointAwsServiceDef, models.aws_ec2.InterfaceVpcEndpointServiceDef] = pydantic.Field(..., description='The service to use for this interface VPC endpoint.\n')
    lookup_supported_azs: typing.Optional[bool] = pydantic.Field(None, description="Limit to only those availability zones where the endpoint service can be created. Setting this to 'true' requires a lookup to be performed at synthesis time. Account and region must be set on the containing stack for this to work. Default: false\n")
    open: typing.Optional[bool] = pydantic.Field(None, description="Whether to automatically allow VPC traffic to the endpoint. If enabled, all traffic to the endpoint from within the VPC will be automatically allowed. This is done based on the VPC's CIDR range. Default: true\n")
    private_dns_enabled: typing.Optional[bool] = pydantic.Field(None, description='Whether to associate a private hosted zone with the specified VPC. This allows you to make requests to the service using its default DNS hostname. Default: set by the instance of IInterfaceVpcEndpointService, or true if not defined by the instance of IInterfaceVpcEndpointService\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='The security groups to associate with this interface VPC endpoint. Default: - a new security group is created\n')
    subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The subnets in which to create an endpoint network interface. At most one per availability zone. Default: - private subnets')
    _init_params: typing.ClassVar[list[str]] = ['vpc', 'service', 'lookup_supported_azs', 'open', 'private_dns_enabled', 'security_groups', 'subnets']
    _method_names: typing.ClassVar[list[str]] = ['add_to_policy', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_interface_vpc_endpoint_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InterfaceVpcEndpoint'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_interface_vpc_endpoint_attributes']
    ...


    from_interface_vpc_endpoint_attributes: typing.Optional[InterfaceVpcEndpointDefFromInterfaceVpcEndpointAttributesParams] = pydantic.Field(None, description='Imports an existing interface VPC endpoint.')
    resource_config: typing.Optional[InterfaceVpcEndpointDefConfig] = pydantic.Field(None)


class InterfaceVpcEndpointDefConfig(pydantic.BaseModel):
    add_to_policy: typing.Optional[list[InterfaceVpcEndpointDefAddToPolicyParams]] = pydantic.Field(None, description='Adds a statement to the policy document of the VPC endpoint. The statement must have a Principal.\nNot all interface VPC endpoints support policy. For more information\nsee https://docs.aws.amazon.com/vpc/latest/userguide/vpce-interface.html')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    connections_config: typing.Optional[models.aws_ec2.ConnectionsDefConfig] = pydantic.Field(None)

class InterfaceVpcEndpointDefAddToPolicyParams(pydantic.BaseModel):
    statement: models.aws_iam.PolicyStatementDef = pydantic.Field(..., description='the IAM statement to add.')
    ...

class InterfaceVpcEndpointDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class InterfaceVpcEndpointDefFromInterfaceVpcEndpointAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    port: typing.Union[int, float] = pydantic.Field(..., description='The port of the service of the interface VPC endpoint.\n')
    vpc_endpoint_id: str = pydantic.Field(..., description='The interface VPC endpoint identifier.\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='The security groups associated with the interface VPC endpoint. If you wish to manage the network connections associated with this endpoint, you will need to specify its security groups.')
    ...


#  autogenerated from aws_cdk.aws_ec2.LaunchTemplate
class LaunchTemplateDef(BaseConstruct, ConnectableMixin):
    block_devices: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.BlockDeviceDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Specifies how block devices are exposed to the instance. You can specify virtual devices and EBS volumes. Each instance that is launched has an associated root device volume, either an Amazon EBS volume or an instance store volume. You can use block device mappings to specify additional EBS volumes or instance store volumes to attach to an instance when it is launched. Default: - Uses the block device mapping of the AMI\n')
    cpu_credits: typing.Optional[aws_cdk.aws_ec2.CpuCredits] = pydantic.Field(None, description='CPU credit type for burstable EC2 instance types. Default: - No credit type is specified in the Launch Template.\n')
    detailed_monitoring: typing.Optional[bool] = pydantic.Field(None, description='If set to true, then detailed monitoring will be enabled on instances created with this launch template. Default: False - Detailed monitoring is disabled.\n')
    disable_api_termination: typing.Optional[bool] = pydantic.Field(None, description='If you set this parameter to true, you cannot terminate the instances launched with this launch template using the Amazon EC2 console, CLI, or API; otherwise, you can. Default: - The API termination setting is not specified in the Launch Template.\n')
    ebs_optimized: typing.Optional[bool] = pydantic.Field(None, description="Indicates whether the instances are optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance. Default: - EBS optimization is not specified in the launch template.\n")
    hibernation_configured: typing.Optional[bool] = pydantic.Field(None, description='If you set this parameter to true, the instance is enabled for hibernation. Default: - Hibernation configuration is not specified in the launch template; defaulting to false.\n')
    http_endpoint: typing.Optional[bool] = pydantic.Field(None, description='Enables or disables the HTTP metadata endpoint on your instances. Default: true\n')
    http_protocol_ipv6: typing.Optional[bool] = pydantic.Field(None, description='Enables or disables the IPv6 endpoint for the instance metadata service. Default: true\n')
    http_put_response_hop_limit: typing.Union[int, float, None] = pydantic.Field(None, description='The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Default: 1\n')
    http_tokens: typing.Optional[aws_cdk.aws_ec2.LaunchTemplateHttpTokens] = pydantic.Field(None, description='The state of token usage for your instance metadata requests. The default state is ``optional`` if not specified. However, if requireImdsv2 is true, the state must be ``required``. Default: LaunchTemplateHttpTokens.OPTIONAL\n')
    instance_initiated_shutdown_behavior: typing.Optional[aws_cdk.aws_ec2.InstanceInitiatedShutdownBehavior] = pydantic.Field(None, description='Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown). Default: - Shutdown behavior is not specified in the launch template; defaults to STOP.\n')
    instance_metadata_tags: typing.Optional[bool] = pydantic.Field(None, description='Set to enabled to allow access to instance tags from the instance metadata. Set to disabled to turn off access to instance tags from the instance metadata. Default: false\n')
    instance_type: typing.Optional[models.aws_ec2.InstanceTypeDef] = pydantic.Field(None, description='Type of instance to launch. Default: - This Launch Template does not specify a default Instance Type.\n')
    key_name: typing.Optional[str] = pydantic.Field(None, description='Name of SSH keypair to grant access to instance. Default: - No SSH access will be possible.\n')
    launch_template_name: typing.Optional[str] = pydantic.Field(None, description='Name for this launch template. Default: Automatically generated name\n')
    machine_image: typing.Optional[typing.Union[models.aws_ec2.AmazonLinux2022ImageSsmParameterDef, models.aws_ec2.AmazonLinux2023ImageSsmParameterDef, models.aws_ec2.AmazonLinux2ImageSsmParameterDef, models.aws_ec2.AmazonLinuxImageDef, models.aws_ec2.AmazonLinuxImageSsmParameterBaseDef, models.aws_ec2.GenericLinuxImageDef, models.aws_ec2.GenericSSMParameterImageDef, models.aws_ec2.GenericWindowsImageDef, models.aws_ec2.LookupMachineImageDef, models.aws_ec2.NatInstanceImageDef, models.aws_ec2.WindowsImageDef, models.aws_ecs.BottleRocketImageDef, models.aws_ecs.EcsOptimizedImageDef, models.aws_eks.EksOptimizedImageDef]] = pydantic.Field(None, description='The AMI that will be used by instances. Default: - This Launch Template does not specify a default AMI.\n')
    nitro_enclave_enabled: typing.Optional[bool] = pydantic.Field(None, description='If this parameter is set to true, the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves. Default: - Enablement of Nitro enclaves is not specified in the launch template; defaulting to false.\n')
    require_imdsv2: typing.Optional[bool] = pydantic.Field(None, description='Whether IMDSv2 should be required on launched instances. Default: - false\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role to associate with the instance profile that is used by instances. The role must be assumable by the service principal ``ec2.amazonaws.com``: Default: - No new role is created.\n')
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='Security group to assign to instances created with the launch template. Default: No security group is assigned.\n')
    spot_options: typing.Union[models.aws_ec2.LaunchTemplateSpotOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description="If this property is defined, then the Launch Template's InstanceMarketOptions will be set to use Spot instances, and the options for the Spot instances will be as defined. Default: - Instance launched with this template will not be spot instances.\n")
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='The AMI that will be used by instances. Default: - This Launch Template creates a UserData based on the type of provided machineImage; no UserData is created if a machineImage is not provided')
    _init_params: typing.ClassVar[list[str]] = ['block_devices', 'cpu_credits', 'detailed_monitoring', 'disable_api_termination', 'ebs_optimized', 'hibernation_configured', 'http_endpoint', 'http_protocol_ipv6', 'http_put_response_hop_limit', 'http_tokens', 'instance_initiated_shutdown_behavior', 'instance_metadata_tags', 'instance_type', 'key_name', 'launch_template_name', 'machine_image', 'nitro_enclave_enabled', 'require_imdsv2', 'role', 'security_group', 'spot_options', 'user_data']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_launch_template_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.LaunchTemplate'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_launch_template_attributes']
    ...


    from_launch_template_attributes: typing.Optional[LaunchTemplateDefFromLaunchTemplateAttributesParams] = pydantic.Field(None, description='Import an existing LaunchTemplate.')
    resource_config: typing.Optional[LaunchTemplateDefConfig] = pydantic.Field(None)


class LaunchTemplateDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    grant_principal_config: typing.Optional[models._interface_methods.AwsIamIPrincipalDefConfig] = pydantic.Field(None)

class LaunchTemplateDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class LaunchTemplateDefFromLaunchTemplateAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    launch_template_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the Launch Template. Exactly one of ``launchTemplateId`` and ``launchTemplateName`` may be set. Default: None\n')
    launch_template_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Launch Template. Exactly one of ``launchTemplateId`` and ``launchTemplateName`` may be set. Default: None\n')
    version_number: typing.Optional[str] = pydantic.Field(None, description='The version number of this launch template to use. Default: Version: "$Default"')
    ...


#  autogenerated from aws_cdk.aws_ec2.NetworkAcl
class NetworkAclDef(BaseConstruct):
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='The VPC in which to create the NetworkACL.\n')
    network_acl_name: typing.Optional[str] = pydantic.Field(None, description="The name of the NetworkAcl. It is not recommended to use an explicit name. Default: If you don't specify a networkAclName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.\n")
    subnet_selection: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Subnets in the given VPC to associate the ACL with. More subnets can always be added later by calling ``associateWithSubnets()``. Default: - No subnets associated')
    _init_params: typing.ClassVar[list[str]] = ['vpc', 'network_acl_name', 'subnet_selection']
    _method_names: typing.ClassVar[list[str]] = ['add_entry', 'apply_removal_policy', 'associate_with_subnet']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_network_acl_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.NetworkAcl'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_network_acl_id']
    ...


    from_network_acl_id: typing.Optional[NetworkAclDefFromNetworkAclIdParams] = pydantic.Field(None, description='Import an existing NetworkAcl into this app.')
    resource_config: typing.Optional[NetworkAclDefConfig] = pydantic.Field(None)


class NetworkAclDefConfig(pydantic.BaseModel):
    add_entry: typing.Optional[list[NetworkAclDefAddEntryParams]] = pydantic.Field(None, description='Add a new entry to the ACL.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    associate_with_subnet: typing.Optional[list[NetworkAclDefAssociateWithSubnetParams]] = pydantic.Field(None, description='Associate the ACL with a given set of subnets.')

class NetworkAclDefAddEntryParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    cidr: models.aws_ec2.AclCidrDef = pydantic.Field(..., description='The CIDR range to allow or deny.\n')
    rule_number: typing.Union[int, float] = pydantic.Field(..., description="Rule number to assign to the entry, such as 100. ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.\n")
    traffic: models.aws_ec2.AclTrafficDef = pydantic.Field(..., description='What kind of traffic this ACL rule applies to.\n')
    direction: typing.Optional[aws_cdk.aws_ec2.TrafficDirection] = pydantic.Field(None, description='Traffic direction, with respect to the subnet, this rule applies to. Default: TrafficDirection.INGRESS\n')
    network_acl_entry_name: typing.Optional[str] = pydantic.Field(None, description="The name of the NetworkAclEntry. It is not recommended to use an explicit group name. Default: If you don't specify a NetworkAclName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.\n")
    rule_action: typing.Optional[aws_cdk.aws_ec2.Action] = pydantic.Field(None, description='Whether to allow or deny traffic that matches the rule; valid values are "allow" or "deny". Any traffic that is not explicitly allowed is automatically denied in a custom ACL, all traffic is automatically allowed in a default ACL. Default: ALLOW')
    return_config: typing.Optional[list[models.aws_ec2.NetworkAclEntryDefConfig]] = pydantic.Field(None)
    ...

class NetworkAclDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class NetworkAclDefAssociateWithSubnetParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    availability_zones: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Select subnets only in the given AZs. Default: no filtering on AZs is done\n')
    one_per_az: typing.Optional[bool] = pydantic.Field(None, description='If true, return at most one subnet per AZ. Default: false\n')
    subnet_filters: typing.Optional[typing.Sequence[models.aws_ec2.SubnetFilterDef]] = pydantic.Field(None, description='List of provided subnet filters. Default: - none\n')
    subnet_group_name: typing.Optional[str] = pydantic.Field(None, description='Select the subnet group with the given name. Select the subnet group with the given name. This only needs to be used if you have multiple subnet groups of the same type and you need to distinguish between them. Otherwise, prefer ``subnetType``. This field does not select individual subnets, it selects all subnets that share the given subnet group name. This is the name supplied in ``subnetConfiguration``. At most one of ``subnetType`` and ``subnetGroupName`` can be supplied. Default: - Selection by type instead of by name\n')
    subnets: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.PrivateSubnetDef, models.aws_ec2.PublicSubnetDef, models.aws_ec2.SubnetDef]]] = pydantic.Field(None, description="Explicitly select individual subnets. Use this if you don't want to automatically use all subnets in a group, but have a need to control selection down to individual subnets. Cannot be specified together with ``subnetType`` or ``subnetGroupName``. Default: - Use all subnets in a selected group (all private subnets by default)\n")
    subnet_type: typing.Optional[aws_cdk.aws_ec2.SubnetType] = pydantic.Field(None, description='Select all subnets of the given type. At most one of ``subnetType`` and ``subnetGroupName`` can be supplied. Default: SubnetType.PRIVATE_WITH_EGRESS (or ISOLATED or PUBLIC if there are no PRIVATE_WITH_EGRESS subnets)')
    ...

class NetworkAclDefFromNetworkAclIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    network_acl_id: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.NetworkAclEntry
class NetworkAclEntryDef(BaseConstruct):
    network_acl: typing.Union[models.aws_ec2.NetworkAclDef] = pydantic.Field(..., description='The network ACL this entry applies to.\n')
    cidr: models.aws_ec2.AclCidrDef = pydantic.Field(..., description='The CIDR range to allow or deny.\n')
    rule_number: typing.Union[int, float] = pydantic.Field(..., description="Rule number to assign to the entry, such as 100. ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.\n")
    traffic: models.aws_ec2.AclTrafficDef = pydantic.Field(..., description='What kind of traffic this ACL rule applies to.\n')
    direction: typing.Optional[aws_cdk.aws_ec2.TrafficDirection] = pydantic.Field(None, description='Traffic direction, with respect to the subnet, this rule applies to. Default: TrafficDirection.INGRESS\n')
    network_acl_entry_name: typing.Optional[str] = pydantic.Field(None, description="The name of the NetworkAclEntry. It is not recommended to use an explicit group name. Default: If you don't specify a NetworkAclName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.\n")
    rule_action: typing.Optional[aws_cdk.aws_ec2.Action] = pydantic.Field(None, description='Whether to allow or deny traffic that matches the rule; valid values are "allow" or "deny". Any traffic that is not explicitly allowed is automatically denied in a custom ACL, all traffic is automatically allowed in a default ACL. Default: ALLOW')
    _init_params: typing.ClassVar[list[str]] = ['network_acl', 'cidr', 'rule_number', 'traffic', 'direction', 'network_acl_entry_name', 'rule_action']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.NetworkAclEntry'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[NetworkAclEntryDefConfig] = pydantic.Field(None)


class NetworkAclEntryDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    network_acl_config: typing.Optional[models._interface_methods.AwsEc2INetworkAclDefConfig] = pydantic.Field(None)

class NetworkAclEntryDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.PlacementGroup
class PlacementGroupDef(BaseConstruct):
    partitions: typing.Union[int, float, None] = pydantic.Field(None, description='The number of partitions. Valid only when Strategy is set to partition. Default: 0\n')
    placement_group_name: typing.Optional[str] = pydantic.Field(None, description='the name of this placement group. Default: - generated by CFN\n')
    spread_level: typing.Optional[aws_cdk.aws_ec2.PlacementGroupSpreadLevel] = pydantic.Field(None, description='Places instances on distinct hardware. Spread placement groups are recommended for applications that have a small number of critical instances that should be kept separate from each other. Launching instances in a spread level placement group reduces the risk of simultaneous failures that might occur when instances share the same equipment. Spread level placement groups provide access to distinct hardware, and are therefore suitable for mixing instance types or launching instances over time. If you start or launch an instance in a spread placement group and there is insufficient unique hardware to fulfill the request, the request fails. Amazon EC2 makes more distinct hardware available over time, so you can try your request again later. Placement groups can spread instances across racks or hosts. You can use host level spread placement groups only with AWS Outposts. Default: - no spread level\n')
    strategy: typing.Optional[aws_cdk.aws_ec2.PlacementGroupStrategy] = pydantic.Field(None, description='Which strategy to use when launching instances. Default: - ``PlacementGroupStrategy.PARTITION`` if ``partitions`` is defined, ``CLUSTER`` otherwise')
    _init_params: typing.ClassVar[list[str]] = ['partitions', 'placement_group_name', 'spread_level', 'strategy']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_placement_group_name']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.PlacementGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_placement_group_name']
    ...


    from_placement_group_name: typing.Optional[PlacementGroupDefFromPlacementGroupNameParams] = pydantic.Field(None, description='Import a PlacementGroup by its arn.')
    resource_config: typing.Optional[PlacementGroupDefConfig] = pydantic.Field(None)


class PlacementGroupDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class PlacementGroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class PlacementGroupDefFromPlacementGroupNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    placement_group_name: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.PrefixList
class PrefixListDef(BaseConstruct):
    address_family: typing.Optional[aws_cdk.aws_ec2.AddressFamily] = pydantic.Field(None, description='The address family of the prefix list. Default: AddressFamily.IP_V4\n')
    entries: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.CfnPrefixList_EntryPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The list of entries for the prefix list. Default: []\n')
    prefix_list_name: typing.Optional[str] = pydantic.Field(None, description='The name of the prefix list. Default: None\n')
    max_entries: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of entries for the prefix list. Default: Automatically-calculated')
    _init_params: typing.ClassVar[list[str]] = ['address_family', 'entries', 'prefix_list_name', 'max_entries']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_prefix_list_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.PrefixList'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_prefix_list_id']
    ...


    from_prefix_list_id: typing.Optional[PrefixListDefFromPrefixListIdParams] = pydantic.Field(None, description='Look up prefix list by id.')
    resource_config: typing.Optional[PrefixListDefConfig] = pydantic.Field(None)


class PrefixListDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class PrefixListDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class PrefixListDefFromPrefixListIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    prefix_list_id: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.PrivateSubnet
class PrivateSubnetDef(BaseConstruct):
    availability_zone: str = pydantic.Field(..., description='The availability zone for the subnet.\n')
    cidr_block: str = pydantic.Field(..., description='The CIDR notation for this subnet.\n')
    vpc_id: str = pydantic.Field(..., description='The VPC which this subnet is part of.\n')
    map_public_ip_on_launch: typing.Optional[bool] = pydantic.Field(None, description='Controls if a public IP is associated to an instance at launch. Default: true in Subnet.Public, false in Subnet.Private or Subnet.Isolated.')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'cidr_block', 'vpc_id', 'map_public_ip_on_launch']
    _method_names: typing.ClassVar[list[str]] = ['add_default_internet_route', 'add_default_nat_route', 'add_route', 'apply_removal_policy', 'associate_network_acl']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_private_subnet_attributes', 'from_subnet_attributes', 'from_subnet_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.PrivateSubnet'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_private_subnet_attributes', 'from_subnet_attributes', 'from_subnet_id']
    ...


    from_private_subnet_attributes: typing.Optional[PrivateSubnetDefFromPrivateSubnetAttributesParams] = pydantic.Field(None, description='')
    from_subnet_attributes: typing.Optional[PrivateSubnetDefFromSubnetAttributesParams] = pydantic.Field(None, description='')
    from_subnet_id: typing.Optional[PrivateSubnetDefFromSubnetIdParams] = pydantic.Field(None, description='Import existing subnet from id.')
    resource_config: typing.Optional[PrivateSubnetDefConfig] = pydantic.Field(None)


class PrivateSubnetDefConfig(pydantic.BaseModel):
    add_default_internet_route: typing.Optional[list[PrivateSubnetDefAddDefaultInternetRouteParams]] = pydantic.Field(None, description="Create a default route that points to a passed IGW, with a dependency on the IGW's attachment to the VPC.")
    add_default_nat_route: typing.Optional[list[PrivateSubnetDefAddDefaultNatRouteParams]] = pydantic.Field(None, description='Adds an entry to this subnets route table that points to the passed NATGatewayId.')
    add_route: typing.Optional[list[PrivateSubnetDefAddRouteParams]] = pydantic.Field(None, description='Adds an entry to this subnets route table.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    associate_network_acl: typing.Optional[list[PrivateSubnetDefAssociateNetworkAclParams]] = pydantic.Field(None, description='Associate a Network ACL with this subnet.')
    network_acl_config: typing.Optional[models._interface_methods.AwsEc2INetworkAclDefConfig] = pydantic.Field(None)

class PrivateSubnetDefAddDefaultInternetRouteParams(pydantic.BaseModel):
    gateway_id: str = pydantic.Field(..., description='the logical ID (ref) of the gateway attached to your VPC.\n')
    gateway_attachment: typing.Union[models.aws_iam.CompositeDependableDef, models.aws_iam.GrantDef, models.constructs.DependencyGroupDef] = pydantic.Field(..., description='the gateway attachment construct to be added as a dependency.')
    ...

class PrivateSubnetDefAddDefaultNatRouteParams(pydantic.BaseModel):
    nat_gateway_id: str = pydantic.Field(..., description='The ID of the NAT gateway.')
    ...

class PrivateSubnetDefAddRouteParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    router_id: str = pydantic.Field(..., description='The ID of the router. Can be an instance ID, gateway ID, etc, depending on the router type.\n')
    router_type: aws_cdk.aws_ec2.RouterType = pydantic.Field(..., description='What type of router to route this traffic to.\n')
    destination_cidr_block: typing.Optional[str] = pydantic.Field(None, description="IPv4 range this route applies to. Default: '0.0.0.0/0'\n")
    destination_ipv6_cidr_block: typing.Optional[str] = pydantic.Field(None, description='IPv6 range this route applies to. Default: - Uses IPv6\n')
    enables_internet_connectivity: typing.Optional[bool] = pydantic.Field(None, description='Whether this route will enable internet connectivity. If true, this route will be added before any AWS resources that depend on internet connectivity in the VPC will be created. Default: false')
    ...

class PrivateSubnetDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class PrivateSubnetDefAssociateNetworkAclParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    network_acl: typing.Union[models.aws_ec2.NetworkAclDef] = pydantic.Field(..., description='-')
    ...

class PrivateSubnetDefFromPrivateSubnetAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    id: str = pydantic.Field(..., description='-\n')
    subnet_id: str = pydantic.Field(..., description='The subnetId for this particular subnet.\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone the subnet is located in. Default: - No AZ information, cannot use AZ selection features\n')
    ipv4_cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv4 CIDR block associated with the subnet. Default: - No CIDR information, cannot use CIDR filter features\n')
    route_table_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the route table for this particular subnet. Default: - No route table information, cannot create VPC endpoints')
    ...

class PrivateSubnetDefFromSubnetAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    id: str = pydantic.Field(..., description='-\n')
    subnet_id: str = pydantic.Field(..., description='The subnetId for this particular subnet.\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone the subnet is located in. Default: - No AZ information, cannot use AZ selection features\n')
    ipv4_cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv4 CIDR block associated with the subnet. Default: - No CIDR information, cannot use CIDR filter features\n')
    route_table_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the route table for this particular subnet. Default: - No route table information, cannot create VPC endpoints')
    ...

class PrivateSubnetDefFromSubnetIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    subnet_id: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.PublicSubnet
class PublicSubnetDef(BaseConstruct):
    availability_zone: str = pydantic.Field(..., description='The availability zone for the subnet.\n')
    cidr_block: str = pydantic.Field(..., description='The CIDR notation for this subnet.\n')
    vpc_id: str = pydantic.Field(..., description='The VPC which this subnet is part of.\n')
    map_public_ip_on_launch: typing.Optional[bool] = pydantic.Field(None, description='Controls if a public IP is associated to an instance at launch. Default: true in Subnet.Public, false in Subnet.Private or Subnet.Isolated.')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'cidr_block', 'vpc_id', 'map_public_ip_on_launch']
    _method_names: typing.ClassVar[list[str]] = ['add_default_internet_route', 'add_default_nat_route', 'add_nat_gateway', 'add_route', 'apply_removal_policy', 'associate_network_acl']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_public_subnet_attributes', 'from_subnet_attributes', 'from_subnet_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.PublicSubnet'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_public_subnet_attributes', 'from_subnet_attributes', 'from_subnet_id']
    ...


    from_public_subnet_attributes: typing.Optional[PublicSubnetDefFromPublicSubnetAttributesParams] = pydantic.Field(None, description='')
    from_subnet_attributes: typing.Optional[PublicSubnetDefFromSubnetAttributesParams] = pydantic.Field(None, description='')
    from_subnet_id: typing.Optional[PublicSubnetDefFromSubnetIdParams] = pydantic.Field(None, description='Import existing subnet from id.')
    resource_config: typing.Optional[PublicSubnetDefConfig] = pydantic.Field(None)


class PublicSubnetDefConfig(pydantic.BaseModel):
    add_default_internet_route: typing.Optional[list[PublicSubnetDefAddDefaultInternetRouteParams]] = pydantic.Field(None, description="Create a default route that points to a passed IGW, with a dependency on the IGW's attachment to the VPC.")
    add_default_nat_route: typing.Optional[list[PublicSubnetDefAddDefaultNatRouteParams]] = pydantic.Field(None, description='Adds an entry to this subnets route table that points to the passed NATGatewayId.')
    add_nat_gateway: typing.Optional[list[PublicSubnetDefAddNatGatewayParams]] = pydantic.Field(None, description='Creates a new managed NAT gateway attached to this public subnet.\nAlso adds the EIP for the managed NAT.')
    add_route: typing.Optional[list[PublicSubnetDefAddRouteParams]] = pydantic.Field(None, description='Adds an entry to this subnets route table.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    associate_network_acl: typing.Optional[list[PublicSubnetDefAssociateNetworkAclParams]] = pydantic.Field(None, description='Associate a Network ACL with this subnet.')
    network_acl_config: typing.Optional[models._interface_methods.AwsEc2INetworkAclDefConfig] = pydantic.Field(None)

class PublicSubnetDefAddDefaultInternetRouteParams(pydantic.BaseModel):
    gateway_id: str = pydantic.Field(..., description='the logical ID (ref) of the gateway attached to your VPC.\n')
    gateway_attachment: typing.Union[models.aws_iam.CompositeDependableDef, models.aws_iam.GrantDef, models.constructs.DependencyGroupDef] = pydantic.Field(..., description='the gateway attachment construct to be added as a dependency.')
    ...

class PublicSubnetDefAddDefaultNatRouteParams(pydantic.BaseModel):
    nat_gateway_id: str = pydantic.Field(..., description='The ID of the NAT gateway.')
    ...

class PublicSubnetDefAddNatGatewayParams(pydantic.BaseModel):
    eip_allocation_id: typing.Optional[str] = pydantic.Field(None, description='-\n')
    return_config: typing.Optional[list[models.aws_ec2.CfnNatGatewayDefConfig]] = pydantic.Field(None)
    ...

class PublicSubnetDefAddRouteParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    router_id: str = pydantic.Field(..., description='The ID of the router. Can be an instance ID, gateway ID, etc, depending on the router type.\n')
    router_type: aws_cdk.aws_ec2.RouterType = pydantic.Field(..., description='What type of router to route this traffic to.\n')
    destination_cidr_block: typing.Optional[str] = pydantic.Field(None, description="IPv4 range this route applies to. Default: '0.0.0.0/0'\n")
    destination_ipv6_cidr_block: typing.Optional[str] = pydantic.Field(None, description='IPv6 range this route applies to. Default: - Uses IPv6\n')
    enables_internet_connectivity: typing.Optional[bool] = pydantic.Field(None, description='Whether this route will enable internet connectivity. If true, this route will be added before any AWS resources that depend on internet connectivity in the VPC will be created. Default: false')
    ...

class PublicSubnetDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class PublicSubnetDefAssociateNetworkAclParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    network_acl: typing.Union[models.aws_ec2.NetworkAclDef] = pydantic.Field(..., description='-')
    ...

class PublicSubnetDefFromPublicSubnetAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    id: str = pydantic.Field(..., description='-\n')
    subnet_id: str = pydantic.Field(..., description='The subnetId for this particular subnet.\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone the subnet is located in. Default: - No AZ information, cannot use AZ selection features\n')
    ipv4_cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv4 CIDR block associated with the subnet. Default: - No CIDR information, cannot use CIDR filter features\n')
    route_table_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the route table for this particular subnet. Default: - No route table information, cannot create VPC endpoints')
    ...

class PublicSubnetDefFromSubnetAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    id: str = pydantic.Field(..., description='-\n')
    subnet_id: str = pydantic.Field(..., description='The subnetId for this particular subnet.\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone the subnet is located in. Default: - No AZ information, cannot use AZ selection features\n')
    ipv4_cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv4 CIDR block associated with the subnet. Default: - No CIDR information, cannot use CIDR filter features\n')
    route_table_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the route table for this particular subnet. Default: - No route table information, cannot create VPC endpoints')
    ...

class PublicSubnetDefFromSubnetIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    subnet_id: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.SecurityGroup
class SecurityGroupDef(BaseConstruct):
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='The VPC in which to create the security group.\n')
    allow_all_ipv6_outbound: typing.Optional[bool] = pydantic.Field(None, description='Whether to allow all outbound ipv6 traffic by default. If this is set to true, there will only be a single egress rule which allows all outbound ipv6 traffic. If this is set to false, no outbound traffic will be allowed by default and all egress ipv6 traffic must be explicitly authorized. To allow all ipv4 traffic use allowAllOutbound Default: false\n')
    allow_all_outbound: typing.Optional[bool] = pydantic.Field(None, description='Whether to allow all outbound traffic by default. If this is set to true, there will only be a single egress rule which allows all outbound traffic. If this is set to false, no outbound traffic will be allowed by default and all egress traffic must be explicitly authorized. To allow all ipv6 traffic use allowAllIpv6Outbound Default: true\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the security group. Default: The default name will be the construct's CDK path.\n")
    disable_inline_rules: typing.Optional[bool] = pydantic.Field(None, description="Whether to disable inline ingress and egress rule optimization. If this is set to true, ingress and egress rules will not be declared under the SecurityGroup in cloudformation, but will be separate elements. Inlining rules is an optimization for producing smaller stack templates. Sometimes this is not desirable, for example when security group access is managed via tags. The default value can be overriden globally by setting the context variable '@aws-cdk/aws-ec2.securityGroupDisableInlineRules'. Default: false\n")
    security_group_name: typing.Optional[str] = pydantic.Field(None, description="The name of the security group. For valid values, see the GroupName parameter of the CreateSecurityGroup action in the Amazon EC2 API Reference. It is not recommended to use an explicit group name. Default: If you don't specify a GroupName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.")
    _init_params: typing.ClassVar[list[str]] = ['vpc', 'allow_all_ipv6_outbound', 'allow_all_outbound', 'description', 'disable_inline_rules', 'security_group_name']
    _method_names: typing.ClassVar[list[str]] = ['add_egress_rule', 'add_ingress_rule', 'apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_lookup_by_id', 'from_lookup_by_name', 'from_security_group_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.SecurityGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_lookup_by_id', 'from_lookup_by_name', 'from_security_group_id']
    ...


    from_lookup_by_id: typing.Optional[SecurityGroupDefFromLookupByIdParams] = pydantic.Field(None, description='Look up a security group by id.')
    from_lookup_by_name: typing.Optional[SecurityGroupDefFromLookupByNameParams] = pydantic.Field(None, description='Look up a security group by name.')
    from_security_group_id: typing.Optional[SecurityGroupDefFromSecurityGroupIdParams] = pydantic.Field(None, description='Import an existing security group into this app.\nThis method will assume that the Security Group has a rule in it which allows\nall outbound traffic, and so will not add egress rules to the imported Security\nGroup (only ingress rules).\n\nIf your existing Security Group needs to have egress rules added, pass the\n``allowAllOutbound: false`` option on import.')
    resource_config: typing.Optional[SecurityGroupDefConfig] = pydantic.Field(None)


class SecurityGroupDefConfig(pydantic.BaseModel):
    add_egress_rule: typing.Optional[list[SecurityGroupDefAddEgressRuleParams]] = pydantic.Field(None, description='Add an egress rule for the current security group.\n``remoteRule`` controls where the Rule object is created if the peer is also a\nsecurityGroup and they are in different stack. If false (default) the\nrule object is created under the current SecurityGroup object. If true and the\npeer is also a SecurityGroup, the rule object is created under the remote\nSecurityGroup object.')
    add_ingress_rule: typing.Optional[list[SecurityGroupDefAddIngressRuleParams]] = pydantic.Field(None, description='Add an ingress rule for the current security group.\n``remoteRule`` controls where the Rule object is created if the peer is also a\nsecurityGroup and they are in different stack. If false (default) the\nrule object is created under the current SecurityGroup object. If true and the\npeer is also a SecurityGroup, the rule object is created under the remote\nSecurityGroup object.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class SecurityGroupDefAddEgressRuleParams(pydantic.BaseModel):
    peer: models.UnsupportedResource = pydantic.Field(..., description='-\n')
    connection: models.aws_ec2.PortDef = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='-\n')
    remote_rule: typing.Optional[bool] = pydantic.Field(None, description='-')
    ...

class SecurityGroupDefAddIngressRuleParams(pydantic.BaseModel):
    peer: models.UnsupportedResource = pydantic.Field(..., description='-\n')
    connection: models.aws_ec2.PortDef = pydantic.Field(..., description='-\n')
    description: typing.Optional[str] = pydantic.Field(None, description='-\n')
    remote_rule: typing.Optional[bool] = pydantic.Field(None, description='-')
    ...

class SecurityGroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class SecurityGroupDefFromLookupByIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    security_group_id: str = pydantic.Field(..., description='-')
    ...

class SecurityGroupDefFromLookupByNameParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    security_group_name: str = pydantic.Field(..., description='-\n')
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='-')
    ...

class SecurityGroupDefFromSecurityGroupIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    security_group_id: str = pydantic.Field(..., description='-\n')
    allow_all_ipv6_outbound: typing.Optional[bool] = pydantic.Field(None, description='Mark the SecurityGroup as having been created allowing all outbound ipv6 traffic. Only if this is set to false will egress rules for ipv6 be added to this security group. Be aware, this would undo any potential "all outbound traffic" default. Default: false\n')
    allow_all_outbound: typing.Optional[bool] = pydantic.Field(None, description='Mark the SecurityGroup as having been created allowing all outbound traffic. Only if this is set to false will egress rules be added to this security group. Be aware, this would undo any potential "all outbound traffic" default. Default: true\n')
    mutable: typing.Optional[bool] = pydantic.Field(None, description='If a SecurityGroup is mutable CDK can add rules to existing groups. Beware that making a SecurityGroup immutable might lead to issue due to missing ingress/egress rules for new resources. Default: true')
    ...


#  autogenerated from aws_cdk.aws_ec2.Subnet
class SubnetDef(BaseConstruct):
    availability_zone: str = pydantic.Field(..., description='The availability zone for the subnet.\n')
    cidr_block: str = pydantic.Field(..., description='The CIDR notation for this subnet.\n')
    vpc_id: str = pydantic.Field(..., description='The VPC which this subnet is part of.\n')
    map_public_ip_on_launch: typing.Optional[bool] = pydantic.Field(None, description='Controls if a public IP is associated to an instance at launch. Default: true in Subnet.Public, false in Subnet.Private or Subnet.Isolated.')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'cidr_block', 'vpc_id', 'map_public_ip_on_launch']
    _method_names: typing.ClassVar[list[str]] = ['add_default_internet_route', 'add_default_nat_route', 'add_route', 'apply_removal_policy', 'associate_network_acl']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_subnet_attributes', 'from_subnet_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.Subnet'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_subnet_attributes', 'from_subnet_id']
    ...


    from_subnet_attributes: typing.Optional[SubnetDefFromSubnetAttributesParams] = pydantic.Field(None, description='')
    from_subnet_id: typing.Optional[SubnetDefFromSubnetIdParams] = pydantic.Field(None, description='Import existing subnet from id.')
    resource_config: typing.Optional[SubnetDefConfig] = pydantic.Field(None)


class SubnetDefConfig(pydantic.BaseModel):
    add_default_internet_route: typing.Optional[list[SubnetDefAddDefaultInternetRouteParams]] = pydantic.Field(None, description="Create a default route that points to a passed IGW, with a dependency on the IGW's attachment to the VPC.")
    add_default_nat_route: typing.Optional[list[SubnetDefAddDefaultNatRouteParams]] = pydantic.Field(None, description='Adds an entry to this subnets route table that points to the passed NATGatewayId.')
    add_route: typing.Optional[list[SubnetDefAddRouteParams]] = pydantic.Field(None, description='Adds an entry to this subnets route table.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    associate_network_acl: typing.Optional[list[SubnetDefAssociateNetworkAclParams]] = pydantic.Field(None, description='Associate a Network ACL with this subnet.')
    network_acl_config: typing.Optional[models._interface_methods.AwsEc2INetworkAclDefConfig] = pydantic.Field(None)

class SubnetDefAddDefaultInternetRouteParams(pydantic.BaseModel):
    gateway_id: str = pydantic.Field(..., description='the logical ID (ref) of the gateway attached to your VPC.\n')
    gateway_attachment: typing.Union[models.aws_iam.CompositeDependableDef, models.aws_iam.GrantDef, models.constructs.DependencyGroupDef] = pydantic.Field(..., description='the gateway attachment construct to be added as a dependency.')
    ...

class SubnetDefAddDefaultNatRouteParams(pydantic.BaseModel):
    nat_gateway_id: str = pydantic.Field(..., description='The ID of the NAT gateway.')
    ...

class SubnetDefAddRouteParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    router_id: str = pydantic.Field(..., description='The ID of the router. Can be an instance ID, gateway ID, etc, depending on the router type.\n')
    router_type: aws_cdk.aws_ec2.RouterType = pydantic.Field(..., description='What type of router to route this traffic to.\n')
    destination_cidr_block: typing.Optional[str] = pydantic.Field(None, description="IPv4 range this route applies to. Default: '0.0.0.0/0'\n")
    destination_ipv6_cidr_block: typing.Optional[str] = pydantic.Field(None, description='IPv6 range this route applies to. Default: - Uses IPv6\n')
    enables_internet_connectivity: typing.Optional[bool] = pydantic.Field(None, description='Whether this route will enable internet connectivity. If true, this route will be added before any AWS resources that depend on internet connectivity in the VPC will be created. Default: false')
    ...

class SubnetDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class SubnetDefAssociateNetworkAclParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    network_acl: typing.Union[models.aws_ec2.NetworkAclDef] = pydantic.Field(..., description='-')
    ...

class SubnetDefFromSubnetAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    id: str = pydantic.Field(..., description='-\n')
    subnet_id: str = pydantic.Field(..., description='The subnetId for this particular subnet.\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone the subnet is located in. Default: - No AZ information, cannot use AZ selection features\n')
    ipv4_cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv4 CIDR block associated with the subnet. Default: - No CIDR information, cannot use CIDR filter features\n')
    route_table_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the route table for this particular subnet. Default: - No route table information, cannot create VPC endpoints')
    ...

class SubnetDefFromSubnetIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    subnet_id: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.SubnetNetworkAclAssociation
class SubnetNetworkAclAssociationDef(BaseConstruct):
    network_acl: typing.Union[models.aws_ec2.NetworkAclDef] = pydantic.Field(..., description='The Network ACL this association is defined for.\n')
    subnet: typing.Union[models.aws_ec2.PrivateSubnetDef, models.aws_ec2.PublicSubnetDef, models.aws_ec2.SubnetDef] = pydantic.Field(..., description='ID of the Subnet.\n')
    subnet_network_acl_association_name: typing.Optional[str] = pydantic.Field(None, description="The name of the SubnetNetworkAclAssociation. It is not recommended to use an explicit name. Default: If you don't specify a SubnetNetworkAclAssociationName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.")
    _init_params: typing.ClassVar[list[str]] = ['network_acl', 'subnet', 'subnet_network_acl_association_name']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_subnet_network_acl_association_association_id']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.SubnetNetworkAclAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_subnet_network_acl_association_association_id']
    ...


    from_subnet_network_acl_association_association_id: typing.Optional[SubnetNetworkAclAssociationDefFromSubnetNetworkAclAssociationAssociationIdParams] = pydantic.Field(None, description='')
    resource_config: typing.Optional[SubnetNetworkAclAssociationDefConfig] = pydantic.Field(None)


class SubnetNetworkAclAssociationDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    network_acl_config: typing.Optional[models._interface_methods.AwsEc2INetworkAclDefConfig] = pydantic.Field(None)
    subnet_config: typing.Optional[models._interface_methods.AwsEc2ISubnetDefConfig] = pydantic.Field(None)

class SubnetNetworkAclAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class SubnetNetworkAclAssociationDefFromSubnetNetworkAclAssociationAssociationIdParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-')
    id: str = pydantic.Field(..., description='-\n')
    subnet_network_acl_association_association_id: str = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.Volume
class VolumeDef(BaseConstruct):
    availability_zone: str = pydantic.Field(..., description='The Availability Zone in which to create the volume.\n')
    auto_enable_io: typing.Optional[bool] = pydantic.Field(None, description="Indicates whether the volume is auto-enabled for I/O operations. By default, Amazon EBS disables I/O to the volume from attached EC2 instances when it determines that a volume's data is potentially inconsistent. If the consistency of the volume is not a concern, and you prefer that the volume be made available immediately if it's impaired, you can configure the volume to automatically enable I/O. Default: false\n")
    enable_multi_attach: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether Amazon EBS Multi-Attach is enabled. See `Considerations and limitations <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volumes-multi.html#considerations>`_ for the constraints of multi-attach. Default: false\n')
    encrypted: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether the volume should be encrypted. The effect of setting the encryption state to true depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Encryption by Default <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default>`_ in the Amazon Elastic Compute Cloud User Guide. Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see `Supported Instance Types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances>`_. Default: false\n')
    encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The customer-managed encryption key that is used to encrypt the Volume. The encrypted property must be true if this is provided. Note: If using an ``aws-kms.IKey`` created from a ``aws-kms.Key.fromKeyArn()`` here, then the KMS key **must** have the following in its Key policy; otherwise, the Volume will fail to create:: { "Effect": "Allow", "Principal": { "AWS": "<arn for your account-user> ex: arn:aws:iam::00000000000:root" }, "Resource": "*", "Action": [ "kms:DescribeKey", "kms:GenerateDataKeyWithoutPlainText", ], "Condition": { "StringEquals": { "kms:ViaService": "ec2.<Region>.amazonaws.com", (eg: ec2.us-east-1.amazonaws.com) "kms:CallerAccount": "0000000000" (your account ID) } } } Default: The default KMS key for the account, region, and EC2 service is used.\n')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='The number of I/O operations per second (IOPS) to provision for the volume. The maximum ratio is 50 IOPS/GiB for PROVISIONED_IOPS_SSD, and 500 IOPS/GiB for both PROVISIONED_IOPS_SSD_IO2 and GENERAL_PURPOSE_SSD_GP3. See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html for more information. This parameter is valid only for PROVISIONED_IOPS_SSD, PROVISIONED_IOPS_SSD_IO2 and GENERAL_PURPOSE_SSD_GP3 volumes. Default: None -- Required for io1 and io2 volumes. The default for gp3 volumes is 3,000 IOPS if omitted.\n')
    removal_policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='Policy to apply when the volume is removed from the stack. Default: RemovalPolicy.RETAIN\n')
    size: typing.Optional[models.SizeDef] = pydantic.Field(None, description="The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html for details on the allowable size for each type of volume. Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.\n")
    snapshot_id: typing.Optional[str] = pydantic.Field(None, description='The snapshot from which to create the volume. You must specify either a snapshot ID or a volume size. Default: The EBS volume is not created from a snapshot.\n')
    throughput: typing.Union[int, float, None] = pydantic.Field(None, description='The throughput that the volume supports, in MiB/s Takes a minimum of 125 and maximum of 1000. Default: - 125 MiB/s. Only valid on gp3 volumes.\n')
    volume_name: typing.Optional[str] = pydantic.Field(None, description='The value of the physicalName property of this resource. Default: The physical name will be allocated by CloudFormation at deployment time\n')
    volume_type: typing.Optional[aws_cdk.aws_ec2.EbsDeviceVolumeType] = pydantic.Field(None, description='The type of the volume; what type of storage to use to form the EBS Volume. Default: ``EbsDeviceVolumeType.GENERAL_PURPOSE_SSD``')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'auto_enable_io', 'enable_multi_attach', 'encrypted', 'encryption_key', 'iops', 'removal_policy', 'size', 'snapshot_id', 'throughput', 'volume_name', 'volume_type']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'grant_attach_volume', 'grant_attach_volume_by_resource_tag', 'grant_detach_volume', 'grant_detach_volume_by_resource_tag']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_volume_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.Volume'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_volume_attributes']
    ...


    from_volume_attributes: typing.Optional[VolumeDefFromVolumeAttributesParams] = pydantic.Field(None, description='Import an existing EBS Volume into the Stack.')
    resource_config: typing.Optional[VolumeDefConfig] = pydantic.Field(None)


class VolumeDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    grant_attach_volume: typing.Optional[list[VolumeDefGrantAttachVolumeParams]] = pydantic.Field(None, description='Grants permission to attach this Volume to an instance.\nCAUTION: Granting an instance permission to attach to itself using this method will lead to\nan unresolvable circular reference between the instance role and the instance.\nUse ``IVolume.grantAttachVolumeToSelf`` to grant an instance permission to attach this\nvolume to itself.')
    grant_attach_volume_by_resource_tag: typing.Optional[list[VolumeDefGrantAttachVolumeByResourceTagParams]] = pydantic.Field(None, description='Grants permission to attach the Volume by a ResourceTag condition.\nIf you are looking to\ngrant an Instance, AutoScalingGroup, EC2-Fleet, SpotFleet, ECS host, etc the ability to attach\nthis volume to **itself** then this is the method you want to use.\n\nThis is implemented by adding a Tag with key ``VolumeGrantAttach-<suffix>`` to the given\nconstructs and this Volume, and then conditioning the Grant such that the grantee is only\ngiven the ability to AttachVolume if both the Volume and the destination Instance have that\ntag applied to them.')
    grant_detach_volume: typing.Optional[list[VolumeDefGrantDetachVolumeParams]] = pydantic.Field(None, description='Grants permission to detach this Volume from an instance CAUTION: Granting an instance permission to detach from itself using this method will lead to an unresolvable circular reference between the instance role and the instance.\nUse ``IVolume.grantDetachVolumeFromSelf`` to grant an instance permission to detach this\nvolume from itself.')
    grant_detach_volume_by_resource_tag: typing.Optional[list[VolumeDefGrantDetachVolumeByResourceTagParams]] = pydantic.Field(None, description='Grants permission to detach the Volume by a ResourceTag condition.\nThis is implemented via the same mechanism as ``IVolume.grantAttachVolumeByResourceTag``,\nand is subject to the same conditions.')

class VolumeDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class VolumeDefFromVolumeAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='the scope of the import.\n')
    id: str = pydantic.Field(..., description='the ID of the imported Volume in the construct tree.\n')
    availability_zone: str = pydantic.Field(..., description='The availability zone that the EBS Volume is contained within (ex: us-west-2a).\n')
    volume_id: str = pydantic.Field(..., description="The EBS Volume's ID.\n")
    encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The customer-managed encryption key that is used to encrypt the Volume. Default: None -- The EBS Volume is not using a customer-managed KMS key for encryption.')
    ...

class VolumeDefGrantAttachVolumeParams(pydantic.BaseModel):
    grantee: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='-\n')
    instances: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.BastionHostLinuxDef, models.aws_ec2.InstanceDef]]] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class VolumeDefGrantAttachVolumeByResourceTagParams(pydantic.BaseModel):
    grantee: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='-\n')
    constructs: typing.Sequence[models.constructs.ConstructDef] = pydantic.Field(..., description='-\n')
    tag_key_suffix: typing.Optional[str] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class VolumeDefGrantDetachVolumeParams(pydantic.BaseModel):
    grantee: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='-\n')
    instances: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.BastionHostLinuxDef, models.aws_ec2.InstanceDef]]] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...

class VolumeDefGrantDetachVolumeByResourceTagParams(pydantic.BaseModel):
    grantee: typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef] = pydantic.Field(..., description='-\n')
    constructs: typing.Sequence[models.constructs.ConstructDef] = pydantic.Field(..., description='-\n')
    tag_key_suffix: typing.Optional[str] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.aws_iam.GrantDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_ec2.Vpc
class VpcDef(BaseConstruct):
    availability_zones: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Availability zones this VPC spans. Specify this option only if you do not specify ``maxAzs``. Default: - a subset of AZs of the stack\n')
    cidr: typing.Optional[str] = pydantic.Field(None, description="(deprecated) The CIDR range to use for the VPC, e.g. '10.0.0.0/16'. Should be a minimum of /28 and maximum size of /16. The range will be split across all subnets per Availability Zone. Default: Vpc.DEFAULT_CIDR_RANGE\n")
    default_instance_tenancy: typing.Optional[aws_cdk.aws_ec2.DefaultInstanceTenancy] = pydantic.Field(None, description='The default tenancy of instances launched into the VPC. By setting this to dedicated tenancy, instances will be launched on hardware dedicated to a single AWS customer, unless specifically specified at instance launch time. Please note, not all instance types are usable with Dedicated tenancy. Default: DefaultInstanceTenancy.Default (shared) tenancy\n')
    enable_dns_hostnames: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the instances launched in the VPC get public DNS hostnames. If this attribute is true, instances in the VPC get public DNS hostnames, but only if the enableDnsSupport attribute is also set to true. Default: true\n')
    enable_dns_support: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the DNS resolution is supported for the VPC. If this attribute is false, the Amazon-provided DNS server in the VPC that resolves public DNS hostnames to IP addresses is not enabled. If this attribute is true, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC IPv4 network range plus two will succeed. Default: true\n')
    flow_logs: typing.Optional[typing.Mapping[str, typing.Union[models.aws_ec2.FlowLogOptionsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Flow logs to add to this VPC. Default: - No flow logs.\n')
    gateway_endpoints: typing.Optional[typing.Mapping[str, typing.Union[models.aws_ec2.GatewayVpcEndpointOptionsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Gateway endpoints to add to this VPC. Default: - None.\n')
    ip_addresses: typing.Optional[models.UnsupportedResource] = pydantic.Field(None, description='The Provider to use to allocate IP Space to your VPC. Options include static allocation or from a pool. Default: ec2.IpAddresses.cidr\n')
    max_azs: typing.Union[int, float, None] = pydantic.Field(None, description='Define the maximum number of AZs to use in this region. If the region has more AZs than you want to use (for example, because of EIP limits), pick a lower number here. The AZs will be sorted and picked from the start of the list. If you pick a higher number than the number of AZs in the region, all AZs in the region will be selected. To use "all AZs" available to your account, use a high number (such as 99). Be aware that environment-agnostic stacks will be created with access to only 2 AZs, so to use more than 2 AZs, be sure to specify the account and region on your stack. Specify this option only if you do not specify ``availabilityZones``. Default: 3\n')
    nat_gateway_provider: typing.Optional[models.aws_ec2.NatProviderDef] = pydantic.Field(None, description='What type of NAT provider to use. Select between NAT gateways or NAT instances. NAT gateways may not be available in all AWS regions. Default: NatProvider.gateway()\n')
    nat_gateways: typing.Union[int, float, None] = pydantic.Field(None, description='The number of NAT Gateways/Instances to create. The type of NAT gateway or instance will be determined by the ``natGatewayProvider`` parameter. You can set this number lower than the number of Availability Zones in your VPC in order to save on NAT cost. Be aware you may be charged for cross-AZ data traffic instead. Default: - One NAT gateway/instance per Availability Zone\n')
    nat_gateway_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configures the subnets which will have NAT Gateways/Instances. You can pick a specific group of subnets by specifying the group name; the picked subnets must be public subnets. Only necessary if you have more than one public subnet group. Default: - All public subnets.\n')
    reserved_azs: typing.Union[int, float, None] = pydantic.Field(None, description='Define the number of AZs to reserve. When specified, the IP space is reserved for the azs but no actual resources are provisioned. Default: 0\n')
    restrict_default_security_group: typing.Optional[bool] = pydantic.Field(None, description="If set to true then the default inbound & outbound rules will be removed from the default security group. Default: true if '@aws-cdk/aws-ec2:restrictDefaultSecurityGroup' is enabled, false otherwise\n")
    subnet_configuration: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SubnetConfigurationDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="Configure the subnets to build for each AZ. Each entry in this list configures a Subnet Group; each group will contain a subnet for each Availability Zone. For example, if you want 1 public subnet, 1 private subnet, and 1 isolated subnet in each AZ provide the following:: new ec2.Vpc(this, 'VPC', { subnetConfiguration: [ { cidrMask: 24, name: 'ingress', subnetType: ec2.SubnetType.PUBLIC, }, { cidrMask: 24, name: 'application', subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS, }, { cidrMask: 28, name: 'rds', subnetType: ec2.SubnetType.PRIVATE_ISOLATED, } ] }); Default: - The VPC CIDR will be evenly divided between 1 public and 1 private subnet per AZ.\n")
    vpc_name: typing.Optional[str] = pydantic.Field(None, description="The VPC name. Since the VPC resource doesn't support providing a physical name, the value provided here will be recorded in the ``Name`` tag Default: this.node.path\n")
    vpn_connections: typing.Optional[typing.Mapping[str, typing.Union[models.aws_ec2.VpnConnectionOptionsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='VPN connections to this VPC. Default: - No connections.\n')
    vpn_gateway: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether a VPN gateway should be created and attached to this VPC. Default: - true when vpnGatewayAsn or vpnConnections is specified\n')
    vpn_gateway_asn: typing.Union[int, float, None] = pydantic.Field(None, description='The private Autonomous System Number (ASN) for the VPN gateway. Default: - Amazon default ASN.\n')
    vpn_route_propagation: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Where to propagate VPN routes. Default: - On the route tables associated with private subnets. If no private subnets exists, isolated subnets are used. If no isolated subnets exists, public subnets are used.')
    _init_params: typing.ClassVar[list[str]] = ['availability_zones', 'cidr', 'default_instance_tenancy', 'enable_dns_hostnames', 'enable_dns_support', 'flow_logs', 'gateway_endpoints', 'ip_addresses', 'max_azs', 'nat_gateway_provider', 'nat_gateways', 'nat_gateway_subnets', 'reserved_azs', 'restrict_default_security_group', 'subnet_configuration', 'vpc_name', 'vpn_connections', 'vpn_gateway', 'vpn_gateway_asn', 'vpn_route_propagation']
    _method_names: typing.ClassVar[list[str]] = ['add_client_vpn_endpoint', 'add_flow_log', 'add_gateway_endpoint', 'add_interface_endpoint', 'add_vpn_connection', 'apply_removal_policy', 'enable_vpn_gateway', 'select_subnets']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_lookup', 'from_vpc_attributes']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.Vpc'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_lookup', 'from_vpc_attributes']
    ...


    from_lookup: typing.Optional[VpcDefFromLookupParams] = pydantic.Field(None, description='Import an existing VPC by querying the AWS environment this stack is deployed to.\nThis function only needs to be used to use VPCs not defined in your CDK\napplication. If you are looking to share a VPC between stacks, you can\npass the ``Vpc`` object between stacks and use it as normal.\n\nCalling this method will lead to a lookup when the CDK CLI is executed.\nYou can therefore not use any values that will only be available at\nCloudFormation execution time (i.e., Tokens).\n\nThe VPC information will be cached in ``cdk.context.json`` and the same VPC\nwill be used on future runs. To refresh the lookup, you will have to\nevict the value from the cache using the ``cdk context`` command. See\nhttps://docs.aws.amazon.com/cdk/latest/guide/context.html for more information.')
    from_vpc_attributes: typing.Optional[VpcDefFromVpcAttributesParams] = pydantic.Field(None, description='Import a VPC by supplying all attributes directly.\nNOTE: using ``fromVpcAttributes()`` with deploy-time parameters (like a ``Fn.importValue()`` or\n``CfnParameter`` to represent a list of subnet IDs) sometimes accidentally works. It happens\nto work for constructs that need a list of subnets (like ``AutoScalingGroup`` and ``eks.Cluster``)\nbut it does not work for constructs that need individual subnets (like\n``Instance``). See https://github.com/aws/aws-cdk/issues/4118 for more\ninformation.\n\nPrefer to use ``Vpc.fromLookup()`` instead.')
    resource_config: typing.Optional[VpcDefConfig] = pydantic.Field(None)


class VpcDefConfig(pydantic.BaseModel):
    add_client_vpn_endpoint: typing.Optional[list[VpcDefAddClientVpnEndpointParams]] = pydantic.Field(None, description='Adds a new client VPN endpoint to this VPC.')
    add_flow_log: typing.Optional[list[VpcDefAddFlowLogParams]] = pydantic.Field(None, description='Adds a new flow log to this VPC.')
    add_gateway_endpoint: typing.Optional[list[VpcDefAddGatewayEndpointParams]] = pydantic.Field(None, description='Adds a new gateway endpoint to this VPC.')
    add_interface_endpoint: typing.Optional[list[VpcDefAddInterfaceEndpointParams]] = pydantic.Field(None, description='Adds a new interface endpoint to this VPC.')
    add_vpn_connection: typing.Optional[list[VpcDefAddVpnConnectionParams]] = pydantic.Field(None, description='Adds a new VPN connection to this VPC.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    enable_vpn_gateway: typing.Optional[list[VpcDefEnableVpnGatewayParams]] = pydantic.Field(None, description='Adds a VPN Gateway to this VPC.')
    select_subnets: typing.Optional[list[VpcDefSelectSubnetsParams]] = pydantic.Field(None, description='Returns IDs of selected subnets.')

class VpcDefAddClientVpnEndpointParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    cidr: str = pydantic.Field(..., description='The IPv4 address range, in CIDR notation, from which to assign client IP addresses. The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. Changing the address range will replace the Client VPN endpoint. The CIDR block should be /22 or greater.\n')
    server_certificate_arn: str = pydantic.Field(..., description='The ARN of the server certificate.\n')
    authorize_all_users_to_vpc_cidr: typing.Optional[bool] = pydantic.Field(None, description='Whether to authorize all users to the VPC CIDR. This automatically creates an authorization rule. Set this to ``false`` and use ``addAuthorizationRule()`` to create your own rules instead. Default: true\n')
    client_certificate_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the client certificate for mutual authentication. The certificate must be signed by a certificate authority (CA) and it must be provisioned in AWS Certificate Manager (ACM). Default: - use user-based authentication\n')
    client_connection_handler: typing.Optional[typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef]] = pydantic.Field(None, description='The AWS Lambda function used for connection authorization. The name of the Lambda function must begin with the ``AWSClientVPN-`` prefix Default: - no connection handler\n')
    client_login_banner: typing.Optional[str] = pydantic.Field(None, description='Customizable text that will be displayed in a banner on AWS provided clients when a VPN session is established. UTF-8 encoded characters only. Maximum of 1400 characters. Default: - no banner is presented to the client\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A brief description of the Client VPN endpoint. Default: - no description\n')
    dns_servers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Information about the DNS servers to be used for DNS resolution. A Client VPN endpoint can have up to two DNS servers. Default: - use the DNS address configured on the device\n')
    logging: typing.Optional[bool] = pydantic.Field(None, description='Whether to enable connections logging. Default: true\n')
    log_group: typing.Optional[typing.Union[models.aws_logs.LogGroupDef]] = pydantic.Field(None, description='A CloudWatch Logs log group for connection logging. Default: - a new group is created\n')
    log_stream: typing.Optional[typing.Union[models.aws_logs.LogStreamDef]] = pydantic.Field(None, description='A CloudWatch Logs log stream for connection logging. Default: - a new stream is created\n')
    port: typing.Optional[aws_cdk.aws_ec2.VpnPort] = pydantic.Field(None, description='The port number to assign to the Client VPN endpoint for TCP and UDP traffic. Default: VpnPort.HTTPS\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='The security groups to apply to the target network. Default: - a new security group is created\n')
    self_service_portal: typing.Optional[bool] = pydantic.Field(None, description='Specify whether to enable the self-service portal for the Client VPN endpoint. Default: true\n')
    session_timeout: typing.Optional[aws_cdk.aws_ec2.ClientVpnSessionTimeout] = pydantic.Field(None, description='The maximum VPN session duration time. Default: ClientVpnSessionTimeout.TWENTY_FOUR_HOURS\n')
    split_tunnel: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint. Default: false\n')
    transport_protocol: typing.Optional[aws_cdk.aws_ec2.TransportProtocol] = pydantic.Field(None, description='The transport protocol to be used by the VPN session. Default: TransportProtocol.UDP\n')
    user_based_authentication: typing.Optional[models.aws_ec2.ClientVpnUserBasedAuthenticationDef] = pydantic.Field(None, description='The type of user-based authentication to use. Default: - use mutual authentication\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Subnets to associate to the client VPN endpoint. Default: - the VPC default strategy')
    return_config: typing.Optional[list[models.aws_ec2.ClientVpnEndpointDefConfig]] = pydantic.Field(None)
    ...

class VpcDefAddFlowLogParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    destination: typing.Optional[models.aws_ec2.FlowLogDestinationDef] = pydantic.Field(None, description='Specifies the type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3 Default: FlowLogDestinationType.toCloudWatchLogs()\n')
    log_format: typing.Optional[typing.Sequence[models.aws_ec2.LogFormatDef]] = pydantic.Field(None, description='The fields to include in the flow log record, in the order in which they should appear. If multiple fields are specified, they will be separated by spaces. For full control over the literal log format string, pass a single field constructed with ``LogFormat.custom()``. See https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-log-records Default: - default log format is used.\n')
    max_aggregation_interval: typing.Optional[aws_cdk.aws_ec2.FlowLogMaxAggregationInterval] = pydantic.Field(None, description='The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record. Default: FlowLogMaxAggregationInterval.TEN_MINUTES\n')
    traffic_type: typing.Optional[aws_cdk.aws_ec2.FlowLogTrafficType] = pydantic.Field(None, description='The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic. Default: ALL')
    return_config: typing.Optional[list[models.aws_ec2.FlowLogDefConfig]] = pydantic.Field(None)
    ...

class VpcDefAddGatewayEndpointParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    service: typing.Union[models.aws_ec2.GatewayVpcEndpointAwsServiceDef] = pydantic.Field(..., description='The service to use for this gateway VPC endpoint.\n')
    subnets: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Where to add endpoint routing. By default, this endpoint will be routable from all subnets in the VPC. Specify a list of subnet selection objects here to be more specific. Default: - All subnets in the VPC')
    return_config: typing.Optional[list[models.aws_ec2.GatewayVpcEndpointDefConfig]] = pydantic.Field(None)
    ...

class VpcDefAddInterfaceEndpointParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    service: typing.Union[models.aws_ec2.InterfaceVpcEndpointAwsServiceDef, models.aws_ec2.InterfaceVpcEndpointServiceDef] = pydantic.Field(..., description='The service to use for this interface VPC endpoint.\n')
    lookup_supported_azs: typing.Optional[bool] = pydantic.Field(None, description="Limit to only those availability zones where the endpoint service can be created. Setting this to 'true' requires a lookup to be performed at synthesis time. Account and region must be set on the containing stack for this to work. Default: false\n")
    open: typing.Optional[bool] = pydantic.Field(None, description="Whether to automatically allow VPC traffic to the endpoint. If enabled, all traffic to the endpoint from within the VPC will be automatically allowed. This is done based on the VPC's CIDR range. Default: true\n")
    private_dns_enabled: typing.Optional[bool] = pydantic.Field(None, description='Whether to associate a private hosted zone with the specified VPC. This allows you to make requests to the service using its default DNS hostname. Default: set by the instance of IInterfaceVpcEndpointService, or true if not defined by the instance of IInterfaceVpcEndpointService\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='The security groups to associate with this interface VPC endpoint. Default: - a new security group is created\n')
    subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The subnets in which to create an endpoint network interface. At most one per availability zone. Default: - private subnets')
    return_config: typing.Optional[list[models.aws_ec2.InterfaceVpcEndpointDefConfig]] = pydantic.Field(None)
    ...

class VpcDefAddVpnConnectionParams(pydantic.BaseModel):
    id: str = pydantic.Field(..., description='-\n')
    ip: str = pydantic.Field(..., description='The ip address of the customer gateway.\n')
    asn: typing.Union[int, float, None] = pydantic.Field(None, description='The ASN of the customer gateway. Default: 65000\n')
    static_routes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The static routes to be routed from the VPN gateway to the customer gateway. Default: Dynamic routing (BGP)\n')
    tunnel_options: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.VpnTunnelOptionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tunnel options for the VPN connection. At most two elements (one per tunnel). Duplicates not allowed. Default: Amazon generated tunnel options')
    return_config: typing.Optional[list[models.aws_ec2.VpnConnectionDefConfig]] = pydantic.Field(None)
    ...

class VpcDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class VpcDefEnableVpnGatewayParams(pydantic.BaseModel):
    vpn_route_propagation: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Provide an array of subnets where the route propagation should be added. Default: noPropagation\n')
    type: str = pydantic.Field(..., description='Default type ipsec.1.\n')
    amazon_side_asn: typing.Union[int, float, None] = pydantic.Field(None, description='Explicitly specify an Asn or let aws pick an Asn for you. Default: 65000')
    ...

class VpcDefFromLookupParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    is_default: typing.Optional[bool] = pydantic.Field(None, description="Whether to match the default VPC. Default: Don't care whether we return the default VPC\n")
    owner_account_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the AWS account that owns the VPC. Default: the account id of the parent stack\n')
    region: typing.Optional[str] = pydantic.Field(None, description="Optional to override inferred region. Default: Current stack's environment region\n")
    return_vpn_gateways: typing.Optional[bool] = pydantic.Field(None, description='Whether to look up whether a VPN Gateway is attached to the looked up VPC. You can set this to ``false`` if you know the VPC does not have a VPN Gateway attached, in order to avoid an API call. If you change this property from ``false`` to ``true`` or undefined, you may need to clear the corresponding context entry in ``cdk.context.json`` in order to trigger a new lookup. Default: true\n')
    subnet_group_name_tag: typing.Optional[str] = pydantic.Field(None, description="Optional tag for subnet group name. If not provided, we'll look at the aws-cdk:subnet-name tag. If the subnet does not have the specified tag, we'll use its type as the name. Default: aws-cdk:subnet-name\n")
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description="Tags on the VPC. The VPC must have all of these tags Default: Don't filter on tags\n")
    vpc_id: typing.Optional[str] = pydantic.Field(None, description="The ID of the VPC. If given, will import exactly this VPC. Default: Don't filter on vpcId\n")
    vpc_name: typing.Optional[str] = pydantic.Field(None, description="The name of the VPC. If given, will import the VPC with this name. Default: Don't filter on vpcName")
    ...

class VpcDefFromVpcAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    availability_zones: typing.Sequence[str] = pydantic.Field(..., description='List of availability zones for the subnets in this VPC.\n')
    vpc_id: str = pydantic.Field(..., description="VPC's identifier.\n")
    isolated_subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of isolated subnet IDs. Must be undefined or match the availability zones in length and order. Default: - The VPC does not have any isolated subnets\n')
    isolated_subnet_ipv4_cidr_blocks: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of IPv4 CIDR blocks for the isolated subnets. Must be undefined or have an entry for every isolated subnet group. Default: - Retrieving the IPv4 CIDR block of any isolated subnet will fail\n')
    isolated_subnet_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of names for the isolated subnets. Must be undefined or have a name for every isolated subnet group. Default: - All isolated subnets will have the name ``Isolated``\n')
    isolated_subnet_route_table_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of IDs of route tables for the isolated subnets. Must be undefined or have a name for every isolated subnet group. Default: - Retrieving the route table ID of any isolated subnet will fail\n')
    private_subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of private subnet IDs. Must be undefined or match the availability zones in length and order. Default: - The VPC does not have any private subnets\n')
    private_subnet_ipv4_cidr_blocks: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of IPv4 CIDR blocks for the private subnets. Must be undefined or have an entry for every private subnet group. Default: - Retrieving the IPv4 CIDR block of any private subnet will fail\n')
    private_subnet_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of names for the private subnets. Must be undefined or have a name for every private subnet group. Default: - All private subnets will have the name ``Private``\n')
    private_subnet_route_table_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of IDs of route tables for the private subnets. Must be undefined or have a name for every private subnet group. Default: - Retrieving the route table ID of any private subnet will fail\n')
    public_subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of public subnet IDs. Must be undefined or match the availability zones in length and order. Default: - The VPC does not have any public subnets\n')
    public_subnet_ipv4_cidr_blocks: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of IPv4 CIDR blocks for the public subnets. Must be undefined or have an entry for every public subnet group. Default: - Retrieving the IPv4 CIDR block of any public subnet will fail\n')
    public_subnet_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of names for the public subnets. Must be undefined or have a name for every public subnet group. Default: - All public subnets will have the name ``Public``\n')
    public_subnet_route_table_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of IDs of route tables for the public subnets. Must be undefined or have a name for every public subnet group. Default: - Retrieving the route table ID of any public subnet will fail\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region the VPC is in. Default: - The region of the stack where the VPC belongs to\n')
    vpc_cidr_block: typing.Optional[str] = pydantic.Field(None, description="VPC's CIDR range. Default: - Retrieving the CIDR from the VPC will fail\n")
    vpn_gateway_id: typing.Optional[str] = pydantic.Field(None, description="VPN gateway's identifier.")
    ...

class VpcDefSelectSubnetsParams(pydantic.BaseModel):
    availability_zones: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Select subnets only in the given AZs. Default: no filtering on AZs is done\n')
    one_per_az: typing.Optional[bool] = pydantic.Field(None, description='If true, return at most one subnet per AZ. Default: false\n')
    subnet_filters: typing.Optional[typing.Sequence[models.aws_ec2.SubnetFilterDef]] = pydantic.Field(None, description='List of provided subnet filters. Default: - none\n')
    subnet_group_name: typing.Optional[str] = pydantic.Field(None, description='Select the subnet group with the given name. Select the subnet group with the given name. This only needs to be used if you have multiple subnet groups of the same type and you need to distinguish between them. Otherwise, prefer ``subnetType``. This field does not select individual subnets, it selects all subnets that share the given subnet group name. This is the name supplied in ``subnetConfiguration``. At most one of ``subnetType`` and ``subnetGroupName`` can be supplied. Default: - Selection by type instead of by name\n')
    subnets: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.PrivateSubnetDef, models.aws_ec2.PublicSubnetDef, models.aws_ec2.SubnetDef]]] = pydantic.Field(None, description="Explicitly select individual subnets. Use this if you don't want to automatically use all subnets in a group, but have a need to control selection down to individual subnets. Cannot be specified together with ``subnetType`` or ``subnetGroupName``. Default: - Use all subnets in a selected group (all private subnets by default)\n")
    subnet_type: typing.Optional[aws_cdk.aws_ec2.SubnetType] = pydantic.Field(None, description='Select all subnets of the given type. At most one of ``subnetType`` and ``subnetGroupName`` can be supplied. Default: SubnetType.PRIVATE_WITH_EGRESS (or ISOLATED or PUBLIC if there are no PRIVATE_WITH_EGRESS subnets)')
    ...


#  autogenerated from aws_cdk.aws_ec2.VpcEndpointService
class VpcEndpointServiceDef(BaseConstruct):
    vpc_endpoint_service_load_balancers: typing.Sequence[models.UnsupportedResource] = pydantic.Field(..., description='One or more load balancers to host the VPC Endpoint Service.\n')
    acceptance_required: typing.Optional[bool] = pydantic.Field(None, description='Whether requests from service consumers to connect to the service through an endpoint must be accepted. Default: true\n')
    allowed_principals: typing.Optional[typing.Sequence[models.aws_iam.ArnPrincipalDef]] = pydantic.Field(None, description='IAM users, IAM roles, or AWS accounts to allow inbound connections from. These principals can connect to your service using VPC endpoints. Takes a list of one or more ArnPrincipal. Default: - no principals')
    _init_params: typing.ClassVar[list[str]] = ['vpc_endpoint_service_load_balancers', 'acceptance_required', 'allowed_principals']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.VpcEndpointService'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[VpcEndpointServiceDefConfig] = pydantic.Field(None)


class VpcEndpointServiceDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class VpcEndpointServiceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.VpnConnection
class VpnConnectionDef(BaseConstruct):
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='The VPC to connect to.\n')
    ip: str = pydantic.Field(..., description='The ip address of the customer gateway.\n')
    asn: typing.Union[int, float, None] = pydantic.Field(None, description='The ASN of the customer gateway. Default: 65000\n')
    static_routes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The static routes to be routed from the VPN gateway to the customer gateway. Default: Dynamic routing (BGP)\n')
    tunnel_options: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.VpnTunnelOptionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tunnel options for the VPN connection. At most two elements (one per tunnel). Duplicates not allowed. Default: Amazon generated tunnel options')
    _init_params: typing.ClassVar[list[str]] = ['vpc', 'ip', 'asn', 'static_routes', 'tunnel_options']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy', 'metric', 'metric_tunnel_data_in', 'metric_tunnel_data_out', 'metric_tunnel_state']
    _classmethod_names: typing.ClassVar[list[str]] = ['from_vpn_connection_attributes', 'metric_all', 'metric_all_tunnel_data_in', 'metric_all_tunnel_data_out', 'metric_all_tunnel_state']
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.VpnConnection'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = ['from_vpn_connection_attributes', 'metric_all', 'metric_all_tunnel_data_in', 'metric_all_tunnel_data_out', 'metric_all_tunnel_state']
    ...


    from_vpn_connection_attributes: typing.Optional[VpnConnectionDefFromVpnConnectionAttributesParams] = pydantic.Field(None, description='Import a VPN connection by supplying all attributes directly.')
    metric_all: typing.Optional[VpnConnectionDefMetricAllParams] = pydantic.Field(None, description='Return the given named metric for all VPN connections in the account/region.')
    metric_all_tunnel_data_in: typing.Optional[VpnConnectionDefMetricAllTunnelDataInParams] = pydantic.Field(None, description='Metric for the tunnel data in of all VPN connections in the account/region.')
    metric_all_tunnel_data_out: typing.Optional[VpnConnectionDefMetricAllTunnelDataOutParams] = pydantic.Field(None, description='Metric for the tunnel data out of all VPN connections.')
    metric_all_tunnel_state: typing.Optional[VpnConnectionDefMetricAllTunnelStateParams] = pydantic.Field(None, description='Metric for the tunnel state of all VPN connections in the account/region.')
    resource_config: typing.Optional[VpnConnectionDefConfig] = pydantic.Field(None)


class VpnConnectionDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    metric: typing.Optional[list[VpnConnectionDefMetricParams]] = pydantic.Field(None, description='Return the given named metric for this VPNConnection.')
    metric_tunnel_data_in: typing.Optional[list[VpnConnectionDefMetricTunnelDataInParams]] = pydantic.Field(None, description='The bytes received through the VPN tunnel.\nSum over 5 minutes')
    metric_tunnel_data_out: typing.Optional[list[VpnConnectionDefMetricTunnelDataOutParams]] = pydantic.Field(None, description='The bytes sent through the VPN tunnel.\nSum over 5 minutes')
    metric_tunnel_state: typing.Optional[list[VpnConnectionDefMetricTunnelStateParams]] = pydantic.Field(None, description='The state of the tunnel. 0 indicates DOWN and 1 indicates UP.\nAverage over 5 minutes')

class VpnConnectionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...

class VpnConnectionDefFromVpnConnectionAttributesParams(pydantic.BaseModel):
    scope: models.constructs.ConstructDef = pydantic.Field(..., description='-\n')
    id: str = pydantic.Field(..., description='-\n')
    customer_gateway_asn: typing.Union[int, float] = pydantic.Field(..., description='The ASN of the customer gateway.\n')
    customer_gateway_id: str = pydantic.Field(..., description='The id of the customer gateway.\n')
    customer_gateway_ip: str = pydantic.Field(..., description='The ip address of the customer gateway.\n')
    vpn_id: str = pydantic.Field(..., description='The id of the VPN connection.')
    ...

class VpnConnectionDefMetricParams(pydantic.BaseModel):
    metric_name: str = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class VpnConnectionDefMetricAllParams(pydantic.BaseModel):
    metric_name: str = pydantic.Field(..., description='-\n')
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    ...

class VpnConnectionDefMetricAllTunnelDataInParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: sum over 5 minutes\n')
    ...

class VpnConnectionDefMetricAllTunnelDataOutParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: sum over 5 minutes\n')
    ...

class VpnConnectionDefMetricAllTunnelStateParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream\n\n:default: average over 5 minutes\n')
    ...

class VpnConnectionDefMetricTunnelDataInParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class VpnConnectionDefMetricTunnelDataOutParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...

class VpnConnectionDefMetricTunnelStateParams(pydantic.BaseModel):
    account: typing.Optional[str] = pydantic.Field(None, description='Account which this metric comes from. Default: - Deployment account.\n')
    color: typing.Optional[str] = pydantic.Field(None, description="The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color\n")
    dimensions_map: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Dimensions of the metric. Default: - No dimensions.\n')
    label: typing.Optional[str] = pydantic.Field(None, description="Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label\n")
    period: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The period over which the specified statistic is applied. Default: Duration.minutes(5)\n')
    region: typing.Optional[str] = pydantic.Field(None, description='Region which this metric comes from. Default: - Deployment region.\n')
    statistic: typing.Optional[str] = pydantic.Field(None, description='What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average\n')
    unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = pydantic.Field(None, description='Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream')
    return_config: typing.Optional[list[models.aws_cloudwatch.MetricDefConfig]] = pydantic.Field(None)
    ...


#  autogenerated from aws_cdk.aws_ec2.VpnGateway
class VpnGatewayDef(BaseConstruct):
    type: str = pydantic.Field(..., description='Default type ipsec.1.\n')
    amazon_side_asn: typing.Union[int, float, None] = pydantic.Field(None, description='Explicitly specify an Asn or let aws pick an Asn for you. Default: 65000')
    _init_params: typing.ClassVar[list[str]] = ['type', 'amazon_side_asn']
    _method_names: typing.ClassVar[list[str]] = ['apply_removal_policy']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.VpnGateway'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[VpnGatewayDefConfig] = pydantic.Field(None)


class VpnGatewayDefConfig(pydantic.BaseModel):
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)

class VpnGatewayDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: aws_cdk.RemovalPolicy = pydantic.Field(..., description='-')
    ...


#  autogenerated from aws_cdk.aws_ec2.AclCidrConfig
class AclCidrConfigDef(BaseStruct):
    cidr_block: typing.Optional[str] = pydantic.Field(None, description='Ipv4 CIDR.\n')
    ipv6_cidr_block: typing.Optional[str] = pydantic.Field(None, description='Ipv6 CIDR.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    acl_cidr_config = ec2.AclCidrConfig(\n        cidr_block="cidrBlock",\n        ipv6_cidr_block="ipv6CidrBlock"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cidr_block', 'ipv6_cidr_block']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AclCidrConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.AclIcmp
class AclIcmpDef(BaseStruct):
    code: typing.Union[int, float, None] = pydantic.Field(None, description='The Internet Control Message Protocol (ICMP) code. You can use -1 to specify all ICMP codes for the given ICMP type. Requirement is conditional: Required if you specify 1 (ICMP) for the protocol parameter.\n')
    type: typing.Union[int, float, None] = pydantic.Field(None, description='The Internet Control Message Protocol (ICMP) type. You can use -1 to specify all ICMP types. Conditional requirement: Required if you specify 1 (ICMP) for the CreateNetworkAclEntry protocol parameter.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    acl_icmp = ec2.AclIcmp(\n        code=123,\n        type=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['code', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AclIcmp'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.AclPortRange
class AclPortRangeDef(BaseStruct):
    from_: typing.Union[int, float, None] = pydantic.Field(None, description='The first port in the range. Required if you specify 6 (TCP) or 17 (UDP) for the protocol parameter.\n')
    to: typing.Union[int, float, None] = pydantic.Field(None, description='The last port in the range. Required if you specify 6 (TCP) or 17 (UDP) for the protocol parameter.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    acl_port_range = ec2.AclPortRange(\n        from=123,\n        to=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['from_', 'to']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AclPortRange'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.AclTrafficConfig
class AclTrafficConfigDef(BaseStruct):
    protocol: typing.Union[int, float] = pydantic.Field(..., description='The protocol number. A value of "-1" means all protocols. If you specify "-1" or a protocol number other than "6" (TCP), "17" (UDP), or "1" (ICMP), traffic on all ports is allowed, regardless of any ports or ICMP types or codes that you specify. If you specify protocol "58" (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and codes allowed, regardless of any that you specify. If you specify protocol "58" (ICMPv6) and specify an IPv6 CIDR block, you must specify an ICMP type and code. Default: 17\n')
    icmp: typing.Union[models.aws_ec2.AclIcmpDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The Internet Control Message Protocol (ICMP) code and type. Default: - Required if specifying 1 (ICMP) for the protocol parameter.\n')
    port_range: typing.Union[models.aws_ec2.AclPortRangeDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The range of port numbers for the UDP/TCP protocol. Default: - Required if specifying 6 (TCP) or 17 (UDP) for the protocol parameter\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    acl_traffic_config = ec2.AclTrafficConfig(\n        protocol=123,\n\n        # the properties below are optional\n        icmp=ec2.AclIcmp(\n            code=123,\n            type=123\n        ),\n        port_range=ec2.AclPortRange(\n            from=123,\n            to=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['protocol', 'icmp', 'port_range']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AclTrafficConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.AddRouteOptions
class AddRouteOptionsDef(BaseStruct):
    router_id: str = pydantic.Field(..., description='The ID of the router. Can be an instance ID, gateway ID, etc, depending on the router type.\n')
    router_type: aws_cdk.aws_ec2.RouterType = pydantic.Field(..., description='What type of router to route this traffic to.\n')
    destination_cidr_block: typing.Optional[str] = pydantic.Field(None, description="IPv4 range this route applies to. Default: '0.0.0.0/0'\n")
    destination_ipv6_cidr_block: typing.Optional[str] = pydantic.Field(None, description='IPv6 range this route applies to. Default: - Uses IPv6\n')
    enables_internet_connectivity: typing.Optional[bool] = pydantic.Field(None, description='Whether this route will enable internet connectivity. If true, this route will be added before any AWS resources that depend on internet connectivity in the VPC will be created. Default: false\n\n:exampleMetadata: infused\n\nExample::\n\n    vpc = ec2.Vpc(self, "VPC",\n        subnet_configuration=[ec2.SubnetConfiguration(\n            subnet_type=ec2.SubnetType.PUBLIC,\n            name="Public"\n        ), ec2.SubnetConfiguration(\n            subnet_type=ec2.SubnetType.PRIVATE_ISOLATED,\n            name="Isolated"\n        )]\n    )\n\n    (vpc.isolated_subnets[0]).add_route("StaticRoute",\n        router_id=vpc.internet_gateway_id,\n        router_type=ec2.RouterType.GATEWAY,\n        destination_cidr_block="8.8.8.8/32"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['router_id', 'router_type', 'destination_cidr_block', 'destination_ipv6_cidr_block', 'enables_internet_connectivity']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AddRouteOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.AllocateCidrRequest
class AllocateCidrRequestDef(BaseStruct):
    requested_subnets: typing.Sequence[typing.Union[models.aws_ec2.RequestedSubnetDef, dict[str, typing.Any]]] = pydantic.Field(..., description='The Subnets to be allocated.\n')
    vpc_cidr: str = pydantic.Field(..., description='The IPv4 CIDR block for this Vpc.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    allocate_cidr_request = ec2.AllocateCidrRequest(\n        requested_subnets=[ec2.RequestedSubnet(\n            availability_zone="availabilityZone",\n            configuration=ec2.SubnetConfiguration(\n                name="name",\n                subnet_type=ec2.SubnetType.PRIVATE_ISOLATED,\n\n                # the properties below are optional\n                cidr_mask=123,\n                map_public_ip_on_launch=False,\n                reserved=False\n            ),\n            subnet_construct_id="subnetConstructId"\n        )],\n        vpc_cidr="vpcCidr"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['requested_subnets', 'vpc_cidr']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AllocateCidrRequest'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.AllocatedSubnet
class AllocatedSubnetDef(BaseStruct):
    cidr: str = pydantic.Field(..., description='Cidr Allocations for a Subnet.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    allocated_subnet = ec2.AllocatedSubnet(\n        cidr="cidr"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cidr']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AllocatedSubnet'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.AmazonLinux2022ImageSsmParameterProps
class AmazonLinux2022ImageSsmParameterPropsDef(BaseStruct):
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false\n")
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines\n')
    cpu_type: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxCpuType] = pydantic.Field(None, description='CPU Type. Default: AmazonLinuxCpuType.X86_64\n')
    edition: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxEdition] = pydantic.Field(None, description='What edition of Amazon Linux to use. Default: AmazonLinuxEdition.Standard\n')
    kernel: typing.Optional[models.aws_ec2.AmazonLinux2022KernelDef] = pydantic.Field(None, description='What kernel version of Amazon Linux to use. Default: AmazonLinux2022Kernel.DEFAULT\n\n:exampleMetadata: infused\n\nExample::\n\n    # vpc: ec2.Vpc\n    # instance_type: ec2.InstanceType\n\n\n    # Amazon Linux 2\n    ec2.Instance(self, "Instance2",\n        vpc=vpc,\n        instance_type=instance_type,\n        machine_image=ec2.MachineImage.latest_amazon_linux2()\n    )\n\n    # Amazon Linux 2 with kernel 5.x\n    ec2.Instance(self, "Instance3",\n        vpc=vpc,\n        instance_type=instance_type,\n        machine_image=ec2.MachineImage.latest_amazon_linux2(\n            kernel=ec2.AmazonLinux2Kernel.KERNEL_5_10\n        )\n    )\n\n    # AWS Linux 2022\n    ec2.Instance(self, "Instance4",\n        vpc=vpc,\n        instance_type=instance_type,\n        machine_image=ec2.MachineImage.latest_amazon_linux2022()\n    )\n\n    # Graviton 3 Processor\n    ec2.Instance(self, "Instance5",\n        vpc=vpc,\n        instance_type=ec2.InstanceType.of(ec2.InstanceClass.C7G, ec2.InstanceSize.LARGE),\n        machine_image=ec2.MachineImage.latest_amazon_linux2022(\n            cpu_type=ec2.AmazonLinuxCpuType.ARM_64\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cached_in_context', 'user_data', 'cpu_type', 'edition', 'kernel']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AmazonLinux2022ImageSsmParameterProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.AmazonLinux2023ImageSsmParameterProps
class AmazonLinux2023ImageSsmParameterPropsDef(BaseStruct):
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false\n")
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines\n')
    cpu_type: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxCpuType] = pydantic.Field(None, description='CPU Type. Default: AmazonLinuxCpuType.X86_64\n')
    edition: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxEdition] = pydantic.Field(None, description='What edition of Amazon Linux to use. Default: AmazonLinuxEdition.Standard\n')
    kernel: typing.Optional[models.aws_ec2.AmazonLinux2023KernelDef] = pydantic.Field(None, description='What kernel version of Amazon Linux to use. Default: AmazonLinux2023Kernel.DEFAULT\n\n:exampleMetadata: infused\n\nExample::\n\n    # vpc: ec2.Vpc\n\n\n    ec2.Instance(self, "LatestAl2023",\n        vpc=vpc,\n        instance_type=ec2.InstanceType.of(ec2.InstanceClass.C7G, ec2.InstanceSize.LARGE),\n        machine_image=ec2.MachineImage.latest_amazon_linux2023(\n            cached_in_context=True\n        )\n    )\n\n    # or\n    ec2.Instance(self, "LatestAl2023",\n        vpc=vpc,\n        instance_type=ec2.InstanceType.of(ec2.InstanceClass.C7G, ec2.InstanceSize.LARGE),\n        # context cache is turned on by default\n        machine_image=ec2.AmazonLinux2023ImageSsmParameter()\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cached_in_context', 'user_data', 'cpu_type', 'edition', 'kernel']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AmazonLinux2023ImageSsmParameterProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.AmazonLinux2ImageSsmParameterProps
class AmazonLinux2ImageSsmParameterPropsDef(BaseStruct):
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false\n")
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines\n')
    cpu_type: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxCpuType] = pydantic.Field(None, description='CPU Type. Default: AmazonLinuxCpuType.X86_64\n')
    edition: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxEdition] = pydantic.Field(None, description='What edition of Amazon Linux to use. Default: AmazonLinuxEdition.Standard\n')
    kernel: typing.Optional[models.aws_ec2.AmazonLinux2KernelDef] = pydantic.Field(None, description='What kernel version of Amazon Linux to use. Default: -\n')
    storage: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxStorage] = pydantic.Field(None, description='What storage backed image to use. Default: GeneralPurpose\n')
    virtualization: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxVirt] = pydantic.Field(None, description='Virtualization type. Default: HVM\n\n:exampleMetadata: infused\n\nExample::\n\n    # vpc: ec2.Vpc\n    # instance_type: ec2.InstanceType\n\n\n    # Amazon Linux 2\n    ec2.Instance(self, "Instance2",\n        vpc=vpc,\n        instance_type=instance_type,\n        machine_image=ec2.MachineImage.latest_amazon_linux2()\n    )\n\n    # Amazon Linux 2 with kernel 5.x\n    ec2.Instance(self, "Instance3",\n        vpc=vpc,\n        instance_type=instance_type,\n        machine_image=ec2.MachineImage.latest_amazon_linux2(\n            kernel=ec2.AmazonLinux2Kernel.KERNEL_5_10\n        )\n    )\n\n    # AWS Linux 2022\n    ec2.Instance(self, "Instance4",\n        vpc=vpc,\n        instance_type=instance_type,\n        machine_image=ec2.MachineImage.latest_amazon_linux2022()\n    )\n\n    # Graviton 3 Processor\n    ec2.Instance(self, "Instance5",\n        vpc=vpc,\n        instance_type=ec2.InstanceType.of(ec2.InstanceClass.C7G, ec2.InstanceSize.LARGE),\n        machine_image=ec2.MachineImage.latest_amazon_linux2022(\n            cpu_type=ec2.AmazonLinuxCpuType.ARM_64\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cached_in_context', 'user_data', 'cpu_type', 'edition', 'kernel', 'storage', 'virtualization']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AmazonLinux2ImageSsmParameterProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.AmazonLinuxImageProps
class AmazonLinuxImagePropsDef(BaseStruct):
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false\n")
    cpu_type: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxCpuType] = pydantic.Field(None, description='CPU Type. Default: X86_64\n')
    edition: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxEdition] = pydantic.Field(None, description='What edition of Amazon Linux to use. Default: Standard\n')
    generation: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxGeneration] = pydantic.Field(None, description='What generation of Amazon Linux to use. Default: AmazonLinux\n')
    kernel: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxKernel] = pydantic.Field(None, description='What kernel version of Amazon Linux to use. Default: -\n')
    storage: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxStorage] = pydantic.Field(None, description='What storage backed image to use. Default: GeneralPurpose\n')
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines\n')
    virtualization: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxVirt] = pydantic.Field(None, description='Virtualization type. Default: HVM\n\n:exampleMetadata: infused\n\nExample::\n\n    # vpc: ec2.IVpc\n\n    lb = elb.LoadBalancer(self, "LB",\n        vpc=vpc\n    )\n\n    # instance to add as the target for load balancer.\n    instance = ec2.Instance(self, "targetInstance",\n        vpc=vpc,\n        instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.MICRO),\n        machine_image=ec2.AmazonLinuxImage(generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX_2)\n    )\n    lb.add_target(elb.InstanceTarget(instance))\n')
    _init_params: typing.ClassVar[list[str]] = ['cached_in_context', 'cpu_type', 'edition', 'generation', 'kernel', 'storage', 'user_data', 'virtualization']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AmazonLinuxImageProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.AmazonLinuxImageSsmParameterBaseOptions
class AmazonLinuxImageSsmParameterBaseOptionsDef(BaseStruct):
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false\n")
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # user_data: ec2.UserData\n\n    amazon_linux_image_ssm_parameter_base_options = ec2.AmazonLinuxImageSsmParameterBaseOptions(\n        cached_in_context=False,\n        user_data=user_data\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cached_in_context', 'user_data']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AmazonLinuxImageSsmParameterBaseOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.AmazonLinuxImageSsmParameterBaseProps
class AmazonLinuxImageSsmParameterBasePropsDef(BaseStruct):
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false\n")
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines\n')
    parameter_name: str = pydantic.Field(..., description='The name of the SSM parameter that contains the AMI value.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # user_data: ec2.UserData\n\n    amazon_linux_image_ssm_parameter_base_props = ec2.AmazonLinuxImageSsmParameterBaseProps(\n        parameter_name="parameterName",\n\n        # the properties below are optional\n        cached_in_context=False,\n        user_data=user_data\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cached_in_context', 'user_data', 'parameter_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AmazonLinuxImageSsmParameterBaseProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.AmazonLinuxImageSsmParameterCommonOptions
class AmazonLinuxImageSsmParameterCommonOptionsDef(BaseStruct):
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false\n")
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines\n')
    cpu_type: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxCpuType] = pydantic.Field(None, description='CPU Type. Default: AmazonLinuxCpuType.X86_64\n')
    edition: typing.Optional[aws_cdk.aws_ec2.AmazonLinuxEdition] = pydantic.Field(None, description='What edition of Amazon Linux to use. Default: AmazonLinuxEdition.Standard\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # user_data: ec2.UserData\n\n    amazon_linux_image_ssm_parameter_common_options = ec2.AmazonLinuxImageSsmParameterCommonOptions(\n        cached_in_context=False,\n        cpu_type=ec2.AmazonLinuxCpuType.ARM_64,\n        edition=ec2.AmazonLinuxEdition.STANDARD,\n        user_data=user_data\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cached_in_context', 'user_data', 'cpu_type', 'edition']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AmazonLinuxImageSsmParameterCommonOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.ApplyCloudFormationInitOptions
class ApplyCloudFormationInitOptionsDef(BaseStruct):
    config_sets: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="ConfigSet to activate. Default: ['default']\n")
    embed_fingerprint: typing.Optional[bool] = pydantic.Field(None, description='Force instance replacement by embedding a config fingerprint. If ``true`` (the default), a hash of the config will be embedded into the UserData, so that if the config changes, the UserData changes. - If the EC2 instance is instance-store backed or ``userDataCausesReplacement`` is set, this will cause the instance to be replaced and the new configuration to be applied. - If the instance is EBS-backed and ``userDataCausesReplacement`` is not set, the change of UserData will make the instance restart but not be replaced, and the configuration will not be applied automatically. If ``false``, no hash will be embedded, and if the CloudFormation Init config changes nothing will happen to the running instance. If a config update introduces errors, you will not notice until after the CloudFormation deployment successfully finishes and the next instance fails to launch. Default: true\n')
    ignore_failures: typing.Optional[bool] = pydantic.Field(None, description="Don't fail the instance creation when cfn-init fails. You can use this to prevent CloudFormation from rolling back when instances fail to start up, to help in debugging. Default: false\n")
    include_role: typing.Optional[bool] = pydantic.Field(None, description='Include --role argument when running cfn-init and cfn-signal commands. This will be the IAM instance profile attached to the EC2 instance Default: false\n')
    include_url: typing.Optional[bool] = pydantic.Field(None, description='Include --url argument when running cfn-init and cfn-signal commands. This will be the cloudformation endpoint in the deployed region e.g. https://cloudformation.us-east-1.amazonaws.com Default: false\n')
    print_log: typing.Optional[bool] = pydantic.Field(None, description='Print the results of running cfn-init to the Instance System Log. By default, the output of running cfn-init is written to a log file on the instance. Set this to ``true`` to print it to the System Log (visible from the EC2 Console), ``false`` to not print it. (Be aware that the system log is refreshed at certain points in time of the instance life cycle, and successful execution may not always show up). Default: true\n')
    timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Timeout waiting for the configuration to be applied. Default: Duration.minutes(5)\n\n:exampleMetadata: infused\n\nExample::\n\n    # vpc: ec2.Vpc\n    # instance_type: ec2.InstanceType\n    # machine_image: ec2.IMachineImage\n\n\n    ec2.Instance(self, "Instance",\n        vpc=vpc,\n        instance_type=instance_type,\n        machine_image=machine_image,\n\n        # Showing the most complex setup, if you have simpler requirements\n        # you can use `CloudFormationInit.fromElements()`.\n        init=ec2.CloudFormationInit.from_config_sets(\n            config_sets={\n                # Applies the configs below in this order\n                "default": ["yumPreinstall", "config"]\n            },\n            configs={\n                "yum_preinstall": ec2.InitConfig([\n                    # Install an Amazon Linux package using yum\n                    ec2.InitPackage.yum("git")\n                ]),\n                "config": ec2.InitConfig([\n                    # Create a JSON file from tokens (can also create other files)\n                    ec2.InitFile.from_object("/etc/stack.json", {\n                        "stack_id": Stack.of(self).stack_id,\n                        "stack_name": Stack.of(self).stack_name,\n                        "region": Stack.of(self).region\n                    }),\n\n                    # Create a group and user\n                    ec2.InitGroup.from_name("my-group"),\n                    ec2.InitUser.from_name("my-user"),\n\n                    # Install an RPM from the internet\n                    ec2.InitPackage.rpm("http://mirrors.ukfast.co.uk/sites/dl.fedoraproject.org/pub/epel/8/Everything/x86_64/Packages/r/rubygem-git-1.5.0-2.el8.noarch.rpm")\n                ])\n            }\n        ),\n        init_options=ec2.ApplyCloudFormationInitOptions(\n            # Optional, which configsets to activate ([\'default\'] by default)\n            config_sets=["default"],\n\n            # Optional, how long the installation is expected to take (5 minutes by default)\n            timeout=Duration.minutes(30),\n\n            # Optional, whether to include the --url argument when running cfn-init and cfn-signal commands (false by default)\n            include_url=True,\n\n            # Optional, whether to include the --role argument when running cfn-init and cfn-signal commands (false by default)\n            include_role=True\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['config_sets', 'embed_fingerprint', 'ignore_failures', 'include_role', 'include_url', 'print_log', 'timeout']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.ApplyCloudFormationInitOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.AttachInitOptions
class AttachInitOptionsDef(BaseStruct):
    instance_role: typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef] = pydantic.Field(..., description='Instance role of the consuming instance or fleet.\n')
    platform: aws_cdk.aws_ec2.OperatingSystemType = pydantic.Field(..., description='OS Platform the init config will be used for.\n')
    user_data: models.aws_ec2.UserDataDef = pydantic.Field(..., description='UserData to add commands to.\n')
    config_sets: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="ConfigSet to activate. Default: ['default']\n")
    embed_fingerprint: typing.Optional[bool] = pydantic.Field(None, description='Whether to embed a hash into the userData. If ``true`` (the default), a hash of the config will be embedded into the UserData, so that if the config changes, the UserData changes and the instance will be replaced. If ``false``, no such hash will be embedded, and if the CloudFormation Init config changes nothing will happen to the running instance. Default: true\n')
    ignore_failures: typing.Optional[bool] = pydantic.Field(None, description="Don't fail the instance creation when cfn-init fails. You can use this to prevent CloudFormation from rolling back when instances fail to start up, to help in debugging. Default: false\n")
    include_role: typing.Optional[bool] = pydantic.Field(None, description='Include --role argument when running cfn-init and cfn-signal commands. This will be the IAM instance profile attached to the EC2 instance Default: false\n')
    include_url: typing.Optional[bool] = pydantic.Field(None, description='Include --url argument when running cfn-init and cfn-signal commands. This will be the cloudformation endpoint in the deployed region e.g. https://cloudformation.us-east-1.amazonaws.com Default: false\n')
    print_log: typing.Optional[bool] = pydantic.Field(None, description='Print the results of running cfn-init to the Instance System Log. By default, the output of running cfn-init is written to a log file on the instance. Set this to ``true`` to print it to the System Log (visible from the EC2 Console), ``false`` to not print it. (Be aware that the system log is refreshed at certain points in time of the instance life cycle, and successful execution may not always show up). Default: true\n')
    signal_resource: typing.Optional[models.CfnResourceDef] = pydantic.Field(None, description='When provided, signals this resource instead of the attached resource. You can use this to support signaling LaunchTemplate while attaching AutoScalingGroup Default: - if this property is undefined cfn-signal signals the attached resource\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_ec2 as ec2\n    from aws_cdk import aws_iam as iam\n\n    # cfn_resource: cdk.CfnResource\n    # role: iam.Role\n    # user_data: ec2.UserData\n\n    attach_init_options = ec2.AttachInitOptions(\n        instance_role=role,\n        platform=ec2.OperatingSystemType.LINUX,\n        user_data=user_data,\n\n        # the properties below are optional\n        config_sets=["configSets"],\n        embed_fingerprint=False,\n        ignore_failures=False,\n        include_role=False,\n        include_url=False,\n        print_log=False,\n        signal_resource=cfn_resource\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_role', 'platform', 'user_data', 'config_sets', 'embed_fingerprint', 'ignore_failures', 'include_role', 'include_url', 'print_log', 'signal_resource']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AttachInitOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[AttachInitOptionsDefConfig] = pydantic.Field(None)


class AttachInitOptionsDefConfig(pydantic.BaseModel):
    instance_role_config: typing.Optional[models._interface_methods.AwsIamIRoleDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ec2.AwsIpamProps
class AwsIpamPropsDef(BaseStruct):
    ipv4_ipam_pool_id: str = pydantic.Field(..., description='Ipam Pool Id for ipv4 allocation.\n')
    ipv4_netmask_length: typing.Union[int, float] = pydantic.Field(..., description='Netmask length for Vpc.\n')
    default_subnet_ipv4_netmask_length: typing.Union[int, float, None] = pydantic.Field(None, description='Default length for Subnet ipv4 Network mask. Specify this option only if you do not specify all Subnets using SubnetConfiguration with a cidrMask Default: - Default ipv4 Subnet Mask for subnets in Vpc\n\n:exampleMetadata: infused\n\nExample::\n\n    from aws_cdk.aws_ec2 import IpAddresses\n\n    # pool: ec2.CfnIPAMPool\n\n\n    ec2.Vpc(self, "TheVPC",\n        ip_addresses=IpAddresses.aws_ipam_allocation(\n            ipv4_ipam_pool_id=pool.ref,\n            ipv4_netmask_length=18,\n            default_subnet_ipv4_netmask_length=24\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ipv4_ipam_pool_id', 'ipv4_netmask_length', 'default_subnet_ipv4_netmask_length']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.AwsIpamProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.BastionHostLinuxProps
class BastionHostLinuxPropsDef(BaseStruct):
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='VPC to launch the instance in.\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='In which AZ to place the instance within the VPC. Default: - Random zone.\n')
    block_devices: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.BlockDeviceDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Specifies how block devices are exposed to the instance. You can specify virtual devices and EBS volumes. Each instance that is launched has an associated root device volume, either an Amazon EBS volume or an instance store volume. You can use block device mappings to specify additional EBS volumes or instance store volumes to attach to an instance when it is launched. Default: - Uses the block device mapping of the AMI\n')
    init: typing.Optional[models.aws_ec2.CloudFormationInitDef] = pydantic.Field(None, description='Apply the given CloudFormation Init configuration to the instance at startup. Default: - no CloudFormation init\n')
    init_options: typing.Union[models.aws_ec2.ApplyCloudFormationInitOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Use the given options for applying CloudFormation Init. Describes the configsets to use and the timeout to wait Default: - default options\n')
    instance_name: typing.Optional[str] = pydantic.Field(None, description="The name of the instance. Default: 'BastionHost'\n")
    instance_type: typing.Optional[models.aws_ec2.InstanceTypeDef] = pydantic.Field(None, description="Type of instance to launch. Default: 't3.nano'\n")
    machine_image: typing.Optional[typing.Union[models.aws_ec2.AmazonLinux2022ImageSsmParameterDef, models.aws_ec2.AmazonLinux2023ImageSsmParameterDef, models.aws_ec2.AmazonLinux2ImageSsmParameterDef, models.aws_ec2.AmazonLinuxImageDef, models.aws_ec2.AmazonLinuxImageSsmParameterBaseDef, models.aws_ec2.GenericLinuxImageDef, models.aws_ec2.GenericSSMParameterImageDef, models.aws_ec2.GenericWindowsImageDef, models.aws_ec2.LookupMachineImageDef, models.aws_ec2.NatInstanceImageDef, models.aws_ec2.WindowsImageDef, models.aws_ecs.BottleRocketImageDef, models.aws_ecs.EcsOptimizedImageDef, models.aws_eks.EksOptimizedImageDef]] = pydantic.Field(None, description='The machine image to use, assumed to have SSM Agent preinstalled. Default: - An Amazon Linux 2 image which is kept up-to-date automatically (the instance may be replaced on every deployment) and already has SSM Agent installed.\n')
    require_imdsv2: typing.Optional[bool] = pydantic.Field(None, description='Whether IMDSv2 should be required on this instance. Default: - false\n')
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='Security Group to assign to this instance. Default: - create new security group with no inbound and all outbound traffic allowed\n')
    subnet_selection: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Select the subnets to run the bastion host in. Set this to PUBLIC if you need to connect to this instance via the internet and cannot use SSM. You have to allow port 22 manually by using the connections field Default: - private subnets of the supplied VPC\n\n:exampleMetadata: fixture=with-vpc infused\n\nExample::\n\n    host = ec2.BastionHostLinux(self, "BastionHost",\n        vpc=vpc,\n        block_devices=[ec2.BlockDevice(\n            device_name="EBSBastionHost",\n            volume=ec2.BlockDeviceVolume.ebs(10,\n                encrypted=True\n            )\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['vpc', 'availability_zone', 'block_devices', 'init', 'init_options', 'instance_name', 'instance_type', 'machine_image', 'require_imdsv2', 'security_group', 'subnet_selection']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.BastionHostLinuxProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.BlockDevice
class BlockDeviceDef(BaseStruct):
    device_name: str = pydantic.Field(..., description='The device name exposed to the EC2 instance. For example, a value like ``/dev/sdh``, ``xvdh``.\n')
    volume: models.aws_ec2.BlockDeviceVolumeDef = pydantic.Field(..., description='Defines the block device volume, to be either an Amazon EBS volume or an ephemeral instance store volume. For example, a value like ``BlockDeviceVolume.ebs(15)``, ``BlockDeviceVolume.ephemeral(0)``.\n')
    mapping_enabled: typing.Optional[bool] = pydantic.Field(None, description='If false, the device mapping will be suppressed. If set to false for the root device, the instance might fail the Amazon EC2 health check. Amazon EC2 Auto Scaling launches a replacement instance if the instance fails the health check. Default: true - device mapping is left untouched\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # block_device_volume: ec2.BlockDeviceVolume\n\n    block_device = ec2.BlockDevice(\n        device_name="deviceName",\n        volume=block_device_volume,\n\n        # the properties below are optional\n        mapping_enabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['device_name', 'volume', 'mapping_enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.BlockDevice'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnCapacityReservation.TagSpecificationProperty
class CfnCapacityReservation_TagSpecificationPropertyDef(BaseStruct):
    resource_type: typing.Optional[str] = pydantic.Field(None, description='The type of resource to tag. Specify ``capacity-reservation`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to apply to the resource.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    tag_specification_property = ec2.CfnCapacityReservation.TagSpecificationProperty(\n        resource_type="resourceType",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resource_type', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnCapacityReservation.TagSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnCapacityReservationFleet.InstanceTypeSpecificationProperty
class CfnCapacityReservationFleet_InstanceTypeSpecificationPropertyDef(BaseStruct):
    availability_zone: typing.Optional[str] = pydantic.Field(None, description="The Availability Zone in which the Capacity Reservation Fleet reserves the capacity. A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.\n")
    availability_zone_id: typing.Optional[str] = pydantic.Field(None, description="The ID of the Availability Zone in which the Capacity Reservation Fleet reserves the capacity. A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.\n")
    ebs_optimized: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Indicates whether the Capacity Reservation Fleet supports EBS-optimized instances types. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using EBS-optimized instance types.\n")
    instance_platform: typing.Optional[str] = pydantic.Field(None, description='The type of operating system for which the Capacity Reservation Fleet reserves capacity.\n')
    instance_type: typing.Optional[str] = pydantic.Field(None, description='The instance type for which the Capacity Reservation Fleet reserves capacity.\n')
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='The priority to assign to the instance type. This value is used to determine which of the instance types specified for the Fleet should be prioritized for use. A lower value indicates a high priority. For more information, see `Instance type priority <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#instance-priority>`_ in the Amazon EC2 User Guide.\n')
    weight: typing.Union[int, float, None] = pydantic.Field(None, description='The number of capacity units provided by the specified instance type. This value, together with the total target capacity that you specify for the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see `Total target capacity <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity>`_ in the Amazon EC2 User Guide. Valid Range: Minimum value of ``0.001`` . Maximum value of ``99.999`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    instance_type_specification_property = ec2.CfnCapacityReservationFleet.InstanceTypeSpecificationProperty(\n        availability_zone="availabilityZone",\n        availability_zone_id="availabilityZoneId",\n        ebs_optimized=False,\n        instance_platform="instancePlatform",\n        instance_type="instanceType",\n        priority=123,\n        weight=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'availability_zone_id', 'ebs_optimized', 'instance_platform', 'instance_type', 'priority', 'weight']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnCapacityReservationFleet.InstanceTypeSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnCapacityReservationFleet.TagSpecificationProperty
class CfnCapacityReservationFleet_TagSpecificationPropertyDef(BaseStruct):
    resource_type: typing.Optional[str] = pydantic.Field(None, description='The type of resource to tag on creation. Specify ``capacity-reservation-fleet`` . To tag a resource after it has been created, see `CreateTags <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html>`_ .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to apply to the resource.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    tag_specification_property = ec2.CfnCapacityReservationFleet.TagSpecificationProperty(\n        resource_type="resourceType",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resource_type', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnCapacityReservationFleet.TagSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnClientVpnEndpoint.CertificateAuthenticationRequestProperty
class CfnClientVpnEndpoint_CertificateAuthenticationRequestPropertyDef(BaseStruct):
    client_root_certificate_chain_arn: str = pydantic.Field(..., description='The ARN of the client certificate. The certificate must be signed by a certificate authority (CA) and it must be provisioned in AWS Certificate Manager (ACM).\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-certificateauthenticationrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    certificate_authentication_request_property = ec2.CfnClientVpnEndpoint.CertificateAuthenticationRequestProperty(\n        client_root_certificate_chain_arn="clientRootCertificateChainArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['client_root_certificate_chain_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnClientVpnEndpoint.CertificateAuthenticationRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnClientVpnEndpoint.ClientAuthenticationRequestProperty
class CfnClientVpnEndpoint_ClientAuthenticationRequestPropertyDef(BaseStruct):
    type: str = pydantic.Field(..., description='The type of client authentication to be used.\n')
    active_directory: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnClientVpnEndpoint_DirectoryServiceAuthenticationRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about the Active Directory to be used, if applicable. You must provide this information if *Type* is ``directory-service-authentication`` .\n')
    federated_authentication: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnClientVpnEndpoint_FederatedAuthenticationRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about the IAM SAML identity provider, if applicable.\n')
    mutual_authentication: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnClientVpnEndpoint_CertificateAuthenticationRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about the authentication certificates to be used, if applicable. You must provide this information if *Type* is ``certificate-authentication`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    client_authentication_request_property = ec2.CfnClientVpnEndpoint.ClientAuthenticationRequestProperty(\n        type="type",\n\n        # the properties below are optional\n        active_directory=ec2.CfnClientVpnEndpoint.DirectoryServiceAuthenticationRequestProperty(\n            directory_id="directoryId"\n        ),\n        federated_authentication=ec2.CfnClientVpnEndpoint.FederatedAuthenticationRequestProperty(\n            saml_provider_arn="samlProviderArn",\n\n            # the properties below are optional\n            self_service_saml_provider_arn="selfServiceSamlProviderArn"\n        ),\n        mutual_authentication=ec2.CfnClientVpnEndpoint.CertificateAuthenticationRequestProperty(\n            client_root_certificate_chain_arn="clientRootCertificateChainArn"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'active_directory', 'federated_authentication', 'mutual_authentication']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnClientVpnEndpoint.ClientAuthenticationRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnClientVpnEndpoint.ClientConnectOptionsProperty
class CfnClientVpnEndpoint_ClientConnectOptionsPropertyDef(BaseStruct):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='Indicates whether client connect options are enabled. The default is ``false`` (not enabled).\n')
    lambda_function_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the AWS Lambda function used for connection authorization.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    client_connect_options_property = ec2.CfnClientVpnEndpoint.ClientConnectOptionsProperty(\n        enabled=False,\n\n        # the properties below are optional\n        lambda_function_arn="lambdaFunctionArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'lambda_function_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnClientVpnEndpoint.ClientConnectOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty
class CfnClientVpnEndpoint_ClientLoginBannerOptionsPropertyDef(BaseStruct):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='Enable or disable a customizable text banner that will be displayed on AWS provided clients when a VPN session is established. Valid values: ``true | false`` Default value: ``false``\n')
    banner_text: typing.Optional[str] = pydantic.Field(None, description='Customizable text that will be displayed in a banner on AWS provided clients when a VPN session is established. UTF-8 encoded characters only. Maximum of 1400 characters.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    client_login_banner_options_property = ec2.CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty(\n        enabled=False,\n\n        # the properties below are optional\n        banner_text="bannerText"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'banner_text']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnClientVpnEndpoint.ConnectionLogOptionsProperty
class CfnClientVpnEndpoint_ConnectionLogOptionsPropertyDef(BaseStruct):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='Indicates whether connection logging is enabled.\n')
    cloudwatch_log_group: typing.Optional[str] = pydantic.Field(None, description='The name of the CloudWatch Logs log group. Required if connection logging is enabled.\n')
    cloudwatch_log_stream: typing.Optional[str] = pydantic.Field(None, description='The name of the CloudWatch Logs log stream to which the connection data is published.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    connection_log_options_property = ec2.CfnClientVpnEndpoint.ConnectionLogOptionsProperty(\n        enabled=False,\n\n        # the properties below are optional\n        cloudwatch_log_group="cloudwatchLogGroup",\n        cloudwatch_log_stream="cloudwatchLogStream"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'cloudwatch_log_group', 'cloudwatch_log_stream']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnClientVpnEndpoint.ConnectionLogOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnClientVpnEndpoint.DirectoryServiceAuthenticationRequestProperty
class CfnClientVpnEndpoint_DirectoryServiceAuthenticationRequestPropertyDef(BaseStruct):
    directory_id: str = pydantic.Field(..., description='The ID of the Active Directory to be used for authentication.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-directoryserviceauthenticationrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    directory_service_authentication_request_property = ec2.CfnClientVpnEndpoint.DirectoryServiceAuthenticationRequestProperty(\n        directory_id="directoryId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['directory_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnClientVpnEndpoint.DirectoryServiceAuthenticationRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnClientVpnEndpoint.FederatedAuthenticationRequestProperty
class CfnClientVpnEndpoint_FederatedAuthenticationRequestPropertyDef(BaseStruct):
    saml_provider_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the IAM SAML identity provider.\n')
    self_service_saml_provider_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the IAM SAML identity provider for the self-service portal.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-federatedauthenticationrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    federated_authentication_request_property = ec2.CfnClientVpnEndpoint.FederatedAuthenticationRequestProperty(\n        saml_provider_arn="samlProviderArn",\n\n        # the properties below are optional\n        self_service_saml_provider_arn="selfServiceSamlProviderArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['saml_provider_arn', 'self_service_saml_provider_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnClientVpnEndpoint.FederatedAuthenticationRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnClientVpnEndpoint.TagSpecificationProperty
class CfnClientVpnEndpoint_TagSpecificationPropertyDef(BaseStruct):
    resource_type: str = pydantic.Field(..., description='The type of resource to tag.\n')
    tags: typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]] = pydantic.Field(..., description='The tags to apply to the resource.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    tag_specification_property = ec2.CfnClientVpnEndpoint.TagSpecificationProperty(\n        resource_type="resourceType",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resource_type', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnClientVpnEndpoint.TagSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet.AcceleratorCountRequestProperty
class CfnEC2Fleet_AcceleratorCountRequestPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of accelerators. To specify no minimum limit, omit this parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratorcountrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    accelerator_count_request_property = ec2.CfnEC2Fleet.AcceleratorCountRequestProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet.AcceleratorCountRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty
class CfnEC2Fleet_AcceleratorTotalMemoryMiBRequestPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratortotalmemorymibrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    accelerator_total_memory_mi_bRequest_property = ec2.CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty
class CfnEC2Fleet_BaselineEbsBandwidthMbpsRequestPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-baselineebsbandwidthmbpsrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    baseline_ebs_bandwidth_mbps_request_property = ec2.CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet.CapacityRebalanceProperty
class CfnEC2Fleet_CapacityRebalancePropertyDef(BaseStruct):
    replacement_strategy: typing.Optional[str] = pydantic.Field(None, description='The replacement strategy to use. Only available for fleets of type ``maintain`` . ``launch`` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. EC2 Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running. ``launch-before-terminate`` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in ``TerminationDelay`` ), terminates the instances that received a rebalance notification.\n')
    termination_delay: typing.Union[int, float, None] = pydantic.Field(None, description='The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance. Required when ``ReplacementStrategy`` is set to ``launch-before-terminate`` . Not valid when ``ReplacementStrategy`` is set to ``launch`` . Valid values: Minimum value of ``120`` seconds. Maximum value of ``7200`` seconds.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityrebalance.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    capacity_rebalance_property = ec2.CfnEC2Fleet.CapacityRebalanceProperty(\n        replacement_strategy="replacementStrategy",\n        termination_delay=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['replacement_strategy', 'termination_delay']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet.CapacityRebalanceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet.CapacityReservationOptionsRequestProperty
class CfnEC2Fleet_CapacityReservationOptionsRequestPropertyDef(BaseStruct):
    usage_strategy: typing.Optional[str] = pydantic.Field(None, description='Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity. If you specify ``use-capacity-reservations-first`` , the fleet uses unused Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If multiple instance pools have unused Capacity Reservations, the On-Demand allocation strategy ( ``lowest-price`` or ``prioritized`` ) is applied. If the number of unused Capacity Reservations is less than the On-Demand target capacity, the remaining On-Demand target capacity is launched according to the On-Demand allocation strategy ( ``lowest-price`` or ``prioritized`` ). If you do not specify a value, the fleet fulfils the On-Demand capacity according to the chosen On-Demand allocation strategy.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityreservationoptionsrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    capacity_reservation_options_request_property = ec2.CfnEC2Fleet.CapacityReservationOptionsRequestProperty(\n        usage_strategy="usageStrategy"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['usage_strategy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet.CapacityReservationOptionsRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty
class CfnEC2Fleet_FleetLaunchTemplateConfigRequestPropertyDef(BaseStruct):
    launch_template_specification: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_FleetLaunchTemplateSpecificationRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The launch template to use. You must specify either the launch template ID or launch template name in the request.\n')
    overrides: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_FleetLaunchTemplateOverridesRequestPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Any parameters that you specify override the same parameters in the launch template. For fleets of type ``request`` and ``maintain`` , a maximum of 300 items is allowed across all launch templates.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    fleet_launch_template_config_request_property = ec2.CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty(\n        launch_template_specification=ec2.CfnEC2Fleet.FleetLaunchTemplateSpecificationRequestProperty(\n            version="version",\n\n            # the properties below are optional\n            launch_template_id="launchTemplateId",\n            launch_template_name="launchTemplateName"\n        ),\n        overrides=[ec2.CfnEC2Fleet.FleetLaunchTemplateOverridesRequestProperty(\n            availability_zone="availabilityZone",\n            instance_requirements=ec2.CfnEC2Fleet.InstanceRequirementsRequestProperty(\n                accelerator_count=ec2.CfnEC2Fleet.AcceleratorCountRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                accelerator_manufacturers=["acceleratorManufacturers"],\n                accelerator_names=["acceleratorNames"],\n                accelerator_total_memory_mi_b=ec2.CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                accelerator_types=["acceleratorTypes"],\n                allowed_instance_types=["allowedInstanceTypes"],\n                bare_metal="bareMetal",\n                baseline_ebs_bandwidth_mbps=ec2.CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                burstable_performance="burstablePerformance",\n                cpu_manufacturers=["cpuManufacturers"],\n                excluded_instance_types=["excludedInstanceTypes"],\n                instance_generations=["instanceGenerations"],\n                local_storage="localStorage",\n                local_storage_types=["localStorageTypes"],\n                memory_gi_bPer_vCpu=ec2.CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                memory_mi_b=ec2.CfnEC2Fleet.MemoryMiBRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                network_bandwidth_gbps=ec2.CfnEC2Fleet.NetworkBandwidthGbpsRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                network_interface_count=ec2.CfnEC2Fleet.NetworkInterfaceCountRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                on_demand_max_price_percentage_over_lowest_price=123,\n                require_hibernate_support=False,\n                spot_max_price_percentage_over_lowest_price=123,\n                total_local_storage_gb=ec2.CfnEC2Fleet.TotalLocalStorageGBRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                v_cpu_count=ec2.CfnEC2Fleet.VCpuCountRangeRequestProperty(\n                    max=123,\n                    min=123\n                )\n            ),\n            instance_type="instanceType",\n            max_price="maxPrice",\n            placement=ec2.CfnEC2Fleet.PlacementProperty(\n                affinity="affinity",\n                availability_zone="availabilityZone",\n                group_name="groupName",\n                host_id="hostId",\n                host_resource_group_arn="hostResourceGroupArn",\n                partition_number=123,\n                spread_domain="spreadDomain",\n                tenancy="tenancy"\n            ),\n            priority=123,\n            subnet_id="subnetId",\n            weighted_capacity=123\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['launch_template_specification', 'overrides']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet.FleetLaunchTemplateOverridesRequestProperty
class CfnEC2Fleet_FleetLaunchTemplateOverridesRequestPropertyDef(BaseStruct):
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone in which to launch the instances.\n')
    instance_requirements: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_InstanceRequirementsRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes. .. epigraph:: If you specify ``InstanceRequirements`` , you can't specify ``InstanceType`` .\n")
    instance_type: typing.Optional[str] = pydantic.Field(None, description="The instance type. ``mac1.metal`` is not supported as a launch template override. .. epigraph:: If you specify ``InstanceType`` , you can't specify ``InstanceRequirements`` .\n")
    max_price: typing.Optional[str] = pydantic.Field(None, description='The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price. .. epigraph:: If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.\n')
    placement: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_PlacementPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The location where the instance launched, if applicable.\n')
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='The priority for the launch template override. The highest priority is launched first. If the On-Demand ``AllocationStrategy`` is set to ``prioritized`` , EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. If the Spot ``AllocationStrategy`` is set to ``capacity-optimized-prioritized`` , EC2 Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first. Valid values are whole numbers starting at ``0`` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.\n')
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='The IDs of the subnets in which to launch the instances. Separate multiple subnet IDs using commas (for example, ``subnet-1234abcdeexample1, subnet-0987cdef6example2`` ). A request of type ``instant`` can have only one subnet ID.\n')
    weighted_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='The number of units provided by the specified instance type.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    fleet_launch_template_overrides_request_property = ec2.CfnEC2Fleet.FleetLaunchTemplateOverridesRequestProperty(\n        availability_zone="availabilityZone",\n        instance_requirements=ec2.CfnEC2Fleet.InstanceRequirementsRequestProperty(\n            accelerator_count=ec2.CfnEC2Fleet.AcceleratorCountRequestProperty(\n                max=123,\n                min=123\n            ),\n            accelerator_manufacturers=["acceleratorManufacturers"],\n            accelerator_names=["acceleratorNames"],\n            accelerator_total_memory_mi_b=ec2.CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty(\n                max=123,\n                min=123\n            ),\n            accelerator_types=["acceleratorTypes"],\n            allowed_instance_types=["allowedInstanceTypes"],\n            bare_metal="bareMetal",\n            baseline_ebs_bandwidth_mbps=ec2.CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty(\n                max=123,\n                min=123\n            ),\n            burstable_performance="burstablePerformance",\n            cpu_manufacturers=["cpuManufacturers"],\n            excluded_instance_types=["excludedInstanceTypes"],\n            instance_generations=["instanceGenerations"],\n            local_storage="localStorage",\n            local_storage_types=["localStorageTypes"],\n            memory_gi_bPer_vCpu=ec2.CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty(\n                max=123,\n                min=123\n            ),\n            memory_mi_b=ec2.CfnEC2Fleet.MemoryMiBRequestProperty(\n                max=123,\n                min=123\n            ),\n            network_bandwidth_gbps=ec2.CfnEC2Fleet.NetworkBandwidthGbpsRequestProperty(\n                max=123,\n                min=123\n            ),\n            network_interface_count=ec2.CfnEC2Fleet.NetworkInterfaceCountRequestProperty(\n                max=123,\n                min=123\n            ),\n            on_demand_max_price_percentage_over_lowest_price=123,\n            require_hibernate_support=False,\n            spot_max_price_percentage_over_lowest_price=123,\n            total_local_storage_gb=ec2.CfnEC2Fleet.TotalLocalStorageGBRequestProperty(\n                max=123,\n                min=123\n            ),\n            v_cpu_count=ec2.CfnEC2Fleet.VCpuCountRangeRequestProperty(\n                max=123,\n                min=123\n            )\n        ),\n        instance_type="instanceType",\n        max_price="maxPrice",\n        placement=ec2.CfnEC2Fleet.PlacementProperty(\n            affinity="affinity",\n            availability_zone="availabilityZone",\n            group_name="groupName",\n            host_id="hostId",\n            host_resource_group_arn="hostResourceGroupArn",\n            partition_number=123,\n            spread_domain="spreadDomain",\n            tenancy="tenancy"\n        ),\n        priority=123,\n        subnet_id="subnetId",\n        weighted_capacity=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'instance_requirements', 'instance_type', 'max_price', 'placement', 'priority', 'subnet_id', 'weighted_capacity']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet.FleetLaunchTemplateOverridesRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet.FleetLaunchTemplateSpecificationRequestProperty
class CfnEC2Fleet_FleetLaunchTemplateSpecificationRequestPropertyDef(BaseStruct):
    version: str = pydantic.Field(..., description='The launch template version number, ``$Latest`` , or ``$Default`` . You must specify a value, otherwise the request fails. If the value is ``$Latest`` , Amazon EC2 uses the latest version of the launch template. If the value is ``$Default`` , Amazon EC2 uses the default version of the launch template.\n')
    launch_template_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the launch template. You must specify the ``LaunchTemplateId`` or the ``LaunchTemplateName`` , but not both.\n')
    launch_template_name: typing.Optional[str] = pydantic.Field(None, description='The name of the launch template. You must specify the ``LaunchTemplateName`` or the ``LaunchTemplateId`` , but not both.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    fleet_launch_template_specification_request_property = ec2.CfnEC2Fleet.FleetLaunchTemplateSpecificationRequestProperty(\n        version="version",\n\n        # the properties below are optional\n        launch_template_id="launchTemplateId",\n        launch_template_name="launchTemplateName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['version', 'launch_template_id', 'launch_template_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet.FleetLaunchTemplateSpecificationRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet.InstanceRequirementsRequestProperty
class CfnEC2Fleet_InstanceRequirementsRequestPropertyDef(BaseStruct):
    accelerator_count: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_AcceleratorCountRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` . Default: No minimum or maximum limits\n')
    accelerator_manufacturers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Indicates whether instance types must have accelerators by specific manufacturers. - For instance types with NVIDIA devices, specify ``nvidia`` . - For instance types with AMD devices, specify ``amd`` . - For instance types with AWS devices, specify ``amazon-web-services`` . - For instance types with Xilinx devices, specify ``xilinx`` . Default: Any manufacturer\n')
    accelerator_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The accelerators that must be on the instance type. - For instance types with NVIDIA A100 GPUs, specify ``a100`` . - For instance types with NVIDIA V100 GPUs, specify ``v100`` . - For instance types with NVIDIA K80 GPUs, specify ``k80`` . - For instance types with NVIDIA T4 GPUs, specify ``t4`` . - For instance types with NVIDIA M60 GPUs, specify ``m60`` . - For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520`` . - For instance types with Xilinx VU9P FPGAs, specify ``vu9p`` . - For instance types with AWS Inferentia chips, specify ``inferentia`` . - For instance types with NVIDIA GRID K520 GPUs, specify ``k520`` . Default: Any accelerator\n')
    accelerator_total_memory_mib: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_AcceleratorTotalMemoryMiBRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum amount of total accelerator memory, in MiB. Default: No minimum or maximum limits\n')
    accelerator_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The accelerator types that must be on the instance type. - To include instance types with GPU hardware, specify ``gpu`` . - To include instance types with FPGA hardware, specify ``fpga`` . - To include instance types with inference hardware, specify ``inference`` . Default: Any accelerator type\n')
    allowed_instance_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to allow an instance type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` . For example, if you specify ``c5*`` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types. .. epigraph:: If you specify ``AllowedInstanceTypes`` , you can't specify ``ExcludedInstanceTypes`` . Default: All instance types\n")
    bare_metal: typing.Optional[str] = pydantic.Field(None, description='Indicates whether bare metal instance types must be included, excluded, or required. - To include bare metal instance types, specify ``included`` . - To require only bare metal instance types, specify ``required`` . - To exclude bare metal instance types, specify ``excluded`` . Default: ``excluded``\n')
    baseline_ebs_bandwidth_mbps: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_BaselineEbsBandwidthMbpsRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see `Amazon EBS–optimized instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html>`_ in the *Amazon EC2 User Guide* . Default: No minimum or maximum limits\n')
    burstable_performance: typing.Optional[str] = pydantic.Field(None, description='Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ . - To include burstable performance instance types, specify ``included`` . - To require only burstable performance instance types, specify ``required`` . - To exclude burstable performance instance types, specify ``excluded`` . Default: ``excluded``\n')
    cpu_manufacturers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The CPU manufacturers to include. - For instance types with Intel CPUs, specify ``intel`` . - For instance types with AMD CPUs, specify ``amd`` . - For instance types with AWS CPUs, specify ``amazon-web-services`` . .. epigraph:: Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. Default: Any manufacturer\n")
    excluded_instance_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to exclude an instance family, type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` . For example, if you specify ``c5*`` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types. .. epigraph:: If you specify ``ExcludedInstanceTypes`` , you can't specify ``AllowedInstanceTypes`` . Default: No excluded instance types\n")
    instance_generations: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* . For current generation instance types, specify ``current`` . For previous generation instance types, specify ``previous`` . Default: Current and previous generation instance types\n')
    local_storage: typing.Optional[str] = pydantic.Field(None, description='Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, `Amazon EC2 instance store <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html>`_ in the *Amazon EC2 User Guide* . - To include instance types with instance store volumes, specify ``included`` . - To require only instance types with instance store volumes, specify ``required`` . - To exclude instance types with instance store volumes, specify ``excluded`` . Default: ``included``\n')
    local_storage_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The type of local storage that is required. - For instance types with hard disk drive (HDD) storage, specify ``hdd`` . - For instance types with solid state drive (SSD) storage, specify ``ssd`` . Default: ``hdd`` and ``ssd``\n')
    memory_gib_per_v_cpu: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_MemoryGiBPerVCpuRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum amount of memory per vCPU, in GiB. Default: No minimum or maximum limits\n')
    memory_mib: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_MemoryMiBRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum amount of memory, in MiB.\n')
    network_bandwidth_gbps: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_NetworkBandwidthGbpsRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default: No minimum or maximum limits\n')
    network_interface_count: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_NetworkInterfaceCountRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum number of network interfaces. Default: No minimum or maximum limits\n')
    on_demand_max_price_percentage_over_lowest_price: typing.Union[int, float, None] = pydantic.Field(None, description='The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. To turn off price protection, specify a high value, such as ``999999`` . This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ . .. epigraph:: If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. Default: ``20``\n')
    require_hibernate_support: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether instance types must support hibernation for On-Demand Instances. This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ . Default: ``false``\n')
    spot_max_price_percentage_over_lowest_price: typing.Union[int, float, None] = pydantic.Field(None, description='The price protection threshold for Spot Instance. This is the maximum you’ll pay for an Spot Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. To turn off price protection, specify a high value, such as ``999999`` . This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ . .. epigraph:: If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. Default: ``100``\n')
    total_local_storage_gb: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_TotalLocalStorageGBRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum amount of total local storage, in GB. Default: No minimum or maximum limits\n')
    v_cpu_count: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_VCpuCountRangeRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum number of vCPUs.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    instance_requirements_request_property = ec2.CfnEC2Fleet.InstanceRequirementsRequestProperty(\n        accelerator_count=ec2.CfnEC2Fleet.AcceleratorCountRequestProperty(\n            max=123,\n            min=123\n        ),\n        accelerator_manufacturers=["acceleratorManufacturers"],\n        accelerator_names=["acceleratorNames"],\n        accelerator_total_memory_mi_b=ec2.CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty(\n            max=123,\n            min=123\n        ),\n        accelerator_types=["acceleratorTypes"],\n        allowed_instance_types=["allowedInstanceTypes"],\n        bare_metal="bareMetal",\n        baseline_ebs_bandwidth_mbps=ec2.CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty(\n            max=123,\n            min=123\n        ),\n        burstable_performance="burstablePerformance",\n        cpu_manufacturers=["cpuManufacturers"],\n        excluded_instance_types=["excludedInstanceTypes"],\n        instance_generations=["instanceGenerations"],\n        local_storage="localStorage",\n        local_storage_types=["localStorageTypes"],\n        memory_gi_bPer_vCpu=ec2.CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty(\n            max=123,\n            min=123\n        ),\n        memory_mi_b=ec2.CfnEC2Fleet.MemoryMiBRequestProperty(\n            max=123,\n            min=123\n        ),\n        network_bandwidth_gbps=ec2.CfnEC2Fleet.NetworkBandwidthGbpsRequestProperty(\n            max=123,\n            min=123\n        ),\n        network_interface_count=ec2.CfnEC2Fleet.NetworkInterfaceCountRequestProperty(\n            max=123,\n            min=123\n        ),\n        on_demand_max_price_percentage_over_lowest_price=123,\n        require_hibernate_support=False,\n        spot_max_price_percentage_over_lowest_price=123,\n        total_local_storage_gb=ec2.CfnEC2Fleet.TotalLocalStorageGBRequestProperty(\n            max=123,\n            min=123\n        ),\n        v_cpu_count=ec2.CfnEC2Fleet.VCpuCountRangeRequestProperty(\n            max=123,\n            min=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['accelerator_count', 'accelerator_manufacturers', 'accelerator_names', 'accelerator_total_memory_mib', 'accelerator_types', 'allowed_instance_types', 'bare_metal', 'baseline_ebs_bandwidth_mbps', 'burstable_performance', 'cpu_manufacturers', 'excluded_instance_types', 'instance_generations', 'local_storage', 'local_storage_types', 'memory_gib_per_v_cpu', 'memory_mib', 'network_bandwidth_gbps', 'network_interface_count', 'on_demand_max_price_percentage_over_lowest_price', 'require_hibernate_support', 'spot_max_price_percentage_over_lowest_price', 'total_local_storage_gb', 'v_cpu_count']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet.InstanceRequirementsRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet.MaintenanceStrategiesProperty
class CfnEC2Fleet_MaintenanceStrategiesPropertyDef(BaseStruct):
    capacity_rebalance: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_CapacityRebalancePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-maintenancestrategies.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    maintenance_strategies_property = ec2.CfnEC2Fleet.MaintenanceStrategiesProperty(\n        capacity_rebalance=ec2.CfnEC2Fleet.CapacityRebalanceProperty(\n            replacement_strategy="replacementStrategy",\n            termination_delay=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['capacity_rebalance']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet.MaintenanceStrategiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty
class CfnEC2Fleet_MemoryGiBPerVCpuRequestPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorygibpervcpurequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    memory_gi_bPer_vCpu_request_property = ec2.CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet.MemoryMiBRequestProperty
class CfnEC2Fleet_MemoryMiBRequestPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum amount of memory, in MiB. To specify no minimum limit, specify ``0`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorymibrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    memory_mi_bRequest_property = ec2.CfnEC2Fleet.MemoryMiBRequestProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet.MemoryMiBRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet.NetworkBandwidthGbpsRequestProperty
class CfnEC2Fleet_NetworkBandwidthGbpsRequestPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkbandwidthgbpsrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    network_bandwidth_gbps_request_property = ec2.CfnEC2Fleet.NetworkBandwidthGbpsRequestProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet.NetworkBandwidthGbpsRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet.NetworkInterfaceCountRequestProperty
class CfnEC2Fleet_NetworkInterfaceCountRequestPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of network interfaces. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of network interfaces. To specify no minimum limit, omit this parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkinterfacecountrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    network_interface_count_request_property = ec2.CfnEC2Fleet.NetworkInterfaceCountRequestProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet.NetworkInterfaceCountRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet.OnDemandOptionsRequestProperty
class CfnEC2Fleet_OnDemandOptionsRequestPropertyDef(BaseStruct):
    allocation_strategy: typing.Optional[str] = pydantic.Field(None, description='The strategy that determines the order of the launch template overrides to use in fulfilling On-Demand capacity. ``lowest-price`` - EC2 Fleet uses price to determine the order, launching the lowest price first. ``prioritized`` - EC2 Fleet uses the priority that you assigned to each launch template override, launching the highest priority first. Default: ``lowest-price``\n')
    capacity_reservation_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_CapacityReservationOptionsRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity. Supported only for fleets of type ``instant`` .\n')
    max_total_price: typing.Optional[str] = pydantic.Field(None, description="The maximum amount per hour for On-Demand Instances that you're willing to pay.\n")
    min_target_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum target capacity for On-Demand Instances in the fleet. If the minimum target capacity is not reached, the fleet launches no instances. Supported only for fleets of type ``instant`` . At least one of the following must be specified: ``SingleAvailabilityZone`` | ``SingleInstanceType``\n')
    single_availability_zone: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates that the fleet launches all On-Demand Instances into a single Availability Zone. Supported only for fleets of type ``instant`` .\n')
    single_instance_type: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet. Supported only for fleets of type ``instant`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    on_demand_options_request_property = ec2.CfnEC2Fleet.OnDemandOptionsRequestProperty(\n        allocation_strategy="allocationStrategy",\n        capacity_reservation_options=ec2.CfnEC2Fleet.CapacityReservationOptionsRequestProperty(\n            usage_strategy="usageStrategy"\n        ),\n        max_total_price="maxTotalPrice",\n        min_target_capacity=123,\n        single_availability_zone=False,\n        single_instance_type=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allocation_strategy', 'capacity_reservation_options', 'max_total_price', 'min_target_capacity', 'single_availability_zone', 'single_instance_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet.OnDemandOptionsRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet.PlacementProperty
class CfnEC2Fleet_PlacementPropertyDef(BaseStruct):
    affinity: typing.Optional[str] = pydantic.Field(None, description='The affinity setting for the instance on the Dedicated Host. This parameter is not supported for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ or `ImportInstance <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html>`_ .\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone of the instance. If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region. This parameter is not supported for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .\n')
    group_name: typing.Optional[str] = pydantic.Field(None, description="The name of the placement group that the instance is in. If you specify ``GroupName`` , you can't specify ``GroupId`` .\n")
    host_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the Dedicated Host on which the instance resides. This parameter is not supported for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ or `ImportInstance <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html>`_ .\n')
    host_resource_group_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the host resource group in which to launch the instances. If you specify this parameter, either omit the *Tenancy* parameter or set it to ``host`` . This parameter is not supported for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .\n')
    partition_number: typing.Union[int, float, None] = pydantic.Field(None, description='The number of the partition that the instance is in. Valid only if the placement group strategy is set to ``partition`` . This parameter is not supported for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .\n')
    spread_domain: typing.Optional[str] = pydantic.Field(None, description='Reserved for future use.\n')
    tenancy: typing.Optional[str] = pydantic.Field(None, description='The tenancy of the instance. An instance with a tenancy of ``dedicated`` runs on single-tenant hardware. This parameter is not supported for `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ . The ``host`` tenancy is not supported for `ImportInstance <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html>`_ or for T3 instances that are configured for the ``unlimited`` CPU credit option.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    placement_property = ec2.CfnEC2Fleet.PlacementProperty(\n        affinity="affinity",\n        availability_zone="availabilityZone",\n        group_name="groupName",\n        host_id="hostId",\n        host_resource_group_arn="hostResourceGroupArn",\n        partition_number=123,\n        spread_domain="spreadDomain",\n        tenancy="tenancy"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['affinity', 'availability_zone', 'group_name', 'host_id', 'host_resource_group_arn', 'partition_number', 'spread_domain', 'tenancy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet.PlacementProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet.SpotOptionsRequestProperty
class CfnEC2Fleet_SpotOptionsRequestPropertyDef(BaseStruct):
    allocation_strategy: typing.Optional[str] = pydantic.Field(None, description='Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the EC2 Fleet. If the allocation strategy is ``lowestPrice`` , EC2 Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy. If the allocation strategy is ``diversified`` , EC2 Fleet launches instances from all the Spot Instance pools that you specify. If the allocation strategy is ``capacityOptimized`` , EC2 Fleet launches instances from Spot Instance pools that are optimally chosen based on the available Spot Instance capacity. *Allowed Values* : ``lowestPrice`` | ``diversified`` | ``capacityOptimized`` | ``capacityOptimizedPrioritized``\n')
    instance_interruption_behavior: typing.Optional[str] = pydantic.Field(None, description='The behavior when a Spot Instance is interrupted. Default: ``terminate``\n')
    instance_pools_to_use_count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of Spot pools across which to allocate your target Spot capacity. Supported only when Spot ``AllocationStrategy`` is set to ``lowest-price`` . EC2 Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify. Note that EC2 Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, EC2 Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.\n')
    maintenance_strategies: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_MaintenanceStrategiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.\n')
    max_total_price: typing.Optional[str] = pydantic.Field(None, description="The maximum amount per hour for Spot Instances that you're willing to pay. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price. .. epigraph:: If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter.\n")
    min_target_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum target capacity for Spot Instances in the fleet. If the minimum target capacity is not reached, the fleet launches no instances. Supported only for fleets of type ``instant`` . At least one of the following must be specified: ``SingleAvailabilityZone`` | ``SingleInstanceType``\n')
    single_availability_zone: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates that the fleet launches all Spot Instances into a single Availability Zone. Supported only for fleets of type ``instant`` .\n')
    single_instance_type: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet. Supported only for fleets of type ``instant`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    spot_options_request_property = ec2.CfnEC2Fleet.SpotOptionsRequestProperty(\n        allocation_strategy="allocationStrategy",\n        instance_interruption_behavior="instanceInterruptionBehavior",\n        instance_pools_to_use_count=123,\n        maintenance_strategies=ec2.CfnEC2Fleet.MaintenanceStrategiesProperty(\n            capacity_rebalance=ec2.CfnEC2Fleet.CapacityRebalanceProperty(\n                replacement_strategy="replacementStrategy",\n                termination_delay=123\n            )\n        ),\n        max_total_price="maxTotalPrice",\n        min_target_capacity=123,\n        single_availability_zone=False,\n        single_instance_type=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allocation_strategy', 'instance_interruption_behavior', 'instance_pools_to_use_count', 'maintenance_strategies', 'max_total_price', 'min_target_capacity', 'single_availability_zone', 'single_instance_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet.SpotOptionsRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet.TagSpecificationProperty
class CfnEC2Fleet_TagSpecificationPropertyDef(BaseStruct):
    resource_type: typing.Optional[str] = pydantic.Field(None, description='The type of resource to tag. ``ResourceType`` must be ``fleet`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to apply to the resource.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    tag_specification_property = ec2.CfnEC2Fleet.TagSpecificationProperty(\n        resource_type="resourceType",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resource_type', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet.TagSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet.TargetCapacitySpecificationRequestProperty
class CfnEC2Fleet_TargetCapacitySpecificationRequestPropertyDef(BaseStruct):
    total_target_capacity: typing.Union[int, float] = pydantic.Field(..., description='The number of units to request, filled using ``DefaultTargetCapacityType`` .\n')
    default_target_capacity_type: typing.Optional[str] = pydantic.Field(None, description='The default ``TotalTargetCapacity`` , which is either ``Spot`` or ``On-Demand`` .\n')
    on_demand_target_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='The number of On-Demand units to request.\n')
    spot_target_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='The number of Spot units to request.\n')
    target_capacity_unit_type: typing.Optional[str] = pydantic.Field(None, description='The unit for the target capacity. ``TargetCapacityUnitType`` can only be specified when ``InstanceRequirements`` is specified. Default: ``units`` (translates to number of instances)\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    target_capacity_specification_request_property = ec2.CfnEC2Fleet.TargetCapacitySpecificationRequestProperty(\n        total_target_capacity=123,\n\n        # the properties below are optional\n        default_target_capacity_type="defaultTargetCapacityType",\n        on_demand_target_capacity=123,\n        spot_target_capacity=123,\n        target_capacity_unit_type="targetCapacityUnitType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['total_target_capacity', 'default_target_capacity_type', 'on_demand_target_capacity', 'spot_target_capacity', 'target_capacity_unit_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet.TargetCapacitySpecificationRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet.TotalLocalStorageGBRequestProperty
class CfnEC2Fleet_TotalLocalStorageGBRequestPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-totallocalstoragegbrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    total_local_storage_gBRequest_property = ec2.CfnEC2Fleet.TotalLocalStorageGBRequestProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet.TotalLocalStorageGBRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet.VCpuCountRangeRequestProperty
class CfnEC2Fleet_VCpuCountRangeRequestPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of vCPUs. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of vCPUs. To specify no minimum limit, specify ``0`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-vcpucountrangerequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    v_cpu_count_range_request_property = ec2.CfnEC2Fleet.VCpuCountRangeRequestProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet.VCpuCountRangeRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnFlowLog.DestinationOptionsProperty
class CfnFlowLog_DestinationOptionsPropertyDef(BaseStruct):
    file_format: str = pydantic.Field(..., description='The format for the flow log. The default is ``plain-text`` .\n')
    hive_compatible_partitions: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3. The default is ``false`` .\n')
    per_hour_partition: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='Indicates whether to partition the flow log per hour. This reduces the cost and response time for queries. The default is ``false`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-destinationoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    destination_options_property = ec2.CfnFlowLog.DestinationOptionsProperty(\n        file_format="fileFormat",\n        hive_compatible_partitions=False,\n        per_hour_partition=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['file_format', 'hive_compatible_partitions', 'per_hour_partition']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnFlowLog.DestinationOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnInstance.AssociationParameterProperty
class CfnInstance_AssociationParameterPropertyDef(BaseStruct):
    key: str = pydantic.Field(..., description='The name of an input parameter that is in the associated SSM document.\n')
    value: typing.Sequence[str] = pydantic.Field(..., description='The value of an input parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociations-associationparameters.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    association_parameter_property = ec2.CfnInstance.AssociationParameterProperty(\n        key="key",\n        value=["value"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'value']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInstance.AssociationParameterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnInstance.BlockDeviceMappingProperty
class CfnInstance_BlockDeviceMappingPropertyDef(BaseStruct):
    device_name: str = pydantic.Field(..., description='The device name (for example, ``/dev/sdh`` or ``xvdh`` ). .. epigraph:: After the instance is running, this parameter is used to specify the device name of the block device mapping to update.\n')
    ebs: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_EbsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Parameters used to automatically set up EBS volumes when the instance is launched. .. epigraph:: After the instance is running, you can modify only the ``DeleteOnTermination`` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-no-interrupt>`_ .\n')
    no_device: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_NoDevicePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='To omit the device from the block device mapping, specify an empty string. .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .\n')
    virtual_name: typing.Optional[str] = pydantic.Field(None, description='The virtual device name ( ``ephemeral`` N). The name must be in the form ``ephemeral`` *X* where *X* is a number starting from zero (0). For example, an instance type with 2 available instance store volumes can specify mappings for ``ephemeral0`` and ``ephemeral1`` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume. NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect. *Constraints* : For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI. .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-mapping.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    block_device_mapping_property = ec2.CfnInstance.BlockDeviceMappingProperty(\n        device_name="deviceName",\n\n        # the properties below are optional\n        ebs=ec2.CfnInstance.EbsProperty(\n            delete_on_termination=False,\n            encrypted=False,\n            iops=123,\n            kms_key_id="kmsKeyId",\n            snapshot_id="snapshotId",\n            volume_size=123,\n            volume_type="volumeType"\n        ),\n        no_device=ec2.CfnInstance.NoDeviceProperty(),\n        virtual_name="virtualName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['device_name', 'ebs', 'no_device', 'virtual_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInstance.BlockDeviceMappingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnInstance.CpuOptionsProperty
class CfnInstance_CpuOptionsPropertyDef(BaseStruct):
    core_count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of CPU cores for the instance.\n')
    threads_per_core: typing.Union[int, float, None] = pydantic.Field(None, description='The number of threads per CPU core.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cpu_options_property = ec2.CfnInstance.CpuOptionsProperty(\n        core_count=123,\n        threads_per_core=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['core_count', 'threads_per_core']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInstance.CpuOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnInstance.CreditSpecificationProperty
class CfnInstance_CreditSpecificationPropertyDef(BaseStruct):
    cpu_credits: typing.Optional[str] = pydantic.Field(None, description='The credit option for CPU usage of the instance. Valid values: ``standard`` | ``unlimited`` T3 instances with ``host`` tenancy do not support the ``unlimited`` CPU credit option.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    credit_specification_property = ec2.CfnInstance.CreditSpecificationProperty(\n        cpu_credits="cpuCredits"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cpu_credits']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInstance.CreditSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnInstance.EbsProperty
class CfnInstance_EbsPropertyDef(BaseStruct):
    delete_on_termination: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether the EBS volume is deleted on instance termination. For more information, see `Preserving Amazon EBS volumes on instance termination <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination>`_ in the *Amazon EC2 User Guide* .\n')
    encrypted: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether the volume should be encrypted. The effect of setting the encryption state to ``true`` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Encryption by default <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default>`_ in the *Amazon Elastic Compute Cloud User Guide* . Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see `Supported instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances>`_ . .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .\n')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='The number of I/O operations per second (IOPS). For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. The following are the supported values for each volume type: - ``gp3`` : 3,000-16,000 IOPS - ``io1`` : 100-64,000 IOPS - ``io2`` : 100-64,000 IOPS For ``io1`` and ``io2`` volumes, we guarantee 64,000 IOPS only for `Instances built on the Nitro System <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ . Other instance families guarantee performance up to 32,000 IOPS. This parameter is required for ``io1`` and ``io2`` volumes. The default for ``gp3`` volumes is 3,000 IOPS. This parameter is not supported for ``gp2`` , ``st1`` , ``sc1`` , or ``standard`` volumes. .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the AWS KMS key to use for Amazon EBS encryption. If ``KmsKeyId`` is specified, the encrypted state must be ``true`` . If the encrypted state is ``true`` but you do not specify ``KmsKeyId`` , your KMS key for EBS is used. You can specify the KMS key using any of the following: - Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab. - Key alias. For example, alias/ExampleAlias. - Key ARN. For example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab. - Alias ARN. For example, arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias. .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .\n')
    snapshot_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the snapshot. If you specify both ``SnapshotId`` and ``VolumeSize`` , ``VolumeSize`` must be equal or greater than the size of the snapshot. .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .\n')
    volume_size: typing.Union[int, float, None] = pydantic.Field(None, description='The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size. The following are the supported volumes sizes for each volume type: - ``gp2`` and ``gp3`` :1-16,384 - ``io1`` and ``io2`` : 4-16,384 - ``st1`` and ``sc1`` : 125-16,384 - ``standard`` : 1-1,024 .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .\n')
    volume_type: typing.Optional[str] = pydantic.Field(None, description='The volume type. For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>`_ in the *Amazon EC2 User Guide* . If the volume type is ``io1`` or ``io2`` , you must specify the IOPS that the volume supports. .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-template.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    ebs_property = ec2.CfnInstance.EbsProperty(\n        delete_on_termination=False,\n        encrypted=False,\n        iops=123,\n        kms_key_id="kmsKeyId",\n        snapshot_id="snapshotId",\n        volume_size=123,\n        volume_type="volumeType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['delete_on_termination', 'encrypted', 'iops', 'kms_key_id', 'snapshot_id', 'volume_size', 'volume_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInstance.EbsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnInstance.ElasticGpuSpecificationProperty
class CfnInstance_ElasticGpuSpecificationPropertyDef(BaseStruct):
    type: str = pydantic.Field(..., description='The type of Elastic Graphics accelerator. For more information about the values to specify for ``Type`` , see `Elastic Graphics Basics <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html#elastic-graphics-basics>`_ , specifically the Elastic Graphics accelerator column, in the *Amazon Elastic Compute Cloud User Guide for Windows Instances* .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    elastic_gpu_specification_property = ec2.CfnInstance.ElasticGpuSpecificationProperty(\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInstance.ElasticGpuSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnInstance.ElasticInferenceAcceleratorProperty
class CfnInstance_ElasticInferenceAcceleratorPropertyDef(BaseStruct):
    type: str = pydantic.Field(..., description='The type of elastic inference accelerator. The possible values are ``eia1.medium`` , ``eia1.large`` , ``eia1.xlarge`` , ``eia2.medium`` , ``eia2.large`` , and ``eia2.xlarge`` .\n')
    count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of elastic inference accelerators to attach to the instance.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    elastic_inference_accelerator_property = ec2.CfnInstance.ElasticInferenceAcceleratorProperty(\n        type="type",\n\n        # the properties below are optional\n        count=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'count']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInstance.ElasticInferenceAcceleratorProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnInstance.EnclaveOptionsProperty
class CfnInstance_EnclaveOptionsPropertyDef(BaseStruct):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='If this parameter is set to ``true`` , the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    enclave_options_property = ec2.CfnInstance.EnclaveOptionsProperty(\n        enabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInstance.EnclaveOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnInstance.HibernationOptionsProperty
class CfnInstance_HibernationOptionsPropertyDef(BaseStruct):
    configured: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='If you set this parameter to ``true`` , your instance is enabled for hibernation. Default: ``false``\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    hibernation_options_property = ec2.CfnInstance.HibernationOptionsProperty(\n        configured=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['configured']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInstance.HibernationOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnInstance.InstanceIpv6AddressProperty
class CfnInstance_InstanceIpv6AddressPropertyDef(BaseStruct):
    ipv6_address: str = pydantic.Field(..., description='The IPv6 address.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    instance_ipv6_address_property = ec2.CfnInstance.InstanceIpv6AddressProperty(\n        ipv6_address="ipv6Address"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ipv6_address']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInstance.InstanceIpv6AddressProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnInstance.LaunchTemplateSpecificationProperty
class CfnInstance_LaunchTemplateSpecificationPropertyDef(BaseStruct):
    version: str = pydantic.Field(..., description='The version number of the launch template. Specifying ``$Latest`` or ``$Default`` for the template version number is not supported. However, you can specify ``LatestVersionNumber`` or ``DefaultVersionNumber`` using the ``Fn::GetAtt`` intrinsic function. For more information, see `Fn::GetAtt <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate-return-values-fn--getatt>`_ .\n')
    launch_template_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the launch template. You must specify the ``LaunchTemplateId`` or the ``LaunchTemplateName`` , but not both.\n')
    launch_template_name: typing.Optional[str] = pydantic.Field(None, description='The name of the launch template. You must specify the ``LaunchTemplateName`` or the ``LaunchTemplateId`` , but not both.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    launch_template_specification_property = ec2.CfnInstance.LaunchTemplateSpecificationProperty(\n        version="version",\n\n        # the properties below are optional\n        launch_template_id="launchTemplateId",\n        launch_template_name="launchTemplateName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['version', 'launch_template_id', 'launch_template_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInstance.LaunchTemplateSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnInstance.LicenseSpecificationProperty
class CfnInstance_LicenseSpecificationPropertyDef(BaseStruct):
    license_configuration_arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the license configuration.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    license_specification_property = ec2.CfnInstance.LicenseSpecificationProperty(\n        license_configuration_arn="licenseConfigurationArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['license_configuration_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInstance.LicenseSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnInstance.NetworkInterfaceProperty
class CfnInstance_NetworkInterfacePropertyDef(BaseStruct):
    device_index: str = pydantic.Field(..., description='The position of the network interface in the attachment order. A primary network interface has a device index of 0. If you create a network interface when launching an instance, you must specify the device index.\n')
    associate_carrier_ip_address: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to assign a carrier IP address to the network interface. You can only assign a carrier IP address to a network interface that is in a subnet in a Wavelength Zone. For more information about carrier IP addresses, see `Carrier IP address <https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip>`_ in the *AWS Wavelength Developer Guide* .\n')
    associate_public_ip_address: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to assign a public IPv4 address to an instance. Applies only if creating a network interface when launching an instance. The network interface must be the primary network interface. If launching into a default subnet, the default value is ``true`` .\n')
    delete_on_termination: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether the network interface is deleted when the instance is terminated. Applies only if creating a network interface when launching an instance.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the network interface. Applies only if creating a network interface when launching an instance.\n')
    group_set: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.\n')
    ipv6_address_count: typing.Union[int, float, None] = pydantic.Field(None, description="A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.\n")
    ipv6_addresses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_InstanceIpv6AddressPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="The IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.\n")
    network_interface_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the network interface, when attaching an existing network interface.\n')
    private_ip_address: typing.Optional[str] = pydantic.Field(None, description='The private IPv4 address of the network interface. Applies only if creating a network interface when launching an instance.\n')
    private_ip_addresses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_PrivateIpAddressSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='One or more private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary.\n')
    secondary_private_ip_address_count: typing.Union[int, float, None] = pydantic.Field(None, description="The number of secondary private IPv4 addresses. You can't specify this option and specify more than one private IP address using the private IP addresses option.\n")
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the subnet associated with the network interface. Applies only if creating a network interface when launching an instance.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    network_interface_property = ec2.CfnInstance.NetworkInterfaceProperty(\n        device_index="deviceIndex",\n\n        # the properties below are optional\n        associate_carrier_ip_address=False,\n        associate_public_ip_address=False,\n        delete_on_termination=False,\n        description="description",\n        group_set=["groupSet"],\n        ipv6_address_count=123,\n        ipv6_addresses=[ec2.CfnInstance.InstanceIpv6AddressProperty(\n            ipv6_address="ipv6Address"\n        )],\n        network_interface_id="networkInterfaceId",\n        private_ip_address="privateIpAddress",\n        private_ip_addresses=[ec2.CfnInstance.PrivateIpAddressSpecificationProperty(\n            primary=False,\n            private_ip_address="privateIpAddress"\n        )],\n        secondary_private_ip_address_count=123,\n        subnet_id="subnetId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['device_index', 'associate_carrier_ip_address', 'associate_public_ip_address', 'delete_on_termination', 'description', 'group_set', 'ipv6_address_count', 'ipv6_addresses', 'network_interface_id', 'private_ip_address', 'private_ip_addresses', 'secondary_private_ip_address_count', 'subnet_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInstance.NetworkInterfaceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnInstance.NoDeviceProperty
class CfnInstance_NoDevicePropertyDef(BaseStruct):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInstance.NoDeviceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnInstance.PrivateDnsNameOptionsProperty
class CfnInstance_PrivateDnsNameOptionsPropertyDef(BaseStruct):
    enable_resource_name_dns_aaaa_record: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .\n')
    enable_resource_name_dns_a_record: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to respond to DNS queries for instance hostnames with DNS A records. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .\n')
    hostname_type: typing.Optional[str] = pydantic.Field(None, description='The type of hostnames to assign to instances in the subnet at launch. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    private_dns_name_options_property = ec2.CfnInstance.PrivateDnsNameOptionsProperty(\n        enable_resource_name_dns_aaaa_record=False,\n        enable_resource_name_dns_aRecord=False,\n        hostname_type="hostnameType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enable_resource_name_dns_aaaa_record', 'enable_resource_name_dns_a_record', 'hostname_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInstance.PrivateDnsNameOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnInstance.PrivateIpAddressSpecificationProperty
class CfnInstance_PrivateIpAddressSpecificationPropertyDef(BaseStruct):
    primary: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.\n')
    private_ip_address: str = pydantic.Field(..., description='The private IPv4 address.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-interface-privateipspec.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    private_ip_address_specification_property = ec2.CfnInstance.PrivateIpAddressSpecificationProperty(\n        primary=False,\n        private_ip_address="privateIpAddress"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['primary', 'private_ip_address']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInstance.PrivateIpAddressSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnInstance.SsmAssociationProperty
class CfnInstance_SsmAssociationPropertyDef(BaseStruct):
    document_name: str = pydantic.Field(..., description='The name of an SSM document to associate with the instance.\n')
    association_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_AssociationParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The input parameter values to use with the associated SSM document.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociations.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    ssm_association_property = ec2.CfnInstance.SsmAssociationProperty(\n        document_name="documentName",\n\n        # the properties below are optional\n        association_parameters=[ec2.CfnInstance.AssociationParameterProperty(\n            key="key",\n            value=["value"]\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['document_name', 'association_parameters']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInstance.SsmAssociationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnInstance.VolumeProperty
class CfnInstance_VolumePropertyDef(BaseStruct):
    device: str = pydantic.Field(..., description='The device name (for example, ``/dev/sdh`` or ``xvdh`` ).\n')
    volume_id: str = pydantic.Field(..., description='The ID of the EBS volume. The volume and instance must be within the same Availability Zone.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-mount-point.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    volume_property = ec2.CfnInstance.VolumeProperty(\n        device="device",\n        volume_id="volumeId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['device', 'volume_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInstance.VolumeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnIPAM.IpamOperatingRegionProperty
class CfnIPAM_IpamOperatingRegionPropertyDef(BaseStruct):
    region_name: str = pydantic.Field(..., description='The name of the operating Region.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-ipamoperatingregion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    ipam_operating_region_property = ec2.CfnIPAM.IpamOperatingRegionProperty(\n        region_name="regionName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['region_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnIPAM.IpamOperatingRegionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnIPAMPool.ProvisionedCidrProperty
class CfnIPAMPool_ProvisionedCidrPropertyDef(BaseStruct):
    cidr: str = pydantic.Field(..., description='The CIDR provisioned to the IPAM pool. A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is ``10.24.34.0/23`` . An IPv6 CIDR example is ``2001:DB8::/32`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    provisioned_cidr_property = ec2.CfnIPAMPool.ProvisionedCidrProperty(\n        cidr="cidr"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cidr']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnIPAMPool.ProvisionedCidrProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnIPAMResourceDiscovery.IpamOperatingRegionProperty
class CfnIPAMResourceDiscovery_IpamOperatingRegionPropertyDef(BaseStruct):
    region_name: str = pydantic.Field(..., description='The name of the operating Region.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscovery-ipamoperatingregion.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    ipam_operating_region_property = ec2.CfnIPAMResourceDiscovery.IpamOperatingRegionProperty(\n        region_name="regionName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['region_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnIPAMResourceDiscovery.IpamOperatingRegionProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.AcceleratorCountProperty
class CfnLaunchTemplate_AcceleratorCountPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of accelerators. To specify no minimum limit, omit this parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratorcount.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    accelerator_count_property = ec2.CfnLaunchTemplate.AcceleratorCountProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.AcceleratorCountProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.AcceleratorTotalMemoryMiBProperty
class CfnLaunchTemplate_AcceleratorTotalMemoryMiBPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratortotalmemorymib.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    accelerator_total_memory_mi_bProperty = ec2.CfnLaunchTemplate.AcceleratorTotalMemoryMiBProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.AcceleratorTotalMemoryMiBProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.BaselineEbsBandwidthMbpsProperty
class CfnLaunchTemplate_BaselineEbsBandwidthMbpsPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-baselineebsbandwidthmbps.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    baseline_ebs_bandwidth_mbps_property = ec2.CfnLaunchTemplate.BaselineEbsBandwidthMbpsProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.BaselineEbsBandwidthMbpsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.BlockDeviceMappingProperty
class CfnLaunchTemplate_BlockDeviceMappingPropertyDef(BaseStruct):
    device_name: typing.Optional[str] = pydantic.Field(None, description='The device name (for example, /dev/sdh or xvdh).\n')
    ebs: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_EbsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Parameters used to automatically set up EBS volumes when the instance is launched.\n')
    no_device: typing.Optional[str] = pydantic.Field(None, description='To omit the device from the block device mapping, specify an empty string.\n')
    virtual_name: typing.Optional[str] = pydantic.Field(None, description='The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    block_device_mapping_property = ec2.CfnLaunchTemplate.BlockDeviceMappingProperty(\n        device_name="deviceName",\n        ebs=ec2.CfnLaunchTemplate.EbsProperty(\n            delete_on_termination=False,\n            encrypted=False,\n            iops=123,\n            kms_key_id="kmsKeyId",\n            snapshot_id="snapshotId",\n            throughput=123,\n            volume_size=123,\n            volume_type="volumeType"\n        ),\n        no_device="noDevice",\n        virtual_name="virtualName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['device_name', 'ebs', 'no_device', 'virtual_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.BlockDeviceMappingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.CapacityReservationSpecificationProperty
class CfnLaunchTemplate_CapacityReservationSpecificationPropertyDef(BaseStruct):
    capacity_reservation_preference: typing.Optional[str] = pydantic.Field(None, description="Indicates the instance's Capacity Reservation preferences. Possible preferences include:. - ``open`` - The instance can run in any ``open`` Capacity Reservation that has matching attributes (instance type, platform, Availability Zone). - ``none`` - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.\n")
    capacity_reservation_target: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_CapacityReservationTargetPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about the target Capacity Reservation or Capacity Reservation group.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-capacityreservationspecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    capacity_reservation_specification_property = ec2.CfnLaunchTemplate.CapacityReservationSpecificationProperty(\n        capacity_reservation_preference="capacityReservationPreference",\n        capacity_reservation_target=ec2.CfnLaunchTemplate.CapacityReservationTargetProperty(\n            capacity_reservation_id="capacityReservationId",\n            capacity_reservation_resource_group_arn="capacityReservationResourceGroupArn"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['capacity_reservation_preference', 'capacity_reservation_target']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.CapacityReservationSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.CapacityReservationTargetProperty
class CfnLaunchTemplate_CapacityReservationTargetPropertyDef(BaseStruct):
    capacity_reservation_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the Capacity Reservation in which to run the instance.\n')
    capacity_reservation_resource_group_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the Capacity Reservation resource group in which to run the instance.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationtarget.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    capacity_reservation_target_property = ec2.CfnLaunchTemplate.CapacityReservationTargetProperty(\n        capacity_reservation_id="capacityReservationId",\n        capacity_reservation_resource_group_arn="capacityReservationResourceGroupArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['capacity_reservation_id', 'capacity_reservation_resource_group_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.CapacityReservationTargetProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.CpuOptionsProperty
class CfnLaunchTemplate_CpuOptionsPropertyDef(BaseStruct):
    amd_sev_snp: typing.Optional[str] = pydantic.Field(None, description='Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. For more information, see `AMD SEV-SNP <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/sev-snp.html>`_ .\n')
    core_count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of CPU cores for the instance.\n')
    threads_per_core: typing.Union[int, float, None] = pydantic.Field(None, description='The number of threads per CPU core. To disable multithreading for the instance, specify a value of ``1`` . Otherwise, specify the default value of ``2`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-cpuoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cpu_options_property = ec2.CfnLaunchTemplate.CpuOptionsProperty(\n        amd_sev_snp="amdSevSnp",\n        core_count=123,\n        threads_per_core=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['amd_sev_snp', 'core_count', 'threads_per_core']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.CpuOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.CreditSpecificationProperty
class CfnLaunchTemplate_CreditSpecificationPropertyDef(BaseStruct):
    cpu_credits: typing.Optional[str] = pydantic.Field(None, description='The credit option for CPU usage of a T instance. Valid values: ``standard`` | ``unlimited``\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-creditspecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    credit_specification_property = ec2.CfnLaunchTemplate.CreditSpecificationProperty(\n        cpu_credits="cpuCredits"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cpu_credits']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.CreditSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.EbsProperty
class CfnLaunchTemplate_EbsPropertyDef(BaseStruct):
    delete_on_termination: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether the EBS volume is deleted on instance termination.\n')
    encrypted: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Indicates whether the EBS volume is encrypted. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. If you are creating a volume from a snapshot, you can't specify an encryption value.\n")
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='The number of I/O operations per second (IOPS). For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. The following are the supported values for each volume type: - ``gp3`` : 3,000-16,000 IOPS - ``io1`` : 100-64,000 IOPS - ``io2`` : 100-64,000 IOPS For ``io1`` and ``io2`` volumes, we guarantee 64,000 IOPS only for `Instances built on the Nitro System <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ . Other instance families guarantee performance up to 32,000 IOPS. This parameter is supported for ``io1`` , ``io2`` , and ``gp3`` volumes only. This parameter is not supported for ``gp2`` , ``st1`` , ``sc1`` , or ``standard`` volumes.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The ARN of the symmetric AWS Key Management Service ( AWS KMS ) CMK used for encryption.\n')
    snapshot_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the snapshot.\n')
    throughput: typing.Union[int, float, None] = pydantic.Field(None, description='The throughput to provision for a ``gp3`` volume, with a maximum of 1,000 MiB/s. Valid Range: Minimum value of 125. Maximum value of 1000.\n')
    volume_size: typing.Union[int, float, None] = pydantic.Field(None, description='The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. The following are the supported volumes sizes for each volume type: - ``gp2`` and ``gp3`` : 1-16,384 - ``io1`` and ``io2`` : 4-16,384 - ``st1`` and ``sc1`` : 125-16,384 - ``standard`` : 1-1,024\n')
    volume_type: typing.Optional[str] = pydantic.Field(None, description='The volume type. For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping-ebs.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    ebs_property = ec2.CfnLaunchTemplate.EbsProperty(\n        delete_on_termination=False,\n        encrypted=False,\n        iops=123,\n        kms_key_id="kmsKeyId",\n        snapshot_id="snapshotId",\n        throughput=123,\n        volume_size=123,\n        volume_type="volumeType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['delete_on_termination', 'encrypted', 'iops', 'kms_key_id', 'snapshot_id', 'throughput', 'volume_size', 'volume_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.EbsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.ElasticGpuSpecificationProperty
class CfnLaunchTemplate_ElasticGpuSpecificationPropertyDef(BaseStruct):
    type: typing.Optional[str] = pydantic.Field(None, description='The type of Elastic Graphics accelerator. For more information about the values to specify for ``Type`` , see `Elastic Graphics Basics <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html#elastic-graphics-basics>`_ , specifically the Elastic Graphics accelerator column, in the *Amazon Elastic Compute Cloud User Guide for Windows Instances* .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-elasticgpuspecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    elastic_gpu_specification_property = ec2.CfnLaunchTemplate.ElasticGpuSpecificationProperty(\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.ElasticGpuSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.EnclaveOptionsProperty
class CfnLaunchTemplate_EnclaveOptionsPropertyDef(BaseStruct):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='If this parameter is set to ``true`` , the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-enclaveoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    enclave_options_property = ec2.CfnLaunchTemplate.EnclaveOptionsProperty(\n        enabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.EnclaveOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.HibernationOptionsProperty
class CfnLaunchTemplate_HibernationOptionsPropertyDef(BaseStruct):
    configured: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='If you set this parameter to ``true`` , the instance is enabled for hibernation. Default: ``false``\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-hibernationoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    hibernation_options_property = ec2.CfnLaunchTemplate.HibernationOptionsProperty(\n        configured=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['configured']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.HibernationOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.IamInstanceProfileProperty
class CfnLaunchTemplate_IamInstanceProfilePropertyDef(BaseStruct):
    arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the instance profile.\n')
    name: typing.Optional[str] = pydantic.Field(None, description='The name of the instance profile.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-iaminstanceprofile.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    iam_instance_profile_property = ec2.CfnLaunchTemplate.IamInstanceProfileProperty(\n        arn="arn",\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['arn', 'name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.IamInstanceProfileProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.InstanceMarketOptionsProperty
class CfnLaunchTemplate_InstanceMarketOptionsPropertyDef(BaseStruct):
    market_type: typing.Optional[str] = pydantic.Field(None, description='The market type.\n')
    spot_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_SpotOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for Spot Instances.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancemarketoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    instance_market_options_property = ec2.CfnLaunchTemplate.InstanceMarketOptionsProperty(\n        market_type="marketType",\n        spot_options=ec2.CfnLaunchTemplate.SpotOptionsProperty(\n            block_duration_minutes=123,\n            instance_interruption_behavior="instanceInterruptionBehavior",\n            max_price="maxPrice",\n            spot_instance_type="spotInstanceType",\n            valid_until="validUntil"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['market_type', 'spot_options']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.InstanceMarketOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.InstanceRequirementsProperty
class CfnLaunchTemplate_InstanceRequirementsPropertyDef(BaseStruct):
    accelerator_count: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_AcceleratorCountPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` . Default: No minimum or maximum limits\n')
    accelerator_manufacturers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Indicates whether instance types must have accelerators by specific manufacturers. - For instance types with NVIDIA devices, specify ``nvidia`` . - For instance types with AMD devices, specify ``amd`` . - For instance types with AWS devices, specify ``amazon-web-services`` . - For instance types with Xilinx devices, specify ``xilinx`` . Default: Any manufacturer\n')
    accelerator_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The accelerators that must be on the instance type. - For instance types with NVIDIA A100 GPUs, specify ``a100`` . - For instance types with NVIDIA V100 GPUs, specify ``v100`` . - For instance types with NVIDIA K80 GPUs, specify ``k80`` . - For instance types with NVIDIA T4 GPUs, specify ``t4`` . - For instance types with NVIDIA M60 GPUs, specify ``m60`` . - For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520`` . - For instance types with Xilinx VU9P FPGAs, specify ``vu9p`` . - For instance types with AWS Inferentia chips, specify ``inferentia`` . - For instance types with NVIDIA GRID K520 GPUs, specify ``k520`` . Default: Any accelerator\n')
    accelerator_total_memory_mib: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_AcceleratorTotalMemoryMiBPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum amount of total accelerator memory, in MiB. Default: No minimum or maximum limits\n')
    accelerator_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The accelerator types that must be on the instance type. - For instance types with GPU accelerators, specify ``gpu`` . - For instance types with FPGA accelerators, specify ``fpga`` . - For instance types with inference accelerators, specify ``inference`` . Default: Any accelerator type\n')
    allowed_instance_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to allow an instance type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` . For example, if you specify ``c5*`` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types. .. epigraph:: If you specify ``AllowedInstanceTypes`` , you can't specify ``ExcludedInstanceTypes`` . Default: All instance types\n")
    bare_metal: typing.Optional[str] = pydantic.Field(None, description='Indicates whether bare metal instance types must be included, excluded, or required. - To include bare metal instance types, specify ``included`` . - To require only bare metal instance types, specify ``required`` . - To exclude bare metal instance types, specify ``excluded`` . Default: ``excluded``\n')
    baseline_ebs_bandwidth_mbps: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_BaselineEbsBandwidthMbpsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see `Amazon EBS–optimized instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html>`_ in the *Amazon EC2 User Guide* . Default: No minimum or maximum limits\n')
    burstable_performance: typing.Optional[str] = pydantic.Field(None, description='Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ . - To include burstable performance instance types, specify ``included`` . - To require only burstable performance instance types, specify ``required`` . - To exclude burstable performance instance types, specify ``excluded`` . Default: ``excluded``\n')
    cpu_manufacturers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The CPU manufacturers to include. - For instance types with Intel CPUs, specify ``intel`` . - For instance types with AMD CPUs, specify ``amd`` . - For instance types with AWS CPUs, specify ``amazon-web-services`` . .. epigraph:: Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. Default: Any manufacturer\n")
    excluded_instance_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to exclude an instance type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` . For example, if you specify ``c5*`` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types. .. epigraph:: If you specify ``ExcludedInstanceTypes`` , you can't specify ``AllowedInstanceTypes`` . Default: No excluded instance types\n")
    instance_generations: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* . For current generation instance types, specify ``current`` . For previous generation instance types, specify ``previous`` . Default: Current and previous generation instance types\n')
    local_storage: typing.Optional[str] = pydantic.Field(None, description='Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, `Amazon EC2 instance store <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html>`_ in the *Amazon EC2 User Guide* . - To include instance types with instance store volumes, specify ``included`` . - To require only instance types with instance store volumes, specify ``required`` . - To exclude instance types with instance store volumes, specify ``excluded`` . Default: ``included``\n')
    local_storage_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The type of local storage that is required. - For instance types with hard disk drive (HDD) storage, specify ``hdd`` . - For instance types with solid state drive (SSD) storage, specify ``ssd`` . Default: ``hdd`` and ``ssd``\n')
    memory_gib_per_v_cpu: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_MemoryGiBPerVCpuPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum amount of memory per vCPU, in GiB. Default: No minimum or maximum limits\n')
    memory_mib: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_MemoryMiBPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum amount of memory, in MiB.\n')
    network_bandwidth_gbps: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_NetworkBandwidthGbpsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default: No minimum or maximum limits\n')
    network_interface_count: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_NetworkInterfaceCountPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum number of network interfaces. Default: No minimum or maximum limits\n')
    on_demand_max_price_percentage_over_lowest_price: typing.Union[int, float, None] = pydantic.Field(None, description='The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. To turn off price protection, specify a high value, such as ``999999`` . This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ . .. epigraph:: If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. Default: ``20``\n')
    require_hibernate_support: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether instance types must support hibernation for On-Demand Instances. This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ . Default: ``false``\n')
    spot_max_price_percentage_over_lowest_price: typing.Union[int, float, None] = pydantic.Field(None, description='The price protection threshold for Spot Instances. This is the maximum you’ll pay for a Spot Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. To turn off price protection, specify a high value, such as ``999999`` . This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ . .. epigraph:: If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. Default: ``100``\n')
    total_local_storage_gb: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_TotalLocalStorageGBPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum amount of total local storage, in GB. Default: No minimum or maximum limits\n')
    v_cpu_count: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_VCpuCountPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum number of vCPUs.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    instance_requirements_property = ec2.CfnLaunchTemplate.InstanceRequirementsProperty(\n        accelerator_count=ec2.CfnLaunchTemplate.AcceleratorCountProperty(\n            max=123,\n            min=123\n        ),\n        accelerator_manufacturers=["acceleratorManufacturers"],\n        accelerator_names=["acceleratorNames"],\n        accelerator_total_memory_mi_b=ec2.CfnLaunchTemplate.AcceleratorTotalMemoryMiBProperty(\n            max=123,\n            min=123\n        ),\n        accelerator_types=["acceleratorTypes"],\n        allowed_instance_types=["allowedInstanceTypes"],\n        bare_metal="bareMetal",\n        baseline_ebs_bandwidth_mbps=ec2.CfnLaunchTemplate.BaselineEbsBandwidthMbpsProperty(\n            max=123,\n            min=123\n        ),\n        burstable_performance="burstablePerformance",\n        cpu_manufacturers=["cpuManufacturers"],\n        excluded_instance_types=["excludedInstanceTypes"],\n        instance_generations=["instanceGenerations"],\n        local_storage="localStorage",\n        local_storage_types=["localStorageTypes"],\n        memory_gi_bPer_vCpu=ec2.CfnLaunchTemplate.MemoryGiBPerVCpuProperty(\n            max=123,\n            min=123\n        ),\n        memory_mi_b=ec2.CfnLaunchTemplate.MemoryMiBProperty(\n            max=123,\n            min=123\n        ),\n        network_bandwidth_gbps=ec2.CfnLaunchTemplate.NetworkBandwidthGbpsProperty(\n            max=123,\n            min=123\n        ),\n        network_interface_count=ec2.CfnLaunchTemplate.NetworkInterfaceCountProperty(\n            max=123,\n            min=123\n        ),\n        on_demand_max_price_percentage_over_lowest_price=123,\n        require_hibernate_support=False,\n        spot_max_price_percentage_over_lowest_price=123,\n        total_local_storage_gb=ec2.CfnLaunchTemplate.TotalLocalStorageGBProperty(\n            max=123,\n            min=123\n        ),\n        v_cpu_count=ec2.CfnLaunchTemplate.VCpuCountProperty(\n            max=123,\n            min=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['accelerator_count', 'accelerator_manufacturers', 'accelerator_names', 'accelerator_total_memory_mib', 'accelerator_types', 'allowed_instance_types', 'bare_metal', 'baseline_ebs_bandwidth_mbps', 'burstable_performance', 'cpu_manufacturers', 'excluded_instance_types', 'instance_generations', 'local_storage', 'local_storage_types', 'memory_gib_per_v_cpu', 'memory_mib', 'network_bandwidth_gbps', 'network_interface_count', 'on_demand_max_price_percentage_over_lowest_price', 'require_hibernate_support', 'spot_max_price_percentage_over_lowest_price', 'total_local_storage_gb', 'v_cpu_count']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.InstanceRequirementsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.Ipv4PrefixSpecificationProperty
class CfnLaunchTemplate_Ipv4PrefixSpecificationPropertyDef(BaseStruct):
    ipv4_prefix: typing.Optional[str] = pydantic.Field(None, description='The IPv4 prefix. For information, see `Assigning prefixes to Amazon EC2 network interfaces <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv4prefixspecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    ipv4_prefix_specification_property = ec2.CfnLaunchTemplate.Ipv4PrefixSpecificationProperty(\n        ipv4_prefix="ipv4Prefix"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ipv4_prefix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.Ipv4PrefixSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.Ipv6AddProperty
class CfnLaunchTemplate_Ipv6AddPropertyDef(BaseStruct):
    ipv6_address: typing.Optional[str] = pydantic.Field(None, description='One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can\'t use this option if you\'re specifying a number of IPv6 addresses.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv6add.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    ipv6_add_property = ec2.CfnLaunchTemplate.Ipv6AddProperty(\n        ipv6_address="ipv6Address"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ipv6_address']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.Ipv6AddProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.Ipv6PrefixSpecificationProperty
class CfnLaunchTemplate_Ipv6PrefixSpecificationPropertyDef(BaseStruct):
    ipv6_prefix: typing.Optional[str] = pydantic.Field(None, description='The IPv6 prefix.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv6prefixspecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    ipv6_prefix_specification_property = ec2.CfnLaunchTemplate.Ipv6PrefixSpecificationProperty(\n        ipv6_prefix="ipv6Prefix"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ipv6_prefix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.Ipv6PrefixSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.LaunchTemplateDataProperty
class CfnLaunchTemplate_LaunchTemplateDataPropertyDef(BaseStruct):
    block_device_mappings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_BlockDeviceMappingPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The block device mapping.\n')
    capacity_reservation_specification: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_CapacityReservationSpecificationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The Capacity Reservation targeting option. If you do not specify this parameter, the instance's Capacity Reservation preference defaults to ``open`` , which enables it to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).\n")
    cpu_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_CpuOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The CPU options for the instance. For more information, see `Optimizing CPU Options <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .\n')
    credit_specification: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_CreditSpecificationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The credit option for CPU usage of the instance. Valid only for T instances.\n')
    disable_api_stop: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to enable the instance for stop protection. For more information, see `Stop protection <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Stop_Start.html#Using_StopProtection>`_ in the *Amazon Elastic Compute Cloud User Guide* .\n')
    disable_api_termination: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="If you set this parameter to ``true`` , you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. To change this attribute after launch, use `ModifyInstanceAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html>`_ . Alternatively, if you set ``InstanceInitiatedShutdownBehavior`` to ``terminate`` , you can terminate the instance by running the shutdown command from the instance.\n")
    ebs_optimized: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.\n")
    elastic_gpu_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_ElasticGpuSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An elastic GPU to associate with the instance.\n')
    elastic_inference_accelerators: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_LaunchTemplateElasticInferenceAcceleratorPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The elastic inference accelerator for the instance.\n')
    enclave_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_EnclaveOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Indicates whether the instance is enabled for AWS Nitro Enclaves. For more information, see `What is AWS Nitro Enclaves? <https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html>`_ in the *AWS Nitro Enclaves User Guide* . You can't enable AWS Nitro Enclaves and hibernation on the same instance.\n")
    hibernation_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_HibernationOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Indicates whether an instance is enabled for hibernation. This parameter is valid only if the instance meets the `hibernation prerequisites <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hibernating-prerequisites.html>`_ . For more information, see `Hibernate your instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .\n')
    iam_instance_profile: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_IamInstanceProfilePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The name or Amazon Resource Name (ARN) of an IAM instance profile.\n')
    image_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the AMI. Alternatively, you can specify a Systems Manager parameter, which will resolve to an AMI ID on launch. Valid formats: - ``ami-17characters00000`` - ``resolve:ssm')
    instance_initiated_shutdown_behavior: typing.Optional[str] = pydantic.Field(None, description='Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown). Default: ``stop``\n')
    instance_market_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_InstanceMarketOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The market (purchasing) option for the instances.\n')
    instance_requirements: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_InstanceRequirementsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with these attributes. If you specify ``InstanceRequirements`` , you can't specify ``InstanceType`` .\n")
    instance_type: typing.Optional[str] = pydantic.Field(None, description="The instance type. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon Elastic Compute Cloud User Guide* . If you specify ``InstanceType`` , you can't specify ``InstanceRequirements`` .\n")
    kernel_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the kernel. We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `User Provided Kernels <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .\n')
    key_name: typing.Optional[str] = pydantic.Field(None, description="The name of the key pair. You can create a key pair using `CreateKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html>`_ or `ImportKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html>`_ . .. epigraph:: If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.\n")
    license_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_LicenseSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The license configurations.\n')
    maintenance_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_MaintenanceOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The maintenance options of your instance.\n')
    metadata_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_MetadataOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The metadata options for the instance. For more information, see `Instance metadata and user data <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .\n')
    monitoring: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_MonitoringPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The monitoring for the instance.\n')
    network_interfaces: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_NetworkInterfacePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='One or more network interfaces. If you specify a network interface, you must specify any security groups and subnets as part of the network interface.\n')
    placement: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_PlacementPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The placement for the instance.\n')
    private_dns_name_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_PrivateDnsNameOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries should be handled. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .\n')
    ram_disk_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the RAM disk. .. epigraph:: We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `User provided kernels <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .\n')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of the security groups. You can specify the IDs of existing security groups and references to resources created by the stack template.\n')
    security_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='One or more security group names. For a nondefault VPC, you must use security group IDs instead. You cannot specify both a security group ID and security name in the same request.\n')
    tag_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_TagSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The tags to apply to the resources that are created during instance launch. You can specify tags for the following resources only: - Instances - Volumes - Elastic graphics - Spot Instance requests - Network interfaces To tag a resource after it has been created, see `CreateTags <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html>`_ . .. epigraph:: To tag the launch template itself, you must use the `TagSpecification <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateLaunchTemplate.html>`_ parameter.\n')
    user_data: typing.Optional[str] = pydantic.Field(None, description='The user data to make available to the instance. You must provide base64-encoded text. User data is limited to 16 KB. For more information, see `Run commands on your Linux instance at launch <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html>`_ (Linux) or `Work with instance user data <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instancedata-add-user-data.html>`_ (Windows) in the *Amazon Elastic Compute Cloud User Guide* . If you are creating the launch template for use with AWS Batch , the user data must be provided in the `MIME multi-part archive format <https://docs.aws.amazon.com/https://cloudinit.readthedocs.io/en/latest/topics/format.html#mime-multi-part-archive>`_ . For more information, see `Amazon EC2 user data in launch templates <https://docs.aws.amazon.com/batch/latest/userguide/launch-templates.html>`_ in the *AWS Batch User Guide* .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    launch_template_data_property = ec2.CfnLaunchTemplate.LaunchTemplateDataProperty(\n        block_device_mappings=[ec2.CfnLaunchTemplate.BlockDeviceMappingProperty(\n            device_name="deviceName",\n            ebs=ec2.CfnLaunchTemplate.EbsProperty(\n                delete_on_termination=False,\n                encrypted=False,\n                iops=123,\n                kms_key_id="kmsKeyId",\n                snapshot_id="snapshotId",\n                throughput=123,\n                volume_size=123,\n                volume_type="volumeType"\n            ),\n            no_device="noDevice",\n            virtual_name="virtualName"\n        )],\n        capacity_reservation_specification=ec2.CfnLaunchTemplate.CapacityReservationSpecificationProperty(\n            capacity_reservation_preference="capacityReservationPreference",\n            capacity_reservation_target=ec2.CfnLaunchTemplate.CapacityReservationTargetProperty(\n                capacity_reservation_id="capacityReservationId",\n                capacity_reservation_resource_group_arn="capacityReservationResourceGroupArn"\n            )\n        ),\n        cpu_options=ec2.CfnLaunchTemplate.CpuOptionsProperty(\n            amd_sev_snp="amdSevSnp",\n            core_count=123,\n            threads_per_core=123\n        ),\n        credit_specification=ec2.CfnLaunchTemplate.CreditSpecificationProperty(\n            cpu_credits="cpuCredits"\n        ),\n        disable_api_stop=False,\n        disable_api_termination=False,\n        ebs_optimized=False,\n        elastic_gpu_specifications=[ec2.CfnLaunchTemplate.ElasticGpuSpecificationProperty(\n            type="type"\n        )],\n        elastic_inference_accelerators=[ec2.CfnLaunchTemplate.LaunchTemplateElasticInferenceAcceleratorProperty(\n            count=123,\n            type="type"\n        )],\n        enclave_options=ec2.CfnLaunchTemplate.EnclaveOptionsProperty(\n            enabled=False\n        ),\n        hibernation_options=ec2.CfnLaunchTemplate.HibernationOptionsProperty(\n            configured=False\n        ),\n        iam_instance_profile=ec2.CfnLaunchTemplate.IamInstanceProfileProperty(\n            arn="arn",\n            name="name"\n        ),\n        image_id="imageId",\n        instance_initiated_shutdown_behavior="instanceInitiatedShutdownBehavior",\n        instance_market_options=ec2.CfnLaunchTemplate.InstanceMarketOptionsProperty(\n            market_type="marketType",\n            spot_options=ec2.CfnLaunchTemplate.SpotOptionsProperty(\n                block_duration_minutes=123,\n                instance_interruption_behavior="instanceInterruptionBehavior",\n                max_price="maxPrice",\n                spot_instance_type="spotInstanceType",\n                valid_until="validUntil"\n            )\n        ),\n        instance_requirements=ec2.CfnLaunchTemplate.InstanceRequirementsProperty(\n            accelerator_count=ec2.CfnLaunchTemplate.AcceleratorCountProperty(\n                max=123,\n                min=123\n            ),\n            accelerator_manufacturers=["acceleratorManufacturers"],\n            accelerator_names=["acceleratorNames"],\n            accelerator_total_memory_mi_b=ec2.CfnLaunchTemplate.AcceleratorTotalMemoryMiBProperty(\n                max=123,\n                min=123\n            ),\n            accelerator_types=["acceleratorTypes"],\n            allowed_instance_types=["allowedInstanceTypes"],\n            bare_metal="bareMetal",\n            baseline_ebs_bandwidth_mbps=ec2.CfnLaunchTemplate.BaselineEbsBandwidthMbpsProperty(\n                max=123,\n                min=123\n            ),\n            burstable_performance="burstablePerformance",\n            cpu_manufacturers=["cpuManufacturers"],\n            excluded_instance_types=["excludedInstanceTypes"],\n            instance_generations=["instanceGenerations"],\n            local_storage="localStorage",\n            local_storage_types=["localStorageTypes"],\n            memory_gi_bPer_vCpu=ec2.CfnLaunchTemplate.MemoryGiBPerVCpuProperty(\n                max=123,\n                min=123\n            ),\n            memory_mi_b=ec2.CfnLaunchTemplate.MemoryMiBProperty(\n                max=123,\n                min=123\n            ),\n            network_bandwidth_gbps=ec2.CfnLaunchTemplate.NetworkBandwidthGbpsProperty(\n                max=123,\n                min=123\n            ),\n            network_interface_count=ec2.CfnLaunchTemplate.NetworkInterfaceCountProperty(\n                max=123,\n                min=123\n            ),\n            on_demand_max_price_percentage_over_lowest_price=123,\n            require_hibernate_support=False,\n            spot_max_price_percentage_over_lowest_price=123,\n            total_local_storage_gb=ec2.CfnLaunchTemplate.TotalLocalStorageGBProperty(\n                max=123,\n                min=123\n            ),\n            v_cpu_count=ec2.CfnLaunchTemplate.VCpuCountProperty(\n                max=123,\n                min=123\n            )\n        ),\n        instance_type="instanceType",\n        kernel_id="kernelId",\n        key_name="keyName",\n        license_specifications=[ec2.CfnLaunchTemplate.LicenseSpecificationProperty(\n            license_configuration_arn="licenseConfigurationArn"\n        )],\n        maintenance_options=ec2.CfnLaunchTemplate.MaintenanceOptionsProperty(\n            auto_recovery="autoRecovery"\n        ),\n        metadata_options=ec2.CfnLaunchTemplate.MetadataOptionsProperty(\n            http_endpoint="httpEndpoint",\n            http_protocol_ipv6="httpProtocolIpv6",\n            http_put_response_hop_limit=123,\n            http_tokens="httpTokens",\n            instance_metadata_tags="instanceMetadataTags"\n        ),\n        monitoring=ec2.CfnLaunchTemplate.MonitoringProperty(\n            enabled=False\n        ),\n        network_interfaces=[ec2.CfnLaunchTemplate.NetworkInterfaceProperty(\n            associate_carrier_ip_address=False,\n            associate_public_ip_address=False,\n            delete_on_termination=False,\n            description="description",\n            device_index=123,\n            groups=["groups"],\n            interface_type="interfaceType",\n            ipv4_prefix_count=123,\n            ipv4_prefixes=[ec2.CfnLaunchTemplate.Ipv4PrefixSpecificationProperty(\n                ipv4_prefix="ipv4Prefix"\n            )],\n            ipv6_address_count=123,\n            ipv6_addresses=[ec2.CfnLaunchTemplate.Ipv6AddProperty(\n                ipv6_address="ipv6Address"\n            )],\n            ipv6_prefix_count=123,\n            ipv6_prefixes=[ec2.CfnLaunchTemplate.Ipv6PrefixSpecificationProperty(\n                ipv6_prefix="ipv6Prefix"\n            )],\n            network_card_index=123,\n            network_interface_id="networkInterfaceId",\n            private_ip_address="privateIpAddress",\n            private_ip_addresses=[ec2.CfnLaunchTemplate.PrivateIpAddProperty(\n                primary=False,\n                private_ip_address="privateIpAddress"\n            )],\n            secondary_private_ip_address_count=123,\n            subnet_id="subnetId"\n        )],\n        placement=ec2.CfnLaunchTemplate.PlacementProperty(\n            affinity="affinity",\n            availability_zone="availabilityZone",\n            group_id="groupId",\n            group_name="groupName",\n            host_id="hostId",\n            host_resource_group_arn="hostResourceGroupArn",\n            partition_number=123,\n            spread_domain="spreadDomain",\n            tenancy="tenancy"\n        ),\n        private_dns_name_options=ec2.CfnLaunchTemplate.PrivateDnsNameOptionsProperty(\n            enable_resource_name_dns_aaaa_record=False,\n            enable_resource_name_dns_aRecord=False,\n            hostname_type="hostnameType"\n        ),\n        ram_disk_id="ramDiskId",\n        security_group_ids=["securityGroupIds"],\n        security_groups=["securityGroups"],\n        tag_specifications=[ec2.CfnLaunchTemplate.TagSpecificationProperty(\n            resource_type="resourceType",\n            tags=[CfnTag(\n                key="key",\n                value="value"\n            )]\n        )],\n        user_data="userData"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['block_device_mappings', 'capacity_reservation_specification', 'cpu_options', 'credit_specification', 'disable_api_stop', 'disable_api_termination', 'ebs_optimized', 'elastic_gpu_specifications', 'elastic_inference_accelerators', 'enclave_options', 'hibernation_options', 'iam_instance_profile', 'image_id', 'instance_initiated_shutdown_behavior', 'instance_market_options', 'instance_requirements', 'instance_type', 'kernel_id', 'key_name', 'license_specifications', 'maintenance_options', 'metadata_options', 'monitoring', 'network_interfaces', 'placement', 'private_dns_name_options', 'ram_disk_id', 'security_group_ids', 'security_groups', 'tag_specifications', 'user_data']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.LaunchTemplateDataProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.LaunchTemplateElasticInferenceAcceleratorProperty
class CfnLaunchTemplate_LaunchTemplateElasticInferenceAcceleratorPropertyDef(BaseStruct):
    count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of elastic inference accelerators to attach to the instance. Default: 1\n')
    type: typing.Optional[str] = pydantic.Field(None, description='The type of elastic inference accelerator. The possible values are eia1.medium, eia1.large, and eia1.xlarge.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    launch_template_elastic_inference_accelerator_property = ec2.CfnLaunchTemplate.LaunchTemplateElasticInferenceAcceleratorProperty(\n        count=123,\n        type="type"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['count', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.LaunchTemplateElasticInferenceAcceleratorProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty
class CfnLaunchTemplate_LaunchTemplateTagSpecificationPropertyDef(BaseStruct):
    resource_type: typing.Optional[str] = pydantic.Field(None, description='The type of resource. To tag the launch template, ``ResourceType`` must be ``launch-template`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the resource.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatetagspecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    launch_template_tag_specification_property = ec2.CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty(\n        resource_type="resourceType",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resource_type', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.LicenseSpecificationProperty
class CfnLaunchTemplate_LicenseSpecificationPropertyDef(BaseStruct):
    license_configuration_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the license configuration.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-licensespecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    license_specification_property = ec2.CfnLaunchTemplate.LicenseSpecificationProperty(\n        license_configuration_arn="licenseConfigurationArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['license_configuration_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.LicenseSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.MaintenanceOptionsProperty
class CfnLaunchTemplate_MaintenanceOptionsPropertyDef(BaseStruct):
    auto_recovery: typing.Optional[str] = pydantic.Field(None, description='Disables the automatic recovery behavior of your instance or sets it to default.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-maintenanceoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    maintenance_options_property = ec2.CfnLaunchTemplate.MaintenanceOptionsProperty(\n        auto_recovery="autoRecovery"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['auto_recovery']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.MaintenanceOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.MemoryGiBPerVCpuProperty
class CfnLaunchTemplate_MemoryGiBPerVCpuPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorygibpervcpu.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    memory_gi_bPer_vCpu_property = ec2.CfnLaunchTemplate.MemoryGiBPerVCpuProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.MemoryGiBPerVCpuProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.MemoryMiBProperty
class CfnLaunchTemplate_MemoryMiBPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum amount of memory, in MiB. To specify no minimum limit, specify ``0`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorymib.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    memory_mi_bProperty = ec2.CfnLaunchTemplate.MemoryMiBProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.MemoryMiBProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.MetadataOptionsProperty
class CfnLaunchTemplate_MetadataOptionsPropertyDef(BaseStruct):
    http_endpoint: typing.Optional[str] = pydantic.Field(None, description='Enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is ``enabled`` . .. epigraph:: If you specify a value of ``disabled`` , you will not be able to access your instance metadata.\n')
    http_protocol_ipv6: typing.Optional[str] = pydantic.Field(None, description='Enables or disables the IPv6 endpoint for the instance metadata service. Default: ``disabled``\n')
    http_put_response_hop_limit: typing.Union[int, float, None] = pydantic.Field(None, description='The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Default: ``1`` Possible values: Integers from 1 to 64\n')
    http_tokens: typing.Optional[str] = pydantic.Field(None, description='IMDSv2 uses token-backed sessions. Set the use of HTTP tokens to ``optional`` (in other words, set the use of IMDSv2 to ``optional`` ) or ``required`` (in other words, set the use of IMDSv2 to ``required`` ). - ``optional`` - When IMDSv2 is optional, you can choose to retrieve instance metadata with or without a session token in your request. If you retrieve the IAM role credentials without a token, the IMDSv1 role credentials are returned. If you retrieve the IAM role credentials using a valid session token, the IMDSv2 role credentials are returned. - ``required`` - When IMDSv2 is required, you must send a session token with any instance metadata retrieval requests. In this state, retrieving the IAM role credentials always returns IMDSv2 credentials; IMDSv1 credentials are not available. Default: ``optional``\n')
    instance_metadata_tags: typing.Optional[str] = pydantic.Field(None, description='Set to ``enabled`` to allow access to instance tags from the instance metadata. Set to ``disabled`` to turn off access to instance tags from the instance metadata. For more information, see `Work with instance tags using the instance metadata <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#work-with-tags-in-IMDS>`_ . Default: ``disabled``\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-metadataoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    metadata_options_property = ec2.CfnLaunchTemplate.MetadataOptionsProperty(\n        http_endpoint="httpEndpoint",\n        http_protocol_ipv6="httpProtocolIpv6",\n        http_put_response_hop_limit=123,\n        http_tokens="httpTokens",\n        instance_metadata_tags="instanceMetadataTags"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['http_endpoint', 'http_protocol_ipv6', 'http_put_response_hop_limit', 'http_tokens', 'instance_metadata_tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.MetadataOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.MonitoringProperty
class CfnLaunchTemplate_MonitoringPropertyDef(BaseStruct):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specify ``true`` to enable detailed monitoring. Otherwise, basic monitoring is enabled.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-monitoring.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    monitoring_property = ec2.CfnLaunchTemplate.MonitoringProperty(\n        enabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.MonitoringProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.NetworkBandwidthGbpsProperty
class CfnLaunchTemplate_NetworkBandwidthGbpsPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum amount of network bandwidth, in Gbps. If this parameter is not specified, there is no minimum limit.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkbandwidthgbps.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    network_bandwidth_gbps_property = ec2.CfnLaunchTemplate.NetworkBandwidthGbpsProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.NetworkBandwidthGbpsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.NetworkInterfaceCountProperty
class CfnLaunchTemplate_NetworkInterfaceCountPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of network interfaces. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of network interfaces. To specify no minimum limit, omit this parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterfacecount.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    network_interface_count_property = ec2.CfnLaunchTemplate.NetworkInterfaceCountProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.NetworkInterfaceCountProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.NetworkInterfaceProperty
class CfnLaunchTemplate_NetworkInterfacePropertyDef(BaseStruct):
    associate_carrier_ip_address: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to associate a Carrier IP address with eth0 for a new network interface. Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. For more information about Carrier IP addresses, see `Carrier IP addresses <https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip>`_ in the *AWS Wavelength Developer Guide* .\n')
    associate_public_ip_address: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Associates a public IPv4 address with eth0 for a new network interface.\n')
    delete_on_termination: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether the network interface is deleted when the instance is terminated.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the network interface.\n')
    device_index: typing.Union[int, float, None] = pydantic.Field(None, description='The device index for the network interface attachment.\n')
    groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of one or more security groups.\n')
    interface_type: typing.Optional[str] = pydantic.Field(None, description='The type of network interface. To create an Elastic Fabric Adapter (EFA), specify ``efa`` . For more information, see `Elastic Fabric Adapter <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html>`_ in the *Amazon Elastic Compute Cloud User Guide* . If you are not creating an EFA, specify ``interface`` or omit this parameter. Valid values: ``interface`` | ``efa``\n')
    ipv4_prefix_count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of IPv4 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the ``Ipv4Prefix`` option.\n')
    ipv4_prefixes: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_Ipv4PrefixSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='One or more IPv4 prefixes to be assigned to the network interface. You cannot use this option if you use the ``Ipv4PrefixCount`` option.\n')
    ipv6_address_count: typing.Union[int, float, None] = pydantic.Field(None, description="The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.\n")
    ipv6_addresses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_Ipv6AddPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.\n")
    ipv6_prefix_count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of IPv6 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the ``Ipv6Prefix`` option.\n')
    ipv6_prefixes: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_Ipv6PrefixSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='One or more IPv6 prefixes to be assigned to the network interface. You cannot use this option if you use the ``Ipv6PrefixCount`` option.\n')
    network_card_index: typing.Union[int, float, None] = pydantic.Field(None, description='The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.\n')
    network_interface_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the network interface.\n')
    private_ip_address: typing.Optional[str] = pydantic.Field(None, description='The primary private IPv4 address of the network interface.\n')
    private_ip_addresses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_PrivateIpAddPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='One or more private IPv4 addresses.\n')
    secondary_private_ip_address_count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of secondary private IPv4 addresses to assign to a network interface.\n')
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the subnet for the network interface.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    network_interface_property = ec2.CfnLaunchTemplate.NetworkInterfaceProperty(\n        associate_carrier_ip_address=False,\n        associate_public_ip_address=False,\n        delete_on_termination=False,\n        description="description",\n        device_index=123,\n        groups=["groups"],\n        interface_type="interfaceType",\n        ipv4_prefix_count=123,\n        ipv4_prefixes=[ec2.CfnLaunchTemplate.Ipv4PrefixSpecificationProperty(\n            ipv4_prefix="ipv4Prefix"\n        )],\n        ipv6_address_count=123,\n        ipv6_addresses=[ec2.CfnLaunchTemplate.Ipv6AddProperty(\n            ipv6_address="ipv6Address"\n        )],\n        ipv6_prefix_count=123,\n        ipv6_prefixes=[ec2.CfnLaunchTemplate.Ipv6PrefixSpecificationProperty(\n            ipv6_prefix="ipv6Prefix"\n        )],\n        network_card_index=123,\n        network_interface_id="networkInterfaceId",\n        private_ip_address="privateIpAddress",\n        private_ip_addresses=[ec2.CfnLaunchTemplate.PrivateIpAddProperty(\n            primary=False,\n            private_ip_address="privateIpAddress"\n        )],\n        secondary_private_ip_address_count=123,\n        subnet_id="subnetId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['associate_carrier_ip_address', 'associate_public_ip_address', 'delete_on_termination', 'description', 'device_index', 'groups', 'interface_type', 'ipv4_prefix_count', 'ipv4_prefixes', 'ipv6_address_count', 'ipv6_addresses', 'ipv6_prefix_count', 'ipv6_prefixes', 'network_card_index', 'network_interface_id', 'private_ip_address', 'private_ip_addresses', 'secondary_private_ip_address_count', 'subnet_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.NetworkInterfaceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.PlacementProperty
class CfnLaunchTemplate_PlacementPropertyDef(BaseStruct):
    affinity: typing.Optional[str] = pydantic.Field(None, description='The affinity setting for an instance on a Dedicated Host.\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone for the instance.\n')
    group_id: typing.Optional[str] = pydantic.Field(None, description='The Group Id of a placement group. You must specify the Placement Group *Group Id* to launch an instance in a shared placement group.\n')
    group_name: typing.Optional[str] = pydantic.Field(None, description='The name of the placement group for the instance.\n')
    host_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the Dedicated Host for the instance.\n')
    host_resource_group_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host`` .\n')
    partition_number: typing.Union[int, float, None] = pydantic.Field(None, description='The number of the partition the instance should launch in. Valid only if the placement group strategy is set to ``partition`` .\n')
    spread_domain: typing.Optional[str] = pydantic.Field(None, description='Reserved for future use.\n')
    tenancy: typing.Optional[str] = pydantic.Field(None, description='The tenancy of the instance. An instance with a tenancy of dedicated runs on single-tenant hardware.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-placement.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    placement_property = ec2.CfnLaunchTemplate.PlacementProperty(\n        affinity="affinity",\n        availability_zone="availabilityZone",\n        group_id="groupId",\n        group_name="groupName",\n        host_id="hostId",\n        host_resource_group_arn="hostResourceGroupArn",\n        partition_number=123,\n        spread_domain="spreadDomain",\n        tenancy="tenancy"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['affinity', 'availability_zone', 'group_id', 'group_name', 'host_id', 'host_resource_group_arn', 'partition_number', 'spread_domain', 'tenancy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.PlacementProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.PrivateDnsNameOptionsProperty
class CfnLaunchTemplate_PrivateDnsNameOptionsPropertyDef(BaseStruct):
    enable_resource_name_dns_aaaa_record: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.\n')
    enable_resource_name_dns_a_record: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to respond to DNS queries for instance hostnames with DNS A records.\n')
    hostname_type: typing.Optional[str] = pydantic.Field(None, description='The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-privatednsnameoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    private_dns_name_options_property = ec2.CfnLaunchTemplate.PrivateDnsNameOptionsProperty(\n        enable_resource_name_dns_aaaa_record=False,\n        enable_resource_name_dns_aRecord=False,\n        hostname_type="hostnameType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enable_resource_name_dns_aaaa_record', 'enable_resource_name_dns_a_record', 'hostname_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.PrivateDnsNameOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.PrivateIpAddProperty
class CfnLaunchTemplate_PrivateIpAddPropertyDef(BaseStruct):
    primary: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.\n')
    private_ip_address: typing.Optional[str] = pydantic.Field(None, description='The private IPv4 address.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privateipadd.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    private_ip_add_property = ec2.CfnLaunchTemplate.PrivateIpAddProperty(\n        primary=False,\n        private_ip_address="privateIpAddress"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['primary', 'private_ip_address']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.PrivateIpAddProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.SpotOptionsProperty
class CfnLaunchTemplate_SpotOptionsPropertyDef(BaseStruct):
    block_duration_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='Deprecated.\n')
    instance_interruption_behavior: typing.Optional[str] = pydantic.Field(None, description='The behavior when a Spot Instance is interrupted. The default is ``terminate`` .\n')
    max_price: typing.Optional[str] = pydantic.Field(None, description="The maximum hourly price you're willing to pay for the Spot Instances. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price. .. epigraph:: If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter.\n")
    spot_instance_type: typing.Optional[str] = pydantic.Field(None, description='The Spot Instance request type. If you are using Spot Instances with an Auto Scaling group, use ``one-time`` requests, as the Amazon EC2 Auto Scaling service handles requesting new Spot Instances whenever the group is below its desired capacity.\n')
    valid_until: typing.Optional[str] = pydantic.Field(None, description='The end date of the request, in UTC format ( *YYYY-MM-DD* T *HH:MM:SS* Z). Supported only for persistent requests. - For a persistent request, the request remains active until the ``ValidUntil`` date and time is reached. Otherwise, the request remains active until you cancel it. - For a one-time request, ``ValidUntil`` is not supported. The request remains active until all instances launch or you cancel the request. Default: 7 days from the current date\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancemarketoptions-spotoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    spot_options_property = ec2.CfnLaunchTemplate.SpotOptionsProperty(\n        block_duration_minutes=123,\n        instance_interruption_behavior="instanceInterruptionBehavior",\n        max_price="maxPrice",\n        spot_instance_type="spotInstanceType",\n        valid_until="validUntil"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['block_duration_minutes', 'instance_interruption_behavior', 'max_price', 'spot_instance_type', 'valid_until']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.SpotOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.TagSpecificationProperty
class CfnLaunchTemplate_TagSpecificationPropertyDef(BaseStruct):
    resource_type: typing.Optional[str] = pydantic.Field(None, description='The type of resource to tag. The ``Valid Values`` are all the resource types that can be tagged. However, when creating a launch template, you can specify tags for the following resource types only: ``instance`` | ``volume`` | ``elastic-gpu`` | ``network-interface`` | ``spot-instances-request`` To tag a resource after it has been created, see `CreateTags <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html>`_ .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to apply to the resource.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-tagspecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    tag_specification_property = ec2.CfnLaunchTemplate.TagSpecificationProperty(\n        resource_type="resourceType",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resource_type', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.TagSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.TotalLocalStorageGBProperty
class CfnLaunchTemplate_TotalLocalStorageGBPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-totallocalstoragegb.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    total_local_storage_gBProperty = ec2.CfnLaunchTemplate.TotalLocalStorageGBProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.TotalLocalStorageGBProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate.VCpuCountProperty
class CfnLaunchTemplate_VCpuCountPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of vCPUs. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of vCPUs. To specify no minimum limit, specify ``0`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-vcpucount.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    v_cpu_count_property = ec2.CfnLaunchTemplate.VCpuCountProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate.VCpuCountProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkAclEntry.IcmpProperty
class CfnNetworkAclEntry_IcmpPropertyDef(BaseStruct):
    code: typing.Union[int, float, None] = pydantic.Field(None, description='The Internet Control Message Protocol (ICMP) code. You can use -1 to specify all ICMP codes for the given ICMP type. Requirement is conditional: Required if you specify 1 (ICMP) for the protocol parameter.\n')
    type: typing.Union[int, float, None] = pydantic.Field(None, description='The Internet Control Message Protocol (ICMP) type. You can use -1 to specify all ICMP types. Conditional requirement: Required if you specify 1 (ICMP) for the ``CreateNetworkAclEntry`` protocol parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    icmp_property = ec2.CfnNetworkAclEntry.IcmpProperty(\n        code=123,\n        type=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['code', 'type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkAclEntry.IcmpProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkAclEntry.PortRangeProperty
class CfnNetworkAclEntry_PortRangePropertyDef(BaseStruct):
    from_: typing.Union[int, float, None] = pydantic.Field(None, description='The first port in the range. Required if you specify 6 (TCP) or 17 (UDP) for the protocol parameter.\n')
    to: typing.Union[int, float, None] = pydantic.Field(None, description='The last port in the range. Required if you specify 6 (TCP) or 17 (UDP) for the protocol parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    port_range_property = ec2.CfnNetworkAclEntry.PortRangeProperty(\n        from=123,\n        to=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['from_', 'to']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkAclEntry.PortRangeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty
class CfnNetworkInsightsAccessScope_AccessScopePathRequestPropertyDef(BaseStruct):
    destination: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAccessScope_PathStatementRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The destination.\n')
    source: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAccessScope_PathStatementRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The source.\n')
    through_resources: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAccessScope_ThroughResourcesStatementRequestPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The through resources.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    access_scope_path_request_property = ec2.CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty(\n        destination=ec2.CfnNetworkInsightsAccessScope.PathStatementRequestProperty(\n            packet_header_statement=ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty(\n                destination_addresses=["destinationAddresses"],\n                destination_ports=["destinationPorts"],\n                destination_prefix_lists=["destinationPrefixLists"],\n                protocols=["protocols"],\n                source_addresses=["sourceAddresses"],\n                source_ports=["sourcePorts"],\n                source_prefix_lists=["sourcePrefixLists"]\n            ),\n            resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(\n                resources=["resources"],\n                resource_types=["resourceTypes"]\n            )\n        ),\n        source=ec2.CfnNetworkInsightsAccessScope.PathStatementRequestProperty(\n            packet_header_statement=ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty(\n                destination_addresses=["destinationAddresses"],\n                destination_ports=["destinationPorts"],\n                destination_prefix_lists=["destinationPrefixLists"],\n                protocols=["protocols"],\n                source_addresses=["sourceAddresses"],\n                source_ports=["sourcePorts"],\n                source_prefix_lists=["sourcePrefixLists"]\n            ),\n            resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(\n                resources=["resources"],\n                resource_types=["resourceTypes"]\n            )\n        ),\n        through_resources=[ec2.CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty(\n            resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(\n                resources=["resources"],\n                resource_types=["resourceTypes"]\n            )\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination', 'source', 'through_resources']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty
class CfnNetworkInsightsAccessScope_PacketHeaderStatementRequestPropertyDef(BaseStruct):
    destination_addresses: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The destination addresses.\n')
    destination_ports: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The destination ports.\n')
    destination_prefix_lists: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The destination prefix lists.\n')
    protocols: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The protocols.\n')
    source_addresses: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The source addresses.\n')
    source_ports: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The source ports.\n')
    source_prefix_lists: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The source prefix lists.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    packet_header_statement_request_property = ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty(\n        destination_addresses=["destinationAddresses"],\n        destination_ports=["destinationPorts"],\n        destination_prefix_lists=["destinationPrefixLists"],\n        protocols=["protocols"],\n        source_addresses=["sourceAddresses"],\n        source_ports=["sourcePorts"],\n        source_prefix_lists=["sourcePrefixLists"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_addresses', 'destination_ports', 'destination_prefix_lists', 'protocols', 'source_addresses', 'source_ports', 'source_prefix_lists']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAccessScope.PathStatementRequestProperty
class CfnNetworkInsightsAccessScope_PathStatementRequestPropertyDef(BaseStruct):
    packet_header_statement: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAccessScope_PacketHeaderStatementRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The packet header statement.\n')
    resource_statement: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAccessScope_ResourceStatementRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The resource statement.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-pathstatementrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    path_statement_request_property = ec2.CfnNetworkInsightsAccessScope.PathStatementRequestProperty(\n        packet_header_statement=ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty(\n            destination_addresses=["destinationAddresses"],\n            destination_ports=["destinationPorts"],\n            destination_prefix_lists=["destinationPrefixLists"],\n            protocols=["protocols"],\n            source_addresses=["sourceAddresses"],\n            source_ports=["sourcePorts"],\n            source_prefix_lists=["sourcePrefixLists"]\n        ),\n        resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(\n            resources=["resources"],\n            resource_types=["resourceTypes"]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['packet_header_statement', 'resource_statement']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAccessScope.PathStatementRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty
class CfnNetworkInsightsAccessScope_ResourceStatementRequestPropertyDef(BaseStruct):
    resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The resources.\n')
    resource_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The resource types.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-resourcestatementrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    resource_statement_request_property = ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(\n        resources=["resources"],\n        resource_types=["resourceTypes"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resources', 'resource_types']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty
class CfnNetworkInsightsAccessScope_ThroughResourcesStatementRequestPropertyDef(BaseStruct):
    resource_statement: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAccessScope_ResourceStatementRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The resource statement.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-throughresourcesstatementrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    through_resources_statement_request_property = ec2.CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty(\n        resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(\n            resources=["resources"],\n            resource_types=["resourceTypes"]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resource_statement']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.AdditionalDetailProperty
class CfnNetworkInsightsAnalysis_AdditionalDetailPropertyDef(BaseStruct):
    additional_detail_type: typing.Optional[str] = pydantic.Field(None, description='The additional detail code.\n')
    component: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The path component.\n')
    load_balancers: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The load balancers.\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the VPC endpoint service.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-additionaldetail.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    additional_detail_property = ec2.CfnNetworkInsightsAnalysis.AdditionalDetailProperty(\n        additional_detail_type="additionalDetailType",\n        component=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        load_balancers=[ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        )],\n        service_name="serviceName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['additional_detail_type', 'component', 'load_balancers', 'service_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.AdditionalDetailProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.AlternatePathHintProperty
class CfnNetworkInsightsAnalysis_AlternatePathHintPropertyDef(BaseStruct):
    component_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the component.\n')
    component_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the component.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-alternatepathhint.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    alternate_path_hint_property = ec2.CfnNetworkInsightsAnalysis.AlternatePathHintProperty(\n        component_arn="componentArn",\n        component_id="componentId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['component_arn', 'component_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.AlternatePathHintProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty
class CfnNetworkInsightsAnalysis_AnalysisAclRulePropertyDef(BaseStruct):
    cidr: typing.Optional[str] = pydantic.Field(None, description='The IPv4 address range, in CIDR notation.\n')
    egress: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether the rule is an outbound rule.\n')
    port_range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_PortRangePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The range of ports.\n')
    protocol: typing.Optional[str] = pydantic.Field(None, description='The protocol.\n')
    rule_action: typing.Optional[str] = pydantic.Field(None, description='Indicates whether to allow or deny traffic that matches the rule.\n')
    rule_number: typing.Union[int, float, None] = pydantic.Field(None, description='The rule number.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    analysis_acl_rule_property = ec2.CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty(\n        cidr="cidr",\n        egress=False,\n        port_range=ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(\n            from=123,\n            to=123\n        ),\n        protocol="protocol",\n        rule_action="ruleAction",\n        rule_number=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cidr', 'egress', 'port_range', 'protocol', 'rule_action', 'rule_number']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty
class CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef(BaseStruct):
    arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the component.\n')
    _init_params: typing.ClassVar[list[str]] = ['arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.AnalysisLoadBalancerListenerProperty
class CfnNetworkInsightsAnalysis_AnalysisLoadBalancerListenerPropertyDef(BaseStruct):
    instance_port: typing.Union[int, float, None] = pydantic.Field(None, description='[Classic Load Balancers] The back-end port for the listener.\n')
    load_balancer_port: typing.Union[int, float, None] = pydantic.Field(None, description='The port on which the load balancer is listening.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancerlistener.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    analysis_load_balancer_listener_property = ec2.CfnNetworkInsightsAnalysis.AnalysisLoadBalancerListenerProperty(\n        instance_port=123,\n        load_balancer_port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_port', 'load_balancer_port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.AnalysisLoadBalancerListenerProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.AnalysisLoadBalancerTargetProperty
class CfnNetworkInsightsAnalysis_AnalysisLoadBalancerTargetPropertyDef(BaseStruct):
    address: typing.Optional[str] = pydantic.Field(None, description='The IP address.\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone.\n')
    instance: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Information about the instance.\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The port on which the target is listening.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    analysis_load_balancer_target_property = ec2.CfnNetworkInsightsAnalysis.AnalysisLoadBalancerTargetProperty(\n        address="address",\n        availability_zone="availabilityZone",\n        instance=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['address', 'availability_zone', 'instance', 'port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.AnalysisLoadBalancerTargetProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty
class CfnNetworkInsightsAnalysis_AnalysisPacketHeaderPropertyDef(BaseStruct):
    destination_addresses: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The destination addresses.\n')
    destination_port_ranges: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_PortRangePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The destination port ranges.\n')
    protocol: typing.Optional[str] = pydantic.Field(None, description='The protocol.\n')
    source_addresses: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The source addresses.\n')
    source_port_ranges: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_PortRangePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The source port ranges.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    analysis_packet_header_property = ec2.CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty(\n        destination_addresses=["destinationAddresses"],\n        destination_port_ranges=[ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(\n            from=123,\n            to=123\n        )],\n        protocol="protocol",\n        source_addresses=["sourceAddresses"],\n        source_port_ranges=[ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(\n            from=123,\n            to=123\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_addresses', 'destination_port_ranges', 'protocol', 'source_addresses', 'source_port_ranges']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty
class CfnNetworkInsightsAnalysis_AnalysisRouteTableRoutePropertyDef(BaseStruct):
    destination_cidr: typing.Optional[str] = pydantic.Field(None, description='The destination IPv4 address, in CIDR notation.\n')
    destination_prefix_list_id: typing.Optional[str] = pydantic.Field(None, description='The prefix of the AWS service .\n')
    egress_only_internet_gateway_id: typing.Optional[str] = pydantic.Field(None, description='The ID of an egress-only internet gateway.\n')
    gateway_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the gateway, such as an internet gateway or virtual private gateway.\n')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the instance, such as a NAT instance.\n')
    nat_gateway_id: typing.Optional[str] = pydantic.Field(None, description='The ID of a NAT gateway.\n')
    network_interface_id: typing.Optional[str] = pydantic.Field(None, description='The ID of a network interface.\n')
    origin: typing.Optional[str] = pydantic.Field(None, description='Describes how the route was created. The following are the possible values:. - CreateRouteTable - The route was automatically created when the route table was created. - CreateRoute - The route was manually added to the route table. - EnableVgwRoutePropagation - The route was propagated by route propagation.\n')
    state: typing.Optional[str] = pydantic.Field(None, description='The state. The following are the possible values:. - active - blackhole\n')
    transit_gateway_id: typing.Optional[str] = pydantic.Field(None, description='The ID of a transit gateway.\n')
    vpc_peering_connection_id: typing.Optional[str] = pydantic.Field(None, description='The ID of a VPC peering connection.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    analysis_route_table_route_property = ec2.CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty(\n        destination_cidr="destinationCidr",\n        destination_prefix_list_id="destinationPrefixListId",\n        egress_only_internet_gateway_id="egressOnlyInternetGatewayId",\n        gateway_id="gatewayId",\n        instance_id="instanceId",\n        nat_gateway_id="natGatewayId",\n        network_interface_id="networkInterfaceId",\n        origin="origin",\n        state="state",\n        transit_gateway_id="transitGatewayId",\n        vpc_peering_connection_id="vpcPeeringConnectionId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_cidr', 'destination_prefix_list_id', 'egress_only_internet_gateway_id', 'gateway_id', 'instance_id', 'nat_gateway_id', 'network_interface_id', 'origin', 'state', 'transit_gateway_id', 'vpc_peering_connection_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty
class CfnNetworkInsightsAnalysis_AnalysisSecurityGroupRulePropertyDef(BaseStruct):
    cidr: typing.Optional[str] = pydantic.Field(None, description='The IPv4 address range, in CIDR notation.\n')
    direction: typing.Optional[str] = pydantic.Field(None, description='The direction. The following are the possible values:. - egress - ingress\n')
    port_range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_PortRangePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The port range.\n')
    prefix_list_id: typing.Optional[str] = pydantic.Field(None, description='The prefix list ID.\n')
    protocol: typing.Optional[str] = pydantic.Field(None, description='The protocol name.\n')
    security_group_id: typing.Optional[str] = pydantic.Field(None, description='The security group ID.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    analysis_security_group_rule_property = ec2.CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty(\n        cidr="cidr",\n        direction="direction",\n        port_range=ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(\n            from=123,\n            to=123\n        ),\n        prefix_list_id="prefixListId",\n        protocol="protocol",\n        security_group_id="securityGroupId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cidr', 'direction', 'port_range', 'prefix_list_id', 'protocol', 'security_group_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.ExplanationProperty
class CfnNetworkInsightsAnalysis_ExplanationPropertyDef(BaseStruct):
    acl: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The network ACL.\n')
    acl_rule: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisAclRulePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The network ACL rule.\n')
    address: typing.Optional[str] = pydantic.Field(None, description='The IPv4 address, in CIDR notation.\n')
    addresses: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IPv4 addresses, in CIDR notation.\n')
    attached_to: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The resource to which the component is attached.\n')
    availability_zones: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Availability Zones.\n')
    cidrs: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The CIDR ranges.\n')
    classic_load_balancer_listener: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisLoadBalancerListenerPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The listener for a Classic Load Balancer.\n')
    component: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The component.\n')
    component_account: typing.Optional[str] = pydantic.Field(None, description='The AWS account for the component.\n')
    component_region: typing.Optional[str] = pydantic.Field(None, description='The Region for the component.\n')
    customer_gateway: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The customer gateway.\n')
    destination: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The destination.\n')
    destination_vpc: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The destination VPC.\n')
    direction: typing.Optional[str] = pydantic.Field(None, description='The direction. The following are the possible values:. - egress - ingress\n')
    elastic_load_balancer_listener: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The load balancer listener.\n')
    explanation_code: typing.Optional[str] = pydantic.Field(None, description='The explanation code.\n')
    ingress_route_table: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The route table.\n')
    internet_gateway: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The internet gateway.\n')
    load_balancer_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the load balancer.\n')
    load_balancer_listener_port: typing.Union[int, float, None] = pydantic.Field(None, description='The listener port of the load balancer.\n')
    load_balancer_target: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisLoadBalancerTargetPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The target.\n')
    load_balancer_target_group: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The target group.\n')
    load_balancer_target_groups: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The target groups.\n')
    load_balancer_target_port: typing.Union[int, float, None] = pydantic.Field(None, description='The target port.\n')
    missing_component: typing.Optional[str] = pydantic.Field(None, description='The missing component.\n')
    nat_gateway: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The NAT gateway.\n')
    network_interface: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The network interface.\n')
    packet_field: typing.Optional[str] = pydantic.Field(None, description='The packet field.\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The port.\n')
    port_ranges: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_PortRangePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The port ranges.\n')
    prefix_list: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The prefix list.\n')
    protocols: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The protocols.\n')
    route_table: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The route table.\n')
    route_table_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisRouteTableRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The route table route.\n')
    security_group: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The security group.\n')
    security_group_rule: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisSecurityGroupRulePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The security group rule.\n')
    security_groups: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The security groups.\n')
    source_vpc: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The source VPC.\n')
    state: typing.Optional[str] = pydantic.Field(None, description='The state.\n')
    subnet: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The subnet.\n')
    subnet_route_table: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The route table for the subnet.\n')
    transit_gateway: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The transit gateway.\n')
    transit_gateway_attachment: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The transit gateway attachment.\n')
    transit_gateway_route_table: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The transit gateway route table.\n')
    transit_gateway_route_table_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_TransitGatewayRouteTableRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The transit gateway route table route.\n')
    vpc: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The component VPC.\n')
    vpc_endpoint: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The VPC endpoint.\n')
    vpc_peering_connection: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The VPC peering connection.\n')
    vpn_connection: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The VPN connection.\n')
    vpn_gateway: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The VPN gateway.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    explanation_property = ec2.CfnNetworkInsightsAnalysis.ExplanationProperty(\n        acl=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        acl_rule=ec2.CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty(\n            cidr="cidr",\n            egress=False,\n            port_range=ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(\n                from=123,\n                to=123\n            ),\n            protocol="protocol",\n            rule_action="ruleAction",\n            rule_number=123\n        ),\n        address="address",\n        addresses=["addresses"],\n        attached_to=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        availability_zones=["availabilityZones"],\n        cidrs=["cidrs"],\n        classic_load_balancer_listener=ec2.CfnNetworkInsightsAnalysis.AnalysisLoadBalancerListenerProperty(\n            instance_port=123,\n            load_balancer_port=123\n        ),\n        component=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        component_account="componentAccount",\n        component_region="componentRegion",\n        customer_gateway=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        destination=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        destination_vpc=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        direction="direction",\n        elastic_load_balancer_listener=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        explanation_code="explanationCode",\n        ingress_route_table=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        internet_gateway=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        load_balancer_arn="loadBalancerArn",\n        load_balancer_listener_port=123,\n        load_balancer_target=ec2.CfnNetworkInsightsAnalysis.AnalysisLoadBalancerTargetProperty(\n            address="address",\n            availability_zone="availabilityZone",\n            instance=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            port=123\n        ),\n        load_balancer_target_group=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        load_balancer_target_groups=[ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        )],\n        load_balancer_target_port=123,\n        missing_component="missingComponent",\n        nat_gateway=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        network_interface=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        packet_field="packetField",\n        port=123,\n        port_ranges=[ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(\n            from=123,\n            to=123\n        )],\n        prefix_list=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        protocols=["protocols"],\n        route_table=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        route_table_route=ec2.CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty(\n            destination_cidr="destinationCidr",\n            destination_prefix_list_id="destinationPrefixListId",\n            egress_only_internet_gateway_id="egressOnlyInternetGatewayId",\n            gateway_id="gatewayId",\n            instance_id="instanceId",\n            nat_gateway_id="natGatewayId",\n            network_interface_id="networkInterfaceId",\n            origin="origin",\n            state="state",\n            transit_gateway_id="transitGatewayId",\n            vpc_peering_connection_id="vpcPeeringConnectionId"\n        ),\n        security_group=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        security_group_rule=ec2.CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty(\n            cidr="cidr",\n            direction="direction",\n            port_range=ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(\n                from=123,\n                to=123\n            ),\n            prefix_list_id="prefixListId",\n            protocol="protocol",\n            security_group_id="securityGroupId"\n        ),\n        security_groups=[ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        )],\n        source_vpc=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        state="state",\n        subnet=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        subnet_route_table=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        transit_gateway=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        transit_gateway_attachment=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        transit_gateway_route_table=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        transit_gateway_route_table_route=ec2.CfnNetworkInsightsAnalysis.TransitGatewayRouteTableRouteProperty(\n            attachment_id="attachmentId",\n            destination_cidr="destinationCidr",\n            prefix_list_id="prefixListId",\n            resource_id="resourceId",\n            resource_type="resourceType",\n            route_origin="routeOrigin",\n            state="state"\n        ),\n        vpc=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        vpc_endpoint=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        vpc_peering_connection=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        vpn_connection=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        vpn_gateway=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['acl', 'acl_rule', 'address', 'addresses', 'attached_to', 'availability_zones', 'cidrs', 'classic_load_balancer_listener', 'component', 'component_account', 'component_region', 'customer_gateway', 'destination', 'destination_vpc', 'direction', 'elastic_load_balancer_listener', 'explanation_code', 'ingress_route_table', 'internet_gateway', 'load_balancer_arn', 'load_balancer_listener_port', 'load_balancer_target', 'load_balancer_target_group', 'load_balancer_target_groups', 'load_balancer_target_port', 'missing_component', 'nat_gateway', 'network_interface', 'packet_field', 'port', 'port_ranges', 'prefix_list', 'protocols', 'route_table', 'route_table_route', 'security_group', 'security_group_rule', 'security_groups', 'source_vpc', 'state', 'subnet', 'subnet_route_table', 'transit_gateway', 'transit_gateway_attachment', 'transit_gateway_route_table', 'transit_gateway_route_table_route', 'vpc', 'vpc_endpoint', 'vpc_peering_connection', 'vpn_connection', 'vpn_gateway']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.ExplanationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.PathComponentProperty
class CfnNetworkInsightsAnalysis_PathComponentPropertyDef(BaseStruct):
    acl_rule: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisAclRulePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The network ACL rule.\n')
    additional_details: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AdditionalDetailPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The additional details.\n')
    component: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The component.\n')
    destination_vpc: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The destination VPC.\n')
    elastic_load_balancer_listener: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The load balancer listener.\n')
    explanations: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_ExplanationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The explanation codes.\n')
    inbound_header: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisPacketHeaderPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The inbound header.\n')
    outbound_header: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisPacketHeaderPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The outbound header.\n')
    route_table_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisRouteTableRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The route table route.\n')
    security_group_rule: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisSecurityGroupRulePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The security group rule.\n')
    sequence_number: typing.Union[int, float, None] = pydantic.Field(None, description='The sequence number.\n')
    service_name: typing.Optional[str] = pydantic.Field(None, description='The name of the VPC endpoint service.\n')
    source_vpc: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The source VPC.\n')
    subnet: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The subnet.\n')
    transit_gateway: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The transit gateway.\n')
    transit_gateway_route_table_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_TransitGatewayRouteTableRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The route in a transit gateway route table.\n')
    vpc: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The component VPC.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    path_component_property = ec2.CfnNetworkInsightsAnalysis.PathComponentProperty(\n        acl_rule=ec2.CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty(\n            cidr="cidr",\n            egress=False,\n            port_range=ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(\n                from=123,\n                to=123\n            ),\n            protocol="protocol",\n            rule_action="ruleAction",\n            rule_number=123\n        ),\n        additional_details=[ec2.CfnNetworkInsightsAnalysis.AdditionalDetailProperty(\n            additional_detail_type="additionalDetailType",\n            component=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            load_balancers=[ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            )],\n            service_name="serviceName"\n        )],\n        component=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        destination_vpc=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        elastic_load_balancer_listener=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        explanations=[ec2.CfnNetworkInsightsAnalysis.ExplanationProperty(\n            acl=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            acl_rule=ec2.CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty(\n                cidr="cidr",\n                egress=False,\n                port_range=ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(\n                    from=123,\n                    to=123\n                ),\n                protocol="protocol",\n                rule_action="ruleAction",\n                rule_number=123\n            ),\n            address="address",\n            addresses=["addresses"],\n            attached_to=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            availability_zones=["availabilityZones"],\n            cidrs=["cidrs"],\n            classic_load_balancer_listener=ec2.CfnNetworkInsightsAnalysis.AnalysisLoadBalancerListenerProperty(\n                instance_port=123,\n                load_balancer_port=123\n            ),\n            component=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            component_account="componentAccount",\n            component_region="componentRegion",\n            customer_gateway=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            destination=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            destination_vpc=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            direction="direction",\n            elastic_load_balancer_listener=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            explanation_code="explanationCode",\n            ingress_route_table=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            internet_gateway=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            load_balancer_arn="loadBalancerArn",\n            load_balancer_listener_port=123,\n            load_balancer_target=ec2.CfnNetworkInsightsAnalysis.AnalysisLoadBalancerTargetProperty(\n                address="address",\n                availability_zone="availabilityZone",\n                instance=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                    arn="arn",\n                    id="id"\n                ),\n                port=123\n            ),\n            load_balancer_target_group=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            load_balancer_target_groups=[ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            )],\n            load_balancer_target_port=123,\n            missing_component="missingComponent",\n            nat_gateway=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            network_interface=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            packet_field="packetField",\n            port=123,\n            port_ranges=[ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(\n                from=123,\n                to=123\n            )],\n            prefix_list=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            protocols=["protocols"],\n            route_table=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            route_table_route=ec2.CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty(\n                destination_cidr="destinationCidr",\n                destination_prefix_list_id="destinationPrefixListId",\n                egress_only_internet_gateway_id="egressOnlyInternetGatewayId",\n                gateway_id="gatewayId",\n                instance_id="instanceId",\n                nat_gateway_id="natGatewayId",\n                network_interface_id="networkInterfaceId",\n                origin="origin",\n                state="state",\n                transit_gateway_id="transitGatewayId",\n                vpc_peering_connection_id="vpcPeeringConnectionId"\n            ),\n            security_group=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            security_group_rule=ec2.CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty(\n                cidr="cidr",\n                direction="direction",\n                port_range=ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(\n                    from=123,\n                    to=123\n                ),\n                prefix_list_id="prefixListId",\n                protocol="protocol",\n                security_group_id="securityGroupId"\n            ),\n            security_groups=[ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            )],\n            source_vpc=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            state="state",\n            subnet=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            subnet_route_table=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            transit_gateway=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            transit_gateway_attachment=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            transit_gateway_route_table=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            transit_gateway_route_table_route=ec2.CfnNetworkInsightsAnalysis.TransitGatewayRouteTableRouteProperty(\n                attachment_id="attachmentId",\n                destination_cidr="destinationCidr",\n                prefix_list_id="prefixListId",\n                resource_id="resourceId",\n                resource_type="resourceType",\n                route_origin="routeOrigin",\n                state="state"\n            ),\n            vpc=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            vpc_endpoint=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            vpc_peering_connection=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            vpn_connection=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            ),\n            vpn_gateway=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n                arn="arn",\n                id="id"\n            )\n        )],\n        inbound_header=ec2.CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty(\n            destination_addresses=["destinationAddresses"],\n            destination_port_ranges=[ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(\n                from=123,\n                to=123\n            )],\n            protocol="protocol",\n            source_addresses=["sourceAddresses"],\n            source_port_ranges=[ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(\n                from=123,\n                to=123\n            )]\n        ),\n        outbound_header=ec2.CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty(\n            destination_addresses=["destinationAddresses"],\n            destination_port_ranges=[ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(\n                from=123,\n                to=123\n            )],\n            protocol="protocol",\n            source_addresses=["sourceAddresses"],\n            source_port_ranges=[ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(\n                from=123,\n                to=123\n            )]\n        ),\n        route_table_route=ec2.CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty(\n            destination_cidr="destinationCidr",\n            destination_prefix_list_id="destinationPrefixListId",\n            egress_only_internet_gateway_id="egressOnlyInternetGatewayId",\n            gateway_id="gatewayId",\n            instance_id="instanceId",\n            nat_gateway_id="natGatewayId",\n            network_interface_id="networkInterfaceId",\n            origin="origin",\n            state="state",\n            transit_gateway_id="transitGatewayId",\n            vpc_peering_connection_id="vpcPeeringConnectionId"\n        ),\n        security_group_rule=ec2.CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty(\n            cidr="cidr",\n            direction="direction",\n            port_range=ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(\n                from=123,\n                to=123\n            ),\n            prefix_list_id="prefixListId",\n            protocol="protocol",\n            security_group_id="securityGroupId"\n        ),\n        sequence_number=123,\n        service_name="serviceName",\n        source_vpc=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        subnet=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        transit_gateway=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        ),\n        transit_gateway_route_table_route=ec2.CfnNetworkInsightsAnalysis.TransitGatewayRouteTableRouteProperty(\n            attachment_id="attachmentId",\n            destination_cidr="destinationCidr",\n            prefix_list_id="prefixListId",\n            resource_id="resourceId",\n            resource_type="resourceType",\n            route_origin="routeOrigin",\n            state="state"\n        ),\n        vpc=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(\n            arn="arn",\n            id="id"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['acl_rule', 'additional_details', 'component', 'destination_vpc', 'elastic_load_balancer_listener', 'explanations', 'inbound_header', 'outbound_header', 'route_table_route', 'security_group_rule', 'sequence_number', 'service_name', 'source_vpc', 'subnet', 'transit_gateway', 'transit_gateway_route_table_route', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.PathComponentProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.PortRangeProperty
class CfnNetworkInsightsAnalysis_PortRangePropertyDef(BaseStruct):
    from_: typing.Union[int, float, None] = pydantic.Field(None, description='The first port in the range.\n')
    to: typing.Union[int, float, None] = pydantic.Field(None, description='The last port in the range.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-portrange.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    port_range_property = ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(\n        from=123,\n        to=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['from_', 'to']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.PortRangeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.TransitGatewayRouteTableRouteProperty
class CfnNetworkInsightsAnalysis_TransitGatewayRouteTableRoutePropertyDef(BaseStruct):
    attachment_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the route attachment.\n')
    destination_cidr: typing.Optional[str] = pydantic.Field(None, description='The CIDR block used for destination matches.\n')
    prefix_list_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the prefix list.\n')
    resource_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the resource for the route attachment.\n')
    resource_type: typing.Optional[str] = pydantic.Field(None, description='The resource type for the route attachment.\n')
    route_origin: typing.Optional[str] = pydantic.Field(None, description='The route origin. The following are the possible values:. - static - propagated\n')
    state: typing.Optional[str] = pydantic.Field(None, description='The state of the route.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    transit_gateway_route_table_route_property = ec2.CfnNetworkInsightsAnalysis.TransitGatewayRouteTableRouteProperty(\n        attachment_id="attachmentId",\n        destination_cidr="destinationCidr",\n        prefix_list_id="prefixListId",\n        resource_id="resourceId",\n        resource_type="resourceType",\n        route_origin="routeOrigin",\n        state="state"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['attachment_id', 'destination_cidr', 'prefix_list_id', 'resource_id', 'resource_type', 'route_origin', 'state']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis.TransitGatewayRouteTableRouteProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsPath.FilterPortRangeProperty
class CfnNetworkInsightsPath_FilterPortRangePropertyDef(BaseStruct):
    from_port: typing.Union[int, float, None] = pydantic.Field(None, description='The first port in the range.\n')
    to_port: typing.Union[int, float, None] = pydantic.Field(None, description='The last port in the range.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-filterportrange.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    filter_port_range_property = ec2.CfnNetworkInsightsPath.FilterPortRangeProperty(\n        from_port=123,\n        to_port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['from_port', 'to_port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsPath.FilterPortRangeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsPath.PathFilterProperty
class CfnNetworkInsightsPath_PathFilterPropertyDef(BaseStruct):
    destination_address: typing.Optional[str] = pydantic.Field(None, description='The destination IPv4 address.\n')
    destination_port_range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsPath_FilterPortRangePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The destination port range.\n')
    source_address: typing.Optional[str] = pydantic.Field(None, description='The source IPv4 address.\n')
    source_port_range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsPath_FilterPortRangePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The source port range.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    path_filter_property = ec2.CfnNetworkInsightsPath.PathFilterProperty(\n        destination_address="destinationAddress",\n        destination_port_range=ec2.CfnNetworkInsightsPath.FilterPortRangeProperty(\n            from_port=123,\n            to_port=123\n        ),\n        source_address="sourceAddress",\n        source_port_range=ec2.CfnNetworkInsightsPath.FilterPortRangeProperty(\n            from_port=123,\n            to_port=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_address', 'destination_port_range', 'source_address', 'source_port_range']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsPath.PathFilterProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInterface.InstanceIpv6AddressProperty
class CfnNetworkInterface_InstanceIpv6AddressPropertyDef(BaseStruct):
    ipv6_address: str = pydantic.Field(..., description='An IPv6 address to associate with the network interface.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    instance_ipv6_address_property = ec2.CfnNetworkInterface.InstanceIpv6AddressProperty(\n        ipv6_address="ipv6Address"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ipv6_address']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInterface.InstanceIpv6AddressProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInterface.PrivateIpAddressSpecificationProperty
class CfnNetworkInterface_PrivateIpAddressSpecificationPropertyDef(BaseStruct):
    primary: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description="Sets the private IP address as the primary private address. You can set only one primary private IP address. If you don't specify a primary private IP address, Amazon EC2 automatically assigns a primary private IP address.\n")
    private_ip_address: str = pydantic.Field(..., description='The private IP address of the network interface.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    private_ip_address_specification_property = ec2.CfnNetworkInterface.PrivateIpAddressSpecificationProperty(\n        primary=False,\n        private_ip_address="privateIpAddress"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['primary', 'private_ip_address']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInterface.PrivateIpAddressSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnPrefixList.EntryProperty
class CfnPrefixList_EntryPropertyDef(BaseStruct):
    cidr: str = pydantic.Field(..., description='The CIDR block.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the entry. Constraints: Up to 255 characters in length.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    entry_property = ec2.CfnPrefixList.EntryProperty(\n        cidr="cidr",\n\n        # the properties below are optional\n        description="description"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cidr', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnPrefixList.EntryProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSecurityGroup.EgressProperty
class CfnSecurityGroup_EgressPropertyDef(BaseStruct):
    ip_protocol: str = pydantic.Field(..., description='The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ). Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.\n')
    cidr_ip: typing.Optional[str] = pydantic.Field(None, description='The IPv4 address range, in CIDR format. You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ). For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .\n')
    cidr_ipv6: typing.Optional[str] = pydantic.Field(None, description='The IPv6 address range, in CIDR format. You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ). For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the security group rule. Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*\n')
    destination_prefix_list_id: typing.Optional[str] = pydantic.Field(None, description='The prefix list IDs for the destination AWS service. This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group. You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).\n')
    destination_security_group_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the destination VPC security group. You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).\n')
    from_port: typing.Union[int, float, None] = pydantic.Field(None, description='If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the type number. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.\n')
    to_port: typing.Union[int, float, None] = pydantic.Field(None, description='If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the code. A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    egress_property = ec2.CfnSecurityGroup.EgressProperty(\n        ip_protocol="ipProtocol",\n\n        # the properties below are optional\n        cidr_ip="cidrIp",\n        cidr_ipv6="cidrIpv6",\n        description="description",\n        destination_prefix_list_id="destinationPrefixListId",\n        destination_security_group_id="destinationSecurityGroupId",\n        from_port=123,\n        to_port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ip_protocol', 'cidr_ip', 'cidr_ipv6', 'description', 'destination_prefix_list_id', 'destination_security_group_id', 'from_port', 'to_port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSecurityGroup.EgressProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSecurityGroup.IngressProperty
class CfnSecurityGroup_IngressPropertyDef(BaseStruct):
    ip_protocol: str = pydantic.Field(..., description='The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ). Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.\n')
    cidr_ip: typing.Optional[str] = pydantic.Field(None, description='The IPv4 address range, in CIDR format. You must specify a source security group ( ``SourcePrefixListId`` or ``SourceSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ). For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .\n')
    cidr_ipv6: typing.Optional[str] = pydantic.Field(None, description='The IPv6 address range, in CIDR format. You must specify a source security group ( ``SourcePrefixListId`` or ``SourceSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ). For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Updates the description of an ingress (inbound) security group rule. You can replace an existing description, or add a description to a rule that did not have one previously. Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*\n')
    from_port: typing.Union[int, float, None] = pydantic.Field(None, description='If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the type number. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.\n')
    source_prefix_list_id: typing.Optional[str] = pydantic.Field(None, description='The ID of a prefix list.\n')
    source_security_group_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the security group. You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.\n')
    source_security_group_name: typing.Optional[str] = pydantic.Field(None, description="[Default VPC] The name of the source security group. You must specify either the security group ID or the security group name. You can't specify the group name in combination with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access. For security groups in a nondefault VPC, you must specify the group ID.\n")
    source_security_group_owner_id: typing.Optional[str] = pydantic.Field(None, description="[nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account. You can't specify this property with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access. If you specify ``SourceSecurityGroupName`` or ``SourceSecurityGroupId`` and that security group is owned by a different account than the account creating the stack, you must specify the ``SourceSecurityGroupOwnerId`` ; otherwise, this property is optional.\n")
    to_port: typing.Union[int, float, None] = pydantic.Field(None, description='If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the code. A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    ingress_property = ec2.CfnSecurityGroup.IngressProperty(\n        ip_protocol="ipProtocol",\n\n        # the properties below are optional\n        cidr_ip="cidrIp",\n        cidr_ipv6="cidrIpv6",\n        description="description",\n        from_port=123,\n        source_prefix_list_id="sourcePrefixListId",\n        source_security_group_id="sourceSecurityGroupId",\n        source_security_group_name="sourceSecurityGroupName",\n        source_security_group_owner_id="sourceSecurityGroupOwnerId",\n        to_port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ip_protocol', 'cidr_ip', 'cidr_ipv6', 'description', 'from_port', 'source_prefix_list_id', 'source_security_group_id', 'source_security_group_name', 'source_security_group_owner_id', 'to_port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSecurityGroup.IngressProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.AcceleratorCountRequestProperty
class CfnSpotFleet_AcceleratorCountRequestPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of accelerators. To specify no minimum limit, omit this parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratorcountrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    accelerator_count_request_property = ec2.CfnSpotFleet.AcceleratorCountRequestProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.AcceleratorCountRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty
class CfnSpotFleet_AcceleratorTotalMemoryMiBRequestPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratortotalmemorymibrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    accelerator_total_memory_mi_bRequest_property = ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty
class CfnSpotFleet_BaselineEbsBandwidthMbpsRequestPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-baselineebsbandwidthmbpsrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    baseline_ebs_bandwidth_mbps_request_property = ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.BlockDeviceMappingProperty
class CfnSpotFleet_BlockDeviceMappingPropertyDef(BaseStruct):
    device_name: str = pydantic.Field(..., description='The device name (for example, ``/dev/sdh`` or ``xvdh`` ).\n')
    ebs: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_EbsBlockDevicePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Parameters used to automatically set up EBS volumes when the instance is launched.\n')
    no_device: typing.Optional[str] = pydantic.Field(None, description='To omit the device from the block device mapping, specify an empty string. When this property is specified, the device is removed from the block device mapping regardless of the assigned value.\n')
    virtual_name: typing.Optional[str] = pydantic.Field(None, description='The virtual device name ( ``ephemeral`` N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ``ephemeral0`` and ``ephemeral1`` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume. NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect. Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    block_device_mapping_property = ec2.CfnSpotFleet.BlockDeviceMappingProperty(\n        device_name="deviceName",\n\n        # the properties below are optional\n        ebs=ec2.CfnSpotFleet.EbsBlockDeviceProperty(\n            delete_on_termination=False,\n            encrypted=False,\n            iops=123,\n            snapshot_id="snapshotId",\n            volume_size=123,\n            volume_type="volumeType"\n        ),\n        no_device="noDevice",\n        virtual_name="virtualName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['device_name', 'ebs', 'no_device', 'virtual_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.BlockDeviceMappingProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.ClassicLoadBalancerProperty
class CfnSpotFleet_ClassicLoadBalancerPropertyDef(BaseStruct):
    name: str = pydantic.Field(..., description='The name of the load balancer.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancer.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    classic_load_balancer_property = ec2.CfnSpotFleet.ClassicLoadBalancerProperty(\n        name="name"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.ClassicLoadBalancerProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.ClassicLoadBalancersConfigProperty
class CfnSpotFleet_ClassicLoadBalancersConfigPropertyDef(BaseStruct):
    classic_load_balancers: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_ClassicLoadBalancerPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='One or more Classic Load Balancers.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancersconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    classic_load_balancers_config_property = ec2.CfnSpotFleet.ClassicLoadBalancersConfigProperty(\n        classic_load_balancers=[ec2.CfnSpotFleet.ClassicLoadBalancerProperty(\n            name="name"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['classic_load_balancers']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.ClassicLoadBalancersConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.EbsBlockDeviceProperty
class CfnSpotFleet_EbsBlockDevicePropertyDef(BaseStruct):
    delete_on_termination: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether the EBS volume is deleted on instance termination. For more information, see `Preserving Amazon EBS volumes on instance termination <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination>`_ in the *Amazon EC2 User Guide* .\n')
    encrypted: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot. The effect of setting the encryption state to ``true`` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Amazon EBS Encryption <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-parameters>`_ in the *Amazon EC2 User Guide* . In no case can you remove encryption from an encrypted volume. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see `Supported Instance Types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances>`_ . This parameter is not returned by `DescribeImageAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html>`_ .\n')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='The number of I/O operations per second (IOPS). For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. The following are the supported values for each volume type: - ``gp3`` : 3,000-16,000 IOPS - ``io1`` : 100-64,000 IOPS - ``io2`` : 100-64,000 IOPS For ``io1`` and ``io2`` volumes, we guarantee 64,000 IOPS only for `Instances built on the Nitro System <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ . Other instance families guarantee performance up to 32,000 IOPS. This parameter is required for ``io1`` and ``io2`` volumes. The default for ``gp3`` volumes is 3,000 IOPS. This parameter is not supported for ``gp2`` , ``st1`` , ``sc1`` , or ``standard`` volumes.\n')
    snapshot_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the snapshot.\n')
    volume_size: typing.Union[int, float, None] = pydantic.Field(None, description='The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size. The following are the supported volumes sizes for each volume type: - ``gp2`` and ``gp3`` :1-16,384 - ``io1`` and ``io2`` : 4-16,384 - ``st1`` and ``sc1`` : 125-16,384 - ``standard`` : 1-1,024\n')
    volume_type: typing.Optional[str] = pydantic.Field(None, description='The volume type. For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>`_ in the *Amazon EC2 User Guide* . If the volume type is ``io1`` or ``io2`` , you must specify the IOPS that the volume supports.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    ebs_block_device_property = ec2.CfnSpotFleet.EbsBlockDeviceProperty(\n        delete_on_termination=False,\n        encrypted=False,\n        iops=123,\n        snapshot_id="snapshotId",\n        volume_size=123,\n        volume_type="volumeType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['delete_on_termination', 'encrypted', 'iops', 'snapshot_id', 'volume_size', 'volume_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.EbsBlockDeviceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.FleetLaunchTemplateSpecificationProperty
class CfnSpotFleet_FleetLaunchTemplateSpecificationPropertyDef(BaseStruct):
    version: str = pydantic.Field(..., description='The version number of the launch template. Specifying ``$Latest`` or ``$Default`` for the template version number is not supported. However, you can specify ``LatestVersionNumber`` or ``DefaultVersionNumber`` using the ``Fn::GetAtt`` intrinsic function. For more information, see `Fn::GetAtt <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate-return-values-fn--getatt>`_ .\n')
    launch_template_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the launch template. You must specify the ``LaunchTemplateId`` or the ``LaunchTemplateName`` , but not both.\n')
    launch_template_name: typing.Optional[str] = pydantic.Field(None, description='The name of the launch template. You must specify the ``LaunchTemplateName`` or the ``LaunchTemplateId`` , but not both.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-fleetlaunchtemplatespecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    fleet_launch_template_specification_property = ec2.CfnSpotFleet.FleetLaunchTemplateSpecificationProperty(\n        version="version",\n\n        # the properties below are optional\n        launch_template_id="launchTemplateId",\n        launch_template_name="launchTemplateName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['version', 'launch_template_id', 'launch_template_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.FleetLaunchTemplateSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.GroupIdentifierProperty
class CfnSpotFleet_GroupIdentifierPropertyDef(BaseStruct):
    group_id: str = pydantic.Field(..., description='The ID of the security group.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-groupidentifier.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    group_identifier_property = ec2.CfnSpotFleet.GroupIdentifierProperty(\n        group_id="groupId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['group_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.GroupIdentifierProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.IamInstanceProfileSpecificationProperty
class CfnSpotFleet_IamInstanceProfileSpecificationPropertyDef(BaseStruct):
    arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the instance profile.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-iaminstanceprofilespecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    iam_instance_profile_specification_property = ec2.CfnSpotFleet.IamInstanceProfileSpecificationProperty(\n        arn="arn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.IamInstanceProfileSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.InstanceIpv6AddressProperty
class CfnSpotFleet_InstanceIpv6AddressPropertyDef(BaseStruct):
    ipv6_address: str = pydantic.Field(..., description='The IPv6 address.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instanceipv6address.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    instance_ipv6_address_property = ec2.CfnSpotFleet.InstanceIpv6AddressProperty(\n        ipv6_address="ipv6Address"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ipv6_address']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.InstanceIpv6AddressProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.InstanceNetworkInterfaceSpecificationProperty
class CfnSpotFleet_InstanceNetworkInterfaceSpecificationPropertyDef(BaseStruct):
    associate_public_ip_address: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is ``true`` .\n')
    delete_on_termination: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether the network interface is deleted when the instance is terminated.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the network interface. Applies only if creating a network interface when launching an instance.\n')
    device_index: typing.Union[int, float, None] = pydantic.Field(None, description='The position of the network interface in the attachment order. A primary network interface has a device index of 0. If you specify a network interface when launching an instance, you must specify the device index.\n')
    groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.\n')
    ipv6_address_count: typing.Union[int, float, None] = pydantic.Field(None, description="A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.\n")
    ipv6_addresses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_InstanceIpv6AddressPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="The IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.\n")
    network_interface_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the network interface. If you are creating a Spot Fleet, omit this parameter because you can’t specify a network interface ID in a launch specification.\n')
    private_ip_addresses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_PrivateIpAddressSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="The private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a `RunInstances <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html>`_ request.\n")
    secondary_private_ip_address_count: typing.Union[int, float, None] = pydantic.Field(None, description="The number of secondary private IPv4 addresses. You can't specify this option and specify more than one private IP address using the private IP addresses option. You cannot specify this option if you're launching more than one instance in a `RunInstances <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html>`_ request.\n")
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the subnet associated with the network interface. Applies only if creating a network interface when launching an instance.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    instance_network_interface_specification_property = ec2.CfnSpotFleet.InstanceNetworkInterfaceSpecificationProperty(\n        associate_public_ip_address=False,\n        delete_on_termination=False,\n        description="description",\n        device_index=123,\n        groups=["groups"],\n        ipv6_address_count=123,\n        ipv6_addresses=[ec2.CfnSpotFleet.InstanceIpv6AddressProperty(\n            ipv6_address="ipv6Address"\n        )],\n        network_interface_id="networkInterfaceId",\n        private_ip_addresses=[ec2.CfnSpotFleet.PrivateIpAddressSpecificationProperty(\n            private_ip_address="privateIpAddress",\n\n            # the properties below are optional\n            primary=False\n        )],\n        secondary_private_ip_address_count=123,\n        subnet_id="subnetId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['associate_public_ip_address', 'delete_on_termination', 'description', 'device_index', 'groups', 'ipv6_address_count', 'ipv6_addresses', 'network_interface_id', 'private_ip_addresses', 'secondary_private_ip_address_count', 'subnet_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.InstanceNetworkInterfaceSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.InstanceRequirementsRequestProperty
class CfnSpotFleet_InstanceRequirementsRequestPropertyDef(BaseStruct):
    accelerator_count: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_AcceleratorCountRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` . Default: No minimum or maximum limits\n')
    accelerator_manufacturers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Indicates whether instance types must have accelerators by specific manufacturers. - For instance types with NVIDIA devices, specify ``nvidia`` . - For instance types with AMD devices, specify ``amd`` . - For instance types with AWS devices, specify ``amazon-web-services`` . - For instance types with Xilinx devices, specify ``xilinx`` . Default: Any manufacturer\n')
    accelerator_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The accelerators that must be on the instance type. - For instance types with NVIDIA A100 GPUs, specify ``a100`` . - For instance types with NVIDIA V100 GPUs, specify ``v100`` . - For instance types with NVIDIA K80 GPUs, specify ``k80`` . - For instance types with NVIDIA T4 GPUs, specify ``t4`` . - For instance types with NVIDIA M60 GPUs, specify ``m60`` . - For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520`` . - For instance types with Xilinx VU9P FPGAs, specify ``vu9p`` . - For instance types with AWS Inferentia chips, specify ``inferentia`` . - For instance types with NVIDIA GRID K520 GPUs, specify ``k520`` . Default: Any accelerator\n')
    accelerator_total_memory_mib: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_AcceleratorTotalMemoryMiBRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum amount of total accelerator memory, in MiB. Default: No minimum or maximum limits\n')
    accelerator_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The accelerator types that must be on the instance type. - To include instance types with GPU hardware, specify ``gpu`` . - To include instance types with FPGA hardware, specify ``fpga`` . - To include instance types with inference hardware, specify ``inference`` . Default: Any accelerator type\n')
    allowed_instance_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to allow an instance type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` . For example, if you specify ``c5*`` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types. .. epigraph:: If you specify ``AllowedInstanceTypes`` , you can't specify ``ExcludedInstanceTypes`` . Default: All instance types\n")
    bare_metal: typing.Optional[str] = pydantic.Field(None, description='Indicates whether bare metal instance types must be included, excluded, or required. - To include bare metal instance types, specify ``included`` . - To require only bare metal instance types, specify ``required`` . - To exclude bare metal instance types, specify ``excluded`` . Default: ``excluded``\n')
    baseline_ebs_bandwidth_mbps: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_BaselineEbsBandwidthMbpsRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see `Amazon EBS–optimized instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html>`_ in the *Amazon EC2 User Guide* . Default: No minimum or maximum limits\n')
    burstable_performance: typing.Optional[str] = pydantic.Field(None, description='Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ . - To include burstable performance instance types, specify ``included`` . - To require only burstable performance instance types, specify ``required`` . - To exclude burstable performance instance types, specify ``excluded`` . Default: ``excluded``\n')
    cpu_manufacturers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The CPU manufacturers to include. - For instance types with Intel CPUs, specify ``intel`` . - For instance types with AMD CPUs, specify ``amd`` . - For instance types with AWS CPUs, specify ``amazon-web-services`` . .. epigraph:: Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. Default: Any manufacturer\n")
    excluded_instance_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to exclude an instance family, type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` . For example, if you specify ``c5*`` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types. .. epigraph:: If you specify ``ExcludedInstanceTypes`` , you can't specify ``AllowedInstanceTypes`` . Default: No excluded instance types\n")
    instance_generations: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* . For current generation instance types, specify ``current`` . For previous generation instance types, specify ``previous`` . Default: Current and previous generation instance types\n')
    local_storage: typing.Optional[str] = pydantic.Field(None, description='Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, `Amazon EC2 instance store <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html>`_ in the *Amazon EC2 User Guide* . - To include instance types with instance store volumes, specify ``included`` . - To require only instance types with instance store volumes, specify ``required`` . - To exclude instance types with instance store volumes, specify ``excluded`` . Default: ``included``\n')
    local_storage_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The type of local storage that is required. - For instance types with hard disk drive (HDD) storage, specify ``hdd`` . - For instance types with solid state drive (SSD) storage, specify ``ssd`` . Default: ``hdd`` and ``ssd``\n')
    memory_gib_per_v_cpu: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_MemoryGiBPerVCpuRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum amount of memory per vCPU, in GiB. Default: No minimum or maximum limits\n')
    memory_mib: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_MemoryMiBRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum amount of memory, in MiB.\n')
    network_bandwidth_gbps: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_NetworkBandwidthGbpsRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default: No minimum or maximum limits\n')
    network_interface_count: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_NetworkInterfaceCountRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum number of network interfaces. Default: No minimum or maximum limits\n')
    on_demand_max_price_percentage_over_lowest_price: typing.Union[int, float, None] = pydantic.Field(None, description='The price protection threshold for On-Demand Instances. This is the maximum you’ll pay for an On-Demand Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. To turn off price protection, specify a high value, such as ``999999`` . This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ . .. epigraph:: If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. Default: ``20``\n')
    require_hibernate_support: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether instance types must support hibernation for On-Demand Instances. This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ . Default: ``false``\n')
    spot_max_price_percentage_over_lowest_price: typing.Union[int, float, None] = pydantic.Field(None, description='The price protection threshold for Spot Instance. This is the maximum you’ll pay for an Spot Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. To turn off price protection, specify a high value, such as ``999999`` . This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ . .. epigraph:: If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. Default: ``100``\n')
    total_local_storage_gb: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_TotalLocalStorageGBRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum amount of total local storage, in GB. Default: No minimum or maximum limits\n')
    v_cpu_count: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_VCpuCountRangeRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The minimum and maximum number of vCPUs.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    instance_requirements_request_property = ec2.CfnSpotFleet.InstanceRequirementsRequestProperty(\n        accelerator_count=ec2.CfnSpotFleet.AcceleratorCountRequestProperty(\n            max=123,\n            min=123\n        ),\n        accelerator_manufacturers=["acceleratorManufacturers"],\n        accelerator_names=["acceleratorNames"],\n        accelerator_total_memory_mi_b=ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty(\n            max=123,\n            min=123\n        ),\n        accelerator_types=["acceleratorTypes"],\n        allowed_instance_types=["allowedInstanceTypes"],\n        bare_metal="bareMetal",\n        baseline_ebs_bandwidth_mbps=ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty(\n            max=123,\n            min=123\n        ),\n        burstable_performance="burstablePerformance",\n        cpu_manufacturers=["cpuManufacturers"],\n        excluded_instance_types=["excludedInstanceTypes"],\n        instance_generations=["instanceGenerations"],\n        local_storage="localStorage",\n        local_storage_types=["localStorageTypes"],\n        memory_gi_bPer_vCpu=ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty(\n            max=123,\n            min=123\n        ),\n        memory_mi_b=ec2.CfnSpotFleet.MemoryMiBRequestProperty(\n            max=123,\n            min=123\n        ),\n        network_bandwidth_gbps=ec2.CfnSpotFleet.NetworkBandwidthGbpsRequestProperty(\n            max=123,\n            min=123\n        ),\n        network_interface_count=ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty(\n            max=123,\n            min=123\n        ),\n        on_demand_max_price_percentage_over_lowest_price=123,\n        require_hibernate_support=False,\n        spot_max_price_percentage_over_lowest_price=123,\n        total_local_storage_gb=ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty(\n            max=123,\n            min=123\n        ),\n        v_cpu_count=ec2.CfnSpotFleet.VCpuCountRangeRequestProperty(\n            max=123,\n            min=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['accelerator_count', 'accelerator_manufacturers', 'accelerator_names', 'accelerator_total_memory_mib', 'accelerator_types', 'allowed_instance_types', 'bare_metal', 'baseline_ebs_bandwidth_mbps', 'burstable_performance', 'cpu_manufacturers', 'excluded_instance_types', 'instance_generations', 'local_storage', 'local_storage_types', 'memory_gib_per_v_cpu', 'memory_mib', 'network_bandwidth_gbps', 'network_interface_count', 'on_demand_max_price_percentage_over_lowest_price', 'require_hibernate_support', 'spot_max_price_percentage_over_lowest_price', 'total_local_storage_gb', 'v_cpu_count']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.InstanceRequirementsRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.LaunchTemplateConfigProperty
class CfnSpotFleet_LaunchTemplateConfigPropertyDef(BaseStruct):
    launch_template_specification: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_FleetLaunchTemplateSpecificationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The launch template to use. Make sure that the launch template does not contain the ``NetworkInterfaceId`` parameter because you can't specify a network interface ID in a Spot Fleet.\n")
    overrides: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_LaunchTemplateOverridesPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Any parameters that you specify override the same parameters in the launch template.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    launch_template_config_property = ec2.CfnSpotFleet.LaunchTemplateConfigProperty(\n        launch_template_specification=ec2.CfnSpotFleet.FleetLaunchTemplateSpecificationProperty(\n            version="version",\n\n            # the properties below are optional\n            launch_template_id="launchTemplateId",\n            launch_template_name="launchTemplateName"\n        ),\n        overrides=[ec2.CfnSpotFleet.LaunchTemplateOverridesProperty(\n            availability_zone="availabilityZone",\n            instance_requirements=ec2.CfnSpotFleet.InstanceRequirementsRequestProperty(\n                accelerator_count=ec2.CfnSpotFleet.AcceleratorCountRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                accelerator_manufacturers=["acceleratorManufacturers"],\n                accelerator_names=["acceleratorNames"],\n                accelerator_total_memory_mi_b=ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                accelerator_types=["acceleratorTypes"],\n                allowed_instance_types=["allowedInstanceTypes"],\n                bare_metal="bareMetal",\n                baseline_ebs_bandwidth_mbps=ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                burstable_performance="burstablePerformance",\n                cpu_manufacturers=["cpuManufacturers"],\n                excluded_instance_types=["excludedInstanceTypes"],\n                instance_generations=["instanceGenerations"],\n                local_storage="localStorage",\n                local_storage_types=["localStorageTypes"],\n                memory_gi_bPer_vCpu=ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                memory_mi_b=ec2.CfnSpotFleet.MemoryMiBRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                network_bandwidth_gbps=ec2.CfnSpotFleet.NetworkBandwidthGbpsRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                network_interface_count=ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                on_demand_max_price_percentage_over_lowest_price=123,\n                require_hibernate_support=False,\n                spot_max_price_percentage_over_lowest_price=123,\n                total_local_storage_gb=ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                v_cpu_count=ec2.CfnSpotFleet.VCpuCountRangeRequestProperty(\n                    max=123,\n                    min=123\n                )\n            ),\n            instance_type="instanceType",\n            priority=123,\n            spot_price="spotPrice",\n            subnet_id="subnetId",\n            weighted_capacity=123\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['launch_template_specification', 'overrides']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.LaunchTemplateConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.LaunchTemplateOverridesProperty
class CfnSpotFleet_LaunchTemplateOverridesPropertyDef(BaseStruct):
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone in which to launch the instances.\n')
    instance_requirements: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_InstanceRequirementsRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The instance requirements. When you specify instance requirements, Amazon EC2 will identify instance types with the provided requirements, and then use your On-Demand and Spot allocation strategies to launch instances from these instance types, in the same way as when you specify a list of instance types. .. epigraph:: If you specify ``InstanceRequirements`` , you can't specify ``InstanceType`` .\n")
    instance_type: typing.Optional[str] = pydantic.Field(None, description='The instance type.\n')
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='The priority for the launch template override. The highest priority is launched first. If ``OnDemandAllocationStrategy`` is set to ``prioritized`` , Spot Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. If the Spot ``AllocationStrategy`` is set to ``capacityOptimizedPrioritized`` , Spot Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first. Valid values are whole numbers starting at ``0`` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.\n')
    spot_price: typing.Optional[str] = pydantic.Field(None, description='The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price. .. epigraph:: If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.\n')
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the subnet in which to launch the instances.\n')
    weighted_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='The number of units provided by the specified instance type.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    launch_template_overrides_property = ec2.CfnSpotFleet.LaunchTemplateOverridesProperty(\n        availability_zone="availabilityZone",\n        instance_requirements=ec2.CfnSpotFleet.InstanceRequirementsRequestProperty(\n            accelerator_count=ec2.CfnSpotFleet.AcceleratorCountRequestProperty(\n                max=123,\n                min=123\n            ),\n            accelerator_manufacturers=["acceleratorManufacturers"],\n            accelerator_names=["acceleratorNames"],\n            accelerator_total_memory_mi_b=ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty(\n                max=123,\n                min=123\n            ),\n            accelerator_types=["acceleratorTypes"],\n            allowed_instance_types=["allowedInstanceTypes"],\n            bare_metal="bareMetal",\n            baseline_ebs_bandwidth_mbps=ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty(\n                max=123,\n                min=123\n            ),\n            burstable_performance="burstablePerformance",\n            cpu_manufacturers=["cpuManufacturers"],\n            excluded_instance_types=["excludedInstanceTypes"],\n            instance_generations=["instanceGenerations"],\n            local_storage="localStorage",\n            local_storage_types=["localStorageTypes"],\n            memory_gi_bPer_vCpu=ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty(\n                max=123,\n                min=123\n            ),\n            memory_mi_b=ec2.CfnSpotFleet.MemoryMiBRequestProperty(\n                max=123,\n                min=123\n            ),\n            network_bandwidth_gbps=ec2.CfnSpotFleet.NetworkBandwidthGbpsRequestProperty(\n                max=123,\n                min=123\n            ),\n            network_interface_count=ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty(\n                max=123,\n                min=123\n            ),\n            on_demand_max_price_percentage_over_lowest_price=123,\n            require_hibernate_support=False,\n            spot_max_price_percentage_over_lowest_price=123,\n            total_local_storage_gb=ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty(\n                max=123,\n                min=123\n            ),\n            v_cpu_count=ec2.CfnSpotFleet.VCpuCountRangeRequestProperty(\n                max=123,\n                min=123\n            )\n        ),\n        instance_type="instanceType",\n        priority=123,\n        spot_price="spotPrice",\n        subnet_id="subnetId",\n        weighted_capacity=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'instance_requirements', 'instance_type', 'priority', 'spot_price', 'subnet_id', 'weighted_capacity']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.LaunchTemplateOverridesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.LoadBalancersConfigProperty
class CfnSpotFleet_LoadBalancersConfigPropertyDef(BaseStruct):
    classic_load_balancers_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_ClassicLoadBalancersConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The Classic Load Balancers.\n')
    target_groups_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_TargetGroupsConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The target groups.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-loadbalancersconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    load_balancers_config_property = ec2.CfnSpotFleet.LoadBalancersConfigProperty(\n        classic_load_balancers_config=ec2.CfnSpotFleet.ClassicLoadBalancersConfigProperty(\n            classic_load_balancers=[ec2.CfnSpotFleet.ClassicLoadBalancerProperty(\n                name="name"\n            )]\n        ),\n        target_groups_config=ec2.CfnSpotFleet.TargetGroupsConfigProperty(\n            target_groups=[ec2.CfnSpotFleet.TargetGroupProperty(\n                arn="arn"\n            )]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['classic_load_balancers_config', 'target_groups_config']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.LoadBalancersConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty
class CfnSpotFleet_MemoryGiBPerVCpuRequestPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorygibpervcpurequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    memory_gi_bPer_vCpu_request_property = ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.MemoryMiBRequestProperty
class CfnSpotFleet_MemoryMiBRequestPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum amount of memory, in MiB. To specify no minimum limit, specify ``0`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorymibrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    memory_mi_bRequest_property = ec2.CfnSpotFleet.MemoryMiBRequestProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.MemoryMiBRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.NetworkBandwidthGbpsRequestProperty
class CfnSpotFleet_NetworkBandwidthGbpsRequestPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkbandwidthgbpsrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    network_bandwidth_gbps_request_property = ec2.CfnSpotFleet.NetworkBandwidthGbpsRequestProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.NetworkBandwidthGbpsRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty
class CfnSpotFleet_NetworkInterfaceCountRequestPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of network interfaces. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of network interfaces. To specify no minimum limit, omit this parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkinterfacecountrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    network_interface_count_request_property = ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.PrivateIpAddressSpecificationProperty
class CfnSpotFleet_PrivateIpAddressSpecificationPropertyDef(BaseStruct):
    private_ip_address: str = pydantic.Field(..., description='The private IPv4 address.\n')
    primary: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-privateipaddressspecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    private_ip_address_specification_property = ec2.CfnSpotFleet.PrivateIpAddressSpecificationProperty(\n        private_ip_address="privateIpAddress",\n\n        # the properties below are optional\n        primary=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['private_ip_address', 'primary']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.PrivateIpAddressSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.SpotCapacityRebalanceProperty
class CfnSpotFleet_SpotCapacityRebalancePropertyDef(BaseStruct):
    replacement_strategy: typing.Optional[str] = pydantic.Field(None, description='The replacement strategy to use. Only available for fleets of type ``maintain`` . ``launch`` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. Spot Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running. ``launch-before-terminate`` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in ``TerminationDelay`` ), terminates the instances that received a rebalance notification.\n')
    termination_delay: typing.Union[int, float, None] = pydantic.Field(None, description='The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance. Required when ``ReplacementStrategy`` is set to ``launch-before-terminate`` . Not valid when ``ReplacementStrategy`` is set to ``launch`` . Valid values: Minimum value of ``120`` seconds. Maximum value of ``7200`` seconds.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotcapacityrebalance.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    spot_capacity_rebalance_property = ec2.CfnSpotFleet.SpotCapacityRebalanceProperty(\n        replacement_strategy="replacementStrategy",\n        termination_delay=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['replacement_strategy', 'termination_delay']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.SpotCapacityRebalanceProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.SpotFleetLaunchSpecificationProperty
class CfnSpotFleet_SpotFleetLaunchSpecificationPropertyDef(BaseStruct):
    image_id: str = pydantic.Field(..., description='The ID of the AMI.\n')
    block_device_mappings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_BlockDeviceMappingPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="One or more block devices that are mapped to the Spot Instances. You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.\n")
    ebs_optimized: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance. Default: ``false``\n")
    iam_instance_profile: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_IamInstanceProfileSpecificationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The IAM instance profile.\n')
    instance_requirements: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_InstanceRequirementsRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes. .. epigraph:: If you specify ``InstanceRequirements`` , you can't specify ``InstanceType`` .\n")
    instance_type: typing.Optional[str] = pydantic.Field(None, description='The instance type.\n')
    kernel_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the kernel.\n')
    key_name: typing.Optional[str] = pydantic.Field(None, description='The name of the key pair.\n')
    monitoring: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_SpotFleetMonitoringPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Enable or disable monitoring for the instances.\n')
    network_interfaces: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_InstanceNetworkInterfaceSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface. .. epigraph:: ``SpotFleetLaunchSpecification`` currently does not support Elastic Fabric Adapter (EFA). To specify an EFA, you must use `LaunchTemplateConfig <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_LaunchTemplateConfig.html>`_ .\n')
    placement: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_SpotPlacementPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The placement information.\n')
    ramdisk_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the RAM disk. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, refer to the AWS Resource Center and search for the kernel ID.\n')
    security_groups: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_GroupIdentifierPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The security groups.\n')
    spot_price: typing.Optional[str] = pydantic.Field(None, description='The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price. .. epigraph:: If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.\n')
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='The IDs of the subnets in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-1234abcdeexample1, subnet-0987cdef6example2".\n')
    tag_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_SpotFleetTagSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The tags to apply during creation.\n')
    user_data: typing.Optional[str] = pydantic.Field(None, description='The base64-encoded user data that instances use when starting up. User data is limited to 16 KB.\n')
    weighted_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O. If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    spot_fleet_launch_specification_property = ec2.CfnSpotFleet.SpotFleetLaunchSpecificationProperty(\n        image_id="imageId",\n\n        # the properties below are optional\n        block_device_mappings=[ec2.CfnSpotFleet.BlockDeviceMappingProperty(\n            device_name="deviceName",\n\n            # the properties below are optional\n            ebs=ec2.CfnSpotFleet.EbsBlockDeviceProperty(\n                delete_on_termination=False,\n                encrypted=False,\n                iops=123,\n                snapshot_id="snapshotId",\n                volume_size=123,\n                volume_type="volumeType"\n            ),\n            no_device="noDevice",\n            virtual_name="virtualName"\n        )],\n        ebs_optimized=False,\n        iam_instance_profile=ec2.CfnSpotFleet.IamInstanceProfileSpecificationProperty(\n            arn="arn"\n        ),\n        instance_requirements=ec2.CfnSpotFleet.InstanceRequirementsRequestProperty(\n            accelerator_count=ec2.CfnSpotFleet.AcceleratorCountRequestProperty(\n                max=123,\n                min=123\n            ),\n            accelerator_manufacturers=["acceleratorManufacturers"],\n            accelerator_names=["acceleratorNames"],\n            accelerator_total_memory_mi_b=ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty(\n                max=123,\n                min=123\n            ),\n            accelerator_types=["acceleratorTypes"],\n            allowed_instance_types=["allowedInstanceTypes"],\n            bare_metal="bareMetal",\n            baseline_ebs_bandwidth_mbps=ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty(\n                max=123,\n                min=123\n            ),\n            burstable_performance="burstablePerformance",\n            cpu_manufacturers=["cpuManufacturers"],\n            excluded_instance_types=["excludedInstanceTypes"],\n            instance_generations=["instanceGenerations"],\n            local_storage="localStorage",\n            local_storage_types=["localStorageTypes"],\n            memory_gi_bPer_vCpu=ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty(\n                max=123,\n                min=123\n            ),\n            memory_mi_b=ec2.CfnSpotFleet.MemoryMiBRequestProperty(\n                max=123,\n                min=123\n            ),\n            network_bandwidth_gbps=ec2.CfnSpotFleet.NetworkBandwidthGbpsRequestProperty(\n                max=123,\n                min=123\n            ),\n            network_interface_count=ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty(\n                max=123,\n                min=123\n            ),\n            on_demand_max_price_percentage_over_lowest_price=123,\n            require_hibernate_support=False,\n            spot_max_price_percentage_over_lowest_price=123,\n            total_local_storage_gb=ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty(\n                max=123,\n                min=123\n            ),\n            v_cpu_count=ec2.CfnSpotFleet.VCpuCountRangeRequestProperty(\n                max=123,\n                min=123\n            )\n        ),\n        instance_type="instanceType",\n        kernel_id="kernelId",\n        key_name="keyName",\n        monitoring=ec2.CfnSpotFleet.SpotFleetMonitoringProperty(\n            enabled=False\n        ),\n        network_interfaces=[ec2.CfnSpotFleet.InstanceNetworkInterfaceSpecificationProperty(\n            associate_public_ip_address=False,\n            delete_on_termination=False,\n            description="description",\n            device_index=123,\n            groups=["groups"],\n            ipv6_address_count=123,\n            ipv6_addresses=[ec2.CfnSpotFleet.InstanceIpv6AddressProperty(\n                ipv6_address="ipv6Address"\n            )],\n            network_interface_id="networkInterfaceId",\n            private_ip_addresses=[ec2.CfnSpotFleet.PrivateIpAddressSpecificationProperty(\n                private_ip_address="privateIpAddress",\n\n                # the properties below are optional\n                primary=False\n            )],\n            secondary_private_ip_address_count=123,\n            subnet_id="subnetId"\n        )],\n        placement=ec2.CfnSpotFleet.SpotPlacementProperty(\n            availability_zone="availabilityZone",\n            group_name="groupName",\n            tenancy="tenancy"\n        ),\n        ramdisk_id="ramdiskId",\n        security_groups=[ec2.CfnSpotFleet.GroupIdentifierProperty(\n            group_id="groupId"\n        )],\n        spot_price="spotPrice",\n        subnet_id="subnetId",\n        tag_specifications=[ec2.CfnSpotFleet.SpotFleetTagSpecificationProperty(\n            resource_type="resourceType",\n            tags=[CfnTag(\n                key="key",\n                value="value"\n            )]\n        )],\n        user_data="userData",\n        weighted_capacity=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['image_id', 'block_device_mappings', 'ebs_optimized', 'iam_instance_profile', 'instance_requirements', 'instance_type', 'kernel_id', 'key_name', 'monitoring', 'network_interfaces', 'placement', 'ramdisk_id', 'security_groups', 'spot_price', 'subnet_id', 'tag_specifications', 'user_data', 'weighted_capacity']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.SpotFleetLaunchSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.SpotFleetMonitoringProperty
class CfnSpotFleet_SpotFleetMonitoringPropertyDef(BaseStruct):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Enables monitoring for the instance. Default: ``false``\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetmonitoring.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    spot_fleet_monitoring_property = ec2.CfnSpotFleet.SpotFleetMonitoringProperty(\n        enabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.SpotFleetMonitoringProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.SpotFleetRequestConfigDataProperty
class CfnSpotFleet_SpotFleetRequestConfigDataPropertyDef(BaseStruct):
    iam_fleet_role: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants the Spot Fleet the permission to request, launch, terminate, and tag instances on your behalf. For more information, see `Spot Fleet Prerequisites <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-requests.html#spot-fleet-prerequisites>`_ in the *Amazon EC2 User Guide for Linux Instances* . Spot Fleet can terminate Spot Instances on your behalf when you cancel its Spot Fleet request or when the Spot Fleet request expires, if you set ``TerminateInstancesWithExpiration`` .\n')
    target_capacity: typing.Union[int, float] = pydantic.Field(..., description='The number of units to request for the Spot Fleet. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is ``maintain`` , you can specify a target capacity of 0 and add capacity later.\n')
    allocation_strategy: typing.Optional[str] = pydantic.Field(None, description="The strategy that determines how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the Spot Fleet launch configuration. For more information, see `Allocation strategies for Spot Instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-allocation-strategy.html>`_ in the *Amazon EC2 User Guide* . - **priceCapacityOptimized (recommended)** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. Spot Fleet then requests Spot Instances from the lowest priced of these pools. - **capacityOptimized** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. To give certain instance types a higher chance of launching first, use ``capacityOptimizedPrioritized`` . Set a priority for each instance type by using the ``Priority`` parameter for ``LaunchTemplateOverrides`` . You can assign the same priority to different ``LaunchTemplateOverrides`` . EC2 implements the priorities on a best-effort basis, but optimizes for capacity first. ``capacityOptimizedPrioritized`` is supported only if your Spot Fleet uses a launch template. Note that if the ``OnDemandAllocationStrategy`` is set to ``prioritized`` , the same priority is applied when fulfilling On-Demand capacity. - **diversified** - Spot Fleet requests instances from all of the Spot Instance pools that you specify. - **lowestPrice** - Spot Fleet requests instances from the lowest priced Spot Instance pool that has available capacity. If the lowest priced pool doesn't have available capacity, the Spot Instances come from the next lowest priced pool that has available capacity. If a pool runs out of capacity before fulfilling your desired capacity, Spot Fleet will continue to fulfill your request by drawing from the next lowest priced pool. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. Because this strategy only considers instance price and not capacity availability, it might lead to high interruption rates. Default: ``lowestPrice``\n")
    context: typing.Optional[str] = pydantic.Field(None, description='Reserved.\n')
    excess_capacity_termination_policy: typing.Optional[str] = pydantic.Field(None, description='Indicates whether running Spot Instances should be terminated if you decrease the target capacity of the Spot Fleet request below the current size of the Spot Fleet. Supported only for fleets of type ``maintain`` .\n')
    instance_interruption_behavior: typing.Optional[str] = pydantic.Field(None, description='The behavior when a Spot Instance is interrupted. The default is ``terminate`` .\n')
    instance_pools_to_use_count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot *AllocationStrategy* is set to ``lowest-price`` . Spot Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify. Note that Spot Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, Spot Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.\n')
    launch_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_SpotFleetLaunchSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="The launch specifications for the Spot Fleet request. If you specify ``LaunchSpecifications`` , you can't specify ``LaunchTemplateConfigs`` .\n")
    launch_template_configs: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_LaunchTemplateConfigPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="The launch template and overrides. If you specify ``LaunchTemplateConfigs`` , you can't specify ``LaunchSpecifications`` .\n")
    load_balancers_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_LoadBalancersConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='One or more Classic Load Balancers and target groups to attach to the Spot Fleet request. Spot Fleet registers the running Spot Instances with the specified Classic Load Balancers and target groups. With Network Load Balancers, Spot Fleet cannot register instances that have the following instance types: C1, CC1, CC2, CG1, CG2, CR1, CS1, G1, G2, HI1, HS1, M1, M2, M3, and T1.\n')
    on_demand_allocation_strategy: typing.Optional[str] = pydantic.Field(None, description='The order of the launch template overrides to use in fulfilling On-Demand capacity. If you specify ``lowestPrice`` , Spot Fleet uses price to determine the order, launching the lowest price first. If you specify ``prioritized`` , Spot Fleet uses the priority that you assign to each Spot Fleet launch template override, launching the highest priority first. If you do not specify a value, Spot Fleet defaults to ``lowestPrice`` .\n')
    on_demand_max_total_price: typing.Optional[str] = pydantic.Field(None, description="The maximum amount per hour for On-Demand Instances that you're willing to pay. You can use the ``onDemandMaxTotalPrice`` parameter, the ``spotMaxTotalPrice`` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasn’t met the target capacity.\n")
    on_demand_target_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='The number of On-Demand units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is ``maintain`` , you can specify a target capacity of 0 and add capacity later.\n')
    replace_unhealthy_instances: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether Spot Fleet should replace unhealthy instances.\n')
    spot_maintenance_strategies: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_SpotMaintenanceStrategiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.\n')
    spot_max_total_price: typing.Optional[str] = pydantic.Field(None, description="The maximum amount per hour for Spot Instances that you're willing to pay. You can use the ``spotdMaxTotalPrice`` parameter, the ``onDemandMaxTotalPrice`` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasn’t met the target capacity.\n")
    spot_price: typing.Optional[str] = pydantic.Field(None, description='The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price. .. epigraph:: If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.\n')
    tag_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_SpotFleetTagSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The key-value pair for tagging the Spot Fleet request on creation. The value for ``ResourceType`` must be ``spot-fleet-request`` , otherwise the Spot Fleet request fails. To tag instances at launch, specify the tags in the `launch template <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template>`_ (valid only if you use ``LaunchTemplateConfigs`` ) or in the ``[SpotFleetTagSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetTagSpecification.html)`` (valid only if you use ``LaunchSpecifications`` ). For information about tagging after launch, see `Tagging Your Resources <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources>`_ .\n')
    target_capacity_unit_type: typing.Optional[str] = pydantic.Field(None, description='The unit for the target capacity. ``TargetCapacityUnitType`` can only be specified when ``InstanceRequirements`` is specified. Default: ``units`` (translates to number of instances)\n')
    terminate_instances_with_expiration: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether running Spot Instances are terminated when the Spot Fleet request expires.\n')
    type: typing.Optional[str] = pydantic.Field(None, description='The type of request. Indicates whether the Spot Fleet only requests the target capacity or also attempts to maintain it. When this value is ``request`` , the Spot Fleet only places the required requests. It does not attempt to replenish Spot Instances if capacity is diminished, nor does it submit requests in alternative Spot pools if capacity is not available. When this value is ``maintain`` , the Spot Fleet maintains the target capacity. The Spot Fleet places the required requests to meet capacity and automatically replenishes any interrupted instances. Default: ``maintain`` . ``instant`` is listed but is not used by Spot Fleet.\n')
    valid_from: typing.Optional[str] = pydantic.Field(None, description='The start date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). By default, Amazon EC2 starts fulfilling the request immediately.\n')
    valid_until: typing.Optional[str] = pydantic.Field(None, description='The end date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). After the end date and time, no new Spot Instance requests are placed or able to fulfill the request. If no value is specified, the Spot Fleet request remains until you cancel it.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    spot_fleet_request_config_data_property = ec2.CfnSpotFleet.SpotFleetRequestConfigDataProperty(\n        iam_fleet_role="iamFleetRole",\n        target_capacity=123,\n\n        # the properties below are optional\n        allocation_strategy="allocationStrategy",\n        context="context",\n        excess_capacity_termination_policy="excessCapacityTerminationPolicy",\n        instance_interruption_behavior="instanceInterruptionBehavior",\n        instance_pools_to_use_count=123,\n        launch_specifications=[ec2.CfnSpotFleet.SpotFleetLaunchSpecificationProperty(\n            image_id="imageId",\n\n            # the properties below are optional\n            block_device_mappings=[ec2.CfnSpotFleet.BlockDeviceMappingProperty(\n                device_name="deviceName",\n\n                # the properties below are optional\n                ebs=ec2.CfnSpotFleet.EbsBlockDeviceProperty(\n                    delete_on_termination=False,\n                    encrypted=False,\n                    iops=123,\n                    snapshot_id="snapshotId",\n                    volume_size=123,\n                    volume_type="volumeType"\n                ),\n                no_device="noDevice",\n                virtual_name="virtualName"\n            )],\n            ebs_optimized=False,\n            iam_instance_profile=ec2.CfnSpotFleet.IamInstanceProfileSpecificationProperty(\n                arn="arn"\n            ),\n            instance_requirements=ec2.CfnSpotFleet.InstanceRequirementsRequestProperty(\n                accelerator_count=ec2.CfnSpotFleet.AcceleratorCountRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                accelerator_manufacturers=["acceleratorManufacturers"],\n                accelerator_names=["acceleratorNames"],\n                accelerator_total_memory_mi_b=ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                accelerator_types=["acceleratorTypes"],\n                allowed_instance_types=["allowedInstanceTypes"],\n                bare_metal="bareMetal",\n                baseline_ebs_bandwidth_mbps=ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                burstable_performance="burstablePerformance",\n                cpu_manufacturers=["cpuManufacturers"],\n                excluded_instance_types=["excludedInstanceTypes"],\n                instance_generations=["instanceGenerations"],\n                local_storage="localStorage",\n                local_storage_types=["localStorageTypes"],\n                memory_gi_bPer_vCpu=ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                memory_mi_b=ec2.CfnSpotFleet.MemoryMiBRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                network_bandwidth_gbps=ec2.CfnSpotFleet.NetworkBandwidthGbpsRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                network_interface_count=ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                on_demand_max_price_percentage_over_lowest_price=123,\n                require_hibernate_support=False,\n                spot_max_price_percentage_over_lowest_price=123,\n                total_local_storage_gb=ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty(\n                    max=123,\n                    min=123\n                ),\n                v_cpu_count=ec2.CfnSpotFleet.VCpuCountRangeRequestProperty(\n                    max=123,\n                    min=123\n                )\n            ),\n            instance_type="instanceType",\n            kernel_id="kernelId",\n            key_name="keyName",\n            monitoring=ec2.CfnSpotFleet.SpotFleetMonitoringProperty(\n                enabled=False\n            ),\n            network_interfaces=[ec2.CfnSpotFleet.InstanceNetworkInterfaceSpecificationProperty(\n                associate_public_ip_address=False,\n                delete_on_termination=False,\n                description="description",\n                device_index=123,\n                groups=["groups"],\n                ipv6_address_count=123,\n                ipv6_addresses=[ec2.CfnSpotFleet.InstanceIpv6AddressProperty(\n                    ipv6_address="ipv6Address"\n                )],\n                network_interface_id="networkInterfaceId",\n                private_ip_addresses=[ec2.CfnSpotFleet.PrivateIpAddressSpecificationProperty(\n                    private_ip_address="privateIpAddress",\n\n                    # the properties below are optional\n                    primary=False\n                )],\n                secondary_private_ip_address_count=123,\n                subnet_id="subnetId"\n            )],\n            placement=ec2.CfnSpotFleet.SpotPlacementProperty(\n                availability_zone="availabilityZone",\n                group_name="groupName",\n                tenancy="tenancy"\n            ),\n            ramdisk_id="ramdiskId",\n            security_groups=[ec2.CfnSpotFleet.GroupIdentifierProperty(\n                group_id="groupId"\n            )],\n            spot_price="spotPrice",\n            subnet_id="subnetId",\n            tag_specifications=[ec2.CfnSpotFleet.SpotFleetTagSpecificationProperty(\n                resource_type="resourceType",\n                tags=[CfnTag(\n                    key="key",\n                    value="value"\n                )]\n            )],\n            user_data="userData",\n            weighted_capacity=123\n        )],\n        launch_template_configs=[ec2.CfnSpotFleet.LaunchTemplateConfigProperty(\n            launch_template_specification=ec2.CfnSpotFleet.FleetLaunchTemplateSpecificationProperty(\n                version="version",\n\n                # the properties below are optional\n                launch_template_id="launchTemplateId",\n                launch_template_name="launchTemplateName"\n            ),\n            overrides=[ec2.CfnSpotFleet.LaunchTemplateOverridesProperty(\n                availability_zone="availabilityZone",\n                instance_requirements=ec2.CfnSpotFleet.InstanceRequirementsRequestProperty(\n                    accelerator_count=ec2.CfnSpotFleet.AcceleratorCountRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    accelerator_manufacturers=["acceleratorManufacturers"],\n                    accelerator_names=["acceleratorNames"],\n                    accelerator_total_memory_mi_b=ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    accelerator_types=["acceleratorTypes"],\n                    allowed_instance_types=["allowedInstanceTypes"],\n                    bare_metal="bareMetal",\n                    baseline_ebs_bandwidth_mbps=ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    burstable_performance="burstablePerformance",\n                    cpu_manufacturers=["cpuManufacturers"],\n                    excluded_instance_types=["excludedInstanceTypes"],\n                    instance_generations=["instanceGenerations"],\n                    local_storage="localStorage",\n                    local_storage_types=["localStorageTypes"],\n                    memory_gi_bPer_vCpu=ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    memory_mi_b=ec2.CfnSpotFleet.MemoryMiBRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    network_bandwidth_gbps=ec2.CfnSpotFleet.NetworkBandwidthGbpsRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    network_interface_count=ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    on_demand_max_price_percentage_over_lowest_price=123,\n                    require_hibernate_support=False,\n                    spot_max_price_percentage_over_lowest_price=123,\n                    total_local_storage_gb=ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    v_cpu_count=ec2.CfnSpotFleet.VCpuCountRangeRequestProperty(\n                        max=123,\n                        min=123\n                    )\n                ),\n                instance_type="instanceType",\n                priority=123,\n                spot_price="spotPrice",\n                subnet_id="subnetId",\n                weighted_capacity=123\n            )]\n        )],\n        load_balancers_config=ec2.CfnSpotFleet.LoadBalancersConfigProperty(\n            classic_load_balancers_config=ec2.CfnSpotFleet.ClassicLoadBalancersConfigProperty(\n                classic_load_balancers=[ec2.CfnSpotFleet.ClassicLoadBalancerProperty(\n                    name="name"\n                )]\n            ),\n            target_groups_config=ec2.CfnSpotFleet.TargetGroupsConfigProperty(\n                target_groups=[ec2.CfnSpotFleet.TargetGroupProperty(\n                    arn="arn"\n                )]\n            )\n        ),\n        on_demand_allocation_strategy="onDemandAllocationStrategy",\n        on_demand_max_total_price="onDemandMaxTotalPrice",\n        on_demand_target_capacity=123,\n        replace_unhealthy_instances=False,\n        spot_maintenance_strategies=ec2.CfnSpotFleet.SpotMaintenanceStrategiesProperty(\n            capacity_rebalance=ec2.CfnSpotFleet.SpotCapacityRebalanceProperty(\n                replacement_strategy="replacementStrategy",\n                termination_delay=123\n            )\n        ),\n        spot_max_total_price="spotMaxTotalPrice",\n        spot_price="spotPrice",\n        tag_specifications=[ec2.CfnSpotFleet.SpotFleetTagSpecificationProperty(\n            resource_type="resourceType",\n            tags=[CfnTag(\n                key="key",\n                value="value"\n            )]\n        )],\n        target_capacity_unit_type="targetCapacityUnitType",\n        terminate_instances_with_expiration=False,\n        type="type",\n        valid_from="validFrom",\n        valid_until="validUntil"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['iam_fleet_role', 'target_capacity', 'allocation_strategy', 'context', 'excess_capacity_termination_policy', 'instance_interruption_behavior', 'instance_pools_to_use_count', 'launch_specifications', 'launch_template_configs', 'load_balancers_config', 'on_demand_allocation_strategy', 'on_demand_max_total_price', 'on_demand_target_capacity', 'replace_unhealthy_instances', 'spot_maintenance_strategies', 'spot_max_total_price', 'spot_price', 'tag_specifications', 'target_capacity_unit_type', 'terminate_instances_with_expiration', 'type', 'valid_from', 'valid_until']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.SpotFleetRequestConfigDataProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.SpotFleetTagSpecificationProperty
class CfnSpotFleet_SpotFleetTagSpecificationPropertyDef(BaseStruct):
    resource_type: typing.Optional[str] = pydantic.Field(None, description='The type of resource. Currently, the only resource type that is supported is ``instance`` . To tag the Spot Fleet request on creation, use the ``TagSpecifications`` parameter in ``[SpotFleetRequestConfigData](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetRequestConfigData.html)`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleettagspecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    spot_fleet_tag_specification_property = ec2.CfnSpotFleet.SpotFleetTagSpecificationProperty(\n        resource_type="resourceType",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resource_type', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.SpotFleetTagSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.SpotMaintenanceStrategiesProperty
class CfnSpotFleet_SpotMaintenanceStrategiesPropertyDef(BaseStruct):
    capacity_rebalance: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_SpotCapacityRebalancePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The Spot Instance replacement strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted. For more information, see `Capacity rebalancing <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-capacity-rebalance.html>`_ in the *Amazon EC2 User Guide for Linux Instances* .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotmaintenancestrategies.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    spot_maintenance_strategies_property = ec2.CfnSpotFleet.SpotMaintenanceStrategiesProperty(\n        capacity_rebalance=ec2.CfnSpotFleet.SpotCapacityRebalanceProperty(\n            replacement_strategy="replacementStrategy",\n            termination_delay=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['capacity_rebalance']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.SpotMaintenanceStrategiesProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.SpotPlacementProperty
class CfnSpotFleet_SpotPlacementPropertyDef(BaseStruct):
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone. To specify multiple Availability Zones, separate them using commas; for example, "us-west-2a, us-west-2b".\n')
    group_name: typing.Optional[str] = pydantic.Field(None, description='The name of the placement group.\n')
    tenancy: typing.Optional[str] = pydantic.Field(None, description='The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of ``dedicated`` runs on single-tenant hardware. The ``host`` tenancy is not supported for Spot Instances.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    spot_placement_property = ec2.CfnSpotFleet.SpotPlacementProperty(\n        availability_zone="availabilityZone",\n        group_name="groupName",\n        tenancy="tenancy"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'group_name', 'tenancy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.SpotPlacementProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.TargetGroupProperty
class CfnSpotFleet_TargetGroupPropertyDef(BaseStruct):
    arn: str = pydantic.Field(..., description='The Amazon Resource Name (ARN) of the target group.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroup.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    target_group_property = ec2.CfnSpotFleet.TargetGroupProperty(\n        arn="arn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.TargetGroupProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.TargetGroupsConfigProperty
class CfnSpotFleet_TargetGroupsConfigPropertyDef(BaseStruct):
    target_groups: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_TargetGroupPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='One or more target groups.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroupsconfig.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    target_groups_config_property = ec2.CfnSpotFleet.TargetGroupsConfigProperty(\n        target_groups=[ec2.CfnSpotFleet.TargetGroupProperty(\n            arn="arn"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['target_groups']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.TargetGroupsConfigProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty
class CfnSpotFleet_TotalLocalStorageGBRequestPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-totallocalstoragegbrequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    total_local_storage_gBRequest_property = ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet.VCpuCountRangeRequestProperty
class CfnSpotFleet_VCpuCountRangeRequestPropertyDef(BaseStruct):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of vCPUs. To specify no maximum limit, omit this parameter.\n')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum number of vCPUs. To specify no minimum limit, specify ``0`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-vcpucountrangerequest.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    v_cpu_count_range_request_property = ec2.CfnSpotFleet.VCpuCountRangeRequestProperty(\n        max=123,\n        min=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max', 'min']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet.VCpuCountRangeRequestProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSubnet.PrivateDnsNameOptionsOnLaunchProperty
class CfnSubnet_PrivateDnsNameOptionsOnLaunchPropertyDef(BaseStruct):
    enable_resource_name_dns_aaaa_record: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to respond to DNS queries for instance hostname with DNS AAAA records.\n')
    enable_resource_name_dns_a_record: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to respond to DNS queries for instance hostnames with DNS A records.\n')
    hostname_type: typing.Optional[str] = pydantic.Field(None, description='The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-privatednsnameoptionsonlaunch.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    private_dns_name_options_on_launch_property = ec2.CfnSubnet.PrivateDnsNameOptionsOnLaunchProperty(\n        enable_resource_name_dns_aaaa_record=False,\n        enable_resource_name_dns_aRecord=False,\n        hostname_type="hostnameType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enable_resource_name_dns_aaaa_record', 'enable_resource_name_dns_a_record', 'hostname_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSubnet.PrivateDnsNameOptionsOnLaunchProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty
class CfnTrafficMirrorFilterRule_TrafficMirrorPortRangePropertyDef(BaseStruct):
    from_port: typing.Union[int, float] = pydantic.Field(..., description='The start of the Traffic Mirror port range. This applies to the TCP and UDP protocols.\n')
    to_port: typing.Union[int, float] = pydantic.Field(..., description='The end of the Traffic Mirror port range. This applies to the TCP and UDP protocols.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    traffic_mirror_port_range_property = ec2.CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty(\n        from_port=123,\n        to_port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['from_port', 'to_port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayAttachment.OptionsProperty
class CfnTransitGatewayAttachment_OptionsPropertyDef(BaseStruct):
    appliance_mode_support: typing.Optional[str] = pydantic.Field(None, description='Indicates whether appliance mode support is enabled.\n')
    dns_support: typing.Optional[str] = pydantic.Field(None, description='Indicates whether DNS support is enabled.\n')
    ipv6_support: typing.Optional[str] = pydantic.Field(None, description='Indicates whether IPv6 support is disabled.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-options.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    options_property = ec2.CfnTransitGatewayAttachment.OptionsProperty(\n        appliance_mode_support="applianceModeSupport",\n        dns_support="dnsSupport",\n        ipv6_support="ipv6Support"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['appliance_mode_support', 'dns_support', 'ipv6_support']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayAttachment.OptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty
class CfnTransitGatewayConnect_TransitGatewayConnectOptionsPropertyDef(BaseStruct):
    protocol: typing.Optional[str] = pydantic.Field(None, description='The tunnel protocol.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnect-transitgatewayconnectoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    transit_gateway_connect_options_property = ec2.CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty(\n        protocol="protocol"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['protocol']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayMulticastDomain.OptionsProperty
class CfnTransitGatewayMulticastDomain_OptionsPropertyDef(BaseStruct):
    auto_accept_shared_associations: typing.Optional[str] = pydantic.Field(None, description='Indicates whether to automatically accept cross-account subnet associations that are associated with the transit gateway multicast domain.\n')
    igmpv2_support: typing.Optional[str] = pydantic.Field(None, description='Specify whether to enable Internet Group Management Protocol (IGMP) version 2 for the transit gateway multicast domain.\n')
    static_sources_support: typing.Optional[str] = pydantic.Field(None, description='Specify whether to enable support for statically configuring multicast group sources for a domain.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaymulticastdomain-options.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    options_property = ec2.CfnTransitGatewayMulticastDomain.OptionsProperty(\n        auto_accept_shared_associations="autoAcceptSharedAssociations",\n        igmpv2_support="igmpv2Support",\n        static_sources_support="staticSourcesSupport"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['auto_accept_shared_associations', 'igmpv2_support', 'static_sources_support']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayMulticastDomain.OptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayPeeringAttachment.PeeringAttachmentStatusProperty
class CfnTransitGatewayPeeringAttachment_PeeringAttachmentStatusPropertyDef(BaseStruct):
    code: typing.Optional[str] = pydantic.Field(None, description='The status code.\n')
    message: typing.Optional[str] = pydantic.Field(None, description='The status message, if applicable.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-peeringattachmentstatus.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    peering_attachment_status_property = ec2.CfnTransitGatewayPeeringAttachment.PeeringAttachmentStatusProperty(\n        code="code",\n        message="message"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['code', 'message']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayPeeringAttachment.PeeringAttachmentStatusProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayVpcAttachment.OptionsProperty
class CfnTransitGatewayVpcAttachment_OptionsPropertyDef(BaseStruct):
    appliance_mode_support: typing.Optional[str] = pydantic.Field(None, description='Indicates whether appliance mode support is enabled.\n')
    dns_support: typing.Optional[str] = pydantic.Field(None, description='Indicates whether DNS support is enabled.\n')
    ipv6_support: typing.Optional[str] = pydantic.Field(None, description='Indicates whether IPv6 support is disabled.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    options_property = ec2.CfnTransitGatewayVpcAttachment.OptionsProperty(\n        appliance_mode_support="applianceModeSupport",\n        dns_support="dnsSupport",\n        ipv6_support="ipv6Support"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['appliance_mode_support', 'dns_support', 'ipv6_support']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayVpcAttachment.OptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVerifiedAccessEndpoint.LoadBalancerOptionsProperty
class CfnVerifiedAccessEndpoint_LoadBalancerOptionsPropertyDef(BaseStruct):
    load_balancer_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the load balancer.\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The IP port number.\n')
    protocol: typing.Optional[str] = pydantic.Field(None, description='The IP protocol.\n')
    subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of the subnets.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    load_balancer_options_property = ec2.CfnVerifiedAccessEndpoint.LoadBalancerOptionsProperty(\n        load_balancer_arn="loadBalancerArn",\n        port=123,\n        protocol="protocol",\n        subnet_ids=["subnetIds"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['load_balancer_arn', 'port', 'protocol', 'subnet_ids']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVerifiedAccessEndpoint.LoadBalancerOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVerifiedAccessEndpoint.NetworkInterfaceOptionsProperty
class CfnVerifiedAccessEndpoint_NetworkInterfaceOptionsPropertyDef(BaseStruct):
    network_interface_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the network interface.\n')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='The IP port number.\n')
    protocol: typing.Optional[str] = pydantic.Field(None, description='The IP protocol.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    network_interface_options_property = ec2.CfnVerifiedAccessEndpoint.NetworkInterfaceOptionsProperty(\n        network_interface_id="networkInterfaceId",\n        port=123,\n        protocol="protocol"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['network_interface_id', 'port', 'protocol']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVerifiedAccessEndpoint.NetworkInterfaceOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVerifiedAccessInstance.CloudWatchLogsProperty
class CfnVerifiedAccessInstance_CloudWatchLogsPropertyDef(BaseStruct):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether logging is enabled.\n')
    log_group: typing.Optional[str] = pydantic.Field(None, description='The ID of the CloudWatch Logs log group.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-cloudwatchlogs.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cloud_watch_logs_property = ec2.CfnVerifiedAccessInstance.CloudWatchLogsProperty(\n        enabled=False,\n        log_group="logGroup"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'log_group']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVerifiedAccessInstance.CloudWatchLogsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVerifiedAccessInstance.KinesisDataFirehoseProperty
class CfnVerifiedAccessInstance_KinesisDataFirehosePropertyDef(BaseStruct):
    delivery_stream: typing.Optional[str] = pydantic.Field(None, description='The ID of the delivery stream.\n')
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether logging is enabled.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-kinesisdatafirehose.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    kinesis_data_firehose_property = ec2.CfnVerifiedAccessInstance.KinesisDataFirehoseProperty(\n        delivery_stream="deliveryStream",\n        enabled=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['delivery_stream', 'enabled']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVerifiedAccessInstance.KinesisDataFirehoseProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVerifiedAccessInstance.S3Property
class CfnVerifiedAccessInstance_S3PropertyDef(BaseStruct):
    bucket_name: typing.Optional[str] = pydantic.Field(None, description='The bucket name.\n')
    bucket_owner: typing.Optional[str] = pydantic.Field(None, description='The AWS account number that owns the bucket.\n')
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether logging is enabled.\n')
    prefix: typing.Optional[str] = pydantic.Field(None, description='The bucket prefix.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-s3.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    s3_property = ec2.CfnVerifiedAccessInstance.S3Property(\n        bucket_name="bucketName",\n        bucket_owner="bucketOwner",\n        enabled=False,\n        prefix="prefix"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket_name', 'bucket_owner', 'enabled', 'prefix']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVerifiedAccessInstance.S3Property'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVerifiedAccessInstance.VerifiedAccessLogsProperty
class CfnVerifiedAccessInstance_VerifiedAccessLogsPropertyDef(BaseStruct):
    cloud_watch_logs: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnVerifiedAccessInstance_CloudWatchLogsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='CloudWatch Logs logging destination.\n')
    kinesis_data_firehose: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnVerifiedAccessInstance_KinesisDataFirehosePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Kinesis logging destination.\n')
    s3: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnVerifiedAccessInstance_S3PropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Amazon S3 logging options.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    verified_access_logs_property = ec2.CfnVerifiedAccessInstance.VerifiedAccessLogsProperty(\n        cloud_watch_logs=ec2.CfnVerifiedAccessInstance.CloudWatchLogsProperty(\n            enabled=False,\n            log_group="logGroup"\n        ),\n        kinesis_data_firehose=ec2.CfnVerifiedAccessInstance.KinesisDataFirehoseProperty(\n            delivery_stream="deliveryStream",\n            enabled=False\n        ),\n        s3=ec2.CfnVerifiedAccessInstance.S3Property(\n            bucket_name="bucketName",\n            bucket_owner="bucketOwner",\n            enabled=False,\n            prefix="prefix"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cloud_watch_logs', 'kinesis_data_firehose', 's3']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVerifiedAccessInstance.VerifiedAccessLogsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVerifiedAccessInstance.VerifiedAccessTrustProviderProperty
class CfnVerifiedAccessInstance_VerifiedAccessTrustProviderPropertyDef(BaseStruct):
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the AWS Verified Access trust provider.\n')
    device_trust_provider_type: typing.Optional[str] = pydantic.Field(None, description='The type of device-based trust provider.\n')
    trust_provider_type: typing.Optional[str] = pydantic.Field(None, description='The type of Verified Access trust provider.\n')
    user_trust_provider_type: typing.Optional[str] = pydantic.Field(None, description='The type of user-based trust provider.\n')
    verified_access_trust_provider_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the AWS Verified Access trust provider.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    verified_access_trust_provider_property = ec2.CfnVerifiedAccessInstance.VerifiedAccessTrustProviderProperty(\n        description="description",\n        device_trust_provider_type="deviceTrustProviderType",\n        trust_provider_type="trustProviderType",\n        user_trust_provider_type="userTrustProviderType",\n        verified_access_trust_provider_id="verifiedAccessTrustProviderId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'device_trust_provider_type', 'trust_provider_type', 'user_trust_provider_type', 'verified_access_trust_provider_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVerifiedAccessInstance.VerifiedAccessTrustProviderProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVerifiedAccessTrustProvider.DeviceOptionsProperty
class CfnVerifiedAccessTrustProvider_DeviceOptionsPropertyDef(BaseStruct):
    tenant_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the tenant application with the device-identity provider.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-deviceoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    device_options_property = ec2.CfnVerifiedAccessTrustProvider.DeviceOptionsProperty(\n        tenant_id="tenantId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['tenant_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVerifiedAccessTrustProvider.DeviceOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVerifiedAccessTrustProvider.OidcOptionsProperty
class CfnVerifiedAccessTrustProvider_OidcOptionsPropertyDef(BaseStruct):
    authorization_endpoint: typing.Optional[str] = pydantic.Field(None, description='The OIDC authorization endpoint.\n')
    client_id: typing.Optional[str] = pydantic.Field(None, description='The client identifier.\n')
    client_secret: typing.Optional[str] = pydantic.Field(None, description='The client secret.\n')
    issuer: typing.Optional[str] = pydantic.Field(None, description='The OIDC issuer.\n')
    token_endpoint: typing.Optional[str] = pydantic.Field(None, description='The OIDC token endpoint.\n')
    user_info_endpoint: typing.Optional[str] = pydantic.Field(None, description='The OIDC user info endpoint.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    oidc_options_property = ec2.CfnVerifiedAccessTrustProvider.OidcOptionsProperty(\n        authorization_endpoint="authorizationEndpoint",\n        client_id="clientId",\n        client_secret="clientSecret",\n        issuer="issuer",\n        scope="scope",\n        token_endpoint="tokenEndpoint",\n        user_info_endpoint="userInfoEndpoint"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['authorization_endpoint', 'client_id', 'client_secret', 'issuer', 'token_endpoint', 'user_info_endpoint']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVerifiedAccessTrustProvider.OidcOptionsProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVPNConnection.VpnTunnelOptionsSpecificationProperty
class CfnVPNConnection_VpnTunnelOptionsSpecificationPropertyDef(BaseStruct):
    pre_shared_key: typing.Optional[str] = pydantic.Field(None, description='The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway. Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores (_). Must be between 8 and 64 characters in length and cannot start with zero (0).\n')
    tunnel_inside_cidr: typing.Optional[str] = pydantic.Field(None, description='The range of inside IP addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway. Constraints: A size /30 CIDR block from the ``169.254.0.0/16`` range. The following CIDR blocks are reserved and cannot be used: - ``169.254.0.0/30`` - ``169.254.1.0/30`` - ``169.254.2.0/30`` - ``169.254.3.0/30`` - ``169.254.4.0/30`` - ``169.254.5.0/30`` - ``169.254.169.252/30``\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    vpn_tunnel_options_specification_property = ec2.CfnVPNConnection.VpnTunnelOptionsSpecificationProperty(\n        pre_shared_key="preSharedKey",\n        tunnel_inside_cidr="tunnelInsideCidr"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['pre_shared_key', 'tunnel_inside_cidr']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPNConnection.VpnTunnelOptionsSpecificationProperty'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.ClientVpnAuthorizationRuleOptions
class ClientVpnAuthorizationRuleOptionsDef(BaseStruct):
    cidr: str = pydantic.Field(..., description='The IPv4 address range, in CIDR notation, of the network for which access is being authorized.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A brief description of the authorization rule. Default: - no description\n')
    group_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group. Default: - authorize all groups\n\n:exampleMetadata: fixture=client-vpn infused\n\nExample::\n\n    endpoint = vpc.add_client_vpn_endpoint("Endpoint",\n        cidr="10.100.0.0/16",\n        server_certificate_arn="arn:aws:acm:us-east-1:123456789012:certificate/server-certificate-id",\n        user_based_authentication=ec2.ClientVpnUserBasedAuthentication.federated(saml_provider),\n        authorize_all_users_to_vpc_cidr=False\n    )\n\n    endpoint.add_authorization_rule("Rule",\n        cidr="10.0.10.0/32",\n        group_id="group-id"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cidr', 'description', 'group_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.ClientVpnAuthorizationRuleOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.ClientVpnAuthorizationRuleProps
class ClientVpnAuthorizationRulePropsDef(BaseStruct):
    cidr: str = pydantic.Field(..., description='The IPv4 address range, in CIDR notation, of the network for which access is being authorized.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A brief description of the authorization rule. Default: - no description\n')
    group_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group. Default: - authorize all groups\n')
    client_vpn_endpoint: typing.Optional[typing.Union[models.aws_ec2.ClientVpnEndpointDef]] = pydantic.Field(None, description='The client VPN endpoint to which to add the rule. Default: clientVpnEndpoint is required\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # client_vpn_endpoint: ec2.ClientVpnEndpoint\n\n    client_vpn_authorization_rule_props = ec2.ClientVpnAuthorizationRuleProps(\n        cidr="cidr",\n\n        # the properties below are optional\n        client_vpn_endpoint=client_vpn_endpoint,\n        description="description",\n        group_id="groupId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cidr', 'description', 'group_id', 'client_vpn_endpoint']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.ClientVpnAuthorizationRuleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.ClientVpnEndpointAttributes
class ClientVpnEndpointAttributesDef(BaseStruct):
    endpoint_id: str = pydantic.Field(..., description='The endpoint ID.\n')
    security_groups: typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(..., description='The security groups associated with the endpoint.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # security_group: ec2.SecurityGroup\n\n    client_vpn_endpoint_attributes = ec2.ClientVpnEndpointAttributes(\n        endpoint_id="endpointId",\n        security_groups=[security_group]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['endpoint_id', 'security_groups']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.ClientVpnEndpointAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.ClientVpnEndpointOptions
class ClientVpnEndpointOptionsDef(BaseStruct):
    cidr: str = pydantic.Field(..., description='The IPv4 address range, in CIDR notation, from which to assign client IP addresses. The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. Changing the address range will replace the Client VPN endpoint. The CIDR block should be /22 or greater.\n')
    server_certificate_arn: str = pydantic.Field(..., description='The ARN of the server certificate.\n')
    authorize_all_users_to_vpc_cidr: typing.Optional[bool] = pydantic.Field(None, description='Whether to authorize all users to the VPC CIDR. This automatically creates an authorization rule. Set this to ``false`` and use ``addAuthorizationRule()`` to create your own rules instead. Default: true\n')
    client_certificate_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the client certificate for mutual authentication. The certificate must be signed by a certificate authority (CA) and it must be provisioned in AWS Certificate Manager (ACM). Default: - use user-based authentication\n')
    client_connection_handler: typing.Optional[typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef]] = pydantic.Field(None, description='The AWS Lambda function used for connection authorization. The name of the Lambda function must begin with the ``AWSClientVPN-`` prefix Default: - no connection handler\n')
    client_login_banner: typing.Optional[str] = pydantic.Field(None, description='Customizable text that will be displayed in a banner on AWS provided clients when a VPN session is established. UTF-8 encoded characters only. Maximum of 1400 characters. Default: - no banner is presented to the client\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A brief description of the Client VPN endpoint. Default: - no description\n')
    dns_servers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Information about the DNS servers to be used for DNS resolution. A Client VPN endpoint can have up to two DNS servers. Default: - use the DNS address configured on the device\n')
    logging: typing.Optional[bool] = pydantic.Field(None, description='Whether to enable connections logging. Default: true\n')
    log_group: typing.Optional[typing.Union[models.aws_logs.LogGroupDef]] = pydantic.Field(None, description='A CloudWatch Logs log group for connection logging. Default: - a new group is created\n')
    log_stream: typing.Optional[typing.Union[models.aws_logs.LogStreamDef]] = pydantic.Field(None, description='A CloudWatch Logs log stream for connection logging. Default: - a new stream is created\n')
    port: typing.Optional[aws_cdk.aws_ec2.VpnPort] = pydantic.Field(None, description='The port number to assign to the Client VPN endpoint for TCP and UDP traffic. Default: VpnPort.HTTPS\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='The security groups to apply to the target network. Default: - a new security group is created\n')
    self_service_portal: typing.Optional[bool] = pydantic.Field(None, description='Specify whether to enable the self-service portal for the Client VPN endpoint. Default: true\n')
    session_timeout: typing.Optional[aws_cdk.aws_ec2.ClientVpnSessionTimeout] = pydantic.Field(None, description='The maximum VPN session duration time. Default: ClientVpnSessionTimeout.TWENTY_FOUR_HOURS\n')
    split_tunnel: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint. Default: false\n')
    transport_protocol: typing.Optional[aws_cdk.aws_ec2.TransportProtocol] = pydantic.Field(None, description='The transport protocol to be used by the VPN session. Default: TransportProtocol.UDP\n')
    user_based_authentication: typing.Optional[models.aws_ec2.ClientVpnUserBasedAuthenticationDef] = pydantic.Field(None, description='The type of user-based authentication to use. Default: - use mutual authentication\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Subnets to associate to the client VPN endpoint. Default: - the VPC default strategy\n\n:exampleMetadata: fixture=client-vpn infused\n\nExample::\n\n    endpoint = vpc.add_client_vpn_endpoint("Endpoint",\n        cidr="10.100.0.0/16",\n        server_certificate_arn="arn:aws:acm:us-east-1:123456789012:certificate/server-certificate-id",\n        user_based_authentication=ec2.ClientVpnUserBasedAuthentication.federated(saml_provider),\n        authorize_all_users_to_vpc_cidr=False\n    )\n\n    endpoint.add_authorization_rule("Rule",\n        cidr="10.0.10.0/32",\n        group_id="group-id"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cidr', 'server_certificate_arn', 'authorize_all_users_to_vpc_cidr', 'client_certificate_arn', 'client_connection_handler', 'client_login_banner', 'description', 'dns_servers', 'logging', 'log_group', 'log_stream', 'port', 'security_groups', 'self_service_portal', 'session_timeout', 'split_tunnel', 'transport_protocol', 'user_based_authentication', 'vpc_subnets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.ClientVpnEndpointOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.ClientVpnEndpointProps
class ClientVpnEndpointPropsDef(BaseStruct):
    cidr: str = pydantic.Field(..., description='The IPv4 address range, in CIDR notation, from which to assign client IP addresses. The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. Changing the address range will replace the Client VPN endpoint. The CIDR block should be /22 or greater.\n')
    server_certificate_arn: str = pydantic.Field(..., description='The ARN of the server certificate.\n')
    authorize_all_users_to_vpc_cidr: typing.Optional[bool] = pydantic.Field(None, description='Whether to authorize all users to the VPC CIDR. This automatically creates an authorization rule. Set this to ``false`` and use ``addAuthorizationRule()`` to create your own rules instead. Default: true\n')
    client_certificate_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the client certificate for mutual authentication. The certificate must be signed by a certificate authority (CA) and it must be provisioned in AWS Certificate Manager (ACM). Default: - use user-based authentication\n')
    client_connection_handler: typing.Optional[typing.Union[models.aws_lambda.FunctionBaseDef, models.aws_lambda.QualifiedFunctionBaseDef, models.aws_lambda.AliasDef, models.aws_lambda.DockerImageFunctionDef, models.aws_lambda.FunctionDef, models.aws_lambda.SingletonFunctionDef, models.aws_lambda.VersionDef, models.aws_lambda_nodejs.NodejsFunctionDef, models.triggers.TriggerFunctionDef]] = pydantic.Field(None, description='The AWS Lambda function used for connection authorization. The name of the Lambda function must begin with the ``AWSClientVPN-`` prefix Default: - no connection handler\n')
    client_login_banner: typing.Optional[str] = pydantic.Field(None, description='Customizable text that will be displayed in a banner on AWS provided clients when a VPN session is established. UTF-8 encoded characters only. Maximum of 1400 characters. Default: - no banner is presented to the client\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A brief description of the Client VPN endpoint. Default: - no description\n')
    dns_servers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Information about the DNS servers to be used for DNS resolution. A Client VPN endpoint can have up to two DNS servers. Default: - use the DNS address configured on the device\n')
    logging: typing.Optional[bool] = pydantic.Field(None, description='Whether to enable connections logging. Default: true\n')
    log_group: typing.Optional[typing.Union[models.aws_logs.LogGroupDef]] = pydantic.Field(None, description='A CloudWatch Logs log group for connection logging. Default: - a new group is created\n')
    log_stream: typing.Optional[typing.Union[models.aws_logs.LogStreamDef]] = pydantic.Field(None, description='A CloudWatch Logs log stream for connection logging. Default: - a new stream is created\n')
    port: typing.Optional[aws_cdk.aws_ec2.VpnPort] = pydantic.Field(None, description='The port number to assign to the Client VPN endpoint for TCP and UDP traffic. Default: VpnPort.HTTPS\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='The security groups to apply to the target network. Default: - a new security group is created\n')
    self_service_portal: typing.Optional[bool] = pydantic.Field(None, description='Specify whether to enable the self-service portal for the Client VPN endpoint. Default: true\n')
    session_timeout: typing.Optional[aws_cdk.aws_ec2.ClientVpnSessionTimeout] = pydantic.Field(None, description='The maximum VPN session duration time. Default: ClientVpnSessionTimeout.TWENTY_FOUR_HOURS\n')
    split_tunnel: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint. Default: false\n')
    transport_protocol: typing.Optional[aws_cdk.aws_ec2.TransportProtocol] = pydantic.Field(None, description='The transport protocol to be used by the VPN session. Default: TransportProtocol.UDP\n')
    user_based_authentication: typing.Optional[models.aws_ec2.ClientVpnUserBasedAuthenticationDef] = pydantic.Field(None, description='The type of user-based authentication to use. Default: - use mutual authentication\n')
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Subnets to associate to the client VPN endpoint. Default: - the VPC default strategy\n')
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='The VPC to connect to.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n    from aws_cdk import aws_logs as logs\n\n    # client_vpn_connection_handler: ec2.IClientVpnConnectionHandler\n    # client_vpn_user_based_authentication: ec2.ClientVpnUserBasedAuthentication\n    # log_group: logs.LogGroup\n    # log_stream: logs.LogStream\n    # security_group: ec2.SecurityGroup\n    # subnet: ec2.Subnet\n    # subnet_filter: ec2.SubnetFilter\n    # vpc: ec2.Vpc\n\n    client_vpn_endpoint_props = ec2.ClientVpnEndpointProps(\n        cidr="cidr",\n        server_certificate_arn="serverCertificateArn",\n        vpc=vpc,\n\n        # the properties below are optional\n        authorize_all_users_to_vpc_cidr=False,\n        client_certificate_arn="clientCertificateArn",\n        client_connection_handler=client_vpn_connection_handler,\n        client_login_banner="clientLoginBanner",\n        description="description",\n        dns_servers=["dnsServers"],\n        logging=False,\n        log_group=log_group,\n        log_stream=log_stream,\n        port=ec2.VpnPort.HTTPS,\n        security_groups=[security_group],\n        self_service_portal=False,\n        session_timeout=ec2.ClientVpnSessionTimeout.EIGHT_HOURS,\n        split_tunnel=False,\n        transport_protocol=ec2.TransportProtocol.TCP,\n        user_based_authentication=client_vpn_user_based_authentication,\n        vpc_subnets=ec2.SubnetSelection(\n            availability_zones=["availabilityZones"],\n            one_per_az=False,\n            subnet_filters=[subnet_filter],\n            subnet_group_name="subnetGroupName",\n            subnets=[subnet],\n            subnet_type=ec2.SubnetType.PRIVATE_ISOLATED\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cidr', 'server_certificate_arn', 'authorize_all_users_to_vpc_cidr', 'client_certificate_arn', 'client_connection_handler', 'client_login_banner', 'description', 'dns_servers', 'logging', 'log_group', 'log_stream', 'port', 'security_groups', 'self_service_portal', 'session_timeout', 'split_tunnel', 'transport_protocol', 'user_based_authentication', 'vpc_subnets', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.ClientVpnEndpointProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.ClientVpnRouteOptions
class ClientVpnRouteOptionsDef(BaseStruct):
    cidr: str = pydantic.Field(..., description="The IPv4 address range, in CIDR notation, of the route destination. For example: - To add a route for Internet access, enter 0.0.0.0/0 - To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range - To add a route for an on-premises network, enter the AWS Site-to-Site VPN connection's IPv4 CIDR range - To add a route for the local network, enter the client CIDR range\n")
    target: models.aws_ec2.ClientVpnRouteTargetDef = pydantic.Field(..., description='The target for the route.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A brief description of the authorization rule. Default: - no description\n\n:exampleMetadata: fixture=client-vpn infused\n\nExample::\n\n    endpoint = vpc.add_client_vpn_endpoint("Endpoint",\n        cidr="10.100.0.0/16",\n        server_certificate_arn="arn:aws:acm:us-east-1:123456789012:certificate/server-certificate-id",\n        user_based_authentication=ec2.ClientVpnUserBasedAuthentication.federated(saml_provider)\n    )\n\n    # Client-to-client access\n    endpoint.add_route("Route",\n        cidr="10.100.0.0/16",\n        target=ec2.ClientVpnRouteTarget.local()\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cidr', 'target', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.ClientVpnRouteOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.ClientVpnRouteProps
class ClientVpnRoutePropsDef(BaseStruct):
    cidr: str = pydantic.Field(..., description="The IPv4 address range, in CIDR notation, of the route destination. For example: - To add a route for Internet access, enter 0.0.0.0/0 - To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range - To add a route for an on-premises network, enter the AWS Site-to-Site VPN connection's IPv4 CIDR range - To add a route for the local network, enter the client CIDR range\n")
    target: models.aws_ec2.ClientVpnRouteTargetDef = pydantic.Field(..., description='The target for the route.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A brief description of the authorization rule. Default: - no description\n')
    client_vpn_endpoint: typing.Optional[typing.Union[models.aws_ec2.ClientVpnEndpointDef]] = pydantic.Field(None, description='The client VPN endpoint to which to add the route. Default: clientVpnEndpoint is required\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # client_vpn_endpoint: ec2.ClientVpnEndpoint\n    # client_vpn_route_target: ec2.ClientVpnRouteTarget\n\n    client_vpn_route_props = ec2.ClientVpnRouteProps(\n        cidr="cidr",\n        target=client_vpn_route_target,\n\n        # the properties below are optional\n        client_vpn_endpoint=client_vpn_endpoint,\n        description="description"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cidr', 'target', 'description', 'client_vpn_endpoint']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.ClientVpnRouteProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CommonNetworkAclEntryOptions
class CommonNetworkAclEntryOptionsDef(BaseStruct):
    cidr: models.aws_ec2.AclCidrDef = pydantic.Field(..., description='The CIDR range to allow or deny.\n')
    rule_number: typing.Union[int, float] = pydantic.Field(..., description="Rule number to assign to the entry, such as 100. ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.\n")
    traffic: models.aws_ec2.AclTrafficDef = pydantic.Field(..., description='What kind of traffic this ACL rule applies to.\n')
    direction: typing.Optional[aws_cdk.aws_ec2.TrafficDirection] = pydantic.Field(None, description='Traffic direction, with respect to the subnet, this rule applies to. Default: TrafficDirection.INGRESS\n')
    network_acl_entry_name: typing.Optional[str] = pydantic.Field(None, description="The name of the NetworkAclEntry. It is not recommended to use an explicit group name. Default: If you don't specify a NetworkAclName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.\n")
    rule_action: typing.Optional[aws_cdk.aws_ec2.Action] = pydantic.Field(None, description='Whether to allow or deny traffic that matches the rule; valid values are "allow" or "deny". Any traffic that is not explicitly allowed is automatically denied in a custom ACL, all traffic is automatically allowed in a default ACL. Default: ALLOW\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # acl_cidr: ec2.AclCidr\n    # acl_traffic: ec2.AclTraffic\n\n    common_network_acl_entry_options = ec2.CommonNetworkAclEntryOptions(\n        cidr=acl_cidr,\n        rule_number=123,\n        traffic=acl_traffic,\n\n        # the properties below are optional\n        direction=ec2.TrafficDirection.EGRESS,\n        network_acl_entry_name="networkAclEntryName",\n        rule_action=ec2.Action.ALLOW\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cidr', 'rule_number', 'traffic', 'direction', 'network_acl_entry_name', 'rule_action']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CommonNetworkAclEntryOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CommonNetworkAclEntryOptionsDefConfig] = pydantic.Field(None)


class CommonNetworkAclEntryOptionsDefConfig(pydantic.BaseModel):
    cidr_config: typing.Optional[models.aws_ec2.AclCidrDefConfig] = pydantic.Field(None)
    traffic_config: typing.Optional[models.aws_ec2.AclTrafficDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ec2.ConfigSetProps
class ConfigSetPropsDef(BaseStruct):
    configs: typing.Mapping[str, models.aws_ec2.InitConfigDef] = pydantic.Field(..., description='The sets of configs to pick from.\n')
    config_sets: typing.Mapping[str, typing.Sequence[str]] = pydantic.Field(..., description='The definitions of each config set.\n\n:exampleMetadata: infused\n\nExample::\n\n    # vpc: ec2.Vpc\n    # instance_type: ec2.InstanceType\n    # machine_image: ec2.IMachineImage\n\n\n    ec2.Instance(self, "Instance",\n        vpc=vpc,\n        instance_type=instance_type,\n        machine_image=machine_image,\n\n        # Showing the most complex setup, if you have simpler requirements\n        # you can use `CloudFormationInit.fromElements()`.\n        init=ec2.CloudFormationInit.from_config_sets(\n            config_sets={\n                # Applies the configs below in this order\n                "default": ["yumPreinstall", "config"]\n            },\n            configs={\n                "yum_preinstall": ec2.InitConfig([\n                    # Install an Amazon Linux package using yum\n                    ec2.InitPackage.yum("git")\n                ]),\n                "config": ec2.InitConfig([\n                    # Create a JSON file from tokens (can also create other files)\n                    ec2.InitFile.from_object("/etc/stack.json", {\n                        "stack_id": Stack.of(self).stack_id,\n                        "stack_name": Stack.of(self).stack_name,\n                        "region": Stack.of(self).region\n                    }),\n\n                    # Create a group and user\n                    ec2.InitGroup.from_name("my-group"),\n                    ec2.InitUser.from_name("my-user"),\n\n                    # Install an RPM from the internet\n                    ec2.InitPackage.rpm("http://mirrors.ukfast.co.uk/sites/dl.fedoraproject.org/pub/epel/8/Everything/x86_64/Packages/r/rubygem-git-1.5.0-2.el8.noarch.rpm")\n                ])\n            }\n        ),\n        init_options=ec2.ApplyCloudFormationInitOptions(\n            # Optional, which configsets to activate ([\'default\'] by default)\n            config_sets=["default"],\n\n            # Optional, how long the installation is expected to take (5 minutes by default)\n            timeout=Duration.minutes(30),\n\n            # Optional, whether to include the --url argument when running cfn-init and cfn-signal commands (false by default)\n            include_url=True,\n\n            # Optional, whether to include the --role argument when running cfn-init and cfn-signal commands (false by default)\n            include_role=True\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['configs', 'config_sets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.ConfigSetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.ConfigureNatOptions
class ConfigureNatOptionsDef(BaseStruct):
    nat_subnets: typing.Sequence[models.aws_ec2.PublicSubnetDef] = pydantic.Field(..., description='The public subnets where the NAT providers need to be placed.\n')
    private_subnets: typing.Sequence[models.aws_ec2.PrivateSubnetDef] = pydantic.Field(..., description='The private subnets that need to route through the NAT providers. There may be more private subnets than public subnets with NAT providers.\n')
    vpc: models.aws_ec2.VpcDef = pydantic.Field(..., description="The VPC we're configuring NAT for.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # private_subnet: ec2.PrivateSubnet\n    # public_subnet: ec2.PublicSubnet\n    # vpc: ec2.Vpc\n\n    configure_nat_options = ec2.ConfigureNatOptions(\n        nat_subnets=[public_subnet],\n        private_subnets=[private_subnet],\n        vpc=vpc\n    )\n")
    _init_params: typing.ClassVar[list[str]] = ['nat_subnets', 'private_subnets', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.ConfigureNatOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.ConnectionRule
class ConnectionRuleDef(BaseStruct):
    from_port: typing.Union[int, float] = pydantic.Field(..., description='Start of port range for the TCP and UDP protocols, or an ICMP type number. If you specify icmp for the IpProtocol property, you can specify -1 as a wildcard (i.e., any ICMP type number).')
    description: typing.Optional[str] = pydantic.Field(None, description='Description of this connection. It is applied to both the ingress rule and the egress rule. Default: No description\n')
    protocol: typing.Optional[str] = pydantic.Field(None, description="The IP protocol name (tcp, udp, icmp) or number (see Protocol Numbers). Use -1 to specify all protocols. If you specify -1, or a protocol number other than tcp, udp, icmp, or 58 (ICMPv6), traffic on all ports is allowed, regardless of any ports you specify. For tcp, udp, and icmp, you must specify a port range. For protocol 58 (ICMPv6), you can optionally specify a port range; if you don't, traffic for all types and codes is allowed. Default: tcp\n")
    to_port: typing.Union[int, float, None] = pydantic.Field(None, description='End of port range for the TCP and UDP protocols, or an ICMP code. If you specify icmp for the IpProtocol property, you can specify -1 as a wildcard (i.e., any ICMP code). Default: If toPort is not specified, it will be the same as fromPort.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    connection_rule = ec2.ConnectionRule(\n        from_port=123,\n\n        # the properties below are optional\n        description="description",\n        protocol="protocol",\n        to_port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['from_port', 'description', 'protocol', 'to_port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.ConnectionRule'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.ConnectionsProps
class ConnectionsPropsDef(BaseStruct):
    default_port: typing.Optional[models.aws_ec2.PortDef] = pydantic.Field(None, description='Default port range for initiating connections to and from this object. Default: - No default port\n')
    peer: typing.Optional[models.UnsupportedResource] = pydantic.Field(None, description='Class that represents the rule by which others can connect to this connectable. This object is required, but will be derived from securityGroup if that is passed. Default: Derived from securityGroup if set.\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='What securityGroup(s) this object is managing connections for. Default: No security groups\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # peer: ec2.IPeer\n    # port: ec2.Port\n    # security_group: ec2.SecurityGroup\n\n    connections_props = ec2.ConnectionsProps(\n        default_port=port,\n        peer=peer,\n        security_groups=[security_group]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['default_port', 'peer', 'security_groups']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.ConnectionsProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.DestinationOptions
class DestinationOptionsDef(BaseStruct):
    file_format: typing.Optional[aws_cdk.aws_ec2.FlowLogFileFormat] = pydantic.Field(None, description='The format for the flow log. Default: FlowLogFileFormat.PLAIN_TEXT\n')
    hive_compatible_partitions: typing.Optional[bool] = pydantic.Field(None, description='Use Hive-compatible prefixes for flow logs stored in Amazon S3. Default: false\n')
    per_hour_partition: typing.Optional[bool] = pydantic.Field(None, description='Partition the flow log per hour. Default: false\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    destination_options = ec2.DestinationOptions(\n        file_format=ec2.FlowLogFileFormat.PLAIN_TEXT,\n        hive_compatible_partitions=False,\n        per_hour_partition=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['file_format', 'hive_compatible_partitions', 'per_hour_partition']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.DestinationOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.EbsDeviceOptions
class EbsDeviceOptionsDef(BaseStruct):
    delete_on_termination: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to delete the volume when the instance is terminated. Default: - true for Amazon EC2 Auto Scaling, false otherwise (e.g. EBS)\n')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='The number of I/O operations per second (IOPS) to provision for the volume. Must only be set for ``volumeType``: ``EbsDeviceVolumeType.IO1`` The maximum ratio of IOPS to volume size (in GiB) is 50:1, so for 5,000 provisioned IOPS, you need at least 100 GiB storage on the volume. Default: - none, required for ``EbsDeviceVolumeType.IO1``\n')
    volume_type: typing.Optional[aws_cdk.aws_ec2.EbsDeviceVolumeType] = pydantic.Field(None, description='The EBS volume type. Default: ``EbsDeviceVolumeType.GP2``\n')
    encrypted: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether the EBS volume is encrypted. Encrypted EBS volumes can only be attached to instances that support Amazon EBS encryption Default: false\n')
    kms_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The ARN of the AWS Key Management Service (AWS KMS) CMK used for encryption. You have to ensure that the KMS CMK has the correct permissions to be used by the service launching the ec2 instances. Default: - If encrypted is true, the default aws/ebs KMS key will be used.\n\n:exampleMetadata: fixture=with-vpc infused\n\nExample::\n\n    host = ec2.BastionHostLinux(self, "BastionHost",\n        vpc=vpc,\n        block_devices=[ec2.BlockDevice(\n            device_name="EBSBastionHost",\n            volume=ec2.BlockDeviceVolume.ebs(10,\n                encrypted=True\n            )\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['delete_on_termination', 'iops', 'volume_type', 'encrypted', 'kms_key']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.EbsDeviceOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.EbsDeviceOptionsBase
class EbsDeviceOptionsBaseDef(BaseStruct):
    delete_on_termination: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to delete the volume when the instance is terminated. Default: - true for Amazon EC2 Auto Scaling, false otherwise (e.g. EBS)\n')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='The number of I/O operations per second (IOPS) to provision for the volume. Must only be set for ``volumeType``: ``EbsDeviceVolumeType.IO1`` The maximum ratio of IOPS to volume size (in GiB) is 50:1, so for 5,000 provisioned IOPS, you need at least 100 GiB storage on the volume. Default: - none, required for ``EbsDeviceVolumeType.IO1``\n')
    volume_type: typing.Optional[aws_cdk.aws_ec2.EbsDeviceVolumeType] = pydantic.Field(None, description='The EBS volume type. Default: ``EbsDeviceVolumeType.GP2``\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    ebs_device_options_base = ec2.EbsDeviceOptionsBase(\n        delete_on_termination=False,\n        iops=123,\n        volume_type=ec2.EbsDeviceVolumeType.STANDARD\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['delete_on_termination', 'iops', 'volume_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.EbsDeviceOptionsBase'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.EbsDeviceProps
class EbsDevicePropsDef(BaseStruct):
    delete_on_termination: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to delete the volume when the instance is terminated. Default: - true for Amazon EC2 Auto Scaling, false otherwise (e.g. EBS)\n')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='The number of I/O operations per second (IOPS) to provision for the volume. Must only be set for ``volumeType``: ``EbsDeviceVolumeType.IO1`` The maximum ratio of IOPS to volume size (in GiB) is 50:1, so for 5,000 provisioned IOPS, you need at least 100 GiB storage on the volume. Default: - none, required for ``EbsDeviceVolumeType.IO1``\n')
    volume_type: typing.Optional[aws_cdk.aws_ec2.EbsDeviceVolumeType] = pydantic.Field(None, description='The EBS volume type. Default: ``EbsDeviceVolumeType.GP2``\n')
    volume_size: typing.Union[int, float, None] = pydantic.Field(None, description='The volume size, in Gibibytes (GiB). If you specify volumeSize, it must be equal or greater than the size of the snapshot. Default: - The snapshot size\n')
    encrypted: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether the EBS volume is encrypted. Encrypted EBS volumes can only be attached to instances that support Amazon EBS encryption Default: false\n')
    kms_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The ARN of the AWS Key Management Service (AWS KMS) CMK used for encryption. You have to ensure that the KMS CMK has the correct permissions to be used by the service launching the ec2 instances. Default: - If encrypted is true, the default aws/ebs KMS key will be used.\n')
    snapshot_id: typing.Optional[str] = pydantic.Field(None, description='The snapshot ID of the volume to use. Default: - No snapshot will be used\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n    from aws_cdk import aws_kms as kms\n\n    # key: kms.Key\n\n    ebs_device_props = ec2.EbsDeviceProps(\n        delete_on_termination=False,\n        encrypted=False,\n        iops=123,\n        kms_key=key,\n        snapshot_id="snapshotId",\n        volume_size=123,\n        volume_type=ec2.EbsDeviceVolumeType.STANDARD\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['delete_on_termination', 'iops', 'volume_type', 'volume_size', 'encrypted', 'kms_key', 'snapshot_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.EbsDeviceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.EbsDeviceSnapshotOptions
class EbsDeviceSnapshotOptionsDef(BaseStruct):
    delete_on_termination: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether to delete the volume when the instance is terminated. Default: - true for Amazon EC2 Auto Scaling, false otherwise (e.g. EBS)\n')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='The number of I/O operations per second (IOPS) to provision for the volume. Must only be set for ``volumeType``: ``EbsDeviceVolumeType.IO1`` The maximum ratio of IOPS to volume size (in GiB) is 50:1, so for 5,000 provisioned IOPS, you need at least 100 GiB storage on the volume. Default: - none, required for ``EbsDeviceVolumeType.IO1``\n')
    volume_type: typing.Optional[aws_cdk.aws_ec2.EbsDeviceVolumeType] = pydantic.Field(None, description='The EBS volume type. Default: ``EbsDeviceVolumeType.GP2``\n')
    volume_size: typing.Union[int, float, None] = pydantic.Field(None, description='The volume size, in Gibibytes (GiB). If you specify volumeSize, it must be equal or greater than the size of the snapshot. Default: - The snapshot size\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    ebs_device_snapshot_options = ec2.EbsDeviceSnapshotOptions(\n        delete_on_termination=False,\n        iops=123,\n        volume_size=123,\n        volume_type=ec2.EbsDeviceVolumeType.STANDARD\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['delete_on_termination', 'iops', 'volume_type', 'volume_size']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.EbsDeviceSnapshotOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.EnableVpnGatewayOptions
class EnableVpnGatewayOptionsDef(BaseStruct):
    type: str = pydantic.Field(..., description='Default type ipsec.1.\n')
    amazon_side_asn: typing.Union[int, float, None] = pydantic.Field(None, description='Explicitly specify an Asn or let aws pick an Asn for you. Default: 65000\n')
    vpn_route_propagation: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Provide an array of subnets where the route propagation should be added. Default: noPropagation\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # subnet: ec2.Subnet\n    # subnet_filter: ec2.SubnetFilter\n\n    enable_vpn_gateway_options = ec2.EnableVpnGatewayOptions(\n        type="type",\n\n        # the properties below are optional\n        amazon_side_asn=123,\n        vpn_route_propagation=[ec2.SubnetSelection(\n            availability_zones=["availabilityZones"],\n            one_per_az=False,\n            subnet_filters=[subnet_filter],\n            subnet_group_name="subnetGroupName",\n            subnets=[subnet],\n            subnet_type=ec2.SubnetType.PRIVATE_ISOLATED\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'amazon_side_asn', 'vpn_route_propagation']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.EnableVpnGatewayOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.ExecuteFileOptions
class ExecuteFileOptionsDef(BaseStruct):
    file_path: str = pydantic.Field(..., description='The path to the file.\n')
    arguments: typing.Optional[str] = pydantic.Field(None, description='The arguments to be passed to the file. Default: No arguments are passed to the file.\n\n:exampleMetadata: infused\n\nExample::\n\n    from aws_cdk.aws_s3_assets import Asset\n\n    # instance: ec2.Instance\n\n\n    asset = Asset(self, "Asset",\n        path="./configure.sh"\n    )\n\n    local_path = instance.user_data.add_s3_download_command(\n        bucket=asset.bucket,\n        bucket_key=asset.s3_object_key,\n        region="us-east-1"\n    )\n    instance.user_data.add_execute_file_command(\n        file_path=local_path,\n        arguments="--verbose -y"\n    )\n    asset.grant_read(instance.role)\n')
    _init_params: typing.ClassVar[list[str]] = ['file_path', 'arguments']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.ExecuteFileOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.FlowLogDestinationConfig
class FlowLogDestinationConfigDef(BaseStruct):
    log_destination_type: aws_cdk.aws_ec2.FlowLogDestinationType = pydantic.Field(..., description='The type of destination to publish the flow logs to. Default: - CLOUD_WATCH_LOGS\n')
    destination_options: typing.Union[models.aws_ec2.DestinationOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Options for writing flow logs to a supported destination. Default: - undefined\n')
    iam_role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='The IAM Role that has access to publish to CloudWatch logs. Default: - default IAM role is created for you\n')
    key_prefix: typing.Optional[str] = pydantic.Field(None, description='S3 bucket key prefix to publish the flow logs to. Default: - undefined\n')
    log_group: typing.Optional[typing.Union[models.aws_logs.LogGroupDef]] = pydantic.Field(None, description='The CloudWatch Logs Log Group to publish the flow logs to. Default: - default log group is created for you\n')
    s3_bucket: typing.Optional[typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef]] = pydantic.Field(None, description='S3 bucket to publish the flow logs to. Default: - undefined\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n    from aws_cdk import aws_iam as iam\n    from aws_cdk import aws_logs as logs\n    from aws_cdk import aws_s3 as s3\n\n    # bucket: s3.Bucket\n    # log_group: logs.LogGroup\n    # role: iam.Role\n\n    flow_log_destination_config = ec2.FlowLogDestinationConfig(\n        log_destination_type=ec2.FlowLogDestinationType.CLOUD_WATCH_LOGS,\n\n        # the properties below are optional\n        destination_options=ec2.DestinationOptions(\n            file_format=ec2.FlowLogFileFormat.PLAIN_TEXT,\n            hive_compatible_partitions=False,\n            per_hour_partition=False\n        ),\n        iam_role=role,\n        key_prefix="keyPrefix",\n        log_group=log_group,\n        s3_bucket=bucket\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['log_destination_type', 'destination_options', 'iam_role', 'key_prefix', 'log_group', 's3_bucket']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.FlowLogDestinationConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.FlowLogOptions
class FlowLogOptionsDef(BaseStruct):
    destination: typing.Optional[models.aws_ec2.FlowLogDestinationDef] = pydantic.Field(None, description='Specifies the type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3 Default: FlowLogDestinationType.toCloudWatchLogs()\n')
    log_format: typing.Optional[typing.Sequence[models.aws_ec2.LogFormatDef]] = pydantic.Field(None, description='The fields to include in the flow log record, in the order in which they should appear. If multiple fields are specified, they will be separated by spaces. For full control over the literal log format string, pass a single field constructed with ``LogFormat.custom()``. See https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-log-records Default: - default log format is used.\n')
    max_aggregation_interval: typing.Optional[aws_cdk.aws_ec2.FlowLogMaxAggregationInterval] = pydantic.Field(None, description='The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record. Default: FlowLogMaxAggregationInterval.TEN_MINUTES\n')
    traffic_type: typing.Optional[aws_cdk.aws_ec2.FlowLogTrafficType] = pydantic.Field(None, description='The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic. Default: ALL\n\n:exampleMetadata: infused\n\nExample::\n\n    vpc = ec2.Vpc(self, "Vpc")\n\n    vpc.add_flow_log("FlowLogS3",\n        destination=ec2.FlowLogDestination.to_s3()\n    )\n\n    # Only reject traffic and interval every minute.\n    vpc.add_flow_log("FlowLogCloudWatch",\n        traffic_type=ec2.FlowLogTrafficType.REJECT,\n        max_aggregation_interval=ec2.FlowLogMaxAggregationInterval.ONE_MINUTE\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination', 'log_format', 'max_aggregation_interval', 'traffic_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.FlowLogOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.FlowLogProps
class FlowLogPropsDef(BaseStruct):
    destination: typing.Optional[models.aws_ec2.FlowLogDestinationDef] = pydantic.Field(None, description='Specifies the type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3 Default: FlowLogDestinationType.toCloudWatchLogs()\n')
    log_format: typing.Optional[typing.Sequence[models.aws_ec2.LogFormatDef]] = pydantic.Field(None, description='The fields to include in the flow log record, in the order in which they should appear. If multiple fields are specified, they will be separated by spaces. For full control over the literal log format string, pass a single field constructed with ``LogFormat.custom()``. See https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-log-records Default: - default log format is used.\n')
    max_aggregation_interval: typing.Optional[aws_cdk.aws_ec2.FlowLogMaxAggregationInterval] = pydantic.Field(None, description='The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record. Default: FlowLogMaxAggregationInterval.TEN_MINUTES\n')
    traffic_type: typing.Optional[aws_cdk.aws_ec2.FlowLogTrafficType] = pydantic.Field(None, description='The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic. Default: ALL\n')
    resource_type: models.aws_ec2.FlowLogResourceTypeDef = pydantic.Field(..., description='The type of resource for which to create the flow log.\n')
    flow_log_name: typing.Optional[str] = pydantic.Field(None, description='The name of the FlowLog. It is not recommended to use an explicit name. Default: If you don\'t specify a flowLogName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.\n\n:exampleMetadata: infused\n\nExample::\n\n    # vpc: ec2.Vpc\n\n\n    log_group = logs.LogGroup(self, "MyCustomLogGroup")\n\n    role = iam.Role(self, "MyCustomRole",\n        assumed_by=iam.ServicePrincipal("vpc-flow-logs.amazonaws.com")\n    )\n\n    ec2.FlowLog(self, "FlowLog",\n        resource_type=ec2.FlowLogResourceType.from_vpc(vpc),\n        destination=ec2.FlowLogDestination.to_cloud_watch_logs(log_group, role)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination', 'log_format', 'max_aggregation_interval', 'traffic_type', 'resource_type', 'flow_log_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.FlowLogProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.GatewayConfig
class GatewayConfigDef(BaseStruct):
    az: str = pydantic.Field(..., description='Availability Zone.\n')
    gateway_id: str = pydantic.Field(..., description='Identity of gateway spawned by the provider.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    gateway_config = ec2.GatewayConfig(\n        az="az",\n        gateway_id="gatewayId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['az', 'gateway_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.GatewayConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.GatewayVpcEndpointOptions
class GatewayVpcEndpointOptionsDef(BaseStruct):
    service: typing.Union[models.aws_ec2.GatewayVpcEndpointAwsServiceDef] = pydantic.Field(..., description='The service to use for this gateway VPC endpoint.\n')
    subnets: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Where to add endpoint routing. By default, this endpoint will be routable from all subnets in the VPC. Specify a list of subnet selection objects here to be more specific. Default: - All subnets in the VPC\n\n:exampleMetadata: lit=aws-ec2/test/integ.vpc-endpoint.lit.ts infused\n\nExample::\n\n    # Add gateway endpoints when creating the VPC\n    vpc = ec2.Vpc(self, "MyVpc",\n        gateway_endpoints={\n            "S3": cdk.aws_ec2.GatewayVpcEndpointOptions(\n                service=ec2.GatewayVpcEndpointAwsService.S3\n            )\n        }\n    )\n\n    # Alternatively gateway endpoints can be added on the VPC\n    dynamo_db_endpoint = vpc.add_gateway_endpoint("DynamoDbEndpoint",\n        service=ec2.GatewayVpcEndpointAwsService.DYNAMODB\n    )\n\n    # This allows to customize the endpoint policy\n    dynamo_db_endpoint.add_to_policy(\n        iam.PolicyStatement( # Restrict to listing and describing tables\n            principals=[iam.AnyPrincipal()],\n            actions=["dynamodb:DescribeTable", "dynamodb:ListTables"],\n            resources=["*"]))\n\n    # Add an interface endpoint\n    vpc.add_interface_endpoint("EcrDockerEndpoint",\n        service=ec2.InterfaceVpcEndpointAwsService.ECR_DOCKER\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['service', 'subnets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.GatewayVpcEndpointOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.GatewayVpcEndpointProps
class GatewayVpcEndpointPropsDef(BaseStruct):
    service: typing.Union[models.aws_ec2.GatewayVpcEndpointAwsServiceDef] = pydantic.Field(..., description='The service to use for this gateway VPC endpoint.\n')
    subnets: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Where to add endpoint routing. By default, this endpoint will be routable from all subnets in the VPC. Specify a list of subnet selection objects here to be more specific. Default: - All subnets in the VPC\n')
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='The VPC network in which the gateway endpoint will be used.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # gateway_vpc_endpoint_service: ec2.IGatewayVpcEndpointService\n    # subnet: ec2.Subnet\n    # subnet_filter: ec2.SubnetFilter\n    # vpc: ec2.Vpc\n\n    gateway_vpc_endpoint_props = ec2.GatewayVpcEndpointProps(\n        service=gateway_vpc_endpoint_service,\n        vpc=vpc,\n\n        # the properties below are optional\n        subnets=[ec2.SubnetSelection(\n            availability_zones=["availabilityZones"],\n            one_per_az=False,\n            subnet_filters=[subnet_filter],\n            subnet_group_name="subnetGroupName",\n            subnets=[subnet],\n            subnet_type=ec2.SubnetType.PRIVATE_ISOLATED\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['service', 'subnets', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.GatewayVpcEndpointProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.GenericLinuxImageProps
class GenericLinuxImagePropsDef(BaseStruct):
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Linux machines\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # user_data: ec2.UserData\n\n    generic_linux_image_props = ec2.GenericLinuxImageProps(\n        user_data=user_data\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['user_data']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.GenericLinuxImageProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.GenericWindowsImageProps
class GenericWindowsImagePropsDef(BaseStruct):
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Windows machines\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # user_data: ec2.UserData\n\n    generic_windows_image_props = ec2.GenericWindowsImageProps(\n        user_data=user_data\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['user_data']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.GenericWindowsImageProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.InitCommandOptions
class InitCommandOptionsDef(BaseStruct):
    cwd: typing.Optional[str] = pydantic.Field(None, description='The working directory. Default: - Use default working directory\n')
    env: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description='Sets environment variables for the command. This property overwrites, rather than appends, the existing environment. Default: - Use current environment\n')
    ignore_errors: typing.Optional[bool] = pydantic.Field(None, description='Continue running if this command fails. Default: false\n')
    key: typing.Optional[str] = pydantic.Field(None, description='Identifier key for this command. Commands are executed in lexicographical order of their key names. Default: - Automatically generated based on index\n')
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given service(s) after this command has run. Default: - Do not restart any service\n')
    test_cmd: typing.Optional[str] = pydantic.Field(None, description='Command to determine whether this command should be run. If the test passes (exits with error code of 0), the command is run. Default: - Always run the command\n')
    wait_after_completion: typing.Optional[models.aws_ec2.InitCommandWaitDurationDef] = pydantic.Field(None, description='The duration to wait after a command has finished in case the command causes a reboot. Set this value to ``InitCommandWaitDuration.none()`` if you do not want to wait for every command; ``InitCommandWaitDuration.forever()`` directs cfn-init to exit and resume only after the reboot is complete. For Windows systems only. Default: - 60 seconds\n\n:exampleMetadata: infused\n\nExample::\n\n    handle = ec2.InitServiceRestartHandle()\n    ec2.CloudFormationInit.from_elements(\n        ec2.InitCommand.shell_command("/usr/bin/custom-nginx-install.sh", service_restart_handles=[handle]),\n        ec2.InitService.enable("nginx", service_restart_handle=handle))\n')
    _init_params: typing.ClassVar[list[str]] = ['cwd', 'env', 'ignore_errors', 'key', 'service_restart_handles', 'test_cmd', 'wait_after_completion']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InitCommandOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.InitFileAssetOptions
class InitFileAssetOptionsDef(BaseStruct):
    base64_encoded: typing.Optional[bool] = pydantic.Field(None, description='True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false\n')
    group: typing.Optional[str] = pydantic.Field(None, description="The name of the owning group for this file. Not supported for Windows systems. Default: 'root'\n")
    mode: typing.Optional[str] = pydantic.Field(None, description="A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'\n")
    owner: typing.Optional[str] = pydantic.Field(None, description="The name of the owning user for this file. Not supported for Windows systems. Default: 'root'\n")
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given service after this file has been written. Default: - Do not restart any service\n')
    asset_hash: typing.Optional[str] = pydantic.Field(None, description='Specify a custom hash for this asset. If ``assetHashType`` is set it must be set to ``AssetHashType.CUSTOM``. For consistency, this custom hash will be SHA256 hashed and encoded as hex. The resulting hash will be the asset hash. NOTE: the hash is used in order to identify a specific revision of the asset, and used for optimizing and caching deployment activities related to this asset such as packaging, uploading to Amazon S3, etc. If you chose to customize the hash, you will need to make sure it is updated every time the asset changes, or otherwise it is possible that some deployments will not be invalidated. Default: - based on ``assetHashType``\n')
    asset_hash_type: typing.Optional[aws_cdk.AssetHashType] = pydantic.Field(None, description='Specifies the type of hash to calculate for this asset. If ``assetHash`` is configured, this option must be ``undefined`` or ``AssetHashType.CUSTOM``. Default: - the default is ``AssetHashType.SOURCE``, but if ``assetHash`` is explicitly specified this value defaults to ``AssetHashType.CUSTOM``.\n')
    bundling: typing.Union[models.BundlingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Bundle the asset by executing a command in a Docker container or a custom bundling provider. The asset path will be mounted at ``/asset-input``. The Docker container is responsible for putting content at ``/asset-output``. The content at ``/asset-output`` will be zipped and used as the final asset. Default: - uploaded as-is to S3 if the asset is a regular file or a .zip file, archived into a .zip file and uploaded to S3 otherwise\n')
    exclude: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='File paths matching the patterns will be excluded. See ``ignoreMode`` to set the matching behavior. Has no effect on Assets bundled using the ``bundling`` property. Default: - nothing is excluded\n')
    follow_symlinks: typing.Optional[aws_cdk.SymlinkFollowMode] = pydantic.Field(None, description='A strategy for how to handle symlinks. Default: SymlinkFollowMode.NEVER\n')
    ignore_mode: typing.Optional[aws_cdk.IgnoreMode] = pydantic.Field(None, description='The ignore behavior to use for ``exclude`` patterns. Default: IgnoreMode.GLOB\n')
    deploy_time: typing.Optional[bool] = pydantic.Field(None, description='Whether or not the asset needs to exist beyond deployment time; i.e. are copied over to a different location and not needed afterwards. Setting this property to true has an impact on the lifecycle of the asset, because we will assume that it is safe to delete after the CloudFormation deployment succeeds. For example, Lambda Function assets are copied over to Lambda during deployment. Therefore, it is not necessary to store the asset in S3, so we consider those deployTime assets. Default: false\n')
    readers: typing.Optional[typing.Sequence[typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef]]] = pydantic.Field(None, description='A list of principals that should be able to read this asset from S3. You can use ``asset.grantRead(principal)`` to grant read permissions later. Default: - No principals that can read file asset.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_ec2 as ec2\n    from aws_cdk import aws_iam as iam\n\n    # docker_image: cdk.DockerImage\n    # grantable: iam.IGrantable\n    # init_service_restart_handle: ec2.InitServiceRestartHandle\n    # local_bundling: cdk.ILocalBundling\n\n    init_file_asset_options = ec2.InitFileAssetOptions(\n        asset_hash="assetHash",\n        asset_hash_type=cdk.AssetHashType.SOURCE,\n        base64_encoded=False,\n        bundling=cdk.BundlingOptions(\n            image=docker_image,\n\n            # the properties below are optional\n            bundling_file_access=cdk.BundlingFileAccess.VOLUME_COPY,\n            command=["command"],\n            entrypoint=["entrypoint"],\n            environment={\n                "environment_key": "environment"\n            },\n            local=local_bundling,\n            network="network",\n            output_type=cdk.BundlingOutput.ARCHIVED,\n            security_opt="securityOpt",\n            user="user",\n            volumes=[cdk.DockerVolume(\n                container_path="containerPath",\n                host_path="hostPath",\n\n                # the properties below are optional\n                consistency=cdk.DockerVolumeConsistency.CONSISTENT\n            )],\n            volumes_from=["volumesFrom"],\n            working_directory="workingDirectory"\n        ),\n        deploy_time=False,\n        exclude=["exclude"],\n        follow_symlinks=cdk.SymlinkFollowMode.NEVER,\n        group="group",\n        ignore_mode=cdk.IgnoreMode.GLOB,\n        mode="mode",\n        owner="owner",\n        readers=[grantable],\n        service_restart_handles=[init_service_restart_handle]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['base64_encoded', 'group', 'mode', 'owner', 'service_restart_handles', 'asset_hash', 'asset_hash_type', 'bundling', 'exclude', 'follow_symlinks', 'ignore_mode', 'deploy_time', 'readers']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InitFileAssetOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.InitFileOptions
class InitFileOptionsDef(BaseStruct):
    base64_encoded: typing.Optional[bool] = pydantic.Field(None, description='True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false\n')
    group: typing.Optional[str] = pydantic.Field(None, description="The name of the owning group for this file. Not supported for Windows systems. Default: 'root'\n")
    mode: typing.Optional[str] = pydantic.Field(None, description="A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'\n")
    owner: typing.Optional[str] = pydantic.Field(None, description="The name of the owning user for this file. Not supported for Windows systems. Default: 'root'\n")
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given service after this file has been written. Default: - Do not restart any service\n\n:exampleMetadata: infused\n\nExample::\n\n    # my_bucket: s3.Bucket\n\n\n    handle = ec2.InitServiceRestartHandle()\n\n    ec2.CloudFormationInit.from_elements(\n        ec2.InitFile.from_string("/etc/nginx/nginx.conf", "...", service_restart_handles=[handle]),\n        ec2.InitSource.from_s3_object("/var/www/html", my_bucket, "html.zip", service_restart_handles=[handle]),\n        ec2.InitService.enable("nginx",\n            service_restart_handle=handle\n        ))\n')
    _init_params: typing.ClassVar[list[str]] = ['base64_encoded', 'group', 'mode', 'owner', 'service_restart_handles']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InitFileOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.InitServiceOptions
class InitServiceOptionsDef(BaseStruct):
    enabled: typing.Optional[bool] = pydantic.Field(None, description='Enable or disable this service. Set to true to ensure that the service will be started automatically upon boot. Set to false to ensure that the service will not be started automatically upon boot. Default: - true if used in ``InitService.enable()``, no change to service state if used in ``InitService.fromOptions()``.\n')
    ensure_running: typing.Optional[bool] = pydantic.Field(None, description='Make sure this service is running or not running after cfn-init finishes. Set to true to ensure that the service is running after cfn-init finishes. Set to false to ensure that the service is not running after cfn-init finishes. Default: - same value as ``enabled``.\n')
    service_manager: typing.Optional[aws_cdk.aws_ec2.ServiceManager] = pydantic.Field(None, description='What service manager to use. This needs to match the actual service manager on your Operating System. For example, Amazon Linux 1 uses SysVinit, but Amazon Linux 2 uses Systemd. Default: ServiceManager.SYSVINIT for Linux images, ServiceManager.WINDOWS for Windows images\n')
    service_restart_handle: typing.Optional[models.aws_ec2.InitServiceRestartHandleDef] = pydantic.Field(None, description='Restart service when the actions registered into the restartHandle have been performed. Register actions into the restartHandle by passing it to ``InitFile``, ``InitCommand``, ``InitPackage`` and ``InitSource`` objects. Default: - No files trigger restart\n\n:exampleMetadata: infused\n\nExample::\n\n    # my_bucket: s3.Bucket\n\n\n    handle = ec2.InitServiceRestartHandle()\n\n    ec2.CloudFormationInit.from_elements(\n        ec2.InitFile.from_string("/etc/nginx/nginx.conf", "...", service_restart_handles=[handle]),\n        ec2.InitSource.from_s3_object("/var/www/html", my_bucket, "html.zip", service_restart_handles=[handle]),\n        ec2.InitService.enable("nginx",\n            service_restart_handle=handle\n        ))\n')
    _init_params: typing.ClassVar[list[str]] = ['enabled', 'ensure_running', 'service_manager', 'service_restart_handle']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InitServiceOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.InitSourceAssetOptions
class InitSourceAssetOptionsDef(BaseStruct):
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given services after this archive has been extracted. Default: - Do not restart any service\n')
    asset_hash: typing.Optional[str] = pydantic.Field(None, description='Specify a custom hash for this asset. If ``assetHashType`` is set it must be set to ``AssetHashType.CUSTOM``. For consistency, this custom hash will be SHA256 hashed and encoded as hex. The resulting hash will be the asset hash. NOTE: the hash is used in order to identify a specific revision of the asset, and used for optimizing and caching deployment activities related to this asset such as packaging, uploading to Amazon S3, etc. If you chose to customize the hash, you will need to make sure it is updated every time the asset changes, or otherwise it is possible that some deployments will not be invalidated. Default: - based on ``assetHashType``\n')
    asset_hash_type: typing.Optional[aws_cdk.AssetHashType] = pydantic.Field(None, description='Specifies the type of hash to calculate for this asset. If ``assetHash`` is configured, this option must be ``undefined`` or ``AssetHashType.CUSTOM``. Default: - the default is ``AssetHashType.SOURCE``, but if ``assetHash`` is explicitly specified this value defaults to ``AssetHashType.CUSTOM``.\n')
    bundling: typing.Union[models.BundlingOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Bundle the asset by executing a command in a Docker container or a custom bundling provider. The asset path will be mounted at ``/asset-input``. The Docker container is responsible for putting content at ``/asset-output``. The content at ``/asset-output`` will be zipped and used as the final asset. Default: - uploaded as-is to S3 if the asset is a regular file or a .zip file, archived into a .zip file and uploaded to S3 otherwise\n')
    exclude: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='File paths matching the patterns will be excluded. See ``ignoreMode`` to set the matching behavior. Has no effect on Assets bundled using the ``bundling`` property. Default: - nothing is excluded\n')
    follow_symlinks: typing.Optional[aws_cdk.SymlinkFollowMode] = pydantic.Field(None, description='A strategy for how to handle symlinks. Default: SymlinkFollowMode.NEVER\n')
    ignore_mode: typing.Optional[aws_cdk.IgnoreMode] = pydantic.Field(None, description='The ignore behavior to use for ``exclude`` patterns. Default: IgnoreMode.GLOB\n')
    deploy_time: typing.Optional[bool] = pydantic.Field(None, description='Whether or not the asset needs to exist beyond deployment time; i.e. are copied over to a different location and not needed afterwards. Setting this property to true has an impact on the lifecycle of the asset, because we will assume that it is safe to delete after the CloudFormation deployment succeeds. For example, Lambda Function assets are copied over to Lambda during deployment. Therefore, it is not necessary to store the asset in S3, so we consider those deployTime assets. Default: false\n')
    readers: typing.Optional[typing.Sequence[typing.Union[models.aws_appsync.BackedDataSourceDef, models.aws_appsync.DynamoDbDataSourceDef, models.aws_appsync.ElasticsearchDataSourceDef, models.aws_appsync.EventBridgeDataSourceDef, models.aws_appsync.HttpDataSourceDef, models.aws_appsync.LambdaDataSourceDef, models.aws_appsync.OpenSearchDataSourceDef, models.aws_appsync.RdsDataSourceDef, models.aws_backup.BackupSelectionDef, models.aws_codebuild.UntrustedCodeBoundaryPolicyDef, models.aws_ec2.LaunchTemplateDef, models.aws_iam.ManagedPolicyDef, models.aws_iam.PolicyDef, models.aws_stepfunctions_tasks.EmrContainersStartJobRunDef, models.aws_stepfunctions_tasks.SageMakerCreateModelDef, models.aws_stepfunctions_tasks.SageMakerCreateTrainingJobDef, models.custom_resources.AwsCustomResourceDef]]] = pydantic.Field(None, description='A list of principals that should be able to read this asset from S3. You can use ``asset.grantRead(principal)`` to grant read permissions later. Default: - No principals that can read file asset.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_ec2 as ec2\n    from aws_cdk import aws_iam as iam\n\n    # docker_image: cdk.DockerImage\n    # grantable: iam.IGrantable\n    # init_service_restart_handle: ec2.InitServiceRestartHandle\n    # local_bundling: cdk.ILocalBundling\n\n    init_source_asset_options = ec2.InitSourceAssetOptions(\n        asset_hash="assetHash",\n        asset_hash_type=cdk.AssetHashType.SOURCE,\n        bundling=cdk.BundlingOptions(\n            image=docker_image,\n\n            # the properties below are optional\n            bundling_file_access=cdk.BundlingFileAccess.VOLUME_COPY,\n            command=["command"],\n            entrypoint=["entrypoint"],\n            environment={\n                "environment_key": "environment"\n            },\n            local=local_bundling,\n            network="network",\n            output_type=cdk.BundlingOutput.ARCHIVED,\n            security_opt="securityOpt",\n            user="user",\n            volumes=[cdk.DockerVolume(\n                container_path="containerPath",\n                host_path="hostPath",\n\n                # the properties below are optional\n                consistency=cdk.DockerVolumeConsistency.CONSISTENT\n            )],\n            volumes_from=["volumesFrom"],\n            working_directory="workingDirectory"\n        ),\n        deploy_time=False,\n        exclude=["exclude"],\n        follow_symlinks=cdk.SymlinkFollowMode.NEVER,\n        ignore_mode=cdk.IgnoreMode.GLOB,\n        readers=[grantable],\n        service_restart_handles=[init_service_restart_handle]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['service_restart_handles', 'asset_hash', 'asset_hash_type', 'bundling', 'exclude', 'follow_symlinks', 'ignore_mode', 'deploy_time', 'readers']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InitSourceAssetOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.InitSourceOptions
class InitSourceOptionsDef(BaseStruct):
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given services after this archive has been extracted. Default: - Do not restart any service\n\n:exampleMetadata: infused\n\nExample::\n\n    # my_bucket: s3.Bucket\n\n\n    handle = ec2.InitServiceRestartHandle()\n\n    ec2.CloudFormationInit.from_elements(\n        ec2.InitFile.from_string("/etc/nginx/nginx.conf", "...", service_restart_handles=[handle]),\n        ec2.InitSource.from_s3_object("/var/www/html", my_bucket, "html.zip", service_restart_handles=[handle]),\n        ec2.InitService.enable("nginx",\n            service_restart_handle=handle\n        ))\n')
    _init_params: typing.ClassVar[list[str]] = ['service_restart_handles']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InitSourceOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.InitUserOptions
class InitUserOptionsDef(BaseStruct):
    groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='A list of group names. The user will be added to each group in the list. Default: the user is not associated with any groups.\n')
    home_dir: typing.Optional[str] = pydantic.Field(None, description="The user's home directory. Default: assigned by the OS\n")
    user_id: typing.Union[int, float, None] = pydantic.Field(None, description='A user ID. The creation process fails if the user name exists with a different user ID. If the user ID is already assigned to an existing user the operating system may reject the creation request. Default: assigned by the OS\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    init_user_options = ec2.InitUserOptions(\n        groups=["groups"],\n        home_dir="homeDir",\n        user_id=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['groups', 'home_dir', 'user_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InitUserOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.InstanceProps
class InstancePropsDef(BaseStruct):
    instance_type: models.aws_ec2.InstanceTypeDef = pydantic.Field(..., description='Type of instance to launch.\n')
    machine_image: typing.Union[models.aws_ec2.AmazonLinux2022ImageSsmParameterDef, models.aws_ec2.AmazonLinux2023ImageSsmParameterDef, models.aws_ec2.AmazonLinux2ImageSsmParameterDef, models.aws_ec2.AmazonLinuxImageDef, models.aws_ec2.AmazonLinuxImageSsmParameterBaseDef, models.aws_ec2.GenericLinuxImageDef, models.aws_ec2.GenericSSMParameterImageDef, models.aws_ec2.GenericWindowsImageDef, models.aws_ec2.LookupMachineImageDef, models.aws_ec2.NatInstanceImageDef, models.aws_ec2.WindowsImageDef, models.aws_ecs.BottleRocketImageDef, models.aws_ecs.EcsOptimizedImageDef, models.aws_eks.EksOptimizedImageDef] = pydantic.Field(..., description='AMI to launch.\n')
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='VPC to launch the instance in.\n')
    allow_all_outbound: typing.Optional[bool] = pydantic.Field(None, description='Whether the instance could initiate connections to anywhere by default. This property is only used when you do not provide a security group. Default: true\n')
    associate_public_ip_address: typing.Optional[bool] = pydantic.Field(None, description='Whether to associate a public IP address to the primary network interface attached to this instance. Default: - public IP address is automatically assigned based on default behavior\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='In which AZ to place the instance within the VPC. Default: - Random zone.\n')
    block_devices: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.BlockDeviceDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Specifies how block devices are exposed to the instance. You can specify virtual devices and EBS volumes. Each instance that is launched has an associated root device volume, either an Amazon EBS volume or an instance store volume. You can use block device mappings to specify additional EBS volumes or instance store volumes to attach to an instance when it is launched. Default: - Uses the block device mapping of the AMI\n')
    detailed_monitoring: typing.Optional[bool] = pydantic.Field(None, description='Whether "Detailed Monitoring" is enabled for this instance Keep in mind that Detailed Monitoring results in extra charges. Default: - false\n')
    init: typing.Optional[models.aws_ec2.CloudFormationInitDef] = pydantic.Field(None, description='Apply the given CloudFormation Init configuration to the instance at startup. Default: - no CloudFormation init\n')
    init_options: typing.Union[models.aws_ec2.ApplyCloudFormationInitOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Use the given options for applying CloudFormation Init. Describes the configsets to use and the timeout to wait Default: - default options\n')
    instance_name: typing.Optional[str] = pydantic.Field(None, description='The name of the instance. Default: - CDK generated name\n')
    key_name: typing.Optional[str] = pydantic.Field(None, description='Name of SSH keypair to grant access to instance. Default: - No SSH access will be possible.\n')
    private_ip_address: typing.Optional[str] = pydantic.Field(None, description='Defines a private IP address to associate with an instance. Private IP should be available within the VPC that the instance is build within. Default: - no association\n')
    propagate_tags_to_volume_on_creation: typing.Optional[bool] = pydantic.Field(None, description='Propagate the EC2 instance tags to the EBS volumes. Default: - false\n')
    require_imdsv2: typing.Optional[bool] = pydantic.Field(None, description='Whether IMDSv2 should be required on this instance. Default: - false\n')
    resource_signal_timeout: typing.Optional[models.DurationDef] = pydantic.Field(None, description='The length of time to wait for the resourceSignalCount. The maximum value is 43200 (12 hours). Default: Duration.minutes(5)\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role to associate with the instance profile assigned to this Auto Scaling Group. The role must be assumable by the service principal ``ec2.amazonaws.com``: Default: - A role will automatically be created, it can be accessed via the ``role`` property\n')
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='Security Group to assign to this instance. Default: - create new security group\n')
    source_dest_check: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether to enable an instance launched in a VPC to perform NAT. This controls whether source/destination checking is enabled on the instance. A value of true means that checking is enabled, and false means that checking is disabled. The value must be false for the instance to perform NAT. Default: true\n')
    ssm_session_permissions: typing.Optional[bool] = pydantic.Field(None, description='Add SSM session permissions to the instance role. Setting this to ``true`` adds the necessary permissions to connect to the instance using SSM Session Manager. You can do this from the AWS Console. NOTE: Setting this flag to ``true`` may not be enough by itself. You must also use an AMI that comes with the SSM Agent, or install the SSM Agent yourself. See `Working with SSM Agent <https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-agent.html>`_ in the SSM Developer Guide. Default: false\n')
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description="Specific UserData to use. The UserData may still be mutated after creation. Default: - A UserData object appropriate for the MachineImage's Operating System is created.\n")
    user_data_causes_replacement: typing.Optional[bool] = pydantic.Field(None, description="Changes to the UserData force replacement. Depending the EC2 instance type, changing UserData either restarts the instance or replaces the instance. - Instance store-backed instances are replaced. - EBS-backed instances are restarted. By default, restarting does not execute the new UserData so you will need a different mechanism to ensure the instance is restarted. Setting this to ``true`` will make the instance's Logical ID depend on the UserData, which will cause CloudFormation to replace it if the UserData changes. Default: - true iff ``initOptions`` is specified, false otherwise.\n")
    vpc_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Where to place the instance within the VPC. Default: - Private subnets.\n\n:exampleMetadata: infused\n\nExample::\n\n    # vpc: ec2.IVpc\n\n    lb = elb.LoadBalancer(self, "LB",\n        vpc=vpc\n    )\n\n    # instance to add as the target for load balancer.\n    instance = ec2.Instance(self, "targetInstance",\n        vpc=vpc,\n        instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.MICRO),\n        machine_image=ec2.AmazonLinuxImage(generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX_2)\n    )\n    lb.add_target(elb.InstanceTarget(instance))\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_type', 'machine_image', 'vpc', 'allow_all_outbound', 'associate_public_ip_address', 'availability_zone', 'block_devices', 'detailed_monitoring', 'init', 'init_options', 'instance_name', 'key_name', 'private_ip_address', 'propagate_tags_to_volume_on_creation', 'require_imdsv2', 'resource_signal_timeout', 'role', 'security_group', 'source_dest_check', 'ssm_session_permissions', 'user_data', 'user_data_causes_replacement', 'vpc_subnets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InstanceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[InstancePropsDefConfig] = pydantic.Field(None)


class InstancePropsDefConfig(pydantic.BaseModel):
    machine_image_config: typing.Optional[models._interface_methods.AwsEc2IMachineImageDefConfig] = pydantic.Field(None)
    vpc_config: typing.Optional[models._interface_methods.AwsEc2IVpcDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ec2.InstanceRequireImdsv2AspectProps
class InstanceRequireImdsv2AspectPropsDef(BaseStruct):
    suppress_launch_template_warning: typing.Optional[bool] = pydantic.Field(None, description='Whether warnings that would be raised when an Instance is associated with an existing Launch Template should be suppressed or not. You can set this to ``true`` if ``LaunchTemplateImdsAspect`` is being used alongside this Aspect to suppress false-positive warnings because any Launch Templates associated with Instances will still be covered. Default: - false\n')
    suppress_warnings: typing.Optional[bool] = pydantic.Field(None, description='Whether warning annotations from this Aspect should be suppressed or not. Default: - false\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    instance_require_imdsv2_aspect_props = ec2.InstanceRequireImdsv2AspectProps(\n        suppress_launch_template_warning=False,\n        suppress_warnings=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['suppress_launch_template_warning', 'suppress_warnings']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InstanceRequireImdsv2AspectProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.InterfaceVpcEndpointAttributes
class InterfaceVpcEndpointAttributesDef(BaseStruct):
    port: typing.Union[int, float] = pydantic.Field(..., description='The port of the service of the interface VPC endpoint.\n')
    vpc_endpoint_id: str = pydantic.Field(..., description='The interface VPC endpoint identifier.\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='The security groups associated with the interface VPC endpoint. If you wish to manage the network connections associated with this endpoint, you will need to specify its security groups.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # security_group: ec2.SecurityGroup\n\n    interface_vpc_endpoint_attributes = ec2.InterfaceVpcEndpointAttributes(\n        port=123,\n        vpc_endpoint_id="vpcEndpointId",\n\n        # the properties below are optional\n        security_groups=[security_group]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['port', 'vpc_endpoint_id', 'security_groups']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InterfaceVpcEndpointAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.InterfaceVpcEndpointOptions
class InterfaceVpcEndpointOptionsDef(BaseStruct):
    service: typing.Union[models.aws_ec2.InterfaceVpcEndpointAwsServiceDef, models.aws_ec2.InterfaceVpcEndpointServiceDef] = pydantic.Field(..., description='The service to use for this interface VPC endpoint.\n')
    lookup_supported_azs: typing.Optional[bool] = pydantic.Field(None, description="Limit to only those availability zones where the endpoint service can be created. Setting this to 'true' requires a lookup to be performed at synthesis time. Account and region must be set on the containing stack for this to work. Default: false\n")
    open: typing.Optional[bool] = pydantic.Field(None, description="Whether to automatically allow VPC traffic to the endpoint. If enabled, all traffic to the endpoint from within the VPC will be automatically allowed. This is done based on the VPC's CIDR range. Default: true\n")
    private_dns_enabled: typing.Optional[bool] = pydantic.Field(None, description='Whether to associate a private hosted zone with the specified VPC. This allows you to make requests to the service using its default DNS hostname. Default: set by the instance of IInterfaceVpcEndpointService, or true if not defined by the instance of IInterfaceVpcEndpointService\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='The security groups to associate with this interface VPC endpoint. Default: - a new security group is created\n')
    subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The subnets in which to create an endpoint network interface. At most one per availability zone. Default: - private subnets\n\n:exampleMetadata: lit=aws-ec2/test/integ.vpc-endpoint.lit.ts infused\n\nExample::\n\n    # Add gateway endpoints when creating the VPC\n    vpc = ec2.Vpc(self, "MyVpc",\n        gateway_endpoints={\n            "S3": cdk.aws_ec2.GatewayVpcEndpointOptions(\n                service=ec2.GatewayVpcEndpointAwsService.S3\n            )\n        }\n    )\n\n    # Alternatively gateway endpoints can be added on the VPC\n    dynamo_db_endpoint = vpc.add_gateway_endpoint("DynamoDbEndpoint",\n        service=ec2.GatewayVpcEndpointAwsService.DYNAMODB\n    )\n\n    # This allows to customize the endpoint policy\n    dynamo_db_endpoint.add_to_policy(\n        iam.PolicyStatement( # Restrict to listing and describing tables\n            principals=[iam.AnyPrincipal()],\n            actions=["dynamodb:DescribeTable", "dynamodb:ListTables"],\n            resources=["*"]))\n\n    # Add an interface endpoint\n    vpc.add_interface_endpoint("EcrDockerEndpoint",\n        service=ec2.InterfaceVpcEndpointAwsService.ECR_DOCKER\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['service', 'lookup_supported_azs', 'open', 'private_dns_enabled', 'security_groups', 'subnets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InterfaceVpcEndpointOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.InterfaceVpcEndpointProps
class InterfaceVpcEndpointPropsDef(BaseStruct):
    service: typing.Union[models.aws_ec2.InterfaceVpcEndpointAwsServiceDef, models.aws_ec2.InterfaceVpcEndpointServiceDef] = pydantic.Field(..., description='The service to use for this interface VPC endpoint.\n')
    lookup_supported_azs: typing.Optional[bool] = pydantic.Field(None, description="Limit to only those availability zones where the endpoint service can be created. Setting this to 'true' requires a lookup to be performed at synthesis time. Account and region must be set on the containing stack for this to work. Default: false\n")
    open: typing.Optional[bool] = pydantic.Field(None, description="Whether to automatically allow VPC traffic to the endpoint. If enabled, all traffic to the endpoint from within the VPC will be automatically allowed. This is done based on the VPC's CIDR range. Default: true\n")
    private_dns_enabled: typing.Optional[bool] = pydantic.Field(None, description='Whether to associate a private hosted zone with the specified VPC. This allows you to make requests to the service using its default DNS hostname. Default: set by the instance of IInterfaceVpcEndpointService, or true if not defined by the instance of IInterfaceVpcEndpointService\n')
    security_groups: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SecurityGroupDef]]] = pydantic.Field(None, description='The security groups to associate with this interface VPC endpoint. Default: - a new security group is created\n')
    subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The subnets in which to create an endpoint network interface. At most one per availability zone. Default: - private subnets\n')
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='The VPC network in which the interface endpoint will be used.\n\n:exampleMetadata: infused\n\nExample::\n\n    # vpc: ec2.Vpc\n\n\n    ec2.InterfaceVpcEndpoint(self, "VPC Endpoint",\n        vpc=vpc,\n        service=ec2.InterfaceVpcEndpointService("com.amazonaws.vpce.us-east-1.vpce-svc-uuddlrlrbastrtsvc", 443),\n        # Choose which availability zones to place the VPC endpoint in, based on\n        # available AZs\n        subnets=ec2.SubnetSelection(\n            availability_zones=["us-east-1a", "us-east-1c"]\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['service', 'lookup_supported_azs', 'open', 'private_dns_enabled', 'security_groups', 'subnets', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.InterfaceVpcEndpointProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[InterfaceVpcEndpointPropsDefConfig] = pydantic.Field(None)


class InterfaceVpcEndpointPropsDefConfig(pydantic.BaseModel):
    vpc_config: typing.Optional[models._interface_methods.AwsEc2IVpcDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ec2.LaunchTemplateAttributes
class LaunchTemplateAttributesDef(BaseStruct):
    launch_template_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the Launch Template. Exactly one of ``launchTemplateId`` and ``launchTemplateName`` may be set. Default: None\n')
    launch_template_name: typing.Optional[str] = pydantic.Field(None, description='The name of the Launch Template. Exactly one of ``launchTemplateId`` and ``launchTemplateName`` may be set. Default: None\n')
    version_number: typing.Optional[str] = pydantic.Field(None, description='The version number of this launch template to use. Default: Version: "$Default"\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    launch_template_attributes = ec2.LaunchTemplateAttributes(\n        launch_template_id="launchTemplateId",\n        launch_template_name="launchTemplateName",\n        version_number="versionNumber"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['launch_template_id', 'launch_template_name', 'version_number']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.LaunchTemplateAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.LaunchTemplateProps
class LaunchTemplatePropsDef(BaseStruct):
    block_devices: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.BlockDeviceDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Specifies how block devices are exposed to the instance. You can specify virtual devices and EBS volumes. Each instance that is launched has an associated root device volume, either an Amazon EBS volume or an instance store volume. You can use block device mappings to specify additional EBS volumes or instance store volumes to attach to an instance when it is launched. Default: - Uses the block device mapping of the AMI\n')
    cpu_credits: typing.Optional[aws_cdk.aws_ec2.CpuCredits] = pydantic.Field(None, description='CPU credit type for burstable EC2 instance types. Default: - No credit type is specified in the Launch Template.\n')
    detailed_monitoring: typing.Optional[bool] = pydantic.Field(None, description='If set to true, then detailed monitoring will be enabled on instances created with this launch template. Default: False - Detailed monitoring is disabled.\n')
    disable_api_termination: typing.Optional[bool] = pydantic.Field(None, description='If you set this parameter to true, you cannot terminate the instances launched with this launch template using the Amazon EC2 console, CLI, or API; otherwise, you can. Default: - The API termination setting is not specified in the Launch Template.\n')
    ebs_optimized: typing.Optional[bool] = pydantic.Field(None, description="Indicates whether the instances are optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance. Default: - EBS optimization is not specified in the launch template.\n")
    hibernation_configured: typing.Optional[bool] = pydantic.Field(None, description='If you set this parameter to true, the instance is enabled for hibernation. Default: - Hibernation configuration is not specified in the launch template; defaulting to false.\n')
    http_endpoint: typing.Optional[bool] = pydantic.Field(None, description='Enables or disables the HTTP metadata endpoint on your instances. Default: true\n')
    http_protocol_ipv6: typing.Optional[bool] = pydantic.Field(None, description='Enables or disables the IPv6 endpoint for the instance metadata service. Default: true\n')
    http_put_response_hop_limit: typing.Union[int, float, None] = pydantic.Field(None, description='The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Default: 1\n')
    http_tokens: typing.Optional[aws_cdk.aws_ec2.LaunchTemplateHttpTokens] = pydantic.Field(None, description='The state of token usage for your instance metadata requests. The default state is ``optional`` if not specified. However, if requireImdsv2 is true, the state must be ``required``. Default: LaunchTemplateHttpTokens.OPTIONAL\n')
    instance_initiated_shutdown_behavior: typing.Optional[aws_cdk.aws_ec2.InstanceInitiatedShutdownBehavior] = pydantic.Field(None, description='Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown). Default: - Shutdown behavior is not specified in the launch template; defaults to STOP.\n')
    instance_metadata_tags: typing.Optional[bool] = pydantic.Field(None, description='Set to enabled to allow access to instance tags from the instance metadata. Set to disabled to turn off access to instance tags from the instance metadata. Default: false\n')
    instance_type: typing.Optional[models.aws_ec2.InstanceTypeDef] = pydantic.Field(None, description='Type of instance to launch. Default: - This Launch Template does not specify a default Instance Type.\n')
    key_name: typing.Optional[str] = pydantic.Field(None, description='Name of SSH keypair to grant access to instance. Default: - No SSH access will be possible.\n')
    launch_template_name: typing.Optional[str] = pydantic.Field(None, description='Name for this launch template. Default: Automatically generated name\n')
    machine_image: typing.Optional[typing.Union[models.aws_ec2.AmazonLinux2022ImageSsmParameterDef, models.aws_ec2.AmazonLinux2023ImageSsmParameterDef, models.aws_ec2.AmazonLinux2ImageSsmParameterDef, models.aws_ec2.AmazonLinuxImageDef, models.aws_ec2.AmazonLinuxImageSsmParameterBaseDef, models.aws_ec2.GenericLinuxImageDef, models.aws_ec2.GenericSSMParameterImageDef, models.aws_ec2.GenericWindowsImageDef, models.aws_ec2.LookupMachineImageDef, models.aws_ec2.NatInstanceImageDef, models.aws_ec2.WindowsImageDef, models.aws_ecs.BottleRocketImageDef, models.aws_ecs.EcsOptimizedImageDef, models.aws_eks.EksOptimizedImageDef]] = pydantic.Field(None, description='The AMI that will be used by instances. Default: - This Launch Template does not specify a default AMI.\n')
    nitro_enclave_enabled: typing.Optional[bool] = pydantic.Field(None, description='If this parameter is set to true, the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves. Default: - Enablement of Nitro enclaves is not specified in the launch template; defaulting to false.\n')
    require_imdsv2: typing.Optional[bool] = pydantic.Field(None, description='Whether IMDSv2 should be required on launched instances. Default: - false\n')
    role: typing.Optional[typing.Union[models.aws_iam.LazyRoleDef, models.aws_iam.RoleDef]] = pydantic.Field(None, description='An IAM role to associate with the instance profile that is used by instances. The role must be assumable by the service principal ``ec2.amazonaws.com``: Default: - No new role is created.\n')
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='Security group to assign to instances created with the launch template. Default: No security group is assigned.\n')
    spot_options: typing.Union[models.aws_ec2.LaunchTemplateSpotOptionsDef, dict[str, typing.Any], None] = pydantic.Field(None, description="If this property is defined, then the Launch Template's InstanceMarketOptions will be set to use Spot instances, and the options for the Spot instances will be as defined. Default: - Instance launched with this template will not be spot instances.\n")
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='The AMI that will be used by instances. Default: - This Launch Template creates a UserData based on the type of provided machineImage; no UserData is created if a machineImage is not provided\n\n:exampleMetadata: infused\n\nExample::\n\n    # vpc: ec2.Vpc\n\n\n    template = ec2.LaunchTemplate(self, "LaunchTemplate",\n        machine_image=ec2.MachineImage.latest_amazon_linux2022(),\n        security_group=ec2.SecurityGroup(self, "LaunchTemplateSG",\n            vpc=vpc\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['block_devices', 'cpu_credits', 'detailed_monitoring', 'disable_api_termination', 'ebs_optimized', 'hibernation_configured', 'http_endpoint', 'http_protocol_ipv6', 'http_put_response_hop_limit', 'http_tokens', 'instance_initiated_shutdown_behavior', 'instance_metadata_tags', 'instance_type', 'key_name', 'launch_template_name', 'machine_image', 'nitro_enclave_enabled', 'require_imdsv2', 'role', 'security_group', 'spot_options', 'user_data']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.LaunchTemplateProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.LaunchTemplateRequireImdsv2AspectProps
class LaunchTemplateRequireImdsv2AspectPropsDef(BaseStruct):
    suppress_warnings: typing.Optional[bool] = pydantic.Field(None, description='Whether warning annotations from this Aspect should be suppressed or not. Default: - false\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    launch_template_require_imdsv2_aspect_props = ec2.LaunchTemplateRequireImdsv2AspectProps(\n        suppress_warnings=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['suppress_warnings']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.LaunchTemplateRequireImdsv2AspectProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.LaunchTemplateSpotOptions
class LaunchTemplateSpotOptionsDef(BaseStruct):
    block_duration: typing.Optional[models.DurationDef] = pydantic.Field(None, description='Spot Instances with a defined duration (also known as Spot blocks) are designed not to be interrupted and will run continuously for the duration you select. You can use a duration of 1, 2, 3, 4, 5, or 6 hours. Default: Requested spot instances do not have a pre-defined duration.\n')
    interruption_behavior: typing.Optional[aws_cdk.aws_ec2.SpotInstanceInterruption] = pydantic.Field(None, description='The behavior when a Spot Instance is interrupted. Default: Spot instances will terminate when interrupted.\n')
    max_price: typing.Union[int, float, None] = pydantic.Field(None, description="Maximum hourly price you're willing to pay for each Spot instance. The value is given in dollars. ex: 0.01 for 1 cent per hour, or 0.001 for one-tenth of a cent per hour. Default: Maximum hourly price will default to the on-demand price for the instance type.\n")
    request_type: typing.Optional[aws_cdk.aws_ec2.SpotRequestType] = pydantic.Field(None, description='The Spot Instance request type. If you are using Spot Instances with an Auto Scaling group, use one-time requests, as the Amazon EC2 Auto Scaling service handles requesting new Spot Instances whenever the group is below its desired capacity. Default: One-time spot request.\n')
    valid_until: typing.Optional[models.ExpirationDef] = pydantic.Field(None, description='The end date of the request. For a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached. Default: The default end date is 7 days from the current date.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_ec2 as ec2\n\n    # expiration: cdk.Expiration\n\n    launch_template_spot_options = ec2.LaunchTemplateSpotOptions(\n        block_duration=cdk.Duration.minutes(30),\n        interruption_behavior=ec2.SpotInstanceInterruption.STOP,\n        max_price=123,\n        request_type=ec2.SpotRequestType.ONE_TIME,\n        valid_until=expiration\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['block_duration', 'interruption_behavior', 'max_price', 'request_type', 'valid_until']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.LaunchTemplateSpotOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.LinuxUserDataOptions
class LinuxUserDataOptionsDef(BaseStruct):
    shebang: typing.Optional[str] = pydantic.Field(None, description='Shebang for the UserData script. Default: "#!/bin/bash"\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    linux_user_data_options = ec2.LinuxUserDataOptions(\n        shebang="shebang"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['shebang']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.LinuxUserDataOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.LocationPackageOptions
class LocationPackageOptionsDef(BaseStruct):
    key: typing.Optional[str] = pydantic.Field(None, description='Identifier key for this package. You can use this to order package installs. Default: - Automatically generated\n')
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given service after this command has run. Default: - Do not restart any service\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # init_service_restart_handle: ec2.InitServiceRestartHandle\n\n    location_package_options = ec2.LocationPackageOptions(\n        key="key",\n        service_restart_handles=[init_service_restart_handle]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key', 'service_restart_handles']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.LocationPackageOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.LookupMachineImageProps
class LookupMachineImagePropsDef(BaseStruct):
    name: str = pydantic.Field(..., description='Name of the image (may contain wildcards).\n')
    filters: typing.Optional[typing.Mapping[str, typing.Sequence[str]]] = pydantic.Field(None, description='Additional filters on the AMI. Default: - No additional filters\n')
    owners: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Owner account IDs or aliases. Default: - All owners\n')
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Custom userdata for this image. Default: - Empty user data appropriate for the platform type\n')
    windows: typing.Optional[bool] = pydantic.Field(None, description='Look for Windows images. Default: false\n\n:exampleMetadata: lit=aws-ec2/test/example.images.lit.ts infused\n\nExample::\n\n    # Pick the right Amazon Linux edition. All arguments shown are optional\n    # and will default to these values when omitted.\n    amzn_linux = ec2.MachineImage.latest_amazon_linux(\n        generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX,\n        edition=ec2.AmazonLinuxEdition.STANDARD,\n        virtualization=ec2.AmazonLinuxVirt.HVM,\n        storage=ec2.AmazonLinuxStorage.GENERAL_PURPOSE,\n        cpu_type=ec2.AmazonLinuxCpuType.X86_64\n    )\n\n    # Pick a Windows edition to use\n    windows = ec2.MachineImage.latest_windows(ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_BASE)\n\n    # Read AMI id from SSM parameter store\n    ssm = ec2.MachineImage.from_ssm_parameter("/my/ami", os=ec2.OperatingSystemType.LINUX)\n\n    # Look up the most recent image matching a set of AMI filters.\n    # In this case, look up the NAT instance AMI, by using a wildcard\n    # in the \'name\' field:\n    nat_ami = ec2.MachineImage.lookup(\n        name="amzn-ami-vpc-nat-*",\n        owners=["amazon"]\n    )\n\n    # For other custom (Linux) images, instantiate a `GenericLinuxImage` with\n    # a map giving the AMI to in for each region:\n    linux = ec2.MachineImage.generic_linux({\n        "us-east-1": "ami-97785bed",\n        "eu-west-1": "ami-12345678"\n    })\n\n    # For other custom (Windows) images, instantiate a `GenericWindowsImage` with\n    # a map giving the AMI to in for each region:\n    generic_windows = ec2.MachineImage.generic_windows({\n        "us-east-1": "ami-97785bed",\n        "eu-west-1": "ami-12345678"\n    })\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'filters', 'owners', 'user_data', 'windows']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.LookupMachineImageProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.MachineImageConfig
class MachineImageConfigDef(BaseStruct):
    image_id: str = pydantic.Field(..., description='The AMI ID of the image to use.\n')
    os_type: aws_cdk.aws_ec2.OperatingSystemType = pydantic.Field(..., description='Operating system type for this image.\n')
    user_data: models.aws_ec2.UserDataDef = pydantic.Field(..., description='Initial UserData for this image.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # user_data: ec2.UserData\n\n    machine_image_config = ec2.MachineImageConfig(\n        image_id="imageId",\n        os_type=ec2.OperatingSystemType.LINUX,\n        user_data=user_data\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['image_id', 'os_type', 'user_data']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.MachineImageConfig'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.MultipartBodyOptions
class MultipartBodyOptionsDef(BaseStruct):
    content_type: str = pydantic.Field(..., description='``Content-Type`` header of this part. Some examples of content types: - ``text/x-shellscript; charset="utf-8"`` (shell script) - ``text/cloud-boothook; charset="utf-8"`` (shell script executed during boot phase) For Linux shell scripts use ``text/x-shellscript``.\n')
    body: typing.Optional[str] = pydantic.Field(None, description='The body of message. Default: undefined - body will not be added to part\n')
    transfer_encoding: typing.Optional[str] = pydantic.Field(None, description='``Content-Transfer-Encoding`` header specifying part encoding. Default: undefined - body is not encoded\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    multipart_body_options = ec2.MultipartBodyOptions(\n        content_type="contentType",\n\n        # the properties below are optional\n        body="body",\n        transfer_encoding="transferEncoding"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['content_type', 'body', 'transfer_encoding']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.MultipartBodyOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.MultipartUserDataOptions
class MultipartUserDataOptionsDef(BaseStruct):
    parts_separator: typing.Optional[str] = pydantic.Field(None, description='The string used to separate parts in multipart user data archive (it\'s like MIME boundary). This string should contain [a-zA-Z0-9()+,-./:=?] characters only, and should not be present in any part, or in text content of archive. Default: ``+AWS+CDK+User+Data+Separator==``\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    multipart_user_data_options = ec2.MultipartUserDataOptions(\n        parts_separator="partsSeparator"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['parts_separator']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.MultipartUserDataOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.NamedPackageOptions
class NamedPackageOptionsDef(BaseStruct):
    service_restart_handles: typing.Optional[typing.Sequence[models.aws_ec2.InitServiceRestartHandleDef]] = pydantic.Field(None, description='Restart the given services after this command has run. Default: - Do not restart any service\n')
    version: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Specify the versions to install. Default: - Install the latest version\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # init_service_restart_handle: ec2.InitServiceRestartHandle\n\n    named_package_options = ec2.NamedPackageOptions(\n        service_restart_handles=[init_service_restart_handle],\n        version=["version"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['service_restart_handles', 'version']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.NamedPackageOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.NatGatewayProps
class NatGatewayPropsDef(BaseStruct):
    eip_allocation_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='EIP allocation IDs for the NAT gateways. Default: - No fixed EIPs allocated for the NAT gateways\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    nat_gateway_props = ec2.NatGatewayProps(\n        eip_allocation_ids=["eipAllocationIds"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['eip_allocation_ids']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.NatGatewayProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.NatInstanceProps
class NatInstancePropsDef(BaseStruct):
    instance_type: models.aws_ec2.InstanceTypeDef = pydantic.Field(..., description='Instance type of the NAT instance.\n')
    default_allowed_traffic: typing.Optional[aws_cdk.aws_ec2.NatTrafficDirection] = pydantic.Field(None, description="Direction to allow all traffic through the NAT instance by default. By default, inbound and outbound traffic is allowed. If you set this to another value than INBOUND_AND_OUTBOUND, you must configure the NAT instance's security groups in another way, either by passing in a fully configured Security Group using the ``securityGroup`` property, or by configuring it using the ``.securityGroup`` or ``.connections`` members after passing the NAT Instance Provider to a Vpc. Default: NatTrafficDirection.INBOUND_AND_OUTBOUND\n")
    key_name: typing.Optional[str] = pydantic.Field(None, description='Name of SSH keypair to grant access to instance. Default: - No SSH access will be possible.\n')
    machine_image: typing.Optional[typing.Union[models.aws_ec2.AmazonLinux2022ImageSsmParameterDef, models.aws_ec2.AmazonLinux2023ImageSsmParameterDef, models.aws_ec2.AmazonLinux2ImageSsmParameterDef, models.aws_ec2.AmazonLinuxImageDef, models.aws_ec2.AmazonLinuxImageSsmParameterBaseDef, models.aws_ec2.GenericLinuxImageDef, models.aws_ec2.GenericSSMParameterImageDef, models.aws_ec2.GenericWindowsImageDef, models.aws_ec2.LookupMachineImageDef, models.aws_ec2.NatInstanceImageDef, models.aws_ec2.WindowsImageDef, models.aws_ecs.BottleRocketImageDef, models.aws_ecs.EcsOptimizedImageDef, models.aws_eks.EksOptimizedImageDef]] = pydantic.Field(None, description="The machine image (AMI) to use. By default, will do an AMI lookup for the latest NAT instance image. If you have a specific AMI ID you want to use, pass a ``GenericLinuxImage``. For example:: ec2.NatProvider.instance({ instanceType: new ec2.InstanceType('t3.micro'), machineImage: new ec2.GenericLinuxImage({ 'us-east-2': 'ami-0f9c61b5a562a16af' }) }) Default: - Latest NAT instance image\n")
    security_group: typing.Optional[typing.Union[models.aws_ec2.SecurityGroupDef]] = pydantic.Field(None, description='Security Group for NAT instances. Default: - A new security group will be created\n\n:exampleMetadata: lit=aws-ec2/test/integ.nat-instances.lit.ts infused\n\nExample::\n\n    # Configure the `natGatewayProvider` when defining a Vpc\n    nat_gateway_provider = ec2.NatProvider.instance(\n        instance_type=ec2.InstanceType("t3.small")\n    )\n\n    vpc = ec2.Vpc(self, "MyVpc",\n        nat_gateway_provider=nat_gateway_provider,\n\n        # The \'natGateways\' parameter now controls the number of NAT instances\n        nat_gateways=2\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['instance_type', 'default_allowed_traffic', 'key_name', 'machine_image', 'security_group']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.NatInstanceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[NatInstancePropsDefConfig] = pydantic.Field(None)


class NatInstancePropsDefConfig(pydantic.BaseModel):
    instance_type_config: typing.Optional[models.aws_ec2.InstanceTypeDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ec2.NetworkAclEntryProps
class NetworkAclEntryPropsDef(BaseStruct):
    cidr: models.aws_ec2.AclCidrDef = pydantic.Field(..., description='The CIDR range to allow or deny.\n')
    rule_number: typing.Union[int, float] = pydantic.Field(..., description="Rule number to assign to the entry, such as 100. ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.\n")
    traffic: models.aws_ec2.AclTrafficDef = pydantic.Field(..., description='What kind of traffic this ACL rule applies to.\n')
    direction: typing.Optional[aws_cdk.aws_ec2.TrafficDirection] = pydantic.Field(None, description='Traffic direction, with respect to the subnet, this rule applies to. Default: TrafficDirection.INGRESS\n')
    network_acl_entry_name: typing.Optional[str] = pydantic.Field(None, description="The name of the NetworkAclEntry. It is not recommended to use an explicit group name. Default: If you don't specify a NetworkAclName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.\n")
    rule_action: typing.Optional[aws_cdk.aws_ec2.Action] = pydantic.Field(None, description='Whether to allow or deny traffic that matches the rule; valid values are "allow" or "deny". Any traffic that is not explicitly allowed is automatically denied in a custom ACL, all traffic is automatically allowed in a default ACL. Default: ALLOW\n')
    network_acl: typing.Union[models.aws_ec2.NetworkAclDef] = pydantic.Field(..., description='The network ACL this entry applies to.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # acl_cidr: ec2.AclCidr\n    # acl_traffic: ec2.AclTraffic\n    # network_acl: ec2.NetworkAcl\n\n    network_acl_entry_props = ec2.NetworkAclEntryProps(\n        cidr=acl_cidr,\n        network_acl=network_acl,\n        rule_number=123,\n        traffic=acl_traffic,\n\n        # the properties below are optional\n        direction=ec2.TrafficDirection.EGRESS,\n        network_acl_entry_name="networkAclEntryName",\n        rule_action=ec2.Action.ALLOW\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cidr', 'rule_number', 'traffic', 'direction', 'network_acl_entry_name', 'rule_action', 'network_acl']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.NetworkAclEntryProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[NetworkAclEntryPropsDefConfig] = pydantic.Field(None)


class NetworkAclEntryPropsDefConfig(pydantic.BaseModel):
    cidr_config: typing.Optional[models.aws_ec2.AclCidrDefConfig] = pydantic.Field(None)
    network_acl_config: typing.Optional[models._interface_methods.AwsEc2INetworkAclDefConfig] = pydantic.Field(None)
    traffic_config: typing.Optional[models.aws_ec2.AclTrafficDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ec2.NetworkAclProps
class NetworkAclPropsDef(BaseStruct):
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='The VPC in which to create the NetworkACL.\n')
    network_acl_name: typing.Optional[str] = pydantic.Field(None, description="The name of the NetworkAcl. It is not recommended to use an explicit name. Default: If you don't specify a networkAclName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.\n")
    subnet_selection: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Subnets in the given VPC to associate the ACL with. More subnets can always be added later by calling ``associateWithSubnets()``. Default: - No subnets associated\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # subnet: ec2.Subnet\n    # subnet_filter: ec2.SubnetFilter\n    # vpc: ec2.Vpc\n\n    network_acl_props = ec2.NetworkAclProps(\n        vpc=vpc,\n\n        # the properties below are optional\n        network_acl_name="networkAclName",\n        subnet_selection=ec2.SubnetSelection(\n            availability_zones=["availabilityZones"],\n            one_per_az=False,\n            subnet_filters=[subnet_filter],\n            subnet_group_name="subnetGroupName",\n            subnets=[subnet],\n            subnet_type=ec2.SubnetType.PRIVATE_ISOLATED\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['vpc', 'network_acl_name', 'subnet_selection']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.NetworkAclProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[NetworkAclPropsDefConfig] = pydantic.Field(None)


class NetworkAclPropsDefConfig(pydantic.BaseModel):
    vpc_config: typing.Optional[models._interface_methods.AwsEc2IVpcDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ec2.PlacementGroupProps
class PlacementGroupPropsDef(BaseStruct):
    partitions: typing.Union[int, float, None] = pydantic.Field(None, description='The number of partitions. Valid only when Strategy is set to partition. Default: 0\n')
    placement_group_name: typing.Optional[str] = pydantic.Field(None, description='the name of this placement group. Default: - generated by CFN\n')
    spread_level: typing.Optional[aws_cdk.aws_ec2.PlacementGroupSpreadLevel] = pydantic.Field(None, description='Places instances on distinct hardware. Spread placement groups are recommended for applications that have a small number of critical instances that should be kept separate from each other. Launching instances in a spread level placement group reduces the risk of simultaneous failures that might occur when instances share the same equipment. Spread level placement groups provide access to distinct hardware, and are therefore suitable for mixing instance types or launching instances over time. If you start or launch an instance in a spread placement group and there is insufficient unique hardware to fulfill the request, the request fails. Amazon EC2 makes more distinct hardware available over time, so you can try your request again later. Placement groups can spread instances across racks or hosts. You can use host level spread placement groups only with AWS Outposts. Default: - no spread level\n')
    strategy: typing.Optional[aws_cdk.aws_ec2.PlacementGroupStrategy] = pydantic.Field(None, description='Which strategy to use when launching instances. Default: - ``PlacementGroupStrategy.PARTITION`` if ``partitions`` is defined, ``CLUSTER`` otherwise\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    placement_group_props = ec2.PlacementGroupProps(\n        partitions=123,\n        placement_group_name="placementGroupName",\n        spread_level=ec2.PlacementGroupSpreadLevel.HOST,\n        strategy=ec2.PlacementGroupStrategy.CLUSTER\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['partitions', 'placement_group_name', 'spread_level', 'strategy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.PlacementGroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.PortProps
class PortPropsDef(BaseStruct):
    protocol: aws_cdk.aws_ec2.Protocol = pydantic.Field(..., description='The protocol for the range.\n')
    string_representation: str = pydantic.Field(..., description='String representation for this object.\n')
    from_port: typing.Union[int, float, None] = pydantic.Field(None, description='The starting port for the range. Default: - Not included in the rule\n')
    to_port: typing.Union[int, float, None] = pydantic.Field(None, description='The ending port for the range. Default: - Not included in the rule\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    port_props = ec2.PortProps(\n        protocol=ec2.Protocol.ALL,\n        string_representation="stringRepresentation",\n\n        # the properties below are optional\n        from_port=123,\n        to_port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['protocol', 'string_representation', 'from_port', 'to_port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.PortProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.PrefixListOptions
class PrefixListOptionsDef(BaseStruct):
    max_entries: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of entries for the prefix list. Default: Automatically-calculated\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    prefix_list_options = ec2.PrefixListOptions(\n        max_entries=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max_entries']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.PrefixListOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.PrefixListProps
class PrefixListPropsDef(BaseStruct):
    max_entries: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum number of entries for the prefix list. Default: Automatically-calculated\n')
    address_family: typing.Optional[aws_cdk.aws_ec2.AddressFamily] = pydantic.Field(None, description='The address family of the prefix list. Default: AddressFamily.IP_V4\n')
    entries: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.CfnPrefixList_EntryPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The list of entries for the prefix list. Default: []\n')
    prefix_list_name: typing.Optional[str] = pydantic.Field(None, description='The name of the prefix list. Default: None\n\n:exampleMetadata: infused\n\nExample::\n\n    ec2.PrefixList(self, "EmptyPrefixList",\n        max_entries=100\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['max_entries', 'address_family', 'entries', 'prefix_list_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.PrefixListProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.PrivateSubnetAttributes
class PrivateSubnetAttributesDef(BaseStruct):
    subnet_id: str = pydantic.Field(..., description='The subnetId for this particular subnet.')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone the subnet is located in. Default: - No AZ information, cannot use AZ selection features\n')
    ipv4_cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv4 CIDR block associated with the subnet. Default: - No CIDR information, cannot use CIDR filter features\n')
    route_table_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the route table for this particular subnet. Default: - No route table information, cannot create VPC endpoints\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    private_subnet_attributes = ec2.PrivateSubnetAttributes(\n        subnet_id="subnetId",\n\n        # the properties below are optional\n        availability_zone="availabilityZone",\n        ipv4_cidr_block="ipv4CidrBlock",\n        route_table_id="routeTableId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['subnet_id', 'availability_zone', 'ipv4_cidr_block', 'route_table_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.PrivateSubnetAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.PrivateSubnetProps
class PrivateSubnetPropsDef(BaseStruct):
    availability_zone: str = pydantic.Field(..., description='The availability zone for the subnet.')
    cidr_block: str = pydantic.Field(..., description='The CIDR notation for this subnet.\n')
    vpc_id: str = pydantic.Field(..., description='The VPC which this subnet is part of.\n')
    map_public_ip_on_launch: typing.Optional[bool] = pydantic.Field(None, description='Controls if a public IP is associated to an instance at launch. Default: true in Subnet.Public, false in Subnet.Private or Subnet.Isolated.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    private_subnet_props = ec2.PrivateSubnetProps(\n        availability_zone="availabilityZone",\n        cidr_block="cidrBlock",\n        vpc_id="vpcId",\n\n        # the properties below are optional\n        map_public_ip_on_launch=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'cidr_block', 'vpc_id', 'map_public_ip_on_launch']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.PrivateSubnetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.PublicSubnetAttributes
class PublicSubnetAttributesDef(BaseStruct):
    subnet_id: str = pydantic.Field(..., description='The subnetId for this particular subnet.')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone the subnet is located in. Default: - No AZ information, cannot use AZ selection features\n')
    ipv4_cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv4 CIDR block associated with the subnet. Default: - No CIDR information, cannot use CIDR filter features\n')
    route_table_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the route table for this particular subnet. Default: - No route table information, cannot create VPC endpoints\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    public_subnet_attributes = ec2.PublicSubnetAttributes(\n        subnet_id="subnetId",\n\n        # the properties below are optional\n        availability_zone="availabilityZone",\n        ipv4_cidr_block="ipv4CidrBlock",\n        route_table_id="routeTableId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['subnet_id', 'availability_zone', 'ipv4_cidr_block', 'route_table_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.PublicSubnetAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.PublicSubnetProps
class PublicSubnetPropsDef(BaseStruct):
    availability_zone: str = pydantic.Field(..., description='The availability zone for the subnet.')
    cidr_block: str = pydantic.Field(..., description='The CIDR notation for this subnet.\n')
    vpc_id: str = pydantic.Field(..., description='The VPC which this subnet is part of.\n')
    map_public_ip_on_launch: typing.Optional[bool] = pydantic.Field(None, description='Controls if a public IP is associated to an instance at launch. Default: true in Subnet.Public, false in Subnet.Private or Subnet.Isolated.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    public_subnet_props = ec2.PublicSubnetProps(\n        availability_zone="availabilityZone",\n        cidr_block="cidrBlock",\n        vpc_id="vpcId",\n\n        # the properties below are optional\n        map_public_ip_on_launch=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'cidr_block', 'vpc_id', 'map_public_ip_on_launch']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.PublicSubnetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.RequestedSubnet
class RequestedSubnetDef(BaseStruct):
    availability_zone: str = pydantic.Field(..., description='The availability zone for the subnet.\n')
    configuration: typing.Union[models.aws_ec2.SubnetConfigurationDef, dict[str, typing.Any]] = pydantic.Field(..., description='Specify configuration parameters for a single subnet group in a VPC.\n')
    subnet_construct_id: str = pydantic.Field(..., description='Id for the Subnet construct.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    requested_subnet = ec2.RequestedSubnet(\n        availability_zone="availabilityZone",\n        configuration=ec2.SubnetConfiguration(\n            name="name",\n            subnet_type=ec2.SubnetType.PRIVATE_ISOLATED,\n\n            # the properties below are optional\n            cidr_mask=123,\n            map_public_ip_on_launch=False,\n            reserved=False\n        ),\n        subnet_construct_id="subnetConstructId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'configuration', 'subnet_construct_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.RequestedSubnet'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.RuleScope
class RuleScopeDef(BaseStruct):
    _init_params: typing.ClassVar[list[str]] = []
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.RuleScope'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[RuleScopeDefConfig] = pydantic.Field(None)


class RuleScopeDefConfig(pydantic.BaseModel):
    scope_config: typing.Optional[models._interface_methods.AwsEc2ISecurityGroupDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ec2.S3DestinationOptions
class S3DestinationOptionsDef(BaseStruct):
    file_format: typing.Optional[aws_cdk.aws_ec2.FlowLogFileFormat] = pydantic.Field(None, description='The format for the flow log. Default: FlowLogFileFormat.PLAIN_TEXT\n')
    hive_compatible_partitions: typing.Optional[bool] = pydantic.Field(None, description='Use Hive-compatible prefixes for flow logs stored in Amazon S3. Default: false\n')
    per_hour_partition: typing.Optional[bool] = pydantic.Field(None, description='Partition the flow log per hour. Default: false\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    s3_destination_options = ec2.S3DestinationOptions(\n        file_format=ec2.FlowLogFileFormat.PLAIN_TEXT,\n        hive_compatible_partitions=False,\n        per_hour_partition=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['file_format', 'hive_compatible_partitions', 'per_hour_partition']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.S3DestinationOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.S3DownloadOptions
class S3DownloadOptionsDef(BaseStruct):
    bucket: typing.Union[models.aws_s3.BucketBaseDef, models.aws_s3.BucketDef] = pydantic.Field(..., description='Name of the S3 bucket to download from.\n')
    bucket_key: str = pydantic.Field(..., description='The key of the file to download.\n')
    local_file: typing.Optional[str] = pydantic.Field(None, description='The name of the local file. Default: Linux - /tmp/bucketKey Windows - %TEMP%/bucketKey\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region of the S3 Bucket (needed for access via VPC Gateway). Default: none\n\n:exampleMetadata: infused\n\nExample::\n\n    from aws_cdk.aws_s3_assets import Asset\n\n    # instance: ec2.Instance\n\n\n    asset = Asset(self, "Asset",\n        path="./configure.sh"\n    )\n\n    local_path = instance.user_data.add_s3_download_command(\n        bucket=asset.bucket,\n        bucket_key=asset.s3_object_key,\n        region="us-east-1"\n    )\n    instance.user_data.add_execute_file_command(\n        file_path=local_path,\n        arguments="--verbose -y"\n    )\n    asset.grant_read(instance.role)\n')
    _init_params: typing.ClassVar[list[str]] = ['bucket', 'bucket_key', 'local_file', 'region']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.S3DownloadOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[S3DownloadOptionsDefConfig] = pydantic.Field(None)


class S3DownloadOptionsDefConfig(pydantic.BaseModel):
    bucket_config: typing.Optional[models._interface_methods.AwsS3IBucketDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ec2.SecurityGroupImportOptions
class SecurityGroupImportOptionsDef(BaseStruct):
    allow_all_ipv6_outbound: typing.Optional[bool] = pydantic.Field(None, description='Mark the SecurityGroup as having been created allowing all outbound ipv6 traffic. Only if this is set to false will egress rules for ipv6 be added to this security group. Be aware, this would undo any potential "all outbound traffic" default. Default: false\n')
    allow_all_outbound: typing.Optional[bool] = pydantic.Field(None, description='Mark the SecurityGroup as having been created allowing all outbound traffic. Only if this is set to false will egress rules be added to this security group. Be aware, this would undo any potential "all outbound traffic" default. Default: true\n')
    mutable: typing.Optional[bool] = pydantic.Field(None, description='If a SecurityGroup is mutable CDK can add rules to existing groups. Beware that making a SecurityGroup immutable might lead to issue due to missing ingress/egress rules for new resources. Default: true\n\n:exampleMetadata: infused\n\nExample::\n\n    security_group = ec2.SecurityGroup.from_security_group_id(self, "SG", "sg-12345",\n        mutable=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allow_all_ipv6_outbound', 'allow_all_outbound', 'mutable']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.SecurityGroupImportOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.SecurityGroupProps
class SecurityGroupPropsDef(BaseStruct):
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='The VPC in which to create the security group.')
    allow_all_ipv6_outbound: typing.Optional[bool] = pydantic.Field(None, description='Whether to allow all outbound ipv6 traffic by default. If this is set to true, there will only be a single egress rule which allows all outbound ipv6 traffic. If this is set to false, no outbound traffic will be allowed by default and all egress ipv6 traffic must be explicitly authorized. To allow all ipv4 traffic use allowAllOutbound Default: false\n')
    allow_all_outbound: typing.Optional[bool] = pydantic.Field(None, description='Whether to allow all outbound traffic by default. If this is set to true, there will only be a single egress rule which allows all outbound traffic. If this is set to false, no outbound traffic will be allowed by default and all egress traffic must be explicitly authorized. To allow all ipv6 traffic use allowAllIpv6Outbound Default: true\n')
    description: typing.Optional[str] = pydantic.Field(None, description="A description of the security group. Default: The default name will be the construct's CDK path.\n")
    disable_inline_rules: typing.Optional[bool] = pydantic.Field(None, description="Whether to disable inline ingress and egress rule optimization. If this is set to true, ingress and egress rules will not be declared under the SecurityGroup in cloudformation, but will be separate elements. Inlining rules is an optimization for producing smaller stack templates. Sometimes this is not desirable, for example when security group access is managed via tags. The default value can be overriden globally by setting the context variable '@aws-cdk/aws-ec2.securityGroupDisableInlineRules'. Default: false\n")
    security_group_name: typing.Optional[str] = pydantic.Field(None, description='The name of the security group. For valid values, see the GroupName parameter of the CreateSecurityGroup action in the Amazon EC2 API Reference. It is not recommended to use an explicit group name. Default: If you don\'t specify a GroupName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.\n\n:exampleMetadata: fixture=with-vpc infused\n\nExample::\n\n    # Stack 1\n    # stack1: Stack\n    # stack2: Stack\n\n\n    sg1 = ec2.SecurityGroup(stack1, "SG1",\n        allow_all_outbound=False,  # if this is `true` then no egress rule will be created\n        vpc=vpc\n    )\n\n    # Stack 2\n    sg2 = ec2.SecurityGroup(stack2, "SG2",\n        allow_all_outbound=False,  # if this is `true` then no egress rule will be created\n        vpc=vpc\n    )\n\n    # `connections.allowTo` on `sg1` since we want the\n    # rules to be created in Stack1\n    sg1.connections.allow_to(sg2, ec2.Port.tcp(3333))\n')
    _init_params: typing.ClassVar[list[str]] = ['vpc', 'allow_all_ipv6_outbound', 'allow_all_outbound', 'description', 'disable_inline_rules', 'security_group_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.SecurityGroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[SecurityGroupPropsDefConfig] = pydantic.Field(None)


class SecurityGroupPropsDefConfig(pydantic.BaseModel):
    vpc_config: typing.Optional[models._interface_methods.AwsEc2IVpcDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ec2.SelectedSubnets
class SelectedSubnetsDef(BaseStruct):
    availability_zones: typing.Sequence[str] = pydantic.Field(..., description='The respective AZs of each subnet.\n')
    has_public: bool = pydantic.Field(..., description="Whether any of the given subnets are from the VPC's public subnets.\n")
    internet_connectivity_established: typing.Union[models.aws_iam.CompositeDependableDef, models.aws_iam.GrantDef, models.constructs.DependencyGroupDef] = pydantic.Field(..., description='Dependency representing internet connectivity for these subnets.\n')
    subnet_ids: typing.Sequence[str] = pydantic.Field(..., description='The subnet IDs.\n')
    subnets: typing.Sequence[typing.Union[models.aws_ec2.PrivateSubnetDef, models.aws_ec2.PublicSubnetDef, models.aws_ec2.SubnetDef]] = pydantic.Field(..., description='Selected subnet objects.\n')
    is_pending_lookup: typing.Optional[bool] = pydantic.Field(None, description='The subnet selection is not actually real yet. If this value is true, don\'t validate anything about the subnets. The count or identities are not known yet, and the validation will most likely fail which will prevent a successful lookup. Default: false\n\n:exampleMetadata: infused\n\nExample::\n\n    vpc = ec2.Vpc(self, "TheVPC",\n        ip_addresses=ec2.IpAddresses.cidr("10.0.0.0/16")\n    )\n\n    # Iterate the private subnets\n    selection = vpc.select_subnets(\n        subnet_type=ec2.SubnetType.PRIVATE_WITH_EGRESS\n    )\n\n    for subnet in selection.subnets:\n        pass\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zones', 'has_public', 'internet_connectivity_established', 'subnet_ids', 'subnets', 'is_pending_lookup']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.SelectedSubnets'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.SsmParameterImageOptions
class SsmParameterImageOptionsDef(BaseStruct):
    cached_in_context: typing.Optional[bool] = pydantic.Field(None, description="Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false\n")
    os: typing.Optional[aws_cdk.aws_ec2.OperatingSystemType] = pydantic.Field(None, description='Operating system. Default: OperatingSystemType.LINUX\n')
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Custom UserData. Default: - UserData appropriate for the OS\n\n:exampleMetadata: lit=aws-ec2/test/example.images.lit.ts infused\n\nExample::\n\n    # Pick the right Amazon Linux edition. All arguments shown are optional\n    # and will default to these values when omitted.\n    amzn_linux = ec2.MachineImage.latest_amazon_linux(\n        generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX,\n        edition=ec2.AmazonLinuxEdition.STANDARD,\n        virtualization=ec2.AmazonLinuxVirt.HVM,\n        storage=ec2.AmazonLinuxStorage.GENERAL_PURPOSE,\n        cpu_type=ec2.AmazonLinuxCpuType.X86_64\n    )\n\n    # Pick a Windows edition to use\n    windows = ec2.MachineImage.latest_windows(ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_BASE)\n\n    # Read AMI id from SSM parameter store\n    ssm = ec2.MachineImage.from_ssm_parameter("/my/ami", os=ec2.OperatingSystemType.LINUX)\n\n    # Look up the most recent image matching a set of AMI filters.\n    # In this case, look up the NAT instance AMI, by using a wildcard\n    # in the \'name\' field:\n    nat_ami = ec2.MachineImage.lookup(\n        name="amzn-ami-vpc-nat-*",\n        owners=["amazon"]\n    )\n\n    # For other custom (Linux) images, instantiate a `GenericLinuxImage` with\n    # a map giving the AMI to in for each region:\n    linux = ec2.MachineImage.generic_linux({\n        "us-east-1": "ami-97785bed",\n        "eu-west-1": "ami-12345678"\n    })\n\n    # For other custom (Windows) images, instantiate a `GenericWindowsImage` with\n    # a map giving the AMI to in for each region:\n    generic_windows = ec2.MachineImage.generic_windows({\n        "us-east-1": "ami-97785bed",\n        "eu-west-1": "ami-12345678"\n    })\n')
    _init_params: typing.ClassVar[list[str]] = ['cached_in_context', 'os', 'user_data']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.SsmParameterImageOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.SubnetAttributes
class SubnetAttributesDef(BaseStruct):
    subnet_id: str = pydantic.Field(..., description='The subnetId for this particular subnet.')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone the subnet is located in. Default: - No AZ information, cannot use AZ selection features\n')
    ipv4_cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv4 CIDR block associated with the subnet. Default: - No CIDR information, cannot use CIDR filter features\n')
    route_table_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the route table for this particular subnet. Default: - No route table information, cannot create VPC endpoints\n\n:exampleMetadata: infused\n\nExample::\n\n    # Supply all properties\n    subnet1 = ec2.Subnet.from_subnet_attributes(self, "SubnetFromAttributes",\n        subnet_id="s-1234",\n        availability_zone="pub-az-4465",\n        route_table_id="rt-145"\n    )\n\n    # Supply only subnet id\n    subnet2 = ec2.Subnet.from_subnet_id(self, "SubnetFromId", "s-1234")\n')
    _init_params: typing.ClassVar[list[str]] = ['subnet_id', 'availability_zone', 'ipv4_cidr_block', 'route_table_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.SubnetAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.SubnetConfiguration
class SubnetConfigurationDef(BaseStruct):
    name: str = pydantic.Field(..., description='Logical name for the subnet group. This name can be used when selecting VPC subnets to distinguish between different subnet groups of the same type.\n')
    subnet_type: aws_cdk.aws_ec2.SubnetType = pydantic.Field(..., description='The type of Subnet to configure. The Subnet type will control the ability to route and connect to the Internet.\n')
    cidr_mask: typing.Union[int, float, None] = pydantic.Field(None, description='The number of leading 1 bits in the routing mask. The number of available IP addresses in each subnet of this group will be equal to ``2^(32 - cidrMask) - 2``. Valid values are ``16--28``. Default: - Available IP space is evenly divided across subnets.\n')
    map_public_ip_on_launch: typing.Optional[bool] = pydantic.Field(None, description='Controls if a public IP is associated to an instance at launch. Default: true in Subnet.Public, false in Subnet.Private or Subnet.Isolated.\n')
    reserved: typing.Optional[bool] = pydantic.Field(None, description='Controls if subnet IP space needs to be reserved. When true, the IP space for the subnet is reserved but no actual resources are provisioned. This space is only dependent on the number of availability zones and on ``cidrMask`` - all other subnet properties are ignored. Default: false\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    subnet_configuration = ec2.SubnetConfiguration(\n        name="name",\n        subnet_type=ec2.SubnetType.PRIVATE_ISOLATED,\n\n        # the properties below are optional\n        cidr_mask=123,\n        map_public_ip_on_launch=False,\n        reserved=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['name', 'subnet_type', 'cidr_mask', 'map_public_ip_on_launch', 'reserved']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.SubnetConfiguration'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.SubnetIpamOptions
class SubnetIpamOptionsDef(BaseStruct):
    allocated_subnets: typing.Sequence[typing.Union[models.aws_ec2.AllocatedSubnetDef, dict[str, typing.Any]]] = pydantic.Field(..., description='Cidr Allocations for Subnets.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    subnet_ipam_options = ec2.SubnetIpamOptions(\n        allocated_subnets=[ec2.AllocatedSubnet(\n            cidr="cidr"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allocated_subnets']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.SubnetIpamOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.SubnetNetworkAclAssociationProps
class SubnetNetworkAclAssociationPropsDef(BaseStruct):
    network_acl: typing.Union[models.aws_ec2.NetworkAclDef] = pydantic.Field(..., description='The Network ACL this association is defined for.\n')
    subnet: typing.Union[models.aws_ec2.PrivateSubnetDef, models.aws_ec2.PublicSubnetDef, models.aws_ec2.SubnetDef] = pydantic.Field(..., description='ID of the Subnet.\n')
    subnet_network_acl_association_name: typing.Optional[str] = pydantic.Field(None, description='The name of the SubnetNetworkAclAssociation. It is not recommended to use an explicit name. Default: If you don\'t specify a SubnetNetworkAclAssociationName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # network_acl: ec2.NetworkAcl\n    # subnet: ec2.Subnet\n\n    subnet_network_acl_association_props = ec2.SubnetNetworkAclAssociationProps(\n        network_acl=network_acl,\n        subnet=subnet,\n\n        # the properties below are optional\n        subnet_network_acl_association_name="subnetNetworkAclAssociationName"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['network_acl', 'subnet', 'subnet_network_acl_association_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.SubnetNetworkAclAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[SubnetNetworkAclAssociationPropsDefConfig] = pydantic.Field(None)


class SubnetNetworkAclAssociationPropsDefConfig(pydantic.BaseModel):
    network_acl_config: typing.Optional[models._interface_methods.AwsEc2INetworkAclDefConfig] = pydantic.Field(None)
    subnet_config: typing.Optional[models._interface_methods.AwsEc2ISubnetDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ec2.SubnetProps
class SubnetPropsDef(BaseStruct):
    availability_zone: str = pydantic.Field(..., description='The availability zone for the subnet.\n')
    cidr_block: str = pydantic.Field(..., description='The CIDR notation for this subnet.\n')
    vpc_id: str = pydantic.Field(..., description='The VPC which this subnet is part of.\n')
    map_public_ip_on_launch: typing.Optional[bool] = pydantic.Field(None, description='Controls if a public IP is associated to an instance at launch. Default: true in Subnet.Public, false in Subnet.Private or Subnet.Isolated.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    subnet_props = ec2.SubnetProps(\n        availability_zone="availabilityZone",\n        cidr_block="cidrBlock",\n        vpc_id="vpcId",\n\n        # the properties below are optional\n        map_public_ip_on_launch=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'cidr_block', 'vpc_id', 'map_public_ip_on_launch']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.SubnetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.SubnetSelection
class SubnetSelectionDef(BaseStruct):
    availability_zones: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Select subnets only in the given AZs. Default: no filtering on AZs is done\n')
    one_per_az: typing.Optional[bool] = pydantic.Field(None, description='If true, return at most one subnet per AZ. Default: false\n')
    subnet_filters: typing.Optional[typing.Sequence[models.aws_ec2.SubnetFilterDef]] = pydantic.Field(None, description='List of provided subnet filters. Default: - none\n')
    subnet_group_name: typing.Optional[str] = pydantic.Field(None, description='Select the subnet group with the given name. Select the subnet group with the given name. This only needs to be used if you have multiple subnet groups of the same type and you need to distinguish between them. Otherwise, prefer ``subnetType``. This field does not select individual subnets, it selects all subnets that share the given subnet group name. This is the name supplied in ``subnetConfiguration``. At most one of ``subnetType`` and ``subnetGroupName`` can be supplied. Default: - Selection by type instead of by name\n')
    subnets: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.PrivateSubnetDef, models.aws_ec2.PublicSubnetDef, models.aws_ec2.SubnetDef]]] = pydantic.Field(None, description="Explicitly select individual subnets. Use this if you don't want to automatically use all subnets in a group, but have a need to control selection down to individual subnets. Cannot be specified together with ``subnetType`` or ``subnetGroupName``. Default: - Use all subnets in a selected group (all private subnets by default)\n")
    subnet_type: typing.Optional[aws_cdk.aws_ec2.SubnetType] = pydantic.Field(None, description='Select all subnets of the given type. At most one of ``subnetType`` and ``subnetGroupName`` can be supplied. Default: SubnetType.PRIVATE_WITH_EGRESS (or ISOLATED or PUBLIC if there are no PRIVATE_WITH_EGRESS subnets)\n\n:exampleMetadata: infused\n\nExample::\n\n    # vpc: ec2.Vpc\n\n    cluster = docdb.DatabaseCluster(self, "Database",\n        master_user=docdb.Login(\n            username="myuser",  # NOTE: \'admin\' is reserved by DocumentDB\n            exclude_characters=""@/:",  # optional, defaults to the set ""@/" and is also used for eventually created rotations\n            secret_name="/myapp/mydocdb/masteruser"\n        ),\n        instance_type=ec2.InstanceType.of(ec2.InstanceClass.MEMORY5, ec2.InstanceSize.LARGE),\n        vpc_subnets=ec2.SubnetSelection(\n            subnet_type=ec2.SubnetType.PUBLIC\n        ),\n        vpc=vpc\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zones', 'one_per_az', 'subnet_filters', 'subnet_group_name', 'subnets', 'subnet_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.SubnetSelection'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.SystemdConfigFileOptions
class SystemdConfigFileOptionsDef(BaseStruct):
    command: str = pydantic.Field(..., description='The command to run to start this service.\n')
    after_network: typing.Optional[bool] = pydantic.Field(None, description='Start the service after the networking part of the OS comes up. Default: true\n')
    cwd: typing.Optional[str] = pydantic.Field(None, description='The working directory for the command. Default: Root directory or home directory of specified user\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description of this service. Default: - No description\n')
    group: typing.Optional[str] = pydantic.Field(None, description='The group to execute the process under. Default: root\n')
    keep_running: typing.Optional[bool] = pydantic.Field(None, description='Keep the process running all the time. Restarts the process when it exits for any reason other than the machine shutting down. Default: true\n')
    user: typing.Optional[str] = pydantic.Field(None, description='The user to execute the process under. Default: root\n\n:exampleMetadata: infused\n\nExample::\n\n    # vpc: ec2.Vpc\n    # instance_type: ec2.InstanceType\n\n\n    ec2.Instance(self, "Instance",\n        vpc=vpc,\n        instance_type=instance_type,\n        machine_image=ec2.MachineImage.latest_amazon_linux2022(),\n\n        init=ec2.CloudFormationInit.from_elements(\n            # Create a simple config file that runs a Python web server\n            ec2.InitService.systemd_config_file("simpleserver",\n                command="/usr/bin/python3 -m http.server 8080",\n                cwd="/var/www/html"\n            ),\n            # Start the server using SystemD\n            ec2.InitService.enable("simpleserver",\n                service_manager=ec2.ServiceManager.SYSTEMD\n            ),\n            # Drop an example file to show the web server working\n            ec2.InitFile.from_string("/var/www/html/index.html", "Hello! It\'s working!"))\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['command', 'after_network', 'cwd', 'description', 'group', 'keep_running', 'user']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.SystemdConfigFileOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.VolumeAttributes
class VolumeAttributesDef(BaseStruct):
    availability_zone: str = pydantic.Field(..., description='The availability zone that the EBS Volume is contained within (ex: us-west-2a).\n')
    volume_id: str = pydantic.Field(..., description="The EBS Volume's ID.\n")
    encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The customer-managed encryption key that is used to encrypt the Volume. Default: None -- The EBS Volume is not using a customer-managed KMS key for encryption.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n    from aws_cdk import aws_kms as kms\n\n    # key: kms.Key\n\n    volume_attributes = ec2.VolumeAttributes(\n        availability_zone="availabilityZone",\n        volume_id="volumeId",\n\n        # the properties below are optional\n        encryption_key=key\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'volume_id', 'encryption_key']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.VolumeAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.VolumeProps
class VolumePropsDef(BaseStruct):
    availability_zone: str = pydantic.Field(..., description='The Availability Zone in which to create the volume.\n')
    auto_enable_io: typing.Optional[bool] = pydantic.Field(None, description="Indicates whether the volume is auto-enabled for I/O operations. By default, Amazon EBS disables I/O to the volume from attached EC2 instances when it determines that a volume's data is potentially inconsistent. If the consistency of the volume is not a concern, and you prefer that the volume be made available immediately if it's impaired, you can configure the volume to automatically enable I/O. Default: false\n")
    enable_multi_attach: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether Amazon EBS Multi-Attach is enabled. See `Considerations and limitations <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volumes-multi.html#considerations>`_ for the constraints of multi-attach. Default: false\n')
    encrypted: typing.Optional[bool] = pydantic.Field(None, description='Specifies whether the volume should be encrypted. The effect of setting the encryption state to true depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Encryption by Default <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default>`_ in the Amazon Elastic Compute Cloud User Guide. Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see `Supported Instance Types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances>`_. Default: false\n')
    encryption_key: typing.Optional[typing.Union[models.aws_kms.KeyDef]] = pydantic.Field(None, description='The customer-managed encryption key that is used to encrypt the Volume. The encrypted property must be true if this is provided. Note: If using an ``aws-kms.IKey`` created from a ``aws-kms.Key.fromKeyArn()`` here, then the KMS key **must** have the following in its Key policy; otherwise, the Volume will fail to create:: { "Effect": "Allow", "Principal": { "AWS": "<arn for your account-user> ex: arn:aws:iam::00000000000:root" }, "Resource": "*", "Action": [ "kms:DescribeKey", "kms:GenerateDataKeyWithoutPlainText", ], "Condition": { "StringEquals": { "kms:ViaService": "ec2.<Region>.amazonaws.com", (eg: ec2.us-east-1.amazonaws.com) "kms:CallerAccount": "0000000000" (your account ID) } } } Default: The default KMS key for the account, region, and EC2 service is used.\n')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='The number of I/O operations per second (IOPS) to provision for the volume. The maximum ratio is 50 IOPS/GiB for PROVISIONED_IOPS_SSD, and 500 IOPS/GiB for both PROVISIONED_IOPS_SSD_IO2 and GENERAL_PURPOSE_SSD_GP3. See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html for more information. This parameter is valid only for PROVISIONED_IOPS_SSD, PROVISIONED_IOPS_SSD_IO2 and GENERAL_PURPOSE_SSD_GP3 volumes. Default: None -- Required for io1 and io2 volumes. The default for gp3 volumes is 3,000 IOPS if omitted.\n')
    removal_policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='Policy to apply when the volume is removed from the stack. Default: RemovalPolicy.RETAIN\n')
    size: typing.Optional[models.SizeDef] = pydantic.Field(None, description="The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html for details on the allowable size for each type of volume. Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.\n")
    snapshot_id: typing.Optional[str] = pydantic.Field(None, description='The snapshot from which to create the volume. You must specify either a snapshot ID or a volume size. Default: The EBS volume is not created from a snapshot.\n')
    throughput: typing.Union[int, float, None] = pydantic.Field(None, description='The throughput that the volume supports, in MiB/s Takes a minimum of 125 and maximum of 1000. Default: - 125 MiB/s. Only valid on gp3 volumes.\n')
    volume_name: typing.Optional[str] = pydantic.Field(None, description='The value of the physicalName property of this resource. Default: The physical name will be allocated by CloudFormation at deployment time\n')
    volume_type: typing.Optional[aws_cdk.aws_ec2.EbsDeviceVolumeType] = pydantic.Field(None, description='The type of the volume; what type of storage to use to form the EBS Volume. Default: ``EbsDeviceVolumeType.GENERAL_PURPOSE_SSD``\n\n:exampleMetadata: infused\n\nExample::\n\n    # instance: ec2.Instance\n    # role: iam.Role\n\n\n    volume = ec2.Volume(self, "Volume",\n        availability_zone="us-west-2a",\n        size=Size.gibibytes(500),\n        encrypted=True\n    )\n\n    volume.grant_attach_volume(role, [instance])\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'auto_enable_io', 'enable_multi_attach', 'encrypted', 'encryption_key', 'iops', 'removal_policy', 'size', 'snapshot_id', 'throughput', 'volume_name', 'volume_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.VolumeProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.VpcAttributes
class VpcAttributesDef(BaseStruct):
    availability_zones: typing.Sequence[str] = pydantic.Field(..., description='List of availability zones for the subnets in this VPC.\n')
    vpc_id: str = pydantic.Field(..., description="VPC's identifier.\n")
    isolated_subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of isolated subnet IDs. Must be undefined or match the availability zones in length and order. Default: - The VPC does not have any isolated subnets\n')
    isolated_subnet_ipv4_cidr_blocks: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of IPv4 CIDR blocks for the isolated subnets. Must be undefined or have an entry for every isolated subnet group. Default: - Retrieving the IPv4 CIDR block of any isolated subnet will fail\n')
    isolated_subnet_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of names for the isolated subnets. Must be undefined or have a name for every isolated subnet group. Default: - All isolated subnets will have the name ``Isolated``\n')
    isolated_subnet_route_table_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of IDs of route tables for the isolated subnets. Must be undefined or have a name for every isolated subnet group. Default: - Retrieving the route table ID of any isolated subnet will fail\n')
    private_subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of private subnet IDs. Must be undefined or match the availability zones in length and order. Default: - The VPC does not have any private subnets\n')
    private_subnet_ipv4_cidr_blocks: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of IPv4 CIDR blocks for the private subnets. Must be undefined or have an entry for every private subnet group. Default: - Retrieving the IPv4 CIDR block of any private subnet will fail\n')
    private_subnet_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of names for the private subnets. Must be undefined or have a name for every private subnet group. Default: - All private subnets will have the name ``Private``\n')
    private_subnet_route_table_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of IDs of route tables for the private subnets. Must be undefined or have a name for every private subnet group. Default: - Retrieving the route table ID of any private subnet will fail\n')
    public_subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of public subnet IDs. Must be undefined or match the availability zones in length and order. Default: - The VPC does not have any public subnets\n')
    public_subnet_ipv4_cidr_blocks: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of IPv4 CIDR blocks for the public subnets. Must be undefined or have an entry for every public subnet group. Default: - Retrieving the IPv4 CIDR block of any public subnet will fail\n')
    public_subnet_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of names for the public subnets. Must be undefined or have a name for every public subnet group. Default: - All public subnets will have the name ``Public``\n')
    public_subnet_route_table_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='List of IDs of route tables for the public subnets. Must be undefined or have a name for every public subnet group. Default: - Retrieving the route table ID of any public subnet will fail\n')
    region: typing.Optional[str] = pydantic.Field(None, description='The region the VPC is in. Default: - The region of the stack where the VPC belongs to\n')
    vpc_cidr_block: typing.Optional[str] = pydantic.Field(None, description="VPC's CIDR range. Default: - Retrieving the CIDR from the VPC will fail\n")
    vpn_gateway_id: typing.Optional[str] = pydantic.Field(None, description='VPN gateway\'s identifier.\n\n:exampleMetadata: infused\n\nExample::\n\n    vpc = ec2.Vpc.from_vpc_attributes(self, "VPC",\n        vpc_id="vpc-1234",\n        availability_zones=["us-east-1a", "us-east-1b"],\n\n        # Either pass literals for all IDs\n        public_subnet_ids=["s-12345", "s-67890"],\n\n        # OR: import a list of known length\n        private_subnet_ids=Fn.import_list_value("PrivateSubnetIds", 2),\n\n        # OR: split an imported string to a list of known length\n        isolated_subnet_ids=Fn.split(",", ssm.StringParameter.value_for_string_parameter(self, "MyParameter"), 2)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zones', 'vpc_id', 'isolated_subnet_ids', 'isolated_subnet_ipv4_cidr_blocks', 'isolated_subnet_names', 'isolated_subnet_route_table_ids', 'private_subnet_ids', 'private_subnet_ipv4_cidr_blocks', 'private_subnet_names', 'private_subnet_route_table_ids', 'public_subnet_ids', 'public_subnet_ipv4_cidr_blocks', 'public_subnet_names', 'public_subnet_route_table_ids', 'region', 'vpc_cidr_block', 'vpn_gateway_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.VpcAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.VpcEndpointServiceProps
class VpcEndpointServicePropsDef(BaseStruct):
    vpc_endpoint_service_load_balancers: typing.Sequence[models.UnsupportedResource] = pydantic.Field(..., description='One or more load balancers to host the VPC Endpoint Service.\n')
    acceptance_required: typing.Optional[bool] = pydantic.Field(None, description='Whether requests from service consumers to connect to the service through an endpoint must be accepted. Default: true\n')
    allowed_principals: typing.Optional[typing.Sequence[models.aws_iam.ArnPrincipalDef]] = pydantic.Field(None, description='IAM users, IAM roles, or AWS accounts to allow inbound connections from. These principals can connect to your service using VPC endpoints. Takes a list of one or more ArnPrincipal. Default: - no principals\n\n:exampleMetadata: infused\n\nExample::\n\n    # network_load_balancer1: elbv2.NetworkLoadBalancer\n    # network_load_balancer2: elbv2.NetworkLoadBalancer\n\n\n    ec2.VpcEndpointService(self, "EndpointService",\n        vpc_endpoint_service_load_balancers=[network_load_balancer1, network_load_balancer2],\n        acceptance_required=True,\n        allowed_principals=[iam.ArnPrincipal("arn:aws:iam::123456789012:root")]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['vpc_endpoint_service_load_balancers', 'acceptance_required', 'allowed_principals']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.VpcEndpointServiceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.VpcIpamOptions
class VpcIpamOptionsDef(BaseStruct):
    cidr_block: typing.Optional[str] = pydantic.Field(None, description='Cidr Block for Vpc. Default: - Only required when Ipam has concrete allocation available for static Vpc\n')
    ipv4_ipam_pool_id: typing.Optional[str] = pydantic.Field(None, description='ipv4 IPAM Pool Id. Default: - Only required when using AWS Ipam\n')
    ipv4_netmask_length: typing.Union[int, float, None] = pydantic.Field(None, description='Cidr Mask for Vpc. Default: - Only required when using AWS Ipam\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    vpc_ipam_options = ec2.VpcIpamOptions(\n        cidr_block="cidrBlock",\n        ipv4_ipam_pool_id="ipv4IpamPoolId",\n        ipv4_netmask_length=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cidr_block', 'ipv4_ipam_pool_id', 'ipv4_netmask_length']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.VpcIpamOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.VpcLookupOptions
class VpcLookupOptionsDef(BaseStruct):
    is_default: typing.Optional[bool] = pydantic.Field(None, description="Whether to match the default VPC. Default: Don't care whether we return the default VPC\n")
    owner_account_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the AWS account that owns the VPC. Default: the account id of the parent stack\n')
    region: typing.Optional[str] = pydantic.Field(None, description="Optional to override inferred region. Default: Current stack's environment region\n")
    return_vpn_gateways: typing.Optional[bool] = pydantic.Field(None, description='Whether to look up whether a VPN Gateway is attached to the looked up VPC. You can set this to ``false`` if you know the VPC does not have a VPN Gateway attached, in order to avoid an API call. If you change this property from ``false`` to ``true`` or undefined, you may need to clear the corresponding context entry in ``cdk.context.json`` in order to trigger a new lookup. Default: true\n')
    subnet_group_name_tag: typing.Optional[str] = pydantic.Field(None, description="Optional tag for subnet group name. If not provided, we'll look at the aws-cdk:subnet-name tag. If the subnet does not have the specified tag, we'll use its type as the name. Default: aws-cdk:subnet-name\n")
    tags: typing.Optional[typing.Mapping[str, str]] = pydantic.Field(None, description="Tags on the VPC. The VPC must have all of these tags Default: Don't filter on tags\n")
    vpc_id: typing.Optional[str] = pydantic.Field(None, description="The ID of the VPC. If given, will import exactly this VPC. Default: Don't filter on vpcId\n")
    vpc_name: typing.Optional[str] = pydantic.Field(None, description='The name of the VPC. If given, will import the VPC with this name. Default: Don\'t filter on vpcName\n\n:exampleMetadata: infused\n\nExample::\n\n    # create a cloud9 ec2 environment in a new VPC\n    vpc = ec2.Vpc(self, "VPC", max_azs=3)\n    cloud9.Ec2Environment(self, "Cloud9Env", vpc=vpc, image_id=cloud9.ImageId.AMAZON_LINUX_2)\n\n    # or create the cloud9 environment in the default VPC with specific instanceType\n    default_vpc = ec2.Vpc.from_lookup(self, "DefaultVPC", is_default=True)\n    cloud9.Ec2Environment(self, "Cloud9Env2",\n        vpc=default_vpc,\n        instance_type=ec2.InstanceType("t3.large"),\n        image_id=cloud9.ImageId.AMAZON_LINUX_2\n    )\n\n    # or specify in a different subnetSelection\n    c9env = cloud9.Ec2Environment(self, "Cloud9Env3",\n        vpc=vpc,\n        subnet_selection=ec2.SubnetSelection(\n            subnet_type=ec2.SubnetType.PRIVATE_WITH_EGRESS\n        ),\n        image_id=cloud9.ImageId.AMAZON_LINUX_2\n    )\n\n    # print the Cloud9 IDE URL in the output\n    CfnOutput(self, "URL", value=c9env.ide_url)\n')
    _init_params: typing.ClassVar[list[str]] = ['is_default', 'owner_account_id', 'region', 'return_vpn_gateways', 'subnet_group_name_tag', 'tags', 'vpc_id', 'vpc_name']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.VpcLookupOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.VpcProps
class VpcPropsDef(BaseStruct):
    availability_zones: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Availability zones this VPC spans. Specify this option only if you do not specify ``maxAzs``. Default: - a subset of AZs of the stack\n')
    cidr: typing.Optional[str] = pydantic.Field(None, description="(deprecated) The CIDR range to use for the VPC, e.g. '10.0.0.0/16'. Should be a minimum of /28 and maximum size of /16. The range will be split across all subnets per Availability Zone. Default: Vpc.DEFAULT_CIDR_RANGE\n")
    default_instance_tenancy: typing.Optional[aws_cdk.aws_ec2.DefaultInstanceTenancy] = pydantic.Field(None, description='The default tenancy of instances launched into the VPC. By setting this to dedicated tenancy, instances will be launched on hardware dedicated to a single AWS customer, unless specifically specified at instance launch time. Please note, not all instance types are usable with Dedicated tenancy. Default: DefaultInstanceTenancy.Default (shared) tenancy\n')
    enable_dns_hostnames: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the instances launched in the VPC get public DNS hostnames. If this attribute is true, instances in the VPC get public DNS hostnames, but only if the enableDnsSupport attribute is also set to true. Default: true\n')
    enable_dns_support: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether the DNS resolution is supported for the VPC. If this attribute is false, the Amazon-provided DNS server in the VPC that resolves public DNS hostnames to IP addresses is not enabled. If this attribute is true, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC IPv4 network range plus two will succeed. Default: true\n')
    flow_logs: typing.Optional[typing.Mapping[str, typing.Union[models.aws_ec2.FlowLogOptionsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Flow logs to add to this VPC. Default: - No flow logs.\n')
    gateway_endpoints: typing.Optional[typing.Mapping[str, typing.Union[models.aws_ec2.GatewayVpcEndpointOptionsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Gateway endpoints to add to this VPC. Default: - None.\n')
    ip_addresses: typing.Optional[models.UnsupportedResource] = pydantic.Field(None, description='The Provider to use to allocate IP Space to your VPC. Options include static allocation or from a pool. Default: ec2.IpAddresses.cidr\n')
    max_azs: typing.Union[int, float, None] = pydantic.Field(None, description='Define the maximum number of AZs to use in this region. If the region has more AZs than you want to use (for example, because of EIP limits), pick a lower number here. The AZs will be sorted and picked from the start of the list. If you pick a higher number than the number of AZs in the region, all AZs in the region will be selected. To use "all AZs" available to your account, use a high number (such as 99). Be aware that environment-agnostic stacks will be created with access to only 2 AZs, so to use more than 2 AZs, be sure to specify the account and region on your stack. Specify this option only if you do not specify ``availabilityZones``. Default: 3\n')
    nat_gateway_provider: typing.Optional[models.aws_ec2.NatProviderDef] = pydantic.Field(None, description='What type of NAT provider to use. Select between NAT gateways or NAT instances. NAT gateways may not be available in all AWS regions. Default: NatProvider.gateway()\n')
    nat_gateways: typing.Union[int, float, None] = pydantic.Field(None, description='The number of NAT Gateways/Instances to create. The type of NAT gateway or instance will be determined by the ``natGatewayProvider`` parameter. You can set this number lower than the number of Availability Zones in your VPC in order to save on NAT cost. Be aware you may be charged for cross-AZ data traffic instead. Default: - One NAT gateway/instance per Availability Zone\n')
    nat_gateway_subnets: typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Configures the subnets which will have NAT Gateways/Instances. You can pick a specific group of subnets by specifying the group name; the picked subnets must be public subnets. Only necessary if you have more than one public subnet group. Default: - All public subnets.\n')
    reserved_azs: typing.Union[int, float, None] = pydantic.Field(None, description='Define the number of AZs to reserve. When specified, the IP space is reserved for the azs but no actual resources are provisioned. Default: 0\n')
    restrict_default_security_group: typing.Optional[bool] = pydantic.Field(None, description="If set to true then the default inbound & outbound rules will be removed from the default security group. Default: true if '@aws-cdk/aws-ec2:restrictDefaultSecurityGroup' is enabled, false otherwise\n")
    subnet_configuration: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SubnetConfigurationDef, dict[str, typing.Any]]]] = pydantic.Field(None, description="Configure the subnets to build for each AZ. Each entry in this list configures a Subnet Group; each group will contain a subnet for each Availability Zone. For example, if you want 1 public subnet, 1 private subnet, and 1 isolated subnet in each AZ provide the following:: new ec2.Vpc(this, 'VPC', { subnetConfiguration: [ { cidrMask: 24, name: 'ingress', subnetType: ec2.SubnetType.PUBLIC, }, { cidrMask: 24, name: 'application', subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS, }, { cidrMask: 28, name: 'rds', subnetType: ec2.SubnetType.PRIVATE_ISOLATED, } ] }); Default: - The VPC CIDR will be evenly divided between 1 public and 1 private subnet per AZ.\n")
    vpc_name: typing.Optional[str] = pydantic.Field(None, description="The VPC name. Since the VPC resource doesn't support providing a physical name, the value provided here will be recorded in the ``Name`` tag Default: this.node.path\n")
    vpn_connections: typing.Optional[typing.Mapping[str, typing.Union[models.aws_ec2.VpnConnectionOptionsDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='VPN connections to this VPC. Default: - No connections.\n')
    vpn_gateway: typing.Optional[bool] = pydantic.Field(None, description='Indicates whether a VPN gateway should be created and attached to this VPC. Default: - true when vpnGatewayAsn or vpnConnections is specified\n')
    vpn_gateway_asn: typing.Union[int, float, None] = pydantic.Field(None, description='The private Autonomous System Number (ASN) for the VPN gateway. Default: - Amazon default ASN.\n')
    vpn_route_propagation: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.SubnetSelectionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Where to propagate VPN routes. Default: - On the route tables associated with private subnets. If no private subnets exists, isolated subnets are used. If no isolated subnets exists, public subnets are used.\n\n:exampleMetadata: infused\n\nExample::\n\n    import aws_cdk.aws_ec2 as ec2\n\n\n    vpc = ec2.Vpc(self, "Vpc",\n        ip_addresses=ec2.IpAddresses.cidr("10.0.0.0/16")\n    )\n\n    vpc_connector = apprunner.VpcConnector(self, "VpcConnector",\n        vpc=vpc,\n        vpc_subnets=vpc.select_subnets(subnet_type=ec2.SubnetType.PUBLIC),\n        vpc_connector_name="MyVpcConnector"\n    )\n\n    apprunner.Service(self, "Service",\n        source=apprunner.Source.from_ecr_public(\n            image_configuration=apprunner.ImageConfiguration(port=8000),\n            image_identifier="public.ecr.aws/aws-containers/hello-app-runner:latest"\n        ),\n        vpc_connector=vpc_connector\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zones', 'cidr', 'default_instance_tenancy', 'enable_dns_hostnames', 'enable_dns_support', 'flow_logs', 'gateway_endpoints', 'ip_addresses', 'max_azs', 'nat_gateway_provider', 'nat_gateways', 'nat_gateway_subnets', 'reserved_azs', 'restrict_default_security_group', 'subnet_configuration', 'vpc_name', 'vpn_connections', 'vpn_gateway', 'vpn_gateway_asn', 'vpn_route_propagation']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.VpcProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.VpnConnectionAttributes
class VpnConnectionAttributesDef(BaseStruct):
    customer_gateway_asn: typing.Union[int, float] = pydantic.Field(..., description='The ASN of the customer gateway.\n')
    customer_gateway_id: str = pydantic.Field(..., description='The id of the customer gateway.\n')
    customer_gateway_ip: str = pydantic.Field(..., description='The ip address of the customer gateway.\n')
    vpn_id: str = pydantic.Field(..., description='The id of the VPN connection.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    vpn_connection_attributes = ec2.VpnConnectionAttributes(\n        customer_gateway_asn=123,\n        customer_gateway_id="customerGatewayId",\n        customer_gateway_ip="customerGatewayIp",\n        vpn_id="vpnId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['customer_gateway_asn', 'customer_gateway_id', 'customer_gateway_ip', 'vpn_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.VpnConnectionAttributes'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.VpnConnectionOptions
class VpnConnectionOptionsDef(BaseStruct):
    ip: str = pydantic.Field(..., description='The ip address of the customer gateway.')
    asn: typing.Union[int, float, None] = pydantic.Field(None, description='The ASN of the customer gateway. Default: 65000\n')
    static_routes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The static routes to be routed from the VPN gateway to the customer gateway. Default: Dynamic routing (BGP)\n')
    tunnel_options: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.VpnTunnelOptionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tunnel options for the VPN connection. At most two elements (one per tunnel). Duplicates not allowed. Default: Amazon generated tunnel options\n\n:exampleMetadata: infused\n\nExample::\n\n    vpc = ec2.Vpc(self, "MyVpc",\n        vpn_connections={\n            "dynamic": ec2.VpnConnectionOptions( # Dynamic routing (BGP)\n                ip="1.2.3.4"),\n            "static": ec2.VpnConnectionOptions( # Static routing\n                ip="4.5.6.7",\n                static_routes=["192.168.10.0/24", "192.168.20.0/24"\n                ])\n        }\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ip', 'asn', 'static_routes', 'tunnel_options']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.VpnConnectionOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.VpnConnectionProps
class VpnConnectionPropsDef(BaseStruct):
    ip: str = pydantic.Field(..., description='The ip address of the customer gateway.')
    asn: typing.Union[int, float, None] = pydantic.Field(None, description='The ASN of the customer gateway. Default: 65000\n')
    static_routes: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The static routes to be routed from the VPN gateway to the customer gateway. Default: Dynamic routing (BGP)\n')
    tunnel_options: typing.Optional[typing.Sequence[typing.Union[models.aws_ec2.VpnTunnelOptionDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tunnel options for the VPN connection. At most two elements (one per tunnel). Duplicates not allowed. Default: Amazon generated tunnel options\n')
    vpc: typing.Union[models.aws_ec2.VpcDef] = pydantic.Field(..., description='The VPC to connect to.\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_ec2 as ec2\n\n    # secret_value: cdk.SecretValue\n    # vpc: ec2.Vpc\n\n    vpn_connection_props = ec2.VpnConnectionProps(\n        ip="ip",\n        vpc=vpc,\n\n        # the properties below are optional\n        asn=123,\n        static_routes=["staticRoutes"],\n        tunnel_options=[ec2.VpnTunnelOption(\n            pre_shared_key="preSharedKey",\n            pre_shared_key_secret=secret_value,\n            tunnel_inside_cidr="tunnelInsideCidr"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ip', 'asn', 'static_routes', 'tunnel_options', 'vpc']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.VpnConnectionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[VpnConnectionPropsDefConfig] = pydantic.Field(None)


class VpnConnectionPropsDefConfig(pydantic.BaseModel):
    vpc_config: typing.Optional[models._interface_methods.AwsEc2IVpcDefConfig] = pydantic.Field(None)


#  autogenerated from aws_cdk.aws_ec2.VpnGatewayProps
class VpnGatewayPropsDef(BaseStruct):
    type: str = pydantic.Field(..., description='Default type ipsec.1.\n')
    amazon_side_asn: typing.Union[int, float, None] = pydantic.Field(None, description='Explicitly specify an Asn or let aws pick an Asn for you. Default: 65000\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    vpn_gateway_props = ec2.VpnGatewayProps(\n        type="type",\n\n        # the properties below are optional\n        amazon_side_asn=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'amazon_side_asn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.VpnGatewayProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.VpnTunnelOption
class VpnTunnelOptionDef(BaseStruct):
    pre_shared_key: typing.Optional[str] = pydantic.Field(None, description='(deprecated) The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway. Allowed characters are alphanumeric characters period ``.`` and underscores ``_``. Must be between 8 and 64 characters in length and cannot start with zero (0). Default: an Amazon generated pre-shared key')
    pre_shared_key_secret: typing.Optional[models.SecretValueDef] = pydantic.Field(None, description='The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway. Allowed characters are alphanumeric characters period ``.`` and underscores ``_``. Must be between 8 and 64 characters in length and cannot start with zero (0). Default: an Amazon generated pre-shared key\n')
    tunnel_inside_cidr: typing.Optional[str] = pydantic.Field(None, description='The range of inside IP addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway. A size /30 CIDR block from the 169.254.0.0/16 range. Default: an Amazon generated inside IP CIDR\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    import aws_cdk as cdk\n    from aws_cdk import aws_ec2 as ec2\n\n    # secret_value: cdk.SecretValue\n\n    vpn_tunnel_option = ec2.VpnTunnelOption(\n        pre_shared_key="preSharedKey",\n        pre_shared_key_secret=secret_value,\n        tunnel_inside_cidr="tunnelInsideCidr"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['pre_shared_key', 'pre_shared_key_secret', 'tunnel_inside_cidr']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.VpnTunnelOption'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.WindowsImageProps
class WindowsImagePropsDef(BaseStruct):
    user_data: typing.Optional[models.aws_ec2.UserDataDef] = pydantic.Field(None, description='Initial user data. Default: - Empty UserData for Windows machines\n\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # user_data: ec2.UserData\n\n    windows_image_props = ec2.WindowsImageProps(\n        user_data=user_data\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['user_data']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.WindowsImageProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.WindowsUserDataOptions
class WindowsUserDataOptionsDef(BaseStruct):
    persist: typing.Optional[bool] = pydantic.Field(None, description='Set to true to set this userdata to persist through an instance reboot; allowing it to run on every instance start. By default, UserData is run only once during the first instance launch. For more information, see: https://aws.amazon.com/premiumsupport/knowledge-center/execute-user-data-ec2/ https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html#user-data-scripts Default: false\n\n:exampleMetadata: infused\n\nExample::\n\n    windows_user_data = ec2.UserData.for_windows(persist=True)\n')
    _init_params: typing.ClassVar[list[str]] = ['persist']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.WindowsUserDataOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.Action
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.AddressFamily
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.AmazonLinuxCpuType
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.AmazonLinuxEdition
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.AmazonLinuxGeneration
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.AmazonLinuxKernel
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.AmazonLinuxStorage
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.AmazonLinuxVirt
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.ClientVpnSessionTimeout
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.CpuCredits
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.DefaultInstanceTenancy
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.EbsDeviceVolumeType
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.FlowLogDestinationType
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.FlowLogFileFormat
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.FlowLogMaxAggregationInterval
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.FlowLogTrafficType
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.InstanceArchitecture
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.InstanceClass
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.InstanceInitiatedShutdownBehavior
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.InstanceSize
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.LaunchTemplateHttpTokens
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.NatTrafficDirection
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.OperatingSystemType
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.PlacementGroupSpreadLevel
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.PlacementGroupStrategy
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.Protocol
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.RouterType
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.ServiceManager
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.SpotInstanceInterruption
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.SpotRequestType
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.SubnetType
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.TrafficDirection
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.TransportProtocol
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.VpcEndpointType
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.VpnConnectionType
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.VpnPort
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.WindowsVersion
# skipping emum

#  autogenerated from aws_cdk.aws_ec2.IClientVpnConnectionHandler
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IClientVpnEndpoint
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IConnectable
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IFlowLog
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IGatewayVpcEndpoint
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IGatewayVpcEndpointService
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IInstance
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IInterfaceVpcEndpoint
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IInterfaceVpcEndpointService
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IIpAddresses
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.ILaunchTemplate
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IMachineImage
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.INetworkAcl
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.INetworkAclEntry
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IPeer
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IPlacementGroup
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IPrefixList
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IPrivateSubnet
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IPublicSubnet
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IRouteTable
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.ISecurityGroup
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.ISubnet
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.ISubnetNetworkAclAssociation
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IVolume
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IVpc
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IVpcEndpoint
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IVpcEndpointService
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IVpcEndpointServiceLoadBalancer
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IVpnConnection
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.IVpnGateway
#  skipping Interface

#  autogenerated from aws_cdk.aws_ec2.CfnCapacityReservation
class CfnCapacityReservationDef(BaseCfnResource):
    availability_zone: str = pydantic.Field(..., description='The Availability Zone in which to create the Capacity Reservation.\n')
    instance_count: typing.Union[int, float] = pydantic.Field(..., description='The number of instances for which to reserve capacity. Valid range: 1 - 1000\n')
    instance_platform: str = pydantic.Field(..., description='The type of operating system for which to reserve capacity.\n')
    instance_type: str = pydantic.Field(..., description='The instance type for which to reserve capacity. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* .\n')
    ebs_optimized: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Indicates whether the Capacity Reservation supports EBS-optimized instances. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS- optimized instance.\n")
    end_date: typing.Optional[str] = pydantic.Field(None, description="The date and time at which the Capacity Reservation expires. When a Capacity Reservation expires, the reserved capacity is released and you can no longer launch instances into it. The Capacity Reservation's state changes to ``expired`` when it reaches its end date and time. You must provide an ``EndDate`` value if ``EndDateType`` is ``limited`` . Omit ``EndDate`` if ``EndDateType`` is ``unlimited`` . If the ``EndDateType`` is ``limited`` , the Capacity Reservation is cancelled within an hour from the specified time. For example, if you specify 5/31/2019, 13:30:55, the Capacity Reservation is guaranteed to end between 13:30:55 and 14:30:55 on 5/31/2019.\n")
    end_date_type: typing.Optional[str] = pydantic.Field(None, description='Indicates the way in which the Capacity Reservation ends. A Capacity Reservation can have one of the following end types: - ``unlimited`` - The Capacity Reservation remains active until you explicitly cancel it. Do not provide an ``EndDate`` if the ``EndDateType`` is ``unlimited`` . - ``limited`` - The Capacity Reservation expires automatically at a specified date and time. You must provide an ``EndDate`` value if the ``EndDateType`` value is ``limited`` .\n')
    ephemeral_storage: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='*Deprecated.*.\n')
    instance_match_criteria: typing.Optional[str] = pydantic.Field(None, description='Indicates the type of instance launches that the Capacity Reservation accepts. The options include:. - ``open`` - The Capacity Reservation automatically matches all instances that have matching attributes (instance type, platform, and Availability Zone). Instances that have matching attributes run in the Capacity Reservation automatically without specifying any additional parameters. - ``targeted`` - The Capacity Reservation only accepts instances that have matching attributes (instance type, platform, and Availability Zone), and explicitly target the Capacity Reservation. This ensures that only permitted instances can use the reserved capacity. Default: ``open``\n')
    out_post_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the Outpost on which to create the Capacity Reservation.\n')
    placement_group_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the cluster placement group in which to create the Capacity Reservation. For more information, see `Capacity Reservations for cluster placement groups <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cr-cpg.html>`_ in the *Amazon EC2 User Guide* .\n')
    tag_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnCapacityReservation_TagSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The tags to apply to the Capacity Reservation during launch.\n')
    tenancy: typing.Optional[str] = pydantic.Field(None, description='Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the following tenancy settings:. - ``default`` - The Capacity Reservation is created on hardware that is shared with other AWS accounts . - ``dedicated`` - The Capacity Reservation is created on single-tenant hardware that is dedicated to a single AWS account .')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'instance_count', 'instance_platform', 'instance_type', 'ebs_optimized', 'end_date', 'end_date_type', 'ephemeral_storage', 'instance_match_criteria', 'out_post_arn', 'placement_group_arn', 'tag_specifications', 'tenancy']
    _method_names: typing.ClassVar[list[str]] = ['TagSpecificationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnCapacityReservation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnCapacityReservationDefConfig] = pydantic.Field(None)


class CfnCapacityReservationDefConfig(pydantic.BaseModel):
    TagSpecificationProperty: typing.Optional[list[CfnCapacityReservationDefTagspecificationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnCapacityReservationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnCapacityReservationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnCapacityReservationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnCapacityReservationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnCapacityReservationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnCapacityReservationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnCapacityReservationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnCapacityReservationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnCapacityReservationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnCapacityReservationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnCapacityReservationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnCapacityReservationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnCapacityReservationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnCapacityReservationDefTagspecificationpropertyParams(pydantic.BaseModel):
    resource_type: typing.Optional[str] = pydantic.Field(None, description='')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='')
    ...

class CfnCapacityReservationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnCapacityReservationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCapacityReservationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnCapacityReservationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCapacityReservationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnCapacityReservationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnCapacityReservationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnCapacityReservationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnCapacityReservationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnCapacityReservationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCapacityReservationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnCapacityReservationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnCapacityReservationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCapacityReservationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnCapacityReservationFleet
class CfnCapacityReservationFleetDef(BaseCfnResource):
    allocation_strategy: typing.Optional[str] = pydantic.Field(None, description='The strategy used by the Capacity Reservation Fleet to determine which of the specified instance types to use. Currently, only the ``prioritized`` allocation strategy is supported. For more information, see `Allocation strategy <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#allocation-strategy>`_ in the Amazon EC2 User Guide. Valid values: ``prioritized``\n')
    end_date: typing.Optional[str] = pydantic.Field(None, description='The date and time at which the Capacity Reservation Fleet expires. When the Capacity Reservation Fleet expires, its state changes to ``expired`` and all of the Capacity Reservations in the Fleet expire. The Capacity Reservation Fleet expires within an hour after the specified time. For example, if you specify ``5/31/2019`` , ``13:30:55`` , the Capacity Reservation Fleet is guaranteed to expire between ``13:30:55`` and ``14:30:55`` on ``5/31/2019`` .\n')
    instance_match_criteria: typing.Optional[str] = pydantic.Field(None, description='Indicates the type of instance launches that the Capacity Reservation Fleet accepts. All Capacity Reservations in the Fleet inherit this instance matching criteria. Currently, Capacity Reservation Fleets support ``open`` instance matching criteria only. This means that instances that have matching attributes (instance type, platform, and Availability Zone) run in the Capacity Reservations automatically. Instances do not need to explicitly target a Capacity Reservation Fleet to use its reserved capacity.\n')
    instance_type_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnCapacityReservationFleet_InstanceTypeSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Information about the instance types for which to reserve the capacity.\n')
    no_remove_end_date: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Used to add an end date to a Capacity Reservation Fleet that has no end date and time. To add an end date to a Capacity Reservation Fleet, specify ``true`` for this paramater and specify the end date and time (in UTC time format) for the *EndDate* parameter.\n')
    remove_end_date: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Used to remove an end date from a Capacity Reservation Fleet that is configured to end automatically at a specific date and time. To remove the end date from a Capacity Reservation Fleet, specify ``true`` for this paramater and omit the *EndDate* parameter.\n')
    tag_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnCapacityReservationFleet_TagSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The tags to assign to the Capacity Reservation Fleet. The tags are automatically assigned to the Capacity Reservations in the Fleet.\n')
    tenancy: typing.Optional[str] = pydantic.Field(None, description='Indicates the tenancy of the Capacity Reservation Fleet. All Capacity Reservations in the Fleet inherit this tenancy. The Capacity Reservation Fleet can have one of the following tenancy settings: - ``default`` - The Capacity Reservation Fleet is created on hardware that is shared with other AWS accounts . - ``dedicated`` - The Capacity Reservations are created on single-tenant hardware that is dedicated to a single AWS account .\n')
    total_target_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='The total number of capacity units to be reserved by the Capacity Reservation Fleet. This value, together with the instance type weights that you assign to each instance type used by the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see `Total target capacity <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity>`_ in the Amazon EC2 User Guide.')
    _init_params: typing.ClassVar[list[str]] = ['allocation_strategy', 'end_date', 'instance_match_criteria', 'instance_type_specifications', 'no_remove_end_date', 'remove_end_date', 'tag_specifications', 'tenancy', 'total_target_capacity']
    _method_names: typing.ClassVar[list[str]] = ['InstanceTypeSpecificationProperty', 'TagSpecificationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnCapacityReservationFleet'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnCapacityReservationFleetDefConfig] = pydantic.Field(None)


class CfnCapacityReservationFleetDefConfig(pydantic.BaseModel):
    InstanceTypeSpecificationProperty: typing.Optional[list[CfnCapacityReservationFleetDefInstancetypespecificationpropertyParams]] = pydantic.Field(None, description='')
    TagSpecificationProperty: typing.Optional[list[CfnCapacityReservationFleetDefTagspecificationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnCapacityReservationFleetDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnCapacityReservationFleetDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnCapacityReservationFleetDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnCapacityReservationFleetDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnCapacityReservationFleetDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnCapacityReservationFleetDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnCapacityReservationFleetDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnCapacityReservationFleetDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnCapacityReservationFleetDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnCapacityReservationFleetDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnCapacityReservationFleetDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnCapacityReservationFleetDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnCapacityReservationFleetDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnCapacityReservationFleetDefInstancetypespecificationpropertyParams(pydantic.BaseModel):
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='')
    availability_zone_id: typing.Optional[str] = pydantic.Field(None, description='')
    ebs_optimized: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    instance_platform: typing.Optional[str] = pydantic.Field(None, description='')
    instance_type: typing.Optional[str] = pydantic.Field(None, description='')
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='')
    weight: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnCapacityReservationFleetDefTagspecificationpropertyParams(pydantic.BaseModel):
    resource_type: typing.Optional[str] = pydantic.Field(None, description='')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='')
    ...

class CfnCapacityReservationFleetDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnCapacityReservationFleetDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCapacityReservationFleetDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnCapacityReservationFleetDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCapacityReservationFleetDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnCapacityReservationFleetDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnCapacityReservationFleetDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnCapacityReservationFleetDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnCapacityReservationFleetDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnCapacityReservationFleetDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCapacityReservationFleetDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnCapacityReservationFleetDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnCapacityReservationFleetDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCapacityReservationFleetDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnCarrierGateway
class CfnCarrierGatewayDef(BaseCfnResource):
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC associated with the carrier gateway.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags assigned to the carrier gateway.')
    _init_params: typing.ClassVar[list[str]] = ['vpc_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnCarrierGateway'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnCarrierGatewayDefConfig] = pydantic.Field(None)


class CfnCarrierGatewayDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnCarrierGatewayDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnCarrierGatewayDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnCarrierGatewayDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnCarrierGatewayDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnCarrierGatewayDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnCarrierGatewayDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnCarrierGatewayDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnCarrierGatewayDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnCarrierGatewayDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnCarrierGatewayDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnCarrierGatewayDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnCarrierGatewayDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnCarrierGatewayDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnCarrierGatewayDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnCarrierGatewayDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCarrierGatewayDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnCarrierGatewayDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCarrierGatewayDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnCarrierGatewayDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnCarrierGatewayDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnCarrierGatewayDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnCarrierGatewayDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnCarrierGatewayDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCarrierGatewayDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnCarrierGatewayDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnCarrierGatewayDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCarrierGatewayDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnClientVpnAuthorizationRule
class CfnClientVpnAuthorizationRuleDef(BaseCfnResource):
    client_vpn_endpoint_id: str = pydantic.Field(..., description='The ID of the Client VPN endpoint.\n')
    target_network_cidr: str = pydantic.Field(..., description='The IPv4 address range, in CIDR notation, of the network for which access is being authorized.\n')
    access_group_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group. Required if ``AuthorizeAllGroups`` is ``false`` or not specified.\n')
    authorize_all_groups: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to grant access to all clients. Specify ``true`` to grant all clients who successfully establish a VPN connection access to the network. Must be set to ``true`` if ``AccessGroupId`` is not specified.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A brief description of the authorization rule.')
    _init_params: typing.ClassVar[list[str]] = ['client_vpn_endpoint_id', 'target_network_cidr', 'access_group_id', 'authorize_all_groups', 'description']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnClientVpnAuthorizationRule'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnClientVpnAuthorizationRuleDefConfig] = pydantic.Field(None)


class CfnClientVpnAuthorizationRuleDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnClientVpnAuthorizationRuleDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnClientVpnAuthorizationRuleDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnClientVpnAuthorizationRuleDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnClientVpnAuthorizationRuleDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnClientVpnAuthorizationRuleDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnClientVpnAuthorizationRuleDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnClientVpnAuthorizationRuleDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnClientVpnAuthorizationRuleDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnClientVpnAuthorizationRuleDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnClientVpnAuthorizationRuleDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnClientVpnAuthorizationRuleDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnClientVpnAuthorizationRuleDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnClientVpnAuthorizationRuleDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnClientVpnAuthorizationRuleDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnClientVpnAuthorizationRuleDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnClientVpnAuthorizationRuleDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnClientVpnAuthorizationRuleDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnClientVpnAuthorizationRuleDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnClientVpnAuthorizationRuleDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnClientVpnAuthorizationRuleDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnClientVpnAuthorizationRuleDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnClientVpnAuthorizationRuleDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnClientVpnAuthorizationRuleDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnClientVpnAuthorizationRuleDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnClientVpnAuthorizationRuleDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnClientVpnAuthorizationRuleDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnClientVpnAuthorizationRuleDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnClientVpnEndpoint
class CfnClientVpnEndpointDef(BaseCfnResource):
    authentication_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnClientVpnEndpoint_ClientAuthenticationRequestPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='Information about the authentication method to be used to authenticate clients.\n')
    client_cidr_block: str = pydantic.Field(..., description='The IPv4 address range, in CIDR notation, from which to assign client IP addresses. The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. The address range cannot be changed after the Client VPN endpoint has been created. Client CIDR range must have a size of at least /22 and must not be greater than /12.\n')
    connection_log_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnClientVpnEndpoint_ConnectionLogOptionsPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Information about the client connection logging options. If you enable client connection logging, data about client connections is sent to a Cloudwatch Logs log stream. The following information is logged: - Client connection requests - Client connection results (successful and unsuccessful) - Reasons for unsuccessful client connection requests - Client connection termination time\n')
    server_certificate_arn: str = pydantic.Field(..., description='The ARN of the server certificate. For more information, see the `AWS Certificate Manager User Guide <https://docs.aws.amazon.com/acm/latest/userguide/>`_ .\n')
    client_connect_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnClientVpnEndpoint_ClientConnectOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for managing connection authorization for new client connections.\n')
    client_login_banner_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnClientVpnEndpoint_ClientLoginBannerOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A brief description of the Client VPN endpoint.\n')
    dns_servers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Information about the DNS servers to be used for DNS resolution. A Client VPN endpoint can have up to two DNS servers. If no DNS server is specified, the DNS address configured on the device is used for the DNS server.\n')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of one or more security groups to apply to the target network. You must also specify the ID of the VPC that contains the security groups.\n')
    self_service_portal: typing.Optional[str] = pydantic.Field(None, description='Specify whether to enable the self-service portal for the Client VPN endpoint. Default Value: ``enabled``\n')
    session_timeout_hours: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum VPN session duration time in hours. Valid values: ``8 | 10 | 12 | 24`` Default value: ``24``\n')
    split_tunnel: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint. By default, split-tunnel on a VPN endpoint is disabled. For information about split-tunnel VPN endpoints, see `Split-tunnel AWS Client VPN endpoint <https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html>`_ in the *AWS Client VPN Administrator Guide* .\n')
    tag_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnClientVpnEndpoint_TagSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The tags to apply to the Client VPN endpoint during creation.\n')
    transport_protocol: typing.Optional[str] = pydantic.Field(None, description='The transport protocol to be used by the VPN session. Default value: ``udp``\n')
    vpc_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the VPC to associate with the Client VPN endpoint. If no security group IDs are specified in the request, the default security group for the VPC is applied.\n')
    vpn_port: typing.Union[int, float, None] = pydantic.Field(None, description='The port number to assign to the Client VPN endpoint for TCP and UDP traffic. Valid Values: ``443`` | ``1194`` Default Value: ``443``')
    _init_params: typing.ClassVar[list[str]] = ['authentication_options', 'client_cidr_block', 'connection_log_options', 'server_certificate_arn', 'client_connect_options', 'client_login_banner_options', 'description', 'dns_servers', 'security_group_ids', 'self_service_portal', 'session_timeout_hours', 'split_tunnel', 'tag_specifications', 'transport_protocol', 'vpc_id', 'vpn_port']
    _method_names: typing.ClassVar[list[str]] = ['CertificateAuthenticationRequestProperty', 'ClientAuthenticationRequestProperty', 'ClientConnectOptionsProperty', 'ClientLoginBannerOptionsProperty', 'ConnectionLogOptionsProperty', 'DirectoryServiceAuthenticationRequestProperty', 'FederatedAuthenticationRequestProperty', 'TagSpecificationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnClientVpnEndpoint'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnClientVpnEndpointDefConfig] = pydantic.Field(None)


class CfnClientVpnEndpointDefConfig(pydantic.BaseModel):
    CertificateAuthenticationRequestProperty: typing.Optional[list[CfnClientVpnEndpointDefCertificateauthenticationrequestpropertyParams]] = pydantic.Field(None, description='')
    ClientAuthenticationRequestProperty: typing.Optional[list[CfnClientVpnEndpointDefClientauthenticationrequestpropertyParams]] = pydantic.Field(None, description='')
    ClientConnectOptionsProperty: typing.Optional[list[CfnClientVpnEndpointDefClientconnectoptionspropertyParams]] = pydantic.Field(None, description='')
    ClientLoginBannerOptionsProperty: typing.Optional[list[CfnClientVpnEndpointDefClientloginbanneroptionspropertyParams]] = pydantic.Field(None, description='')
    ConnectionLogOptionsProperty: typing.Optional[list[CfnClientVpnEndpointDefConnectionlogoptionspropertyParams]] = pydantic.Field(None, description='')
    DirectoryServiceAuthenticationRequestProperty: typing.Optional[list[CfnClientVpnEndpointDefDirectoryserviceauthenticationrequestpropertyParams]] = pydantic.Field(None, description='')
    FederatedAuthenticationRequestProperty: typing.Optional[list[CfnClientVpnEndpointDefFederatedauthenticationrequestpropertyParams]] = pydantic.Field(None, description='')
    TagSpecificationProperty: typing.Optional[list[CfnClientVpnEndpointDefTagspecificationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnClientVpnEndpointDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnClientVpnEndpointDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnClientVpnEndpointDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnClientVpnEndpointDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnClientVpnEndpointDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnClientVpnEndpointDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnClientVpnEndpointDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnClientVpnEndpointDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnClientVpnEndpointDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnClientVpnEndpointDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnClientVpnEndpointDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnClientVpnEndpointDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnClientVpnEndpointDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnClientVpnEndpointDefCertificateauthenticationrequestpropertyParams(pydantic.BaseModel):
    client_root_certificate_chain_arn: str = pydantic.Field(..., description='')
    ...

class CfnClientVpnEndpointDefClientauthenticationrequestpropertyParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='')
    active_directory: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnClientVpnEndpoint_DirectoryServiceAuthenticationRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    federated_authentication: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnClientVpnEndpoint_FederatedAuthenticationRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    mutual_authentication: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnClientVpnEndpoint_CertificateAuthenticationRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnClientVpnEndpointDefClientconnectoptionspropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='')
    lambda_function_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnClientVpnEndpointDefClientloginbanneroptionspropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='')
    banner_text: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnClientVpnEndpointDefConnectionlogoptionspropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='')
    cloudwatch_log_group: typing.Optional[str] = pydantic.Field(None, description='')
    cloudwatch_log_stream: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnClientVpnEndpointDefDirectoryserviceauthenticationrequestpropertyParams(pydantic.BaseModel):
    directory_id: str = pydantic.Field(..., description='')
    ...

class CfnClientVpnEndpointDefFederatedauthenticationrequestpropertyParams(pydantic.BaseModel):
    saml_provider_arn: str = pydantic.Field(..., description='')
    self_service_saml_provider_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnClientVpnEndpointDefTagspecificationpropertyParams(pydantic.BaseModel):
    resource_type: str = pydantic.Field(..., description='')
    tags: typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]] = pydantic.Field(..., description='')
    ...

class CfnClientVpnEndpointDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnClientVpnEndpointDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnClientVpnEndpointDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnClientVpnEndpointDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnClientVpnEndpointDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnClientVpnEndpointDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnClientVpnEndpointDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnClientVpnEndpointDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnClientVpnEndpointDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnClientVpnEndpointDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnClientVpnEndpointDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnClientVpnEndpointDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnClientVpnEndpointDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnClientVpnEndpointDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnClientVpnRoute
class CfnClientVpnRouteDef(BaseCfnResource):
    client_vpn_endpoint_id: str = pydantic.Field(..., description='The ID of the Client VPN endpoint to which to add the route.\n')
    destination_cidr_block: str = pydantic.Field(..., description="The IPv4 address range, in CIDR notation, of the route destination. For example:. - To add a route for Internet access, enter ``0.0.0.0/0`` - To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range - To add a route for an on-premises network, enter the AWS Site-to-Site VPN connection's IPv4 CIDR range - To add a route for the local network, enter the client CIDR range\n")
    target_vpc_subnet_id: str = pydantic.Field(..., description="The ID of the subnet through which you want to route traffic. The specified subnet must be an existing target network of the Client VPN endpoint. Alternatively, if you're adding a route for the local network, specify ``local`` .\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A brief description of the route.')
    _init_params: typing.ClassVar[list[str]] = ['client_vpn_endpoint_id', 'destination_cidr_block', 'target_vpc_subnet_id', 'description']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnClientVpnRoute'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnClientVpnRouteDefConfig] = pydantic.Field(None)


class CfnClientVpnRouteDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnClientVpnRouteDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnClientVpnRouteDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnClientVpnRouteDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnClientVpnRouteDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnClientVpnRouteDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnClientVpnRouteDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnClientVpnRouteDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnClientVpnRouteDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnClientVpnRouteDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnClientVpnRouteDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnClientVpnRouteDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnClientVpnRouteDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnClientVpnRouteDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnClientVpnRouteDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnClientVpnRouteDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnClientVpnRouteDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnClientVpnRouteDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnClientVpnRouteDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnClientVpnRouteDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnClientVpnRouteDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnClientVpnRouteDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnClientVpnRouteDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnClientVpnRouteDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnClientVpnRouteDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnClientVpnRouteDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnClientVpnRouteDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnClientVpnRouteDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnClientVpnTargetNetworkAssociation
class CfnClientVpnTargetNetworkAssociationDef(BaseCfnResource):
    client_vpn_endpoint_id: str = pydantic.Field(..., description='The ID of the Client VPN endpoint.\n')
    subnet_id: str = pydantic.Field(..., description='The ID of the subnet to associate with the Client VPN endpoint.')
    _init_params: typing.ClassVar[list[str]] = ['client_vpn_endpoint_id', 'subnet_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnClientVpnTargetNetworkAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnClientVpnTargetNetworkAssociationDefConfig] = pydantic.Field(None)


class CfnClientVpnTargetNetworkAssociationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnClientVpnTargetNetworkAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnClientVpnTargetNetworkAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnClientVpnTargetNetworkAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnClientVpnTargetNetworkAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnClientVpnTargetNetworkAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnClientVpnTargetNetworkAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnClientVpnTargetNetworkAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnClientVpnTargetNetworkAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnClientVpnTargetNetworkAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnClientVpnTargetNetworkAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnClientVpnTargetNetworkAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnClientVpnTargetNetworkAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnClientVpnTargetNetworkAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnClientVpnTargetNetworkAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnClientVpnTargetNetworkAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnClientVpnTargetNetworkAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnClientVpnTargetNetworkAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnClientVpnTargetNetworkAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnClientVpnTargetNetworkAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnClientVpnTargetNetworkAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnClientVpnTargetNetworkAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnClientVpnTargetNetworkAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnClientVpnTargetNetworkAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnClientVpnTargetNetworkAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnClientVpnTargetNetworkAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnClientVpnTargetNetworkAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnClientVpnTargetNetworkAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnCustomerGateway
class CfnCustomerGatewayDef(BaseCfnResource):
    bgp_asn: typing.Union[int, float] = pydantic.Field(..., description="For devices that support BGP, the customer gateway's BGP ASN. Default: 65000\n")
    ip_address: str = pydantic.Field(..., description="IPv4 address for the customer gateway device's outside interface. The address must be static.\n")
    type: str = pydantic.Field(..., description='The type of VPN connection that this customer gateway supports ( ``ipsec.1`` ).\n')
    device_name: typing.Optional[str] = pydantic.Field(None, description='The name of customer gateway device.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='One or more tags for the customer gateway.')
    _init_params: typing.ClassVar[list[str]] = ['bgp_asn', 'ip_address', 'type', 'device_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnCustomerGateway'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnCustomerGatewayDefConfig] = pydantic.Field(None)


class CfnCustomerGatewayDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnCustomerGatewayDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnCustomerGatewayDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnCustomerGatewayDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnCustomerGatewayDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnCustomerGatewayDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnCustomerGatewayDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnCustomerGatewayDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnCustomerGatewayDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnCustomerGatewayDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnCustomerGatewayDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnCustomerGatewayDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnCustomerGatewayDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnCustomerGatewayDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnCustomerGatewayDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnCustomerGatewayDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCustomerGatewayDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnCustomerGatewayDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCustomerGatewayDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnCustomerGatewayDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnCustomerGatewayDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnCustomerGatewayDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnCustomerGatewayDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnCustomerGatewayDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnCustomerGatewayDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnCustomerGatewayDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnCustomerGatewayDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnCustomerGatewayDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnDHCPOptions
class CfnDHCPOptionsDef(BaseCfnResource):
    domain_name: typing.Optional[str] = pydantic.Field(None, description="This value is used to complete unqualified DNS hostnames. If you're using AmazonProvidedDNS in ``us-east-1`` , specify ``ec2.internal`` . If you're using AmazonProvidedDNS in another Region, specify *region* . ``compute.internal`` (for example, ``ap-northeast-1.compute.internal`` ). Otherwise, specify a domain name (for example, *MyCompany.com* ).\n")
    domain_name_servers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IPv4 addresses of up to four domain name servers, or ``AmazonProvidedDNS`` . The default is ``AmazonProvidedDNS`` . To have your instance receive a custom DNS hostname as specified in ``DomainName`` , you must set this property to a custom DNS server.\n')
    netbios_name_servers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IPv4 addresses of up to four NetBIOS name servers.\n')
    netbios_node_type: typing.Union[int, float, None] = pydantic.Field(None, description='The NetBIOS node type (1, 2, 4, or 8). We recommend that you specify 2 (broadcast and multicast are not currently supported).\n')
    ntp_servers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IPv4 addresses of up to four Network Time Protocol (NTP) servers.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Any tags assigned to the DHCP options set.')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'domain_name_servers', 'netbios_name_servers', 'netbios_node_type', 'ntp_servers', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnDHCPOptions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnDHCPOptionsDefConfig] = pydantic.Field(None)


class CfnDHCPOptionsDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnDHCPOptionsDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnDHCPOptionsDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnDHCPOptionsDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnDHCPOptionsDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnDHCPOptionsDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnDHCPOptionsDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnDHCPOptionsDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnDHCPOptionsDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnDHCPOptionsDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnDHCPOptionsDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnDHCPOptionsDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnDHCPOptionsDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnDHCPOptionsDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnDHCPOptionsDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnDHCPOptionsDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDHCPOptionsDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnDHCPOptionsDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDHCPOptionsDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnDHCPOptionsDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnDHCPOptionsDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnDHCPOptionsDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnDHCPOptionsDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnDHCPOptionsDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnDHCPOptionsDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnDHCPOptionsDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnDHCPOptionsDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnDHCPOptionsDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnEC2Fleet
class CfnEC2FleetDef(BaseCfnResource):
    launch_template_configs: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_FleetLaunchTemplateConfigRequestPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='The configuration for the EC2 Fleet.\n')
    target_capacity_specification: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_TargetCapacitySpecificationRequestPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The number of units to request.\n')
    context: typing.Optional[str] = pydantic.Field(None, description='Reserved.\n')
    excess_capacity_termination_policy: typing.Optional[str] = pydantic.Field(None, description='Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet. Supported only for fleets of type ``maintain`` .\n')
    on_demand_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_OnDemandOptionsRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Describes the configuration of On-Demand Instances in an EC2 Fleet.\n')
    replace_unhealthy_instances: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether EC2 Fleet should replace unhealthy Spot Instances. Supported only for fleets of type ``maintain`` . For more information, see `EC2 Fleet health checks <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/manage-ec2-fleet.html#ec2-fleet-health-checks>`_ in the *Amazon EC2 User Guide* .\n')
    spot_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_SpotOptionsRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Describes the configuration of Spot Instances in an EC2 Fleet.\n')
    tag_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_TagSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The key-value pair for tagging the EC2 Fleet request on creation. For more information, see `Tagging your resources <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources>`_ . If the fleet type is ``instant`` , specify a resource type of ``fleet`` to tag the fleet or ``instance`` to tag the instances at launch. If the fleet type is ``maintain`` or ``request`` , specify a resource type of ``fleet`` to tag the fleet. You cannot specify a resource type of ``instance`` . To tag instances at launch, specify the tags in a `launch template <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template>`_ .\n')
    terminate_instances_with_expiration: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether running instances should be terminated when the EC2 Fleet expires.\n')
    type: typing.Optional[str] = pydantic.Field(None, description='The fleet type. The default value is ``maintain`` . - ``maintain`` - The EC2 Fleet places an asynchronous request for your desired capacity, and continues to maintain your desired Spot capacity by replenishing interrupted Spot Instances. - ``request`` - The EC2 Fleet places an asynchronous one-time request for your desired capacity, but does submit Spot requests in alternative capacity pools if Spot capacity is unavailable, and does not maintain Spot capacity if Spot Instances are interrupted. - ``instant`` - The EC2 Fleet places a synchronous one-time request for your desired capacity, and returns errors for any instances that could not be launched. For more information, see `EC2 Fleet request types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-request-type.html>`_ in the *Amazon EC2 User Guide* .\n')
    valid_from: typing.Optional[str] = pydantic.Field(None, description='The start date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). The default is to start fulfilling the request immediately.\n')
    valid_until: typing.Optional[str] = pydantic.Field(None, description='The end date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). At this point, no new EC2 Fleet requests are placed or able to fulfill the request. If no value is specified, the request remains until you cancel it.')
    _init_params: typing.ClassVar[list[str]] = ['launch_template_configs', 'target_capacity_specification', 'context', 'excess_capacity_termination_policy', 'on_demand_options', 'replace_unhealthy_instances', 'spot_options', 'tag_specifications', 'terminate_instances_with_expiration', 'type', 'valid_from', 'valid_until']
    _method_names: typing.ClassVar[list[str]] = ['AcceleratorCountRequestProperty', 'AcceleratorTotalMemoryMiBRequestProperty', 'BaselineEbsBandwidthMbpsRequestProperty', 'CapacityRebalanceProperty', 'CapacityReservationOptionsRequestProperty', 'FleetLaunchTemplateConfigRequestProperty', 'FleetLaunchTemplateOverridesRequestProperty', 'FleetLaunchTemplateSpecificationRequestProperty', 'InstanceRequirementsRequestProperty', 'MaintenanceStrategiesProperty', 'MemoryGiBPerVCpuRequestProperty', 'MemoryMiBRequestProperty', 'NetworkBandwidthGbpsRequestProperty', 'NetworkInterfaceCountRequestProperty', 'OnDemandOptionsRequestProperty', 'PlacementProperty', 'SpotOptionsRequestProperty', 'TagSpecificationProperty', 'TargetCapacitySpecificationRequestProperty', 'TotalLocalStorageGBRequestProperty', 'VCpuCountRangeRequestProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2Fleet'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnEC2FleetDefConfig] = pydantic.Field(None)


class CfnEC2FleetDefConfig(pydantic.BaseModel):
    AcceleratorCountRequestProperty: typing.Optional[list[CfnEC2FleetDefAcceleratorcountrequestpropertyParams]] = pydantic.Field(None, description='')
    AcceleratorTotalMemoryMiBRequestProperty: typing.Optional[list[CfnEC2FleetDefAcceleratortotalmemorymibrequestpropertyParams]] = pydantic.Field(None, description='')
    BaselineEbsBandwidthMbpsRequestProperty: typing.Optional[list[CfnEC2FleetDefBaselineebsbandwidthmbpsrequestpropertyParams]] = pydantic.Field(None, description='')
    CapacityRebalanceProperty: typing.Optional[list[CfnEC2FleetDefCapacityrebalancepropertyParams]] = pydantic.Field(None, description='')
    CapacityReservationOptionsRequestProperty: typing.Optional[list[CfnEC2FleetDefCapacityreservationoptionsrequestpropertyParams]] = pydantic.Field(None, description='')
    FleetLaunchTemplateConfigRequestProperty: typing.Optional[list[CfnEC2FleetDefFleetlaunchtemplateconfigrequestpropertyParams]] = pydantic.Field(None, description='')
    FleetLaunchTemplateOverridesRequestProperty: typing.Optional[list[CfnEC2FleetDefFleetlaunchtemplateoverridesrequestpropertyParams]] = pydantic.Field(None, description='')
    FleetLaunchTemplateSpecificationRequestProperty: typing.Optional[list[CfnEC2FleetDefFleetlaunchtemplatespecificationrequestpropertyParams]] = pydantic.Field(None, description='')
    InstanceRequirementsRequestProperty: typing.Optional[list[CfnEC2FleetDefInstancerequirementsrequestpropertyParams]] = pydantic.Field(None, description='')
    MaintenanceStrategiesProperty: typing.Optional[list[CfnEC2FleetDefMaintenancestrategiespropertyParams]] = pydantic.Field(None, description='')
    MemoryGiBPerVCpuRequestProperty: typing.Optional[list[CfnEC2FleetDefMemorygibpervcpurequestpropertyParams]] = pydantic.Field(None, description='')
    MemoryMiBRequestProperty: typing.Optional[list[CfnEC2FleetDefMemorymibrequestpropertyParams]] = pydantic.Field(None, description='')
    NetworkBandwidthGbpsRequestProperty: typing.Optional[list[CfnEC2FleetDefNetworkbandwidthgbpsrequestpropertyParams]] = pydantic.Field(None, description='')
    NetworkInterfaceCountRequestProperty: typing.Optional[list[CfnEC2FleetDefNetworkinterfacecountrequestpropertyParams]] = pydantic.Field(None, description='')
    OnDemandOptionsRequestProperty: typing.Optional[list[CfnEC2FleetDefOndemandoptionsrequestpropertyParams]] = pydantic.Field(None, description='')
    PlacementProperty: typing.Optional[list[CfnEC2FleetDefPlacementpropertyParams]] = pydantic.Field(None, description='')
    SpotOptionsRequestProperty: typing.Optional[list[CfnEC2FleetDefSpotoptionsrequestpropertyParams]] = pydantic.Field(None, description='')
    TagSpecificationProperty: typing.Optional[list[CfnEC2FleetDefTagspecificationpropertyParams]] = pydantic.Field(None, description='')
    TargetCapacitySpecificationRequestProperty: typing.Optional[list[CfnEC2FleetDefTargetcapacityspecificationrequestpropertyParams]] = pydantic.Field(None, description='')
    TotalLocalStorageGBRequestProperty: typing.Optional[list[CfnEC2FleetDefTotallocalstoragegbrequestpropertyParams]] = pydantic.Field(None, description='')
    VCpuCountRangeRequestProperty: typing.Optional[list[CfnEC2FleetDefVcpucountrangerequestpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnEC2FleetDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnEC2FleetDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnEC2FleetDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnEC2FleetDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnEC2FleetDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnEC2FleetDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnEC2FleetDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnEC2FleetDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnEC2FleetDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnEC2FleetDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnEC2FleetDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnEC2FleetDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnEC2FleetDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnEC2FleetDefAcceleratorcountrequestpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnEC2FleetDefAcceleratortotalmemorymibrequestpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnEC2FleetDefBaselineebsbandwidthmbpsrequestpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnEC2FleetDefCapacityrebalancepropertyParams(pydantic.BaseModel):
    replacement_strategy: typing.Optional[str] = pydantic.Field(None, description='')
    termination_delay: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnEC2FleetDefCapacityreservationoptionsrequestpropertyParams(pydantic.BaseModel):
    usage_strategy: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnEC2FleetDefFleetlaunchtemplateconfigrequestpropertyParams(pydantic.BaseModel):
    launch_template_specification: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_FleetLaunchTemplateSpecificationRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    overrides: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_FleetLaunchTemplateOverridesRequestPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnEC2FleetDefFleetlaunchtemplateoverridesrequestpropertyParams(pydantic.BaseModel):
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='')
    instance_requirements: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_InstanceRequirementsRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    instance_type: typing.Optional[str] = pydantic.Field(None, description='')
    max_price: typing.Optional[str] = pydantic.Field(None, description='')
    placement: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_PlacementPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='')
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='')
    weighted_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnEC2FleetDefFleetlaunchtemplatespecificationrequestpropertyParams(pydantic.BaseModel):
    version: str = pydantic.Field(..., description='')
    launch_template_id: typing.Optional[str] = pydantic.Field(None, description='')
    launch_template_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnEC2FleetDefInstancerequirementsrequestpropertyParams(pydantic.BaseModel):
    accelerator_count: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_AcceleratorCountRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    accelerator_manufacturers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    accelerator_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    accelerator_total_memory_mib: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_AcceleratorTotalMemoryMiBRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    accelerator_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    allowed_instance_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    bare_metal: typing.Optional[str] = pydantic.Field(None, description='')
    baseline_ebs_bandwidth_mbps: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_BaselineEbsBandwidthMbpsRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    burstable_performance: typing.Optional[str] = pydantic.Field(None, description='')
    cpu_manufacturers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    excluded_instance_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    instance_generations: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    local_storage: typing.Optional[str] = pydantic.Field(None, description='')
    local_storage_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    memory_gib_per_v_cpu: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_MemoryGiBPerVCpuRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    memory_mib: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_MemoryMiBRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    network_bandwidth_gbps: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_NetworkBandwidthGbpsRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    network_interface_count: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_NetworkInterfaceCountRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    on_demand_max_price_percentage_over_lowest_price: typing.Union[int, float, None] = pydantic.Field(None, description='')
    require_hibernate_support: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    spot_max_price_percentage_over_lowest_price: typing.Union[int, float, None] = pydantic.Field(None, description='')
    total_local_storage_gb: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_TotalLocalStorageGBRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    v_cpu_count: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_VCpuCountRangeRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnEC2FleetDefMaintenancestrategiespropertyParams(pydantic.BaseModel):
    capacity_rebalance: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_CapacityRebalancePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnEC2FleetDefMemorygibpervcpurequestpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnEC2FleetDefMemorymibrequestpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnEC2FleetDefNetworkbandwidthgbpsrequestpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnEC2FleetDefNetworkinterfacecountrequestpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnEC2FleetDefOndemandoptionsrequestpropertyParams(pydantic.BaseModel):
    allocation_strategy: typing.Optional[str] = pydantic.Field(None, description='')
    capacity_reservation_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_CapacityReservationOptionsRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    max_total_price: typing.Optional[str] = pydantic.Field(None, description='')
    min_target_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='')
    single_availability_zone: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    single_instance_type: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ...

class CfnEC2FleetDefPlacementpropertyParams(pydantic.BaseModel):
    affinity: typing.Optional[str] = pydantic.Field(None, description='')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='')
    group_name: typing.Optional[str] = pydantic.Field(None, description='')
    host_id: typing.Optional[str] = pydantic.Field(None, description='')
    host_resource_group_arn: typing.Optional[str] = pydantic.Field(None, description='')
    partition_number: typing.Union[int, float, None] = pydantic.Field(None, description='')
    spread_domain: typing.Optional[str] = pydantic.Field(None, description='')
    tenancy: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnEC2FleetDefSpotoptionsrequestpropertyParams(pydantic.BaseModel):
    allocation_strategy: typing.Optional[str] = pydantic.Field(None, description='')
    instance_interruption_behavior: typing.Optional[str] = pydantic.Field(None, description='')
    instance_pools_to_use_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    maintenance_strategies: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_MaintenanceStrategiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    max_total_price: typing.Optional[str] = pydantic.Field(None, description='')
    min_target_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='')
    single_availability_zone: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    single_instance_type: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ...

class CfnEC2FleetDefTagspecificationpropertyParams(pydantic.BaseModel):
    resource_type: typing.Optional[str] = pydantic.Field(None, description='')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='')
    ...

class CfnEC2FleetDefTargetcapacityspecificationrequestpropertyParams(pydantic.BaseModel):
    total_target_capacity: typing.Union[int, float] = pydantic.Field(..., description='')
    default_target_capacity_type: typing.Optional[str] = pydantic.Field(None, description='')
    on_demand_target_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='')
    spot_target_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='')
    target_capacity_unit_type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnEC2FleetDefTotallocalstoragegbrequestpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnEC2FleetDefVcpucountrangerequestpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnEC2FleetDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnEC2FleetDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEC2FleetDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnEC2FleetDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEC2FleetDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnEC2FleetDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnEC2FleetDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnEC2FleetDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnEC2FleetDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnEC2FleetDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEC2FleetDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnEC2FleetDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnEC2FleetDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEC2FleetDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnEgressOnlyInternetGateway
class CfnEgressOnlyInternetGatewayDef(BaseCfnResource):
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC for which to create the egress-only internet gateway.')
    _init_params: typing.ClassVar[list[str]] = ['vpc_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEgressOnlyInternetGateway'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnEgressOnlyInternetGatewayDefConfig] = pydantic.Field(None)


class CfnEgressOnlyInternetGatewayDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnEgressOnlyInternetGatewayDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnEgressOnlyInternetGatewayDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnEgressOnlyInternetGatewayDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnEgressOnlyInternetGatewayDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnEgressOnlyInternetGatewayDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnEgressOnlyInternetGatewayDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnEgressOnlyInternetGatewayDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnEgressOnlyInternetGatewayDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnEgressOnlyInternetGatewayDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnEgressOnlyInternetGatewayDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnEgressOnlyInternetGatewayDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnEgressOnlyInternetGatewayDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnEgressOnlyInternetGatewayDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnEgressOnlyInternetGatewayDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnEgressOnlyInternetGatewayDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEgressOnlyInternetGatewayDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnEgressOnlyInternetGatewayDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEgressOnlyInternetGatewayDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnEgressOnlyInternetGatewayDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnEgressOnlyInternetGatewayDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnEgressOnlyInternetGatewayDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnEgressOnlyInternetGatewayDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnEgressOnlyInternetGatewayDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEgressOnlyInternetGatewayDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnEgressOnlyInternetGatewayDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnEgressOnlyInternetGatewayDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEgressOnlyInternetGatewayDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnEIP
class CfnEIPDef(BaseCfnResource):
    domain: typing.Optional[str] = pydantic.Field(None, description='The network ( ``vpc`` ). If you define an Elastic IP address and associate it with a VPC that is defined in the same template, you must declare a dependency on the VPC-gateway attachment by using the `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ on this resource.\n')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the instance. .. epigraph:: Updates to the ``InstanceId`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.\n')
    network_border_group: typing.Optional[str] = pydantic.Field(None, description='A unique set of Availability Zones, Local Zones, or Wavelength Zones from which AWS advertises IP addresses. Use this parameter to limit the IP address to this location. IP addresses cannot move between network border groups. Use `DescribeAvailabilityZones <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAvailabilityZones.html>`_ to view the network border groups. You cannot use a network border group with EC2 Classic. If you attempt this operation on EC2 Classic, you receive an ``InvalidParameterCombination`` error.\n')
    public_ipv4_pool: typing.Optional[str] = pydantic.Field(None, description='The ID of an address pool that you own. Use this parameter to let Amazon EC2 select an address from the address pool. .. epigraph:: Updates to the ``PublicIpv4Pool`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Any tags assigned to the Elastic IP address. .. epigraph:: Updates to the ``Tags`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.\n')
    transfer_address: typing.Optional[str] = pydantic.Field(None, description='The Elastic IP address you are accepting for transfer. You can only accept one transferred address. For more information on Elastic IP address transfers, see `Transfer Elastic IP addresses <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-eips.html#transfer-EIPs-intro>`_ in the *Amazon Virtual Private Cloud User Guide* .')
    _init_params: typing.ClassVar[list[str]] = ['domain', 'instance_id', 'network_border_group', 'public_ipv4_pool', 'tags', 'transfer_address']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEIP'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnEIPDefConfig] = pydantic.Field(None)


class CfnEIPDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnEIPDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnEIPDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnEIPDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnEIPDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnEIPDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnEIPDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnEIPDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnEIPDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnEIPDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnEIPDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnEIPDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnEIPDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnEIPDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnEIPDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnEIPDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEIPDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnEIPDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEIPDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnEIPDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnEIPDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnEIPDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnEIPDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnEIPDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEIPDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnEIPDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnEIPDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEIPDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnEIPAssociation
class CfnEIPAssociationDef(BaseCfnResource):
    allocation_id: typing.Optional[str] = pydantic.Field(None, description='The allocation ID. This is required.\n')
    eip: typing.Optional[str] = pydantic.Field(None, description='Deprecated.\n')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the instance. The instance must have exactly one attached network interface. You can specify either the instance ID or the network interface ID, but not both.\n')
    network_interface_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the network interface. If the instance has more than one network interface, you must specify a network interface ID. You can specify either the instance ID or the network interface ID, but not both.\n')
    private_ip_address: typing.Optional[str] = pydantic.Field(None, description='The primary or secondary private IP address to associate with the Elastic IP address. If no private IP address is specified, the Elastic IP address is associated with the primary private IP address.')
    _init_params: typing.ClassVar[list[str]] = ['allocation_id', 'eip', 'instance_id', 'network_interface_id', 'private_ip_address']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEIPAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnEIPAssociationDefConfig] = pydantic.Field(None)


class CfnEIPAssociationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnEIPAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnEIPAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnEIPAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnEIPAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnEIPAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnEIPAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnEIPAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnEIPAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnEIPAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnEIPAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnEIPAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnEIPAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnEIPAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnEIPAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnEIPAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEIPAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnEIPAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEIPAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnEIPAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnEIPAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnEIPAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnEIPAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnEIPAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEIPAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnEIPAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnEIPAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEIPAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnEnclaveCertificateIamRoleAssociation
class CfnEnclaveCertificateIamRoleAssociationDef(BaseCfnResource):
    certificate_arn: str = pydantic.Field(..., description='The ARN of the ACM certificate with which to associate the IAM role.\n')
    role_arn: str = pydantic.Field(..., description='The ARN of the IAM role to associate with the ACM certificate. You can associate up to 16 IAM roles with an ACM certificate.')
    _init_params: typing.ClassVar[list[str]] = ['certificate_arn', 'role_arn']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEnclaveCertificateIamRoleAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnEnclaveCertificateIamRoleAssociationDefConfig] = pydantic.Field(None)


class CfnEnclaveCertificateIamRoleAssociationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnEnclaveCertificateIamRoleAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnEnclaveCertificateIamRoleAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnEnclaveCertificateIamRoleAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnEnclaveCertificateIamRoleAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnEnclaveCertificateIamRoleAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnEnclaveCertificateIamRoleAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnEnclaveCertificateIamRoleAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnEnclaveCertificateIamRoleAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnEnclaveCertificateIamRoleAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnEnclaveCertificateIamRoleAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnEnclaveCertificateIamRoleAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnEnclaveCertificateIamRoleAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnEnclaveCertificateIamRoleAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnEnclaveCertificateIamRoleAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnEnclaveCertificateIamRoleAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEnclaveCertificateIamRoleAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnEnclaveCertificateIamRoleAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEnclaveCertificateIamRoleAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnEnclaveCertificateIamRoleAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnEnclaveCertificateIamRoleAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnEnclaveCertificateIamRoleAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnEnclaveCertificateIamRoleAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnEnclaveCertificateIamRoleAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnEnclaveCertificateIamRoleAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnEnclaveCertificateIamRoleAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnEnclaveCertificateIamRoleAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnEnclaveCertificateIamRoleAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnFlowLog
class CfnFlowLogDef(BaseCfnResource):
    resource_id: str = pydantic.Field(..., description='The ID of the resource to monitor. For example, if the resource type is ``VPC`` , specify the ID of the VPC.\n')
    resource_type: str = pydantic.Field(..., description='The type of resource to monitor.\n')
    deliver_logs_permission_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the IAM role that allows Amazon EC2 to publish flow logs to a CloudWatch Logs log group in your account. This parameter is required if the destination type is ``cloud-watch-logs`` and unsupported otherwise.\n')
    destination_options: typing.Any = pydantic.Field(None, description='The destination options. The following options are supported:. - ``FileFormat`` - The format for the flow log ( ``plain-text`` | ``parquet`` ). The default is ``plain-text`` . - ``HiveCompatiblePartitions`` - Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3 ( ``true`` | ``false`` ). The default is ``false`` . - ``PerHourPartition`` - Indicates whether to partition the flow log per hour ( ``true`` | ``false`` ). The default is ``false`` .\n')
    log_destination: typing.Optional[str] = pydantic.Field(None, description="The destination for the flow log data. The meaning of this parameter depends on the destination type. - If the destination type is ``cloud-watch-logs`` , specify the ARN of a CloudWatch Logs log group. For example: arn:aws:logs: *region* : *account_id* :log-group: *my_group* Alternatively, use the ``LogGroupName`` parameter. - If the destination type is ``s3`` , specify the ARN of an S3 bucket. For example: arn:aws:s3::: *my_bucket* / *my_subfolder* / The subfolder is optional. Note that you can't use ``AWSLogs`` as a subfolder name. - If the destination type is ``kinesis-data-firehose`` , specify the ARN of a Kinesis Data Firehose delivery stream. For example: arn:aws:firehose: *region* : *account_id* :deliverystream: *my_stream*\n")
    log_destination_type: typing.Optional[str] = pydantic.Field(None, description='The type of destination for the flow log data. Default: ``cloud-watch-logs``\n')
    log_format: typing.Optional[str] = pydantic.Field(None, description='The fields to include in the flow log record, in the order in which they should appear. If you omit this parameter, the flow log is created using the default format. If you specify this parameter, you must include at least one field. For more information about the available fields, see `Flow log records <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-log-records>`_ in the *Amazon VPC User Guide* or `Transit Gateway Flow Log records <https://docs.aws.amazon.com/vpc/latest/tgw/tgw-flow-logs.html#flow-log-records>`_ in the *AWS Transit Gateway Guide* . Specify the fields using the ``${field-id}`` format, separated by spaces.\n')
    log_group_name: typing.Optional[str] = pydantic.Field(None, description='The name of a new or existing CloudWatch Logs log group where Amazon EC2 publishes your flow logs. This parameter is valid only if the destination type is ``cloud-watch-logs`` .\n')
    max_aggregation_interval: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record. The possible values are 60 seconds (1 minute) or 600 seconds (10 minutes). This parameter must be 60 seconds for transit gateway resource types. When a network interface is attached to a `Nitro-based instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ , the aggregation interval is always 60 seconds or less, regardless of the value that you specify. Default: 600\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to apply to the flow logs.\n')
    traffic_type: typing.Optional[str] = pydantic.Field(None, description='The type of traffic to monitor (accepted traffic, rejected traffic, or all traffic). This parameter is not supported for transit gateway resource types. It is required for the other resource types.')
    _init_params: typing.ClassVar[list[str]] = ['resource_id', 'resource_type', 'deliver_logs_permission_arn', 'destination_options', 'log_destination', 'log_destination_type', 'log_format', 'log_group_name', 'max_aggregation_interval', 'tags', 'traffic_type']
    _method_names: typing.ClassVar[list[str]] = ['DestinationOptionsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnFlowLog'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnFlowLogDefConfig] = pydantic.Field(None)


class CfnFlowLogDefConfig(pydantic.BaseModel):
    DestinationOptionsProperty: typing.Optional[list[CfnFlowLogDefDestinationoptionspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnFlowLogDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnFlowLogDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnFlowLogDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnFlowLogDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnFlowLogDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnFlowLogDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnFlowLogDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnFlowLogDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnFlowLogDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnFlowLogDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnFlowLogDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnFlowLogDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnFlowLogDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnFlowLogDefDestinationoptionspropertyParams(pydantic.BaseModel):
    file_format: str = pydantic.Field(..., description='')
    hive_compatible_partitions: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='')
    per_hour_partition: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='')
    ...

class CfnFlowLogDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnFlowLogDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFlowLogDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnFlowLogDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFlowLogDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnFlowLogDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnFlowLogDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnFlowLogDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnFlowLogDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnFlowLogDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnFlowLogDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnFlowLogDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnFlowLogDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnFlowLogDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnGatewayRouteTableAssociation
class CfnGatewayRouteTableAssociationDef(BaseCfnResource):
    gateway_id: str = pydantic.Field(..., description='The ID of the gateway.\n')
    route_table_id: str = pydantic.Field(..., description='The ID of the route table.')
    _init_params: typing.ClassVar[list[str]] = ['gateway_id', 'route_table_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnGatewayRouteTableAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnGatewayRouteTableAssociationDefConfig] = pydantic.Field(None)


class CfnGatewayRouteTableAssociationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnGatewayRouteTableAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnGatewayRouteTableAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnGatewayRouteTableAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnGatewayRouteTableAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnGatewayRouteTableAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnGatewayRouteTableAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnGatewayRouteTableAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnGatewayRouteTableAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnGatewayRouteTableAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnGatewayRouteTableAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnGatewayRouteTableAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnGatewayRouteTableAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnGatewayRouteTableAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnGatewayRouteTableAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnGatewayRouteTableAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGatewayRouteTableAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnGatewayRouteTableAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGatewayRouteTableAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnGatewayRouteTableAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnGatewayRouteTableAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnGatewayRouteTableAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnGatewayRouteTableAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnGatewayRouteTableAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnGatewayRouteTableAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnGatewayRouteTableAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnGatewayRouteTableAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnGatewayRouteTableAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnHost
class CfnHostDef(BaseCfnResource):
    availability_zone: str = pydantic.Field(..., description='The Availability Zone in which to allocate the Dedicated Host.\n')
    auto_placement: typing.Optional[str] = pydantic.Field(None, description='Indicates whether the host accepts any untargeted instance launches that match its instance type configuration, or if it only accepts Host tenancy instance launches that specify its unique host ID. For more information, see `Understanding auto-placement and affinity <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/how-dedicated-hosts-work.html#dedicated-hosts-understanding>`_ in the *Amazon EC2 User Guide* . Default: ``on``\n')
    host_maintenance: typing.Optional[str] = pydantic.Field(None, description='Indicates whether host maintenance is enabled or disabled for the Dedicated Host.\n')
    host_recovery: typing.Optional[str] = pydantic.Field(None, description='Indicates whether to enable or disable host recovery for the Dedicated Host. Host recovery is disabled by default. For more information, see `Host recovery <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-recovery.html>`_ in the *Amazon EC2 User Guide* . Default: ``off``\n')
    instance_family: typing.Optional[str] = pydantic.Field(None, description='The instance family supported by the Dedicated Host. For example, ``m5`` .\n')
    instance_type: typing.Optional[str] = pydantic.Field(None, description='Specifies the instance type to be supported by the Dedicated Hosts. If you specify an instance type, the Dedicated Hosts support instances of the specified instance type only.\n')
    outpost_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the AWS Outpost on which the Dedicated Host is allocated.')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'auto_placement', 'host_maintenance', 'host_recovery', 'instance_family', 'instance_type', 'outpost_arn']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnHost'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnHostDefConfig] = pydantic.Field(None)


class CfnHostDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnHostDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnHostDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnHostDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnHostDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnHostDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnHostDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnHostDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnHostDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnHostDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnHostDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnHostDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnHostDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnHostDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnHostDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnHostDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnHostDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnHostDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnHostDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnHostDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnHostDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnHostDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnHostDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnHostDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnHostDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnHostDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnHostDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnHostDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnInstance
class CfnInstanceDef(BaseCfnResource):
    additional_info: typing.Optional[str] = pydantic.Field(None, description='This property is reserved for internal use. If you use it, the stack fails with this error: ``Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)`` .\n')
    affinity: typing.Optional[str] = pydantic.Field(None, description='Indicates whether the instance is associated with a dedicated host. If you want the instance to always restart on the same host on which it was launched, specify ``host`` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify ``default`` .\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone of the instance. If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region. This parameter is not supported by `DescribeImageAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html>`_ .\n')
    block_device_mappings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_BlockDeviceMappingPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The block device mapping entries that defines the block devices to attach to the instance at launch. By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the ``DeleteOnTermination`` setting. .. epigraph:: After the instance is running, you can modify only the ``DeleteOnTermination`` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .\n')
    cpu_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_CpuOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The CPU options for the instance. For more information, see `Optimize CPU options <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .\n')
    credit_specification: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_CreditSpecificationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The credit option for CPU usage of the burstable performance instance. Valid values are ``standard`` and ``unlimited`` . To change this attribute after launch, use `ModifyInstanceCreditSpecification <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html>`_ . For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ in the *Amazon EC2 User Guide* . Default: ``standard`` (T2 instances) or ``unlimited`` (T3/T3a/T4g instances) For T3 instances with ``host`` tenancy, only ``standard`` is supported.\n')
    disable_api_termination: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="If you set this parameter to ``true`` , you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. To change this attribute after launch, use `ModifyInstanceAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html>`_ . Alternatively, if you set ``InstanceInitiatedShutdownBehavior`` to ``terminate`` , you can terminate the instance by running the shutdown command from the instance. Default: ``false``\n")
    ebs_optimized: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance. Default: ``false``\n")
    elastic_gpu_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_ElasticGpuSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An elastic GPU to associate with the instance. An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see `Amazon EC2 Elastic GPUs <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html>`_ in the *Amazon EC2 User Guide* .\n')
    elastic_inference_accelerators: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_ElasticInferenceAcceleratorPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An elastic inference accelerator to associate with the instance. Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads. You cannot specify accelerators from different generations in the same request. .. epigraph:: Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.\n')
    enclave_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_EnclaveOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Indicates whether the instance is enabled for AWS Nitro Enclaves.\n')
    hibernation_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_HibernationOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Indicates whether an instance is enabled for hibernation. For more information, see `Hibernate your instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html>`_ in the *Amazon EC2 User Guide* . You can't enable hibernation and AWS Nitro Enclaves on the same instance.\n")
    host_id: typing.Optional[str] = pydantic.Field(None, description="If you specify host for the ``Affinity`` property, the ID of a dedicated host that the instance is associated with. If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.\n")
    host_resource_group_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host`` .\n')
    iam_instance_profile: typing.Optional[str] = pydantic.Field(None, description='The name of an IAM instance profile. To create a new IAM instance profile, use the `AWS::IAM::InstanceProfile <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html>`_ resource.\n')
    image_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the AMI. An AMI ID is required to launch an instance and must be specified here or in a launch template.\n')
    instance_initiated_shutdown_behavior: typing.Optional[str] = pydantic.Field(None, description='Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown). Default: ``stop``\n')
    instance_type: typing.Optional[str] = pydantic.Field(None, description='The instance type. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* . Default: ``m1.small``\n')
    ipv6_address_count: typing.Union[int, float, None] = pydantic.Field(None, description="The number of IPv6 addresses to associate with the primary network interface. Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch. You cannot specify this option and the network interfaces option in the same request.\n")
    ipv6_addresses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_InstanceIpv6AddressPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="The IPv6 addresses from the range of the subnet to associate with the primary network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch. You cannot specify this option and the network interfaces option in the same request.\n")
    kernel_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the kernel. .. epigraph:: We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `PV-GRUB <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .\n')
    key_name: typing.Optional[str] = pydantic.Field(None, description="The name of the key pair. You can create a key pair using `CreateKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html>`_ or `ImportKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html>`_ . .. epigraph:: If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.\n")
    launch_template: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_LaunchTemplateSpecificationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The launch template to use to launch the instances. Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.\n')
    license_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_LicenseSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The license configurations.\n')
    monitoring: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether detailed monitoring is enabled for the instance. Specify ``true`` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see `Enable or turn off detailed monitoring for your instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html>`_ in the *Amazon EC2 User Guide* .\n')
    network_interfaces: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_NetworkInterfacePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The network interfaces to associate with the instance. .. epigraph:: If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed. If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ to declare a dependency on the VPC-gateway attachment.\n')
    placement_group_name: typing.Optional[str] = pydantic.Field(None, description='The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).\n')
    private_dns_name_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_PrivateDnsNameOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for the instance hostname.\n')
    private_ip_address: typing.Optional[str] = pydantic.Field(None, description="The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet. Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request. You cannot specify this option and the network interfaces option in the same request. If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.\n")
    propagate_tags_to_volume_on_creation: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch. If you specify ``true`` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify ``false`` , those tags are not assigned to the attached volumes.\n')
    ramdisk_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the RAM disk to select. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID. .. epigraph:: We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `PV-GRUB <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .\n')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of the security groups. You can specify the IDs of existing security groups and references to resources created by the stack template. If you specify a network interface, you must specify any security groups as part of the network interface.\n')
    security_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='[Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead. You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template. Default: Amazon EC2 uses the default security group.\n')
    source_dest_check: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives. If the value is ``true`` , source/destination checks are enabled; otherwise, they are disabled. The default value is ``true`` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.\n')
    ssm_associations: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_SsmAssociationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The SSM `document <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html>`_ and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see `Create an IAM instance profile for Systems Manager <https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html>`_ in the *AWS Systems Manager User Guide* . .. epigraph:: You can currently associate only one document with an instance.\n')
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the subnet to launch the instance into. If you specify a network interface, you must specify any subnets as part of the network interface.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to add to the instance. These tags are not applied to the EBS volumes, such as the root volume, unless `PropagateTagsToVolumeOnCreation <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation>`_ is ``true`` .\n')
    tenancy: typing.Optional[str] = pydantic.Field(None, description='The tenancy of the instance. An instance with a tenancy of ``dedicated`` runs on single-tenant hardware.\n')
    user_data: typing.Optional[str] = pydantic.Field(None, description='The user data script to make available to the instance. User data is limited to 16 KB. You must provide base64-encoded text. For more information, see `Fn::Base64 <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html>`_ . User data runs only at instance launch. For more information, see `Run commands on your Linux instance at launch <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html>`_ and `Run commands on your Windows instance at launch <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html>`_ .\n')
    volumes: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_VolumePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The volumes to attach to the instance.')
    _init_params: typing.ClassVar[list[str]] = ['additional_info', 'affinity', 'availability_zone', 'block_device_mappings', 'cpu_options', 'credit_specification', 'disable_api_termination', 'ebs_optimized', 'elastic_gpu_specifications', 'elastic_inference_accelerators', 'enclave_options', 'hibernation_options', 'host_id', 'host_resource_group_arn', 'iam_instance_profile', 'image_id', 'instance_initiated_shutdown_behavior', 'instance_type', 'ipv6_address_count', 'ipv6_addresses', 'kernel_id', 'key_name', 'launch_template', 'license_specifications', 'monitoring', 'network_interfaces', 'placement_group_name', 'private_dns_name_options', 'private_ip_address', 'propagate_tags_to_volume_on_creation', 'ramdisk_id', 'security_group_ids', 'security_groups', 'source_dest_check', 'ssm_associations', 'subnet_id', 'tags', 'tenancy', 'user_data', 'volumes']
    _method_names: typing.ClassVar[list[str]] = ['AssociationParameterProperty', 'BlockDeviceMappingProperty', 'CpuOptionsProperty', 'CreditSpecificationProperty', 'EbsProperty', 'ElasticGpuSpecificationProperty', 'ElasticInferenceAcceleratorProperty', 'EnclaveOptionsProperty', 'HibernationOptionsProperty', 'InstanceIpv6AddressProperty', 'LaunchTemplateSpecificationProperty', 'LicenseSpecificationProperty', 'NetworkInterfaceProperty', 'NoDeviceProperty', 'PrivateDnsNameOptionsProperty', 'PrivateIpAddressSpecificationProperty', 'SsmAssociationProperty', 'VolumeProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInstance'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnInstanceDefConfig] = pydantic.Field(None)


class CfnInstanceDefConfig(pydantic.BaseModel):
    AssociationParameterProperty: typing.Optional[list[CfnInstanceDefAssociationparameterpropertyParams]] = pydantic.Field(None, description='')
    BlockDeviceMappingProperty: typing.Optional[list[CfnInstanceDefBlockdevicemappingpropertyParams]] = pydantic.Field(None, description='')
    CpuOptionsProperty: typing.Optional[list[CfnInstanceDefCpuoptionspropertyParams]] = pydantic.Field(None, description='')
    CreditSpecificationProperty: typing.Optional[list[CfnInstanceDefCreditspecificationpropertyParams]] = pydantic.Field(None, description='')
    EbsProperty: typing.Optional[list[CfnInstanceDefEbspropertyParams]] = pydantic.Field(None, description='')
    ElasticGpuSpecificationProperty: typing.Optional[list[CfnInstanceDefElasticgpuspecificationpropertyParams]] = pydantic.Field(None, description='')
    ElasticInferenceAcceleratorProperty: typing.Optional[list[CfnInstanceDefElasticinferenceacceleratorpropertyParams]] = pydantic.Field(None, description='')
    EnclaveOptionsProperty: typing.Optional[list[CfnInstanceDefEnclaveoptionspropertyParams]] = pydantic.Field(None, description='')
    HibernationOptionsProperty: typing.Optional[list[CfnInstanceDefHibernationoptionspropertyParams]] = pydantic.Field(None, description='')
    InstanceIpv6AddressProperty: typing.Optional[list[CfnInstanceDefInstanceipv6AddresspropertyParams]] = pydantic.Field(None, description='')
    LaunchTemplateSpecificationProperty: typing.Optional[list[CfnInstanceDefLaunchtemplatespecificationpropertyParams]] = pydantic.Field(None, description='')
    LicenseSpecificationProperty: typing.Optional[list[CfnInstanceDefLicensespecificationpropertyParams]] = pydantic.Field(None, description='')
    NetworkInterfaceProperty: typing.Optional[list[CfnInstanceDefNetworkinterfacepropertyParams]] = pydantic.Field(None, description='')
    NoDeviceProperty: typing.Optional[bool] = pydantic.Field(None, description='')
    PrivateDnsNameOptionsProperty: typing.Optional[list[CfnInstanceDefPrivatednsnameoptionspropertyParams]] = pydantic.Field(None, description='')
    PrivateIpAddressSpecificationProperty: typing.Optional[list[CfnInstanceDefPrivateipaddressspecificationpropertyParams]] = pydantic.Field(None, description='')
    SsmAssociationProperty: typing.Optional[list[CfnInstanceDefSsmassociationpropertyParams]] = pydantic.Field(None, description='')
    VolumeProperty: typing.Optional[list[CfnInstanceDefVolumepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnInstanceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnInstanceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnInstanceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnInstanceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnInstanceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnInstanceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnInstanceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnInstanceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnInstanceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnInstanceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnInstanceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnInstanceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnInstanceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnInstanceDefAssociationparameterpropertyParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='')
    value: typing.Sequence[str] = pydantic.Field(..., description='')
    ...

class CfnInstanceDefBlockdevicemappingpropertyParams(pydantic.BaseModel):
    device_name: str = pydantic.Field(..., description='')
    ebs: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_EbsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    no_device: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_NoDevicePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    virtual_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnInstanceDefCpuoptionspropertyParams(pydantic.BaseModel):
    core_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    threads_per_core: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnInstanceDefCreditspecificationpropertyParams(pydantic.BaseModel):
    cpu_credits: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnInstanceDefEbspropertyParams(pydantic.BaseModel):
    delete_on_termination: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    encrypted: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='')
    snapshot_id: typing.Optional[str] = pydantic.Field(None, description='')
    volume_size: typing.Union[int, float, None] = pydantic.Field(None, description='')
    volume_type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnInstanceDefElasticgpuspecificationpropertyParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='')
    ...

class CfnInstanceDefElasticinferenceacceleratorpropertyParams(pydantic.BaseModel):
    type: str = pydantic.Field(..., description='')
    count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnInstanceDefEnclaveoptionspropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ...

class CfnInstanceDefHibernationoptionspropertyParams(pydantic.BaseModel):
    configured: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ...

class CfnInstanceDefInstanceipv6AddresspropertyParams(pydantic.BaseModel):
    ipv6_address: str = pydantic.Field(..., description='')
    ...

class CfnInstanceDefLaunchtemplatespecificationpropertyParams(pydantic.BaseModel):
    version: str = pydantic.Field(..., description='')
    launch_template_id: typing.Optional[str] = pydantic.Field(None, description='')
    launch_template_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnInstanceDefLicensespecificationpropertyParams(pydantic.BaseModel):
    license_configuration_arn: str = pydantic.Field(..., description='')
    ...

class CfnInstanceDefNetworkinterfacepropertyParams(pydantic.BaseModel):
    device_index: str = pydantic.Field(..., description='')
    associate_carrier_ip_address: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    associate_public_ip_address: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    delete_on_termination: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    group_set: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ipv6_address_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ipv6_addresses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_InstanceIpv6AddressPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    network_interface_id: typing.Optional[str] = pydantic.Field(None, description='')
    private_ip_address: typing.Optional[str] = pydantic.Field(None, description='')
    private_ip_addresses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_PrivateIpAddressSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    secondary_private_ip_address_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnInstanceDefPrivatednsnameoptionspropertyParams(pydantic.BaseModel):
    enable_resource_name_dns_aaaa_record: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    enable_resource_name_dns_a_record: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    hostname_type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnInstanceDefPrivateipaddressspecificationpropertyParams(pydantic.BaseModel):
    primary: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='')
    private_ip_address: str = pydantic.Field(..., description='')
    ...

class CfnInstanceDefSsmassociationpropertyParams(pydantic.BaseModel):
    document_name: str = pydantic.Field(..., description='')
    association_parameters: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_AssociationParameterPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnInstanceDefVolumepropertyParams(pydantic.BaseModel):
    device: str = pydantic.Field(..., description='')
    volume_id: str = pydantic.Field(..., description='')
    ...

class CfnInstanceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnInstanceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnInstanceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnInstanceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnInstanceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnInstanceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnInstanceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnInstanceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnInstanceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnInstanceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnInstanceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnInstanceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnInstanceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnInstanceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnInternetGateway
class CfnInternetGatewayDef(BaseCfnResource):
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Any tags to assign to the internet gateway.')
    _init_params: typing.ClassVar[list[str]] = ['tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInternetGateway'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnInternetGatewayDefConfig] = pydantic.Field(None)


class CfnInternetGatewayDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnInternetGatewayDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnInternetGatewayDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnInternetGatewayDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnInternetGatewayDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnInternetGatewayDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnInternetGatewayDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnInternetGatewayDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnInternetGatewayDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnInternetGatewayDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnInternetGatewayDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnInternetGatewayDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnInternetGatewayDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnInternetGatewayDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnInternetGatewayDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnInternetGatewayDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnInternetGatewayDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnInternetGatewayDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnInternetGatewayDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnInternetGatewayDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnInternetGatewayDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnInternetGatewayDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnInternetGatewayDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnInternetGatewayDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnInternetGatewayDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnInternetGatewayDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnInternetGatewayDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnInternetGatewayDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnIPAM
class CfnIPAMDef(BaseCfnResource):
    default_resource_discovery_association_id: typing.Optional[str] = pydantic.Field(None, description="The IPAM's default resource discovery association ID.\n")
    default_resource_discovery_id: typing.Optional[str] = pydantic.Field(None, description="The IPAM's default resource discovery ID.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='The description for the IPAM.\n')
    operating_regions: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnIPAM_IpamOperatingRegionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The operating Regions for an IPAM. Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions. For more information about operating Regions, see `Create an IPAM <https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.')
    _init_params: typing.ClassVar[list[str]] = ['default_resource_discovery_association_id', 'default_resource_discovery_id', 'description', 'operating_regions', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['IpamOperatingRegionProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnIPAM'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnIPAMDefConfig] = pydantic.Field(None)


class CfnIPAMDefConfig(pydantic.BaseModel):
    IpamOperatingRegionProperty: typing.Optional[list[CfnIPAMDefIpamoperatingregionpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnIPAMDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnIPAMDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnIPAMDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnIPAMDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnIPAMDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnIPAMDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnIPAMDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnIPAMDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnIPAMDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnIPAMDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnIPAMDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnIPAMDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnIPAMDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnIPAMDefIpamoperatingregionpropertyParams(pydantic.BaseModel):
    region_name: str = pydantic.Field(..., description='')
    ...

class CfnIPAMDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnIPAMDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIPAMDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnIPAMDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIPAMDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnIPAMDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnIPAMDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnIPAMDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnIPAMDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnIPAMDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIPAMDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnIPAMDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnIPAMDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIPAMDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnIPAMAllocation
class CfnIPAMAllocationDef(BaseCfnResource):
    ipam_pool_id: str = pydantic.Field(..., description='The ID of the IPAM pool from which you would like to allocate a CIDR.\n')
    cidr: typing.Optional[str] = pydantic.Field(None, description='The CIDR you would like to allocate from the IPAM pool. Note the following:. - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR. - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored. Possible values: Any available IPv4 or IPv6 CIDR.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the allocation.\n')
    netmask_length: typing.Union[int, float, None] = pydantic.Field(None, description='The netmask length of the CIDR you would like to allocate from the IPAM pool. Note the following:. - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR. - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.')
    _init_params: typing.ClassVar[list[str]] = ['ipam_pool_id', 'cidr', 'description', 'netmask_length']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnIPAMAllocation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnIPAMAllocationDefConfig] = pydantic.Field(None)


class CfnIPAMAllocationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnIPAMAllocationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnIPAMAllocationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnIPAMAllocationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnIPAMAllocationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnIPAMAllocationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnIPAMAllocationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnIPAMAllocationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnIPAMAllocationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnIPAMAllocationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnIPAMAllocationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnIPAMAllocationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnIPAMAllocationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnIPAMAllocationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnIPAMAllocationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnIPAMAllocationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIPAMAllocationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnIPAMAllocationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIPAMAllocationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnIPAMAllocationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnIPAMAllocationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnIPAMAllocationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnIPAMAllocationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnIPAMAllocationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIPAMAllocationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnIPAMAllocationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnIPAMAllocationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIPAMAllocationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnIPAMPool
class CfnIPAMPoolDef(BaseCfnResource):
    address_family: str = pydantic.Field(..., description='The address family of the pool.\n')
    ipam_scope_id: str = pydantic.Field(..., description='The ID of the scope in which you would like to create the IPAM pool.\n')
    allocation_default_netmask_length: typing.Union[int, float, None] = pydantic.Field(None, description='The default netmask length for allocations added to this pool. If, for example, the CIDR assigned to this pool is 10.0.0.0/8 and you enter 16 here, new allocations will default to 10.0.0.0/16.\n')
    allocation_max_netmask_length: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum netmask length possible for CIDR allocations in this IPAM pool to be compliant. The maximum netmask length must be greater than the minimum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.\n')
    allocation_min_netmask_length: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum netmask length required for CIDR allocations in this IPAM pool to be compliant. The minimum netmask length must be less than the maximum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.\n')
    allocation_resource_tags: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.CfnTagDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Tags that are required for resources that use CIDRs from this IPAM pool. Resources that do not have these tags will not be allowed to allocate space from the pool. If the resources have their tags changed after they have allocated space or if the allocation tagging requirements are changed on the pool, the resource may be marked as noncompliant.\n')
    auto_import: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="If selected, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM. The CIDRs that will be allocated for these resources must not already be allocated to other resources in order for the import to succeed. IPAM will import a CIDR regardless of its compliance with the pool's allocation rules, so a resource might be imported and subsequently marked as noncompliant. If IPAM discovers multiple CIDRs that overlap, IPAM will import the largest CIDR only. If IPAM discovers multiple CIDRs with matching CIDRs, IPAM will randomly import one of them only. A locale must be set on the pool for this feature to work.\n")
    aws_service: typing.Optional[str] = pydantic.Field(None, description='Limits which service in AWS that the pool can be used in. "ec2", for example, allows users to use space for Elastic IP addresses and VPCs.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the IPAM pool.\n')
    locale: typing.Optional[str] = pydantic.Field(None, description="The locale of the IPAM pool. In IPAM, the locale is the AWS Region where you want to make an IPAM pool available for allocations. Only resources in the same Region as the locale of the pool can get IP address allocations from the pool. You can only allocate a CIDR for a VPC, for example, from an IPAM pool that shares a locale with the VPC’s Region. Note that once you choose a Locale for a pool, you cannot modify it. If you choose an AWS Region for locale that has not been configured as an operating Region for the IPAM, you'll get an error.\n")
    provisioned_cidrs: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnIPAMPool_ProvisionedCidrPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Information about the CIDRs provisioned to an IPAM pool.\n')
    public_ip_source: typing.Optional[str] = pydantic.Field(None, description='The IP address source for pools in the public scope. Only used for provisioning IP address CIDRs to pools in the public scope. Default is ``BYOIP`` . For more information, see `Create IPv6 pools <https://docs.aws.amazon.com//vpc/latest/ipam/intro-create-ipv6-pools.html>`_ in the *Amazon VPC IPAM User Guide* . By default, you can add only one Amazon-provided IPv6 CIDR block to a top-level IPv6 pool. For information on increasing the default limit, see `Quotas for your IPAM <https://docs.aws.amazon.com//vpc/latest/ipam/quotas-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .\n')
    publicly_advertisable: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Determines if a pool is publicly advertisable. This option is not available for pools with AddressFamily set to ``ipv4`` .\n')
    source_ipam_pool_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the source IPAM pool. You can use this option to create an IPAM pool within an existing source pool.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.')
    _init_params: typing.ClassVar[list[str]] = ['address_family', 'ipam_scope_id', 'allocation_default_netmask_length', 'allocation_max_netmask_length', 'allocation_min_netmask_length', 'allocation_resource_tags', 'auto_import', 'aws_service', 'description', 'locale', 'provisioned_cidrs', 'public_ip_source', 'publicly_advertisable', 'source_ipam_pool_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['ProvisionedCidrProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnIPAMPool'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnIPAMPoolDefConfig] = pydantic.Field(None)


class CfnIPAMPoolDefConfig(pydantic.BaseModel):
    ProvisionedCidrProperty: typing.Optional[list[CfnIPAMPoolDefProvisionedcidrpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnIPAMPoolDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnIPAMPoolDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnIPAMPoolDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnIPAMPoolDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnIPAMPoolDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnIPAMPoolDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnIPAMPoolDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnIPAMPoolDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnIPAMPoolDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnIPAMPoolDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnIPAMPoolDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnIPAMPoolDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnIPAMPoolDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnIPAMPoolDefProvisionedcidrpropertyParams(pydantic.BaseModel):
    cidr: str = pydantic.Field(..., description='')
    ...

class CfnIPAMPoolDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnIPAMPoolDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIPAMPoolDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnIPAMPoolDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIPAMPoolDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnIPAMPoolDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnIPAMPoolDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnIPAMPoolDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnIPAMPoolDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnIPAMPoolDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIPAMPoolDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnIPAMPoolDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnIPAMPoolDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIPAMPoolDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnIPAMPoolCidr
class CfnIPAMPoolCidrDef(BaseCfnResource):
    ipam_pool_id: str = pydantic.Field(..., description='The ID of the IPAM pool.\n')
    cidr: typing.Optional[str] = pydantic.Field(None, description='The CIDR provisioned to the IPAM pool. A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is ``10.24.34.0/23`` . An IPv6 CIDR example is ``2001:DB8::/32`` .\n')
    netmask_length: typing.Union[int, float, None] = pydantic.Field(None, description='The netmask length of the CIDR you\'d like to provision to a pool. Can be used for provisioning Amazon-provided IPv6 CIDRs to top-level pools and for provisioning CIDRs to pools with source pools. Cannot be used to provision BYOIP CIDRs to top-level pools. "NetmaskLength" or "Cidr" is required.')
    _init_params: typing.ClassVar[list[str]] = ['ipam_pool_id', 'cidr', 'netmask_length']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnIPAMPoolCidr'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnIPAMPoolCidrDefConfig] = pydantic.Field(None)


class CfnIPAMPoolCidrDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnIPAMPoolCidrDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnIPAMPoolCidrDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnIPAMPoolCidrDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnIPAMPoolCidrDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnIPAMPoolCidrDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnIPAMPoolCidrDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnIPAMPoolCidrDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnIPAMPoolCidrDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnIPAMPoolCidrDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnIPAMPoolCidrDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnIPAMPoolCidrDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnIPAMPoolCidrDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnIPAMPoolCidrDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnIPAMPoolCidrDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnIPAMPoolCidrDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIPAMPoolCidrDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnIPAMPoolCidrDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIPAMPoolCidrDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnIPAMPoolCidrDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnIPAMPoolCidrDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnIPAMPoolCidrDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnIPAMPoolCidrDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnIPAMPoolCidrDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIPAMPoolCidrDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnIPAMPoolCidrDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnIPAMPoolCidrDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIPAMPoolCidrDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnIPAMResourceDiscovery
class CfnIPAMResourceDiscoveryDef(BaseCfnResource):
    description: typing.Optional[str] = pydantic.Field(None, description='The resource discovery description.\n')
    operating_regions: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnIPAMResourceDiscovery_IpamOperatingRegionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The operating Regions for the resource discovery. Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A tag is a label that you assign to an AWS resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your AWS costs.')
    _init_params: typing.ClassVar[list[str]] = ['description', 'operating_regions', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['IpamOperatingRegionProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnIPAMResourceDiscovery'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnIPAMResourceDiscoveryDefConfig] = pydantic.Field(None)


class CfnIPAMResourceDiscoveryDefConfig(pydantic.BaseModel):
    IpamOperatingRegionProperty: typing.Optional[list[CfnIPAMResourceDiscoveryDefIpamoperatingregionpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnIPAMResourceDiscoveryDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnIPAMResourceDiscoveryDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnIPAMResourceDiscoveryDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnIPAMResourceDiscoveryDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnIPAMResourceDiscoveryDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnIPAMResourceDiscoveryDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnIPAMResourceDiscoveryDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnIPAMResourceDiscoveryDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnIPAMResourceDiscoveryDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnIPAMResourceDiscoveryDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnIPAMResourceDiscoveryDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnIPAMResourceDiscoveryDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnIPAMResourceDiscoveryDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_is_default_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnIPAMResourceDiscoveryDefIpamoperatingregionpropertyParams(pydantic.BaseModel):
    region_name: str = pydantic.Field(..., description='')
    ...

class CfnIPAMResourceDiscoveryDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnIPAMResourceDiscoveryDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIPAMResourceDiscoveryDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnIPAMResourceDiscoveryDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIPAMResourceDiscoveryDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnIPAMResourceDiscoveryDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnIPAMResourceDiscoveryDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnIPAMResourceDiscoveryDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnIPAMResourceDiscoveryDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnIPAMResourceDiscoveryDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIPAMResourceDiscoveryDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnIPAMResourceDiscoveryDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnIPAMResourceDiscoveryDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIPAMResourceDiscoveryDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnIPAMResourceDiscoveryAssociation
class CfnIPAMResourceDiscoveryAssociationDef(BaseCfnResource):
    ipam_id: str = pydantic.Field(..., description='The IPAM ID.\n')
    ipam_resource_discovery_id: str = pydantic.Field(..., description='The resource discovery ID.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A tag is a label that you assign to an AWS resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your AWS costs.')
    _init_params: typing.ClassVar[list[str]] = ['ipam_id', 'ipam_resource_discovery_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnIPAMResourceDiscoveryAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnIPAMResourceDiscoveryAssociationDefConfig] = pydantic.Field(None)


class CfnIPAMResourceDiscoveryAssociationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnIPAMResourceDiscoveryAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnIPAMResourceDiscoveryAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnIPAMResourceDiscoveryAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnIPAMResourceDiscoveryAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnIPAMResourceDiscoveryAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnIPAMResourceDiscoveryAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnIPAMResourceDiscoveryAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnIPAMResourceDiscoveryAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnIPAMResourceDiscoveryAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnIPAMResourceDiscoveryAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnIPAMResourceDiscoveryAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnIPAMResourceDiscoveryAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnIPAMResourceDiscoveryAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_is_default_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnIPAMResourceDiscoveryAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnIPAMResourceDiscoveryAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIPAMResourceDiscoveryAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnIPAMResourceDiscoveryAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIPAMResourceDiscoveryAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnIPAMResourceDiscoveryAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnIPAMResourceDiscoveryAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnIPAMResourceDiscoveryAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnIPAMResourceDiscoveryAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnIPAMResourceDiscoveryAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIPAMResourceDiscoveryAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnIPAMResourceDiscoveryAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnIPAMResourceDiscoveryAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIPAMResourceDiscoveryAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnIPAMScope
class CfnIPAMScopeDef(BaseCfnResource):
    ipam_id: str = pydantic.Field(..., description="The ID of the IPAM for which you're creating this scope.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the scope.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.')
    _init_params: typing.ClassVar[list[str]] = ['ipam_id', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnIPAMScope'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnIPAMScopeDefConfig] = pydantic.Field(None)


class CfnIPAMScopeDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnIPAMScopeDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnIPAMScopeDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnIPAMScopeDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnIPAMScopeDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnIPAMScopeDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnIPAMScopeDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnIPAMScopeDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnIPAMScopeDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnIPAMScopeDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnIPAMScopeDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnIPAMScopeDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnIPAMScopeDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnIPAMScopeDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_is_default_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnIPAMScopeDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnIPAMScopeDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIPAMScopeDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnIPAMScopeDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIPAMScopeDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnIPAMScopeDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnIPAMScopeDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnIPAMScopeDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnIPAMScopeDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnIPAMScopeDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnIPAMScopeDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnIPAMScopeDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnIPAMScopeDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnIPAMScopeDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnKeyPair
class CfnKeyPairDef(BaseCfnResource):
    key_name: str = pydantic.Field(..., description='A unique name for the key pair. Constraints: Up to 255 ASCII characters\n')
    key_type: typing.Optional[str] = pydantic.Field(None, description='The type of key pair. Note that ED25519 keys are not supported for Windows instances. If the ``PublicKeyMaterial`` property is specified, the ``KeyType`` property is ignored, and the key type is inferred from the ``PublicKeyMaterial`` value. Default: ``rsa``\n')
    public_key_material: typing.Optional[str] = pydantic.Field(None, description='The public key material. The ``PublicKeyMaterial`` property is used to import a key pair. If this property is not specified, then a new key pair will be created.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to apply to the key pair.')
    _init_params: typing.ClassVar[list[str]] = ['key_name', 'key_type', 'public_key_material', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnKeyPair'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnKeyPairDefConfig] = pydantic.Field(None)


class CfnKeyPairDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnKeyPairDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnKeyPairDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnKeyPairDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnKeyPairDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnKeyPairDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnKeyPairDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnKeyPairDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnKeyPairDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnKeyPairDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnKeyPairDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnKeyPairDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnKeyPairDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnKeyPairDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnKeyPairDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnKeyPairDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnKeyPairDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnKeyPairDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnKeyPairDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnKeyPairDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnKeyPairDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnKeyPairDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnKeyPairDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnKeyPairDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnKeyPairDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnKeyPairDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnKeyPairDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnKeyPairDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplate
class CfnLaunchTemplateDef(BaseCfnResource):
    launch_template_data: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_LaunchTemplateDataPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The information for the launch template.\n')
    launch_template_name: typing.Optional[str] = pydantic.Field(None, description='A name for the launch template.\n')
    tag_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_LaunchTemplateTagSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The tags to apply to the launch template on creation. To tag the launch template, the resource type must be ``launch-template`` . .. epigraph:: To specify the tags for the resources that are created when an instance is launched, you must use the ``TagSpecifications`` parameter in the `launch template data <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestLaunchTemplateData.html>`_ structure.\n')
    version_description: typing.Optional[str] = pydantic.Field(None, description='A description for the first version of the launch template.')
    _init_params: typing.ClassVar[list[str]] = ['launch_template_data', 'launch_template_name', 'tag_specifications', 'version_description']
    _method_names: typing.ClassVar[list[str]] = ['AcceleratorCountProperty', 'AcceleratorTotalMemoryMiBProperty', 'BaselineEbsBandwidthMbpsProperty', 'BlockDeviceMappingProperty', 'CapacityReservationSpecificationProperty', 'CapacityReservationTargetProperty', 'CpuOptionsProperty', 'CreditSpecificationProperty', 'EbsProperty', 'ElasticGpuSpecificationProperty', 'EnclaveOptionsProperty', 'HibernationOptionsProperty', 'IamInstanceProfileProperty', 'InstanceMarketOptionsProperty', 'InstanceRequirementsProperty', 'Ipv4PrefixSpecificationProperty', 'Ipv6AddProperty', 'Ipv6PrefixSpecificationProperty', 'LaunchTemplateDataProperty', 'LaunchTemplateElasticInferenceAcceleratorProperty', 'LaunchTemplateTagSpecificationProperty', 'LicenseSpecificationProperty', 'MaintenanceOptionsProperty', 'MemoryGiBPerVCpuProperty', 'MemoryMiBProperty', 'MetadataOptionsProperty', 'MonitoringProperty', 'NetworkBandwidthGbpsProperty', 'NetworkInterfaceCountProperty', 'NetworkInterfaceProperty', 'PlacementProperty', 'PrivateDnsNameOptionsProperty', 'PrivateIpAddProperty', 'SpotOptionsProperty', 'TagSpecificationProperty', 'TotalLocalStorageGBProperty', 'VCpuCountProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplate'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnLaunchTemplateDefConfig] = pydantic.Field(None)


class CfnLaunchTemplateDefConfig(pydantic.BaseModel):
    AcceleratorCountProperty: typing.Optional[list[CfnLaunchTemplateDefAcceleratorcountpropertyParams]] = pydantic.Field(None, description='')
    AcceleratorTotalMemoryMiBProperty: typing.Optional[list[CfnLaunchTemplateDefAcceleratortotalmemorymibpropertyParams]] = pydantic.Field(None, description='')
    BaselineEbsBandwidthMbpsProperty: typing.Optional[list[CfnLaunchTemplateDefBaselineebsbandwidthmbpspropertyParams]] = pydantic.Field(None, description='')
    BlockDeviceMappingProperty: typing.Optional[list[CfnLaunchTemplateDefBlockdevicemappingpropertyParams]] = pydantic.Field(None, description='')
    CapacityReservationSpecificationProperty: typing.Optional[list[CfnLaunchTemplateDefCapacityreservationspecificationpropertyParams]] = pydantic.Field(None, description='')
    CapacityReservationTargetProperty: typing.Optional[list[CfnLaunchTemplateDefCapacityreservationtargetpropertyParams]] = pydantic.Field(None, description='')
    CpuOptionsProperty: typing.Optional[list[CfnLaunchTemplateDefCpuoptionspropertyParams]] = pydantic.Field(None, description='')
    CreditSpecificationProperty: typing.Optional[list[CfnLaunchTemplateDefCreditspecificationpropertyParams]] = pydantic.Field(None, description='')
    EbsProperty: typing.Optional[list[CfnLaunchTemplateDefEbspropertyParams]] = pydantic.Field(None, description='')
    ElasticGpuSpecificationProperty: typing.Optional[list[CfnLaunchTemplateDefElasticgpuspecificationpropertyParams]] = pydantic.Field(None, description='')
    EnclaveOptionsProperty: typing.Optional[list[CfnLaunchTemplateDefEnclaveoptionspropertyParams]] = pydantic.Field(None, description='')
    HibernationOptionsProperty: typing.Optional[list[CfnLaunchTemplateDefHibernationoptionspropertyParams]] = pydantic.Field(None, description='')
    IamInstanceProfileProperty: typing.Optional[list[CfnLaunchTemplateDefIaminstanceprofilepropertyParams]] = pydantic.Field(None, description='')
    InstanceMarketOptionsProperty: typing.Optional[list[CfnLaunchTemplateDefInstancemarketoptionspropertyParams]] = pydantic.Field(None, description='')
    InstanceRequirementsProperty: typing.Optional[list[CfnLaunchTemplateDefInstancerequirementspropertyParams]] = pydantic.Field(None, description='')
    Ipv4PrefixSpecificationProperty: typing.Optional[list[CfnLaunchTemplateDefIpv4PrefixspecificationpropertyParams]] = pydantic.Field(None, description='')
    Ipv6AddProperty: typing.Optional[list[CfnLaunchTemplateDefIpv6AddpropertyParams]] = pydantic.Field(None, description='')
    Ipv6PrefixSpecificationProperty: typing.Optional[list[CfnLaunchTemplateDefIpv6PrefixspecificationpropertyParams]] = pydantic.Field(None, description='')
    LaunchTemplateDataProperty: typing.Optional[list[CfnLaunchTemplateDefLaunchtemplatedatapropertyParams]] = pydantic.Field(None, description='')
    LaunchTemplateElasticInferenceAcceleratorProperty: typing.Optional[list[CfnLaunchTemplateDefLaunchtemplateelasticinferenceacceleratorpropertyParams]] = pydantic.Field(None, description='')
    LaunchTemplateTagSpecificationProperty: typing.Optional[list[CfnLaunchTemplateDefLaunchtemplatetagspecificationpropertyParams]] = pydantic.Field(None, description='')
    LicenseSpecificationProperty: typing.Optional[list[CfnLaunchTemplateDefLicensespecificationpropertyParams]] = pydantic.Field(None, description='')
    MaintenanceOptionsProperty: typing.Optional[list[CfnLaunchTemplateDefMaintenanceoptionspropertyParams]] = pydantic.Field(None, description='')
    MemoryGiBPerVCpuProperty: typing.Optional[list[CfnLaunchTemplateDefMemorygibpervcpupropertyParams]] = pydantic.Field(None, description='')
    MemoryMiBProperty: typing.Optional[list[CfnLaunchTemplateDefMemorymibpropertyParams]] = pydantic.Field(None, description='')
    MetadataOptionsProperty: typing.Optional[list[CfnLaunchTemplateDefMetadataoptionspropertyParams]] = pydantic.Field(None, description='')
    MonitoringProperty: typing.Optional[list[CfnLaunchTemplateDefMonitoringpropertyParams]] = pydantic.Field(None, description='')
    NetworkBandwidthGbpsProperty: typing.Optional[list[CfnLaunchTemplateDefNetworkbandwidthgbpspropertyParams]] = pydantic.Field(None, description='')
    NetworkInterfaceCountProperty: typing.Optional[list[CfnLaunchTemplateDefNetworkinterfacecountpropertyParams]] = pydantic.Field(None, description='')
    NetworkInterfaceProperty: typing.Optional[list[CfnLaunchTemplateDefNetworkinterfacepropertyParams]] = pydantic.Field(None, description='')
    PlacementProperty: typing.Optional[list[CfnLaunchTemplateDefPlacementpropertyParams]] = pydantic.Field(None, description='')
    PrivateDnsNameOptionsProperty: typing.Optional[list[CfnLaunchTemplateDefPrivatednsnameoptionspropertyParams]] = pydantic.Field(None, description='')
    PrivateIpAddProperty: typing.Optional[list[CfnLaunchTemplateDefPrivateipaddpropertyParams]] = pydantic.Field(None, description='')
    SpotOptionsProperty: typing.Optional[list[CfnLaunchTemplateDefSpotoptionspropertyParams]] = pydantic.Field(None, description='')
    TagSpecificationProperty: typing.Optional[list[CfnLaunchTemplateDefTagspecificationpropertyParams]] = pydantic.Field(None, description='')
    TotalLocalStorageGBProperty: typing.Optional[list[CfnLaunchTemplateDefTotallocalstoragegbpropertyParams]] = pydantic.Field(None, description='')
    VCpuCountProperty: typing.Optional[list[CfnLaunchTemplateDefVcpucountpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnLaunchTemplateDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnLaunchTemplateDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnLaunchTemplateDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnLaunchTemplateDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnLaunchTemplateDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnLaunchTemplateDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnLaunchTemplateDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnLaunchTemplateDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnLaunchTemplateDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnLaunchTemplateDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnLaunchTemplateDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnLaunchTemplateDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnLaunchTemplateDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnLaunchTemplateDefAcceleratorcountpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefAcceleratortotalmemorymibpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefBaselineebsbandwidthmbpspropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefBlockdevicemappingpropertyParams(pydantic.BaseModel):
    device_name: typing.Optional[str] = pydantic.Field(None, description='')
    ebs: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_EbsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    no_device: typing.Optional[str] = pydantic.Field(None, description='')
    virtual_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefCapacityreservationspecificationpropertyParams(pydantic.BaseModel):
    capacity_reservation_preference: typing.Optional[str] = pydantic.Field(None, description='')
    capacity_reservation_target: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_CapacityReservationTargetPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefCapacityreservationtargetpropertyParams(pydantic.BaseModel):
    capacity_reservation_id: typing.Optional[str] = pydantic.Field(None, description='')
    capacity_reservation_resource_group_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefCpuoptionspropertyParams(pydantic.BaseModel):
    amd_sev_snp: typing.Optional[str] = pydantic.Field(None, description='')
    core_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    threads_per_core: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefCreditspecificationpropertyParams(pydantic.BaseModel):
    cpu_credits: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefEbspropertyParams(pydantic.BaseModel):
    delete_on_termination: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    encrypted: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='')
    snapshot_id: typing.Optional[str] = pydantic.Field(None, description='')
    throughput: typing.Union[int, float, None] = pydantic.Field(None, description='')
    volume_size: typing.Union[int, float, None] = pydantic.Field(None, description='')
    volume_type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefElasticgpuspecificationpropertyParams(pydantic.BaseModel):
    type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefEnclaveoptionspropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefHibernationoptionspropertyParams(pydantic.BaseModel):
    configured: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefIaminstanceprofilepropertyParams(pydantic.BaseModel):
    arn: typing.Optional[str] = pydantic.Field(None, description='')
    name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefInstancemarketoptionspropertyParams(pydantic.BaseModel):
    market_type: typing.Optional[str] = pydantic.Field(None, description='')
    spot_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_SpotOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefInstancerequirementspropertyParams(pydantic.BaseModel):
    accelerator_count: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_AcceleratorCountPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    accelerator_manufacturers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    accelerator_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    accelerator_total_memory_mib: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_AcceleratorTotalMemoryMiBPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    accelerator_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    allowed_instance_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    bare_metal: typing.Optional[str] = pydantic.Field(None, description='')
    baseline_ebs_bandwidth_mbps: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_BaselineEbsBandwidthMbpsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    burstable_performance: typing.Optional[str] = pydantic.Field(None, description='')
    cpu_manufacturers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    excluded_instance_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    instance_generations: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    local_storage: typing.Optional[str] = pydantic.Field(None, description='')
    local_storage_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    memory_gib_per_v_cpu: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_MemoryGiBPerVCpuPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    memory_mib: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_MemoryMiBPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    network_bandwidth_gbps: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_NetworkBandwidthGbpsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    network_interface_count: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_NetworkInterfaceCountPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    on_demand_max_price_percentage_over_lowest_price: typing.Union[int, float, None] = pydantic.Field(None, description='')
    require_hibernate_support: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    spot_max_price_percentage_over_lowest_price: typing.Union[int, float, None] = pydantic.Field(None, description='')
    total_local_storage_gb: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_TotalLocalStorageGBPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    v_cpu_count: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_VCpuCountPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefIpv4PrefixspecificationpropertyParams(pydantic.BaseModel):
    ipv4_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefIpv6AddpropertyParams(pydantic.BaseModel):
    ipv6_address: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefIpv6PrefixspecificationpropertyParams(pydantic.BaseModel):
    ipv6_prefix: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefLaunchtemplatedatapropertyParams(pydantic.BaseModel):
    block_device_mappings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_BlockDeviceMappingPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    capacity_reservation_specification: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_CapacityReservationSpecificationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    cpu_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_CpuOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    credit_specification: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_CreditSpecificationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    disable_api_stop: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    disable_api_termination: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ebs_optimized: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    elastic_gpu_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_ElasticGpuSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    elastic_inference_accelerators: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_LaunchTemplateElasticInferenceAcceleratorPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    enclave_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_EnclaveOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    hibernation_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_HibernationOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    iam_instance_profile: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_IamInstanceProfilePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    image_id: typing.Optional[str] = pydantic.Field(None, description='')
    instance_initiated_shutdown_behavior: typing.Optional[str] = pydantic.Field(None, description='')
    instance_market_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_InstanceMarketOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    instance_requirements: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_InstanceRequirementsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    instance_type: typing.Optional[str] = pydantic.Field(None, description='')
    kernel_id: typing.Optional[str] = pydantic.Field(None, description='')
    key_name: typing.Optional[str] = pydantic.Field(None, description='')
    license_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_LicenseSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    maintenance_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_MaintenanceOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    metadata_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_MetadataOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    monitoring: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_MonitoringPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    network_interfaces: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_NetworkInterfacePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    placement: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_PlacementPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    private_dns_name_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_PrivateDnsNameOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ram_disk_id: typing.Optional[str] = pydantic.Field(None, description='')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    security_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    tag_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_TagSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    user_data: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefLaunchtemplateelasticinferenceacceleratorpropertyParams(pydantic.BaseModel):
    count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefLaunchtemplatetagspecificationpropertyParams(pydantic.BaseModel):
    resource_type: typing.Optional[str] = pydantic.Field(None, description='')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefLicensespecificationpropertyParams(pydantic.BaseModel):
    license_configuration_arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefMaintenanceoptionspropertyParams(pydantic.BaseModel):
    auto_recovery: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefMemorygibpervcpupropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefMemorymibpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefMetadataoptionspropertyParams(pydantic.BaseModel):
    http_endpoint: typing.Optional[str] = pydantic.Field(None, description='')
    http_protocol_ipv6: typing.Optional[str] = pydantic.Field(None, description='')
    http_put_response_hop_limit: typing.Union[int, float, None] = pydantic.Field(None, description='')
    http_tokens: typing.Optional[str] = pydantic.Field(None, description='')
    instance_metadata_tags: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefMonitoringpropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefNetworkbandwidthgbpspropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefNetworkinterfacecountpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefNetworkinterfacepropertyParams(pydantic.BaseModel):
    associate_carrier_ip_address: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    associate_public_ip_address: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    delete_on_termination: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    device_index: typing.Union[int, float, None] = pydantic.Field(None, description='')
    groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    interface_type: typing.Optional[str] = pydantic.Field(None, description='')
    ipv4_prefix_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ipv4_prefixes: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_Ipv4PrefixSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ipv6_address_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ipv6_addresses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_Ipv6AddPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ipv6_prefix_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ipv6_prefixes: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_Ipv6PrefixSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    network_card_index: typing.Union[int, float, None] = pydantic.Field(None, description='')
    network_interface_id: typing.Optional[str] = pydantic.Field(None, description='')
    private_ip_address: typing.Optional[str] = pydantic.Field(None, description='')
    private_ip_addresses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_PrivateIpAddPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    secondary_private_ip_address_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefPlacementpropertyParams(pydantic.BaseModel):
    affinity: typing.Optional[str] = pydantic.Field(None, description='')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='')
    group_id: typing.Optional[str] = pydantic.Field(None, description='')
    group_name: typing.Optional[str] = pydantic.Field(None, description='')
    host_id: typing.Optional[str] = pydantic.Field(None, description='')
    host_resource_group_arn: typing.Optional[str] = pydantic.Field(None, description='')
    partition_number: typing.Union[int, float, None] = pydantic.Field(None, description='')
    spread_domain: typing.Optional[str] = pydantic.Field(None, description='')
    tenancy: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefPrivatednsnameoptionspropertyParams(pydantic.BaseModel):
    enable_resource_name_dns_aaaa_record: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    enable_resource_name_dns_a_record: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    hostname_type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefPrivateipaddpropertyParams(pydantic.BaseModel):
    primary: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    private_ip_address: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefSpotoptionspropertyParams(pydantic.BaseModel):
    block_duration_minutes: typing.Union[int, float, None] = pydantic.Field(None, description='')
    instance_interruption_behavior: typing.Optional[str] = pydantic.Field(None, description='')
    max_price: typing.Optional[str] = pydantic.Field(None, description='')
    spot_instance_type: typing.Optional[str] = pydantic.Field(None, description='')
    valid_until: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefTagspecificationpropertyParams(pydantic.BaseModel):
    resource_type: typing.Optional[str] = pydantic.Field(None, description='')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefTotallocalstoragegbpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefVcpucountpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnLaunchTemplateDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnLaunchTemplateDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLaunchTemplateDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnLaunchTemplateDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLaunchTemplateDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnLaunchTemplateDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnLaunchTemplateDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnLaunchTemplateDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnLaunchTemplateDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnLaunchTemplateDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLaunchTemplateDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnLaunchTemplateDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnLaunchTemplateDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLaunchTemplateDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnLocalGatewayRoute
class CfnLocalGatewayRouteDef(BaseCfnResource):
    destination_cidr_block: str = pydantic.Field(..., description='The CIDR block used for destination matches.\n')
    local_gateway_route_table_id: str = pydantic.Field(..., description='The ID of the local gateway route table.\n')
    local_gateway_virtual_interface_group_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the virtual interface group.\n')
    network_interface_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the network interface.')
    _init_params: typing.ClassVar[list[str]] = ['destination_cidr_block', 'local_gateway_route_table_id', 'local_gateway_virtual_interface_group_id', 'network_interface_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLocalGatewayRoute'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnLocalGatewayRouteDefConfig] = pydantic.Field(None)


class CfnLocalGatewayRouteDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnLocalGatewayRouteDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnLocalGatewayRouteDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnLocalGatewayRouteDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnLocalGatewayRouteDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnLocalGatewayRouteDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnLocalGatewayRouteDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnLocalGatewayRouteDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnLocalGatewayRouteDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnLocalGatewayRouteDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnLocalGatewayRouteDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnLocalGatewayRouteDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnLocalGatewayRouteDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnLocalGatewayRouteDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnLocalGatewayRouteDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnLocalGatewayRouteDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLocalGatewayRouteDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnLocalGatewayRouteDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLocalGatewayRouteDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnLocalGatewayRouteDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnLocalGatewayRouteDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnLocalGatewayRouteDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnLocalGatewayRouteDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnLocalGatewayRouteDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLocalGatewayRouteDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnLocalGatewayRouteDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnLocalGatewayRouteDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLocalGatewayRouteDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnLocalGatewayRouteTable
class CfnLocalGatewayRouteTableDef(BaseCfnResource):
    local_gateway_id: str = pydantic.Field(..., description='The ID of the local gateway.\n')
    mode: typing.Optional[str] = pydantic.Field(None, description='The mode of the local gateway route table.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags assigned to the local gateway route table.')
    _init_params: typing.ClassVar[list[str]] = ['local_gateway_id', 'mode', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLocalGatewayRouteTable'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnLocalGatewayRouteTableDefConfig] = pydantic.Field(None)


class CfnLocalGatewayRouteTableDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnLocalGatewayRouteTableDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnLocalGatewayRouteTableDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnLocalGatewayRouteTableDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnLocalGatewayRouteTableDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnLocalGatewayRouteTableDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnLocalGatewayRouteTableDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnLocalGatewayRouteTableDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnLocalGatewayRouteTableDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnLocalGatewayRouteTableDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnLocalGatewayRouteTableDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnLocalGatewayRouteTableDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnLocalGatewayRouteTableDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnLocalGatewayRouteTableDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnLocalGatewayRouteTableDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnLocalGatewayRouteTableDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLocalGatewayRouteTableDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnLocalGatewayRouteTableDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLocalGatewayRouteTableDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnLocalGatewayRouteTableDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnLocalGatewayRouteTableDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnLocalGatewayRouteTableDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnLocalGatewayRouteTableDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnLocalGatewayRouteTableDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLocalGatewayRouteTableDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnLocalGatewayRouteTableDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnLocalGatewayRouteTableDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLocalGatewayRouteTableDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation
class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDef(BaseCfnResource):
    local_gateway_route_table_id: str = pydantic.Field(..., description='The ID of the local gateway route table.\n')
    local_gateway_virtual_interface_group_id: str = pydantic.Field(..., description='The ID of the virtual interface group.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags assigned to the association.')
    _init_params: typing.ClassVar[list[str]] = ['local_gateway_route_table_id', 'local_gateway_virtual_interface_group_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefConfig] = pydantic.Field(None)


class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnLocalGatewayRouteTableVPCAssociation
class CfnLocalGatewayRouteTableVPCAssociationDef(BaseCfnResource):
    local_gateway_route_table_id: str = pydantic.Field(..., description='The ID of the local gateway route table.\n')
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags assigned to the association.')
    _init_params: typing.ClassVar[list[str]] = ['local_gateway_route_table_id', 'vpc_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLocalGatewayRouteTableVPCAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnLocalGatewayRouteTableVPCAssociationDefConfig] = pydantic.Field(None)


class CfnLocalGatewayRouteTableVPCAssociationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnLocalGatewayRouteTableVPCAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnLocalGatewayRouteTableVPCAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnLocalGatewayRouteTableVPCAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnLocalGatewayRouteTableVPCAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnLocalGatewayRouteTableVPCAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnLocalGatewayRouteTableVPCAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnLocalGatewayRouteTableVPCAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnLocalGatewayRouteTableVPCAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnLocalGatewayRouteTableVPCAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnLocalGatewayRouteTableVPCAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnLocalGatewayRouteTableVPCAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnLocalGatewayRouteTableVPCAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnLocalGatewayRouteTableVPCAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnLocalGatewayRouteTableVPCAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnLocalGatewayRouteTableVPCAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLocalGatewayRouteTableVPCAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnLocalGatewayRouteTableVPCAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLocalGatewayRouteTableVPCAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnLocalGatewayRouteTableVPCAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnLocalGatewayRouteTableVPCAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnLocalGatewayRouteTableVPCAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnLocalGatewayRouteTableVPCAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnLocalGatewayRouteTableVPCAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnLocalGatewayRouteTableVPCAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnLocalGatewayRouteTableVPCAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnLocalGatewayRouteTableVPCAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnLocalGatewayRouteTableVPCAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnNatGateway
class CfnNatGatewayDef(BaseCfnResource):
    subnet_id: str = pydantic.Field(..., description='The ID of the subnet in which the NAT gateway is located.\n')
    allocation_id: typing.Optional[str] = pydantic.Field(None, description="[Public NAT gateway only] The allocation ID of the Elastic IP address that's associated with the NAT gateway. This property is required for a public NAT gateway and cannot be specified with a private NAT gateway.\n")
    connectivity_type: typing.Optional[str] = pydantic.Field(None, description='Indicates whether the NAT gateway supports public or private connectivity. The default is public connectivity.\n')
    max_drain_duration_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum amount of time to wait (in seconds) before forcibly releasing the IP addresses if connections are still in progress. Default value is 350 seconds.\n')
    private_ip_address: typing.Optional[str] = pydantic.Field(None, description="The private IPv4 address to assign to the NAT gateway. If you don't provide an address, a private IPv4 address will be automatically assigned.\n")
    secondary_allocation_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Secondary EIP allocation IDs. For more information, see `Create a NAT gateway <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating>`_ in the *Amazon VPC User Guide* .\n')
    secondary_private_ip_address_count: typing.Union[int, float, None] = pydantic.Field(None, description='[Private NAT gateway only] The number of secondary private IPv4 addresses you want to assign to the NAT gateway. For more information about secondary addresses, see `Create a NAT gateway <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating>`_ in the *Amazon Virtual Private Cloud User Guide* . .. epigraph:: ``SecondaryPrivateIpAddressCount`` and ``SecondaryPrivateIpAddresses`` cannot be set at the same time.\n')
    secondary_private_ip_addresses: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Secondary private IPv4 addresses. For more information about secondary addresses, see `Create a NAT gateway <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating>`_ in the *Amazon Virtual Private Cloud User Guide* . .. epigraph:: ``SecondaryPrivateIpAddressCount`` and ``SecondaryPrivateIpAddresses`` cannot be set at the same time.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the NAT gateway.')
    _init_params: typing.ClassVar[list[str]] = ['subnet_id', 'allocation_id', 'connectivity_type', 'max_drain_duration_seconds', 'private_ip_address', 'secondary_allocation_ids', 'secondary_private_ip_address_count', 'secondary_private_ip_addresses', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNatGateway'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnNatGatewayDefConfig] = pydantic.Field(None)


class CfnNatGatewayDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnNatGatewayDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnNatGatewayDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnNatGatewayDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnNatGatewayDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnNatGatewayDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnNatGatewayDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnNatGatewayDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnNatGatewayDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnNatGatewayDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnNatGatewayDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnNatGatewayDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnNatGatewayDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnNatGatewayDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnNatGatewayDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnNatGatewayDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNatGatewayDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnNatGatewayDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNatGatewayDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnNatGatewayDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnNatGatewayDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnNatGatewayDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnNatGatewayDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnNatGatewayDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNatGatewayDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnNatGatewayDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnNatGatewayDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNatGatewayDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnNetworkAcl
class CfnNetworkAclDef(BaseCfnResource):
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC for the network ACL.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the network ACL.')
    _init_params: typing.ClassVar[list[str]] = ['vpc_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkAcl'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnNetworkAclDefConfig] = pydantic.Field(None)


class CfnNetworkAclDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnNetworkAclDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnNetworkAclDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnNetworkAclDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnNetworkAclDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnNetworkAclDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnNetworkAclDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnNetworkAclDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnNetworkAclDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnNetworkAclDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnNetworkAclDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnNetworkAclDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnNetworkAclDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnNetworkAclDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnNetworkAclDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnNetworkAclDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNetworkAclDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnNetworkAclDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNetworkAclDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnNetworkAclDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnNetworkAclDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnNetworkAclDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnNetworkAclDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnNetworkAclDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNetworkAclDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnNetworkAclDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnNetworkAclDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNetworkAclDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnNetworkAclEntry
class CfnNetworkAclEntryDef(BaseCfnResource):
    network_acl_id: str = pydantic.Field(..., description='The ID of the ACL for the entry.\n')
    protocol: typing.Union[int, float] = pydantic.Field(..., description='The IP protocol that the rule applies to. You must specify -1 or a protocol number. You can specify -1 for all protocols. .. epigraph:: If you specify -1, all ports are opened and the ``PortRange`` property is ignored.\n')
    rule_action: str = pydantic.Field(..., description='Whether to allow or deny traffic that matches the rule; valid values are "allow" or "deny".\n')
    rule_number: typing.Union[int, float] = pydantic.Field(..., description="Rule number to assign to the entry, such as 100. ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.\n")
    cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv4 CIDR range to allow or deny, in CIDR notation (for example, 172.16.0.0/24). Requirement is conditional: You must specify the ``CidrBlock`` or ``Ipv6CidrBlock`` property.\n')
    egress: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Whether this rule applies to egress traffic from the subnet ( ``true`` ) or ingress traffic to the subnet ( ``false`` ). By default, AWS CloudFormation specifies ``false`` .\n')
    icmp: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkAclEntry_IcmpPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The Internet Control Message Protocol (ICMP) code and type. Requirement is conditional: Required if specifying 1 (ICMP) for the protocol parameter.\n')
    ipv6_cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv6 network range to allow or deny, in CIDR notation. Requirement is conditional: You must specify the ``CidrBlock`` or ``Ipv6CidrBlock`` property.\n')
    port_range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkAclEntry_PortRangePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The range of port numbers for the UDP/TCP protocol. Conditional required if specifying 6 (TCP) or 17 (UDP) for the protocol parameter.')
    _init_params: typing.ClassVar[list[str]] = ['network_acl_id', 'protocol', 'rule_action', 'rule_number', 'cidr_block', 'egress', 'icmp', 'ipv6_cidr_block', 'port_range']
    _method_names: typing.ClassVar[list[str]] = ['IcmpProperty', 'PortRangeProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkAclEntry'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnNetworkAclEntryDefConfig] = pydantic.Field(None)


class CfnNetworkAclEntryDefConfig(pydantic.BaseModel):
    IcmpProperty: typing.Optional[list[CfnNetworkAclEntryDefIcmppropertyParams]] = pydantic.Field(None, description='')
    PortRangeProperty: typing.Optional[list[CfnNetworkAclEntryDefPortrangepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnNetworkAclEntryDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnNetworkAclEntryDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnNetworkAclEntryDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnNetworkAclEntryDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnNetworkAclEntryDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnNetworkAclEntryDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnNetworkAclEntryDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnNetworkAclEntryDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnNetworkAclEntryDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnNetworkAclEntryDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnNetworkAclEntryDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnNetworkAclEntryDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnNetworkAclEntryDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnNetworkAclEntryDefIcmppropertyParams(pydantic.BaseModel):
    code: typing.Union[int, float, None] = pydantic.Field(None, description='')
    type: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnNetworkAclEntryDefPortrangepropertyParams(pydantic.BaseModel):
    from_: typing.Union[int, float, None] = pydantic.Field(None, description='')
    to: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnNetworkAclEntryDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnNetworkAclEntryDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNetworkAclEntryDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnNetworkAclEntryDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNetworkAclEntryDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnNetworkAclEntryDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnNetworkAclEntryDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnNetworkAclEntryDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnNetworkAclEntryDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnNetworkAclEntryDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNetworkAclEntryDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnNetworkAclEntryDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnNetworkAclEntryDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNetworkAclEntryDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAccessScope
class CfnNetworkInsightsAccessScopeDef(BaseCfnResource):
    exclude_paths: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAccessScope_AccessScopePathRequestPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The paths to exclude.\n')
    match_paths: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAccessScope_AccessScopePathRequestPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The paths to match.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags.')
    _init_params: typing.ClassVar[list[str]] = ['exclude_paths', 'match_paths', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['AccessScopePathRequestProperty', 'PacketHeaderStatementRequestProperty', 'PathStatementRequestProperty', 'ResourceStatementRequestProperty', 'ThroughResourcesStatementRequestProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAccessScope'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnNetworkInsightsAccessScopeDefConfig] = pydantic.Field(None)


class CfnNetworkInsightsAccessScopeDefConfig(pydantic.BaseModel):
    AccessScopePathRequestProperty: typing.Optional[list[CfnNetworkInsightsAccessScopeDefAccessscopepathrequestpropertyParams]] = pydantic.Field(None, description='')
    PacketHeaderStatementRequestProperty: typing.Optional[list[CfnNetworkInsightsAccessScopeDefPacketheaderstatementrequestpropertyParams]] = pydantic.Field(None, description='')
    PathStatementRequestProperty: typing.Optional[list[CfnNetworkInsightsAccessScopeDefPathstatementrequestpropertyParams]] = pydantic.Field(None, description='')
    ResourceStatementRequestProperty: typing.Optional[list[CfnNetworkInsightsAccessScopeDefResourcestatementrequestpropertyParams]] = pydantic.Field(None, description='')
    ThroughResourcesStatementRequestProperty: typing.Optional[list[CfnNetworkInsightsAccessScopeDefThroughresourcesstatementrequestpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnNetworkInsightsAccessScopeDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnNetworkInsightsAccessScopeDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnNetworkInsightsAccessScopeDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnNetworkInsightsAccessScopeDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnNetworkInsightsAccessScopeDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnNetworkInsightsAccessScopeDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnNetworkInsightsAccessScopeDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnNetworkInsightsAccessScopeDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnNetworkInsightsAccessScopeDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnNetworkInsightsAccessScopeDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnNetworkInsightsAccessScopeDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnNetworkInsightsAccessScopeDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnNetworkInsightsAccessScopeDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnNetworkInsightsAccessScopeDefAccessscopepathrequestpropertyParams(pydantic.BaseModel):
    destination: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAccessScope_PathStatementRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    source: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAccessScope_PathStatementRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    through_resources: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAccessScope_ThroughResourcesStatementRequestPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnNetworkInsightsAccessScopeDefPacketheaderstatementrequestpropertyParams(pydantic.BaseModel):
    destination_addresses: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    destination_ports: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    destination_prefix_lists: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    protocols: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    source_addresses: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    source_ports: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    source_prefix_lists: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnNetworkInsightsAccessScopeDefPathstatementrequestpropertyParams(pydantic.BaseModel):
    packet_header_statement: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAccessScope_PacketHeaderStatementRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    resource_statement: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAccessScope_ResourceStatementRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnNetworkInsightsAccessScopeDefResourcestatementrequestpropertyParams(pydantic.BaseModel):
    resources: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    resource_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnNetworkInsightsAccessScopeDefThroughresourcesstatementrequestpropertyParams(pydantic.BaseModel):
    resource_statement: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAccessScope_ResourceStatementRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnNetworkInsightsAccessScopeDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnNetworkInsightsAccessScopeDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNetworkInsightsAccessScopeDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnNetworkInsightsAccessScopeDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNetworkInsightsAccessScopeDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnNetworkInsightsAccessScopeDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnNetworkInsightsAccessScopeDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnNetworkInsightsAccessScopeDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnNetworkInsightsAccessScopeDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnNetworkInsightsAccessScopeDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNetworkInsightsAccessScopeDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnNetworkInsightsAccessScopeDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnNetworkInsightsAccessScopeDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNetworkInsightsAccessScopeDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAccessScopeAnalysis
class CfnNetworkInsightsAccessScopeAnalysisDef(BaseCfnResource):
    network_insights_access_scope_id: str = pydantic.Field(..., description='The ID of the Network Access Scope.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags.')
    _init_params: typing.ClassVar[list[str]] = ['network_insights_access_scope_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAccessScopeAnalysis'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnNetworkInsightsAccessScopeAnalysisDefConfig] = pydantic.Field(None)


class CfnNetworkInsightsAccessScopeAnalysisDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnNetworkInsightsAccessScopeAnalysisDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnNetworkInsightsAccessScopeAnalysisDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnNetworkInsightsAccessScopeAnalysisDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnNetworkInsightsAccessScopeAnalysisDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnNetworkInsightsAccessScopeAnalysisDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnNetworkInsightsAccessScopeAnalysisDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnNetworkInsightsAccessScopeAnalysisDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnNetworkInsightsAccessScopeAnalysisDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnNetworkInsightsAccessScopeAnalysisDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnNetworkInsightsAccessScopeAnalysisDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnNetworkInsightsAccessScopeAnalysisDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnNetworkInsightsAccessScopeAnalysisDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnNetworkInsightsAccessScopeAnalysisDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnNetworkInsightsAccessScopeAnalysisDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnNetworkInsightsAccessScopeAnalysisDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNetworkInsightsAccessScopeAnalysisDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnNetworkInsightsAccessScopeAnalysisDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNetworkInsightsAccessScopeAnalysisDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnNetworkInsightsAccessScopeAnalysisDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnNetworkInsightsAccessScopeAnalysisDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnNetworkInsightsAccessScopeAnalysisDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnNetworkInsightsAccessScopeAnalysisDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnNetworkInsightsAccessScopeAnalysisDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNetworkInsightsAccessScopeAnalysisDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnNetworkInsightsAccessScopeAnalysisDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnNetworkInsightsAccessScopeAnalysisDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNetworkInsightsAccessScopeAnalysisDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis
class CfnNetworkInsightsAnalysisDef(BaseCfnResource):
    network_insights_path_id: str = pydantic.Field(..., description='The ID of the path.\n')
    additional_accounts: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The member accounts that contain resources that the path can traverse.\n')
    filter_in_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Amazon Resource Names (ARN) of the resources that the path must traverse.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to apply.')
    _init_params: typing.ClassVar[list[str]] = ['network_insights_path_id', 'additional_accounts', 'filter_in_arns', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['AdditionalDetailProperty', 'AlternatePathHintProperty', 'AnalysisAclRuleProperty', 'AnalysisComponentProperty', 'AnalysisLoadBalancerListenerProperty', 'AnalysisLoadBalancerTargetProperty', 'AnalysisPacketHeaderProperty', 'AnalysisRouteTableRouteProperty', 'AnalysisSecurityGroupRuleProperty', 'ExplanationProperty', 'PathComponentProperty', 'PortRangeProperty', 'TransitGatewayRouteTableRouteProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAnalysis'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnNetworkInsightsAnalysisDefConfig] = pydantic.Field(None)


class CfnNetworkInsightsAnalysisDefConfig(pydantic.BaseModel):
    AdditionalDetailProperty: typing.Optional[list[CfnNetworkInsightsAnalysisDefAdditionaldetailpropertyParams]] = pydantic.Field(None, description='')
    AlternatePathHintProperty: typing.Optional[list[CfnNetworkInsightsAnalysisDefAlternatepathhintpropertyParams]] = pydantic.Field(None, description='')
    AnalysisAclRuleProperty: typing.Optional[list[CfnNetworkInsightsAnalysisDefAnalysisaclrulepropertyParams]] = pydantic.Field(None, description='')
    AnalysisComponentProperty: typing.Optional[list[CfnNetworkInsightsAnalysisDefAnalysiscomponentpropertyParams]] = pydantic.Field(None, description='')
    AnalysisLoadBalancerListenerProperty: typing.Optional[list[CfnNetworkInsightsAnalysisDefAnalysisloadbalancerlistenerpropertyParams]] = pydantic.Field(None, description='')
    AnalysisLoadBalancerTargetProperty: typing.Optional[list[CfnNetworkInsightsAnalysisDefAnalysisloadbalancertargetpropertyParams]] = pydantic.Field(None, description='')
    AnalysisPacketHeaderProperty: typing.Optional[list[CfnNetworkInsightsAnalysisDefAnalysispacketheaderpropertyParams]] = pydantic.Field(None, description='')
    AnalysisRouteTableRouteProperty: typing.Optional[list[CfnNetworkInsightsAnalysisDefAnalysisroutetableroutepropertyParams]] = pydantic.Field(None, description='')
    AnalysisSecurityGroupRuleProperty: typing.Optional[list[CfnNetworkInsightsAnalysisDefAnalysissecuritygrouprulepropertyParams]] = pydantic.Field(None, description='')
    ExplanationProperty: typing.Optional[list[CfnNetworkInsightsAnalysisDefExplanationpropertyParams]] = pydantic.Field(None, description='')
    PathComponentProperty: typing.Optional[list[CfnNetworkInsightsAnalysisDefPathcomponentpropertyParams]] = pydantic.Field(None, description='')
    PortRangeProperty: typing.Optional[list[CfnNetworkInsightsAnalysisDefPortrangepropertyParams]] = pydantic.Field(None, description='')
    TransitGatewayRouteTableRouteProperty: typing.Optional[list[CfnNetworkInsightsAnalysisDefTransitgatewayroutetableroutepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnNetworkInsightsAnalysisDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnNetworkInsightsAnalysisDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnNetworkInsightsAnalysisDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnNetworkInsightsAnalysisDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnNetworkInsightsAnalysisDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnNetworkInsightsAnalysisDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnNetworkInsightsAnalysisDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnNetworkInsightsAnalysisDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnNetworkInsightsAnalysisDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnNetworkInsightsAnalysisDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnNetworkInsightsAnalysisDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnNetworkInsightsAnalysisDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnNetworkInsightsAnalysisDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_alternate_path_hints_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_explanations_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_forward_path_components_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_network_path_found_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_return_path_components_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnNetworkInsightsAnalysisDefAdditionaldetailpropertyParams(pydantic.BaseModel):
    additional_detail_type: typing.Optional[str] = pydantic.Field(None, description='')
    component: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    load_balancers: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    service_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnNetworkInsightsAnalysisDefAlternatepathhintpropertyParams(pydantic.BaseModel):
    component_arn: typing.Optional[str] = pydantic.Field(None, description='')
    component_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnNetworkInsightsAnalysisDefAnalysisaclrulepropertyParams(pydantic.BaseModel):
    cidr: typing.Optional[str] = pydantic.Field(None, description='')
    egress: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    port_range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_PortRangePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    protocol: typing.Optional[str] = pydantic.Field(None, description='')
    rule_action: typing.Optional[str] = pydantic.Field(None, description='')
    rule_number: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnNetworkInsightsAnalysisDefAnalysiscomponentpropertyParams(pydantic.BaseModel):
    arn: typing.Optional[str] = pydantic.Field(None, description='')
    id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnNetworkInsightsAnalysisDefAnalysisloadbalancerlistenerpropertyParams(pydantic.BaseModel):
    instance_port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    load_balancer_port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnNetworkInsightsAnalysisDefAnalysisloadbalancertargetpropertyParams(pydantic.BaseModel):
    address: typing.Optional[str] = pydantic.Field(None, description='')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='')
    instance: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnNetworkInsightsAnalysisDefAnalysispacketheaderpropertyParams(pydantic.BaseModel):
    destination_addresses: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    destination_port_ranges: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_PortRangePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    protocol: typing.Optional[str] = pydantic.Field(None, description='')
    source_addresses: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    source_port_ranges: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_PortRangePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnNetworkInsightsAnalysisDefAnalysisroutetableroutepropertyParams(pydantic.BaseModel):
    destination_cidr: typing.Optional[str] = pydantic.Field(None, description='')
    destination_prefix_list_id: typing.Optional[str] = pydantic.Field(None, description='')
    egress_only_internet_gateway_id: typing.Optional[str] = pydantic.Field(None, description='')
    gateway_id: typing.Optional[str] = pydantic.Field(None, description='')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='')
    nat_gateway_id: typing.Optional[str] = pydantic.Field(None, description='')
    network_interface_id: typing.Optional[str] = pydantic.Field(None, description='')
    origin: typing.Optional[str] = pydantic.Field(None, description='')
    state: typing.Optional[str] = pydantic.Field(None, description='')
    transit_gateway_id: typing.Optional[str] = pydantic.Field(None, description='')
    vpc_peering_connection_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnNetworkInsightsAnalysisDefAnalysissecuritygrouprulepropertyParams(pydantic.BaseModel):
    cidr: typing.Optional[str] = pydantic.Field(None, description='')
    direction: typing.Optional[str] = pydantic.Field(None, description='')
    port_range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_PortRangePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    prefix_list_id: typing.Optional[str] = pydantic.Field(None, description='')
    protocol: typing.Optional[str] = pydantic.Field(None, description='')
    security_group_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnNetworkInsightsAnalysisDefExplanationpropertyParams(pydantic.BaseModel):
    acl: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    acl_rule: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisAclRulePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    address: typing.Optional[str] = pydantic.Field(None, description='')
    addresses: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    attached_to: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    availability_zones: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    cidrs: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    classic_load_balancer_listener: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisLoadBalancerListenerPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    component: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    component_account: typing.Optional[str] = pydantic.Field(None, description='')
    component_region: typing.Optional[str] = pydantic.Field(None, description='')
    customer_gateway: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    destination: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    destination_vpc: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    direction: typing.Optional[str] = pydantic.Field(None, description='')
    elastic_load_balancer_listener: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    explanation_code: typing.Optional[str] = pydantic.Field(None, description='')
    ingress_route_table: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    internet_gateway: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    load_balancer_arn: typing.Optional[str] = pydantic.Field(None, description='')
    load_balancer_listener_port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    load_balancer_target: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisLoadBalancerTargetPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    load_balancer_target_group: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    load_balancer_target_groups: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    load_balancer_target_port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    missing_component: typing.Optional[str] = pydantic.Field(None, description='')
    nat_gateway: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    network_interface: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    packet_field: typing.Optional[str] = pydantic.Field(None, description='')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    port_ranges: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_PortRangePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    prefix_list: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    protocols: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    route_table: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    route_table_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisRouteTableRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    security_group: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    security_group_rule: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisSecurityGroupRulePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    security_groups: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    source_vpc: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    state: typing.Optional[str] = pydantic.Field(None, description='')
    subnet: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    subnet_route_table: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    transit_gateway: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    transit_gateway_attachment: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    transit_gateway_route_table: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    transit_gateway_route_table_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_TransitGatewayRouteTableRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    vpc: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    vpc_endpoint: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    vpc_peering_connection: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    vpn_connection: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    vpn_gateway: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnNetworkInsightsAnalysisDefPathcomponentpropertyParams(pydantic.BaseModel):
    acl_rule: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisAclRulePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    additional_details: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AdditionalDetailPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    component: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    destination_vpc: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    elastic_load_balancer_listener: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    explanations: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_ExplanationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    inbound_header: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisPacketHeaderPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    outbound_header: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisPacketHeaderPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    route_table_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisRouteTableRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    security_group_rule: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisSecurityGroupRulePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    sequence_number: typing.Union[int, float, None] = pydantic.Field(None, description='')
    service_name: typing.Optional[str] = pydantic.Field(None, description='')
    source_vpc: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    subnet: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    transit_gateway: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    transit_gateway_route_table_route: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_TransitGatewayRouteTableRoutePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    vpc: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnNetworkInsightsAnalysisDefPortrangepropertyParams(pydantic.BaseModel):
    from_: typing.Union[int, float, None] = pydantic.Field(None, description='')
    to: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnNetworkInsightsAnalysisDefTransitgatewayroutetableroutepropertyParams(pydantic.BaseModel):
    attachment_id: typing.Optional[str] = pydantic.Field(None, description='')
    destination_cidr: typing.Optional[str] = pydantic.Field(None, description='')
    prefix_list_id: typing.Optional[str] = pydantic.Field(None, description='')
    resource_id: typing.Optional[str] = pydantic.Field(None, description='')
    resource_type: typing.Optional[str] = pydantic.Field(None, description='')
    route_origin: typing.Optional[str] = pydantic.Field(None, description='')
    state: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnNetworkInsightsAnalysisDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnNetworkInsightsAnalysisDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNetworkInsightsAnalysisDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnNetworkInsightsAnalysisDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNetworkInsightsAnalysisDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnNetworkInsightsAnalysisDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnNetworkInsightsAnalysisDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnNetworkInsightsAnalysisDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnNetworkInsightsAnalysisDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnNetworkInsightsAnalysisDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNetworkInsightsAnalysisDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnNetworkInsightsAnalysisDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnNetworkInsightsAnalysisDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNetworkInsightsAnalysisDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsPath
class CfnNetworkInsightsPathDef(BaseCfnResource):
    protocol: str = pydantic.Field(..., description='The protocol.\n')
    source: str = pydantic.Field(..., description='The ID or ARN of the source. If the resource is in another account, you must specify an ARN.\n')
    destination: typing.Optional[str] = pydantic.Field(None, description='The ID or ARN of the destination. If the resource is in another account, you must specify an ARN.\n')
    destination_ip: typing.Optional[str] = pydantic.Field(None, description='The IP address of the destination.\n')
    destination_port: typing.Union[int, float, None] = pydantic.Field(None, description='The destination port.\n')
    filter_at_destination: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsPath_PathFilterPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Scopes the analysis to network paths that match specific filters at the destination. If you specify this parameter, you can't specify the parameter for the destination IP address.\n")
    filter_at_source: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsPath_PathFilterPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Scopes the analysis to network paths that match specific filters at the source. If you specify this parameter, you can't specify the parameters for the source IP address or the destination port.\n")
    source_ip: typing.Optional[str] = pydantic.Field(None, description='The IP address of the source.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to add to the path.')
    _init_params: typing.ClassVar[list[str]] = ['protocol', 'source', 'destination', 'destination_ip', 'destination_port', 'filter_at_destination', 'filter_at_source', 'source_ip', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['FilterPortRangeProperty', 'PathFilterProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsPath'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnNetworkInsightsPathDefConfig] = pydantic.Field(None)


class CfnNetworkInsightsPathDefConfig(pydantic.BaseModel):
    FilterPortRangeProperty: typing.Optional[list[CfnNetworkInsightsPathDefFilterportrangepropertyParams]] = pydantic.Field(None, description='')
    PathFilterProperty: typing.Optional[list[CfnNetworkInsightsPathDefPathfilterpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnNetworkInsightsPathDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnNetworkInsightsPathDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnNetworkInsightsPathDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnNetworkInsightsPathDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnNetworkInsightsPathDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnNetworkInsightsPathDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnNetworkInsightsPathDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnNetworkInsightsPathDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnNetworkInsightsPathDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnNetworkInsightsPathDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnNetworkInsightsPathDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnNetworkInsightsPathDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnNetworkInsightsPathDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnNetworkInsightsPathDefFilterportrangepropertyParams(pydantic.BaseModel):
    from_port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    to_port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnNetworkInsightsPathDefPathfilterpropertyParams(pydantic.BaseModel):
    destination_address: typing.Optional[str] = pydantic.Field(None, description='')
    destination_port_range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsPath_FilterPortRangePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    source_address: typing.Optional[str] = pydantic.Field(None, description='')
    source_port_range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsPath_FilterPortRangePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnNetworkInsightsPathDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnNetworkInsightsPathDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNetworkInsightsPathDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnNetworkInsightsPathDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNetworkInsightsPathDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnNetworkInsightsPathDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnNetworkInsightsPathDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnNetworkInsightsPathDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnNetworkInsightsPathDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnNetworkInsightsPathDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNetworkInsightsPathDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnNetworkInsightsPathDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnNetworkInsightsPathDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNetworkInsightsPathDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInterface
class CfnNetworkInterfaceDef(BaseCfnResource):
    subnet_id: str = pydantic.Field(..., description='The ID of the subnet to associate with the network interface.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the network interface.\n')
    group_set: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The security group IDs associated with this network interface.\n')
    interface_type: typing.Optional[str] = pydantic.Field(None, description='The type of network interface. The default is ``interface`` . The supported values are ``efa`` and ``trunk`` .\n')
    ipv6_address_count: typing.Union[int, float, None] = pydantic.Field(None, description="The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. To specify specific IPv6 addresses, use the ``Ipv6Addresses`` property and don't specify this property.\n")
    ipv6_addresses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInterface_InstanceIpv6AddressPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet to associate with the network interface. If you're specifying a number of IPv6 addresses, use the ``Ipv6AddressCount`` property and don't specify this property.\n")
    private_ip_address: typing.Optional[str] = pydantic.Field(None, description='Assigns a single private IP address to the network interface, which is used as the primary private IP address. If you want to specify multiple private IP address, use the ``PrivateIpAddresses`` property.\n')
    private_ip_addresses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInterface_PrivateIpAddressSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Assigns private IP addresses to the network interface. You can specify a primary private IP address by setting the value of the ``Primary`` property to ``true`` in the ``PrivateIpAddressSpecification`` property. If you want EC2 to automatically assign private IP addresses, use the ``SecondaryPrivateIpAddressCount`` property and do not specify this property.\n')
    secondary_private_ip_address_count: typing.Union[int, float, None] = pydantic.Field(None, description="The number of secondary private IPv4 addresses to assign to a network interface. When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using ``privateIpAddresses`` . You can't specify a count of private IPv4 addresses if you've specified one of the following: specific private IPv4 addresses, specific IPv4 prefixes, or a count of IPv4 prefixes.\n")
    source_dest_check: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives. If the value is ``true`` , source/destination checks are enabled; otherwise, they are disabled. The default value is ``true`` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An arbitrary set of tags (key-value pairs) for this network interface.')
    _init_params: typing.ClassVar[list[str]] = ['subnet_id', 'description', 'group_set', 'interface_type', 'ipv6_address_count', 'ipv6_addresses', 'private_ip_address', 'private_ip_addresses', 'secondary_private_ip_address_count', 'source_dest_check', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['InstanceIpv6AddressProperty', 'PrivateIpAddressSpecificationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInterface'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnNetworkInterfaceDefConfig] = pydantic.Field(None)


class CfnNetworkInterfaceDefConfig(pydantic.BaseModel):
    InstanceIpv6AddressProperty: typing.Optional[list[CfnNetworkInterfaceDefInstanceipv6AddresspropertyParams]] = pydantic.Field(None, description='')
    PrivateIpAddressSpecificationProperty: typing.Optional[list[CfnNetworkInterfaceDefPrivateipaddressspecificationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnNetworkInterfaceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnNetworkInterfaceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnNetworkInterfaceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnNetworkInterfaceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnNetworkInterfaceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnNetworkInterfaceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnNetworkInterfaceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnNetworkInterfaceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnNetworkInterfaceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnNetworkInterfaceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnNetworkInterfaceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnNetworkInterfaceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnNetworkInterfaceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnNetworkInterfaceDefInstanceipv6AddresspropertyParams(pydantic.BaseModel):
    ipv6_address: str = pydantic.Field(..., description='')
    ...

class CfnNetworkInterfaceDefPrivateipaddressspecificationpropertyParams(pydantic.BaseModel):
    primary: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef]] = pydantic.Field(..., description='')
    private_ip_address: str = pydantic.Field(..., description='')
    ...

class CfnNetworkInterfaceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnNetworkInterfaceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNetworkInterfaceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnNetworkInterfaceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNetworkInterfaceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnNetworkInterfaceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnNetworkInterfaceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnNetworkInterfaceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnNetworkInterfaceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnNetworkInterfaceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNetworkInterfaceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnNetworkInterfaceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnNetworkInterfaceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNetworkInterfaceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInterfaceAttachment
class CfnNetworkInterfaceAttachmentDef(BaseCfnResource):
    device_index: str = pydantic.Field(..., description="The network interface's position in the attachment order. For example, the first attached network interface has a ``DeviceIndex`` of 0.\n")
    instance_id: str = pydantic.Field(..., description='The ID of the instance to which you will attach the ENI.\n')
    network_interface_id: str = pydantic.Field(..., description='The ID of the ENI that you want to attach.\n')
    delete_on_termination: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Whether to delete the network interface when the instance terminates. By default, this value is set to ``true`` .')
    _init_params: typing.ClassVar[list[str]] = ['device_index', 'instance_id', 'network_interface_id', 'delete_on_termination']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInterfaceAttachment'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnNetworkInterfaceAttachmentDefConfig] = pydantic.Field(None)


class CfnNetworkInterfaceAttachmentDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnNetworkInterfaceAttachmentDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnNetworkInterfaceAttachmentDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnNetworkInterfaceAttachmentDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnNetworkInterfaceAttachmentDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnNetworkInterfaceAttachmentDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnNetworkInterfaceAttachmentDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnNetworkInterfaceAttachmentDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnNetworkInterfaceAttachmentDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnNetworkInterfaceAttachmentDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnNetworkInterfaceAttachmentDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnNetworkInterfaceAttachmentDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnNetworkInterfaceAttachmentDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnNetworkInterfaceAttachmentDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnNetworkInterfaceAttachmentDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnNetworkInterfaceAttachmentDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNetworkInterfaceAttachmentDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnNetworkInterfaceAttachmentDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNetworkInterfaceAttachmentDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnNetworkInterfaceAttachmentDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnNetworkInterfaceAttachmentDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnNetworkInterfaceAttachmentDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnNetworkInterfaceAttachmentDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnNetworkInterfaceAttachmentDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNetworkInterfaceAttachmentDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnNetworkInterfaceAttachmentDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnNetworkInterfaceAttachmentDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNetworkInterfaceAttachmentDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInterfacePermission
class CfnNetworkInterfacePermissionDef(BaseCfnResource):
    aws_account_id: str = pydantic.Field(..., description='The AWS account ID.\n')
    network_interface_id: str = pydantic.Field(..., description='The ID of the network interface.\n')
    permission: str = pydantic.Field(..., description='The type of permission to grant: ``INSTANCE-ATTACH`` or ``EIP-ASSOCIATE`` .')
    _init_params: typing.ClassVar[list[str]] = ['aws_account_id', 'network_interface_id', 'permission']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInterfacePermission'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnNetworkInterfacePermissionDefConfig] = pydantic.Field(None)


class CfnNetworkInterfacePermissionDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnNetworkInterfacePermissionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnNetworkInterfacePermissionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnNetworkInterfacePermissionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnNetworkInterfacePermissionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnNetworkInterfacePermissionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnNetworkInterfacePermissionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnNetworkInterfacePermissionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnNetworkInterfacePermissionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnNetworkInterfacePermissionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnNetworkInterfacePermissionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnNetworkInterfacePermissionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnNetworkInterfacePermissionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnNetworkInterfacePermissionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnNetworkInterfacePermissionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnNetworkInterfacePermissionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNetworkInterfacePermissionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnNetworkInterfacePermissionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNetworkInterfacePermissionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnNetworkInterfacePermissionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnNetworkInterfacePermissionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnNetworkInterfacePermissionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnNetworkInterfacePermissionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnNetworkInterfacePermissionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNetworkInterfacePermissionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnNetworkInterfacePermissionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnNetworkInterfacePermissionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNetworkInterfacePermissionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnNetworkPerformanceMetricSubscription
class CfnNetworkPerformanceMetricSubscriptionDef(BaseCfnResource):
    destination: str = pydantic.Field(..., description="The Region or Availability Zone that's the target for the subscription. For example, ``eu-west-1`` .\n")
    metric: str = pydantic.Field(..., description='The metric used for the subscription.\n')
    source: str = pydantic.Field(..., description="The Region or Availability Zone that's the source for the subscription. For example, ``us-east-1`` .\n")
    statistic: str = pydantic.Field(..., description='The statistic used for the subscription.')
    _init_params: typing.ClassVar[list[str]] = ['destination', 'metric', 'source', 'statistic']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkPerformanceMetricSubscription'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnNetworkPerformanceMetricSubscriptionDefConfig] = pydantic.Field(None)


class CfnNetworkPerformanceMetricSubscriptionDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnNetworkPerformanceMetricSubscriptionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnNetworkPerformanceMetricSubscriptionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnNetworkPerformanceMetricSubscriptionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnNetworkPerformanceMetricSubscriptionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnNetworkPerformanceMetricSubscriptionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnNetworkPerformanceMetricSubscriptionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnNetworkPerformanceMetricSubscriptionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnNetworkPerformanceMetricSubscriptionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnNetworkPerformanceMetricSubscriptionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnNetworkPerformanceMetricSubscriptionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnNetworkPerformanceMetricSubscriptionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnNetworkPerformanceMetricSubscriptionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnNetworkPerformanceMetricSubscriptionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnNetworkPerformanceMetricSubscriptionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnNetworkPerformanceMetricSubscriptionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNetworkPerformanceMetricSubscriptionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnNetworkPerformanceMetricSubscriptionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNetworkPerformanceMetricSubscriptionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnNetworkPerformanceMetricSubscriptionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnNetworkPerformanceMetricSubscriptionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnNetworkPerformanceMetricSubscriptionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnNetworkPerformanceMetricSubscriptionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnNetworkPerformanceMetricSubscriptionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnNetworkPerformanceMetricSubscriptionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnNetworkPerformanceMetricSubscriptionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnNetworkPerformanceMetricSubscriptionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnNetworkPerformanceMetricSubscriptionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnPlacementGroup
class CfnPlacementGroupDef(BaseCfnResource):
    partition_count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of partitions. Valid only when *Strategy* is set to ``partition`` .\n')
    spread_level: typing.Optional[str] = pydantic.Field(None, description='Determines how placement groups spread instances. - Host – You can use ``host`` only with Outpost placement groups. - Rack – No usage restrictions.\n')
    strategy: typing.Optional[str] = pydantic.Field(None, description='The placement strategy.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to apply to the new placement group.')
    _init_params: typing.ClassVar[list[str]] = ['partition_count', 'spread_level', 'strategy', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnPlacementGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnPlacementGroupDefConfig] = pydantic.Field(None)


class CfnPlacementGroupDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnPlacementGroupDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnPlacementGroupDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnPlacementGroupDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnPlacementGroupDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnPlacementGroupDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnPlacementGroupDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnPlacementGroupDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnPlacementGroupDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnPlacementGroupDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnPlacementGroupDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnPlacementGroupDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnPlacementGroupDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnPlacementGroupDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnPlacementGroupDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPlacementGroupDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPlacementGroupDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPlacementGroupDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPlacementGroupDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPlacementGroupDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPlacementGroupDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPlacementGroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPlacementGroupDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPlacementGroupDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPlacementGroupDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnPlacementGroupDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPlacementGroupDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPlacementGroupDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnPrefixList
class CfnPrefixListDef(BaseCfnResource):
    address_family: str = pydantic.Field(..., description='The IP address type. Valid Values: ``IPv4`` | ``IPv6``\n')
    max_entries: typing.Union[int, float] = pydantic.Field(..., description='The maximum number of entries for the prefix list.\n')
    prefix_list_name: str = pydantic.Field(..., description='A name for the prefix list. Constraints: Up to 255 characters in length. The name cannot start with ``com.amazonaws`` .\n')
    entries: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnPrefixList_EntryPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='One or more entries for the prefix list.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the prefix list.')
    _init_params: typing.ClassVar[list[str]] = ['address_family', 'max_entries', 'prefix_list_name', 'entries', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['EntryProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnPrefixList'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnPrefixListDefConfig] = pydantic.Field(None)


class CfnPrefixListDefConfig(pydantic.BaseModel):
    EntryProperty: typing.Optional[list[CfnPrefixListDefEntrypropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnPrefixListDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnPrefixListDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnPrefixListDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnPrefixListDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnPrefixListDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnPrefixListDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnPrefixListDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnPrefixListDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnPrefixListDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnPrefixListDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnPrefixListDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnPrefixListDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnPrefixListDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnPrefixListDefEntrypropertyParams(pydantic.BaseModel):
    cidr: str = pydantic.Field(..., description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnPrefixListDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnPrefixListDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPrefixListDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnPrefixListDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPrefixListDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnPrefixListDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnPrefixListDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnPrefixListDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnPrefixListDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnPrefixListDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnPrefixListDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnPrefixListDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnPrefixListDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnPrefixListDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnRoute
class CfnRouteDef(BaseCfnResource):
    route_table_id: str = pydantic.Field(..., description='The ID of the route table for the route.\n')
    carrier_gateway_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the carrier gateway. You can only use this option when the VPC contains a subnet which is associated with a Wavelength Zone.\n')
    destination_cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv4 CIDR address block used for the destination match. Routing decisions are based on the most specific match. We modify the specified CIDR block to its canonical form; for example, if you specify ``100.68.0.18/18`` , we modify it to ``100.68.0.0/18`` .\n')
    destination_ipv6_cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv6 CIDR block used for the destination match. Routing decisions are based on the most specific match.\n')
    egress_only_internet_gateway_id: typing.Optional[str] = pydantic.Field(None, description='[IPv6 traffic only] The ID of an egress-only internet gateway.\n')
    gateway_id: typing.Optional[str] = pydantic.Field(None, description='The ID of an internet gateway or virtual private gateway attached to your VPC.\n')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The ID of a NAT instance in your VPC. The operation fails if you specify an instance ID unless exactly one network interface is attached.\n')
    local_gateway_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the local gateway.\n')
    nat_gateway_id: typing.Optional[str] = pydantic.Field(None, description='[IPv4 traffic only] The ID of a NAT gateway.\n')
    network_interface_id: typing.Optional[str] = pydantic.Field(None, description='The ID of a network interface.\n')
    transit_gateway_id: typing.Optional[str] = pydantic.Field(None, description='The ID of a transit gateway.\n')
    vpc_endpoint_id: typing.Optional[str] = pydantic.Field(None, description='The ID of a VPC endpoint. Supported for Gateway Load Balancer endpoints only.\n')
    vpc_peering_connection_id: typing.Optional[str] = pydantic.Field(None, description='The ID of a VPC peering connection.')
    _init_params: typing.ClassVar[list[str]] = ['route_table_id', 'carrier_gateway_id', 'destination_cidr_block', 'destination_ipv6_cidr_block', 'egress_only_internet_gateway_id', 'gateway_id', 'instance_id', 'local_gateway_id', 'nat_gateway_id', 'network_interface_id', 'transit_gateway_id', 'vpc_endpoint_id', 'vpc_peering_connection_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnRoute'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnRouteDefConfig] = pydantic.Field(None)


class CfnRouteDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnRouteDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnRouteDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnRouteDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnRouteDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnRouteDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnRouteDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnRouteDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnRouteDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnRouteDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnRouteDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnRouteDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnRouteDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnRouteDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnRouteDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnRouteDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRouteDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnRouteDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRouteDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnRouteDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnRouteDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnRouteDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnRouteDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnRouteDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRouteDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnRouteDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnRouteDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRouteDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnRouteTable
class CfnRouteTableDef(BaseCfnResource):
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Any tags assigned to the route table.')
    _init_params: typing.ClassVar[list[str]] = ['vpc_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnRouteTable'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnRouteTableDefConfig] = pydantic.Field(None)


class CfnRouteTableDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnRouteTableDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnRouteTableDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnRouteTableDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnRouteTableDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnRouteTableDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnRouteTableDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnRouteTableDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnRouteTableDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnRouteTableDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnRouteTableDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnRouteTableDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnRouteTableDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnRouteTableDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnRouteTableDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnRouteTableDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRouteTableDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnRouteTableDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRouteTableDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnRouteTableDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnRouteTableDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnRouteTableDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnRouteTableDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnRouteTableDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnRouteTableDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnRouteTableDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnRouteTableDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnRouteTableDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnSecurityGroup
class CfnSecurityGroupDef(BaseCfnResource):
    group_description: str = pydantic.Field(..., description='A description for the security group. Constraints: Up to 255 characters in length Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*\n')
    group_name: typing.Optional[str] = pydantic.Field(None, description='The name of the security group. Constraints: Up to 255 characters in length. Cannot start with ``sg-`` . Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*\n')
    security_group_egress: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSecurityGroup_EgressPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The outbound rules associated with the security group. There is a short interruption during which you cannot connect to the security group.\n')
    security_group_ingress: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSecurityGroup_IngressPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The inbound rules associated with the security group. There is a short interruption during which you cannot connect to the security group.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Any tags assigned to the security group.\n')
    vpc_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the VPC for the security group.')
    _init_params: typing.ClassVar[list[str]] = ['group_description', 'group_name', 'security_group_egress', 'security_group_ingress', 'tags', 'vpc_id']
    _method_names: typing.ClassVar[list[str]] = ['EgressProperty', 'IngressProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSecurityGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnSecurityGroupDefConfig] = pydantic.Field(None)


class CfnSecurityGroupDefConfig(pydantic.BaseModel):
    EgressProperty: typing.Optional[list[CfnSecurityGroupDefEgresspropertyParams]] = pydantic.Field(None, description='')
    IngressProperty: typing.Optional[list[CfnSecurityGroupDefIngresspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnSecurityGroupDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnSecurityGroupDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnSecurityGroupDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnSecurityGroupDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnSecurityGroupDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnSecurityGroupDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnSecurityGroupDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnSecurityGroupDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnSecurityGroupDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnSecurityGroupDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnSecurityGroupDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnSecurityGroupDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnSecurityGroupDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnSecurityGroupDefEgresspropertyParams(pydantic.BaseModel):
    ip_protocol: str = pydantic.Field(..., description='')
    cidr_ip: typing.Optional[str] = pydantic.Field(None, description='')
    cidr_ipv6: typing.Optional[str] = pydantic.Field(None, description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    destination_prefix_list_id: typing.Optional[str] = pydantic.Field(None, description='')
    destination_security_group_id: typing.Optional[str] = pydantic.Field(None, description='')
    from_port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    to_port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnSecurityGroupDefIngresspropertyParams(pydantic.BaseModel):
    ip_protocol: str = pydantic.Field(..., description='')
    cidr_ip: typing.Optional[str] = pydantic.Field(None, description='')
    cidr_ipv6: typing.Optional[str] = pydantic.Field(None, description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    from_port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    source_prefix_list_id: typing.Optional[str] = pydantic.Field(None, description='')
    source_security_group_id: typing.Optional[str] = pydantic.Field(None, description='')
    source_security_group_name: typing.Optional[str] = pydantic.Field(None, description='')
    source_security_group_owner_id: typing.Optional[str] = pydantic.Field(None, description='')
    to_port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnSecurityGroupDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSecurityGroupDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSecurityGroupDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSecurityGroupDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSecurityGroupDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSecurityGroupDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSecurityGroupDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSecurityGroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSecurityGroupDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSecurityGroupDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSecurityGroupDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnSecurityGroupDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSecurityGroupDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSecurityGroupDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnSecurityGroupEgress
class CfnSecurityGroupEgressDef(BaseCfnResource):
    group_id: str = pydantic.Field(..., description='The ID of the security group. You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.\n')
    ip_protocol: str = pydantic.Field(..., description='The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ). Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.\n')
    cidr_ip: typing.Optional[str] = pydantic.Field(None, description='The IPv4 address range, in CIDR format. You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ). For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .\n')
    cidr_ipv6: typing.Optional[str] = pydantic.Field(None, description='The IPv6 address range, in CIDR format. You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ). For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of an egress (outbound) security group rule. Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*\n')
    destination_prefix_list_id: typing.Optional[str] = pydantic.Field(None, description='The prefix list IDs for an AWS service. This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group. You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).\n')
    destination_security_group_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the security group. You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).\n')
    from_port: typing.Union[int, float, None] = pydantic.Field(None, description='If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the type number. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.\n')
    to_port: typing.Union[int, float, None] = pydantic.Field(None, description='If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the code. A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.')
    _init_params: typing.ClassVar[list[str]] = ['group_id', 'ip_protocol', 'cidr_ip', 'cidr_ipv6', 'description', 'destination_prefix_list_id', 'destination_security_group_id', 'from_port', 'to_port']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSecurityGroupEgress'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnSecurityGroupEgressDefConfig] = pydantic.Field(None)


class CfnSecurityGroupEgressDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnSecurityGroupEgressDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnSecurityGroupEgressDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnSecurityGroupEgressDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnSecurityGroupEgressDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnSecurityGroupEgressDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnSecurityGroupEgressDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnSecurityGroupEgressDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnSecurityGroupEgressDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnSecurityGroupEgressDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnSecurityGroupEgressDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnSecurityGroupEgressDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnSecurityGroupEgressDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnSecurityGroupEgressDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnSecurityGroupEgressDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSecurityGroupEgressDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSecurityGroupEgressDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSecurityGroupEgressDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSecurityGroupEgressDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSecurityGroupEgressDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSecurityGroupEgressDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSecurityGroupEgressDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSecurityGroupEgressDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSecurityGroupEgressDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSecurityGroupEgressDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnSecurityGroupEgressDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSecurityGroupEgressDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSecurityGroupEgressDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnSecurityGroupIngress
class CfnSecurityGroupIngressDef(BaseCfnResource):
    ip_protocol: str = pydantic.Field(..., description='The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ). Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.\n')
    cidr_ip: typing.Optional[str] = pydantic.Field(None, description='The IPv4 address range, in CIDR format. You must specify a source security group ( ``SourcePrefixListId`` or ``SourceSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ). For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .\n')
    cidr_ipv6: typing.Optional[str] = pydantic.Field(None, description='The IPv6 address range, in CIDR format. You must specify a source security group ( ``SourcePrefixListId`` or ``SourceSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ). For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Updates the description of an ingress (inbound) security group rule. You can replace an existing description, or add a description to a rule that did not have one previously. Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*\n')
    from_port: typing.Union[int, float, None] = pydantic.Field(None, description='The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of ``-1`` indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes. Use this for ICMP and any protocol that uses ports.\n')
    group_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the security group.\n')
    group_name: typing.Optional[str] = pydantic.Field(None, description='The name of the security group. Constraints: Up to 255 characters in length. Cannot start with ``sg-`` . Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*\n')
    source_prefix_list_id: typing.Optional[str] = pydantic.Field(None, description='The ID of a prefix list.\n')
    source_security_group_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the security group. You must specify either the security group ID or the security group name. For security groups in a nondefault VPC, you must specify the security group ID.\n')
    source_security_group_name: typing.Optional[str] = pydantic.Field(None, description="[Default VPC] The name of the source security group. You must specify either the security group ID or the security group name. You can't specify the group name in combination with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access. For security groups in a nondefault VPC, you must specify the group ID.\n")
    source_security_group_owner_id: typing.Optional[str] = pydantic.Field(None, description="[nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account. You can't specify this property with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access. If you specify ``SourceSecurityGroupName`` or ``SourceSecurityGroupId`` and that security group is owned by a different account than the account creating the stack, you must specify ``SourceSecurityGroupOwnerId`` ; otherwise, this property is optional.\n")
    to_port: typing.Union[int, float, None] = pydantic.Field(None, description='The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of ``-1`` indicates all ICMP/ICMPv6 codes for the specified ICMP type. If you specify all ICMP/ICMPv6 types, you must specify all codes. Use this for ICMP and any protocol that uses ports.')
    _init_params: typing.ClassVar[list[str]] = ['ip_protocol', 'cidr_ip', 'cidr_ipv6', 'description', 'from_port', 'group_id', 'group_name', 'source_prefix_list_id', 'source_security_group_id', 'source_security_group_name', 'source_security_group_owner_id', 'to_port']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSecurityGroupIngress'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnSecurityGroupIngressDefConfig] = pydantic.Field(None)


class CfnSecurityGroupIngressDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnSecurityGroupIngressDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnSecurityGroupIngressDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnSecurityGroupIngressDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnSecurityGroupIngressDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnSecurityGroupIngressDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnSecurityGroupIngressDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnSecurityGroupIngressDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnSecurityGroupIngressDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnSecurityGroupIngressDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnSecurityGroupIngressDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnSecurityGroupIngressDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnSecurityGroupIngressDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnSecurityGroupIngressDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnSecurityGroupIngressDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSecurityGroupIngressDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSecurityGroupIngressDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSecurityGroupIngressDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSecurityGroupIngressDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSecurityGroupIngressDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSecurityGroupIngressDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSecurityGroupIngressDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSecurityGroupIngressDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSecurityGroupIngressDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSecurityGroupIngressDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnSecurityGroupIngressDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSecurityGroupIngressDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSecurityGroupIngressDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleet
class CfnSpotFleetDef(BaseCfnResource):
    spot_fleet_request_config_data: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_SpotFleetRequestConfigDataPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Describes the configuration of a Spot Fleet request.')
    _init_params: typing.ClassVar[list[str]] = ['spot_fleet_request_config_data']
    _method_names: typing.ClassVar[list[str]] = ['AcceleratorCountRequestProperty', 'AcceleratorTotalMemoryMiBRequestProperty', 'BaselineEbsBandwidthMbpsRequestProperty', 'BlockDeviceMappingProperty', 'ClassicLoadBalancerProperty', 'ClassicLoadBalancersConfigProperty', 'EbsBlockDeviceProperty', 'FleetLaunchTemplateSpecificationProperty', 'GroupIdentifierProperty', 'IamInstanceProfileSpecificationProperty', 'InstanceIpv6AddressProperty', 'InstanceNetworkInterfaceSpecificationProperty', 'InstanceRequirementsRequestProperty', 'LaunchTemplateConfigProperty', 'LaunchTemplateOverridesProperty', 'LoadBalancersConfigProperty', 'MemoryGiBPerVCpuRequestProperty', 'MemoryMiBRequestProperty', 'NetworkBandwidthGbpsRequestProperty', 'NetworkInterfaceCountRequestProperty', 'PrivateIpAddressSpecificationProperty', 'SpotCapacityRebalanceProperty', 'SpotFleetLaunchSpecificationProperty', 'SpotFleetMonitoringProperty', 'SpotFleetRequestConfigDataProperty', 'SpotFleetTagSpecificationProperty', 'SpotMaintenanceStrategiesProperty', 'SpotPlacementProperty', 'TargetGroupProperty', 'TargetGroupsConfigProperty', 'TotalLocalStorageGBRequestProperty', 'VCpuCountRangeRequestProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleet'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnSpotFleetDefConfig] = pydantic.Field(None)


class CfnSpotFleetDefConfig(pydantic.BaseModel):
    AcceleratorCountRequestProperty: typing.Optional[list[CfnSpotFleetDefAcceleratorcountrequestpropertyParams]] = pydantic.Field(None, description='')
    AcceleratorTotalMemoryMiBRequestProperty: typing.Optional[list[CfnSpotFleetDefAcceleratortotalmemorymibrequestpropertyParams]] = pydantic.Field(None, description='')
    BaselineEbsBandwidthMbpsRequestProperty: typing.Optional[list[CfnSpotFleetDefBaselineebsbandwidthmbpsrequestpropertyParams]] = pydantic.Field(None, description='')
    BlockDeviceMappingProperty: typing.Optional[list[CfnSpotFleetDefBlockdevicemappingpropertyParams]] = pydantic.Field(None, description='')
    ClassicLoadBalancerProperty: typing.Optional[list[CfnSpotFleetDefClassicloadbalancerpropertyParams]] = pydantic.Field(None, description='')
    ClassicLoadBalancersConfigProperty: typing.Optional[list[CfnSpotFleetDefClassicloadbalancersconfigpropertyParams]] = pydantic.Field(None, description='')
    EbsBlockDeviceProperty: typing.Optional[list[CfnSpotFleetDefEbsblockdevicepropertyParams]] = pydantic.Field(None, description='')
    FleetLaunchTemplateSpecificationProperty: typing.Optional[list[CfnSpotFleetDefFleetlaunchtemplatespecificationpropertyParams]] = pydantic.Field(None, description='')
    GroupIdentifierProperty: typing.Optional[list[CfnSpotFleetDefGroupidentifierpropertyParams]] = pydantic.Field(None, description='')
    IamInstanceProfileSpecificationProperty: typing.Optional[list[CfnSpotFleetDefIaminstanceprofilespecificationpropertyParams]] = pydantic.Field(None, description='')
    InstanceIpv6AddressProperty: typing.Optional[list[CfnSpotFleetDefInstanceipv6AddresspropertyParams]] = pydantic.Field(None, description='')
    InstanceNetworkInterfaceSpecificationProperty: typing.Optional[list[CfnSpotFleetDefInstancenetworkinterfacespecificationpropertyParams]] = pydantic.Field(None, description='')
    InstanceRequirementsRequestProperty: typing.Optional[list[CfnSpotFleetDefInstancerequirementsrequestpropertyParams]] = pydantic.Field(None, description='')
    LaunchTemplateConfigProperty: typing.Optional[list[CfnSpotFleetDefLaunchtemplateconfigpropertyParams]] = pydantic.Field(None, description='')
    LaunchTemplateOverridesProperty: typing.Optional[list[CfnSpotFleetDefLaunchtemplateoverridespropertyParams]] = pydantic.Field(None, description='')
    LoadBalancersConfigProperty: typing.Optional[list[CfnSpotFleetDefLoadbalancersconfigpropertyParams]] = pydantic.Field(None, description='')
    MemoryGiBPerVCpuRequestProperty: typing.Optional[list[CfnSpotFleetDefMemorygibpervcpurequestpropertyParams]] = pydantic.Field(None, description='')
    MemoryMiBRequestProperty: typing.Optional[list[CfnSpotFleetDefMemorymibrequestpropertyParams]] = pydantic.Field(None, description='')
    NetworkBandwidthGbpsRequestProperty: typing.Optional[list[CfnSpotFleetDefNetworkbandwidthgbpsrequestpropertyParams]] = pydantic.Field(None, description='')
    NetworkInterfaceCountRequestProperty: typing.Optional[list[CfnSpotFleetDefNetworkinterfacecountrequestpropertyParams]] = pydantic.Field(None, description='')
    PrivateIpAddressSpecificationProperty: typing.Optional[list[CfnSpotFleetDefPrivateipaddressspecificationpropertyParams]] = pydantic.Field(None, description='')
    SpotCapacityRebalanceProperty: typing.Optional[list[CfnSpotFleetDefSpotcapacityrebalancepropertyParams]] = pydantic.Field(None, description='')
    SpotFleetLaunchSpecificationProperty: typing.Optional[list[CfnSpotFleetDefSpotfleetlaunchspecificationpropertyParams]] = pydantic.Field(None, description='')
    SpotFleetMonitoringProperty: typing.Optional[list[CfnSpotFleetDefSpotfleetmonitoringpropertyParams]] = pydantic.Field(None, description='')
    SpotFleetRequestConfigDataProperty: typing.Optional[list[CfnSpotFleetDefSpotfleetrequestconfigdatapropertyParams]] = pydantic.Field(None, description='')
    SpotFleetTagSpecificationProperty: typing.Optional[list[CfnSpotFleetDefSpotfleettagspecificationpropertyParams]] = pydantic.Field(None, description='')
    SpotMaintenanceStrategiesProperty: typing.Optional[list[CfnSpotFleetDefSpotmaintenancestrategiespropertyParams]] = pydantic.Field(None, description='')
    SpotPlacementProperty: typing.Optional[list[CfnSpotFleetDefSpotplacementpropertyParams]] = pydantic.Field(None, description='')
    TargetGroupProperty: typing.Optional[list[CfnSpotFleetDefTargetgrouppropertyParams]] = pydantic.Field(None, description='')
    TargetGroupsConfigProperty: typing.Optional[list[CfnSpotFleetDefTargetgroupsconfigpropertyParams]] = pydantic.Field(None, description='')
    TotalLocalStorageGBRequestProperty: typing.Optional[list[CfnSpotFleetDefTotallocalstoragegbrequestpropertyParams]] = pydantic.Field(None, description='')
    VCpuCountRangeRequestProperty: typing.Optional[list[CfnSpotFleetDefVcpucountrangerequestpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnSpotFleetDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnSpotFleetDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnSpotFleetDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnSpotFleetDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnSpotFleetDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnSpotFleetDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnSpotFleetDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnSpotFleetDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnSpotFleetDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnSpotFleetDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnSpotFleetDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnSpotFleetDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnSpotFleetDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnSpotFleetDefAcceleratorcountrequestpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefAcceleratortotalmemorymibrequestpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefBaselineebsbandwidthmbpsrequestpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefBlockdevicemappingpropertyParams(pydantic.BaseModel):
    device_name: str = pydantic.Field(..., description='')
    ebs: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_EbsBlockDevicePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    no_device: typing.Optional[str] = pydantic.Field(None, description='')
    virtual_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefClassicloadbalancerpropertyParams(pydantic.BaseModel):
    name: str = pydantic.Field(..., description='')
    ...

class CfnSpotFleetDefClassicloadbalancersconfigpropertyParams(pydantic.BaseModel):
    classic_load_balancers: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_ClassicLoadBalancerPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnSpotFleetDefEbsblockdevicepropertyParams(pydantic.BaseModel):
    delete_on_termination: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    encrypted: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='')
    snapshot_id: typing.Optional[str] = pydantic.Field(None, description='')
    volume_size: typing.Union[int, float, None] = pydantic.Field(None, description='')
    volume_type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefFleetlaunchtemplatespecificationpropertyParams(pydantic.BaseModel):
    version: str = pydantic.Field(..., description='')
    launch_template_id: typing.Optional[str] = pydantic.Field(None, description='')
    launch_template_name: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefGroupidentifierpropertyParams(pydantic.BaseModel):
    group_id: str = pydantic.Field(..., description='')
    ...

class CfnSpotFleetDefIaminstanceprofilespecificationpropertyParams(pydantic.BaseModel):
    arn: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefInstanceipv6AddresspropertyParams(pydantic.BaseModel):
    ipv6_address: str = pydantic.Field(..., description='')
    ...

class CfnSpotFleetDefInstancenetworkinterfacespecificationpropertyParams(pydantic.BaseModel):
    associate_public_ip_address: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    delete_on_termination: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    description: typing.Optional[str] = pydantic.Field(None, description='')
    device_index: typing.Union[int, float, None] = pydantic.Field(None, description='')
    groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ipv6_address_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ipv6_addresses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_InstanceIpv6AddressPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    network_interface_id: typing.Optional[str] = pydantic.Field(None, description='')
    private_ip_addresses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_PrivateIpAddressSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    secondary_private_ip_address_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefInstancerequirementsrequestpropertyParams(pydantic.BaseModel):
    accelerator_count: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_AcceleratorCountRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    accelerator_manufacturers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    accelerator_names: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    accelerator_total_memory_mib: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_AcceleratorTotalMemoryMiBRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    accelerator_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    allowed_instance_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    bare_metal: typing.Optional[str] = pydantic.Field(None, description='')
    baseline_ebs_bandwidth_mbps: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_BaselineEbsBandwidthMbpsRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    burstable_performance: typing.Optional[str] = pydantic.Field(None, description='')
    cpu_manufacturers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    excluded_instance_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    instance_generations: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    local_storage: typing.Optional[str] = pydantic.Field(None, description='')
    local_storage_types: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    memory_gib_per_v_cpu: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_MemoryGiBPerVCpuRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    memory_mib: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_MemoryMiBRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    network_bandwidth_gbps: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_NetworkBandwidthGbpsRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    network_interface_count: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_NetworkInterfaceCountRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    on_demand_max_price_percentage_over_lowest_price: typing.Union[int, float, None] = pydantic.Field(None, description='')
    require_hibernate_support: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    spot_max_price_percentage_over_lowest_price: typing.Union[int, float, None] = pydantic.Field(None, description='')
    total_local_storage_gb: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_TotalLocalStorageGBRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    v_cpu_count: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_VCpuCountRangeRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefLaunchtemplateconfigpropertyParams(pydantic.BaseModel):
    launch_template_specification: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_FleetLaunchTemplateSpecificationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    overrides: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_LaunchTemplateOverridesPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefLaunchtemplateoverridespropertyParams(pydantic.BaseModel):
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='')
    instance_requirements: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_InstanceRequirementsRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    instance_type: typing.Optional[str] = pydantic.Field(None, description='')
    priority: typing.Union[int, float, None] = pydantic.Field(None, description='')
    spot_price: typing.Optional[str] = pydantic.Field(None, description='')
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='')
    weighted_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefLoadbalancersconfigpropertyParams(pydantic.BaseModel):
    classic_load_balancers_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_ClassicLoadBalancersConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    target_groups_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_TargetGroupsConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefMemorygibpervcpurequestpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefMemorymibrequestpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefNetworkbandwidthgbpsrequestpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefNetworkinterfacecountrequestpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefPrivateipaddressspecificationpropertyParams(pydantic.BaseModel):
    private_ip_address: str = pydantic.Field(..., description='')
    primary: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefSpotcapacityrebalancepropertyParams(pydantic.BaseModel):
    replacement_strategy: typing.Optional[str] = pydantic.Field(None, description='')
    termination_delay: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefSpotfleetlaunchspecificationpropertyParams(pydantic.BaseModel):
    image_id: str = pydantic.Field(..., description='')
    block_device_mappings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_BlockDeviceMappingPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    ebs_optimized: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    iam_instance_profile: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_IamInstanceProfileSpecificationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    instance_requirements: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_InstanceRequirementsRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    instance_type: typing.Optional[str] = pydantic.Field(None, description='')
    kernel_id: typing.Optional[str] = pydantic.Field(None, description='')
    key_name: typing.Optional[str] = pydantic.Field(None, description='')
    monitoring: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_SpotFleetMonitoringPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    network_interfaces: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_InstanceNetworkInterfaceSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    placement: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_SpotPlacementPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ramdisk_id: typing.Optional[str] = pydantic.Field(None, description='')
    security_groups: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_GroupIdentifierPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    spot_price: typing.Optional[str] = pydantic.Field(None, description='')
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='')
    tag_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_SpotFleetTagSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    user_data: typing.Optional[str] = pydantic.Field(None, description='')
    weighted_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefSpotfleetmonitoringpropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefSpotfleetrequestconfigdatapropertyParams(pydantic.BaseModel):
    iam_fleet_role: str = pydantic.Field(..., description='')
    target_capacity: typing.Union[int, float] = pydantic.Field(..., description='')
    allocation_strategy: typing.Optional[str] = pydantic.Field(None, description='')
    context: typing.Optional[str] = pydantic.Field(None, description='')
    excess_capacity_termination_policy: typing.Optional[str] = pydantic.Field(None, description='')
    instance_interruption_behavior: typing.Optional[str] = pydantic.Field(None, description='')
    instance_pools_to_use_count: typing.Union[int, float, None] = pydantic.Field(None, description='')
    launch_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_SpotFleetLaunchSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    launch_template_configs: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_LaunchTemplateConfigPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    load_balancers_config: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_LoadBalancersConfigPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    on_demand_allocation_strategy: typing.Optional[str] = pydantic.Field(None, description='')
    on_demand_max_total_price: typing.Optional[str] = pydantic.Field(None, description='')
    on_demand_target_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='')
    replace_unhealthy_instances: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    spot_maintenance_strategies: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_SpotMaintenanceStrategiesPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    spot_max_total_price: typing.Optional[str] = pydantic.Field(None, description='')
    spot_price: typing.Optional[str] = pydantic.Field(None, description='')
    tag_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_SpotFleetTagSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='')
    target_capacity_unit_type: typing.Optional[str] = pydantic.Field(None, description='')
    terminate_instances_with_expiration: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    type: typing.Optional[str] = pydantic.Field(None, description='')
    valid_from: typing.Optional[str] = pydantic.Field(None, description='')
    valid_until: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefSpotfleettagspecificationpropertyParams(pydantic.BaseModel):
    resource_type: typing.Optional[str] = pydantic.Field(None, description='')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefSpotmaintenancestrategiespropertyParams(pydantic.BaseModel):
    capacity_rebalance: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_SpotCapacityRebalancePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefSpotplacementpropertyParams(pydantic.BaseModel):
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='')
    group_name: typing.Optional[str] = pydantic.Field(None, description='')
    tenancy: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefTargetgrouppropertyParams(pydantic.BaseModel):
    arn: str = pydantic.Field(..., description='')
    ...

class CfnSpotFleetDefTargetgroupsconfigpropertyParams(pydantic.BaseModel):
    target_groups: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_TargetGroupPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='')
    ...

class CfnSpotFleetDefTotallocalstoragegbrequestpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefVcpucountrangerequestpropertyParams(pydantic.BaseModel):
    max: typing.Union[int, float, None] = pydantic.Field(None, description='')
    min: typing.Union[int, float, None] = pydantic.Field(None, description='')
    ...

class CfnSpotFleetDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSpotFleetDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSpotFleetDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSpotFleetDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSpotFleetDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSpotFleetDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSpotFleetDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSpotFleetDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSpotFleetDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSpotFleetDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSpotFleetDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnSpotFleetDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSpotFleetDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSpotFleetDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnSubnet
class CfnSubnetDef(BaseCfnResource):
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC the subnet is in. If you update this property, you must also update the ``CidrBlock`` property.\n')
    assign_ipv6_address_on_creation: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether a network interface created in this subnet receives an IPv6 address. The default value is ``false`` . If you specify ``AssignIpv6AddressOnCreation`` , you must also specify ``Ipv6CidrBlock`` .\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone of the subnet. If you update this property, you must also update the ``CidrBlock`` property.\n')
    availability_zone_id: typing.Optional[str] = pydantic.Field(None, description='The AZ ID of the subnet.\n')
    cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv4 CIDR block assigned to the subnet. If you update this property, we create a new subnet, and then delete the existing one.\n')
    enable_dns64: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether DNS queries made to the Amazon-provided DNS Resolver in this subnet should return synthetic IPv6 addresses for IPv4-only destinations. For more information, see `DNS64 and NAT64 <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-nat64-dns64>`_ in the *Amazon Virtual Private Cloud User Guide* .\n')
    ipv6_cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv6 CIDR block. If you specify ``AssignIpv6AddressOnCreation`` , you must also specify ``Ipv6CidrBlock`` .\n')
    ipv6_native: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether this is an IPv6 only subnet. For more information, see `Subnet basics <https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html#subnet-basics>`_ in the *Amazon Virtual Private Cloud User Guide* .\n')
    map_public_ip_on_launch: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether instances launched in this subnet receive a public IPv4 address. The default value is ``false`` .\n')
    outpost_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the Outpost.\n')
    private_dns_name_options_on_launch: typing.Any = pydantic.Field(None, description='The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* . Available options: - EnableResourceNameDnsAAAARecord (true | false) - EnableResourceNameDnsARecord (true | false) - HostnameType (ip-name | resource-name)\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Any tags assigned to the subnet.')
    _init_params: typing.ClassVar[list[str]] = ['vpc_id', 'assign_ipv6_address_on_creation', 'availability_zone', 'availability_zone_id', 'cidr_block', 'enable_dns64', 'ipv6_cidr_block', 'ipv6_native', 'map_public_ip_on_launch', 'outpost_arn', 'private_dns_name_options_on_launch', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['PrivateDnsNameOptionsOnLaunchProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSubnet'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnSubnetDefConfig] = pydantic.Field(None)


class CfnSubnetDefConfig(pydantic.BaseModel):
    PrivateDnsNameOptionsOnLaunchProperty: typing.Optional[list[CfnSubnetDefPrivatednsnameoptionsonlaunchpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnSubnetDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnSubnetDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnSubnetDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnSubnetDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnSubnetDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnSubnetDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnSubnetDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnSubnetDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnSubnetDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnSubnetDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnSubnetDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnSubnetDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnSubnetDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnSubnetDefPrivatednsnameoptionsonlaunchpropertyParams(pydantic.BaseModel):
    enable_resource_name_dns_aaaa_record: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    enable_resource_name_dns_a_record: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    hostname_type: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnSubnetDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSubnetDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSubnetDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSubnetDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSubnetDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSubnetDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSubnetDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSubnetDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSubnetDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSubnetDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSubnetDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnSubnetDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSubnetDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSubnetDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnSubnetCidrBlock
class CfnSubnetCidrBlockDef(BaseCfnResource):
    ipv6_cidr_block: str = pydantic.Field(..., description='The IPv6 network range for the subnet, in CIDR notation. The subnet size must use a /64 prefix length. This parameter is required for an IPv6 only subnet.\n')
    subnet_id: str = pydantic.Field(..., description='The ID of the subnet.')
    _init_params: typing.ClassVar[list[str]] = ['ipv6_cidr_block', 'subnet_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSubnetCidrBlock'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnSubnetCidrBlockDefConfig] = pydantic.Field(None)


class CfnSubnetCidrBlockDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnSubnetCidrBlockDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnSubnetCidrBlockDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnSubnetCidrBlockDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnSubnetCidrBlockDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnSubnetCidrBlockDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnSubnetCidrBlockDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnSubnetCidrBlockDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnSubnetCidrBlockDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnSubnetCidrBlockDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnSubnetCidrBlockDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnSubnetCidrBlockDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnSubnetCidrBlockDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnSubnetCidrBlockDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnSubnetCidrBlockDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSubnetCidrBlockDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSubnetCidrBlockDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSubnetCidrBlockDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSubnetCidrBlockDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSubnetCidrBlockDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSubnetCidrBlockDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSubnetCidrBlockDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSubnetCidrBlockDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSubnetCidrBlockDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSubnetCidrBlockDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnSubnetCidrBlockDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSubnetCidrBlockDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSubnetCidrBlockDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnSubnetNetworkAclAssociation
class CfnSubnetNetworkAclAssociationDef(BaseCfnResource):
    network_acl_id: str = pydantic.Field(..., description='The ID of the network ACL.\n')
    subnet_id: str = pydantic.Field(..., description='The ID of the subnet.')
    _init_params: typing.ClassVar[list[str]] = ['network_acl_id', 'subnet_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSubnetNetworkAclAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnSubnetNetworkAclAssociationDefConfig] = pydantic.Field(None)


class CfnSubnetNetworkAclAssociationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnSubnetNetworkAclAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnSubnetNetworkAclAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnSubnetNetworkAclAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnSubnetNetworkAclAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnSubnetNetworkAclAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnSubnetNetworkAclAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnSubnetNetworkAclAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnSubnetNetworkAclAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnSubnetNetworkAclAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnSubnetNetworkAclAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnSubnetNetworkAclAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnSubnetNetworkAclAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnSubnetNetworkAclAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnSubnetNetworkAclAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSubnetNetworkAclAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSubnetNetworkAclAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSubnetNetworkAclAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSubnetNetworkAclAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSubnetNetworkAclAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSubnetNetworkAclAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSubnetNetworkAclAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSubnetNetworkAclAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSubnetNetworkAclAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSubnetNetworkAclAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnSubnetNetworkAclAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSubnetNetworkAclAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSubnetNetworkAclAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnSubnetRouteTableAssociation
class CfnSubnetRouteTableAssociationDef(BaseCfnResource):
    route_table_id: str = pydantic.Field(..., description='The ID of the route table. The physical ID changes when the route table ID is changed.\n')
    subnet_id: str = pydantic.Field(..., description='The ID of the subnet.')
    _init_params: typing.ClassVar[list[str]] = ['route_table_id', 'subnet_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSubnetRouteTableAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnSubnetRouteTableAssociationDefConfig] = pydantic.Field(None)


class CfnSubnetRouteTableAssociationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnSubnetRouteTableAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnSubnetRouteTableAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnSubnetRouteTableAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnSubnetRouteTableAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnSubnetRouteTableAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnSubnetRouteTableAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnSubnetRouteTableAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnSubnetRouteTableAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnSubnetRouteTableAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnSubnetRouteTableAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnSubnetRouteTableAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnSubnetRouteTableAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnSubnetRouteTableAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnSubnetRouteTableAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnSubnetRouteTableAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSubnetRouteTableAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnSubnetRouteTableAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSubnetRouteTableAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnSubnetRouteTableAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnSubnetRouteTableAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnSubnetRouteTableAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnSubnetRouteTableAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnSubnetRouteTableAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnSubnetRouteTableAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnSubnetRouteTableAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnSubnetRouteTableAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnSubnetRouteTableAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnTrafficMirrorFilter
class CfnTrafficMirrorFilterDef(BaseCfnResource):
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the Traffic Mirror filter.\n')
    network_services: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The network service traffic that is associated with the Traffic Mirror filter. Valid values are ``amazon-dns`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to assign to a Traffic Mirror filter.')
    _init_params: typing.ClassVar[list[str]] = ['description', 'network_services', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTrafficMirrorFilter'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTrafficMirrorFilterDefConfig] = pydantic.Field(None)


class CfnTrafficMirrorFilterDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnTrafficMirrorFilterDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTrafficMirrorFilterDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTrafficMirrorFilterDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTrafficMirrorFilterDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTrafficMirrorFilterDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTrafficMirrorFilterDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTrafficMirrorFilterDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTrafficMirrorFilterDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTrafficMirrorFilterDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTrafficMirrorFilterDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTrafficMirrorFilterDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTrafficMirrorFilterDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTrafficMirrorFilterDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnTrafficMirrorFilterDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTrafficMirrorFilterDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTrafficMirrorFilterDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTrafficMirrorFilterDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTrafficMirrorFilterDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTrafficMirrorFilterDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTrafficMirrorFilterDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTrafficMirrorFilterDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTrafficMirrorFilterDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTrafficMirrorFilterDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTrafficMirrorFilterDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnTrafficMirrorFilterDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTrafficMirrorFilterDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTrafficMirrorFilterDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnTrafficMirrorFilterRule
class CfnTrafficMirrorFilterRuleDef(BaseCfnResource):
    destination_cidr_block: str = pydantic.Field(..., description='The destination CIDR block to assign to the Traffic Mirror rule.\n')
    rule_action: str = pydantic.Field(..., description='The action to take on the filtered traffic.\n')
    rule_number: typing.Union[int, float] = pydantic.Field(..., description='The number of the Traffic Mirror rule. This number must be unique for each Traffic Mirror rule in a given direction. The rules are processed in ascending order by rule number.\n')
    source_cidr_block: str = pydantic.Field(..., description='The source CIDR block to assign to the Traffic Mirror rule.\n')
    traffic_direction: str = pydantic.Field(..., description='The type of traffic.\n')
    traffic_mirror_filter_id: str = pydantic.Field(..., description='The ID of the filter that this rule is associated with.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the Traffic Mirror rule.\n')
    destination_port_range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnTrafficMirrorFilterRule_TrafficMirrorPortRangePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The destination port range.\n')
    protocol: typing.Union[int, float, None] = pydantic.Field(None, description='The protocol, for example UDP, to assign to the Traffic Mirror rule. For information about the protocol value, see `Protocol Numbers <https://docs.aws.amazon.com/https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ on the Internet Assigned Numbers Authority (IANA) website.\n')
    source_port_range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnTrafficMirrorFilterRule_TrafficMirrorPortRangePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The source port range.')
    _init_params: typing.ClassVar[list[str]] = ['destination_cidr_block', 'rule_action', 'rule_number', 'source_cidr_block', 'traffic_direction', 'traffic_mirror_filter_id', 'description', 'destination_port_range', 'protocol', 'source_port_range']
    _method_names: typing.ClassVar[list[str]] = ['TrafficMirrorPortRangeProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTrafficMirrorFilterRule'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTrafficMirrorFilterRuleDefConfig] = pydantic.Field(None)


class CfnTrafficMirrorFilterRuleDefConfig(pydantic.BaseModel):
    TrafficMirrorPortRangeProperty: typing.Optional[list[CfnTrafficMirrorFilterRuleDefTrafficmirrorportrangepropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnTrafficMirrorFilterRuleDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTrafficMirrorFilterRuleDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTrafficMirrorFilterRuleDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTrafficMirrorFilterRuleDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTrafficMirrorFilterRuleDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTrafficMirrorFilterRuleDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTrafficMirrorFilterRuleDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTrafficMirrorFilterRuleDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTrafficMirrorFilterRuleDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTrafficMirrorFilterRuleDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTrafficMirrorFilterRuleDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTrafficMirrorFilterRuleDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTrafficMirrorFilterRuleDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnTrafficMirrorFilterRuleDefTrafficmirrorportrangepropertyParams(pydantic.BaseModel):
    from_port: typing.Union[int, float] = pydantic.Field(..., description='')
    to_port: typing.Union[int, float] = pydantic.Field(..., description='')
    ...

class CfnTrafficMirrorFilterRuleDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTrafficMirrorFilterRuleDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTrafficMirrorFilterRuleDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTrafficMirrorFilterRuleDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTrafficMirrorFilterRuleDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTrafficMirrorFilterRuleDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTrafficMirrorFilterRuleDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTrafficMirrorFilterRuleDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTrafficMirrorFilterRuleDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTrafficMirrorFilterRuleDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTrafficMirrorFilterRuleDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnTrafficMirrorFilterRuleDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTrafficMirrorFilterRuleDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTrafficMirrorFilterRuleDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnTrafficMirrorSession
class CfnTrafficMirrorSessionDef(BaseCfnResource):
    network_interface_id: str = pydantic.Field(..., description='The ID of the source network interface.\n')
    session_number: typing.Union[int, float] = pydantic.Field(..., description='The session number determines the order in which sessions are evaluated when an interface is used by multiple sessions. The first session with a matching filter is the one that mirrors the packets. Valid values are 1-32766.\n')
    traffic_mirror_filter_id: str = pydantic.Field(..., description='The ID of the Traffic Mirror filter.\n')
    traffic_mirror_target_id: str = pydantic.Field(..., description='The ID of the Traffic Mirror target.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the Traffic Mirror session.\n')
    packet_length: typing.Union[int, float, None] = pydantic.Field(None, description='The number of bytes in each packet to mirror. These are bytes after the VXLAN header. Do not specify this parameter when you want to mirror the entire packet. To mirror a subset of the packet, set this to the length (in bytes) that you want to mirror. For example, if you set this value to 100, then the first 100 bytes that meet the filter criteria are copied to the target. If you do not want to mirror the entire packet, use the ``PacketLength`` parameter to specify the number of bytes in each packet to mirror.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to assign to a Traffic Mirror session.\n')
    virtual_network_id: typing.Union[int, float, None] = pydantic.Field(None, description='The VXLAN ID for the Traffic Mirror session. For more information about the VXLAN protocol, see `RFC 7348 <https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc7348>`_ . If you do not specify a ``VirtualNetworkId`` , an account-wide unique id is chosen at random.')
    _init_params: typing.ClassVar[list[str]] = ['network_interface_id', 'session_number', 'traffic_mirror_filter_id', 'traffic_mirror_target_id', 'description', 'packet_length', 'tags', 'virtual_network_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTrafficMirrorSession'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTrafficMirrorSessionDefConfig] = pydantic.Field(None)


class CfnTrafficMirrorSessionDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnTrafficMirrorSessionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTrafficMirrorSessionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTrafficMirrorSessionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTrafficMirrorSessionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTrafficMirrorSessionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTrafficMirrorSessionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTrafficMirrorSessionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTrafficMirrorSessionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTrafficMirrorSessionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTrafficMirrorSessionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTrafficMirrorSessionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTrafficMirrorSessionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTrafficMirrorSessionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnTrafficMirrorSessionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTrafficMirrorSessionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTrafficMirrorSessionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTrafficMirrorSessionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTrafficMirrorSessionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTrafficMirrorSessionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTrafficMirrorSessionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTrafficMirrorSessionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTrafficMirrorSessionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTrafficMirrorSessionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTrafficMirrorSessionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnTrafficMirrorSessionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTrafficMirrorSessionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTrafficMirrorSessionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnTrafficMirrorTarget
class CfnTrafficMirrorTargetDef(BaseCfnResource):
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the Traffic Mirror target.\n')
    gateway_load_balancer_endpoint_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the Gateway Load Balancer endpoint.\n')
    network_interface_id: typing.Optional[str] = pydantic.Field(None, description='The network interface ID that is associated with the target.\n')
    network_load_balancer_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the Network Load Balancer that is associated with the target.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to assign to the Traffic Mirror target.')
    _init_params: typing.ClassVar[list[str]] = ['description', 'gateway_load_balancer_endpoint_id', 'network_interface_id', 'network_load_balancer_arn', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTrafficMirrorTarget'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTrafficMirrorTargetDefConfig] = pydantic.Field(None)


class CfnTrafficMirrorTargetDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnTrafficMirrorTargetDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTrafficMirrorTargetDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTrafficMirrorTargetDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTrafficMirrorTargetDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTrafficMirrorTargetDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTrafficMirrorTargetDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTrafficMirrorTargetDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTrafficMirrorTargetDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTrafficMirrorTargetDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTrafficMirrorTargetDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTrafficMirrorTargetDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTrafficMirrorTargetDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTrafficMirrorTargetDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnTrafficMirrorTargetDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTrafficMirrorTargetDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTrafficMirrorTargetDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTrafficMirrorTargetDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTrafficMirrorTargetDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTrafficMirrorTargetDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTrafficMirrorTargetDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTrafficMirrorTargetDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTrafficMirrorTargetDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTrafficMirrorTargetDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTrafficMirrorTargetDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnTrafficMirrorTargetDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTrafficMirrorTargetDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTrafficMirrorTargetDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnTransitGateway
class CfnTransitGatewayDef(BaseCfnResource):
    amazon_side_asn: typing.Union[int, float, None] = pydantic.Field(None, description='A private Autonomous System Number (ASN) for the Amazon side of a BGP session. The range is 64512 to 65534 for 16-bit ASNs. The default is 64512.\n')
    association_default_route_table_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the default association route table.\n')
    auto_accept_shared_attachments: typing.Optional[str] = pydantic.Field(None, description='Enable or disable automatic acceptance of attachment requests. Disabled by default.\n')
    default_route_table_association: typing.Optional[str] = pydantic.Field(None, description='Enable or disable automatic association with the default association route table. Enabled by default.\n')
    default_route_table_propagation: typing.Optional[str] = pydantic.Field(None, description='Enable or disable automatic propagation of routes to the default propagation route table. Enabled by default.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the transit gateway.\n')
    dns_support: typing.Optional[str] = pydantic.Field(None, description='Enable or disable DNS support. Enabled by default.\n')
    multicast_support: typing.Optional[str] = pydantic.Field(None, description='Indicates whether multicast is enabled on the transit gateway.\n')
    propagation_default_route_table_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the default propagation route table.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the transit gateway.\n')
    transit_gateway_cidr_blocks: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The transit gateway CIDR blocks.\n')
    vpn_ecmp_support: typing.Optional[str] = pydantic.Field(None, description='Enable or disable Equal Cost Multipath Protocol support. Enabled by default.')
    _init_params: typing.ClassVar[list[str]] = ['amazon_side_asn', 'association_default_route_table_id', 'auto_accept_shared_attachments', 'default_route_table_association', 'default_route_table_propagation', 'description', 'dns_support', 'multicast_support', 'propagation_default_route_table_id', 'tags', 'transit_gateway_cidr_blocks', 'vpn_ecmp_support']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGateway'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTransitGatewayDefConfig] = pydantic.Field(None)


class CfnTransitGatewayDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnTransitGatewayDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTransitGatewayDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTransitGatewayDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTransitGatewayDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTransitGatewayDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTransitGatewayDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTransitGatewayDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTransitGatewayDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTransitGatewayDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTransitGatewayDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTransitGatewayDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTransitGatewayDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTransitGatewayDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnTransitGatewayDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTransitGatewayDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTransitGatewayDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTransitGatewayDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTransitGatewayDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTransitGatewayDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTransitGatewayDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTransitGatewayDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnTransitGatewayDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTransitGatewayDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayAttachment
class CfnTransitGatewayAttachmentDef(BaseCfnResource):
    subnet_ids: typing.Sequence[str] = pydantic.Field(..., description='The IDs of one or more subnets. You can specify only one subnet per Availability Zone. You must specify at least one subnet, but we recommend that you specify two subnets for better availability. The transit gateway uses one IP address from each specified subnet.\n')
    transit_gateway_id: str = pydantic.Field(..., description='The ID of the transit gateway.\n')
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC.\n')
    options: typing.Any = pydantic.Field(None, description='The VPC attachment options, in JSON or YAML. - ``ApplianceModeSupport`` - Set to ``enable`` or ``disable`` . The default is ``disable`` . - ``DnsSupport`` - Set to ``enable`` or ``disable`` . The default is ``enable`` . - ``Ipv6Support`` - Set to ``enable`` or ``disable`` . The default is ``disable`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the attachment.')
    _init_params: typing.ClassVar[list[str]] = ['subnet_ids', 'transit_gateway_id', 'vpc_id', 'options', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['OptionsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayAttachment'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTransitGatewayAttachmentDefConfig] = pydantic.Field(None)


class CfnTransitGatewayAttachmentDefConfig(pydantic.BaseModel):
    OptionsProperty: typing.Optional[list[CfnTransitGatewayAttachmentDefOptionspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnTransitGatewayAttachmentDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTransitGatewayAttachmentDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTransitGatewayAttachmentDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTransitGatewayAttachmentDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTransitGatewayAttachmentDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTransitGatewayAttachmentDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTransitGatewayAttachmentDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTransitGatewayAttachmentDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTransitGatewayAttachmentDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTransitGatewayAttachmentDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTransitGatewayAttachmentDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTransitGatewayAttachmentDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTransitGatewayAttachmentDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnTransitGatewayAttachmentDefOptionspropertyParams(pydantic.BaseModel):
    appliance_mode_support: typing.Optional[str] = pydantic.Field(None, description='')
    dns_support: typing.Optional[str] = pydantic.Field(None, description='')
    ipv6_support: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTransitGatewayAttachmentDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTransitGatewayAttachmentDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayAttachmentDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTransitGatewayAttachmentDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayAttachmentDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTransitGatewayAttachmentDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTransitGatewayAttachmentDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTransitGatewayAttachmentDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTransitGatewayAttachmentDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTransitGatewayAttachmentDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayAttachmentDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnTransitGatewayAttachmentDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTransitGatewayAttachmentDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayAttachmentDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayConnect
class CfnTransitGatewayConnectDef(BaseCfnResource):
    options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnTransitGatewayConnect_TransitGatewayConnectOptionsPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The Connect attachment options. - protocol (gre)\n')
    transport_transit_gateway_attachment_id: str = pydantic.Field(..., description='The ID of the attachment from which the Connect attachment was created.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the attachment.')
    _init_params: typing.ClassVar[list[str]] = ['options', 'transport_transit_gateway_attachment_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['TransitGatewayConnectOptionsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayConnect'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTransitGatewayConnectDefConfig] = pydantic.Field(None)


class CfnTransitGatewayConnectDefConfig(pydantic.BaseModel):
    TransitGatewayConnectOptionsProperty: typing.Optional[list[CfnTransitGatewayConnectDefTransitgatewayconnectoptionspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnTransitGatewayConnectDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTransitGatewayConnectDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTransitGatewayConnectDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTransitGatewayConnectDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTransitGatewayConnectDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTransitGatewayConnectDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTransitGatewayConnectDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTransitGatewayConnectDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTransitGatewayConnectDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTransitGatewayConnectDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTransitGatewayConnectDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTransitGatewayConnectDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTransitGatewayConnectDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnTransitGatewayConnectDefTransitgatewayconnectoptionspropertyParams(pydantic.BaseModel):
    protocol: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTransitGatewayConnectDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTransitGatewayConnectDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayConnectDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTransitGatewayConnectDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayConnectDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTransitGatewayConnectDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTransitGatewayConnectDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTransitGatewayConnectDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTransitGatewayConnectDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTransitGatewayConnectDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayConnectDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnTransitGatewayConnectDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTransitGatewayConnectDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayConnectDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayMulticastDomain
class CfnTransitGatewayMulticastDomainDef(BaseCfnResource):
    transit_gateway_id: str = pydantic.Field(..., description='The ID of the transit gateway.\n')
    options: typing.Any = pydantic.Field(None, description='The options for the transit gateway multicast domain. - AutoAcceptSharedAssociations (enable | disable) - Igmpv2Support (enable | disable) - StaticSourcesSupport (enable | disable)\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the transit gateway multicast domain.')
    _init_params: typing.ClassVar[list[str]] = ['transit_gateway_id', 'options', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['OptionsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayMulticastDomain'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTransitGatewayMulticastDomainDefConfig] = pydantic.Field(None)


class CfnTransitGatewayMulticastDomainDefConfig(pydantic.BaseModel):
    OptionsProperty: typing.Optional[list[CfnTransitGatewayMulticastDomainDefOptionspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnTransitGatewayMulticastDomainDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTransitGatewayMulticastDomainDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTransitGatewayMulticastDomainDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTransitGatewayMulticastDomainDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTransitGatewayMulticastDomainDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTransitGatewayMulticastDomainDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTransitGatewayMulticastDomainDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTransitGatewayMulticastDomainDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTransitGatewayMulticastDomainDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTransitGatewayMulticastDomainDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTransitGatewayMulticastDomainDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTransitGatewayMulticastDomainDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTransitGatewayMulticastDomainDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnTransitGatewayMulticastDomainDefOptionspropertyParams(pydantic.BaseModel):
    auto_accept_shared_associations: typing.Optional[str] = pydantic.Field(None, description='')
    igmpv2_support: typing.Optional[str] = pydantic.Field(None, description='')
    static_sources_support: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTransitGatewayMulticastDomainDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTransitGatewayMulticastDomainDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayMulticastDomainDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTransitGatewayMulticastDomainDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayMulticastDomainDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTransitGatewayMulticastDomainDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTransitGatewayMulticastDomainDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTransitGatewayMulticastDomainDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTransitGatewayMulticastDomainDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTransitGatewayMulticastDomainDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayMulticastDomainDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnTransitGatewayMulticastDomainDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTransitGatewayMulticastDomainDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayMulticastDomainDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayMulticastDomainAssociation
class CfnTransitGatewayMulticastDomainAssociationDef(BaseCfnResource):
    subnet_id: str = pydantic.Field(..., description='The IDs of the subnets to associate with the transit gateway multicast domain.\n')
    transit_gateway_attachment_id: str = pydantic.Field(..., description='The ID of the transit gateway attachment.\n')
    transit_gateway_multicast_domain_id: str = pydantic.Field(..., description='The ID of the transit gateway multicast domain.')
    _init_params: typing.ClassVar[list[str]] = ['subnet_id', 'transit_gateway_attachment_id', 'transit_gateway_multicast_domain_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayMulticastDomainAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTransitGatewayMulticastDomainAssociationDefConfig] = pydantic.Field(None)


class CfnTransitGatewayMulticastDomainAssociationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnTransitGatewayMulticastDomainAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTransitGatewayMulticastDomainAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTransitGatewayMulticastDomainAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTransitGatewayMulticastDomainAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTransitGatewayMulticastDomainAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTransitGatewayMulticastDomainAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTransitGatewayMulticastDomainAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTransitGatewayMulticastDomainAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTransitGatewayMulticastDomainAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTransitGatewayMulticastDomainAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTransitGatewayMulticastDomainAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTransitGatewayMulticastDomainAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTransitGatewayMulticastDomainAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnTransitGatewayMulticastDomainAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTransitGatewayMulticastDomainAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayMulticastDomainAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTransitGatewayMulticastDomainAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayMulticastDomainAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTransitGatewayMulticastDomainAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTransitGatewayMulticastDomainAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTransitGatewayMulticastDomainAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTransitGatewayMulticastDomainAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTransitGatewayMulticastDomainAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayMulticastDomainAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnTransitGatewayMulticastDomainAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTransitGatewayMulticastDomainAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayMulticastDomainAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayMulticastGroupMember
class CfnTransitGatewayMulticastGroupMemberDef(BaseCfnResource):
    group_ip_address: str = pydantic.Field(..., description='The IP address assigned to the transit gateway multicast group.\n')
    network_interface_id: str = pydantic.Field(..., description="The group members' network interface IDs to register with the transit gateway multicast group.\n")
    transit_gateway_multicast_domain_id: str = pydantic.Field(..., description='The ID of the transit gateway multicast domain.')
    _init_params: typing.ClassVar[list[str]] = ['group_ip_address', 'network_interface_id', 'transit_gateway_multicast_domain_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayMulticastGroupMember'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTransitGatewayMulticastGroupMemberDefConfig] = pydantic.Field(None)


class CfnTransitGatewayMulticastGroupMemberDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnTransitGatewayMulticastGroupMemberDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTransitGatewayMulticastGroupMemberDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTransitGatewayMulticastGroupMemberDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTransitGatewayMulticastGroupMemberDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTransitGatewayMulticastGroupMemberDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTransitGatewayMulticastGroupMemberDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTransitGatewayMulticastGroupMemberDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTransitGatewayMulticastGroupMemberDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTransitGatewayMulticastGroupMemberDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTransitGatewayMulticastGroupMemberDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTransitGatewayMulticastGroupMemberDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTransitGatewayMulticastGroupMemberDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTransitGatewayMulticastGroupMemberDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_group_member_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_group_source_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)

class CfnTransitGatewayMulticastGroupMemberDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTransitGatewayMulticastGroupMemberDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayMulticastGroupMemberDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTransitGatewayMulticastGroupMemberDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayMulticastGroupMemberDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTransitGatewayMulticastGroupMemberDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTransitGatewayMulticastGroupMemberDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTransitGatewayMulticastGroupMemberDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTransitGatewayMulticastGroupMemberDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTransitGatewayMulticastGroupMemberDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayMulticastGroupMemberDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnTransitGatewayMulticastGroupMemberDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTransitGatewayMulticastGroupMemberDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayMulticastGroupMemberDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayMulticastGroupSource
class CfnTransitGatewayMulticastGroupSourceDef(BaseCfnResource):
    group_ip_address: str = pydantic.Field(..., description='The IP address assigned to the transit gateway multicast group.\n')
    network_interface_id: str = pydantic.Field(..., description="The group sources' network interface IDs to register with the transit gateway multicast group.\n")
    transit_gateway_multicast_domain_id: str = pydantic.Field(..., description='The ID of the transit gateway multicast domain.')
    _init_params: typing.ClassVar[list[str]] = ['group_ip_address', 'network_interface_id', 'transit_gateway_multicast_domain_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayMulticastGroupSource'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTransitGatewayMulticastGroupSourceDefConfig] = pydantic.Field(None)


class CfnTransitGatewayMulticastGroupSourceDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnTransitGatewayMulticastGroupSourceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTransitGatewayMulticastGroupSourceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTransitGatewayMulticastGroupSourceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTransitGatewayMulticastGroupSourceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTransitGatewayMulticastGroupSourceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTransitGatewayMulticastGroupSourceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTransitGatewayMulticastGroupSourceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTransitGatewayMulticastGroupSourceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTransitGatewayMulticastGroupSourceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTransitGatewayMulticastGroupSourceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTransitGatewayMulticastGroupSourceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTransitGatewayMulticastGroupSourceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTransitGatewayMulticastGroupSourceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    attr_group_member_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)
    attr_group_source_config: typing.Optional[models._interface_methods.CoreIResolvableDefConfig] = pydantic.Field(None)

class CfnTransitGatewayMulticastGroupSourceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTransitGatewayMulticastGroupSourceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayMulticastGroupSourceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTransitGatewayMulticastGroupSourceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayMulticastGroupSourceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTransitGatewayMulticastGroupSourceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTransitGatewayMulticastGroupSourceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTransitGatewayMulticastGroupSourceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTransitGatewayMulticastGroupSourceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTransitGatewayMulticastGroupSourceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayMulticastGroupSourceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnTransitGatewayMulticastGroupSourceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTransitGatewayMulticastGroupSourceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayMulticastGroupSourceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayPeeringAttachment
class CfnTransitGatewayPeeringAttachmentDef(BaseCfnResource):
    peer_account_id: str = pydantic.Field(..., description='The ID of the AWS account that owns the transit gateway.\n')
    peer_region: str = pydantic.Field(..., description='The Region of the transit gateway.\n')
    peer_transit_gateway_id: str = pydantic.Field(..., description='The ID of the transit gateway.\n')
    transit_gateway_id: str = pydantic.Field(..., description='The ID of the transit gateway peering attachment.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the transit gateway peering attachment.')
    _init_params: typing.ClassVar[list[str]] = ['peer_account_id', 'peer_region', 'peer_transit_gateway_id', 'transit_gateway_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['PeeringAttachmentStatusProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayPeeringAttachment'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTransitGatewayPeeringAttachmentDefConfig] = pydantic.Field(None)


class CfnTransitGatewayPeeringAttachmentDefConfig(pydantic.BaseModel):
    PeeringAttachmentStatusProperty: typing.Optional[list[CfnTransitGatewayPeeringAttachmentDefPeeringattachmentstatuspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnTransitGatewayPeeringAttachmentDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTransitGatewayPeeringAttachmentDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTransitGatewayPeeringAttachmentDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTransitGatewayPeeringAttachmentDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTransitGatewayPeeringAttachmentDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTransitGatewayPeeringAttachmentDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTransitGatewayPeeringAttachmentDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTransitGatewayPeeringAttachmentDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTransitGatewayPeeringAttachmentDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTransitGatewayPeeringAttachmentDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTransitGatewayPeeringAttachmentDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTransitGatewayPeeringAttachmentDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTransitGatewayPeeringAttachmentDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnTransitGatewayPeeringAttachmentDefPeeringattachmentstatuspropertyParams(pydantic.BaseModel):
    code: typing.Optional[str] = pydantic.Field(None, description='')
    message: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTransitGatewayPeeringAttachmentDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTransitGatewayPeeringAttachmentDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayPeeringAttachmentDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTransitGatewayPeeringAttachmentDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayPeeringAttachmentDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTransitGatewayPeeringAttachmentDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTransitGatewayPeeringAttachmentDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTransitGatewayPeeringAttachmentDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTransitGatewayPeeringAttachmentDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTransitGatewayPeeringAttachmentDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayPeeringAttachmentDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnTransitGatewayPeeringAttachmentDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTransitGatewayPeeringAttachmentDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayPeeringAttachmentDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayRoute
class CfnTransitGatewayRouteDef(BaseCfnResource):
    transit_gateway_route_table_id: str = pydantic.Field(..., description='The ID of the transit gateway route table.\n')
    blackhole: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to drop traffic that matches this route.\n')
    destination_cidr_block: typing.Optional[str] = pydantic.Field(None, description='The CIDR block used for destination matches.\n')
    transit_gateway_attachment_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the attachment.')
    _init_params: typing.ClassVar[list[str]] = ['transit_gateway_route_table_id', 'blackhole', 'destination_cidr_block', 'transit_gateway_attachment_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayRoute'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTransitGatewayRouteDefConfig] = pydantic.Field(None)


class CfnTransitGatewayRouteDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnTransitGatewayRouteDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTransitGatewayRouteDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTransitGatewayRouteDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTransitGatewayRouteDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTransitGatewayRouteDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTransitGatewayRouteDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTransitGatewayRouteDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTransitGatewayRouteDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTransitGatewayRouteDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTransitGatewayRouteDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTransitGatewayRouteDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTransitGatewayRouteDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTransitGatewayRouteDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnTransitGatewayRouteDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTransitGatewayRouteDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayRouteDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTransitGatewayRouteDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayRouteDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTransitGatewayRouteDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTransitGatewayRouteDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTransitGatewayRouteDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTransitGatewayRouteDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTransitGatewayRouteDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayRouteDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnTransitGatewayRouteDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTransitGatewayRouteDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayRouteDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayRouteTable
class CfnTransitGatewayRouteTableDef(BaseCfnResource):
    transit_gateway_id: str = pydantic.Field(..., description='The ID of the transit gateway.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Any tags assigned to the route table.')
    _init_params: typing.ClassVar[list[str]] = ['transit_gateway_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayRouteTable'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTransitGatewayRouteTableDefConfig] = pydantic.Field(None)


class CfnTransitGatewayRouteTableDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnTransitGatewayRouteTableDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTransitGatewayRouteTableDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTransitGatewayRouteTableDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTransitGatewayRouteTableDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTransitGatewayRouteTableDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTransitGatewayRouteTableDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTransitGatewayRouteTableDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTransitGatewayRouteTableDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTransitGatewayRouteTableDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTransitGatewayRouteTableDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTransitGatewayRouteTableDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTransitGatewayRouteTableDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTransitGatewayRouteTableDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnTransitGatewayRouteTableDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTransitGatewayRouteTableDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayRouteTableDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTransitGatewayRouteTableDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayRouteTableDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTransitGatewayRouteTableDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTransitGatewayRouteTableDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTransitGatewayRouteTableDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTransitGatewayRouteTableDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTransitGatewayRouteTableDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayRouteTableDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnTransitGatewayRouteTableDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTransitGatewayRouteTableDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayRouteTableDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayRouteTableAssociation
class CfnTransitGatewayRouteTableAssociationDef(BaseCfnResource):
    transit_gateway_attachment_id: str = pydantic.Field(..., description='The ID of the attachment.\n')
    transit_gateway_route_table_id: str = pydantic.Field(..., description='The ID of the route table for the transit gateway.')
    _init_params: typing.ClassVar[list[str]] = ['transit_gateway_attachment_id', 'transit_gateway_route_table_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayRouteTableAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTransitGatewayRouteTableAssociationDefConfig] = pydantic.Field(None)


class CfnTransitGatewayRouteTableAssociationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnTransitGatewayRouteTableAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTransitGatewayRouteTableAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTransitGatewayRouteTableAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTransitGatewayRouteTableAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTransitGatewayRouteTableAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTransitGatewayRouteTableAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTransitGatewayRouteTableAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTransitGatewayRouteTableAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTransitGatewayRouteTableAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTransitGatewayRouteTableAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTransitGatewayRouteTableAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTransitGatewayRouteTableAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTransitGatewayRouteTableAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnTransitGatewayRouteTableAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTransitGatewayRouteTableAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayRouteTableAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTransitGatewayRouteTableAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayRouteTableAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTransitGatewayRouteTableAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTransitGatewayRouteTableAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTransitGatewayRouteTableAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTransitGatewayRouteTableAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTransitGatewayRouteTableAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayRouteTableAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnTransitGatewayRouteTableAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTransitGatewayRouteTableAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayRouteTableAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayRouteTablePropagation
class CfnTransitGatewayRouteTablePropagationDef(BaseCfnResource):
    transit_gateway_attachment_id: str = pydantic.Field(..., description='The ID of the attachment.\n')
    transit_gateway_route_table_id: str = pydantic.Field(..., description='The ID of the propagation route table.')
    _init_params: typing.ClassVar[list[str]] = ['transit_gateway_attachment_id', 'transit_gateway_route_table_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayRouteTablePropagation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTransitGatewayRouteTablePropagationDefConfig] = pydantic.Field(None)


class CfnTransitGatewayRouteTablePropagationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnTransitGatewayRouteTablePropagationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTransitGatewayRouteTablePropagationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTransitGatewayRouteTablePropagationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTransitGatewayRouteTablePropagationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTransitGatewayRouteTablePropagationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTransitGatewayRouteTablePropagationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTransitGatewayRouteTablePropagationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTransitGatewayRouteTablePropagationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTransitGatewayRouteTablePropagationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTransitGatewayRouteTablePropagationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTransitGatewayRouteTablePropagationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTransitGatewayRouteTablePropagationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTransitGatewayRouteTablePropagationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnTransitGatewayRouteTablePropagationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTransitGatewayRouteTablePropagationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayRouteTablePropagationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTransitGatewayRouteTablePropagationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayRouteTablePropagationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTransitGatewayRouteTablePropagationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTransitGatewayRouteTablePropagationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTransitGatewayRouteTablePropagationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTransitGatewayRouteTablePropagationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTransitGatewayRouteTablePropagationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayRouteTablePropagationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnTransitGatewayRouteTablePropagationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTransitGatewayRouteTablePropagationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayRouteTablePropagationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayVpcAttachment
class CfnTransitGatewayVpcAttachmentDef(BaseCfnResource):
    subnet_ids: typing.Sequence[str] = pydantic.Field(..., description='The IDs of the subnets.\n')
    transit_gateway_id: str = pydantic.Field(..., description='The ID of the transit gateway.\n')
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC.\n')
    add_subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of one or more subnets to add. You can specify at most one subnet per Availability Zone.\n')
    options: typing.Any = pydantic.Field(None, description='The VPC attachment options, in JSON or YAML. - ``ApplianceModeSupport`` - Set to ``enable`` or ``disable`` . The default is ``disable`` . - ``DnsSupport`` - Set to ``enable`` or ``disable`` . The default is ``enable`` . - ``Ipv6Support`` - Set to ``enable`` or ``disable`` . The default is ``disable`` .\n')
    remove_subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of one or more subnets to remove.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the VPC attachment.')
    _init_params: typing.ClassVar[list[str]] = ['subnet_ids', 'transit_gateway_id', 'vpc_id', 'add_subnet_ids', 'options', 'remove_subnet_ids', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['OptionsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayVpcAttachment'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnTransitGatewayVpcAttachmentDefConfig] = pydantic.Field(None)


class CfnTransitGatewayVpcAttachmentDefConfig(pydantic.BaseModel):
    OptionsProperty: typing.Optional[list[CfnTransitGatewayVpcAttachmentDefOptionspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnTransitGatewayVpcAttachmentDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnTransitGatewayVpcAttachmentDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnTransitGatewayVpcAttachmentDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnTransitGatewayVpcAttachmentDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnTransitGatewayVpcAttachmentDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnTransitGatewayVpcAttachmentDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnTransitGatewayVpcAttachmentDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnTransitGatewayVpcAttachmentDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnTransitGatewayVpcAttachmentDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnTransitGatewayVpcAttachmentDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnTransitGatewayVpcAttachmentDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnTransitGatewayVpcAttachmentDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnTransitGatewayVpcAttachmentDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnTransitGatewayVpcAttachmentDefOptionspropertyParams(pydantic.BaseModel):
    appliance_mode_support: typing.Optional[str] = pydantic.Field(None, description='')
    dns_support: typing.Optional[str] = pydantic.Field(None, description='')
    ipv6_support: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnTransitGatewayVpcAttachmentDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnTransitGatewayVpcAttachmentDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayVpcAttachmentDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnTransitGatewayVpcAttachmentDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayVpcAttachmentDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnTransitGatewayVpcAttachmentDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnTransitGatewayVpcAttachmentDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnTransitGatewayVpcAttachmentDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnTransitGatewayVpcAttachmentDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnTransitGatewayVpcAttachmentDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnTransitGatewayVpcAttachmentDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnTransitGatewayVpcAttachmentDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnTransitGatewayVpcAttachmentDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnTransitGatewayVpcAttachmentDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnVerifiedAccessEndpoint
class CfnVerifiedAccessEndpointDef(BaseCfnResource):
    application_domain: str = pydantic.Field(..., description='The DNS name for users to reach your application.\n')
    attachment_type: str = pydantic.Field(..., description='The type of attachment used to provide connectivity between the AWS Verified Access endpoint and the application.\n')
    domain_certificate_arn: str = pydantic.Field(..., description='The ARN of a public TLS/SSL certificate imported into or created with ACM.\n')
    endpoint_domain_prefix: str = pydantic.Field(..., description='A custom identifier that is prepended to the DNS name that is generated for the endpoint.\n')
    endpoint_type: str = pydantic.Field(..., description='The type of AWS Verified Access endpoint. Incoming application requests will be sent to an IP address, load balancer or a network interface depending on the endpoint type specified.\n')
    verified_access_group_id: str = pydantic.Field(..., description='The ID of the AWS Verified Access group.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the AWS Verified Access endpoint.\n')
    load_balancer_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnVerifiedAccessEndpoint_LoadBalancerOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The load balancer details if creating the AWS Verified Access endpoint as ``load-balancer`` type.\n')
    network_interface_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnVerifiedAccessEndpoint_NetworkInterfaceOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for network-interface type endpoint.\n')
    policy_document: typing.Optional[str] = pydantic.Field(None, description='The Verified Access policy document.\n')
    policy_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='The status of the Verified Access policy.\n')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of the security groups for the endpoint.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags.')
    _init_params: typing.ClassVar[list[str]] = ['application_domain', 'attachment_type', 'domain_certificate_arn', 'endpoint_domain_prefix', 'endpoint_type', 'verified_access_group_id', 'description', 'load_balancer_options', 'network_interface_options', 'policy_document', 'policy_enabled', 'security_group_ids', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['LoadBalancerOptionsProperty', 'NetworkInterfaceOptionsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVerifiedAccessEndpoint'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVerifiedAccessEndpointDefConfig] = pydantic.Field(None)


class CfnVerifiedAccessEndpointDefConfig(pydantic.BaseModel):
    LoadBalancerOptionsProperty: typing.Optional[list[CfnVerifiedAccessEndpointDefLoadbalanceroptionspropertyParams]] = pydantic.Field(None, description='')
    NetworkInterfaceOptionsProperty: typing.Optional[list[CfnVerifiedAccessEndpointDefNetworkinterfaceoptionspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnVerifiedAccessEndpointDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVerifiedAccessEndpointDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVerifiedAccessEndpointDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVerifiedAccessEndpointDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVerifiedAccessEndpointDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVerifiedAccessEndpointDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVerifiedAccessEndpointDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVerifiedAccessEndpointDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVerifiedAccessEndpointDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVerifiedAccessEndpointDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVerifiedAccessEndpointDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVerifiedAccessEndpointDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVerifiedAccessEndpointDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnVerifiedAccessEndpointDefLoadbalanceroptionspropertyParams(pydantic.BaseModel):
    load_balancer_arn: typing.Optional[str] = pydantic.Field(None, description='')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    protocol: typing.Optional[str] = pydantic.Field(None, description='')
    subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='')
    ...

class CfnVerifiedAccessEndpointDefNetworkinterfaceoptionspropertyParams(pydantic.BaseModel):
    network_interface_id: typing.Optional[str] = pydantic.Field(None, description='')
    port: typing.Union[int, float, None] = pydantic.Field(None, description='')
    protocol: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnVerifiedAccessEndpointDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVerifiedAccessEndpointDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVerifiedAccessEndpointDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVerifiedAccessEndpointDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVerifiedAccessEndpointDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVerifiedAccessEndpointDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVerifiedAccessEndpointDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVerifiedAccessEndpointDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVerifiedAccessEndpointDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVerifiedAccessEndpointDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVerifiedAccessEndpointDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVerifiedAccessEndpointDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVerifiedAccessEndpointDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVerifiedAccessEndpointDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnVerifiedAccessGroup
class CfnVerifiedAccessGroupDef(BaseCfnResource):
    verified_access_instance_id: str = pydantic.Field(..., description='The ID of the AWS Verified Access instance.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the AWS Verified Access group.\n')
    policy_document: typing.Optional[str] = pydantic.Field(None, description='The Verified Access policy document.\n')
    policy_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='The status of the Verified Access policy.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags.')
    _init_params: typing.ClassVar[list[str]] = ['verified_access_instance_id', 'description', 'policy_document', 'policy_enabled', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVerifiedAccessGroup'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVerifiedAccessGroupDefConfig] = pydantic.Field(None)


class CfnVerifiedAccessGroupDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnVerifiedAccessGroupDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVerifiedAccessGroupDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVerifiedAccessGroupDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVerifiedAccessGroupDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVerifiedAccessGroupDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVerifiedAccessGroupDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVerifiedAccessGroupDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVerifiedAccessGroupDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVerifiedAccessGroupDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVerifiedAccessGroupDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVerifiedAccessGroupDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVerifiedAccessGroupDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVerifiedAccessGroupDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnVerifiedAccessGroupDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVerifiedAccessGroupDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVerifiedAccessGroupDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVerifiedAccessGroupDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVerifiedAccessGroupDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVerifiedAccessGroupDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVerifiedAccessGroupDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVerifiedAccessGroupDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVerifiedAccessGroupDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVerifiedAccessGroupDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVerifiedAccessGroupDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVerifiedAccessGroupDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVerifiedAccessGroupDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVerifiedAccessGroupDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnVerifiedAccessInstance
class CfnVerifiedAccessInstanceDef(BaseCfnResource):
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the AWS Verified Access instance.\n')
    logging_configurations: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnVerifiedAccessInstance_VerifiedAccessLogsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The current logging configuration for the Verified Access instances.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags.\n')
    verified_access_trust_provider_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of the AWS Verified Access trust providers.\n')
    verified_access_trust_providers: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnVerifiedAccessInstance_VerifiedAccessTrustProviderPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The IDs of the AWS Verified Access trust providers.')
    _init_params: typing.ClassVar[list[str]] = ['description', 'logging_configurations', 'tags', 'verified_access_trust_provider_ids', 'verified_access_trust_providers']
    _method_names: typing.ClassVar[list[str]] = ['CloudWatchLogsProperty', 'KinesisDataFirehoseProperty', 'S3Property', 'VerifiedAccessLogsProperty', 'VerifiedAccessTrustProviderProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVerifiedAccessInstance'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVerifiedAccessInstanceDefConfig] = pydantic.Field(None)


class CfnVerifiedAccessInstanceDefConfig(pydantic.BaseModel):
    CloudWatchLogsProperty: typing.Optional[list[CfnVerifiedAccessInstanceDefCloudwatchlogspropertyParams]] = pydantic.Field(None, description='')
    KinesisDataFirehoseProperty: typing.Optional[list[CfnVerifiedAccessInstanceDefKinesisdatafirehosepropertyParams]] = pydantic.Field(None, description='')
    S3Property: typing.Optional[list[CfnVerifiedAccessInstanceDefS3PropertyParams]] = pydantic.Field(None, description='')
    VerifiedAccessLogsProperty: typing.Optional[list[CfnVerifiedAccessInstanceDefVerifiedaccesslogspropertyParams]] = pydantic.Field(None, description='')
    VerifiedAccessTrustProviderProperty: typing.Optional[list[CfnVerifiedAccessInstanceDefVerifiedaccesstrustproviderpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnVerifiedAccessInstanceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVerifiedAccessInstanceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVerifiedAccessInstanceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVerifiedAccessInstanceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVerifiedAccessInstanceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVerifiedAccessInstanceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVerifiedAccessInstanceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVerifiedAccessInstanceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVerifiedAccessInstanceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVerifiedAccessInstanceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVerifiedAccessInstanceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVerifiedAccessInstanceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVerifiedAccessInstanceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnVerifiedAccessInstanceDefCloudwatchlogspropertyParams(pydantic.BaseModel):
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    log_group: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnVerifiedAccessInstanceDefKinesisdatafirehosepropertyParams(pydantic.BaseModel):
    delivery_stream: typing.Optional[str] = pydantic.Field(None, description='')
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    ...

class CfnVerifiedAccessInstanceDefS3PropertyParams(pydantic.BaseModel):
    bucket_name: typing.Optional[str] = pydantic.Field(None, description='')
    bucket_owner: typing.Optional[str] = pydantic.Field(None, description='')
    enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='')
    prefix: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnVerifiedAccessInstanceDefVerifiedaccesslogspropertyParams(pydantic.BaseModel):
    cloud_watch_logs: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnVerifiedAccessInstance_CloudWatchLogsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    kinesis_data_firehose: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnVerifiedAccessInstance_KinesisDataFirehosePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    s3: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnVerifiedAccessInstance_S3PropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='')
    ...

class CfnVerifiedAccessInstanceDefVerifiedaccesstrustproviderpropertyParams(pydantic.BaseModel):
    description: typing.Optional[str] = pydantic.Field(None, description='')
    device_trust_provider_type: typing.Optional[str] = pydantic.Field(None, description='')
    trust_provider_type: typing.Optional[str] = pydantic.Field(None, description='')
    user_trust_provider_type: typing.Optional[str] = pydantic.Field(None, description='')
    verified_access_trust_provider_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnVerifiedAccessInstanceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVerifiedAccessInstanceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVerifiedAccessInstanceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVerifiedAccessInstanceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVerifiedAccessInstanceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVerifiedAccessInstanceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVerifiedAccessInstanceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVerifiedAccessInstanceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVerifiedAccessInstanceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVerifiedAccessInstanceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVerifiedAccessInstanceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVerifiedAccessInstanceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVerifiedAccessInstanceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVerifiedAccessInstanceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnVerifiedAccessTrustProvider
class CfnVerifiedAccessTrustProviderDef(BaseCfnResource):
    policy_reference_name: str = pydantic.Field(..., description='The identifier to be used when working with policy rules.\n')
    trust_provider_type: str = pydantic.Field(..., description='The type of Verified Access trust provider.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the AWS Verified Access trust provider.\n')
    device_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnVerifiedAccessTrustProvider_DeviceOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for device-identity trust provider.\n')
    device_trust_provider_type: typing.Optional[str] = pydantic.Field(None, description='The type of device-based trust provider.\n')
    oidc_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnVerifiedAccessTrustProvider_OidcOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for an OpenID Connect-compatible user-identity trust provider.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags.\n')
    user_trust_provider_type: typing.Optional[str] = pydantic.Field(None, description='The type of user-based trust provider.')
    _init_params: typing.ClassVar[list[str]] = ['policy_reference_name', 'trust_provider_type', 'description', 'device_options', 'device_trust_provider_type', 'oidc_options', 'tags', 'user_trust_provider_type']
    _method_names: typing.ClassVar[list[str]] = ['DeviceOptionsProperty', 'OidcOptionsProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVerifiedAccessTrustProvider'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVerifiedAccessTrustProviderDefConfig] = pydantic.Field(None)


class CfnVerifiedAccessTrustProviderDefConfig(pydantic.BaseModel):
    DeviceOptionsProperty: typing.Optional[list[CfnVerifiedAccessTrustProviderDefDeviceoptionspropertyParams]] = pydantic.Field(None, description='')
    OidcOptionsProperty: typing.Optional[list[CfnVerifiedAccessTrustProviderDefOidcoptionspropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnVerifiedAccessTrustProviderDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVerifiedAccessTrustProviderDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVerifiedAccessTrustProviderDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVerifiedAccessTrustProviderDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVerifiedAccessTrustProviderDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVerifiedAccessTrustProviderDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVerifiedAccessTrustProviderDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVerifiedAccessTrustProviderDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVerifiedAccessTrustProviderDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVerifiedAccessTrustProviderDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVerifiedAccessTrustProviderDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVerifiedAccessTrustProviderDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVerifiedAccessTrustProviderDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnVerifiedAccessTrustProviderDefDeviceoptionspropertyParams(pydantic.BaseModel):
    tenant_id: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnVerifiedAccessTrustProviderDefOidcoptionspropertyParams(pydantic.BaseModel):
    authorization_endpoint: typing.Optional[str] = pydantic.Field(None, description='')
    client_id: typing.Optional[str] = pydantic.Field(None, description='')
    client_secret: typing.Optional[str] = pydantic.Field(None, description='')
    issuer: typing.Optional[str] = pydantic.Field(None, description='')
    scope: typing.Optional[str] = pydantic.Field(None, description='')
    token_endpoint: typing.Optional[str] = pydantic.Field(None, description='')
    user_info_endpoint: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnVerifiedAccessTrustProviderDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVerifiedAccessTrustProviderDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVerifiedAccessTrustProviderDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVerifiedAccessTrustProviderDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVerifiedAccessTrustProviderDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVerifiedAccessTrustProviderDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVerifiedAccessTrustProviderDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVerifiedAccessTrustProviderDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVerifiedAccessTrustProviderDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVerifiedAccessTrustProviderDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVerifiedAccessTrustProviderDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVerifiedAccessTrustProviderDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVerifiedAccessTrustProviderDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVerifiedAccessTrustProviderDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnVolume
class CfnVolumeDef(BaseCfnResource):
    availability_zone: str = pydantic.Field(..., description='The ID of the Availability Zone in which to create the volume. For example, ``us-east-1a`` .\n')
    auto_enable_io: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Indicates whether the volume is auto-enabled for I/O operations. By default, Amazon EBS disables I/O to the volume from attached EC2 instances when it determines that a volume's data is potentially inconsistent. If the consistency of the volume is not a concern, and you prefer that the volume be made available immediately if it's impaired, you can configure the volume to automatically enable I/O.\n")
    encrypted: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether the volume should be encrypted. The effect of setting the encryption state to ``true`` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Encryption by default <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default>`_ in the *Amazon Elastic Compute Cloud User Guide* . Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see `Supported instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances>`_ .\n')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='The number of I/O operations per second (IOPS). For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. The following are the supported values for each volume type: - ``gp3`` : 3,000-16,000 IOPS - ``io1`` : 100-64,000 IOPS - ``io2`` : 100-64,000 IOPS ``io1`` and ``io2`` volumes support up to 64,000 IOPS only on `Instances built on the Nitro System <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ . Other instance families support performance up to 32,000 IOPS. This parameter is required for ``io1`` and ``io2`` volumes. The default for ``gp3`` volumes is 3,000 IOPS. This parameter is not supported for ``gp2`` , ``st1`` , ``sc1`` , or ``standard`` volumes.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the AWS KMS key to use for Amazon EBS encryption. If ``KmsKeyId`` is specified, the encrypted state must be ``true`` . If you omit this property and your account is enabled for encryption by default, or *Encrypted* is set to ``true`` , then the volume is encrypted using the default key specified for your account. If your account does not have a default key, then the volume is encrypted using the AWS managed key . Alternatively, if you want to specify a different key, you can specify one of the following: - Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab. - Key alias. Specify the alias for the key, prefixed with ``alias/`` . For example, for a key with the alias ``my_cmk`` , use ``alias/my_cmk`` . Or to specify the AWS managed key , use ``alias/aws/ebs`` . - Key ARN. For example, arn:aws:kms:us-east-1:012345678910:key/1234abcd-12ab-34cd-56ef-1234567890ab. - Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias.\n')
    multi_attach_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether Amazon EBS Multi-Attach is enabled. AWS CloudFormation does not currently support updating a single-attach volume to be multi-attach enabled, updating a multi-attach enabled volume to be single-attach, or updating the size or number of I/O operations per second (IOPS) of a multi-attach enabled volume.\n')
    outpost_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the Outpost.\n')
    size: typing.Union[int, float, None] = pydantic.Field(None, description='The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size. The following are the supported volumes sizes for each volume type: - ``gp2`` and ``gp3`` : 1-16,384 - ``io1`` and ``io2`` : 4-16,384 - ``st1`` and ``sc1`` : 125-16,384 - ``standard`` : 1-1,024\n')
    snapshot_id: typing.Optional[str] = pydantic.Field(None, description='The snapshot from which to create the volume. You must specify either a snapshot ID or a volume size.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to apply to the volume during creation.\n')
    throughput: typing.Union[int, float, None] = pydantic.Field(None, description='The throughput to provision for a volume, with a maximum of 1,000 MiB/s. This parameter is valid only for ``gp3`` volumes. The default value is 125. Valid Range: Minimum value of 125. Maximum value of 1000.\n')
    volume_type: typing.Optional[str] = pydantic.Field(None, description='The volume type. This parameter can be one of the following values:. - General Purpose SSD: ``gp2`` | ``gp3`` - Provisioned IOPS SSD: ``io1`` | ``io2`` - Throughput Optimized HDD: ``st1`` - Cold HDD: ``sc1`` - Magnetic: ``standard`` For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>`_ in the *Amazon Elastic Compute Cloud User Guide* . Default: ``gp2``')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'auto_enable_io', 'encrypted', 'iops', 'kms_key_id', 'multi_attach_enabled', 'outpost_arn', 'size', 'snapshot_id', 'tags', 'throughput', 'volume_type']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVolume'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVolumeDefConfig] = pydantic.Field(None)


class CfnVolumeDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnVolumeDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVolumeDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVolumeDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVolumeDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVolumeDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVolumeDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVolumeDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVolumeDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVolumeDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVolumeDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVolumeDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVolumeDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVolumeDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnVolumeDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVolumeDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVolumeDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVolumeDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVolumeDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVolumeDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVolumeDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVolumeDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVolumeDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVolumeDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVolumeDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVolumeDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVolumeDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVolumeDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnVolumeAttachment
class CfnVolumeAttachmentDef(BaseCfnResource):
    device: str = pydantic.Field(..., description='The device name (for example, ``/dev/sdh`` or ``xvdh`` ).\n')
    instance_id: str = pydantic.Field(..., description='The ID of the instance to which the volume attaches. This value can be a reference to an ```AWS::EC2::Instance`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource, or it can be the physical ID of an existing EC2 instance.\n')
    volume_id: str = pydantic.Field(..., description='The ID of the Amazon EBS volume. The volume and instance must be within the same Availability Zone. This value can be a reference to an ```AWS::EC2::Volume`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html>`_ resource, or it can be the volume ID of an existing Amazon EBS volume.')
    _init_params: typing.ClassVar[list[str]] = ['device', 'instance_id', 'volume_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVolumeAttachment'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVolumeAttachmentDefConfig] = pydantic.Field(None)


class CfnVolumeAttachmentDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnVolumeAttachmentDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVolumeAttachmentDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVolumeAttachmentDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVolumeAttachmentDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVolumeAttachmentDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVolumeAttachmentDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVolumeAttachmentDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVolumeAttachmentDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVolumeAttachmentDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVolumeAttachmentDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVolumeAttachmentDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVolumeAttachmentDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVolumeAttachmentDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnVolumeAttachmentDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVolumeAttachmentDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVolumeAttachmentDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVolumeAttachmentDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVolumeAttachmentDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVolumeAttachmentDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVolumeAttachmentDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVolumeAttachmentDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVolumeAttachmentDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVolumeAttachmentDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVolumeAttachmentDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVolumeAttachmentDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVolumeAttachmentDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVolumeAttachmentDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnVPC
class CfnVPCDef(BaseCfnResource):
    cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv4 network range for the VPC, in CIDR notation. For example, ``10.0.0.0/16`` . We modify the specified CIDR block to its canonical form; for example, if you specify ``100.68.0.18/18`` , we modify it to ``100.68.0.0/18`` . You must specify either ``CidrBlock`` or ``Ipv4IpamPoolId`` .\n')
    enable_dns_hostnames: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Indicates whether the instances launched in the VPC get DNS hostnames. If enabled, instances in the VPC get DNS hostnames; otherwise, they do not. Disabled by default for nondefault VPCs. For more information, see `DNS attributes in your VPC <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support>`_ . You can only enable DNS hostnames if you've enabled DNS support.\n")
    enable_dns_support: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether the DNS resolution is supported for the VPC. If enabled, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC network range "plus two" succeed. If disabled, the Amazon provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is not enabled. Enabled by default. For more information, see `DNS attributes in your VPC <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support>`_ .\n')
    instance_tenancy: typing.Optional[str] = pydantic.Field(None, description='The allowed tenancy of instances launched into the VPC. - ``default`` : An instance launched into the VPC runs on shared hardware by default, unless you explicitly specify a different tenancy during instance launch. - ``dedicated`` : An instance launched into the VPC runs on dedicated hardware by default, unless you explicitly specify a tenancy of ``host`` during instance launch. You cannot specify a tenancy of ``default`` during instance launch. Updating ``InstanceTenancy`` requires no replacement only if you are updating its value from ``dedicated`` to ``default`` . Updating ``InstanceTenancy`` from ``default`` to ``dedicated`` requires replacement.\n')
    ipv4_ipam_pool_id: typing.Optional[str] = pydantic.Field(None, description="The ID of an IPv4 IPAM pool you want to use for allocating this VPC's CIDR. For more information, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* . You must specify either ``CidrBlock`` or ``Ipv4IpamPoolId`` .\n")
    ipv4_netmask_length: typing.Union[int, float, None] = pydantic.Field(None, description='The netmask length of the IPv4 CIDR you want to allocate to this VPC from an Amazon VPC IP Address Manager (IPAM) pool. For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the VPC.')
    _init_params: typing.ClassVar[list[str]] = ['cidr_block', 'enable_dns_hostnames', 'enable_dns_support', 'instance_tenancy', 'ipv4_ipam_pool_id', 'ipv4_netmask_length', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPC'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVPCDefConfig] = pydantic.Field(None)


class CfnVPCDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnVPCDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVPCDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVPCDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVPCDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVPCDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVPCDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVPCDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVPCDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVPCDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVPCDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVPCDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVPCDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVPCDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnVPCDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVPCDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPCDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVPCDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPCDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVPCDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVPCDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVPCDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVPCDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVPCDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPCDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVPCDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVPCDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPCDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnVPCCidrBlock
class CfnVPCCidrBlockDef(BaseCfnResource):
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC.\n')
    amazon_provided_ipv6_cidr_block: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IPv6 addresses, or the size of the CIDR block.\n')
    cidr_block: typing.Optional[str] = pydantic.Field(None, description='An IPv4 CIDR block to associate with the VPC.\n')
    ipv4_ipam_pool_id: typing.Optional[str] = pydantic.Field(None, description='Associate a CIDR allocated from an IPv4 IPAM pool to a VPC. For more information about Amazon VPC IP Address Manager (IPAM), see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .\n')
    ipv4_netmask_length: typing.Union[int, float, None] = pydantic.Field(None, description='The netmask length of the IPv4 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool. For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .\n')
    ipv6_cidr_block: typing.Optional[str] = pydantic.Field(None, description='An IPv6 CIDR block from the IPv6 address pool. You must also specify ``Ipv6Pool`` in the request. To let Amazon choose the IPv6 CIDR block for you, omit this parameter.\n')
    ipv6_ipam_pool_id: typing.Optional[str] = pydantic.Field(None, description='Associates a CIDR allocated from an IPv6 IPAM pool to a VPC. For more information about Amazon VPC IP Address Manager (IPAM), see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .\n')
    ipv6_netmask_length: typing.Union[int, float, None] = pydantic.Field(None, description='The netmask length of the IPv6 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool. For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .\n')
    ipv6_pool: typing.Optional[str] = pydantic.Field(None, description='The ID of an IPv6 address pool from which to allocate the IPv6 CIDR block.')
    _init_params: typing.ClassVar[list[str]] = ['vpc_id', 'amazon_provided_ipv6_cidr_block', 'cidr_block', 'ipv4_ipam_pool_id', 'ipv4_netmask_length', 'ipv6_cidr_block', 'ipv6_ipam_pool_id', 'ipv6_netmask_length', 'ipv6_pool']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPCCidrBlock'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVPCCidrBlockDefConfig] = pydantic.Field(None)


class CfnVPCCidrBlockDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnVPCCidrBlockDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVPCCidrBlockDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVPCCidrBlockDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVPCCidrBlockDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVPCCidrBlockDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVPCCidrBlockDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVPCCidrBlockDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVPCCidrBlockDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVPCCidrBlockDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVPCCidrBlockDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVPCCidrBlockDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVPCCidrBlockDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVPCCidrBlockDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnVPCCidrBlockDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVPCCidrBlockDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPCCidrBlockDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVPCCidrBlockDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPCCidrBlockDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVPCCidrBlockDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVPCCidrBlockDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVPCCidrBlockDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVPCCidrBlockDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVPCCidrBlockDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPCCidrBlockDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVPCCidrBlockDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVPCCidrBlockDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPCCidrBlockDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnVPCDHCPOptionsAssociation
class CfnVPCDHCPOptionsAssociationDef(BaseCfnResource):
    dhcp_options_id: str = pydantic.Field(..., description='The ID of the DHCP options set, or ``default`` to associate no DHCP options with the VPC.\n')
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC.')
    _init_params: typing.ClassVar[list[str]] = ['dhcp_options_id', 'vpc_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPCDHCPOptionsAssociation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVPCDHCPOptionsAssociationDefConfig] = pydantic.Field(None)


class CfnVPCDHCPOptionsAssociationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnVPCDHCPOptionsAssociationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVPCDHCPOptionsAssociationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVPCDHCPOptionsAssociationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVPCDHCPOptionsAssociationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVPCDHCPOptionsAssociationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVPCDHCPOptionsAssociationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVPCDHCPOptionsAssociationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVPCDHCPOptionsAssociationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVPCDHCPOptionsAssociationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVPCDHCPOptionsAssociationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVPCDHCPOptionsAssociationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVPCDHCPOptionsAssociationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVPCDHCPOptionsAssociationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnVPCDHCPOptionsAssociationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVPCDHCPOptionsAssociationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPCDHCPOptionsAssociationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVPCDHCPOptionsAssociationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPCDHCPOptionsAssociationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVPCDHCPOptionsAssociationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVPCDHCPOptionsAssociationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVPCDHCPOptionsAssociationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVPCDHCPOptionsAssociationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVPCDHCPOptionsAssociationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPCDHCPOptionsAssociationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVPCDHCPOptionsAssociationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVPCDHCPOptionsAssociationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPCDHCPOptionsAssociationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnVPCEndpoint
class CfnVPCEndpointDef(BaseCfnResource):
    service_name: str = pydantic.Field(..., description='The name of the endpoint service.\n')
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC.\n')
    policy_document: typing.Any = pydantic.Field(None, description='An endpoint policy, which controls access to the service from the VPC. The default endpoint policy allows full access to the service. Endpoint policies are supported only for gateway and interface endpoints. For CloudFormation templates in YAML, you can provide the policy in JSON or YAML format. AWS CloudFormation converts YAML policies to JSON format before calling the API to create or modify the VPC endpoint.\n')
    private_dns_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicate whether to associate a private hosted zone with the specified VPC. The private hosted zone contains a record set for the default public DNS name for the service for the Region (for example, ``kinesis.us-east-1.amazonaws.com`` ), which resolves to the private IP addresses of the endpoint network interfaces in the VPC. This enables you to make requests to the default public DNS name for the service instead of the public DNS names that are automatically generated by the VPC endpoint service. To use a private hosted zone, you must set the following VPC attributes to ``true`` : ``enableDnsHostnames`` and ``enableDnsSupport`` . This property is supported only for interface endpoints. Default: ``false``\n')
    route_table_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of the route tables. Routing is supported only for gateway endpoints.\n')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of the security groups to associate with the endpoint network interfaces. If this parameter is not specified, we use the default security group for the VPC. Security groups are supported only for interface endpoints.\n')
    subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The IDs of the subnets in which to create endpoint network interfaces. You must specify this property for an interface endpoint or a Gateway Load Balancer endpoint. You can't specify this property for a gateway endpoint. For a Gateway Load Balancer endpoint, you can specify only one subnet.\n")
    vpc_endpoint_type: typing.Optional[str] = pydantic.Field(None, description='The type of endpoint. Default: Gateway')
    _init_params: typing.ClassVar[list[str]] = ['service_name', 'vpc_id', 'policy_document', 'private_dns_enabled', 'route_table_ids', 'security_group_ids', 'subnet_ids', 'vpc_endpoint_type']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPCEndpoint'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVPCEndpointDefConfig] = pydantic.Field(None)


class CfnVPCEndpointDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnVPCEndpointDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVPCEndpointDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVPCEndpointDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVPCEndpointDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVPCEndpointDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVPCEndpointDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVPCEndpointDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVPCEndpointDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVPCEndpointDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVPCEndpointDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVPCEndpointDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVPCEndpointDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVPCEndpointDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnVPCEndpointDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVPCEndpointDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPCEndpointDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVPCEndpointDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPCEndpointDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVPCEndpointDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVPCEndpointDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVPCEndpointDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVPCEndpointDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVPCEndpointDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPCEndpointDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVPCEndpointDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVPCEndpointDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPCEndpointDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnVPCEndpointConnectionNotification
class CfnVPCEndpointConnectionNotificationDef(BaseCfnResource):
    connection_events: typing.Sequence[str] = pydantic.Field(..., description='The endpoint events for which to receive notifications. Valid values are ``Accept`` , ``Connect`` , ``Delete`` , and ``Reject`` .\n')
    connection_notification_arn: str = pydantic.Field(..., description='The ARN of the SNS topic for the notifications.\n')
    service_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the endpoint service.\n')
    vpc_endpoint_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the endpoint.')
    _init_params: typing.ClassVar[list[str]] = ['connection_events', 'connection_notification_arn', 'service_id', 'vpc_endpoint_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPCEndpointConnectionNotification'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVPCEndpointConnectionNotificationDefConfig] = pydantic.Field(None)


class CfnVPCEndpointConnectionNotificationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnVPCEndpointConnectionNotificationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVPCEndpointConnectionNotificationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVPCEndpointConnectionNotificationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVPCEndpointConnectionNotificationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVPCEndpointConnectionNotificationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVPCEndpointConnectionNotificationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVPCEndpointConnectionNotificationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVPCEndpointConnectionNotificationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVPCEndpointConnectionNotificationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVPCEndpointConnectionNotificationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVPCEndpointConnectionNotificationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVPCEndpointConnectionNotificationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVPCEndpointConnectionNotificationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnVPCEndpointConnectionNotificationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVPCEndpointConnectionNotificationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPCEndpointConnectionNotificationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVPCEndpointConnectionNotificationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPCEndpointConnectionNotificationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVPCEndpointConnectionNotificationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVPCEndpointConnectionNotificationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVPCEndpointConnectionNotificationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVPCEndpointConnectionNotificationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVPCEndpointConnectionNotificationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPCEndpointConnectionNotificationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVPCEndpointConnectionNotificationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVPCEndpointConnectionNotificationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPCEndpointConnectionNotificationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnVPCEndpointService
class CfnVPCEndpointServiceDef(BaseCfnResource):
    acceptance_required: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether requests from service consumers to create an endpoint to your service must be accepted.\n')
    contributor_insights_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to enable the built-in Contributor Insights rules provided by AWS PrivateLink .\n')
    gateway_load_balancer_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Amazon Resource Names (ARNs) of the Gateway Load Balancers.\n')
    network_load_balancer_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Amazon Resource Names (ARNs) of the Network Load Balancers.\n')
    payer_responsibility: typing.Optional[str] = pydantic.Field(None, description='The entity that is responsible for the endpoint costs. The default is the endpoint owner. If you set the payer responsibility to the service owner, you cannot set it back to the endpoint owner.')
    _init_params: typing.ClassVar[list[str]] = ['acceptance_required', 'contributor_insights_enabled', 'gateway_load_balancer_arns', 'network_load_balancer_arns', 'payer_responsibility']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPCEndpointService'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVPCEndpointServiceDefConfig] = pydantic.Field(None)


class CfnVPCEndpointServiceDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnVPCEndpointServiceDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVPCEndpointServiceDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVPCEndpointServiceDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVPCEndpointServiceDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVPCEndpointServiceDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVPCEndpointServiceDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVPCEndpointServiceDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVPCEndpointServiceDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVPCEndpointServiceDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVPCEndpointServiceDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVPCEndpointServiceDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVPCEndpointServiceDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVPCEndpointServiceDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnVPCEndpointServiceDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVPCEndpointServiceDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPCEndpointServiceDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVPCEndpointServiceDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPCEndpointServiceDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVPCEndpointServiceDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVPCEndpointServiceDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVPCEndpointServiceDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVPCEndpointServiceDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVPCEndpointServiceDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPCEndpointServiceDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVPCEndpointServiceDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVPCEndpointServiceDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPCEndpointServiceDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnVPCEndpointServicePermissions
class CfnVPCEndpointServicePermissionsDef(BaseCfnResource):
    service_id: str = pydantic.Field(..., description='The ID of the service.\n')
    allowed_principals: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Amazon Resource Names (ARN) of one or more principals (for example, users, IAM roles, and AWS accounts ). Permissions are granted to the principals in this list. To grant permissions to all principals, specify an asterisk (*). Permissions are revoked for principals not in this list. If the list is empty, then all permissions are revoked.')
    _init_params: typing.ClassVar[list[str]] = ['service_id', 'allowed_principals']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPCEndpointServicePermissions'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVPCEndpointServicePermissionsDefConfig] = pydantic.Field(None)


class CfnVPCEndpointServicePermissionsDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnVPCEndpointServicePermissionsDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVPCEndpointServicePermissionsDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVPCEndpointServicePermissionsDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVPCEndpointServicePermissionsDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVPCEndpointServicePermissionsDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVPCEndpointServicePermissionsDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVPCEndpointServicePermissionsDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVPCEndpointServicePermissionsDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVPCEndpointServicePermissionsDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVPCEndpointServicePermissionsDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVPCEndpointServicePermissionsDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVPCEndpointServicePermissionsDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVPCEndpointServicePermissionsDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnVPCEndpointServicePermissionsDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVPCEndpointServicePermissionsDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPCEndpointServicePermissionsDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVPCEndpointServicePermissionsDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPCEndpointServicePermissionsDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVPCEndpointServicePermissionsDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVPCEndpointServicePermissionsDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVPCEndpointServicePermissionsDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVPCEndpointServicePermissionsDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVPCEndpointServicePermissionsDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPCEndpointServicePermissionsDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVPCEndpointServicePermissionsDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVPCEndpointServicePermissionsDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPCEndpointServicePermissionsDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnVPCGatewayAttachment
class CfnVPCGatewayAttachmentDef(BaseCfnResource):
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC.\n')
    internet_gateway_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the internet gateway. You must specify either ``InternetGatewayId`` or ``VpnGatewayId`` , but not both.\n')
    vpn_gateway_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the virtual private gateway. You must specify either ``InternetGatewayId`` or ``VpnGatewayId`` , but not both.')
    _init_params: typing.ClassVar[list[str]] = ['vpc_id', 'internet_gateway_id', 'vpn_gateway_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPCGatewayAttachment'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVPCGatewayAttachmentDefConfig] = pydantic.Field(None)


class CfnVPCGatewayAttachmentDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnVPCGatewayAttachmentDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVPCGatewayAttachmentDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVPCGatewayAttachmentDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVPCGatewayAttachmentDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVPCGatewayAttachmentDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVPCGatewayAttachmentDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVPCGatewayAttachmentDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVPCGatewayAttachmentDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVPCGatewayAttachmentDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVPCGatewayAttachmentDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVPCGatewayAttachmentDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVPCGatewayAttachmentDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVPCGatewayAttachmentDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnVPCGatewayAttachmentDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVPCGatewayAttachmentDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPCGatewayAttachmentDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVPCGatewayAttachmentDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPCGatewayAttachmentDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVPCGatewayAttachmentDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVPCGatewayAttachmentDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVPCGatewayAttachmentDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVPCGatewayAttachmentDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVPCGatewayAttachmentDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPCGatewayAttachmentDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVPCGatewayAttachmentDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVPCGatewayAttachmentDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPCGatewayAttachmentDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnVPCPeeringConnection
class CfnVPCPeeringConnectionDef(BaseCfnResource):
    peer_vpc_id: str = pydantic.Field(..., description='The ID of the VPC with which you are creating the VPC peering connection. You must specify this parameter in the request.\n')
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC.\n')
    peer_owner_id: typing.Optional[str] = pydantic.Field(None, description='The AWS account ID of the owner of the accepter VPC. Default: Your AWS account ID\n')
    peer_region: typing.Optional[str] = pydantic.Field(None, description='The Region code for the accepter VPC, if the accepter VPC is located in a Region other than the Region in which you make the request. Default: The Region in which you make the request.\n')
    peer_role_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the VPC peer role for the peering connection in another AWS account. This is required when you are peering a VPC in a different AWS account.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Any tags assigned to the resource.')
    _init_params: typing.ClassVar[list[str]] = ['peer_vpc_id', 'vpc_id', 'peer_owner_id', 'peer_region', 'peer_role_arn', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPCPeeringConnection'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVPCPeeringConnectionDefConfig] = pydantic.Field(None)


class CfnVPCPeeringConnectionDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnVPCPeeringConnectionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVPCPeeringConnectionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVPCPeeringConnectionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVPCPeeringConnectionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVPCPeeringConnectionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVPCPeeringConnectionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVPCPeeringConnectionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVPCPeeringConnectionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVPCPeeringConnectionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVPCPeeringConnectionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVPCPeeringConnectionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVPCPeeringConnectionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVPCPeeringConnectionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnVPCPeeringConnectionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVPCPeeringConnectionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPCPeeringConnectionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVPCPeeringConnectionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPCPeeringConnectionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVPCPeeringConnectionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVPCPeeringConnectionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVPCPeeringConnectionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVPCPeeringConnectionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVPCPeeringConnectionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPCPeeringConnectionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVPCPeeringConnectionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVPCPeeringConnectionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPCPeeringConnectionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnVPNConnection
class CfnVPNConnectionDef(BaseCfnResource):
    customer_gateway_id: str = pydantic.Field(..., description='The ID of the customer gateway at your end of the VPN connection.\n')
    type: str = pydantic.Field(..., description='The type of VPN connection.\n')
    static_routes_only: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP. If you are creating a VPN connection for a device that does not support Border Gateway Protocol (BGP), you must specify ``true`` .\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Any tags assigned to the VPN connection.\n')
    transit_gateway_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the transit gateway associated with the VPN connection. You must specify either ``TransitGatewayId`` or ``VpnGatewayId`` , but not both.\n')
    vpn_gateway_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the virtual private gateway at the AWS side of the VPN connection. You must specify either ``TransitGatewayId`` or ``VpnGatewayId`` , but not both.\n')
    vpn_tunnel_options_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnVPNConnection_VpnTunnelOptionsSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The tunnel options for the VPN connection.')
    _init_params: typing.ClassVar[list[str]] = ['customer_gateway_id', 'type', 'static_routes_only', 'tags', 'transit_gateway_id', 'vpn_gateway_id', 'vpn_tunnel_options_specifications']
    _method_names: typing.ClassVar[list[str]] = ['VpnTunnelOptionsSpecificationProperty', 'add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPNConnection'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVPNConnectionDefConfig] = pydantic.Field(None)


class CfnVPNConnectionDefConfig(pydantic.BaseModel):
    VpnTunnelOptionsSpecificationProperty: typing.Optional[list[CfnVPNConnectionDefVpntunneloptionsspecificationpropertyParams]] = pydantic.Field(None, description='')
    add_deletion_override: typing.Optional[list[CfnVPNConnectionDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVPNConnectionDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVPNConnectionDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVPNConnectionDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVPNConnectionDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVPNConnectionDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVPNConnectionDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVPNConnectionDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVPNConnectionDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVPNConnectionDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVPNConnectionDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVPNConnectionDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVPNConnectionDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnVPNConnectionDefVpntunneloptionsspecificationpropertyParams(pydantic.BaseModel):
    pre_shared_key: typing.Optional[str] = pydantic.Field(None, description='')
    tunnel_inside_cidr: typing.Optional[str] = pydantic.Field(None, description='')
    ...

class CfnVPNConnectionDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVPNConnectionDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPNConnectionDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVPNConnectionDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPNConnectionDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVPNConnectionDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVPNConnectionDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVPNConnectionDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVPNConnectionDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVPNConnectionDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPNConnectionDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVPNConnectionDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVPNConnectionDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPNConnectionDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnVPNConnectionRoute
class CfnVPNConnectionRouteDef(BaseCfnResource):
    destination_cidr_block: str = pydantic.Field(..., description='The CIDR block associated with the local subnet of the customer network.\n')
    vpn_connection_id: str = pydantic.Field(..., description='The ID of the VPN connection.')
    _init_params: typing.ClassVar[list[str]] = ['destination_cidr_block', 'vpn_connection_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPNConnectionRoute'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVPNConnectionRouteDefConfig] = pydantic.Field(None)


class CfnVPNConnectionRouteDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnVPNConnectionRouteDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVPNConnectionRouteDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVPNConnectionRouteDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVPNConnectionRouteDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVPNConnectionRouteDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVPNConnectionRouteDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVPNConnectionRouteDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVPNConnectionRouteDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVPNConnectionRouteDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVPNConnectionRouteDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVPNConnectionRouteDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVPNConnectionRouteDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVPNConnectionRouteDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnVPNConnectionRouteDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVPNConnectionRouteDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPNConnectionRouteDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVPNConnectionRouteDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPNConnectionRouteDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVPNConnectionRouteDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVPNConnectionRouteDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVPNConnectionRouteDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVPNConnectionRouteDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVPNConnectionRouteDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPNConnectionRouteDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVPNConnectionRouteDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVPNConnectionRouteDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPNConnectionRouteDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnVPNGateway
class CfnVPNGatewayDef(BaseCfnResource):
    type: str = pydantic.Field(..., description='The type of VPN connection the virtual private gateway supports.\n')
    amazon_side_asn: typing.Union[int, float, None] = pydantic.Field(None, description='The private Autonomous System Number (ASN) for the Amazon side of a BGP session.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Any tags assigned to the virtual private gateway.')
    _init_params: typing.ClassVar[list[str]] = ['type', 'amazon_side_asn', 'tags']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPNGateway'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVPNGatewayDefConfig] = pydantic.Field(None)


class CfnVPNGatewayDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnVPNGatewayDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVPNGatewayDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVPNGatewayDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVPNGatewayDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVPNGatewayDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVPNGatewayDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVPNGatewayDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVPNGatewayDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVPNGatewayDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVPNGatewayDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVPNGatewayDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVPNGatewayDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVPNGatewayDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')
    tags_config: typing.Optional[models.core.TagManagerDefConfig] = pydantic.Field(None)

class CfnVPNGatewayDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVPNGatewayDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPNGatewayDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVPNGatewayDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPNGatewayDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVPNGatewayDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVPNGatewayDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVPNGatewayDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVPNGatewayDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVPNGatewayDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPNGatewayDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVPNGatewayDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVPNGatewayDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPNGatewayDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnVPNGatewayRoutePropagation
class CfnVPNGatewayRoutePropagationDef(BaseCfnResource):
    route_table_ids: typing.Sequence[str] = pydantic.Field(..., description='The ID of the route table. The routing table must be associated with the same VPC that the virtual private gateway is attached to.\n')
    vpn_gateway_id: str = pydantic.Field(..., description='The ID of the virtual private gateway that is attached to a VPC. The virtual private gateway must be attached to the same VPC that the routing tables are associated with.')
    _init_params: typing.ClassVar[list[str]] = ['route_table_ids', 'vpn_gateway_id']
    _method_names: typing.ClassVar[list[str]] = ['add_deletion_override', 'add_dependency', 'add_depends_on', 'add_metadata', 'add_override', 'add_property_deletion_override', 'add_property_override', 'apply_removal_policy', 'get_att', 'get_metadata', 'inspect', 'obtain_dependencies', 'obtain_resource_dependencies', 'override_logical_id', 'remove_dependency', 'replace_dependency']
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPNGatewayRoutePropagation'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...


    resource_config: typing.Optional[CfnVPNGatewayRoutePropagationDefConfig] = pydantic.Field(None)


class CfnVPNGatewayRoutePropagationDefConfig(pydantic.BaseModel):
    add_deletion_override: typing.Optional[list[CfnVPNGatewayRoutePropagationDefAddDeletionOverrideParams]] = pydantic.Field(None, description='Syntactic sugar for ``addOverride(path, undefined)``.')
    add_dependency: typing.Optional[list[CfnVPNGatewayRoutePropagationDefAddDependencyParams]] = pydantic.Field(None, description='Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.\nThis can be used for resources across stacks (or nested stack) boundaries\nand the dependency will automatically be transferred to the relevant scope.')
    add_depends_on: typing.Optional[list[CfnVPNGatewayRoutePropagationDefAddDependsOnParams]] = pydantic.Field(None, description='(deprecated) Indicates that this resource depends on another resource and cannot be provisioned unless the other resource has been successfully provisioned.')
    add_metadata: typing.Optional[list[CfnVPNGatewayRoutePropagationDefAddMetadataParams]] = pydantic.Field(None, description='Add a value to the CloudFormation Resource Metadata.')
    add_override: typing.Optional[list[CfnVPNGatewayRoutePropagationDefAddOverrideParams]] = pydantic.Field(None, description='Adds an override to the synthesized CloudFormation resource.\nTo add a\nproperty override, either use ``addPropertyOverride`` or prefix ``path`` with\n"Properties." (i.e. ``Properties.TopicName``).\n\nIf the override is nested, separate each nested level using a dot (.) in the path parameter.\nIf there is an array as part of the nesting, specify the index in the path.\n\nTo include a literal ``.`` in the property name, prefix with a ``\\``. In most\nprogramming languages you will need to write this as ``"\\\\."`` because the\n``\\`` itself will need to be escaped.\n\nFor example::\n\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes", ["myattribute"])\n   cfn_resource.add_override("Properties.GlobalSecondaryIndexes.1.ProjectionType", "INCLUDE")\n\nwould add the overrides Example::\n\n   "Properties": {\n     "GlobalSecondaryIndexes": [\n       {\n         "Projection": {\n           "NonKeyAttributes": [ "myattribute" ]\n           ...\n         }\n         ...\n       },\n       {\n         "ProjectionType": "INCLUDE"\n         ...\n       },\n     ]\n     ...\n   }\n\nThe ``value`` argument to ``addOverride`` will not be processed or translated\nin any way. Pass raw JSON values in here with the correct capitalization\nfor CloudFormation. If you pass CDK classes or structs, they will be\nrendered with lowercased key names, and CloudFormation will reject the\ntemplate.')
    add_property_deletion_override: typing.Optional[list[CfnVPNGatewayRoutePropagationDefAddPropertyDeletionOverrideParams]] = pydantic.Field(None, description='Adds an override that deletes the value of a property from the resource definition.')
    add_property_override: typing.Optional[list[CfnVPNGatewayRoutePropagationDefAddPropertyOverrideParams]] = pydantic.Field(None, description='Adds an override to a resource property.\nSyntactic sugar for ``addOverride("Properties.<...>", value)``.')
    apply_removal_policy: typing.Optional[list[models.GenericApplyRemovalPolicyParams]] = pydantic.Field(None)
    get_att: typing.Optional[list[CfnVPNGatewayRoutePropagationDefGetAttParams]] = pydantic.Field(None, description='Returns a token for an runtime attribute of this resource.\nIdeally, use generated attribute accessors (e.g. ``resource.arn``), but this can be used for future compatibility\nin case there is no generated attribute.')
    get_metadata: typing.Optional[list[CfnVPNGatewayRoutePropagationDefGetMetadataParams]] = pydantic.Field(None, description='Retrieve a value value from the CloudFormation Resource Metadata.')
    inspect: typing.Optional[list[CfnVPNGatewayRoutePropagationDefInspectParams]] = pydantic.Field(None, description='Examines the CloudFormation resource and discloses attributes.')
    obtain_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Retrieves an array of resources this resource depends on.\nThis assembles dependencies on resources across stacks (including nested stacks)\nautomatically.')
    obtain_resource_dependencies: typing.Optional[bool] = pydantic.Field(None, description='Get a shallow copy of dependencies between this resource and other resources in the same stack.')
    override_logical_id: typing.Optional[list[CfnVPNGatewayRoutePropagationDefOverrideLogicalIdParams]] = pydantic.Field(None, description='Overrides the auto-generated logical ID with a specific ID.')
    remove_dependency: typing.Optional[list[CfnVPNGatewayRoutePropagationDefRemoveDependencyParams]] = pydantic.Field(None, description='Indicates that this resource no longer depends on another resource.\nThis can be used for resources across stacks (including nested stacks)\nand the dependency will automatically be removed from the relevant scope.')
    replace_dependency: typing.Optional[list[CfnVPNGatewayRoutePropagationDefReplaceDependencyParams]] = pydantic.Field(None, description='Replaces one dependency with another.')

class CfnVPNGatewayRoutePropagationDefAddDeletionOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='The path of the value to delete.')
    ...

class CfnVPNGatewayRoutePropagationDefAddDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPNGatewayRoutePropagationDefAddDependsOnParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-\n\n:deprecated: use addDependency\n\n:stability: deprecated\n')
    ...

class CfnVPNGatewayRoutePropagationDefAddMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n')
    value: typing.Any = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPNGatewayRoutePropagationDefAddOverrideParams(pydantic.BaseModel):
    path: str = pydantic.Field(..., description='- The path of the property, you can use dot notation to override values in complex types. Any intermediate keys will be created as needed.\n')
    value: typing.Any = pydantic.Field(..., description='- The value. Could be primitive or complex.')
    ...

class CfnVPNGatewayRoutePropagationDefAddPropertyDeletionOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path to the property.')
    ...

class CfnVPNGatewayRoutePropagationDefAddPropertyOverrideParams(pydantic.BaseModel):
    property_path: str = pydantic.Field(..., description='The path of the property.\n')
    value: typing.Any = pydantic.Field(..., description='The value.')
    ...

class CfnVPNGatewayRoutePropagationDefApplyRemovalPolicyParams(pydantic.BaseModel):
    policy: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description='-\n')
    apply_to_update_replace_policy: typing.Optional[bool] = pydantic.Field(None, description='Apply the same deletion policy to the resource\'s "UpdateReplacePolicy". Default: true\n')
    default: typing.Optional[aws_cdk.RemovalPolicy] = pydantic.Field(None, description="The default policy to apply in case the removal policy is not defined. Default: - Default value is resource specific. To determine the default value for a resource, please consult that specific resource's documentation.\n\n:see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html#aws-attribute-deletionpolicy-options\n")
    ...

class CfnVPNGatewayRoutePropagationDefGetAttParams(pydantic.BaseModel):
    attribute_name: str = pydantic.Field(..., description='The name of the attribute.\n')
    type_hint: typing.Optional[aws_cdk.ResolutionTypeHint] = pydantic.Field(None, description='-')
    return_config: typing.Optional[list[models.core.ReferenceDefConfig]] = pydantic.Field(None)
    ...

class CfnVPNGatewayRoutePropagationDefGetMetadataParams(pydantic.BaseModel):
    key: str = pydantic.Field(..., description='-\n\n:see:\n\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n\nNote that this is a different set of metadata from CDK node metadata; this\nmetadata ends up in the stack template under the resource, whereas CDK\nnode metadata ends up in the Cloud Assembly.\n')
    ...

class CfnVPNGatewayRoutePropagationDefInspectParams(pydantic.BaseModel):
    inspector: models.TreeInspectorDef = pydantic.Field(..., description='- tree inspector to collect and process attributes.')
    ...

class CfnVPNGatewayRoutePropagationDefOverrideLogicalIdParams(pydantic.BaseModel):
    new_logical_id: str = pydantic.Field(..., description='The new logical ID to use for this stack element.')
    ...

class CfnVPNGatewayRoutePropagationDefRemoveDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='-')
    ...

class CfnVPNGatewayRoutePropagationDefReplaceDependencyParams(pydantic.BaseModel):
    target: models.CfnResourceDef = pydantic.Field(..., description='The dependency to replace.\n')
    new_target: models.CfnResourceDef = pydantic.Field(..., description='The new dependency to add.')
    ...


#  autogenerated from aws_cdk.aws_ec2.CfnCapacityReservationFleetProps
class CfnCapacityReservationFleetPropsDef(BaseCfnProperty):
    allocation_strategy: typing.Optional[str] = pydantic.Field(None, description='The strategy used by the Capacity Reservation Fleet to determine which of the specified instance types to use. Currently, only the ``prioritized`` allocation strategy is supported. For more information, see `Allocation strategy <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#allocation-strategy>`_ in the Amazon EC2 User Guide. Valid values: ``prioritized``\n')
    end_date: typing.Optional[str] = pydantic.Field(None, description='The date and time at which the Capacity Reservation Fleet expires. When the Capacity Reservation Fleet expires, its state changes to ``expired`` and all of the Capacity Reservations in the Fleet expire. The Capacity Reservation Fleet expires within an hour after the specified time. For example, if you specify ``5/31/2019`` , ``13:30:55`` , the Capacity Reservation Fleet is guaranteed to expire between ``13:30:55`` and ``14:30:55`` on ``5/31/2019`` .\n')
    instance_match_criteria: typing.Optional[str] = pydantic.Field(None, description='Indicates the type of instance launches that the Capacity Reservation Fleet accepts. All Capacity Reservations in the Fleet inherit this instance matching criteria. Currently, Capacity Reservation Fleets support ``open`` instance matching criteria only. This means that instances that have matching attributes (instance type, platform, and Availability Zone) run in the Capacity Reservations automatically. Instances do not need to explicitly target a Capacity Reservation Fleet to use its reserved capacity.\n')
    instance_type_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnCapacityReservationFleet_InstanceTypeSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Information about the instance types for which to reserve the capacity.\n')
    no_remove_end_date: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Used to add an end date to a Capacity Reservation Fleet that has no end date and time. To add an end date to a Capacity Reservation Fleet, specify ``true`` for this paramater and specify the end date and time (in UTC time format) for the *EndDate* parameter.\n')
    remove_end_date: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Used to remove an end date from a Capacity Reservation Fleet that is configured to end automatically at a specific date and time. To remove the end date from a Capacity Reservation Fleet, specify ``true`` for this paramater and omit the *EndDate* parameter.\n')
    tag_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnCapacityReservationFleet_TagSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The tags to assign to the Capacity Reservation Fleet. The tags are automatically assigned to the Capacity Reservations in the Fleet.\n')
    tenancy: typing.Optional[str] = pydantic.Field(None, description='Indicates the tenancy of the Capacity Reservation Fleet. All Capacity Reservations in the Fleet inherit this tenancy. The Capacity Reservation Fleet can have one of the following tenancy settings: - ``default`` - The Capacity Reservation Fleet is created on hardware that is shared with other AWS accounts . - ``dedicated`` - The Capacity Reservations are created on single-tenant hardware that is dedicated to a single AWS account .\n')
    total_target_capacity: typing.Union[int, float, None] = pydantic.Field(None, description='The total number of capacity units to be reserved by the Capacity Reservation Fleet. This value, together with the instance type weights that you assign to each instance type used by the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see `Total target capacity <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity>`_ in the Amazon EC2 User Guide.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_capacity_reservation_fleet_props = ec2.CfnCapacityReservationFleetProps(\n        allocation_strategy="allocationStrategy",\n        end_date="endDate",\n        instance_match_criteria="instanceMatchCriteria",\n        instance_type_specifications=[ec2.CfnCapacityReservationFleet.InstanceTypeSpecificationProperty(\n            availability_zone="availabilityZone",\n            availability_zone_id="availabilityZoneId",\n            ebs_optimized=False,\n            instance_platform="instancePlatform",\n            instance_type="instanceType",\n            priority=123,\n            weight=123\n        )],\n        no_remove_end_date=False,\n        remove_end_date=False,\n        tag_specifications=[ec2.CfnCapacityReservationFleet.TagSpecificationProperty(\n            resource_type="resourceType",\n            tags=[CfnTag(\n                key="key",\n                value="value"\n            )]\n        )],\n        tenancy="tenancy",\n        total_target_capacity=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allocation_strategy', 'end_date', 'instance_match_criteria', 'instance_type_specifications', 'no_remove_end_date', 'remove_end_date', 'tag_specifications', 'tenancy', 'total_target_capacity']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnCapacityReservationFleetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnCapacityReservationProps
class CfnCapacityReservationPropsDef(BaseCfnProperty):
    availability_zone: str = pydantic.Field(..., description='The Availability Zone in which to create the Capacity Reservation.\n')
    instance_count: typing.Union[int, float] = pydantic.Field(..., description='The number of instances for which to reserve capacity. Valid range: 1 - 1000\n')
    instance_platform: str = pydantic.Field(..., description='The type of operating system for which to reserve capacity.\n')
    instance_type: str = pydantic.Field(..., description='The instance type for which to reserve capacity. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* .\n')
    ebs_optimized: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Indicates whether the Capacity Reservation supports EBS-optimized instances. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS- optimized instance.\n")
    end_date: typing.Optional[str] = pydantic.Field(None, description="The date and time at which the Capacity Reservation expires. When a Capacity Reservation expires, the reserved capacity is released and you can no longer launch instances into it. The Capacity Reservation's state changes to ``expired`` when it reaches its end date and time. You must provide an ``EndDate`` value if ``EndDateType`` is ``limited`` . Omit ``EndDate`` if ``EndDateType`` is ``unlimited`` . If the ``EndDateType`` is ``limited`` , the Capacity Reservation is cancelled within an hour from the specified time. For example, if you specify 5/31/2019, 13:30:55, the Capacity Reservation is guaranteed to end between 13:30:55 and 14:30:55 on 5/31/2019.\n")
    end_date_type: typing.Optional[str] = pydantic.Field(None, description='Indicates the way in which the Capacity Reservation ends. A Capacity Reservation can have one of the following end types: - ``unlimited`` - The Capacity Reservation remains active until you explicitly cancel it. Do not provide an ``EndDate`` if the ``EndDateType`` is ``unlimited`` . - ``limited`` - The Capacity Reservation expires automatically at a specified date and time. You must provide an ``EndDate`` value if the ``EndDateType`` value is ``limited`` .\n')
    ephemeral_storage: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='*Deprecated.*.\n')
    instance_match_criteria: typing.Optional[str] = pydantic.Field(None, description='Indicates the type of instance launches that the Capacity Reservation accepts. The options include:. - ``open`` - The Capacity Reservation automatically matches all instances that have matching attributes (instance type, platform, and Availability Zone). Instances that have matching attributes run in the Capacity Reservation automatically without specifying any additional parameters. - ``targeted`` - The Capacity Reservation only accepts instances that have matching attributes (instance type, platform, and Availability Zone), and explicitly target the Capacity Reservation. This ensures that only permitted instances can use the reserved capacity. Default: ``open``\n')
    out_post_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the Outpost on which to create the Capacity Reservation.\n')
    placement_group_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the cluster placement group in which to create the Capacity Reservation. For more information, see `Capacity Reservations for cluster placement groups <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cr-cpg.html>`_ in the *Amazon EC2 User Guide* .\n')
    tag_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnCapacityReservation_TagSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The tags to apply to the Capacity Reservation during launch.\n')
    tenancy: typing.Optional[str] = pydantic.Field(None, description='Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the following tenancy settings:. - ``default`` - The Capacity Reservation is created on hardware that is shared with other AWS accounts . - ``dedicated`` - The Capacity Reservation is created on single-tenant hardware that is dedicated to a single AWS account .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_capacity_reservation_props = ec2.CfnCapacityReservationProps(\n        availability_zone="availabilityZone",\n        instance_count=123,\n        instance_platform="instancePlatform",\n        instance_type="instanceType",\n\n        # the properties below are optional\n        ebs_optimized=False,\n        end_date="endDate",\n        end_date_type="endDateType",\n        ephemeral_storage=False,\n        instance_match_criteria="instanceMatchCriteria",\n        out_post_arn="outPostArn",\n        placement_group_arn="placementGroupArn",\n        tag_specifications=[ec2.CfnCapacityReservation.TagSpecificationProperty(\n            resource_type="resourceType",\n            tags=[CfnTag(\n                key="key",\n                value="value"\n            )]\n        )],\n        tenancy="tenancy"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'instance_count', 'instance_platform', 'instance_type', 'ebs_optimized', 'end_date', 'end_date_type', 'ephemeral_storage', 'instance_match_criteria', 'out_post_arn', 'placement_group_arn', 'tag_specifications', 'tenancy']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnCapacityReservationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnCarrierGatewayProps
class CfnCarrierGatewayPropsDef(BaseCfnProperty):
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC associated with the carrier gateway.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags assigned to the carrier gateway.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_carrier_gateway_props = ec2.CfnCarrierGatewayProps(\n        vpc_id="vpcId",\n\n        # the properties below are optional\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['vpc_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnCarrierGatewayProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnClientVpnAuthorizationRuleProps
class CfnClientVpnAuthorizationRulePropsDef(BaseCfnProperty):
    client_vpn_endpoint_id: str = pydantic.Field(..., description='The ID of the Client VPN endpoint.\n')
    target_network_cidr: str = pydantic.Field(..., description='The IPv4 address range, in CIDR notation, of the network for which access is being authorized.\n')
    access_group_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group. Required if ``AuthorizeAllGroups`` is ``false`` or not specified.\n')
    authorize_all_groups: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to grant access to all clients. Specify ``true`` to grant all clients who successfully establish a VPN connection access to the network. Must be set to ``true`` if ``AccessGroupId`` is not specified.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A brief description of the authorization rule.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_client_vpn_authorization_rule_props = ec2.CfnClientVpnAuthorizationRuleProps(\n        client_vpn_endpoint_id="clientVpnEndpointId",\n        target_network_cidr="targetNetworkCidr",\n\n        # the properties below are optional\n        access_group_id="accessGroupId",\n        authorize_all_groups=False,\n        description="description"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['client_vpn_endpoint_id', 'target_network_cidr', 'access_group_id', 'authorize_all_groups', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnClientVpnAuthorizationRuleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnClientVpnEndpointProps
class CfnClientVpnEndpointPropsDef(BaseCfnProperty):
    authentication_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnClientVpnEndpoint_ClientAuthenticationRequestPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='Information about the authentication method to be used to authenticate clients.\n')
    client_cidr_block: str = pydantic.Field(..., description='The IPv4 address range, in CIDR notation, from which to assign client IP addresses. The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. The address range cannot be changed after the Client VPN endpoint has been created. Client CIDR range must have a size of at least /22 and must not be greater than /12.\n')
    connection_log_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnClientVpnEndpoint_ConnectionLogOptionsPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Information about the client connection logging options. If you enable client connection logging, data about client connections is sent to a Cloudwatch Logs log stream. The following information is logged: - Client connection requests - Client connection results (successful and unsuccessful) - Reasons for unsuccessful client connection requests - Client connection termination time\n')
    server_certificate_arn: str = pydantic.Field(..., description='The ARN of the server certificate. For more information, see the `AWS Certificate Manager User Guide <https://docs.aws.amazon.com/acm/latest/userguide/>`_ .\n')
    client_connect_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnClientVpnEndpoint_ClientConnectOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for managing connection authorization for new client connections.\n')
    client_login_banner_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnClientVpnEndpoint_ClientLoginBannerOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A brief description of the Client VPN endpoint.\n')
    dns_servers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Information about the DNS servers to be used for DNS resolution. A Client VPN endpoint can have up to two DNS servers. If no DNS server is specified, the DNS address configured on the device is used for the DNS server.\n')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of one or more security groups to apply to the target network. You must also specify the ID of the VPC that contains the security groups.\n')
    self_service_portal: typing.Optional[str] = pydantic.Field(None, description='Specify whether to enable the self-service portal for the Client VPN endpoint. Default Value: ``enabled``\n')
    session_timeout_hours: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum VPN session duration time in hours. Valid values: ``8 | 10 | 12 | 24`` Default value: ``24``\n')
    split_tunnel: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint. By default, split-tunnel on a VPN endpoint is disabled. For information about split-tunnel VPN endpoints, see `Split-tunnel AWS Client VPN endpoint <https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html>`_ in the *AWS Client VPN Administrator Guide* .\n')
    tag_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnClientVpnEndpoint_TagSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The tags to apply to the Client VPN endpoint during creation.\n')
    transport_protocol: typing.Optional[str] = pydantic.Field(None, description='The transport protocol to be used by the VPN session. Default value: ``udp``\n')
    vpc_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the VPC to associate with the Client VPN endpoint. If no security group IDs are specified in the request, the default security group for the VPC is applied.\n')
    vpn_port: typing.Union[int, float, None] = pydantic.Field(None, description='The port number to assign to the Client VPN endpoint for TCP and UDP traffic. Valid Values: ``443`` | ``1194`` Default Value: ``443``\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_client_vpn_endpoint_props = ec2.CfnClientVpnEndpointProps(\n        authentication_options=[ec2.CfnClientVpnEndpoint.ClientAuthenticationRequestProperty(\n            type="type",\n\n            # the properties below are optional\n            active_directory=ec2.CfnClientVpnEndpoint.DirectoryServiceAuthenticationRequestProperty(\n                directory_id="directoryId"\n            ),\n            federated_authentication=ec2.CfnClientVpnEndpoint.FederatedAuthenticationRequestProperty(\n                saml_provider_arn="samlProviderArn",\n\n                # the properties below are optional\n                self_service_saml_provider_arn="selfServiceSamlProviderArn"\n            ),\n            mutual_authentication=ec2.CfnClientVpnEndpoint.CertificateAuthenticationRequestProperty(\n                client_root_certificate_chain_arn="clientRootCertificateChainArn"\n            )\n        )],\n        client_cidr_block="clientCidrBlock",\n        connection_log_options=ec2.CfnClientVpnEndpoint.ConnectionLogOptionsProperty(\n            enabled=False,\n\n            # the properties below are optional\n            cloudwatch_log_group="cloudwatchLogGroup",\n            cloudwatch_log_stream="cloudwatchLogStream"\n        ),\n        server_certificate_arn="serverCertificateArn",\n\n        # the properties below are optional\n        client_connect_options=ec2.CfnClientVpnEndpoint.ClientConnectOptionsProperty(\n            enabled=False,\n\n            # the properties below are optional\n            lambda_function_arn="lambdaFunctionArn"\n        ),\n        client_login_banner_options=ec2.CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty(\n            enabled=False,\n\n            # the properties below are optional\n            banner_text="bannerText"\n        ),\n        description="description",\n        dns_servers=["dnsServers"],\n        security_group_ids=["securityGroupIds"],\n        self_service_portal="selfServicePortal",\n        session_timeout_hours=123,\n        split_tunnel=False,\n        tag_specifications=[ec2.CfnClientVpnEndpoint.TagSpecificationProperty(\n            resource_type="resourceType",\n            tags=[CfnTag(\n                key="key",\n                value="value"\n            )]\n        )],\n        transport_protocol="transportProtocol",\n        vpc_id="vpcId",\n        vpn_port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['authentication_options', 'client_cidr_block', 'connection_log_options', 'server_certificate_arn', 'client_connect_options', 'client_login_banner_options', 'description', 'dns_servers', 'security_group_ids', 'self_service_portal', 'session_timeout_hours', 'split_tunnel', 'tag_specifications', 'transport_protocol', 'vpc_id', 'vpn_port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnClientVpnEndpointProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnClientVpnRouteProps
class CfnClientVpnRoutePropsDef(BaseCfnProperty):
    client_vpn_endpoint_id: str = pydantic.Field(..., description='The ID of the Client VPN endpoint to which to add the route.\n')
    destination_cidr_block: str = pydantic.Field(..., description="The IPv4 address range, in CIDR notation, of the route destination. For example:. - To add a route for Internet access, enter ``0.0.0.0/0`` - To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range - To add a route for an on-premises network, enter the AWS Site-to-Site VPN connection's IPv4 CIDR range - To add a route for the local network, enter the client CIDR range\n")
    target_vpc_subnet_id: str = pydantic.Field(..., description="The ID of the subnet through which you want to route traffic. The specified subnet must be an existing target network of the Client VPN endpoint. Alternatively, if you're adding a route for the local network, specify ``local`` .\n")
    description: typing.Optional[str] = pydantic.Field(None, description='A brief description of the route.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_client_vpn_route_props = ec2.CfnClientVpnRouteProps(\n        client_vpn_endpoint_id="clientVpnEndpointId",\n        destination_cidr_block="destinationCidrBlock",\n        target_vpc_subnet_id="targetVpcSubnetId",\n\n        # the properties below are optional\n        description="description"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['client_vpn_endpoint_id', 'destination_cidr_block', 'target_vpc_subnet_id', 'description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnClientVpnRouteProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnClientVpnTargetNetworkAssociationProps
class CfnClientVpnTargetNetworkAssociationPropsDef(BaseCfnProperty):
    client_vpn_endpoint_id: str = pydantic.Field(..., description='The ID of the Client VPN endpoint.\n')
    subnet_id: str = pydantic.Field(..., description='The ID of the subnet to associate with the Client VPN endpoint.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_client_vpn_target_network_association_props = ec2.CfnClientVpnTargetNetworkAssociationProps(\n        client_vpn_endpoint_id="clientVpnEndpointId",\n        subnet_id="subnetId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['client_vpn_endpoint_id', 'subnet_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnClientVpnTargetNetworkAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnCustomerGatewayProps
class CfnCustomerGatewayPropsDef(BaseCfnProperty):
    bgp_asn: typing.Union[int, float] = pydantic.Field(..., description="For devices that support BGP, the customer gateway's BGP ASN. Default: 65000\n")
    ip_address: str = pydantic.Field(..., description="IPv4 address for the customer gateway device's outside interface. The address must be static.\n")
    type: str = pydantic.Field(..., description='The type of VPN connection that this customer gateway supports ( ``ipsec.1`` ).\n')
    device_name: typing.Optional[str] = pydantic.Field(None, description='The name of customer gateway device.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='One or more tags for the customer gateway.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_customer_gateway_props = ec2.CfnCustomerGatewayProps(\n        bgp_asn=123,\n        ip_address="ipAddress",\n        type="type",\n\n        # the properties below are optional\n        device_name="deviceName",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['bgp_asn', 'ip_address', 'type', 'device_name', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnCustomerGatewayProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnDHCPOptionsProps
class CfnDHCPOptionsPropsDef(BaseCfnProperty):
    domain_name: typing.Optional[str] = pydantic.Field(None, description="This value is used to complete unqualified DNS hostnames. If you're using AmazonProvidedDNS in ``us-east-1`` , specify ``ec2.internal`` . If you're using AmazonProvidedDNS in another Region, specify *region* . ``compute.internal`` (for example, ``ap-northeast-1.compute.internal`` ). Otherwise, specify a domain name (for example, *MyCompany.com* ).\n")
    domain_name_servers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IPv4 addresses of up to four domain name servers, or ``AmazonProvidedDNS`` . The default is ``AmazonProvidedDNS`` . To have your instance receive a custom DNS hostname as specified in ``DomainName`` , you must set this property to a custom DNS server.\n')
    netbios_name_servers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IPv4 addresses of up to four NetBIOS name servers.\n')
    netbios_node_type: typing.Union[int, float, None] = pydantic.Field(None, description='The NetBIOS node type (1, 2, 4, or 8). We recommend that you specify 2 (broadcast and multicast are not currently supported).\n')
    ntp_servers: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IPv4 addresses of up to four Network Time Protocol (NTP) servers.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Any tags assigned to the DHCP options set.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_dHCPOptions_props = ec2.CfnDHCPOptionsProps(\n        domain_name="domainName",\n        domain_name_servers=["domainNameServers"],\n        netbios_name_servers=["netbiosNameServers"],\n        netbios_node_type=123,\n        ntp_servers=["ntpServers"],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['domain_name', 'domain_name_servers', 'netbios_name_servers', 'netbios_node_type', 'ntp_servers', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnDHCPOptionsProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEC2FleetProps
class CfnEC2FleetPropsDef(BaseCfnProperty):
    launch_template_configs: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_FleetLaunchTemplateConfigRequestPropertyDef, dict[str, typing.Any]]]] = pydantic.Field(..., description='The configuration for the EC2 Fleet.\n')
    target_capacity_specification: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_TargetCapacitySpecificationRequestPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The number of units to request.\n')
    context: typing.Optional[str] = pydantic.Field(None, description='Reserved.\n')
    excess_capacity_termination_policy: typing.Optional[str] = pydantic.Field(None, description='Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet. Supported only for fleets of type ``maintain`` .\n')
    on_demand_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_OnDemandOptionsRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Describes the configuration of On-Demand Instances in an EC2 Fleet.\n')
    replace_unhealthy_instances: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether EC2 Fleet should replace unhealthy Spot Instances. Supported only for fleets of type ``maintain`` . For more information, see `EC2 Fleet health checks <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/manage-ec2-fleet.html#ec2-fleet-health-checks>`_ in the *Amazon EC2 User Guide* .\n')
    spot_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_SpotOptionsRequestPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Describes the configuration of Spot Instances in an EC2 Fleet.\n')
    tag_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnEC2Fleet_TagSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The key-value pair for tagging the EC2 Fleet request on creation. For more information, see `Tagging your resources <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources>`_ . If the fleet type is ``instant`` , specify a resource type of ``fleet`` to tag the fleet or ``instance`` to tag the instances at launch. If the fleet type is ``maintain`` or ``request`` , specify a resource type of ``fleet`` to tag the fleet. You cannot specify a resource type of ``instance`` . To tag instances at launch, specify the tags in a `launch template <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template>`_ .\n')
    terminate_instances_with_expiration: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether running instances should be terminated when the EC2 Fleet expires.\n')
    type: typing.Optional[str] = pydantic.Field(None, description='The fleet type. The default value is ``maintain`` . - ``maintain`` - The EC2 Fleet places an asynchronous request for your desired capacity, and continues to maintain your desired Spot capacity by replenishing interrupted Spot Instances. - ``request`` - The EC2 Fleet places an asynchronous one-time request for your desired capacity, but does submit Spot requests in alternative capacity pools if Spot capacity is unavailable, and does not maintain Spot capacity if Spot Instances are interrupted. - ``instant`` - The EC2 Fleet places a synchronous one-time request for your desired capacity, and returns errors for any instances that could not be launched. For more information, see `EC2 Fleet request types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-request-type.html>`_ in the *Amazon EC2 User Guide* .\n')
    valid_from: typing.Optional[str] = pydantic.Field(None, description='The start date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). The default is to start fulfilling the request immediately.\n')
    valid_until: typing.Optional[str] = pydantic.Field(None, description='The end date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). At this point, no new EC2 Fleet requests are placed or able to fulfill the request. If no value is specified, the request remains until you cancel it.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_eC2_fleet_props = ec2.CfnEC2FleetProps(\n        launch_template_configs=[ec2.CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty(\n            launch_template_specification=ec2.CfnEC2Fleet.FleetLaunchTemplateSpecificationRequestProperty(\n                version="version",\n\n                # the properties below are optional\n                launch_template_id="launchTemplateId",\n                launch_template_name="launchTemplateName"\n            ),\n            overrides=[ec2.CfnEC2Fleet.FleetLaunchTemplateOverridesRequestProperty(\n                availability_zone="availabilityZone",\n                instance_requirements=ec2.CfnEC2Fleet.InstanceRequirementsRequestProperty(\n                    accelerator_count=ec2.CfnEC2Fleet.AcceleratorCountRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    accelerator_manufacturers=["acceleratorManufacturers"],\n                    accelerator_names=["acceleratorNames"],\n                    accelerator_total_memory_mi_b=ec2.CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    accelerator_types=["acceleratorTypes"],\n                    allowed_instance_types=["allowedInstanceTypes"],\n                    bare_metal="bareMetal",\n                    baseline_ebs_bandwidth_mbps=ec2.CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    burstable_performance="burstablePerformance",\n                    cpu_manufacturers=["cpuManufacturers"],\n                    excluded_instance_types=["excludedInstanceTypes"],\n                    instance_generations=["instanceGenerations"],\n                    local_storage="localStorage",\n                    local_storage_types=["localStorageTypes"],\n                    memory_gi_bPer_vCpu=ec2.CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    memory_mi_b=ec2.CfnEC2Fleet.MemoryMiBRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    network_bandwidth_gbps=ec2.CfnEC2Fleet.NetworkBandwidthGbpsRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    network_interface_count=ec2.CfnEC2Fleet.NetworkInterfaceCountRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    on_demand_max_price_percentage_over_lowest_price=123,\n                    require_hibernate_support=False,\n                    spot_max_price_percentage_over_lowest_price=123,\n                    total_local_storage_gb=ec2.CfnEC2Fleet.TotalLocalStorageGBRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    v_cpu_count=ec2.CfnEC2Fleet.VCpuCountRangeRequestProperty(\n                        max=123,\n                        min=123\n                    )\n                ),\n                instance_type="instanceType",\n                max_price="maxPrice",\n                placement=ec2.CfnEC2Fleet.PlacementProperty(\n                    affinity="affinity",\n                    availability_zone="availabilityZone",\n                    group_name="groupName",\n                    host_id="hostId",\n                    host_resource_group_arn="hostResourceGroupArn",\n                    partition_number=123,\n                    spread_domain="spreadDomain",\n                    tenancy="tenancy"\n                ),\n                priority=123,\n                subnet_id="subnetId",\n                weighted_capacity=123\n            )]\n        )],\n        target_capacity_specification=ec2.CfnEC2Fleet.TargetCapacitySpecificationRequestProperty(\n            total_target_capacity=123,\n\n            # the properties below are optional\n            default_target_capacity_type="defaultTargetCapacityType",\n            on_demand_target_capacity=123,\n            spot_target_capacity=123,\n            target_capacity_unit_type="targetCapacityUnitType"\n        ),\n\n        # the properties below are optional\n        context="context",\n        excess_capacity_termination_policy="excessCapacityTerminationPolicy",\n        on_demand_options=ec2.CfnEC2Fleet.OnDemandOptionsRequestProperty(\n            allocation_strategy="allocationStrategy",\n            capacity_reservation_options=ec2.CfnEC2Fleet.CapacityReservationOptionsRequestProperty(\n                usage_strategy="usageStrategy"\n            ),\n            max_total_price="maxTotalPrice",\n            min_target_capacity=123,\n            single_availability_zone=False,\n            single_instance_type=False\n        ),\n        replace_unhealthy_instances=False,\n        spot_options=ec2.CfnEC2Fleet.SpotOptionsRequestProperty(\n            allocation_strategy="allocationStrategy",\n            instance_interruption_behavior="instanceInterruptionBehavior",\n            instance_pools_to_use_count=123,\n            maintenance_strategies=ec2.CfnEC2Fleet.MaintenanceStrategiesProperty(\n                capacity_rebalance=ec2.CfnEC2Fleet.CapacityRebalanceProperty(\n                    replacement_strategy="replacementStrategy",\n                    termination_delay=123\n                )\n            ),\n            max_total_price="maxTotalPrice",\n            min_target_capacity=123,\n            single_availability_zone=False,\n            single_instance_type=False\n        ),\n        tag_specifications=[ec2.CfnEC2Fleet.TagSpecificationProperty(\n            resource_type="resourceType",\n            tags=[CfnTag(\n                key="key",\n                value="value"\n            )]\n        )],\n        terminate_instances_with_expiration=False,\n        type="type",\n        valid_from="validFrom",\n        valid_until="validUntil"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['launch_template_configs', 'target_capacity_specification', 'context', 'excess_capacity_termination_policy', 'on_demand_options', 'replace_unhealthy_instances', 'spot_options', 'tag_specifications', 'terminate_instances_with_expiration', 'type', 'valid_from', 'valid_until']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEC2FleetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEgressOnlyInternetGatewayProps
class CfnEgressOnlyInternetGatewayPropsDef(BaseCfnProperty):
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC for which to create the egress-only internet gateway.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-egressonlyinternetgateway.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_egress_only_internet_gateway_props = ec2.CfnEgressOnlyInternetGatewayProps(\n        vpc_id="vpcId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['vpc_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEgressOnlyInternetGatewayProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEIPAssociationProps
class CfnEIPAssociationPropsDef(BaseCfnProperty):
    allocation_id: typing.Optional[str] = pydantic.Field(None, description='The allocation ID. This is required.\n')
    eip: typing.Optional[str] = pydantic.Field(None, description='Deprecated.\n')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the instance. The instance must have exactly one attached network interface. You can specify either the instance ID or the network interface ID, but not both.\n')
    network_interface_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the network interface. If the instance has more than one network interface, you must specify a network interface ID. You can specify either the instance ID or the network interface ID, but not both.\n')
    private_ip_address: typing.Optional[str] = pydantic.Field(None, description='The primary or secondary private IP address to associate with the Elastic IP address. If no private IP address is specified, the Elastic IP address is associated with the primary private IP address.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip-association.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_eIPAssociation_props = ec2.CfnEIPAssociationProps(\n        allocation_id="allocationId",\n        eip="eip",\n        instance_id="instanceId",\n        network_interface_id="networkInterfaceId",\n        private_ip_address="privateIpAddress"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['allocation_id', 'eip', 'instance_id', 'network_interface_id', 'private_ip_address']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEIPAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEIPProps
class CfnEIPPropsDef(BaseCfnProperty):
    domain: typing.Optional[str] = pydantic.Field(None, description='The network ( ``vpc`` ). If you define an Elastic IP address and associate it with a VPC that is defined in the same template, you must declare a dependency on the VPC-gateway attachment by using the `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ on this resource.\n')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the instance. .. epigraph:: Updates to the ``InstanceId`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.\n')
    network_border_group: typing.Optional[str] = pydantic.Field(None, description='A unique set of Availability Zones, Local Zones, or Wavelength Zones from which AWS advertises IP addresses. Use this parameter to limit the IP address to this location. IP addresses cannot move between network border groups. Use `DescribeAvailabilityZones <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAvailabilityZones.html>`_ to view the network border groups. You cannot use a network border group with EC2 Classic. If you attempt this operation on EC2 Classic, you receive an ``InvalidParameterCombination`` error.\n')
    public_ipv4_pool: typing.Optional[str] = pydantic.Field(None, description='The ID of an address pool that you own. Use this parameter to let Amazon EC2 select an address from the address pool. .. epigraph:: Updates to the ``PublicIpv4Pool`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Any tags assigned to the Elastic IP address. .. epigraph:: Updates to the ``Tags`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.\n')
    transfer_address: typing.Optional[str] = pydantic.Field(None, description='The Elastic IP address you are accepting for transfer. You can only accept one transferred address. For more information on Elastic IP address transfers, see `Transfer Elastic IP addresses <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-eips.html#transfer-EIPs-intro>`_ in the *Amazon Virtual Private Cloud User Guide* .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html\n:exampleMetadata: infused\n\nExample::\n\n    # instance: ec2.Instance\n\n    # my_zone: route53.HostedZone\n\n\n    elastic_ip = ec2.CfnEIP(self, "EIP",\n        domain="vpc",\n        instance_id=instance.instance_id\n    )\n    route53.ARecord(self, "ARecord",\n        zone=my_zone,\n        target=route53.RecordTarget.from_ip_addresses(elastic_ip.ref)\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['domain', 'instance_id', 'network_border_group', 'public_ipv4_pool', 'tags', 'transfer_address']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEIPProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnEnclaveCertificateIamRoleAssociationProps
class CfnEnclaveCertificateIamRoleAssociationPropsDef(BaseCfnProperty):
    certificate_arn: str = pydantic.Field(..., description='The ARN of the ACM certificate with which to associate the IAM role.\n')
    role_arn: str = pydantic.Field(..., description='The ARN of the IAM role to associate with the ACM certificate. You can associate up to 16 IAM roles with an ACM certificate.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_enclave_certificate_iam_role_association_props = ec2.CfnEnclaveCertificateIamRoleAssociationProps(\n        certificate_arn="certificateArn",\n        role_arn="roleArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['certificate_arn', 'role_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnEnclaveCertificateIamRoleAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnFlowLogProps
class CfnFlowLogPropsDef(BaseCfnProperty):
    resource_id: str = pydantic.Field(..., description='The ID of the resource to monitor. For example, if the resource type is ``VPC`` , specify the ID of the VPC.\n')
    resource_type: str = pydantic.Field(..., description='The type of resource to monitor.\n')
    deliver_logs_permission_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the IAM role that allows Amazon EC2 to publish flow logs to a CloudWatch Logs log group in your account. This parameter is required if the destination type is ``cloud-watch-logs`` and unsupported otherwise.\n')
    destination_options: typing.Any = pydantic.Field(None, description='The destination options. The following options are supported:. - ``FileFormat`` - The format for the flow log ( ``plain-text`` | ``parquet`` ). The default is ``plain-text`` . - ``HiveCompatiblePartitions`` - Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3 ( ``true`` | ``false`` ). The default is ``false`` . - ``PerHourPartition`` - Indicates whether to partition the flow log per hour ( ``true`` | ``false`` ). The default is ``false`` .\n')
    log_destination: typing.Optional[str] = pydantic.Field(None, description="The destination for the flow log data. The meaning of this parameter depends on the destination type. - If the destination type is ``cloud-watch-logs`` , specify the ARN of a CloudWatch Logs log group. For example: arn:aws:logs: *region* : *account_id* :log-group: *my_group* Alternatively, use the ``LogGroupName`` parameter. - If the destination type is ``s3`` , specify the ARN of an S3 bucket. For example: arn:aws:s3::: *my_bucket* / *my_subfolder* / The subfolder is optional. Note that you can't use ``AWSLogs`` as a subfolder name. - If the destination type is ``kinesis-data-firehose`` , specify the ARN of a Kinesis Data Firehose delivery stream. For example: arn:aws:firehose: *region* : *account_id* :deliverystream: *my_stream*\n")
    log_destination_type: typing.Optional[str] = pydantic.Field(None, description='The type of destination for the flow log data. Default: ``cloud-watch-logs``\n')
    log_format: typing.Optional[str] = pydantic.Field(None, description='The fields to include in the flow log record, in the order in which they should appear. If you omit this parameter, the flow log is created using the default format. If you specify this parameter, you must include at least one field. For more information about the available fields, see `Flow log records <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-log-records>`_ in the *Amazon VPC User Guide* or `Transit Gateway Flow Log records <https://docs.aws.amazon.com/vpc/latest/tgw/tgw-flow-logs.html#flow-log-records>`_ in the *AWS Transit Gateway Guide* . Specify the fields using the ``${field-id}`` format, separated by spaces.\n')
    log_group_name: typing.Optional[str] = pydantic.Field(None, description='The name of a new or existing CloudWatch Logs log group where Amazon EC2 publishes your flow logs. This parameter is valid only if the destination type is ``cloud-watch-logs`` .\n')
    max_aggregation_interval: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record. The possible values are 60 seconds (1 minute) or 600 seconds (10 minutes). This parameter must be 60 seconds for transit gateway resource types. When a network interface is attached to a `Nitro-based instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ , the aggregation interval is always 60 seconds or less, regardless of the value that you specify. Default: 600\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to apply to the flow logs.\n')
    traffic_type: typing.Optional[str] = pydantic.Field(None, description='The type of traffic to monitor (accepted traffic, rejected traffic, or all traffic). This parameter is not supported for transit gateway resource types. It is required for the other resource types.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # destination_options: Any\n\n    cfn_flow_log_props = ec2.CfnFlowLogProps(\n        resource_id="resourceId",\n        resource_type="resourceType",\n\n        # the properties below are optional\n        deliver_logs_permission_arn="deliverLogsPermissionArn",\n        destination_options=destination_options,\n        log_destination="logDestination",\n        log_destination_type="logDestinationType",\n        log_format="logFormat",\n        log_group_name="logGroupName",\n        max_aggregation_interval=123,\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        traffic_type="trafficType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['resource_id', 'resource_type', 'deliver_logs_permission_arn', 'destination_options', 'log_destination', 'log_destination_type', 'log_format', 'log_group_name', 'max_aggregation_interval', 'tags', 'traffic_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnFlowLogProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnGatewayRouteTableAssociationProps
class CfnGatewayRouteTableAssociationPropsDef(BaseCfnProperty):
    gateway_id: str = pydantic.Field(..., description='The ID of the gateway.\n')
    route_table_id: str = pydantic.Field(..., description='The ID of the route table.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_gateway_route_table_association_props = ec2.CfnGatewayRouteTableAssociationProps(\n        gateway_id="gatewayId",\n        route_table_id="routeTableId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['gateway_id', 'route_table_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnGatewayRouteTableAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnHostProps
class CfnHostPropsDef(BaseCfnProperty):
    availability_zone: str = pydantic.Field(..., description='The Availability Zone in which to allocate the Dedicated Host.\n')
    auto_placement: typing.Optional[str] = pydantic.Field(None, description='Indicates whether the host accepts any untargeted instance launches that match its instance type configuration, or if it only accepts Host tenancy instance launches that specify its unique host ID. For more information, see `Understanding auto-placement and affinity <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/how-dedicated-hosts-work.html#dedicated-hosts-understanding>`_ in the *Amazon EC2 User Guide* . Default: ``on``\n')
    host_maintenance: typing.Optional[str] = pydantic.Field(None, description='Indicates whether host maintenance is enabled or disabled for the Dedicated Host.\n')
    host_recovery: typing.Optional[str] = pydantic.Field(None, description='Indicates whether to enable or disable host recovery for the Dedicated Host. Host recovery is disabled by default. For more information, see `Host recovery <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-recovery.html>`_ in the *Amazon EC2 User Guide* . Default: ``off``\n')
    instance_family: typing.Optional[str] = pydantic.Field(None, description='The instance family supported by the Dedicated Host. For example, ``m5`` .\n')
    instance_type: typing.Optional[str] = pydantic.Field(None, description='Specifies the instance type to be supported by the Dedicated Hosts. If you specify an instance type, the Dedicated Hosts support instances of the specified instance type only.\n')
    outpost_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the AWS Outpost on which the Dedicated Host is allocated.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_host_props = ec2.CfnHostProps(\n        availability_zone="availabilityZone",\n\n        # the properties below are optional\n        auto_placement="autoPlacement",\n        host_maintenance="hostMaintenance",\n        host_recovery="hostRecovery",\n        instance_family="instanceFamily",\n        instance_type="instanceType",\n        outpost_arn="outpostArn"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'auto_placement', 'host_maintenance', 'host_recovery', 'instance_family', 'instance_type', 'outpost_arn']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnHostProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnInstanceProps
class CfnInstancePropsDef(BaseCfnProperty):
    additional_info: typing.Optional[str] = pydantic.Field(None, description='This property is reserved for internal use. If you use it, the stack fails with this error: ``Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)`` .\n')
    affinity: typing.Optional[str] = pydantic.Field(None, description='Indicates whether the instance is associated with a dedicated host. If you want the instance to always restart on the same host on which it was launched, specify ``host`` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify ``default`` .\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone of the instance. If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region. This parameter is not supported by `DescribeImageAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html>`_ .\n')
    block_device_mappings: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_BlockDeviceMappingPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The block device mapping entries that defines the block devices to attach to the instance at launch. By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the ``DeleteOnTermination`` setting. .. epigraph:: After the instance is running, you can modify only the ``DeleteOnTermination`` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .\n')
    cpu_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_CpuOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The CPU options for the instance. For more information, see `Optimize CPU options <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .\n')
    credit_specification: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_CreditSpecificationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The credit option for CPU usage of the burstable performance instance. Valid values are ``standard`` and ``unlimited`` . To change this attribute after launch, use `ModifyInstanceCreditSpecification <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html>`_ . For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ in the *Amazon EC2 User Guide* . Default: ``standard`` (T2 instances) or ``unlimited`` (T3/T3a/T4g instances) For T3 instances with ``host`` tenancy, only ``standard`` is supported.\n')
    disable_api_termination: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="If you set this parameter to ``true`` , you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. To change this attribute after launch, use `ModifyInstanceAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html>`_ . Alternatively, if you set ``InstanceInitiatedShutdownBehavior`` to ``terminate`` , you can terminate the instance by running the shutdown command from the instance. Default: ``false``\n")
    ebs_optimized: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance. Default: ``false``\n")
    elastic_gpu_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_ElasticGpuSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An elastic GPU to associate with the instance. An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see `Amazon EC2 Elastic GPUs <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html>`_ in the *Amazon EC2 User Guide* .\n')
    elastic_inference_accelerators: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_ElasticInferenceAcceleratorPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='An elastic inference accelerator to associate with the instance. Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads. You cannot specify accelerators from different generations in the same request. .. epigraph:: Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.\n')
    enclave_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_EnclaveOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='Indicates whether the instance is enabled for AWS Nitro Enclaves.\n')
    hibernation_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_HibernationOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Indicates whether an instance is enabled for hibernation. For more information, see `Hibernate your instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html>`_ in the *Amazon EC2 User Guide* . You can't enable hibernation and AWS Nitro Enclaves on the same instance.\n")
    host_id: typing.Optional[str] = pydantic.Field(None, description="If you specify host for the ``Affinity`` property, the ID of a dedicated host that the instance is associated with. If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.\n")
    host_resource_group_arn: typing.Optional[str] = pydantic.Field(None, description='The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host`` .\n')
    iam_instance_profile: typing.Optional[str] = pydantic.Field(None, description='The name of an IAM instance profile. To create a new IAM instance profile, use the `AWS::IAM::InstanceProfile <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html>`_ resource.\n')
    image_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the AMI. An AMI ID is required to launch an instance and must be specified here or in a launch template.\n')
    instance_initiated_shutdown_behavior: typing.Optional[str] = pydantic.Field(None, description='Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown). Default: ``stop``\n')
    instance_type: typing.Optional[str] = pydantic.Field(None, description='The instance type. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* . Default: ``m1.small``\n')
    ipv6_address_count: typing.Union[int, float, None] = pydantic.Field(None, description="The number of IPv6 addresses to associate with the primary network interface. Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch. You cannot specify this option and the network interfaces option in the same request.\n")
    ipv6_addresses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_InstanceIpv6AddressPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="The IPv6 addresses from the range of the subnet to associate with the primary network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch. You cannot specify this option and the network interfaces option in the same request.\n")
    kernel_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the kernel. .. epigraph:: We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `PV-GRUB <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .\n')
    key_name: typing.Optional[str] = pydantic.Field(None, description="The name of the key pair. You can create a key pair using `CreateKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html>`_ or `ImportKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html>`_ . .. epigraph:: If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.\n")
    launch_template: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_LaunchTemplateSpecificationPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The launch template to use to launch the instances. Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.\n')
    license_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_LicenseSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The license configurations.\n')
    monitoring: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Specifies whether detailed monitoring is enabled for the instance. Specify ``true`` to enable detailed monitoring. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see `Enable or turn off detailed monitoring for your instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html>`_ in the *Amazon EC2 User Guide* .\n')
    network_interfaces: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_NetworkInterfacePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The network interfaces to associate with the instance. .. epigraph:: If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed. If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ to declare a dependency on the VPC-gateway attachment.\n')
    placement_group_name: typing.Optional[str] = pydantic.Field(None, description='The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).\n')
    private_dns_name_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_PrivateDnsNameOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for the instance hostname.\n')
    private_ip_address: typing.Optional[str] = pydantic.Field(None, description="The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet. Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request. You cannot specify this option and the network interfaces option in the same request. If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.\n")
    propagate_tags_to_volume_on_creation: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch. If you specify ``true`` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify ``false`` , those tags are not assigned to the attached volumes.\n')
    ramdisk_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the RAM disk to select. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID. .. epigraph:: We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `PV-GRUB <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .\n')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of the security groups. You can specify the IDs of existing security groups and references to resources created by the stack template. If you specify a network interface, you must specify any security groups as part of the network interface.\n')
    security_groups: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='[Default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead. You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template. Default: Amazon EC2 uses the default security group.\n')
    source_dest_check: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives. If the value is ``true`` , source/destination checks are enabled; otherwise, they are disabled. The default value is ``true`` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.\n')
    ssm_associations: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_SsmAssociationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The SSM `document <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html>`_ and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see `Create an IAM instance profile for Systems Manager <https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html>`_ in the *AWS Systems Manager User Guide* . .. epigraph:: You can currently associate only one document with an instance.\n')
    subnet_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the subnet to launch the instance into. If you specify a network interface, you must specify any subnets as part of the network interface.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to add to the instance. These tags are not applied to the EBS volumes, such as the root volume, unless `PropagateTagsToVolumeOnCreation <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation>`_ is ``true`` .\n')
    tenancy: typing.Optional[str] = pydantic.Field(None, description='The tenancy of the instance. An instance with a tenancy of ``dedicated`` runs on single-tenant hardware.\n')
    user_data: typing.Optional[str] = pydantic.Field(None, description='The user data script to make available to the instance. User data is limited to 16 KB. You must provide base64-encoded text. For more information, see `Fn::Base64 <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-base64.html>`_ . User data runs only at instance launch. For more information, see `Run commands on your Linux instance at launch <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html>`_ and `Run commands on your Windows instance at launch <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html>`_ .\n')
    volumes: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnInstance_VolumePropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The volumes to attach to the instance.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_instance_props = ec2.CfnInstanceProps(\n        additional_info="additionalInfo",\n        affinity="affinity",\n        availability_zone="availabilityZone",\n        block_device_mappings=[ec2.CfnInstance.BlockDeviceMappingProperty(\n            device_name="deviceName",\n\n            # the properties below are optional\n            ebs=ec2.CfnInstance.EbsProperty(\n                delete_on_termination=False,\n                encrypted=False,\n                iops=123,\n                kms_key_id="kmsKeyId",\n                snapshot_id="snapshotId",\n                volume_size=123,\n                volume_type="volumeType"\n            ),\n            no_device=ec2.CfnInstance.NoDeviceProperty(),\n            virtual_name="virtualName"\n        )],\n        cpu_options=ec2.CfnInstance.CpuOptionsProperty(\n            core_count=123,\n            threads_per_core=123\n        ),\n        credit_specification=ec2.CfnInstance.CreditSpecificationProperty(\n            cpu_credits="cpuCredits"\n        ),\n        disable_api_termination=False,\n        ebs_optimized=False,\n        elastic_gpu_specifications=[ec2.CfnInstance.ElasticGpuSpecificationProperty(\n            type="type"\n        )],\n        elastic_inference_accelerators=[ec2.CfnInstance.ElasticInferenceAcceleratorProperty(\n            type="type",\n\n            # the properties below are optional\n            count=123\n        )],\n        enclave_options=ec2.CfnInstance.EnclaveOptionsProperty(\n            enabled=False\n        ),\n        hibernation_options=ec2.CfnInstance.HibernationOptionsProperty(\n            configured=False\n        ),\n        host_id="hostId",\n        host_resource_group_arn="hostResourceGroupArn",\n        iam_instance_profile="iamInstanceProfile",\n        image_id="imageId",\n        instance_initiated_shutdown_behavior="instanceInitiatedShutdownBehavior",\n        instance_type="instanceType",\n        ipv6_address_count=123,\n        ipv6_addresses=[ec2.CfnInstance.InstanceIpv6AddressProperty(\n            ipv6_address="ipv6Address"\n        )],\n        kernel_id="kernelId",\n        key_name="keyName",\n        launch_template=ec2.CfnInstance.LaunchTemplateSpecificationProperty(\n            version="version",\n\n            # the properties below are optional\n            launch_template_id="launchTemplateId",\n            launch_template_name="launchTemplateName"\n        ),\n        license_specifications=[ec2.CfnInstance.LicenseSpecificationProperty(\n            license_configuration_arn="licenseConfigurationArn"\n        )],\n        monitoring=False,\n        network_interfaces=[ec2.CfnInstance.NetworkInterfaceProperty(\n            device_index="deviceIndex",\n\n            # the properties below are optional\n            associate_carrier_ip_address=False,\n            associate_public_ip_address=False,\n            delete_on_termination=False,\n            description="description",\n            group_set=["groupSet"],\n            ipv6_address_count=123,\n            ipv6_addresses=[ec2.CfnInstance.InstanceIpv6AddressProperty(\n                ipv6_address="ipv6Address"\n            )],\n            network_interface_id="networkInterfaceId",\n            private_ip_address="privateIpAddress",\n            private_ip_addresses=[ec2.CfnInstance.PrivateIpAddressSpecificationProperty(\n                primary=False,\n                private_ip_address="privateIpAddress"\n            )],\n            secondary_private_ip_address_count=123,\n            subnet_id="subnetId"\n        )],\n        placement_group_name="placementGroupName",\n        private_dns_name_options=ec2.CfnInstance.PrivateDnsNameOptionsProperty(\n            enable_resource_name_dns_aaaa_record=False,\n            enable_resource_name_dns_aRecord=False,\n            hostname_type="hostnameType"\n        ),\n        private_ip_address="privateIpAddress",\n        propagate_tags_to_volume_on_creation=False,\n        ramdisk_id="ramdiskId",\n        security_group_ids=["securityGroupIds"],\n        security_groups=["securityGroups"],\n        source_dest_check=False,\n        ssm_associations=[ec2.CfnInstance.SsmAssociationProperty(\n            document_name="documentName",\n\n            # the properties below are optional\n            association_parameters=[ec2.CfnInstance.AssociationParameterProperty(\n                key="key",\n                value=["value"]\n            )]\n        )],\n        subnet_id="subnetId",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        tenancy="tenancy",\n        user_data="userData",\n        volumes=[ec2.CfnInstance.VolumeProperty(\n            device="device",\n            volume_id="volumeId"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['additional_info', 'affinity', 'availability_zone', 'block_device_mappings', 'cpu_options', 'credit_specification', 'disable_api_termination', 'ebs_optimized', 'elastic_gpu_specifications', 'elastic_inference_accelerators', 'enclave_options', 'hibernation_options', 'host_id', 'host_resource_group_arn', 'iam_instance_profile', 'image_id', 'instance_initiated_shutdown_behavior', 'instance_type', 'ipv6_address_count', 'ipv6_addresses', 'kernel_id', 'key_name', 'launch_template', 'license_specifications', 'monitoring', 'network_interfaces', 'placement_group_name', 'private_dns_name_options', 'private_ip_address', 'propagate_tags_to_volume_on_creation', 'ramdisk_id', 'security_group_ids', 'security_groups', 'source_dest_check', 'ssm_associations', 'subnet_id', 'tags', 'tenancy', 'user_data', 'volumes']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInstanceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnInternetGatewayProps
class CfnInternetGatewayPropsDef(BaseCfnProperty):
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Any tags to assign to the internet gateway.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_internet_gateway_props = ec2.CfnInternetGatewayProps(\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnInternetGatewayProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnIPAMAllocationProps
class CfnIPAMAllocationPropsDef(BaseCfnProperty):
    ipam_pool_id: str = pydantic.Field(..., description='The ID of the IPAM pool from which you would like to allocate a CIDR.\n')
    cidr: typing.Optional[str] = pydantic.Field(None, description='The CIDR you would like to allocate from the IPAM pool. Note the following:. - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR. - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored. Possible values: Any available IPv4 or IPv6 CIDR.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the allocation.\n')
    netmask_length: typing.Union[int, float, None] = pydantic.Field(None, description='The netmask length of the CIDR you would like to allocate from the IPAM pool. Note the following:. - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR. - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_iPAMAllocation_props = ec2.CfnIPAMAllocationProps(\n        ipam_pool_id="ipamPoolId",\n\n        # the properties below are optional\n        cidr="cidr",\n        description="description",\n        netmask_length=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ipam_pool_id', 'cidr', 'description', 'netmask_length']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnIPAMAllocationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnIPAMPoolCidrProps
class CfnIPAMPoolCidrPropsDef(BaseCfnProperty):
    ipam_pool_id: str = pydantic.Field(..., description='The ID of the IPAM pool.\n')
    cidr: typing.Optional[str] = pydantic.Field(None, description='The CIDR provisioned to the IPAM pool. A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is ``10.24.34.0/23`` . An IPv6 CIDR example is ``2001:DB8::/32`` .\n')
    netmask_length: typing.Union[int, float, None] = pydantic.Field(None, description='The netmask length of the CIDR you\'d like to provision to a pool. Can be used for provisioning Amazon-provided IPv6 CIDRs to top-level pools and for provisioning CIDRs to pools with source pools. Cannot be used to provision BYOIP CIDRs to top-level pools. "NetmaskLength" or "Cidr" is required.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_iPAMPool_cidr_props = ec2.CfnIPAMPoolCidrProps(\n        ipam_pool_id="ipamPoolId",\n\n        # the properties below are optional\n        cidr="cidr",\n        netmask_length=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ipam_pool_id', 'cidr', 'netmask_length']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnIPAMPoolCidrProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnIPAMPoolProps
class CfnIPAMPoolPropsDef(BaseCfnProperty):
    address_family: str = pydantic.Field(..., description='The address family of the pool.\n')
    ipam_scope_id: str = pydantic.Field(..., description='The ID of the scope in which you would like to create the IPAM pool.\n')
    allocation_default_netmask_length: typing.Union[int, float, None] = pydantic.Field(None, description='The default netmask length for allocations added to this pool. If, for example, the CIDR assigned to this pool is 10.0.0.0/8 and you enter 16 here, new allocations will default to 10.0.0.0/16.\n')
    allocation_max_netmask_length: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum netmask length possible for CIDR allocations in this IPAM pool to be compliant. The maximum netmask length must be greater than the minimum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.\n')
    allocation_min_netmask_length: typing.Union[int, float, None] = pydantic.Field(None, description='The minimum netmask length required for CIDR allocations in this IPAM pool to be compliant. The minimum netmask length must be less than the maximum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.\n')
    allocation_resource_tags: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.CfnTagDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Tags that are required for resources that use CIDRs from this IPAM pool. Resources that do not have these tags will not be allowed to allocate space from the pool. If the resources have their tags changed after they have allocated space or if the allocation tagging requirements are changed on the pool, the resource may be marked as noncompliant.\n')
    auto_import: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="If selected, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM. The CIDRs that will be allocated for these resources must not already be allocated to other resources in order for the import to succeed. IPAM will import a CIDR regardless of its compliance with the pool's allocation rules, so a resource might be imported and subsequently marked as noncompliant. If IPAM discovers multiple CIDRs that overlap, IPAM will import the largest CIDR only. If IPAM discovers multiple CIDRs with matching CIDRs, IPAM will randomly import one of them only. A locale must be set on the pool for this feature to work.\n")
    aws_service: typing.Optional[str] = pydantic.Field(None, description='Limits which service in AWS that the pool can be used in. "ec2", for example, allows users to use space for Elastic IP addresses and VPCs.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the IPAM pool.\n')
    locale: typing.Optional[str] = pydantic.Field(None, description="The locale of the IPAM pool. In IPAM, the locale is the AWS Region where you want to make an IPAM pool available for allocations. Only resources in the same Region as the locale of the pool can get IP address allocations from the pool. You can only allocate a CIDR for a VPC, for example, from an IPAM pool that shares a locale with the VPC’s Region. Note that once you choose a Locale for a pool, you cannot modify it. If you choose an AWS Region for locale that has not been configured as an operating Region for the IPAM, you'll get an error.\n")
    provisioned_cidrs: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnIPAMPool_ProvisionedCidrPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Information about the CIDRs provisioned to an IPAM pool.\n')
    public_ip_source: typing.Optional[str] = pydantic.Field(None, description='The IP address source for pools in the public scope. Only used for provisioning IP address CIDRs to pools in the public scope. Default is ``BYOIP`` . For more information, see `Create IPv6 pools <https://docs.aws.amazon.com//vpc/latest/ipam/intro-create-ipv6-pools.html>`_ in the *Amazon VPC IPAM User Guide* . By default, you can add only one Amazon-provided IPv6 CIDR block to a top-level IPv6 pool. For information on increasing the default limit, see `Quotas for your IPAM <https://docs.aws.amazon.com//vpc/latest/ipam/quotas-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .\n')
    publicly_advertisable: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Determines if a pool is publicly advertisable. This option is not available for pools with AddressFamily set to ``ipv4`` .\n')
    source_ipam_pool_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the source IPAM pool. You can use this option to create an IPAM pool within an existing source pool.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_iPAMPool_props = ec2.CfnIPAMPoolProps(\n        address_family="addressFamily",\n        ipam_scope_id="ipamScopeId",\n\n        # the properties below are optional\n        allocation_default_netmask_length=123,\n        allocation_max_netmask_length=123,\n        allocation_min_netmask_length=123,\n        allocation_resource_tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        auto_import=False,\n        aws_service="awsService",\n        description="description",\n        locale="locale",\n        provisioned_cidrs=[ec2.CfnIPAMPool.ProvisionedCidrProperty(\n            cidr="cidr"\n        )],\n        public_ip_source="publicIpSource",\n        publicly_advertisable=False,\n        source_ipam_pool_id="sourceIpamPoolId",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['address_family', 'ipam_scope_id', 'allocation_default_netmask_length', 'allocation_max_netmask_length', 'allocation_min_netmask_length', 'allocation_resource_tags', 'auto_import', 'aws_service', 'description', 'locale', 'provisioned_cidrs', 'public_ip_source', 'publicly_advertisable', 'source_ipam_pool_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnIPAMPoolProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnIPAMProps
class CfnIPAMPropsDef(BaseCfnProperty):
    default_resource_discovery_association_id: typing.Optional[str] = pydantic.Field(None, description="The IPAM's default resource discovery association ID.\n")
    default_resource_discovery_id: typing.Optional[str] = pydantic.Field(None, description="The IPAM's default resource discovery ID.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='The description for the IPAM.\n')
    operating_regions: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnIPAM_IpamOperatingRegionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The operating Regions for an IPAM. Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions. For more information about operating Regions, see `Create an IPAM <https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_iPAMProps = ec2.CfnIPAMProps(\n        default_resource_discovery_association_id="defaultResourceDiscoveryAssociationId",\n        default_resource_discovery_id="defaultResourceDiscoveryId",\n        description="description",\n        operating_regions=[ec2.CfnIPAM.IpamOperatingRegionProperty(\n            region_name="regionName"\n        )],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['default_resource_discovery_association_id', 'default_resource_discovery_id', 'description', 'operating_regions', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnIPAMProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnIPAMResourceDiscoveryAssociationProps
class CfnIPAMResourceDiscoveryAssociationPropsDef(BaseCfnProperty):
    ipam_id: str = pydantic.Field(..., description='The IPAM ID.\n')
    ipam_resource_discovery_id: str = pydantic.Field(..., description='The resource discovery ID.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A tag is a label that you assign to an AWS resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your AWS costs.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_iPAMResource_discovery_association_props = ec2.CfnIPAMResourceDiscoveryAssociationProps(\n        ipam_id="ipamId",\n        ipam_resource_discovery_id="ipamResourceDiscoveryId",\n\n        # the properties below are optional\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ipam_id', 'ipam_resource_discovery_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnIPAMResourceDiscoveryAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnIPAMResourceDiscoveryProps
class CfnIPAMResourceDiscoveryPropsDef(BaseCfnProperty):
    description: typing.Optional[str] = pydantic.Field(None, description='The resource discovery description.\n')
    operating_regions: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnIPAMResourceDiscovery_IpamOperatingRegionPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The operating Regions for the resource discovery. Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='A tag is a label that you assign to an AWS resource. Each tag consists of a key and an optional value. You can use tags to search and filter your resources or track your AWS costs.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_iPAMResource_discovery_props = ec2.CfnIPAMResourceDiscoveryProps(\n        description="description",\n        operating_regions=[ec2.CfnIPAMResourceDiscovery.IpamOperatingRegionProperty(\n            region_name="regionName"\n        )],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'operating_regions', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnIPAMResourceDiscoveryProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnIPAMScopeProps
class CfnIPAMScopePropsDef(BaseCfnProperty):
    ipam_id: str = pydantic.Field(..., description="The ID of the IPAM for which you're creating this scope.\n")
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the scope.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_iPAMScope_props = ec2.CfnIPAMScopeProps(\n        ipam_id="ipamId",\n\n        # the properties below are optional\n        description="description",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ipam_id', 'description', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnIPAMScopeProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnKeyPairProps
class CfnKeyPairPropsDef(BaseCfnProperty):
    key_name: str = pydantic.Field(..., description='A unique name for the key pair. Constraints: Up to 255 ASCII characters\n')
    key_type: typing.Optional[str] = pydantic.Field(None, description='The type of key pair. Note that ED25519 keys are not supported for Windows instances. If the ``PublicKeyMaterial`` property is specified, the ``KeyType`` property is ignored, and the key type is inferred from the ``PublicKeyMaterial`` value. Default: ``rsa``\n')
    public_key_material: typing.Optional[str] = pydantic.Field(None, description='The public key material. The ``PublicKeyMaterial`` property is used to import a key pair. If this property is not specified, then a new key pair will be created.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to apply to the key pair.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_key_pair_props = ec2.CfnKeyPairProps(\n        key_name="keyName",\n\n        # the properties below are optional\n        key_type="keyType",\n        public_key_material="publicKeyMaterial",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['key_name', 'key_type', 'public_key_material', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnKeyPairProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLaunchTemplateProps
class CfnLaunchTemplatePropsDef(BaseCfnProperty):
    launch_template_data: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_LaunchTemplateDataPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The information for the launch template.\n')
    launch_template_name: typing.Optional[str] = pydantic.Field(None, description='A name for the launch template.\n')
    tag_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnLaunchTemplate_LaunchTemplateTagSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The tags to apply to the launch template on creation. To tag the launch template, the resource type must be ``launch-template`` . .. epigraph:: To specify the tags for the resources that are created when an instance is launched, you must use the ``TagSpecifications`` parameter in the `launch template data <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestLaunchTemplateData.html>`_ structure.\n')
    version_description: typing.Optional[str] = pydantic.Field(None, description='A description for the first version of the launch template.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html\n:exampleMetadata: infused\n\nExample::\n\n    # cluster: eks.Cluster\n\n\n    user_data = """MIME-Version: 1.0\n    Content-Type: multipart/mixed; boundary="==MYBOUNDARY=="\n\n    --==MYBOUNDARY==\n    Content-Type: text/x-shellscript; charset="us-ascii"\n\n    #!/bin/bash\n    echo "Running custom user data script"\n\n    --==MYBOUNDARY==--\\\n    """\n    lt = ec2.CfnLaunchTemplate(self, "LaunchTemplate",\n        launch_template_data=ec2.CfnLaunchTemplate.LaunchTemplateDataProperty(\n            instance_type="t3.small",\n            user_data=Fn.base64(user_data)\n        )\n    )\n\n    cluster.add_nodegroup_capacity("extra-ng",\n        launch_template_spec=eks.LaunchTemplateSpec(\n            id=lt.ref,\n            version=lt.attr_latest_version_number\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['launch_template_data', 'launch_template_name', 'tag_specifications', 'version_description']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLaunchTemplateProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLocalGatewayRouteProps
class CfnLocalGatewayRoutePropsDef(BaseCfnProperty):
    destination_cidr_block: str = pydantic.Field(..., description='The CIDR block used for destination matches.\n')
    local_gateway_route_table_id: str = pydantic.Field(..., description='The ID of the local gateway route table.\n')
    local_gateway_virtual_interface_group_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the virtual interface group.\n')
    network_interface_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the network interface.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_local_gateway_route_props = ec2.CfnLocalGatewayRouteProps(\n        destination_cidr_block="destinationCidrBlock",\n        local_gateway_route_table_id="localGatewayRouteTableId",\n\n        # the properties below are optional\n        local_gateway_virtual_interface_group_id="localGatewayVirtualInterfaceGroupId",\n        network_interface_id="networkInterfaceId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_cidr_block', 'local_gateway_route_table_id', 'local_gateway_virtual_interface_group_id', 'network_interface_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLocalGatewayRouteProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLocalGatewayRouteTableProps
class CfnLocalGatewayRouteTablePropsDef(BaseCfnProperty):
    local_gateway_id: str = pydantic.Field(..., description='The ID of the local gateway.\n')
    mode: typing.Optional[str] = pydantic.Field(None, description='The mode of the local gateway route table.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags assigned to the local gateway route table.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_local_gateway_route_table_props = ec2.CfnLocalGatewayRouteTableProps(\n        local_gateway_id="localGatewayId",\n\n        # the properties below are optional\n        mode="mode",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['local_gateway_id', 'mode', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLocalGatewayRouteTableProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps
class CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsDef(BaseCfnProperty):
    local_gateway_route_table_id: str = pydantic.Field(..., description='The ID of the local gateway route table.\n')
    local_gateway_virtual_interface_group_id: str = pydantic.Field(..., description='The ID of the virtual interface group.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags assigned to the association.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_local_gateway_route_table_virtual_interface_group_association_props = ec2.CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps(\n        local_gateway_route_table_id="localGatewayRouteTableId",\n        local_gateway_virtual_interface_group_id="localGatewayVirtualInterfaceGroupId",\n\n        # the properties below are optional\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['local_gateway_route_table_id', 'local_gateway_virtual_interface_group_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnLocalGatewayRouteTableVPCAssociationProps
class CfnLocalGatewayRouteTableVPCAssociationPropsDef(BaseCfnProperty):
    local_gateway_route_table_id: str = pydantic.Field(..., description='The ID of the local gateway route table.\n')
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags assigned to the association.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_local_gateway_route_table_vPCAssociation_props = ec2.CfnLocalGatewayRouteTableVPCAssociationProps(\n        local_gateway_route_table_id="localGatewayRouteTableId",\n        vpc_id="vpcId",\n\n        # the properties below are optional\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['local_gateway_route_table_id', 'vpc_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnLocalGatewayRouteTableVPCAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNatGatewayProps
class CfnNatGatewayPropsDef(BaseCfnProperty):
    subnet_id: str = pydantic.Field(..., description='The ID of the subnet in which the NAT gateway is located.\n')
    allocation_id: typing.Optional[str] = pydantic.Field(None, description="[Public NAT gateway only] The allocation ID of the Elastic IP address that's associated with the NAT gateway. This property is required for a public NAT gateway and cannot be specified with a private NAT gateway.\n")
    connectivity_type: typing.Optional[str] = pydantic.Field(None, description='Indicates whether the NAT gateway supports public or private connectivity. The default is public connectivity.\n')
    max_drain_duration_seconds: typing.Union[int, float, None] = pydantic.Field(None, description='The maximum amount of time to wait (in seconds) before forcibly releasing the IP addresses if connections are still in progress. Default value is 350 seconds.\n')
    private_ip_address: typing.Optional[str] = pydantic.Field(None, description="The private IPv4 address to assign to the NAT gateway. If you don't provide an address, a private IPv4 address will be automatically assigned.\n")
    secondary_allocation_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Secondary EIP allocation IDs. For more information, see `Create a NAT gateway <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating>`_ in the *Amazon VPC User Guide* .\n')
    secondary_private_ip_address_count: typing.Union[int, float, None] = pydantic.Field(None, description='[Private NAT gateway only] The number of secondary private IPv4 addresses you want to assign to the NAT gateway. For more information about secondary addresses, see `Create a NAT gateway <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating>`_ in the *Amazon Virtual Private Cloud User Guide* . .. epigraph:: ``SecondaryPrivateIpAddressCount`` and ``SecondaryPrivateIpAddresses`` cannot be set at the same time.\n')
    secondary_private_ip_addresses: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='Secondary private IPv4 addresses. For more information about secondary addresses, see `Create a NAT gateway <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-creating>`_ in the *Amazon Virtual Private Cloud User Guide* . .. epigraph:: ``SecondaryPrivateIpAddressCount`` and ``SecondaryPrivateIpAddresses`` cannot be set at the same time.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the NAT gateway.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_nat_gateway_props = ec2.CfnNatGatewayProps(\n        subnet_id="subnetId",\n\n        # the properties below are optional\n        allocation_id="allocationId",\n        connectivity_type="connectivityType",\n        max_drain_duration_seconds=123,\n        private_ip_address="privateIpAddress",\n        secondary_allocation_ids=["secondaryAllocationIds"],\n        secondary_private_ip_address_count=123,\n        secondary_private_ip_addresses=["secondaryPrivateIpAddresses"],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['subnet_id', 'allocation_id', 'connectivity_type', 'max_drain_duration_seconds', 'private_ip_address', 'secondary_allocation_ids', 'secondary_private_ip_address_count', 'secondary_private_ip_addresses', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNatGatewayProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkAclEntryProps
class CfnNetworkAclEntryPropsDef(BaseCfnProperty):
    network_acl_id: str = pydantic.Field(..., description='The ID of the ACL for the entry.\n')
    protocol: typing.Union[int, float] = pydantic.Field(..., description='The IP protocol that the rule applies to. You must specify -1 or a protocol number. You can specify -1 for all protocols. .. epigraph:: If you specify -1, all ports are opened and the ``PortRange`` property is ignored.\n')
    rule_action: str = pydantic.Field(..., description='Whether to allow or deny traffic that matches the rule; valid values are "allow" or "deny".\n')
    rule_number: typing.Union[int, float] = pydantic.Field(..., description="Rule number to assign to the entry, such as 100. ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.\n")
    cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv4 CIDR range to allow or deny, in CIDR notation (for example, 172.16.0.0/24). Requirement is conditional: You must specify the ``CidrBlock`` or ``Ipv6CidrBlock`` property.\n')
    egress: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Whether this rule applies to egress traffic from the subnet ( ``true`` ) or ingress traffic to the subnet ( ``false`` ). By default, AWS CloudFormation specifies ``false`` .\n')
    icmp: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkAclEntry_IcmpPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The Internet Control Message Protocol (ICMP) code and type. Requirement is conditional: Required if specifying 1 (ICMP) for the protocol parameter.\n')
    ipv6_cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv6 network range to allow or deny, in CIDR notation. Requirement is conditional: You must specify the ``CidrBlock`` or ``Ipv6CidrBlock`` property.\n')
    port_range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkAclEntry_PortRangePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The range of port numbers for the UDP/TCP protocol. Conditional required if specifying 6 (TCP) or 17 (UDP) for the protocol parameter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_network_acl_entry_props = ec2.CfnNetworkAclEntryProps(\n        network_acl_id="networkAclId",\n        protocol=123,\n        rule_action="ruleAction",\n        rule_number=123,\n\n        # the properties below are optional\n        cidr_block="cidrBlock",\n        egress=False,\n        icmp=ec2.CfnNetworkAclEntry.IcmpProperty(\n            code=123,\n            type=123\n        ),\n        ipv6_cidr_block="ipv6CidrBlock",\n        port_range=ec2.CfnNetworkAclEntry.PortRangeProperty(\n            from=123,\n            to=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['network_acl_id', 'protocol', 'rule_action', 'rule_number', 'cidr_block', 'egress', 'icmp', 'ipv6_cidr_block', 'port_range']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkAclEntryProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkAclProps
class CfnNetworkAclPropsDef(BaseCfnProperty):
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC for the network ACL.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the network ACL.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_network_acl_props = ec2.CfnNetworkAclProps(\n        vpc_id="vpcId",\n\n        # the properties below are optional\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['vpc_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkAclProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAccessScopeAnalysisProps
class CfnNetworkInsightsAccessScopeAnalysisPropsDef(BaseCfnProperty):
    network_insights_access_scope_id: str = pydantic.Field(..., description='The ID of the Network Access Scope.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_network_insights_access_scope_analysis_props = ec2.CfnNetworkInsightsAccessScopeAnalysisProps(\n        network_insights_access_scope_id="networkInsightsAccessScopeId",\n\n        # the properties below are optional\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['network_insights_access_scope_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAccessScopeAnalysisProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAccessScopeProps
class CfnNetworkInsightsAccessScopePropsDef(BaseCfnProperty):
    exclude_paths: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAccessScope_AccessScopePathRequestPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The paths to exclude.\n')
    match_paths: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsAccessScope_AccessScopePathRequestPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The paths to match.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_network_insights_access_scope_props = ec2.CfnNetworkInsightsAccessScopeProps(\n        exclude_paths=[ec2.CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty(\n            destination=ec2.CfnNetworkInsightsAccessScope.PathStatementRequestProperty(\n                packet_header_statement=ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty(\n                    destination_addresses=["destinationAddresses"],\n                    destination_ports=["destinationPorts"],\n                    destination_prefix_lists=["destinationPrefixLists"],\n                    protocols=["protocols"],\n                    source_addresses=["sourceAddresses"],\n                    source_ports=["sourcePorts"],\n                    source_prefix_lists=["sourcePrefixLists"]\n                ),\n                resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(\n                    resources=["resources"],\n                    resource_types=["resourceTypes"]\n                )\n            ),\n            source=ec2.CfnNetworkInsightsAccessScope.PathStatementRequestProperty(\n                packet_header_statement=ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty(\n                    destination_addresses=["destinationAddresses"],\n                    destination_ports=["destinationPorts"],\n                    destination_prefix_lists=["destinationPrefixLists"],\n                    protocols=["protocols"],\n                    source_addresses=["sourceAddresses"],\n                    source_ports=["sourcePorts"],\n                    source_prefix_lists=["sourcePrefixLists"]\n                ),\n                resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(\n                    resources=["resources"],\n                    resource_types=["resourceTypes"]\n                )\n            ),\n            through_resources=[ec2.CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty(\n                resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(\n                    resources=["resources"],\n                    resource_types=["resourceTypes"]\n                )\n            )]\n        )],\n        match_paths=[ec2.CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty(\n            destination=ec2.CfnNetworkInsightsAccessScope.PathStatementRequestProperty(\n                packet_header_statement=ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty(\n                    destination_addresses=["destinationAddresses"],\n                    destination_ports=["destinationPorts"],\n                    destination_prefix_lists=["destinationPrefixLists"],\n                    protocols=["protocols"],\n                    source_addresses=["sourceAddresses"],\n                    source_ports=["sourcePorts"],\n                    source_prefix_lists=["sourcePrefixLists"]\n                ),\n                resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(\n                    resources=["resources"],\n                    resource_types=["resourceTypes"]\n                )\n            ),\n            source=ec2.CfnNetworkInsightsAccessScope.PathStatementRequestProperty(\n                packet_header_statement=ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty(\n                    destination_addresses=["destinationAddresses"],\n                    destination_ports=["destinationPorts"],\n                    destination_prefix_lists=["destinationPrefixLists"],\n                    protocols=["protocols"],\n                    source_addresses=["sourceAddresses"],\n                    source_ports=["sourcePorts"],\n                    source_prefix_lists=["sourcePrefixLists"]\n                ),\n                resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(\n                    resources=["resources"],\n                    resource_types=["resourceTypes"]\n                )\n            ),\n            through_resources=[ec2.CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty(\n                resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(\n                    resources=["resources"],\n                    resource_types=["resourceTypes"]\n                )\n            )]\n        )],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['exclude_paths', 'match_paths', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAccessScopeProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsAnalysisProps
class CfnNetworkInsightsAnalysisPropsDef(BaseCfnProperty):
    network_insights_path_id: str = pydantic.Field(..., description='The ID of the path.\n')
    additional_accounts: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The member accounts that contain resources that the path can traverse.\n')
    filter_in_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Amazon Resource Names (ARN) of the resources that the path must traverse.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to apply.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_network_insights_analysis_props = ec2.CfnNetworkInsightsAnalysisProps(\n        network_insights_path_id="networkInsightsPathId",\n\n        # the properties below are optional\n        additional_accounts=["additionalAccounts"],\n        filter_in_arns=["filterInArns"],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['network_insights_path_id', 'additional_accounts', 'filter_in_arns', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsAnalysisProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInsightsPathProps
class CfnNetworkInsightsPathPropsDef(BaseCfnProperty):
    protocol: str = pydantic.Field(..., description='The protocol.\n')
    source: str = pydantic.Field(..., description='The ID or ARN of the source. If the resource is in another account, you must specify an ARN.\n')
    destination: typing.Optional[str] = pydantic.Field(None, description='The ID or ARN of the destination. If the resource is in another account, you must specify an ARN.\n')
    destination_ip: typing.Optional[str] = pydantic.Field(None, description='The IP address of the destination.\n')
    destination_port: typing.Union[int, float, None] = pydantic.Field(None, description='The destination port.\n')
    filter_at_destination: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsPath_PathFilterPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Scopes the analysis to network paths that match specific filters at the destination. If you specify this parameter, you can't specify the parameter for the destination IP address.\n")
    filter_at_source: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInsightsPath_PathFilterPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description="Scopes the analysis to network paths that match specific filters at the source. If you specify this parameter, you can't specify the parameters for the source IP address or the destination port.\n")
    source_ip: typing.Optional[str] = pydantic.Field(None, description='The IP address of the source.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to add to the path.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_network_insights_path_props = ec2.CfnNetworkInsightsPathProps(\n        protocol="protocol",\n        source="source",\n\n        # the properties below are optional\n        destination="destination",\n        destination_ip="destinationIp",\n        destination_port=123,\n        filter_at_destination=ec2.CfnNetworkInsightsPath.PathFilterProperty(\n            destination_address="destinationAddress",\n            destination_port_range=ec2.CfnNetworkInsightsPath.FilterPortRangeProperty(\n                from_port=123,\n                to_port=123\n            ),\n            source_address="sourceAddress",\n            source_port_range=ec2.CfnNetworkInsightsPath.FilterPortRangeProperty(\n                from_port=123,\n                to_port=123\n            )\n        ),\n        filter_at_source=ec2.CfnNetworkInsightsPath.PathFilterProperty(\n            destination_address="destinationAddress",\n            destination_port_range=ec2.CfnNetworkInsightsPath.FilterPortRangeProperty(\n                from_port=123,\n                to_port=123\n            ),\n            source_address="sourceAddress",\n            source_port_range=ec2.CfnNetworkInsightsPath.FilterPortRangeProperty(\n                from_port=123,\n                to_port=123\n            )\n        ),\n        source_ip="sourceIp",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['protocol', 'source', 'destination', 'destination_ip', 'destination_port', 'filter_at_destination', 'filter_at_source', 'source_ip', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInsightsPathProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInterfaceAttachmentProps
class CfnNetworkInterfaceAttachmentPropsDef(BaseCfnProperty):
    device_index: str = pydantic.Field(..., description="The network interface's position in the attachment order. For example, the first attached network interface has a ``DeviceIndex`` of 0.\n")
    instance_id: str = pydantic.Field(..., description='The ID of the instance to which you will attach the ENI.\n')
    network_interface_id: str = pydantic.Field(..., description='The ID of the ENI that you want to attach.\n')
    delete_on_termination: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Whether to delete the network interface when the instance terminates. By default, this value is set to ``true`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-network-interface-attachment.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_network_interface_attachment_props = ec2.CfnNetworkInterfaceAttachmentProps(\n        device_index="deviceIndex",\n        instance_id="instanceId",\n        network_interface_id="networkInterfaceId",\n\n        # the properties below are optional\n        delete_on_termination=False\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['device_index', 'instance_id', 'network_interface_id', 'delete_on_termination']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInterfaceAttachmentProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInterfacePermissionProps
class CfnNetworkInterfacePermissionPropsDef(BaseCfnProperty):
    aws_account_id: str = pydantic.Field(..., description='The AWS account ID.\n')
    network_interface_id: str = pydantic.Field(..., description='The ID of the network interface.\n')
    permission: str = pydantic.Field(..., description='The type of permission to grant: ``INSTANCE-ATTACH`` or ``EIP-ASSOCIATE`` .\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_network_interface_permission_props = ec2.CfnNetworkInterfacePermissionProps(\n        aws_account_id="awsAccountId",\n        network_interface_id="networkInterfaceId",\n        permission="permission"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['aws_account_id', 'network_interface_id', 'permission']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInterfacePermissionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkInterfaceProps
class CfnNetworkInterfacePropsDef(BaseCfnProperty):
    subnet_id: str = pydantic.Field(..., description='The ID of the subnet to associate with the network interface.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the network interface.\n')
    group_set: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The security group IDs associated with this network interface.\n')
    interface_type: typing.Optional[str] = pydantic.Field(None, description='The type of network interface. The default is ``interface`` . The supported values are ``efa`` and ``trunk`` .\n')
    ipv6_address_count: typing.Union[int, float, None] = pydantic.Field(None, description="The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. To specify specific IPv6 addresses, use the ``Ipv6Addresses`` property and don't specify this property.\n")
    ipv6_addresses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInterface_InstanceIpv6AddressPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description="One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet to associate with the network interface. If you're specifying a number of IPv6 addresses, use the ``Ipv6AddressCount`` property and don't specify this property.\n")
    private_ip_address: typing.Optional[str] = pydantic.Field(None, description='Assigns a single private IP address to the network interface, which is used as the primary private IP address. If you want to specify multiple private IP address, use the ``PrivateIpAddresses`` property.\n')
    private_ip_addresses: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnNetworkInterface_PrivateIpAddressSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='Assigns private IP addresses to the network interface. You can specify a primary private IP address by setting the value of the ``Primary`` property to ``true`` in the ``PrivateIpAddressSpecification`` property. If you want EC2 to automatically assign private IP addresses, use the ``SecondaryPrivateIpAddressCount`` property and do not specify this property.\n')
    secondary_private_ip_address_count: typing.Union[int, float, None] = pydantic.Field(None, description="The number of secondary private IPv4 addresses to assign to a network interface. When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using ``privateIpAddresses`` . You can't specify a count of private IPv4 addresses if you've specified one of the following: specific private IPv4 addresses, specific IPv4 prefixes, or a count of IPv4 prefixes.\n")
    source_dest_check: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives. If the value is ``true`` , source/destination checks are enabled; otherwise, they are disabled. The default value is ``true`` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='An arbitrary set of tags (key-value pairs) for this network interface.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_network_interface_props = ec2.CfnNetworkInterfaceProps(\n        subnet_id="subnetId",\n\n        # the properties below are optional\n        description="description",\n        group_set=["groupSet"],\n        interface_type="interfaceType",\n        ipv6_address_count=123,\n        ipv6_addresses=[ec2.CfnNetworkInterface.InstanceIpv6AddressProperty(\n            ipv6_address="ipv6Address"\n        )],\n        private_ip_address="privateIpAddress",\n        private_ip_addresses=[ec2.CfnNetworkInterface.PrivateIpAddressSpecificationProperty(\n            primary=False,\n            private_ip_address="privateIpAddress"\n        )],\n        secondary_private_ip_address_count=123,\n        source_dest_check=False,\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['subnet_id', 'description', 'group_set', 'interface_type', 'ipv6_address_count', 'ipv6_addresses', 'private_ip_address', 'private_ip_addresses', 'secondary_private_ip_address_count', 'source_dest_check', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkInterfaceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnNetworkPerformanceMetricSubscriptionProps
class CfnNetworkPerformanceMetricSubscriptionPropsDef(BaseCfnProperty):
    destination: str = pydantic.Field(..., description="The Region or Availability Zone that's the target for the subscription. For example, ``eu-west-1`` .\n")
    metric: str = pydantic.Field(..., description='The metric used for the subscription.\n')
    source: str = pydantic.Field(..., description="The Region or Availability Zone that's the source for the subscription. For example, ``us-east-1`` .\n")
    statistic: str = pydantic.Field(..., description='The statistic used for the subscription.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_network_performance_metric_subscription_props = ec2.CfnNetworkPerformanceMetricSubscriptionProps(\n        destination="destination",\n        metric="metric",\n        source="source",\n        statistic="statistic"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination', 'metric', 'source', 'statistic']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnNetworkPerformanceMetricSubscriptionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnPlacementGroupProps
class CfnPlacementGroupPropsDef(BaseCfnProperty):
    partition_count: typing.Union[int, float, None] = pydantic.Field(None, description='The number of partitions. Valid only when *Strategy* is set to ``partition`` .\n')
    spread_level: typing.Optional[str] = pydantic.Field(None, description='Determines how placement groups spread instances. - Host – You can use ``host`` only with Outpost placement groups. - Rack – No usage restrictions.\n')
    strategy: typing.Optional[str] = pydantic.Field(None, description='The placement strategy.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to apply to the new placement group.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_placement_group_props = ec2.CfnPlacementGroupProps(\n        partition_count=123,\n        spread_level="spreadLevel",\n        strategy="strategy",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['partition_count', 'spread_level', 'strategy', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnPlacementGroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnPrefixListProps
class CfnPrefixListPropsDef(BaseCfnProperty):
    address_family: str = pydantic.Field(..., description='The IP address type. Valid Values: ``IPv4`` | ``IPv6``\n')
    max_entries: typing.Union[int, float] = pydantic.Field(..., description='The maximum number of entries for the prefix list.\n')
    prefix_list_name: str = pydantic.Field(..., description='A name for the prefix list. Constraints: Up to 255 characters in length. The name cannot start with ``com.amazonaws`` .\n')
    entries: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnPrefixList_EntryPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='One or more entries for the prefix list.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the prefix list.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_prefix_list_props = ec2.CfnPrefixListProps(\n        address_family="addressFamily",\n        max_entries=123,\n        prefix_list_name="prefixListName",\n\n        # the properties below are optional\n        entries=[ec2.CfnPrefixList.EntryProperty(\n            cidr="cidr",\n\n            # the properties below are optional\n            description="description"\n        )],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['address_family', 'max_entries', 'prefix_list_name', 'entries', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnPrefixListProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnRouteProps
class CfnRoutePropsDef(BaseCfnProperty):
    route_table_id: str = pydantic.Field(..., description='The ID of the route table for the route.\n')
    carrier_gateway_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the carrier gateway. You can only use this option when the VPC contains a subnet which is associated with a Wavelength Zone.\n')
    destination_cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv4 CIDR address block used for the destination match. Routing decisions are based on the most specific match. We modify the specified CIDR block to its canonical form; for example, if you specify ``100.68.0.18/18`` , we modify it to ``100.68.0.0/18`` .\n')
    destination_ipv6_cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv6 CIDR block used for the destination match. Routing decisions are based on the most specific match.\n')
    egress_only_internet_gateway_id: typing.Optional[str] = pydantic.Field(None, description='[IPv6 traffic only] The ID of an egress-only internet gateway.\n')
    gateway_id: typing.Optional[str] = pydantic.Field(None, description='The ID of an internet gateway or virtual private gateway attached to your VPC.\n')
    instance_id: typing.Optional[str] = pydantic.Field(None, description='The ID of a NAT instance in your VPC. The operation fails if you specify an instance ID unless exactly one network interface is attached.\n')
    local_gateway_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the local gateway.\n')
    nat_gateway_id: typing.Optional[str] = pydantic.Field(None, description='[IPv4 traffic only] The ID of a NAT gateway.\n')
    network_interface_id: typing.Optional[str] = pydantic.Field(None, description='The ID of a network interface.\n')
    transit_gateway_id: typing.Optional[str] = pydantic.Field(None, description='The ID of a transit gateway.\n')
    vpc_endpoint_id: typing.Optional[str] = pydantic.Field(None, description='The ID of a VPC endpoint. Supported for Gateway Load Balancer endpoints only.\n')
    vpc_peering_connection_id: typing.Optional[str] = pydantic.Field(None, description='The ID of a VPC peering connection.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_route_props = ec2.CfnRouteProps(\n        route_table_id="routeTableId",\n\n        # the properties below are optional\n        carrier_gateway_id="carrierGatewayId",\n        destination_cidr_block="destinationCidrBlock",\n        destination_ipv6_cidr_block="destinationIpv6CidrBlock",\n        egress_only_internet_gateway_id="egressOnlyInternetGatewayId",\n        gateway_id="gatewayId",\n        instance_id="instanceId",\n        local_gateway_id="localGatewayId",\n        nat_gateway_id="natGatewayId",\n        network_interface_id="networkInterfaceId",\n        transit_gateway_id="transitGatewayId",\n        vpc_endpoint_id="vpcEndpointId",\n        vpc_peering_connection_id="vpcPeeringConnectionId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['route_table_id', 'carrier_gateway_id', 'destination_cidr_block', 'destination_ipv6_cidr_block', 'egress_only_internet_gateway_id', 'gateway_id', 'instance_id', 'local_gateway_id', 'nat_gateway_id', 'network_interface_id', 'transit_gateway_id', 'vpc_endpoint_id', 'vpc_peering_connection_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnRouteProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnRouteTableProps
class CfnRouteTablePropsDef(BaseCfnProperty):
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Any tags assigned to the route table.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_route_table_props = ec2.CfnRouteTableProps(\n        vpc_id="vpcId",\n\n        # the properties below are optional\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['vpc_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnRouteTableProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSecurityGroupEgressProps
class CfnSecurityGroupEgressPropsDef(BaseCfnProperty):
    group_id: str = pydantic.Field(..., description='The ID of the security group. You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.\n')
    ip_protocol: str = pydantic.Field(..., description='The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ). Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.\n')
    cidr_ip: typing.Optional[str] = pydantic.Field(None, description='The IPv4 address range, in CIDR format. You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ). For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .\n')
    cidr_ipv6: typing.Optional[str] = pydantic.Field(None, description='The IPv6 address range, in CIDR format. You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ). For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of an egress (outbound) security group rule. Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*\n')
    destination_prefix_list_id: typing.Optional[str] = pydantic.Field(None, description='The prefix list IDs for an AWS service. This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group. You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).\n')
    destination_security_group_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the security group. You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).\n')
    from_port: typing.Union[int, float, None] = pydantic.Field(None, description='If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the type number. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.\n')
    to_port: typing.Union[int, float, None] = pydantic.Field(None, description='If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the code. A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all ICMP/ICMPv6 codes.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_security_group_egress_props = ec2.CfnSecurityGroupEgressProps(\n        group_id="groupId",\n        ip_protocol="ipProtocol",\n\n        # the properties below are optional\n        cidr_ip="cidrIp",\n        cidr_ipv6="cidrIpv6",\n        description="description",\n        destination_prefix_list_id="destinationPrefixListId",\n        destination_security_group_id="destinationSecurityGroupId",\n        from_port=123,\n        to_port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['group_id', 'ip_protocol', 'cidr_ip', 'cidr_ipv6', 'description', 'destination_prefix_list_id', 'destination_security_group_id', 'from_port', 'to_port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSecurityGroupEgressProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSecurityGroupIngressProps
class CfnSecurityGroupIngressPropsDef(BaseCfnProperty):
    ip_protocol: str = pydantic.Field(..., description='The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ). Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.\n')
    cidr_ip: typing.Optional[str] = pydantic.Field(None, description='The IPv4 address range, in CIDR format. You must specify a source security group ( ``SourcePrefixListId`` or ``SourceSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ). For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .\n')
    cidr_ipv6: typing.Optional[str] = pydantic.Field(None, description='The IPv6 address range, in CIDR format. You must specify a source security group ( ``SourcePrefixListId`` or ``SourceSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ). For examples of rules that you can add to security groups for specific access scenarios, see `Security group rules for different use cases <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html>`_ in the *Amazon EC2 User Guide* .\n')
    description: typing.Optional[str] = pydantic.Field(None, description='Updates the description of an ingress (inbound) security group rule. You can replace an existing description, or add a description to a rule that did not have one previously. Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*\n')
    from_port: typing.Union[int, float, None] = pydantic.Field(None, description='The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of ``-1`` indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes. Use this for ICMP and any protocol that uses ports.\n')
    group_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the security group.\n')
    group_name: typing.Optional[str] = pydantic.Field(None, description='The name of the security group. Constraints: Up to 255 characters in length. Cannot start with ``sg-`` . Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*\n')
    source_prefix_list_id: typing.Optional[str] = pydantic.Field(None, description='The ID of a prefix list.\n')
    source_security_group_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the security group. You must specify either the security group ID or the security group name. For security groups in a nondefault VPC, you must specify the security group ID.\n')
    source_security_group_name: typing.Optional[str] = pydantic.Field(None, description="[Default VPC] The name of the source security group. You must specify either the security group ID or the security group name. You can't specify the group name in combination with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access. For security groups in a nondefault VPC, you must specify the group ID.\n")
    source_security_group_owner_id: typing.Optional[str] = pydantic.Field(None, description="[nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account. You can't specify this property with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access. If you specify ``SourceSecurityGroupName`` or ``SourceSecurityGroupId`` and that security group is owned by a different account than the account creating the stack, you must specify ``SourceSecurityGroupOwnerId`` ; otherwise, this property is optional.\n")
    to_port: typing.Union[int, float, None] = pydantic.Field(None, description='The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of ``-1`` indicates all ICMP/ICMPv6 codes for the specified ICMP type. If you specify all ICMP/ICMPv6 types, you must specify all codes. Use this for ICMP and any protocol that uses ports.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_security_group_ingress_props = ec2.CfnSecurityGroupIngressProps(\n        ip_protocol="ipProtocol",\n\n        # the properties below are optional\n        cidr_ip="cidrIp",\n        cidr_ipv6="cidrIpv6",\n        description="description",\n        from_port=123,\n        group_id="groupId",\n        group_name="groupName",\n        source_prefix_list_id="sourcePrefixListId",\n        source_security_group_id="sourceSecurityGroupId",\n        source_security_group_name="sourceSecurityGroupName",\n        source_security_group_owner_id="sourceSecurityGroupOwnerId",\n        to_port=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ip_protocol', 'cidr_ip', 'cidr_ipv6', 'description', 'from_port', 'group_id', 'group_name', 'source_prefix_list_id', 'source_security_group_id', 'source_security_group_name', 'source_security_group_owner_id', 'to_port']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSecurityGroupIngressProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSecurityGroupProps
class CfnSecurityGroupPropsDef(BaseCfnProperty):
    group_description: str = pydantic.Field(..., description='A description for the security group. Constraints: Up to 255 characters in length Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*\n')
    group_name: typing.Optional[str] = pydantic.Field(None, description='The name of the security group. Constraints: Up to 255 characters in length. Cannot start with ``sg-`` . Valid characters: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*\n')
    security_group_egress: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSecurityGroup_EgressPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The outbound rules associated with the security group. There is a short interruption during which you cannot connect to the security group.\n')
    security_group_ingress: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSecurityGroup_IngressPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The inbound rules associated with the security group. There is a short interruption during which you cannot connect to the security group.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Any tags assigned to the security group.\n')
    vpc_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the VPC for the security group.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_security_group_props = ec2.CfnSecurityGroupProps(\n        group_description="groupDescription",\n\n        # the properties below are optional\n        group_name="groupName",\n        security_group_egress=[ec2.CfnSecurityGroup.EgressProperty(\n            ip_protocol="ipProtocol",\n\n            # the properties below are optional\n            cidr_ip="cidrIp",\n            cidr_ipv6="cidrIpv6",\n            description="description",\n            destination_prefix_list_id="destinationPrefixListId",\n            destination_security_group_id="destinationSecurityGroupId",\n            from_port=123,\n            to_port=123\n        )],\n        security_group_ingress=[ec2.CfnSecurityGroup.IngressProperty(\n            ip_protocol="ipProtocol",\n\n            # the properties below are optional\n            cidr_ip="cidrIp",\n            cidr_ipv6="cidrIpv6",\n            description="description",\n            from_port=123,\n            source_prefix_list_id="sourcePrefixListId",\n            source_security_group_id="sourceSecurityGroupId",\n            source_security_group_name="sourceSecurityGroupName",\n            source_security_group_owner_id="sourceSecurityGroupOwnerId",\n            to_port=123\n        )],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        vpc_id="vpcId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['group_description', 'group_name', 'security_group_egress', 'security_group_ingress', 'tags', 'vpc_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSecurityGroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSpotFleetProps
class CfnSpotFleetPropsDef(BaseCfnProperty):
    spot_fleet_request_config_data: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnSpotFleet_SpotFleetRequestConfigDataPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='Describes the configuration of a Spot Fleet request.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_spot_fleet_props = ec2.CfnSpotFleetProps(\n        spot_fleet_request_config_data=ec2.CfnSpotFleet.SpotFleetRequestConfigDataProperty(\n            iam_fleet_role="iamFleetRole",\n            target_capacity=123,\n\n            # the properties below are optional\n            allocation_strategy="allocationStrategy",\n            context="context",\n            excess_capacity_termination_policy="excessCapacityTerminationPolicy",\n            instance_interruption_behavior="instanceInterruptionBehavior",\n            instance_pools_to_use_count=123,\n            launch_specifications=[ec2.CfnSpotFleet.SpotFleetLaunchSpecificationProperty(\n                image_id="imageId",\n\n                # the properties below are optional\n                block_device_mappings=[ec2.CfnSpotFleet.BlockDeviceMappingProperty(\n                    device_name="deviceName",\n\n                    # the properties below are optional\n                    ebs=ec2.CfnSpotFleet.EbsBlockDeviceProperty(\n                        delete_on_termination=False,\n                        encrypted=False,\n                        iops=123,\n                        snapshot_id="snapshotId",\n                        volume_size=123,\n                        volume_type="volumeType"\n                    ),\n                    no_device="noDevice",\n                    virtual_name="virtualName"\n                )],\n                ebs_optimized=False,\n                iam_instance_profile=ec2.CfnSpotFleet.IamInstanceProfileSpecificationProperty(\n                    arn="arn"\n                ),\n                instance_requirements=ec2.CfnSpotFleet.InstanceRequirementsRequestProperty(\n                    accelerator_count=ec2.CfnSpotFleet.AcceleratorCountRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    accelerator_manufacturers=["acceleratorManufacturers"],\n                    accelerator_names=["acceleratorNames"],\n                    accelerator_total_memory_mi_b=ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    accelerator_types=["acceleratorTypes"],\n                    allowed_instance_types=["allowedInstanceTypes"],\n                    bare_metal="bareMetal",\n                    baseline_ebs_bandwidth_mbps=ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    burstable_performance="burstablePerformance",\n                    cpu_manufacturers=["cpuManufacturers"],\n                    excluded_instance_types=["excludedInstanceTypes"],\n                    instance_generations=["instanceGenerations"],\n                    local_storage="localStorage",\n                    local_storage_types=["localStorageTypes"],\n                    memory_gi_bPer_vCpu=ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    memory_mi_b=ec2.CfnSpotFleet.MemoryMiBRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    network_bandwidth_gbps=ec2.CfnSpotFleet.NetworkBandwidthGbpsRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    network_interface_count=ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    on_demand_max_price_percentage_over_lowest_price=123,\n                    require_hibernate_support=False,\n                    spot_max_price_percentage_over_lowest_price=123,\n                    total_local_storage_gb=ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty(\n                        max=123,\n                        min=123\n                    ),\n                    v_cpu_count=ec2.CfnSpotFleet.VCpuCountRangeRequestProperty(\n                        max=123,\n                        min=123\n                    )\n                ),\n                instance_type="instanceType",\n                kernel_id="kernelId",\n                key_name="keyName",\n                monitoring=ec2.CfnSpotFleet.SpotFleetMonitoringProperty(\n                    enabled=False\n                ),\n                network_interfaces=[ec2.CfnSpotFleet.InstanceNetworkInterfaceSpecificationProperty(\n                    associate_public_ip_address=False,\n                    delete_on_termination=False,\n                    description="description",\n                    device_index=123,\n                    groups=["groups"],\n                    ipv6_address_count=123,\n                    ipv6_addresses=[ec2.CfnSpotFleet.InstanceIpv6AddressProperty(\n                        ipv6_address="ipv6Address"\n                    )],\n                    network_interface_id="networkInterfaceId",\n                    private_ip_addresses=[ec2.CfnSpotFleet.PrivateIpAddressSpecificationProperty(\n                        private_ip_address="privateIpAddress",\n\n                        # the properties below are optional\n                        primary=False\n                    )],\n                    secondary_private_ip_address_count=123,\n                    subnet_id="subnetId"\n                )],\n                placement=ec2.CfnSpotFleet.SpotPlacementProperty(\n                    availability_zone="availabilityZone",\n                    group_name="groupName",\n                    tenancy="tenancy"\n                ),\n                ramdisk_id="ramdiskId",\n                security_groups=[ec2.CfnSpotFleet.GroupIdentifierProperty(\n                    group_id="groupId"\n                )],\n                spot_price="spotPrice",\n                subnet_id="subnetId",\n                tag_specifications=[ec2.CfnSpotFleet.SpotFleetTagSpecificationProperty(\n                    resource_type="resourceType",\n                    tags=[CfnTag(\n                        key="key",\n                        value="value"\n                    )]\n                )],\n                user_data="userData",\n                weighted_capacity=123\n            )],\n            launch_template_configs=[ec2.CfnSpotFleet.LaunchTemplateConfigProperty(\n                launch_template_specification=ec2.CfnSpotFleet.FleetLaunchTemplateSpecificationProperty(\n                    version="version",\n\n                    # the properties below are optional\n                    launch_template_id="launchTemplateId",\n                    launch_template_name="launchTemplateName"\n                ),\n                overrides=[ec2.CfnSpotFleet.LaunchTemplateOverridesProperty(\n                    availability_zone="availabilityZone",\n                    instance_requirements=ec2.CfnSpotFleet.InstanceRequirementsRequestProperty(\n                        accelerator_count=ec2.CfnSpotFleet.AcceleratorCountRequestProperty(\n                            max=123,\n                            min=123\n                        ),\n                        accelerator_manufacturers=["acceleratorManufacturers"],\n                        accelerator_names=["acceleratorNames"],\n                        accelerator_total_memory_mi_b=ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty(\n                            max=123,\n                            min=123\n                        ),\n                        accelerator_types=["acceleratorTypes"],\n                        allowed_instance_types=["allowedInstanceTypes"],\n                        bare_metal="bareMetal",\n                        baseline_ebs_bandwidth_mbps=ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty(\n                            max=123,\n                            min=123\n                        ),\n                        burstable_performance="burstablePerformance",\n                        cpu_manufacturers=["cpuManufacturers"],\n                        excluded_instance_types=["excludedInstanceTypes"],\n                        instance_generations=["instanceGenerations"],\n                        local_storage="localStorage",\n                        local_storage_types=["localStorageTypes"],\n                        memory_gi_bPer_vCpu=ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty(\n                            max=123,\n                            min=123\n                        ),\n                        memory_mi_b=ec2.CfnSpotFleet.MemoryMiBRequestProperty(\n                            max=123,\n                            min=123\n                        ),\n                        network_bandwidth_gbps=ec2.CfnSpotFleet.NetworkBandwidthGbpsRequestProperty(\n                            max=123,\n                            min=123\n                        ),\n                        network_interface_count=ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty(\n                            max=123,\n                            min=123\n                        ),\n                        on_demand_max_price_percentage_over_lowest_price=123,\n                        require_hibernate_support=False,\n                        spot_max_price_percentage_over_lowest_price=123,\n                        total_local_storage_gb=ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty(\n                            max=123,\n                            min=123\n                        ),\n                        v_cpu_count=ec2.CfnSpotFleet.VCpuCountRangeRequestProperty(\n                            max=123,\n                            min=123\n                        )\n                    ),\n                    instance_type="instanceType",\n                    priority=123,\n                    spot_price="spotPrice",\n                    subnet_id="subnetId",\n                    weighted_capacity=123\n                )]\n            )],\n            load_balancers_config=ec2.CfnSpotFleet.LoadBalancersConfigProperty(\n                classic_load_balancers_config=ec2.CfnSpotFleet.ClassicLoadBalancersConfigProperty(\n                    classic_load_balancers=[ec2.CfnSpotFleet.ClassicLoadBalancerProperty(\n                        name="name"\n                    )]\n                ),\n                target_groups_config=ec2.CfnSpotFleet.TargetGroupsConfigProperty(\n                    target_groups=[ec2.CfnSpotFleet.TargetGroupProperty(\n                        arn="arn"\n                    )]\n                )\n            ),\n            on_demand_allocation_strategy="onDemandAllocationStrategy",\n            on_demand_max_total_price="onDemandMaxTotalPrice",\n            on_demand_target_capacity=123,\n            replace_unhealthy_instances=False,\n            spot_maintenance_strategies=ec2.CfnSpotFleet.SpotMaintenanceStrategiesProperty(\n                capacity_rebalance=ec2.CfnSpotFleet.SpotCapacityRebalanceProperty(\n                    replacement_strategy="replacementStrategy",\n                    termination_delay=123\n                )\n            ),\n            spot_max_total_price="spotMaxTotalPrice",\n            spot_price="spotPrice",\n            tag_specifications=[ec2.CfnSpotFleet.SpotFleetTagSpecificationProperty(\n                resource_type="resourceType",\n                tags=[CfnTag(\n                    key="key",\n                    value="value"\n                )]\n            )],\n            target_capacity_unit_type="targetCapacityUnitType",\n            terminate_instances_with_expiration=False,\n            type="type",\n            valid_from="validFrom",\n            valid_until="validUntil"\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['spot_fleet_request_config_data']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSpotFleetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSubnetCidrBlockProps
class CfnSubnetCidrBlockPropsDef(BaseCfnProperty):
    ipv6_cidr_block: str = pydantic.Field(..., description='The IPv6 network range for the subnet, in CIDR notation. The subnet size must use a /64 prefix length. This parameter is required for an IPv6 only subnet.\n')
    subnet_id: str = pydantic.Field(..., description='The ID of the subnet.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_subnet_cidr_block_props = ec2.CfnSubnetCidrBlockProps(\n        ipv6_cidr_block="ipv6CidrBlock",\n        subnet_id="subnetId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['ipv6_cidr_block', 'subnet_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSubnetCidrBlockProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSubnetNetworkAclAssociationProps
class CfnSubnetNetworkAclAssociationPropsDef(BaseCfnProperty):
    network_acl_id: str = pydantic.Field(..., description='The ID of the network ACL.\n')
    subnet_id: str = pydantic.Field(..., description='The ID of the subnet.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet-network-acl-assoc.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_subnet_network_acl_association_props = ec2.CfnSubnetNetworkAclAssociationProps(\n        network_acl_id="networkAclId",\n        subnet_id="subnetId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['network_acl_id', 'subnet_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSubnetNetworkAclAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSubnetProps
class CfnSubnetPropsDef(BaseCfnProperty):
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC the subnet is in. If you update this property, you must also update the ``CidrBlock`` property.\n')
    assign_ipv6_address_on_creation: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether a network interface created in this subnet receives an IPv6 address. The default value is ``false`` . If you specify ``AssignIpv6AddressOnCreation`` , you must also specify ``Ipv6CidrBlock`` .\n')
    availability_zone: typing.Optional[str] = pydantic.Field(None, description='The Availability Zone of the subnet. If you update this property, you must also update the ``CidrBlock`` property.\n')
    availability_zone_id: typing.Optional[str] = pydantic.Field(None, description='The AZ ID of the subnet.\n')
    cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv4 CIDR block assigned to the subnet. If you update this property, we create a new subnet, and then delete the existing one.\n')
    enable_dns64: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether DNS queries made to the Amazon-provided DNS Resolver in this subnet should return synthetic IPv6 addresses for IPv4-only destinations. For more information, see `DNS64 and NAT64 <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-nat64-dns64>`_ in the *Amazon Virtual Private Cloud User Guide* .\n')
    ipv6_cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv6 CIDR block. If you specify ``AssignIpv6AddressOnCreation`` , you must also specify ``Ipv6CidrBlock`` .\n')
    ipv6_native: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether this is an IPv6 only subnet. For more information, see `Subnet basics <https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html#subnet-basics>`_ in the *Amazon Virtual Private Cloud User Guide* .\n')
    map_public_ip_on_launch: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether instances launched in this subnet receive a public IPv4 address. The default value is ``false`` .\n')
    outpost_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the Outpost.\n')
    private_dns_name_options_on_launch: typing.Any = pydantic.Field(None, description='The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* . Available options: - EnableResourceNameDnsAAAARecord (true | false) - EnableResourceNameDnsARecord (true | false) - HostnameType (ip-name | resource-name)\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Any tags assigned to the subnet.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # private_dns_name_options_on_launch: Any\n\n    cfn_subnet_props = ec2.CfnSubnetProps(\n        vpc_id="vpcId",\n\n        # the properties below are optional\n        assign_ipv6_address_on_creation=False,\n        availability_zone="availabilityZone",\n        availability_zone_id="availabilityZoneId",\n        cidr_block="cidrBlock",\n        enable_dns64=False,\n        ipv6_cidr_block="ipv6CidrBlock",\n        ipv6_native=False,\n        map_public_ip_on_launch=False,\n        outpost_arn="outpostArn",\n        private_dns_name_options_on_launch=private_dns_name_options_on_launch,\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['vpc_id', 'assign_ipv6_address_on_creation', 'availability_zone', 'availability_zone_id', 'cidr_block', 'enable_dns64', 'ipv6_cidr_block', 'ipv6_native', 'map_public_ip_on_launch', 'outpost_arn', 'private_dns_name_options_on_launch', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSubnetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnSubnetRouteTableAssociationProps
class CfnSubnetRouteTableAssociationPropsDef(BaseCfnProperty):
    route_table_id: str = pydantic.Field(..., description='The ID of the route table. The physical ID changes when the route table ID is changed.\n')
    subnet_id: str = pydantic.Field(..., description='The ID of the subnet.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_subnet_route_table_association_props = ec2.CfnSubnetRouteTableAssociationProps(\n        route_table_id="routeTableId",\n        subnet_id="subnetId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['route_table_id', 'subnet_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnSubnetRouteTableAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTrafficMirrorFilterProps
class CfnTrafficMirrorFilterPropsDef(BaseCfnProperty):
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the Traffic Mirror filter.\n')
    network_services: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The network service traffic that is associated with the Traffic Mirror filter. Valid values are ``amazon-dns`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to assign to a Traffic Mirror filter.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_traffic_mirror_filter_props = ec2.CfnTrafficMirrorFilterProps(\n        description="description",\n        network_services=["networkServices"],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'network_services', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTrafficMirrorFilterProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTrafficMirrorFilterRuleProps
class CfnTrafficMirrorFilterRulePropsDef(BaseCfnProperty):
    destination_cidr_block: str = pydantic.Field(..., description='The destination CIDR block to assign to the Traffic Mirror rule.\n')
    rule_action: str = pydantic.Field(..., description='The action to take on the filtered traffic.\n')
    rule_number: typing.Union[int, float] = pydantic.Field(..., description='The number of the Traffic Mirror rule. This number must be unique for each Traffic Mirror rule in a given direction. The rules are processed in ascending order by rule number.\n')
    source_cidr_block: str = pydantic.Field(..., description='The source CIDR block to assign to the Traffic Mirror rule.\n')
    traffic_direction: str = pydantic.Field(..., description='The type of traffic.\n')
    traffic_mirror_filter_id: str = pydantic.Field(..., description='The ID of the filter that this rule is associated with.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the Traffic Mirror rule.\n')
    destination_port_range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnTrafficMirrorFilterRule_TrafficMirrorPortRangePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The destination port range.\n')
    protocol: typing.Union[int, float, None] = pydantic.Field(None, description='The protocol, for example UDP, to assign to the Traffic Mirror rule. For information about the protocol value, see `Protocol Numbers <https://docs.aws.amazon.com/https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ on the Internet Assigned Numbers Authority (IANA) website.\n')
    source_port_range: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnTrafficMirrorFilterRule_TrafficMirrorPortRangePropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The source port range.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_traffic_mirror_filter_rule_props = ec2.CfnTrafficMirrorFilterRuleProps(\n        destination_cidr_block="destinationCidrBlock",\n        rule_action="ruleAction",\n        rule_number=123,\n        source_cidr_block="sourceCidrBlock",\n        traffic_direction="trafficDirection",\n        traffic_mirror_filter_id="trafficMirrorFilterId",\n\n        # the properties below are optional\n        description="description",\n        destination_port_range=ec2.CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty(\n            from_port=123,\n            to_port=123\n        ),\n        protocol=123,\n        source_port_range=ec2.CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty(\n            from_port=123,\n            to_port=123\n        )\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_cidr_block', 'rule_action', 'rule_number', 'source_cidr_block', 'traffic_direction', 'traffic_mirror_filter_id', 'description', 'destination_port_range', 'protocol', 'source_port_range']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTrafficMirrorFilterRuleProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTrafficMirrorSessionProps
class CfnTrafficMirrorSessionPropsDef(BaseCfnProperty):
    network_interface_id: str = pydantic.Field(..., description='The ID of the source network interface.\n')
    session_number: typing.Union[int, float] = pydantic.Field(..., description='The session number determines the order in which sessions are evaluated when an interface is used by multiple sessions. The first session with a matching filter is the one that mirrors the packets. Valid values are 1-32766.\n')
    traffic_mirror_filter_id: str = pydantic.Field(..., description='The ID of the Traffic Mirror filter.\n')
    traffic_mirror_target_id: str = pydantic.Field(..., description='The ID of the Traffic Mirror target.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the Traffic Mirror session.\n')
    packet_length: typing.Union[int, float, None] = pydantic.Field(None, description='The number of bytes in each packet to mirror. These are bytes after the VXLAN header. Do not specify this parameter when you want to mirror the entire packet. To mirror a subset of the packet, set this to the length (in bytes) that you want to mirror. For example, if you set this value to 100, then the first 100 bytes that meet the filter criteria are copied to the target. If you do not want to mirror the entire packet, use the ``PacketLength`` parameter to specify the number of bytes in each packet to mirror.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to assign to a Traffic Mirror session.\n')
    virtual_network_id: typing.Union[int, float, None] = pydantic.Field(None, description='The VXLAN ID for the Traffic Mirror session. For more information about the VXLAN protocol, see `RFC 7348 <https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc7348>`_ . If you do not specify a ``VirtualNetworkId`` , an account-wide unique id is chosen at random.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_traffic_mirror_session_props = ec2.CfnTrafficMirrorSessionProps(\n        network_interface_id="networkInterfaceId",\n        session_number=123,\n        traffic_mirror_filter_id="trafficMirrorFilterId",\n        traffic_mirror_target_id="trafficMirrorTargetId",\n\n        # the properties below are optional\n        description="description",\n        packet_length=123,\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        virtual_network_id=123\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['network_interface_id', 'session_number', 'traffic_mirror_filter_id', 'traffic_mirror_target_id', 'description', 'packet_length', 'tags', 'virtual_network_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTrafficMirrorSessionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTrafficMirrorTargetProps
class CfnTrafficMirrorTargetPropsDef(BaseCfnProperty):
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the Traffic Mirror target.\n')
    gateway_load_balancer_endpoint_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the Gateway Load Balancer endpoint.\n')
    network_interface_id: typing.Optional[str] = pydantic.Field(None, description='The network interface ID that is associated with the target.\n')
    network_load_balancer_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the Network Load Balancer that is associated with the target.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to assign to the Traffic Mirror target.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_traffic_mirror_target_props = ec2.CfnTrafficMirrorTargetProps(\n        description="description",\n        gateway_load_balancer_endpoint_id="gatewayLoadBalancerEndpointId",\n        network_interface_id="networkInterfaceId",\n        network_load_balancer_arn="networkLoadBalancerArn",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'gateway_load_balancer_endpoint_id', 'network_interface_id', 'network_load_balancer_arn', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTrafficMirrorTargetProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayAttachmentProps
class CfnTransitGatewayAttachmentPropsDef(BaseCfnProperty):
    subnet_ids: typing.Sequence[str] = pydantic.Field(..., description='The IDs of one or more subnets. You can specify only one subnet per Availability Zone. You must specify at least one subnet, but we recommend that you specify two subnets for better availability. The transit gateway uses one IP address from each specified subnet.\n')
    transit_gateway_id: str = pydantic.Field(..., description='The ID of the transit gateway.\n')
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC.\n')
    options: typing.Any = pydantic.Field(None, description='The VPC attachment options, in JSON or YAML. - ``ApplianceModeSupport`` - Set to ``enable`` or ``disable`` . The default is ``disable`` . - ``DnsSupport`` - Set to ``enable`` or ``disable`` . The default is ``enable`` . - ``Ipv6Support`` - Set to ``enable`` or ``disable`` . The default is ``disable`` .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the attachment.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # options: Any\n\n    cfn_transit_gateway_attachment_props = ec2.CfnTransitGatewayAttachmentProps(\n        subnet_ids=["subnetIds"],\n        transit_gateway_id="transitGatewayId",\n        vpc_id="vpcId",\n\n        # the properties below are optional\n        options=options,\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['subnet_ids', 'transit_gateway_id', 'vpc_id', 'options', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayAttachmentProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayConnectProps
class CfnTransitGatewayConnectPropsDef(BaseCfnProperty):
    options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnTransitGatewayConnect_TransitGatewayConnectOptionsPropertyDef, dict[str, typing.Any]] = pydantic.Field(..., description='The Connect attachment options. - protocol (gre)\n')
    transport_transit_gateway_attachment_id: str = pydantic.Field(..., description='The ID of the attachment from which the Connect attachment was created.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the attachment.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_transit_gateway_connect_props = ec2.CfnTransitGatewayConnectProps(\n        options=ec2.CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty(\n            protocol="protocol"\n        ),\n        transport_transit_gateway_attachment_id="transportTransitGatewayAttachmentId",\n\n        # the properties below are optional\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['options', 'transport_transit_gateway_attachment_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayConnectProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayMulticastDomainAssociationProps
class CfnTransitGatewayMulticastDomainAssociationPropsDef(BaseCfnProperty):
    subnet_id: str = pydantic.Field(..., description='The IDs of the subnets to associate with the transit gateway multicast domain.\n')
    transit_gateway_attachment_id: str = pydantic.Field(..., description='The ID of the transit gateway attachment.\n')
    transit_gateway_multicast_domain_id: str = pydantic.Field(..., description='The ID of the transit gateway multicast domain.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_transit_gateway_multicast_domain_association_props = ec2.CfnTransitGatewayMulticastDomainAssociationProps(\n        subnet_id="subnetId",\n        transit_gateway_attachment_id="transitGatewayAttachmentId",\n        transit_gateway_multicast_domain_id="transitGatewayMulticastDomainId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['subnet_id', 'transit_gateway_attachment_id', 'transit_gateway_multicast_domain_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayMulticastDomainAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayMulticastDomainProps
class CfnTransitGatewayMulticastDomainPropsDef(BaseCfnProperty):
    transit_gateway_id: str = pydantic.Field(..., description='The ID of the transit gateway.\n')
    options: typing.Any = pydantic.Field(None, description='The options for the transit gateway multicast domain. - AutoAcceptSharedAssociations (enable | disable) - Igmpv2Support (enable | disable) - StaticSourcesSupport (enable | disable)\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the transit gateway multicast domain.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # options: Any\n\n    cfn_transit_gateway_multicast_domain_props = ec2.CfnTransitGatewayMulticastDomainProps(\n        transit_gateway_id="transitGatewayId",\n\n        # the properties below are optional\n        options=options,\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['transit_gateway_id', 'options', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayMulticastDomainProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayMulticastGroupMemberProps
class CfnTransitGatewayMulticastGroupMemberPropsDef(BaseCfnProperty):
    group_ip_address: str = pydantic.Field(..., description='The IP address assigned to the transit gateway multicast group.\n')
    network_interface_id: str = pydantic.Field(..., description="The group members' network interface IDs to register with the transit gateway multicast group.\n")
    transit_gateway_multicast_domain_id: str = pydantic.Field(..., description='The ID of the transit gateway multicast domain.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_transit_gateway_multicast_group_member_props = ec2.CfnTransitGatewayMulticastGroupMemberProps(\n        group_ip_address="groupIpAddress",\n        network_interface_id="networkInterfaceId",\n        transit_gateway_multicast_domain_id="transitGatewayMulticastDomainId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['group_ip_address', 'network_interface_id', 'transit_gateway_multicast_domain_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayMulticastGroupMemberProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayMulticastGroupSourceProps
class CfnTransitGatewayMulticastGroupSourcePropsDef(BaseCfnProperty):
    group_ip_address: str = pydantic.Field(..., description='The IP address assigned to the transit gateway multicast group.\n')
    network_interface_id: str = pydantic.Field(..., description="The group sources' network interface IDs to register with the transit gateway multicast group.\n")
    transit_gateway_multicast_domain_id: str = pydantic.Field(..., description='The ID of the transit gateway multicast domain.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_transit_gateway_multicast_group_source_props = ec2.CfnTransitGatewayMulticastGroupSourceProps(\n        group_ip_address="groupIpAddress",\n        network_interface_id="networkInterfaceId",\n        transit_gateway_multicast_domain_id="transitGatewayMulticastDomainId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['group_ip_address', 'network_interface_id', 'transit_gateway_multicast_domain_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayMulticastGroupSourceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayPeeringAttachmentProps
class CfnTransitGatewayPeeringAttachmentPropsDef(BaseCfnProperty):
    peer_account_id: str = pydantic.Field(..., description='The ID of the AWS account that owns the transit gateway.\n')
    peer_region: str = pydantic.Field(..., description='The Region of the transit gateway.\n')
    peer_transit_gateway_id: str = pydantic.Field(..., description='The ID of the transit gateway.\n')
    transit_gateway_id: str = pydantic.Field(..., description='The ID of the transit gateway peering attachment.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the transit gateway peering attachment.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_transit_gateway_peering_attachment_props = ec2.CfnTransitGatewayPeeringAttachmentProps(\n        peer_account_id="peerAccountId",\n        peer_region="peerRegion",\n        peer_transit_gateway_id="peerTransitGatewayId",\n        transit_gateway_id="transitGatewayId",\n\n        # the properties below are optional\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['peer_account_id', 'peer_region', 'peer_transit_gateway_id', 'transit_gateway_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayPeeringAttachmentProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayProps
class CfnTransitGatewayPropsDef(BaseCfnProperty):
    amazon_side_asn: typing.Union[int, float, None] = pydantic.Field(None, description='A private Autonomous System Number (ASN) for the Amazon side of a BGP session. The range is 64512 to 65534 for 16-bit ASNs. The default is 64512.\n')
    association_default_route_table_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the default association route table.\n')
    auto_accept_shared_attachments: typing.Optional[str] = pydantic.Field(None, description='Enable or disable automatic acceptance of attachment requests. Disabled by default.\n')
    default_route_table_association: typing.Optional[str] = pydantic.Field(None, description='Enable or disable automatic association with the default association route table. Enabled by default.\n')
    default_route_table_propagation: typing.Optional[str] = pydantic.Field(None, description='Enable or disable automatic propagation of routes to the default propagation route table. Enabled by default.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='The description of the transit gateway.\n')
    dns_support: typing.Optional[str] = pydantic.Field(None, description='Enable or disable DNS support. Enabled by default.\n')
    multicast_support: typing.Optional[str] = pydantic.Field(None, description='Indicates whether multicast is enabled on the transit gateway.\n')
    propagation_default_route_table_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the default propagation route table.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the transit gateway.\n')
    transit_gateway_cidr_blocks: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The transit gateway CIDR blocks.\n')
    vpn_ecmp_support: typing.Optional[str] = pydantic.Field(None, description='Enable or disable Equal Cost Multipath Protocol support. Enabled by default.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_transit_gateway_props = ec2.CfnTransitGatewayProps(\n        amazon_side_asn=123,\n        association_default_route_table_id="associationDefaultRouteTableId",\n        auto_accept_shared_attachments="autoAcceptSharedAttachments",\n        default_route_table_association="defaultRouteTableAssociation",\n        default_route_table_propagation="defaultRouteTablePropagation",\n        description="description",\n        dns_support="dnsSupport",\n        multicast_support="multicastSupport",\n        propagation_default_route_table_id="propagationDefaultRouteTableId",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        transit_gateway_cidr_blocks=["transitGatewayCidrBlocks"],\n        vpn_ecmp_support="vpnEcmpSupport"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['amazon_side_asn', 'association_default_route_table_id', 'auto_accept_shared_attachments', 'default_route_table_association', 'default_route_table_propagation', 'description', 'dns_support', 'multicast_support', 'propagation_default_route_table_id', 'tags', 'transit_gateway_cidr_blocks', 'vpn_ecmp_support']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayRouteProps
class CfnTransitGatewayRoutePropsDef(BaseCfnProperty):
    transit_gateway_route_table_id: str = pydantic.Field(..., description='The ID of the transit gateway route table.\n')
    blackhole: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to drop traffic that matches this route.\n')
    destination_cidr_block: typing.Optional[str] = pydantic.Field(None, description='The CIDR block used for destination matches.\n')
    transit_gateway_attachment_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the attachment.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_transit_gateway_route_props = ec2.CfnTransitGatewayRouteProps(\n        transit_gateway_route_table_id="transitGatewayRouteTableId",\n\n        # the properties below are optional\n        blackhole=False,\n        destination_cidr_block="destinationCidrBlock",\n        transit_gateway_attachment_id="transitGatewayAttachmentId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['transit_gateway_route_table_id', 'blackhole', 'destination_cidr_block', 'transit_gateway_attachment_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayRouteProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayRouteTableAssociationProps
class CfnTransitGatewayRouteTableAssociationPropsDef(BaseCfnProperty):
    transit_gateway_attachment_id: str = pydantic.Field(..., description='The ID of the attachment.\n')
    transit_gateway_route_table_id: str = pydantic.Field(..., description='The ID of the route table for the transit gateway.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_transit_gateway_route_table_association_props = ec2.CfnTransitGatewayRouteTableAssociationProps(\n        transit_gateway_attachment_id="transitGatewayAttachmentId",\n        transit_gateway_route_table_id="transitGatewayRouteTableId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['transit_gateway_attachment_id', 'transit_gateway_route_table_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayRouteTableAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayRouteTablePropagationProps
class CfnTransitGatewayRouteTablePropagationPropsDef(BaseCfnProperty):
    transit_gateway_attachment_id: str = pydantic.Field(..., description='The ID of the attachment.\n')
    transit_gateway_route_table_id: str = pydantic.Field(..., description='The ID of the propagation route table.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_transit_gateway_route_table_propagation_props = ec2.CfnTransitGatewayRouteTablePropagationProps(\n        transit_gateway_attachment_id="transitGatewayAttachmentId",\n        transit_gateway_route_table_id="transitGatewayRouteTableId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['transit_gateway_attachment_id', 'transit_gateway_route_table_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayRouteTablePropagationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayRouteTableProps
class CfnTransitGatewayRouteTablePropsDef(BaseCfnProperty):
    transit_gateway_id: str = pydantic.Field(..., description='The ID of the transit gateway.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Any tags assigned to the route table.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_transit_gateway_route_table_props = ec2.CfnTransitGatewayRouteTableProps(\n        transit_gateway_id="transitGatewayId",\n\n        # the properties below are optional\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['transit_gateway_id', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayRouteTableProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnTransitGatewayVpcAttachmentProps
class CfnTransitGatewayVpcAttachmentPropsDef(BaseCfnProperty):
    subnet_ids: typing.Sequence[str] = pydantic.Field(..., description='The IDs of the subnets.\n')
    transit_gateway_id: str = pydantic.Field(..., description='The ID of the transit gateway.\n')
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC.\n')
    add_subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of one or more subnets to add. You can specify at most one subnet per Availability Zone.\n')
    options: typing.Any = pydantic.Field(None, description='The VPC attachment options, in JSON or YAML. - ``ApplianceModeSupport`` - Set to ``enable`` or ``disable`` . The default is ``disable`` . - ``DnsSupport`` - Set to ``enable`` or ``disable`` . The default is ``enable`` . - ``Ipv6Support`` - Set to ``enable`` or ``disable`` . The default is ``disable`` .\n')
    remove_subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of one or more subnets to remove.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the VPC attachment.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # options: Any\n\n    cfn_transit_gateway_vpc_attachment_props = ec2.CfnTransitGatewayVpcAttachmentProps(\n        subnet_ids=["subnetIds"],\n        transit_gateway_id="transitGatewayId",\n        vpc_id="vpcId",\n\n        # the properties below are optional\n        add_subnet_ids=["addSubnetIds"],\n        options=options,\n        remove_subnet_ids=["removeSubnetIds"],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['subnet_ids', 'transit_gateway_id', 'vpc_id', 'add_subnet_ids', 'options', 'remove_subnet_ids', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnTransitGatewayVpcAttachmentProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVerifiedAccessEndpointProps
class CfnVerifiedAccessEndpointPropsDef(BaseCfnProperty):
    application_domain: str = pydantic.Field(..., description='The DNS name for users to reach your application.\n')
    attachment_type: str = pydantic.Field(..., description='The type of attachment used to provide connectivity between the AWS Verified Access endpoint and the application.\n')
    domain_certificate_arn: str = pydantic.Field(..., description='The ARN of a public TLS/SSL certificate imported into or created with ACM.\n')
    endpoint_domain_prefix: str = pydantic.Field(..., description='A custom identifier that is prepended to the DNS name that is generated for the endpoint.\n')
    endpoint_type: str = pydantic.Field(..., description='The type of AWS Verified Access endpoint. Incoming application requests will be sent to an IP address, load balancer or a network interface depending on the endpoint type specified.\n')
    verified_access_group_id: str = pydantic.Field(..., description='The ID of the AWS Verified Access group.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the AWS Verified Access endpoint.\n')
    load_balancer_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnVerifiedAccessEndpoint_LoadBalancerOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The load balancer details if creating the AWS Verified Access endpoint as ``load-balancer`` type.\n')
    network_interface_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnVerifiedAccessEndpoint_NetworkInterfaceOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for network-interface type endpoint.\n')
    policy_document: typing.Optional[str] = pydantic.Field(None, description='The Verified Access policy document.\n')
    policy_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='The status of the Verified Access policy.\n')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of the security groups for the endpoint.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_verified_access_endpoint_props = ec2.CfnVerifiedAccessEndpointProps(\n        application_domain="applicationDomain",\n        attachment_type="attachmentType",\n        domain_certificate_arn="domainCertificateArn",\n        endpoint_domain_prefix="endpointDomainPrefix",\n        endpoint_type="endpointType",\n        verified_access_group_id="verifiedAccessGroupId",\n\n        # the properties below are optional\n        description="description",\n        load_balancer_options=ec2.CfnVerifiedAccessEndpoint.LoadBalancerOptionsProperty(\n            load_balancer_arn="loadBalancerArn",\n            port=123,\n            protocol="protocol",\n            subnet_ids=["subnetIds"]\n        ),\n        network_interface_options=ec2.CfnVerifiedAccessEndpoint.NetworkInterfaceOptionsProperty(\n            network_interface_id="networkInterfaceId",\n            port=123,\n            protocol="protocol"\n        ),\n        policy_document="policyDocument",\n        policy_enabled=False,\n        security_group_ids=["securityGroupIds"],\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['application_domain', 'attachment_type', 'domain_certificate_arn', 'endpoint_domain_prefix', 'endpoint_type', 'verified_access_group_id', 'description', 'load_balancer_options', 'network_interface_options', 'policy_document', 'policy_enabled', 'security_group_ids', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVerifiedAccessEndpointProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVerifiedAccessGroupProps
class CfnVerifiedAccessGroupPropsDef(BaseCfnProperty):
    verified_access_instance_id: str = pydantic.Field(..., description='The ID of the AWS Verified Access instance.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the AWS Verified Access group.\n')
    policy_document: typing.Optional[str] = pydantic.Field(None, description='The Verified Access policy document.\n')
    policy_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='The status of the Verified Access policy.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_verified_access_group_props = ec2.CfnVerifiedAccessGroupProps(\n        verified_access_instance_id="verifiedAccessInstanceId",\n\n        # the properties below are optional\n        description="description",\n        policy_document="policyDocument",\n        policy_enabled=False,\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['verified_access_instance_id', 'description', 'policy_document', 'policy_enabled', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVerifiedAccessGroupProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVerifiedAccessInstanceProps
class CfnVerifiedAccessInstancePropsDef(BaseCfnProperty):
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the AWS Verified Access instance.\n')
    logging_configurations: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnVerifiedAccessInstance_VerifiedAccessLogsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The current logging configuration for the Verified Access instances.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags.\n')
    verified_access_trust_provider_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of the AWS Verified Access trust providers.\n')
    verified_access_trust_providers: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnVerifiedAccessInstance_VerifiedAccessTrustProviderPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The IDs of the AWS Verified Access trust providers.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_verified_access_instance_props = ec2.CfnVerifiedAccessInstanceProps(\n        description="description",\n        logging_configurations=ec2.CfnVerifiedAccessInstance.VerifiedAccessLogsProperty(\n            cloud_watch_logs=ec2.CfnVerifiedAccessInstance.CloudWatchLogsProperty(\n                enabled=False,\n                log_group="logGroup"\n            ),\n            kinesis_data_firehose=ec2.CfnVerifiedAccessInstance.KinesisDataFirehoseProperty(\n                delivery_stream="deliveryStream",\n                enabled=False\n            ),\n            s3=ec2.CfnVerifiedAccessInstance.S3Property(\n                bucket_name="bucketName",\n                bucket_owner="bucketOwner",\n                enabled=False,\n                prefix="prefix"\n            )\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        verified_access_trust_provider_ids=["verifiedAccessTrustProviderIds"],\n        verified_access_trust_providers=[ec2.CfnVerifiedAccessInstance.VerifiedAccessTrustProviderProperty(\n            description="description",\n            device_trust_provider_type="deviceTrustProviderType",\n            trust_provider_type="trustProviderType",\n            user_trust_provider_type="userTrustProviderType",\n            verified_access_trust_provider_id="verifiedAccessTrustProviderId"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['description', 'logging_configurations', 'tags', 'verified_access_trust_provider_ids', 'verified_access_trust_providers']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVerifiedAccessInstanceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVerifiedAccessTrustProviderProps
class CfnVerifiedAccessTrustProviderPropsDef(BaseCfnProperty):
    policy_reference_name: str = pydantic.Field(..., description='The identifier to be used when working with policy rules.\n')
    trust_provider_type: str = pydantic.Field(..., description='The type of Verified Access trust provider.\n')
    description: typing.Optional[str] = pydantic.Field(None, description='A description for the AWS Verified Access trust provider.\n')
    device_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnVerifiedAccessTrustProvider_DeviceOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for device-identity trust provider.\n')
    device_trust_provider_type: typing.Optional[str] = pydantic.Field(None, description='The type of device-based trust provider.\n')
    oidc_options: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnVerifiedAccessTrustProvider_OidcOptionsPropertyDef, dict[str, typing.Any], None] = pydantic.Field(None, description='The options for an OpenID Connect-compatible user-identity trust provider.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags.\n')
    user_trust_provider_type: typing.Optional[str] = pydantic.Field(None, description='The type of user-based trust provider.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_verified_access_trust_provider_props = ec2.CfnVerifiedAccessTrustProviderProps(\n        policy_reference_name="policyReferenceName",\n        trust_provider_type="trustProviderType",\n\n        # the properties below are optional\n        description="description",\n        device_options=ec2.CfnVerifiedAccessTrustProvider.DeviceOptionsProperty(\n            tenant_id="tenantId"\n        ),\n        device_trust_provider_type="deviceTrustProviderType",\n        oidc_options=ec2.CfnVerifiedAccessTrustProvider.OidcOptionsProperty(\n            authorization_endpoint="authorizationEndpoint",\n            client_id="clientId",\n            client_secret="clientSecret",\n            issuer="issuer",\n            scope="scope",\n            token_endpoint="tokenEndpoint",\n            user_info_endpoint="userInfoEndpoint"\n        ),\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        user_trust_provider_type="userTrustProviderType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['policy_reference_name', 'trust_provider_type', 'description', 'device_options', 'device_trust_provider_type', 'oidc_options', 'tags', 'user_trust_provider_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVerifiedAccessTrustProviderProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVolumeAttachmentProps
class CfnVolumeAttachmentPropsDef(BaseCfnProperty):
    device: str = pydantic.Field(..., description='The device name (for example, ``/dev/sdh`` or ``xvdh`` ).\n')
    instance_id: str = pydantic.Field(..., description='The ID of the instance to which the volume attaches. This value can be a reference to an ```AWS::EC2::Instance`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource, or it can be the physical ID of an existing EC2 instance.\n')
    volume_id: str = pydantic.Field(..., description='The ID of the Amazon EBS volume. The volume and instance must be within the same Availability Zone. This value can be a reference to an ```AWS::EC2::Volume`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html>`_ resource, or it can be the volume ID of an existing Amazon EBS volume.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volumeattachment.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_volume_attachment_props = ec2.CfnVolumeAttachmentProps(\n        device="device",\n        instance_id="instanceId",\n        volume_id="volumeId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['device', 'instance_id', 'volume_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVolumeAttachmentProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVolumeProps
class CfnVolumePropsDef(BaseCfnProperty):
    availability_zone: str = pydantic.Field(..., description='The ID of the Availability Zone in which to create the volume. For example, ``us-east-1a`` .\n')
    auto_enable_io: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Indicates whether the volume is auto-enabled for I/O operations. By default, Amazon EBS disables I/O to the volume from attached EC2 instances when it determines that a volume's data is potentially inconsistent. If the consistency of the volume is not a concern, and you prefer that the volume be made available immediately if it's impaired, you can configure the volume to automatically enable I/O.\n")
    encrypted: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether the volume should be encrypted. The effect of setting the encryption state to ``true`` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Encryption by default <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default>`_ in the *Amazon Elastic Compute Cloud User Guide* . Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see `Supported instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances>`_ .\n')
    iops: typing.Union[int, float, None] = pydantic.Field(None, description='The number of I/O operations per second (IOPS). For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. The following are the supported values for each volume type: - ``gp3`` : 3,000-16,000 IOPS - ``io1`` : 100-64,000 IOPS - ``io2`` : 100-64,000 IOPS ``io1`` and ``io2`` volumes support up to 64,000 IOPS only on `Instances built on the Nitro System <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ . Other instance families support performance up to 32,000 IOPS. This parameter is required for ``io1`` and ``io2`` volumes. The default for ``gp3`` volumes is 3,000 IOPS. This parameter is not supported for ``gp2`` , ``st1`` , ``sc1`` , or ``standard`` volumes.\n')
    kms_key_id: typing.Optional[str] = pydantic.Field(None, description='The identifier of the AWS KMS key to use for Amazon EBS encryption. If ``KmsKeyId`` is specified, the encrypted state must be ``true`` . If you omit this property and your account is enabled for encryption by default, or *Encrypted* is set to ``true`` , then the volume is encrypted using the default key specified for your account. If your account does not have a default key, then the volume is encrypted using the AWS managed key . Alternatively, if you want to specify a different key, you can specify one of the following: - Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab. - Key alias. Specify the alias for the key, prefixed with ``alias/`` . For example, for a key with the alias ``my_cmk`` , use ``alias/my_cmk`` . Or to specify the AWS managed key , use ``alias/aws/ebs`` . - Key ARN. For example, arn:aws:kms:us-east-1:012345678910:key/1234abcd-12ab-34cd-56ef-1234567890ab. - Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias.\n')
    multi_attach_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether Amazon EBS Multi-Attach is enabled. AWS CloudFormation does not currently support updating a single-attach volume to be multi-attach enabled, updating a multi-attach enabled volume to be single-attach, or updating the size or number of I/O operations per second (IOPS) of a multi-attach enabled volume.\n')
    outpost_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the Outpost.\n')
    size: typing.Union[int, float, None] = pydantic.Field(None, description='The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size. The following are the supported volumes sizes for each volume type: - ``gp2`` and ``gp3`` : 1-16,384 - ``io1`` and ``io2`` : 4-16,384 - ``st1`` and ``sc1`` : 125-16,384 - ``standard`` : 1-1,024\n')
    snapshot_id: typing.Optional[str] = pydantic.Field(None, description='The snapshot from which to create the volume. You must specify either a snapshot ID or a volume size.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags to apply to the volume during creation.\n')
    throughput: typing.Union[int, float, None] = pydantic.Field(None, description='The throughput to provision for a volume, with a maximum of 1,000 MiB/s. This parameter is valid only for ``gp3`` volumes. The default value is 125. Valid Range: Minimum value of 125. Maximum value of 1000.\n')
    volume_type: typing.Optional[str] = pydantic.Field(None, description='The volume type. This parameter can be one of the following values:. - General Purpose SSD: ``gp2`` | ``gp3`` - Provisioned IOPS SSD: ``io1`` | ``io2`` - Throughput Optimized HDD: ``st1`` - Cold HDD: ``sc1`` - Magnetic: ``standard`` For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>`_ in the *Amazon Elastic Compute Cloud User Guide* . Default: ``gp2``\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_volume_props = ec2.CfnVolumeProps(\n        availability_zone="availabilityZone",\n\n        # the properties below are optional\n        auto_enable_io=False,\n        encrypted=False,\n        iops=123,\n        kms_key_id="kmsKeyId",\n        multi_attach_enabled=False,\n        outpost_arn="outpostArn",\n        size=123,\n        snapshot_id="snapshotId",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        throughput=123,\n        volume_type="volumeType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['availability_zone', 'auto_enable_io', 'encrypted', 'iops', 'kms_key_id', 'multi_attach_enabled', 'outpost_arn', 'size', 'snapshot_id', 'tags', 'throughput', 'volume_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVolumeProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVPCCidrBlockProps
class CfnVPCCidrBlockPropsDef(BaseCfnProperty):
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC.\n')
    amazon_provided_ipv6_cidr_block: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IPv6 addresses, or the size of the CIDR block.\n')
    cidr_block: typing.Optional[str] = pydantic.Field(None, description='An IPv4 CIDR block to associate with the VPC.\n')
    ipv4_ipam_pool_id: typing.Optional[str] = pydantic.Field(None, description='Associate a CIDR allocated from an IPv4 IPAM pool to a VPC. For more information about Amazon VPC IP Address Manager (IPAM), see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .\n')
    ipv4_netmask_length: typing.Union[int, float, None] = pydantic.Field(None, description='The netmask length of the IPv4 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool. For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .\n')
    ipv6_cidr_block: typing.Optional[str] = pydantic.Field(None, description='An IPv6 CIDR block from the IPv6 address pool. You must also specify ``Ipv6Pool`` in the request. To let Amazon choose the IPv6 CIDR block for you, omit this parameter.\n')
    ipv6_ipam_pool_id: typing.Optional[str] = pydantic.Field(None, description='Associates a CIDR allocated from an IPv6 IPAM pool to a VPC. For more information about Amazon VPC IP Address Manager (IPAM), see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .\n')
    ipv6_netmask_length: typing.Union[int, float, None] = pydantic.Field(None, description='The netmask length of the IPv6 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool. For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .\n')
    ipv6_pool: typing.Optional[str] = pydantic.Field(None, description='The ID of an IPv6 address pool from which to allocate the IPv6 CIDR block.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_vPCCidr_block_props = ec2.CfnVPCCidrBlockProps(\n        vpc_id="vpcId",\n\n        # the properties below are optional\n        amazon_provided_ipv6_cidr_block=False,\n        cidr_block="cidrBlock",\n        ipv4_ipam_pool_id="ipv4IpamPoolId",\n        ipv4_netmask_length=123,\n        ipv6_cidr_block="ipv6CidrBlock",\n        ipv6_ipam_pool_id="ipv6IpamPoolId",\n        ipv6_netmask_length=123,\n        ipv6_pool="ipv6Pool"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['vpc_id', 'amazon_provided_ipv6_cidr_block', 'cidr_block', 'ipv4_ipam_pool_id', 'ipv4_netmask_length', 'ipv6_cidr_block', 'ipv6_ipam_pool_id', 'ipv6_netmask_length', 'ipv6_pool']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPCCidrBlockProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVPCDHCPOptionsAssociationProps
class CfnVPCDHCPOptionsAssociationPropsDef(BaseCfnProperty):
    dhcp_options_id: str = pydantic.Field(..., description='The ID of the DHCP options set, or ``default`` to associate no DHCP options with the VPC.\n')
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_vPCDHCPOptions_association_props = ec2.CfnVPCDHCPOptionsAssociationProps(\n        dhcp_options_id="dhcpOptionsId",\n        vpc_id="vpcId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['dhcp_options_id', 'vpc_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPCDHCPOptionsAssociationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVPCEndpointConnectionNotificationProps
class CfnVPCEndpointConnectionNotificationPropsDef(BaseCfnProperty):
    connection_events: typing.Sequence[str] = pydantic.Field(..., description='The endpoint events for which to receive notifications. Valid values are ``Accept`` , ``Connect`` , ``Delete`` , and ``Reject`` .\n')
    connection_notification_arn: str = pydantic.Field(..., description='The ARN of the SNS topic for the notifications.\n')
    service_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the endpoint service.\n')
    vpc_endpoint_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the endpoint.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_vPCEndpoint_connection_notification_props = ec2.CfnVPCEndpointConnectionNotificationProps(\n        connection_events=["connectionEvents"],\n        connection_notification_arn="connectionNotificationArn",\n\n        # the properties below are optional\n        service_id="serviceId",\n        vpc_endpoint_id="vpcEndpointId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['connection_events', 'connection_notification_arn', 'service_id', 'vpc_endpoint_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPCEndpointConnectionNotificationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVPCEndpointProps
class CfnVPCEndpointPropsDef(BaseCfnProperty):
    service_name: str = pydantic.Field(..., description='The name of the endpoint service.\n')
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC.\n')
    policy_document: typing.Any = pydantic.Field(None, description='An endpoint policy, which controls access to the service from the VPC. The default endpoint policy allows full access to the service. Endpoint policies are supported only for gateway and interface endpoints. For CloudFormation templates in YAML, you can provide the policy in JSON or YAML format. AWS CloudFormation converts YAML policies to JSON format before calling the API to create or modify the VPC endpoint.\n')
    private_dns_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicate whether to associate a private hosted zone with the specified VPC. The private hosted zone contains a record set for the default public DNS name for the service for the Region (for example, ``kinesis.us-east-1.amazonaws.com`` ), which resolves to the private IP addresses of the endpoint network interfaces in the VPC. This enables you to make requests to the default public DNS name for the service instead of the public DNS names that are automatically generated by the VPC endpoint service. To use a private hosted zone, you must set the following VPC attributes to ``true`` : ``enableDnsHostnames`` and ``enableDnsSupport`` . This property is supported only for interface endpoints. Default: ``false``\n')
    route_table_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of the route tables. Routing is supported only for gateway endpoints.\n')
    security_group_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The IDs of the security groups to associate with the endpoint network interfaces. If this parameter is not specified, we use the default security group for the VPC. Security groups are supported only for interface endpoints.\n')
    subnet_ids: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description="The IDs of the subnets in which to create endpoint network interfaces. You must specify this property for an interface endpoint or a Gateway Load Balancer endpoint. You can't specify this property for a gateway endpoint. For a Gateway Load Balancer endpoint, you can specify only one subnet.\n")
    vpc_endpoint_type: typing.Optional[str] = pydantic.Field(None, description='The type of endpoint. Default: Gateway\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    # policy_document: Any\n\n    cfn_vPCEndpoint_props = ec2.CfnVPCEndpointProps(\n        service_name="serviceName",\n        vpc_id="vpcId",\n\n        # the properties below are optional\n        policy_document=policy_document,\n        private_dns_enabled=False,\n        route_table_ids=["routeTableIds"],\n        security_group_ids=["securityGroupIds"],\n        subnet_ids=["subnetIds"],\n        vpc_endpoint_type="vpcEndpointType"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['service_name', 'vpc_id', 'policy_document', 'private_dns_enabled', 'route_table_ids', 'security_group_ids', 'subnet_ids', 'vpc_endpoint_type']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPCEndpointProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVPCEndpointServicePermissionsProps
class CfnVPCEndpointServicePermissionsPropsDef(BaseCfnProperty):
    service_id: str = pydantic.Field(..., description='The ID of the service.\n')
    allowed_principals: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Amazon Resource Names (ARN) of one or more principals (for example, users, IAM roles, and AWS accounts ). Permissions are granted to the principals in this list. To grant permissions to all principals, specify an asterisk (*). Permissions are revoked for principals not in this list. If the list is empty, then all permissions are revoked.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_vPCEndpoint_service_permissions_props = ec2.CfnVPCEndpointServicePermissionsProps(\n        service_id="serviceId",\n\n        # the properties below are optional\n        allowed_principals=["allowedPrincipals"]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['service_id', 'allowed_principals']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPCEndpointServicePermissionsProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVPCEndpointServiceProps
class CfnVPCEndpointServicePropsDef(BaseCfnProperty):
    acceptance_required: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether requests from service consumers to create an endpoint to your service must be accepted.\n')
    contributor_insights_enabled: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether to enable the built-in Contributor Insights rules provided by AWS PrivateLink .\n')
    gateway_load_balancer_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Amazon Resource Names (ARNs) of the Gateway Load Balancers.\n')
    network_load_balancer_arns: typing.Optional[typing.Sequence[str]] = pydantic.Field(None, description='The Amazon Resource Names (ARNs) of the Network Load Balancers.\n')
    payer_responsibility: typing.Optional[str] = pydantic.Field(None, description='The entity that is responsible for the endpoint costs. The default is the endpoint owner. If you set the payer responsibility to the service owner, you cannot set it back to the endpoint owner.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_vPCEndpoint_service_props = ec2.CfnVPCEndpointServiceProps(\n        acceptance_required=False,\n        contributor_insights_enabled=False,\n        gateway_load_balancer_arns=["gatewayLoadBalancerArns"],\n        network_load_balancer_arns=["networkLoadBalancerArns"],\n        payer_responsibility="payerResponsibility"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['acceptance_required', 'contributor_insights_enabled', 'gateway_load_balancer_arns', 'network_load_balancer_arns', 'payer_responsibility']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPCEndpointServiceProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVPCGatewayAttachmentProps
class CfnVPCGatewayAttachmentPropsDef(BaseCfnProperty):
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC.\n')
    internet_gateway_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the internet gateway. You must specify either ``InternetGatewayId`` or ``VpnGatewayId`` , but not both.\n')
    vpn_gateway_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the virtual private gateway. You must specify either ``InternetGatewayId`` or ``VpnGatewayId`` , but not both.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc-gateway-attachment.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_vPCGateway_attachment_props = ec2.CfnVPCGatewayAttachmentProps(\n        vpc_id="vpcId",\n\n        # the properties below are optional\n        internet_gateway_id="internetGatewayId",\n        vpn_gateway_id="vpnGatewayId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['vpc_id', 'internet_gateway_id', 'vpn_gateway_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPCGatewayAttachmentProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVPCPeeringConnectionProps
class CfnVPCPeeringConnectionPropsDef(BaseCfnProperty):
    peer_vpc_id: str = pydantic.Field(..., description='The ID of the VPC with which you are creating the VPC peering connection. You must specify this parameter in the request.\n')
    vpc_id: str = pydantic.Field(..., description='The ID of the VPC.\n')
    peer_owner_id: typing.Optional[str] = pydantic.Field(None, description='The AWS account ID of the owner of the accepter VPC. Default: Your AWS account ID\n')
    peer_region: typing.Optional[str] = pydantic.Field(None, description='The Region code for the accepter VPC, if the accepter VPC is located in a Region other than the Region in which you make the request. Default: The Region in which you make the request.\n')
    peer_role_arn: typing.Optional[str] = pydantic.Field(None, description='The Amazon Resource Name (ARN) of the VPC peer role for the peering connection in another AWS account. This is required when you are peering a VPC in a different AWS account.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Any tags assigned to the resource.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_vPCPeering_connection_props = ec2.CfnVPCPeeringConnectionProps(\n        peer_vpc_id="peerVpcId",\n        vpc_id="vpcId",\n\n        # the properties below are optional\n        peer_owner_id="peerOwnerId",\n        peer_region="peerRegion",\n        peer_role_arn="peerRoleArn",\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['peer_vpc_id', 'vpc_id', 'peer_owner_id', 'peer_region', 'peer_role_arn', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPCPeeringConnectionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVPCProps
class CfnVPCPropsDef(BaseCfnProperty):
    cidr_block: typing.Optional[str] = pydantic.Field(None, description='The IPv4 network range for the VPC, in CIDR notation. For example, ``10.0.0.0/16`` . We modify the specified CIDR block to its canonical form; for example, if you specify ``100.68.0.18/18`` , we modify it to ``100.68.0.0/18`` . You must specify either ``CidrBlock`` or ``Ipv4IpamPoolId`` .\n')
    enable_dns_hostnames: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Indicates whether the instances launched in the VPC get DNS hostnames. If enabled, instances in the VPC get DNS hostnames; otherwise, they do not. Disabled by default for nondefault VPCs. For more information, see `DNS attributes in your VPC <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support>`_ . You can only enable DNS hostnames if you've enabled DNS support.\n")
    enable_dns_support: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description='Indicates whether the DNS resolution is supported for the VPC. If enabled, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC network range "plus two" succeed. If disabled, the Amazon provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is not enabled. Enabled by default. For more information, see `DNS attributes in your VPC <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support>`_ .\n')
    instance_tenancy: typing.Optional[str] = pydantic.Field(None, description='The allowed tenancy of instances launched into the VPC. - ``default`` : An instance launched into the VPC runs on shared hardware by default, unless you explicitly specify a different tenancy during instance launch. - ``dedicated`` : An instance launched into the VPC runs on dedicated hardware by default, unless you explicitly specify a tenancy of ``host`` during instance launch. You cannot specify a tenancy of ``default`` during instance launch. Updating ``InstanceTenancy`` requires no replacement only if you are updating its value from ``dedicated`` to ``default`` . Updating ``InstanceTenancy`` from ``default`` to ``dedicated`` requires replacement.\n')
    ipv4_ipam_pool_id: typing.Optional[str] = pydantic.Field(None, description="The ID of an IPv4 IPAM pool you want to use for allocating this VPC's CIDR. For more information, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* . You must specify either ``CidrBlock`` or ``Ipv4IpamPoolId`` .\n")
    ipv4_netmask_length: typing.Union[int, float, None] = pydantic.Field(None, description='The netmask length of the IPv4 CIDR you want to allocate to this VPC from an Amazon VPC IP Address Manager (IPAM) pool. For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='The tags for the VPC.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_vPCProps = ec2.CfnVPCProps(\n        cidr_block="cidrBlock",\n        enable_dns_hostnames=False,\n        enable_dns_support=False,\n        instance_tenancy="instanceTenancy",\n        ipv4_ipam_pool_id="ipv4IpamPoolId",\n        ipv4_netmask_length=123,\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['cidr_block', 'enable_dns_hostnames', 'enable_dns_support', 'instance_tenancy', 'ipv4_ipam_pool_id', 'ipv4_netmask_length', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPCProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVPNConnectionProps
class CfnVPNConnectionPropsDef(BaseCfnProperty):
    customer_gateway_id: str = pydantic.Field(..., description='The ID of the customer gateway at your end of the VPN connection.\n')
    type: str = pydantic.Field(..., description='The type of VPN connection.\n')
    static_routes_only: typing.Union[bool, typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], None] = pydantic.Field(None, description="Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP. If you are creating a VPN connection for a device that does not support Border Gateway Protocol (BGP), you must specify ``true`` .\n")
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Any tags assigned to the VPN connection.\n')
    transit_gateway_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the transit gateway associated with the VPN connection. You must specify either ``TransitGatewayId`` or ``VpnGatewayId`` , but not both.\n')
    vpn_gateway_id: typing.Optional[str] = pydantic.Field(None, description='The ID of the virtual private gateway at the AWS side of the VPN connection. You must specify either ``TransitGatewayId`` or ``VpnGatewayId`` , but not both.\n')
    vpn_tunnel_options_specifications: typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], typing.Sequence[typing.Union[typing.Union[models.CfnDynamicReferenceDef, models.IntrinsicDef, models.JsonNullDef, models.ReferenceDef, models.SecretValueDef, models.CfnConditionDef, models.CfnJsonDef, models.aws_events.EventFieldDef, models.aws_events.MatchDef, models.aws_iam.PolicyDocumentDef, models.custom_resources.PhysicalResourceIdReferenceDef], models.aws_ec2.CfnVPNConnection_VpnTunnelOptionsSpecificationPropertyDef, dict[str, typing.Any]]], None] = pydantic.Field(None, description='The tunnel options for the VPN connection.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_vPNConnection_props = ec2.CfnVPNConnectionProps(\n        customer_gateway_id="customerGatewayId",\n        type="type",\n\n        # the properties below are optional\n        static_routes_only=False,\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )],\n        transit_gateway_id="transitGatewayId",\n        vpn_gateway_id="vpnGatewayId",\n        vpn_tunnel_options_specifications=[ec2.CfnVPNConnection.VpnTunnelOptionsSpecificationProperty(\n            pre_shared_key="preSharedKey",\n            tunnel_inside_cidr="tunnelInsideCidr"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['customer_gateway_id', 'type', 'static_routes_only', 'tags', 'transit_gateway_id', 'vpn_gateway_id', 'vpn_tunnel_options_specifications']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPNConnectionProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVPNConnectionRouteProps
class CfnVPNConnectionRoutePropsDef(BaseCfnProperty):
    destination_cidr_block: str = pydantic.Field(..., description='The CIDR block associated with the local subnet of the customer network.\n')
    vpn_connection_id: str = pydantic.Field(..., description='The ID of the VPN connection.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_vPNConnection_route_props = ec2.CfnVPNConnectionRouteProps(\n        destination_cidr_block="destinationCidrBlock",\n        vpn_connection_id="vpnConnectionId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['destination_cidr_block', 'vpn_connection_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPNConnectionRouteProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVPNGatewayProps
class CfnVPNGatewayPropsDef(BaseCfnProperty):
    type: str = pydantic.Field(..., description='The type of VPN connection the virtual private gateway supports.\n')
    amazon_side_asn: typing.Union[int, float, None] = pydantic.Field(None, description='The private Autonomous System Number (ASN) for the Amazon side of a BGP session.\n')
    tags: typing.Optional[typing.Sequence[typing.Union[models.CfnTagDef, dict[str, typing.Any]]]] = pydantic.Field(None, description='Any tags assigned to the virtual private gateway.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_vPNGateway_props = ec2.CfnVPNGatewayProps(\n        type="type",\n\n        # the properties below are optional\n        amazon_side_asn=123,\n        tags=[CfnTag(\n            key="key",\n            value="value"\n        )]\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['type', 'amazon_side_asn', 'tags']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPNGatewayProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




#  autogenerated from aws_cdk.aws_ec2.CfnVPNGatewayRoutePropagationProps
class CfnVPNGatewayRoutePropagationPropsDef(BaseCfnProperty):
    route_table_ids: typing.Sequence[str] = pydantic.Field(..., description='The ID of the route table. The routing table must be associated with the same VPC that the virtual private gateway is attached to.\n')
    vpn_gateway_id: str = pydantic.Field(..., description='The ID of the virtual private gateway that is attached to a VPC. The virtual private gateway must be attached to the same VPC that the routing tables are associated with.\n\n:link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html\n:exampleMetadata: fixture=_generated\n\nExample::\n\n    # The code below shows an example of how to instantiate this type.\n    # The values are placeholders you should change.\n    from aws_cdk import aws_ec2 as ec2\n\n    cfn_vPNGateway_route_propagation_props = ec2.CfnVPNGatewayRoutePropagationProps(\n        route_table_ids=["routeTableIds"],\n        vpn_gateway_id="vpnGatewayId"\n    )\n')
    _init_params: typing.ClassVar[list[str]] = ['route_table_ids', 'vpn_gateway_id']
    _method_names: typing.ClassVar[list[str]] = []
    _classmethod_names: typing.ClassVar[list[str]] = []
    _cdk_class_fqn: typing.ClassVar[str] = 'aws_cdk.aws_ec2.CfnVPNGatewayRoutePropagationProps'
    _alternate_constructor_method_names: typing.ClassVar[list[str]] = []
    ...




import models

class ModuleModel(pydantic.BaseModel):
    AclCidr: typing.Optional[dict[str, AclCidrDef]] = pydantic.Field(None)
    AclTraffic: typing.Optional[dict[str, AclTrafficDef]] = pydantic.Field(None)
    AmazonLinux2022ImageSsmParameter: typing.Optional[dict[str, AmazonLinux2022ImageSsmParameterDef]] = pydantic.Field(None)
    AmazonLinux2022Kernel: typing.Optional[dict[str, AmazonLinux2022KernelDef]] = pydantic.Field(None)
    AmazonLinux2023ImageSsmParameter: typing.Optional[dict[str, AmazonLinux2023ImageSsmParameterDef]] = pydantic.Field(None)
    AmazonLinux2023Kernel: typing.Optional[dict[str, AmazonLinux2023KernelDef]] = pydantic.Field(None)
    AmazonLinux2ImageSsmParameter: typing.Optional[dict[str, AmazonLinux2ImageSsmParameterDef]] = pydantic.Field(None)
    AmazonLinux2Kernel: typing.Optional[dict[str, AmazonLinux2KernelDef]] = pydantic.Field(None)
    AmazonLinuxImage: typing.Optional[dict[str, AmazonLinuxImageDef]] = pydantic.Field(None)
    AmazonLinuxImageSsmParameterBase: typing.Optional[dict[str, AmazonLinuxImageSsmParameterBaseDef]] = pydantic.Field(None)
    BlockDeviceVolume: typing.Optional[dict[str, BlockDeviceVolumeDef]] = pydantic.Field(None)
    ClientVpnRouteTarget: typing.Optional[dict[str, ClientVpnRouteTargetDef]] = pydantic.Field(None)
    ClientVpnUserBasedAuthentication: typing.Optional[dict[str, ClientVpnUserBasedAuthenticationDef]] = pydantic.Field(None)
    CloudFormationInit: typing.Optional[dict[str, CloudFormationInitDef]] = pydantic.Field(None)
    Connections: typing.Optional[dict[str, ConnectionsDef]] = pydantic.Field(None)
    FlowLogDestination: typing.Optional[dict[str, FlowLogDestinationDef]] = pydantic.Field(None)
    FlowLogResourceType: typing.Optional[dict[str, FlowLogResourceTypeDef]] = pydantic.Field(None)
    GatewayVpcEndpointAwsService: typing.Optional[dict[str, GatewayVpcEndpointAwsServiceDef]] = pydantic.Field(None)
    GenericLinuxImage: typing.Optional[dict[str, GenericLinuxImageDef]] = pydantic.Field(None)
    GenericSSMParameterImage: typing.Optional[dict[str, GenericSSMParameterImageDef]] = pydantic.Field(None)
    GenericWindowsImage: typing.Optional[dict[str, GenericWindowsImageDef]] = pydantic.Field(None)
    InitCommand: typing.Optional[dict[str, InitCommandDef]] = pydantic.Field(None)
    InitCommandWaitDuration: typing.Optional[dict[str, InitCommandWaitDurationDef]] = pydantic.Field(None)
    InitConfig: typing.Optional[dict[str, InitConfigDef]] = pydantic.Field(None)
    InitElement: typing.Optional[dict[str, InitElementDef]] = pydantic.Field(None)
    InitFile: typing.Optional[dict[str, InitFileDef]] = pydantic.Field(None)
    InitGroup: typing.Optional[dict[str, InitGroupDef]] = pydantic.Field(None)
    InitPackage: typing.Optional[dict[str, InitPackageDef]] = pydantic.Field(None)
    InitService: typing.Optional[dict[str, InitServiceDef]] = pydantic.Field(None)
    InitServiceRestartHandle: typing.Optional[dict[str, InitServiceRestartHandleDef]] = pydantic.Field(None)
    InitSource: typing.Optional[dict[str, InitSourceDef]] = pydantic.Field(None)
    InitUser: typing.Optional[dict[str, InitUserDef]] = pydantic.Field(None)
    InstanceRequireImdsv2Aspect: typing.Optional[dict[str, InstanceRequireImdsv2AspectDef]] = pydantic.Field(None)
    InstanceType: typing.Optional[dict[str, InstanceTypeDef]] = pydantic.Field(None)
    InterfaceVpcEndpointAwsService: typing.Optional[dict[str, InterfaceVpcEndpointAwsServiceDef]] = pydantic.Field(None)
    InterfaceVpcEndpointService: typing.Optional[dict[str, InterfaceVpcEndpointServiceDef]] = pydantic.Field(None)
    IpAddresses: typing.Optional[dict[str, IpAddressesDef]] = pydantic.Field(None)
    LaunchTemplateRequireImdsv2Aspect: typing.Optional[dict[str, LaunchTemplateRequireImdsv2AspectDef]] = pydantic.Field(None)
    LaunchTemplateSpecialVersions: typing.Optional[dict[str, LaunchTemplateSpecialVersionsDef]] = pydantic.Field(None)
    LogFormat: typing.Optional[dict[str, LogFormatDef]] = pydantic.Field(None)
    LookupMachineImage: typing.Optional[dict[str, LookupMachineImageDef]] = pydantic.Field(None)
    MachineImage: typing.Optional[dict[str, MachineImageDef]] = pydantic.Field(None)
    MultipartBody: typing.Optional[dict[str, MultipartBodyDef]] = pydantic.Field(None)
    MultipartUserData: typing.Optional[dict[str, MultipartUserDataDef]] = pydantic.Field(None)
    NatInstanceImage: typing.Optional[dict[str, NatInstanceImageDef]] = pydantic.Field(None)
    NatInstanceProvider: typing.Optional[dict[str, NatInstanceProviderDef]] = pydantic.Field(None)
    NatProvider: typing.Optional[dict[str, NatProviderDef]] = pydantic.Field(None)
    Peer: typing.Optional[dict[str, PeerDef]] = pydantic.Field(None)
    Port: typing.Optional[dict[str, PortDef]] = pydantic.Field(None)
    SubnetFilter: typing.Optional[dict[str, SubnetFilterDef]] = pydantic.Field(None)
    UserData: typing.Optional[dict[str, UserDataDef]] = pydantic.Field(None)
    VpcEndpoint: typing.Optional[dict[str, VpcEndpointDef]] = pydantic.Field(None)
    VpnConnectionBase: typing.Optional[dict[str, VpnConnectionBaseDef]] = pydantic.Field(None)
    WindowsImage: typing.Optional[dict[str, WindowsImageDef]] = pydantic.Field(None)
    BastionHostLinux: typing.Optional[dict[str, BastionHostLinuxDef]] = pydantic.Field(None)
    ClientVpnAuthorizationRule: typing.Optional[dict[str, ClientVpnAuthorizationRuleDef]] = pydantic.Field(None)
    ClientVpnEndpoint: typing.Optional[dict[str, ClientVpnEndpointDef]] = pydantic.Field(None)
    ClientVpnRoute: typing.Optional[dict[str, ClientVpnRouteDef]] = pydantic.Field(None)
    FlowLog: typing.Optional[dict[str, FlowLogDef]] = pydantic.Field(None)
    GatewayVpcEndpoint: typing.Optional[dict[str, GatewayVpcEndpointDef]] = pydantic.Field(None)
    Instance: typing.Optional[dict[str, InstanceDef]] = pydantic.Field(None)
    InterfaceVpcEndpoint: typing.Optional[dict[str, InterfaceVpcEndpointDef]] = pydantic.Field(None)
    LaunchTemplate: typing.Optional[dict[str, LaunchTemplateDef]] = pydantic.Field(None)
    NetworkAcl: typing.Optional[dict[str, NetworkAclDef]] = pydantic.Field(None)
    NetworkAclEntry: typing.Optional[dict[str, NetworkAclEntryDef]] = pydantic.Field(None)
    PlacementGroup: typing.Optional[dict[str, PlacementGroupDef]] = pydantic.Field(None)
    PrefixList: typing.Optional[dict[str, PrefixListDef]] = pydantic.Field(None)
    PrivateSubnet: typing.Optional[dict[str, PrivateSubnetDef]] = pydantic.Field(None)
    PublicSubnet: typing.Optional[dict[str, PublicSubnetDef]] = pydantic.Field(None)
    SecurityGroup: typing.Optional[dict[str, SecurityGroupDef]] = pydantic.Field(None)
    Subnet: typing.Optional[dict[str, SubnetDef]] = pydantic.Field(None)
    SubnetNetworkAclAssociation: typing.Optional[dict[str, SubnetNetworkAclAssociationDef]] = pydantic.Field(None)
    Volume: typing.Optional[dict[str, VolumeDef]] = pydantic.Field(None)
    Vpc: typing.Optional[dict[str, VpcDef]] = pydantic.Field(None)
    VpcEndpointService: typing.Optional[dict[str, VpcEndpointServiceDef]] = pydantic.Field(None)
    VpnConnection: typing.Optional[dict[str, VpnConnectionDef]] = pydantic.Field(None)
    VpnGateway: typing.Optional[dict[str, VpnGatewayDef]] = pydantic.Field(None)
    AclCidrConfig: typing.Optional[dict[str, AclCidrConfigDef]] = pydantic.Field(None)
    AclIcmp: typing.Optional[dict[str, AclIcmpDef]] = pydantic.Field(None)
    AclPortRange: typing.Optional[dict[str, AclPortRangeDef]] = pydantic.Field(None)
    AclTrafficConfig: typing.Optional[dict[str, AclTrafficConfigDef]] = pydantic.Field(None)
    AddRouteOptions: typing.Optional[dict[str, AddRouteOptionsDef]] = pydantic.Field(None)
    AllocateCidrRequest: typing.Optional[dict[str, AllocateCidrRequestDef]] = pydantic.Field(None)
    AllocatedSubnet: typing.Optional[dict[str, AllocatedSubnetDef]] = pydantic.Field(None)
    AmazonLinux2022ImageSsmParameterProps: typing.Optional[dict[str, AmazonLinux2022ImageSsmParameterPropsDef]] = pydantic.Field(None)
    AmazonLinux2023ImageSsmParameterProps: typing.Optional[dict[str, AmazonLinux2023ImageSsmParameterPropsDef]] = pydantic.Field(None)
    AmazonLinux2ImageSsmParameterProps: typing.Optional[dict[str, AmazonLinux2ImageSsmParameterPropsDef]] = pydantic.Field(None)
    AmazonLinuxImageProps: typing.Optional[dict[str, AmazonLinuxImagePropsDef]] = pydantic.Field(None)
    AmazonLinuxImageSsmParameterBaseOptions: typing.Optional[dict[str, AmazonLinuxImageSsmParameterBaseOptionsDef]] = pydantic.Field(None)
    AmazonLinuxImageSsmParameterBaseProps: typing.Optional[dict[str, AmazonLinuxImageSsmParameterBasePropsDef]] = pydantic.Field(None)
    AmazonLinuxImageSsmParameterCommonOptions: typing.Optional[dict[str, AmazonLinuxImageSsmParameterCommonOptionsDef]] = pydantic.Field(None)
    ApplyCloudFormationInitOptions: typing.Optional[dict[str, ApplyCloudFormationInitOptionsDef]] = pydantic.Field(None)
    AttachInitOptions: typing.Optional[dict[str, AttachInitOptionsDef]] = pydantic.Field(None)
    AwsIpamProps: typing.Optional[dict[str, AwsIpamPropsDef]] = pydantic.Field(None)
    BastionHostLinuxProps: typing.Optional[dict[str, BastionHostLinuxPropsDef]] = pydantic.Field(None)
    BlockDevice: typing.Optional[dict[str, BlockDeviceDef]] = pydantic.Field(None)
    CfnCapacityReservation_TagSpecificationProperty: typing.Optional[dict[str, CfnCapacityReservation_TagSpecificationPropertyDef]] = pydantic.Field(None)
    CfnCapacityReservationFleet_InstanceTypeSpecificationProperty: typing.Optional[dict[str, CfnCapacityReservationFleet_InstanceTypeSpecificationPropertyDef]] = pydantic.Field(None)
    CfnCapacityReservationFleet_TagSpecificationProperty: typing.Optional[dict[str, CfnCapacityReservationFleet_TagSpecificationPropertyDef]] = pydantic.Field(None)
    CfnClientVpnEndpoint_CertificateAuthenticationRequestProperty: typing.Optional[dict[str, CfnClientVpnEndpoint_CertificateAuthenticationRequestPropertyDef]] = pydantic.Field(None)
    CfnClientVpnEndpoint_ClientAuthenticationRequestProperty: typing.Optional[dict[str, CfnClientVpnEndpoint_ClientAuthenticationRequestPropertyDef]] = pydantic.Field(None)
    CfnClientVpnEndpoint_ClientConnectOptionsProperty: typing.Optional[dict[str, CfnClientVpnEndpoint_ClientConnectOptionsPropertyDef]] = pydantic.Field(None)
    CfnClientVpnEndpoint_ClientLoginBannerOptionsProperty: typing.Optional[dict[str, CfnClientVpnEndpoint_ClientLoginBannerOptionsPropertyDef]] = pydantic.Field(None)
    CfnClientVpnEndpoint_ConnectionLogOptionsProperty: typing.Optional[dict[str, CfnClientVpnEndpoint_ConnectionLogOptionsPropertyDef]] = pydantic.Field(None)
    CfnClientVpnEndpoint_DirectoryServiceAuthenticationRequestProperty: typing.Optional[dict[str, CfnClientVpnEndpoint_DirectoryServiceAuthenticationRequestPropertyDef]] = pydantic.Field(None)
    CfnClientVpnEndpoint_FederatedAuthenticationRequestProperty: typing.Optional[dict[str, CfnClientVpnEndpoint_FederatedAuthenticationRequestPropertyDef]] = pydantic.Field(None)
    CfnClientVpnEndpoint_TagSpecificationProperty: typing.Optional[dict[str, CfnClientVpnEndpoint_TagSpecificationPropertyDef]] = pydantic.Field(None)
    CfnEC2Fleet_AcceleratorCountRequestProperty: typing.Optional[dict[str, CfnEC2Fleet_AcceleratorCountRequestPropertyDef]] = pydantic.Field(None)
    CfnEC2Fleet_AcceleratorTotalMemoryMiBRequestProperty: typing.Optional[dict[str, CfnEC2Fleet_AcceleratorTotalMemoryMiBRequestPropertyDef]] = pydantic.Field(None)
    CfnEC2Fleet_BaselineEbsBandwidthMbpsRequestProperty: typing.Optional[dict[str, CfnEC2Fleet_BaselineEbsBandwidthMbpsRequestPropertyDef]] = pydantic.Field(None)
    CfnEC2Fleet_CapacityRebalanceProperty: typing.Optional[dict[str, CfnEC2Fleet_CapacityRebalancePropertyDef]] = pydantic.Field(None)
    CfnEC2Fleet_CapacityReservationOptionsRequestProperty: typing.Optional[dict[str, CfnEC2Fleet_CapacityReservationOptionsRequestPropertyDef]] = pydantic.Field(None)
    CfnEC2Fleet_FleetLaunchTemplateConfigRequestProperty: typing.Optional[dict[str, CfnEC2Fleet_FleetLaunchTemplateConfigRequestPropertyDef]] = pydantic.Field(None)
    CfnEC2Fleet_FleetLaunchTemplateOverridesRequestProperty: typing.Optional[dict[str, CfnEC2Fleet_FleetLaunchTemplateOverridesRequestPropertyDef]] = pydantic.Field(None)
    CfnEC2Fleet_FleetLaunchTemplateSpecificationRequestProperty: typing.Optional[dict[str, CfnEC2Fleet_FleetLaunchTemplateSpecificationRequestPropertyDef]] = pydantic.Field(None)
    CfnEC2Fleet_InstanceRequirementsRequestProperty: typing.Optional[dict[str, CfnEC2Fleet_InstanceRequirementsRequestPropertyDef]] = pydantic.Field(None)
    CfnEC2Fleet_MaintenanceStrategiesProperty: typing.Optional[dict[str, CfnEC2Fleet_MaintenanceStrategiesPropertyDef]] = pydantic.Field(None)
    CfnEC2Fleet_MemoryGiBPerVCpuRequestProperty: typing.Optional[dict[str, CfnEC2Fleet_MemoryGiBPerVCpuRequestPropertyDef]] = pydantic.Field(None)
    CfnEC2Fleet_MemoryMiBRequestProperty: typing.Optional[dict[str, CfnEC2Fleet_MemoryMiBRequestPropertyDef]] = pydantic.Field(None)
    CfnEC2Fleet_NetworkBandwidthGbpsRequestProperty: typing.Optional[dict[str, CfnEC2Fleet_NetworkBandwidthGbpsRequestPropertyDef]] = pydantic.Field(None)
    CfnEC2Fleet_NetworkInterfaceCountRequestProperty: typing.Optional[dict[str, CfnEC2Fleet_NetworkInterfaceCountRequestPropertyDef]] = pydantic.Field(None)
    CfnEC2Fleet_OnDemandOptionsRequestProperty: typing.Optional[dict[str, CfnEC2Fleet_OnDemandOptionsRequestPropertyDef]] = pydantic.Field(None)
    CfnEC2Fleet_PlacementProperty: typing.Optional[dict[str, CfnEC2Fleet_PlacementPropertyDef]] = pydantic.Field(None)
    CfnEC2Fleet_SpotOptionsRequestProperty: typing.Optional[dict[str, CfnEC2Fleet_SpotOptionsRequestPropertyDef]] = pydantic.Field(None)
    CfnEC2Fleet_TagSpecificationProperty: typing.Optional[dict[str, CfnEC2Fleet_TagSpecificationPropertyDef]] = pydantic.Field(None)
    CfnEC2Fleet_TargetCapacitySpecificationRequestProperty: typing.Optional[dict[str, CfnEC2Fleet_TargetCapacitySpecificationRequestPropertyDef]] = pydantic.Field(None)
    CfnEC2Fleet_TotalLocalStorageGBRequestProperty: typing.Optional[dict[str, CfnEC2Fleet_TotalLocalStorageGBRequestPropertyDef]] = pydantic.Field(None)
    CfnEC2Fleet_VCpuCountRangeRequestProperty: typing.Optional[dict[str, CfnEC2Fleet_VCpuCountRangeRequestPropertyDef]] = pydantic.Field(None)
    CfnFlowLog_DestinationOptionsProperty: typing.Optional[dict[str, CfnFlowLog_DestinationOptionsPropertyDef]] = pydantic.Field(None)
    CfnInstance_AssociationParameterProperty: typing.Optional[dict[str, CfnInstance_AssociationParameterPropertyDef]] = pydantic.Field(None)
    CfnInstance_BlockDeviceMappingProperty: typing.Optional[dict[str, CfnInstance_BlockDeviceMappingPropertyDef]] = pydantic.Field(None)
    CfnInstance_CpuOptionsProperty: typing.Optional[dict[str, CfnInstance_CpuOptionsPropertyDef]] = pydantic.Field(None)
    CfnInstance_CreditSpecificationProperty: typing.Optional[dict[str, CfnInstance_CreditSpecificationPropertyDef]] = pydantic.Field(None)
    CfnInstance_EbsProperty: typing.Optional[dict[str, CfnInstance_EbsPropertyDef]] = pydantic.Field(None)
    CfnInstance_ElasticGpuSpecificationProperty: typing.Optional[dict[str, CfnInstance_ElasticGpuSpecificationPropertyDef]] = pydantic.Field(None)
    CfnInstance_ElasticInferenceAcceleratorProperty: typing.Optional[dict[str, CfnInstance_ElasticInferenceAcceleratorPropertyDef]] = pydantic.Field(None)
    CfnInstance_EnclaveOptionsProperty: typing.Optional[dict[str, CfnInstance_EnclaveOptionsPropertyDef]] = pydantic.Field(None)
    CfnInstance_HibernationOptionsProperty: typing.Optional[dict[str, CfnInstance_HibernationOptionsPropertyDef]] = pydantic.Field(None)
    CfnInstance_InstanceIpv6AddressProperty: typing.Optional[dict[str, CfnInstance_InstanceIpv6AddressPropertyDef]] = pydantic.Field(None)
    CfnInstance_LaunchTemplateSpecificationProperty: typing.Optional[dict[str, CfnInstance_LaunchTemplateSpecificationPropertyDef]] = pydantic.Field(None)
    CfnInstance_LicenseSpecificationProperty: typing.Optional[dict[str, CfnInstance_LicenseSpecificationPropertyDef]] = pydantic.Field(None)
    CfnInstance_NetworkInterfaceProperty: typing.Optional[dict[str, CfnInstance_NetworkInterfacePropertyDef]] = pydantic.Field(None)
    CfnInstance_NoDeviceProperty: typing.Optional[dict[str, CfnInstance_NoDevicePropertyDef]] = pydantic.Field(None)
    CfnInstance_PrivateDnsNameOptionsProperty: typing.Optional[dict[str, CfnInstance_PrivateDnsNameOptionsPropertyDef]] = pydantic.Field(None)
    CfnInstance_PrivateIpAddressSpecificationProperty: typing.Optional[dict[str, CfnInstance_PrivateIpAddressSpecificationPropertyDef]] = pydantic.Field(None)
    CfnInstance_SsmAssociationProperty: typing.Optional[dict[str, CfnInstance_SsmAssociationPropertyDef]] = pydantic.Field(None)
    CfnInstance_VolumeProperty: typing.Optional[dict[str, CfnInstance_VolumePropertyDef]] = pydantic.Field(None)
    CfnIPAM_IpamOperatingRegionProperty: typing.Optional[dict[str, CfnIPAM_IpamOperatingRegionPropertyDef]] = pydantic.Field(None)
    CfnIPAMPool_ProvisionedCidrProperty: typing.Optional[dict[str, CfnIPAMPool_ProvisionedCidrPropertyDef]] = pydantic.Field(None)
    CfnIPAMResourceDiscovery_IpamOperatingRegionProperty: typing.Optional[dict[str, CfnIPAMResourceDiscovery_IpamOperatingRegionPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_AcceleratorCountProperty: typing.Optional[dict[str, CfnLaunchTemplate_AcceleratorCountPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_AcceleratorTotalMemoryMiBProperty: typing.Optional[dict[str, CfnLaunchTemplate_AcceleratorTotalMemoryMiBPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_BaselineEbsBandwidthMbpsProperty: typing.Optional[dict[str, CfnLaunchTemplate_BaselineEbsBandwidthMbpsPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_BlockDeviceMappingProperty: typing.Optional[dict[str, CfnLaunchTemplate_BlockDeviceMappingPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_CapacityReservationSpecificationProperty: typing.Optional[dict[str, CfnLaunchTemplate_CapacityReservationSpecificationPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_CapacityReservationTargetProperty: typing.Optional[dict[str, CfnLaunchTemplate_CapacityReservationTargetPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_CpuOptionsProperty: typing.Optional[dict[str, CfnLaunchTemplate_CpuOptionsPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_CreditSpecificationProperty: typing.Optional[dict[str, CfnLaunchTemplate_CreditSpecificationPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_EbsProperty: typing.Optional[dict[str, CfnLaunchTemplate_EbsPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_ElasticGpuSpecificationProperty: typing.Optional[dict[str, CfnLaunchTemplate_ElasticGpuSpecificationPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_EnclaveOptionsProperty: typing.Optional[dict[str, CfnLaunchTemplate_EnclaveOptionsPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_HibernationOptionsProperty: typing.Optional[dict[str, CfnLaunchTemplate_HibernationOptionsPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_IamInstanceProfileProperty: typing.Optional[dict[str, CfnLaunchTemplate_IamInstanceProfilePropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_InstanceMarketOptionsProperty: typing.Optional[dict[str, CfnLaunchTemplate_InstanceMarketOptionsPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_InstanceRequirementsProperty: typing.Optional[dict[str, CfnLaunchTemplate_InstanceRequirementsPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_Ipv4PrefixSpecificationProperty: typing.Optional[dict[str, CfnLaunchTemplate_Ipv4PrefixSpecificationPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_Ipv6AddProperty: typing.Optional[dict[str, CfnLaunchTemplate_Ipv6AddPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_Ipv6PrefixSpecificationProperty: typing.Optional[dict[str, CfnLaunchTemplate_Ipv6PrefixSpecificationPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_LaunchTemplateDataProperty: typing.Optional[dict[str, CfnLaunchTemplate_LaunchTemplateDataPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_LaunchTemplateElasticInferenceAcceleratorProperty: typing.Optional[dict[str, CfnLaunchTemplate_LaunchTemplateElasticInferenceAcceleratorPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_LaunchTemplateTagSpecificationProperty: typing.Optional[dict[str, CfnLaunchTemplate_LaunchTemplateTagSpecificationPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_LicenseSpecificationProperty: typing.Optional[dict[str, CfnLaunchTemplate_LicenseSpecificationPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_MaintenanceOptionsProperty: typing.Optional[dict[str, CfnLaunchTemplate_MaintenanceOptionsPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_MemoryGiBPerVCpuProperty: typing.Optional[dict[str, CfnLaunchTemplate_MemoryGiBPerVCpuPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_MemoryMiBProperty: typing.Optional[dict[str, CfnLaunchTemplate_MemoryMiBPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_MetadataOptionsProperty: typing.Optional[dict[str, CfnLaunchTemplate_MetadataOptionsPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_MonitoringProperty: typing.Optional[dict[str, CfnLaunchTemplate_MonitoringPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_NetworkBandwidthGbpsProperty: typing.Optional[dict[str, CfnLaunchTemplate_NetworkBandwidthGbpsPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_NetworkInterfaceCountProperty: typing.Optional[dict[str, CfnLaunchTemplate_NetworkInterfaceCountPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_NetworkInterfaceProperty: typing.Optional[dict[str, CfnLaunchTemplate_NetworkInterfacePropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_PlacementProperty: typing.Optional[dict[str, CfnLaunchTemplate_PlacementPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_PrivateDnsNameOptionsProperty: typing.Optional[dict[str, CfnLaunchTemplate_PrivateDnsNameOptionsPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_PrivateIpAddProperty: typing.Optional[dict[str, CfnLaunchTemplate_PrivateIpAddPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_SpotOptionsProperty: typing.Optional[dict[str, CfnLaunchTemplate_SpotOptionsPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_TagSpecificationProperty: typing.Optional[dict[str, CfnLaunchTemplate_TagSpecificationPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_TotalLocalStorageGBProperty: typing.Optional[dict[str, CfnLaunchTemplate_TotalLocalStorageGBPropertyDef]] = pydantic.Field(None)
    CfnLaunchTemplate_VCpuCountProperty: typing.Optional[dict[str, CfnLaunchTemplate_VCpuCountPropertyDef]] = pydantic.Field(None)
    CfnNetworkAclEntry_IcmpProperty: typing.Optional[dict[str, CfnNetworkAclEntry_IcmpPropertyDef]] = pydantic.Field(None)
    CfnNetworkAclEntry_PortRangeProperty: typing.Optional[dict[str, CfnNetworkAclEntry_PortRangePropertyDef]] = pydantic.Field(None)
    CfnNetworkInsightsAccessScope_AccessScopePathRequestProperty: typing.Optional[dict[str, CfnNetworkInsightsAccessScope_AccessScopePathRequestPropertyDef]] = pydantic.Field(None)
    CfnNetworkInsightsAccessScope_PacketHeaderStatementRequestProperty: typing.Optional[dict[str, CfnNetworkInsightsAccessScope_PacketHeaderStatementRequestPropertyDef]] = pydantic.Field(None)
    CfnNetworkInsightsAccessScope_PathStatementRequestProperty: typing.Optional[dict[str, CfnNetworkInsightsAccessScope_PathStatementRequestPropertyDef]] = pydantic.Field(None)
    CfnNetworkInsightsAccessScope_ResourceStatementRequestProperty: typing.Optional[dict[str, CfnNetworkInsightsAccessScope_ResourceStatementRequestPropertyDef]] = pydantic.Field(None)
    CfnNetworkInsightsAccessScope_ThroughResourcesStatementRequestProperty: typing.Optional[dict[str, CfnNetworkInsightsAccessScope_ThroughResourcesStatementRequestPropertyDef]] = pydantic.Field(None)
    CfnNetworkInsightsAnalysis_AdditionalDetailProperty: typing.Optional[dict[str, CfnNetworkInsightsAnalysis_AdditionalDetailPropertyDef]] = pydantic.Field(None)
    CfnNetworkInsightsAnalysis_AlternatePathHintProperty: typing.Optional[dict[str, CfnNetworkInsightsAnalysis_AlternatePathHintPropertyDef]] = pydantic.Field(None)
    CfnNetworkInsightsAnalysis_AnalysisAclRuleProperty: typing.Optional[dict[str, CfnNetworkInsightsAnalysis_AnalysisAclRulePropertyDef]] = pydantic.Field(None)
    CfnNetworkInsightsAnalysis_AnalysisComponentProperty: typing.Optional[dict[str, CfnNetworkInsightsAnalysis_AnalysisComponentPropertyDef]] = pydantic.Field(None)
    CfnNetworkInsightsAnalysis_AnalysisLoadBalancerListenerProperty: typing.Optional[dict[str, CfnNetworkInsightsAnalysis_AnalysisLoadBalancerListenerPropertyDef]] = pydantic.Field(None)
    CfnNetworkInsightsAnalysis_AnalysisLoadBalancerTargetProperty: typing.Optional[dict[str, CfnNetworkInsightsAnalysis_AnalysisLoadBalancerTargetPropertyDef]] = pydantic.Field(None)
    CfnNetworkInsightsAnalysis_AnalysisPacketHeaderProperty: typing.Optional[dict[str, CfnNetworkInsightsAnalysis_AnalysisPacketHeaderPropertyDef]] = pydantic.Field(None)
    CfnNetworkInsightsAnalysis_AnalysisRouteTableRouteProperty: typing.Optional[dict[str, CfnNetworkInsightsAnalysis_AnalysisRouteTableRoutePropertyDef]] = pydantic.Field(None)
    CfnNetworkInsightsAnalysis_AnalysisSecurityGroupRuleProperty: typing.Optional[dict[str, CfnNetworkInsightsAnalysis_AnalysisSecurityGroupRulePropertyDef]] = pydantic.Field(None)
    CfnNetworkInsightsAnalysis_ExplanationProperty: typing.Optional[dict[str, CfnNetworkInsightsAnalysis_ExplanationPropertyDef]] = pydantic.Field(None)
    CfnNetworkInsightsAnalysis_PathComponentProperty: typing.Optional[dict[str, CfnNetworkInsightsAnalysis_PathComponentPropertyDef]] = pydantic.Field(None)
    CfnNetworkInsightsAnalysis_PortRangeProperty: typing.Optional[dict[str, CfnNetworkInsightsAnalysis_PortRangePropertyDef]] = pydantic.Field(None)
    CfnNetworkInsightsAnalysis_TransitGatewayRouteTableRouteProperty: typing.Optional[dict[str, CfnNetworkInsightsAnalysis_TransitGatewayRouteTableRoutePropertyDef]] = pydantic.Field(None)
    CfnNetworkInsightsPath_FilterPortRangeProperty: typing.Optional[dict[str, CfnNetworkInsightsPath_FilterPortRangePropertyDef]] = pydantic.Field(None)
    CfnNetworkInsightsPath_PathFilterProperty: typing.Optional[dict[str, CfnNetworkInsightsPath_PathFilterPropertyDef]] = pydantic.Field(None)
    CfnNetworkInterface_InstanceIpv6AddressProperty: typing.Optional[dict[str, CfnNetworkInterface_InstanceIpv6AddressPropertyDef]] = pydantic.Field(None)
    CfnNetworkInterface_PrivateIpAddressSpecificationProperty: typing.Optional[dict[str, CfnNetworkInterface_PrivateIpAddressSpecificationPropertyDef]] = pydantic.Field(None)
    CfnPrefixList_EntryProperty: typing.Optional[dict[str, CfnPrefixList_EntryPropertyDef]] = pydantic.Field(None)
    CfnSecurityGroup_EgressProperty: typing.Optional[dict[str, CfnSecurityGroup_EgressPropertyDef]] = pydantic.Field(None)
    CfnSecurityGroup_IngressProperty: typing.Optional[dict[str, CfnSecurityGroup_IngressPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_AcceleratorCountRequestProperty: typing.Optional[dict[str, CfnSpotFleet_AcceleratorCountRequestPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_AcceleratorTotalMemoryMiBRequestProperty: typing.Optional[dict[str, CfnSpotFleet_AcceleratorTotalMemoryMiBRequestPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_BaselineEbsBandwidthMbpsRequestProperty: typing.Optional[dict[str, CfnSpotFleet_BaselineEbsBandwidthMbpsRequestPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_BlockDeviceMappingProperty: typing.Optional[dict[str, CfnSpotFleet_BlockDeviceMappingPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_ClassicLoadBalancerProperty: typing.Optional[dict[str, CfnSpotFleet_ClassicLoadBalancerPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_ClassicLoadBalancersConfigProperty: typing.Optional[dict[str, CfnSpotFleet_ClassicLoadBalancersConfigPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_EbsBlockDeviceProperty: typing.Optional[dict[str, CfnSpotFleet_EbsBlockDevicePropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_FleetLaunchTemplateSpecificationProperty: typing.Optional[dict[str, CfnSpotFleet_FleetLaunchTemplateSpecificationPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_GroupIdentifierProperty: typing.Optional[dict[str, CfnSpotFleet_GroupIdentifierPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_IamInstanceProfileSpecificationProperty: typing.Optional[dict[str, CfnSpotFleet_IamInstanceProfileSpecificationPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_InstanceIpv6AddressProperty: typing.Optional[dict[str, CfnSpotFleet_InstanceIpv6AddressPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_InstanceNetworkInterfaceSpecificationProperty: typing.Optional[dict[str, CfnSpotFleet_InstanceNetworkInterfaceSpecificationPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_InstanceRequirementsRequestProperty: typing.Optional[dict[str, CfnSpotFleet_InstanceRequirementsRequestPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_LaunchTemplateConfigProperty: typing.Optional[dict[str, CfnSpotFleet_LaunchTemplateConfigPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_LaunchTemplateOverridesProperty: typing.Optional[dict[str, CfnSpotFleet_LaunchTemplateOverridesPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_LoadBalancersConfigProperty: typing.Optional[dict[str, CfnSpotFleet_LoadBalancersConfigPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_MemoryGiBPerVCpuRequestProperty: typing.Optional[dict[str, CfnSpotFleet_MemoryGiBPerVCpuRequestPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_MemoryMiBRequestProperty: typing.Optional[dict[str, CfnSpotFleet_MemoryMiBRequestPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_NetworkBandwidthGbpsRequestProperty: typing.Optional[dict[str, CfnSpotFleet_NetworkBandwidthGbpsRequestPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_NetworkInterfaceCountRequestProperty: typing.Optional[dict[str, CfnSpotFleet_NetworkInterfaceCountRequestPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_PrivateIpAddressSpecificationProperty: typing.Optional[dict[str, CfnSpotFleet_PrivateIpAddressSpecificationPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_SpotCapacityRebalanceProperty: typing.Optional[dict[str, CfnSpotFleet_SpotCapacityRebalancePropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_SpotFleetLaunchSpecificationProperty: typing.Optional[dict[str, CfnSpotFleet_SpotFleetLaunchSpecificationPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_SpotFleetMonitoringProperty: typing.Optional[dict[str, CfnSpotFleet_SpotFleetMonitoringPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_SpotFleetRequestConfigDataProperty: typing.Optional[dict[str, CfnSpotFleet_SpotFleetRequestConfigDataPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_SpotFleetTagSpecificationProperty: typing.Optional[dict[str, CfnSpotFleet_SpotFleetTagSpecificationPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_SpotMaintenanceStrategiesProperty: typing.Optional[dict[str, CfnSpotFleet_SpotMaintenanceStrategiesPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_SpotPlacementProperty: typing.Optional[dict[str, CfnSpotFleet_SpotPlacementPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_TargetGroupProperty: typing.Optional[dict[str, CfnSpotFleet_TargetGroupPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_TargetGroupsConfigProperty: typing.Optional[dict[str, CfnSpotFleet_TargetGroupsConfigPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_TotalLocalStorageGBRequestProperty: typing.Optional[dict[str, CfnSpotFleet_TotalLocalStorageGBRequestPropertyDef]] = pydantic.Field(None)
    CfnSpotFleet_VCpuCountRangeRequestProperty: typing.Optional[dict[str, CfnSpotFleet_VCpuCountRangeRequestPropertyDef]] = pydantic.Field(None)
    CfnSubnet_PrivateDnsNameOptionsOnLaunchProperty: typing.Optional[dict[str, CfnSubnet_PrivateDnsNameOptionsOnLaunchPropertyDef]] = pydantic.Field(None)
    CfnTrafficMirrorFilterRule_TrafficMirrorPortRangeProperty: typing.Optional[dict[str, CfnTrafficMirrorFilterRule_TrafficMirrorPortRangePropertyDef]] = pydantic.Field(None)
    CfnTransitGatewayAttachment_OptionsProperty: typing.Optional[dict[str, CfnTransitGatewayAttachment_OptionsPropertyDef]] = pydantic.Field(None)
    CfnTransitGatewayConnect_TransitGatewayConnectOptionsProperty: typing.Optional[dict[str, CfnTransitGatewayConnect_TransitGatewayConnectOptionsPropertyDef]] = pydantic.Field(None)
    CfnTransitGatewayMulticastDomain_OptionsProperty: typing.Optional[dict[str, CfnTransitGatewayMulticastDomain_OptionsPropertyDef]] = pydantic.Field(None)
    CfnTransitGatewayPeeringAttachment_PeeringAttachmentStatusProperty: typing.Optional[dict[str, CfnTransitGatewayPeeringAttachment_PeeringAttachmentStatusPropertyDef]] = pydantic.Field(None)
    CfnTransitGatewayVpcAttachment_OptionsProperty: typing.Optional[dict[str, CfnTransitGatewayVpcAttachment_OptionsPropertyDef]] = pydantic.Field(None)
    CfnVerifiedAccessEndpoint_LoadBalancerOptionsProperty: typing.Optional[dict[str, CfnVerifiedAccessEndpoint_LoadBalancerOptionsPropertyDef]] = pydantic.Field(None)
    CfnVerifiedAccessEndpoint_NetworkInterfaceOptionsProperty: typing.Optional[dict[str, CfnVerifiedAccessEndpoint_NetworkInterfaceOptionsPropertyDef]] = pydantic.Field(None)
    CfnVerifiedAccessInstance_CloudWatchLogsProperty: typing.Optional[dict[str, CfnVerifiedAccessInstance_CloudWatchLogsPropertyDef]] = pydantic.Field(None)
    CfnVerifiedAccessInstance_KinesisDataFirehoseProperty: typing.Optional[dict[str, CfnVerifiedAccessInstance_KinesisDataFirehosePropertyDef]] = pydantic.Field(None)
    CfnVerifiedAccessInstance_S3Property: typing.Optional[dict[str, CfnVerifiedAccessInstance_S3PropertyDef]] = pydantic.Field(None)
    CfnVerifiedAccessInstance_VerifiedAccessLogsProperty: typing.Optional[dict[str, CfnVerifiedAccessInstance_VerifiedAccessLogsPropertyDef]] = pydantic.Field(None)
    CfnVerifiedAccessInstance_VerifiedAccessTrustProviderProperty: typing.Optional[dict[str, CfnVerifiedAccessInstance_VerifiedAccessTrustProviderPropertyDef]] = pydantic.Field(None)
    CfnVerifiedAccessTrustProvider_DeviceOptionsProperty: typing.Optional[dict[str, CfnVerifiedAccessTrustProvider_DeviceOptionsPropertyDef]] = pydantic.Field(None)
    CfnVerifiedAccessTrustProvider_OidcOptionsProperty: typing.Optional[dict[str, CfnVerifiedAccessTrustProvider_OidcOptionsPropertyDef]] = pydantic.Field(None)
    CfnVPNConnection_VpnTunnelOptionsSpecificationProperty: typing.Optional[dict[str, CfnVPNConnection_VpnTunnelOptionsSpecificationPropertyDef]] = pydantic.Field(None)
    ClientVpnAuthorizationRuleOptions: typing.Optional[dict[str, ClientVpnAuthorizationRuleOptionsDef]] = pydantic.Field(None)
    ClientVpnAuthorizationRuleProps: typing.Optional[dict[str, ClientVpnAuthorizationRulePropsDef]] = pydantic.Field(None)
    ClientVpnEndpointAttributes: typing.Optional[dict[str, ClientVpnEndpointAttributesDef]] = pydantic.Field(None)
    ClientVpnEndpointOptions: typing.Optional[dict[str, ClientVpnEndpointOptionsDef]] = pydantic.Field(None)
    ClientVpnEndpointProps: typing.Optional[dict[str, ClientVpnEndpointPropsDef]] = pydantic.Field(None)
    ClientVpnRouteOptions: typing.Optional[dict[str, ClientVpnRouteOptionsDef]] = pydantic.Field(None)
    ClientVpnRouteProps: typing.Optional[dict[str, ClientVpnRoutePropsDef]] = pydantic.Field(None)
    CommonNetworkAclEntryOptions: typing.Optional[dict[str, CommonNetworkAclEntryOptionsDef]] = pydantic.Field(None)
    ConfigSetProps: typing.Optional[dict[str, ConfigSetPropsDef]] = pydantic.Field(None)
    ConfigureNatOptions: typing.Optional[dict[str, ConfigureNatOptionsDef]] = pydantic.Field(None)
    ConnectionRule: typing.Optional[dict[str, ConnectionRuleDef]] = pydantic.Field(None)
    ConnectionsProps: typing.Optional[dict[str, ConnectionsPropsDef]] = pydantic.Field(None)
    DestinationOptions: typing.Optional[dict[str, DestinationOptionsDef]] = pydantic.Field(None)
    EbsDeviceOptions: typing.Optional[dict[str, EbsDeviceOptionsDef]] = pydantic.Field(None)
    EbsDeviceOptionsBase: typing.Optional[dict[str, EbsDeviceOptionsBaseDef]] = pydantic.Field(None)
    EbsDeviceProps: typing.Optional[dict[str, EbsDevicePropsDef]] = pydantic.Field(None)
    EbsDeviceSnapshotOptions: typing.Optional[dict[str, EbsDeviceSnapshotOptionsDef]] = pydantic.Field(None)
    EnableVpnGatewayOptions: typing.Optional[dict[str, EnableVpnGatewayOptionsDef]] = pydantic.Field(None)
    ExecuteFileOptions: typing.Optional[dict[str, ExecuteFileOptionsDef]] = pydantic.Field(None)
    FlowLogDestinationConfig: typing.Optional[dict[str, FlowLogDestinationConfigDef]] = pydantic.Field(None)
    FlowLogOptions: typing.Optional[dict[str, FlowLogOptionsDef]] = pydantic.Field(None)
    FlowLogProps: typing.Optional[dict[str, FlowLogPropsDef]] = pydantic.Field(None)
    GatewayConfig: typing.Optional[dict[str, GatewayConfigDef]] = pydantic.Field(None)
    GatewayVpcEndpointOptions: typing.Optional[dict[str, GatewayVpcEndpointOptionsDef]] = pydantic.Field(None)
    GatewayVpcEndpointProps: typing.Optional[dict[str, GatewayVpcEndpointPropsDef]] = pydantic.Field(None)
    GenericLinuxImageProps: typing.Optional[dict[str, GenericLinuxImagePropsDef]] = pydantic.Field(None)
    GenericWindowsImageProps: typing.Optional[dict[str, GenericWindowsImagePropsDef]] = pydantic.Field(None)
    InitCommandOptions: typing.Optional[dict[str, InitCommandOptionsDef]] = pydantic.Field(None)
    InitFileAssetOptions: typing.Optional[dict[str, InitFileAssetOptionsDef]] = pydantic.Field(None)
    InitFileOptions: typing.Optional[dict[str, InitFileOptionsDef]] = pydantic.Field(None)
    InitServiceOptions: typing.Optional[dict[str, InitServiceOptionsDef]] = pydantic.Field(None)
    InitSourceAssetOptions: typing.Optional[dict[str, InitSourceAssetOptionsDef]] = pydantic.Field(None)
    InitSourceOptions: typing.Optional[dict[str, InitSourceOptionsDef]] = pydantic.Field(None)
    InitUserOptions: typing.Optional[dict[str, InitUserOptionsDef]] = pydantic.Field(None)
    InstanceProps: typing.Optional[dict[str, InstancePropsDef]] = pydantic.Field(None)
    InstanceRequireImdsv2AspectProps: typing.Optional[dict[str, InstanceRequireImdsv2AspectPropsDef]] = pydantic.Field(None)
    InterfaceVpcEndpointAttributes: typing.Optional[dict[str, InterfaceVpcEndpointAttributesDef]] = pydantic.Field(None)
    InterfaceVpcEndpointOptions: typing.Optional[dict[str, InterfaceVpcEndpointOptionsDef]] = pydantic.Field(None)
    InterfaceVpcEndpointProps: typing.Optional[dict[str, InterfaceVpcEndpointPropsDef]] = pydantic.Field(None)
    LaunchTemplateAttributes: typing.Optional[dict[str, LaunchTemplateAttributesDef]] = pydantic.Field(None)
    LaunchTemplateProps: typing.Optional[dict[str, LaunchTemplatePropsDef]] = pydantic.Field(None)
    LaunchTemplateRequireImdsv2AspectProps: typing.Optional[dict[str, LaunchTemplateRequireImdsv2AspectPropsDef]] = pydantic.Field(None)
    LaunchTemplateSpotOptions: typing.Optional[dict[str, LaunchTemplateSpotOptionsDef]] = pydantic.Field(None)
    LinuxUserDataOptions: typing.Optional[dict[str, LinuxUserDataOptionsDef]] = pydantic.Field(None)
    LocationPackageOptions: typing.Optional[dict[str, LocationPackageOptionsDef]] = pydantic.Field(None)
    LookupMachineImageProps: typing.Optional[dict[str, LookupMachineImagePropsDef]] = pydantic.Field(None)
    MachineImageConfig: typing.Optional[dict[str, MachineImageConfigDef]] = pydantic.Field(None)
    MultipartBodyOptions: typing.Optional[dict[str, MultipartBodyOptionsDef]] = pydantic.Field(None)
    MultipartUserDataOptions: typing.Optional[dict[str, MultipartUserDataOptionsDef]] = pydantic.Field(None)
    NamedPackageOptions: typing.Optional[dict[str, NamedPackageOptionsDef]] = pydantic.Field(None)
    NatGatewayProps: typing.Optional[dict[str, NatGatewayPropsDef]] = pydantic.Field(None)
    NatInstanceProps: typing.Optional[dict[str, NatInstancePropsDef]] = pydantic.Field(None)
    NetworkAclEntryProps: typing.Optional[dict[str, NetworkAclEntryPropsDef]] = pydantic.Field(None)
    NetworkAclProps: typing.Optional[dict[str, NetworkAclPropsDef]] = pydantic.Field(None)
    PlacementGroupProps: typing.Optional[dict[str, PlacementGroupPropsDef]] = pydantic.Field(None)
    PortProps: typing.Optional[dict[str, PortPropsDef]] = pydantic.Field(None)
    PrefixListOptions: typing.Optional[dict[str, PrefixListOptionsDef]] = pydantic.Field(None)
    PrefixListProps: typing.Optional[dict[str, PrefixListPropsDef]] = pydantic.Field(None)
    PrivateSubnetAttributes: typing.Optional[dict[str, PrivateSubnetAttributesDef]] = pydantic.Field(None)
    PrivateSubnetProps: typing.Optional[dict[str, PrivateSubnetPropsDef]] = pydantic.Field(None)
    PublicSubnetAttributes: typing.Optional[dict[str, PublicSubnetAttributesDef]] = pydantic.Field(None)
    PublicSubnetProps: typing.Optional[dict[str, PublicSubnetPropsDef]] = pydantic.Field(None)
    RequestedSubnet: typing.Optional[dict[str, RequestedSubnetDef]] = pydantic.Field(None)
    RuleScope: typing.Optional[dict[str, RuleScopeDef]] = pydantic.Field(None)
    S3DestinationOptions: typing.Optional[dict[str, S3DestinationOptionsDef]] = pydantic.Field(None)
    S3DownloadOptions: typing.Optional[dict[str, S3DownloadOptionsDef]] = pydantic.Field(None)
    SecurityGroupImportOptions: typing.Optional[dict[str, SecurityGroupImportOptionsDef]] = pydantic.Field(None)
    SecurityGroupProps: typing.Optional[dict[str, SecurityGroupPropsDef]] = pydantic.Field(None)
    SelectedSubnets: typing.Optional[dict[str, SelectedSubnetsDef]] = pydantic.Field(None)
    SsmParameterImageOptions: typing.Optional[dict[str, SsmParameterImageOptionsDef]] = pydantic.Field(None)
    SubnetAttributes: typing.Optional[dict[str, SubnetAttributesDef]] = pydantic.Field(None)
    SubnetConfiguration: typing.Optional[dict[str, SubnetConfigurationDef]] = pydantic.Field(None)
    SubnetIpamOptions: typing.Optional[dict[str, SubnetIpamOptionsDef]] = pydantic.Field(None)
    SubnetNetworkAclAssociationProps: typing.Optional[dict[str, SubnetNetworkAclAssociationPropsDef]] = pydantic.Field(None)
    SubnetProps: typing.Optional[dict[str, SubnetPropsDef]] = pydantic.Field(None)
    SubnetSelection: typing.Optional[dict[str, SubnetSelectionDef]] = pydantic.Field(None)
    SystemdConfigFileOptions: typing.Optional[dict[str, SystemdConfigFileOptionsDef]] = pydantic.Field(None)
    VolumeAttributes: typing.Optional[dict[str, VolumeAttributesDef]] = pydantic.Field(None)
    VolumeProps: typing.Optional[dict[str, VolumePropsDef]] = pydantic.Field(None)
    VpcAttributes: typing.Optional[dict[str, VpcAttributesDef]] = pydantic.Field(None)
    VpcEndpointServiceProps: typing.Optional[dict[str, VpcEndpointServicePropsDef]] = pydantic.Field(None)
    VpcIpamOptions: typing.Optional[dict[str, VpcIpamOptionsDef]] = pydantic.Field(None)
    VpcLookupOptions: typing.Optional[dict[str, VpcLookupOptionsDef]] = pydantic.Field(None)
    VpcProps: typing.Optional[dict[str, VpcPropsDef]] = pydantic.Field(None)
    VpnConnectionAttributes: typing.Optional[dict[str, VpnConnectionAttributesDef]] = pydantic.Field(None)
    VpnConnectionOptions: typing.Optional[dict[str, VpnConnectionOptionsDef]] = pydantic.Field(None)
    VpnConnectionProps: typing.Optional[dict[str, VpnConnectionPropsDef]] = pydantic.Field(None)
    VpnGatewayProps: typing.Optional[dict[str, VpnGatewayPropsDef]] = pydantic.Field(None)
    VpnTunnelOption: typing.Optional[dict[str, VpnTunnelOptionDef]] = pydantic.Field(None)
    WindowsImageProps: typing.Optional[dict[str, WindowsImagePropsDef]] = pydantic.Field(None)
    WindowsUserDataOptions: typing.Optional[dict[str, WindowsUserDataOptionsDef]] = pydantic.Field(None)
    CfnCapacityReservation: typing.Optional[dict[str, CfnCapacityReservationDef]] = pydantic.Field(None)
    CfnCapacityReservationFleet: typing.Optional[dict[str, CfnCapacityReservationFleetDef]] = pydantic.Field(None)
    CfnCarrierGateway: typing.Optional[dict[str, CfnCarrierGatewayDef]] = pydantic.Field(None)
    CfnClientVpnAuthorizationRule: typing.Optional[dict[str, CfnClientVpnAuthorizationRuleDef]] = pydantic.Field(None)
    CfnClientVpnEndpoint: typing.Optional[dict[str, CfnClientVpnEndpointDef]] = pydantic.Field(None)
    CfnClientVpnRoute: typing.Optional[dict[str, CfnClientVpnRouteDef]] = pydantic.Field(None)
    CfnClientVpnTargetNetworkAssociation: typing.Optional[dict[str, CfnClientVpnTargetNetworkAssociationDef]] = pydantic.Field(None)
    CfnCustomerGateway: typing.Optional[dict[str, CfnCustomerGatewayDef]] = pydantic.Field(None)
    CfnDHCPOptions: typing.Optional[dict[str, CfnDHCPOptionsDef]] = pydantic.Field(None)
    CfnEC2Fleet: typing.Optional[dict[str, CfnEC2FleetDef]] = pydantic.Field(None)
    CfnEgressOnlyInternetGateway: typing.Optional[dict[str, CfnEgressOnlyInternetGatewayDef]] = pydantic.Field(None)
    CfnEIP: typing.Optional[dict[str, CfnEIPDef]] = pydantic.Field(None)
    CfnEIPAssociation: typing.Optional[dict[str, CfnEIPAssociationDef]] = pydantic.Field(None)
    CfnEnclaveCertificateIamRoleAssociation: typing.Optional[dict[str, CfnEnclaveCertificateIamRoleAssociationDef]] = pydantic.Field(None)
    CfnFlowLog: typing.Optional[dict[str, CfnFlowLogDef]] = pydantic.Field(None)
    CfnGatewayRouteTableAssociation: typing.Optional[dict[str, CfnGatewayRouteTableAssociationDef]] = pydantic.Field(None)
    CfnHost: typing.Optional[dict[str, CfnHostDef]] = pydantic.Field(None)
    CfnInstance: typing.Optional[dict[str, CfnInstanceDef]] = pydantic.Field(None)
    CfnInternetGateway: typing.Optional[dict[str, CfnInternetGatewayDef]] = pydantic.Field(None)
    CfnIPAM: typing.Optional[dict[str, CfnIPAMDef]] = pydantic.Field(None)
    CfnIPAMAllocation: typing.Optional[dict[str, CfnIPAMAllocationDef]] = pydantic.Field(None)
    CfnIPAMPool: typing.Optional[dict[str, CfnIPAMPoolDef]] = pydantic.Field(None)
    CfnIPAMPoolCidr: typing.Optional[dict[str, CfnIPAMPoolCidrDef]] = pydantic.Field(None)
    CfnIPAMResourceDiscovery: typing.Optional[dict[str, CfnIPAMResourceDiscoveryDef]] = pydantic.Field(None)
    CfnIPAMResourceDiscoveryAssociation: typing.Optional[dict[str, CfnIPAMResourceDiscoveryAssociationDef]] = pydantic.Field(None)
    CfnIPAMScope: typing.Optional[dict[str, CfnIPAMScopeDef]] = pydantic.Field(None)
    CfnKeyPair: typing.Optional[dict[str, CfnKeyPairDef]] = pydantic.Field(None)
    CfnLaunchTemplate: typing.Optional[dict[str, CfnLaunchTemplateDef]] = pydantic.Field(None)
    CfnLocalGatewayRoute: typing.Optional[dict[str, CfnLocalGatewayRouteDef]] = pydantic.Field(None)
    CfnLocalGatewayRouteTable: typing.Optional[dict[str, CfnLocalGatewayRouteTableDef]] = pydantic.Field(None)
    CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociation: typing.Optional[dict[str, CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationDef]] = pydantic.Field(None)
    CfnLocalGatewayRouteTableVPCAssociation: typing.Optional[dict[str, CfnLocalGatewayRouteTableVPCAssociationDef]] = pydantic.Field(None)
    CfnNatGateway: typing.Optional[dict[str, CfnNatGatewayDef]] = pydantic.Field(None)
    CfnNetworkAcl: typing.Optional[dict[str, CfnNetworkAclDef]] = pydantic.Field(None)
    CfnNetworkAclEntry: typing.Optional[dict[str, CfnNetworkAclEntryDef]] = pydantic.Field(None)
    CfnNetworkInsightsAccessScope: typing.Optional[dict[str, CfnNetworkInsightsAccessScopeDef]] = pydantic.Field(None)
    CfnNetworkInsightsAccessScopeAnalysis: typing.Optional[dict[str, CfnNetworkInsightsAccessScopeAnalysisDef]] = pydantic.Field(None)
    CfnNetworkInsightsAnalysis: typing.Optional[dict[str, CfnNetworkInsightsAnalysisDef]] = pydantic.Field(None)
    CfnNetworkInsightsPath: typing.Optional[dict[str, CfnNetworkInsightsPathDef]] = pydantic.Field(None)
    CfnNetworkInterface: typing.Optional[dict[str, CfnNetworkInterfaceDef]] = pydantic.Field(None)
    CfnNetworkInterfaceAttachment: typing.Optional[dict[str, CfnNetworkInterfaceAttachmentDef]] = pydantic.Field(None)
    CfnNetworkInterfacePermission: typing.Optional[dict[str, CfnNetworkInterfacePermissionDef]] = pydantic.Field(None)
    CfnNetworkPerformanceMetricSubscription: typing.Optional[dict[str, CfnNetworkPerformanceMetricSubscriptionDef]] = pydantic.Field(None)
    CfnPlacementGroup: typing.Optional[dict[str, CfnPlacementGroupDef]] = pydantic.Field(None)
    CfnPrefixList: typing.Optional[dict[str, CfnPrefixListDef]] = pydantic.Field(None)
    CfnRoute: typing.Optional[dict[str, CfnRouteDef]] = pydantic.Field(None)
    CfnRouteTable: typing.Optional[dict[str, CfnRouteTableDef]] = pydantic.Field(None)
    CfnSecurityGroup: typing.Optional[dict[str, CfnSecurityGroupDef]] = pydantic.Field(None)
    CfnSecurityGroupEgress: typing.Optional[dict[str, CfnSecurityGroupEgressDef]] = pydantic.Field(None)
    CfnSecurityGroupIngress: typing.Optional[dict[str, CfnSecurityGroupIngressDef]] = pydantic.Field(None)
    CfnSpotFleet: typing.Optional[dict[str, CfnSpotFleetDef]] = pydantic.Field(None)
    CfnSubnet: typing.Optional[dict[str, CfnSubnetDef]] = pydantic.Field(None)
    CfnSubnetCidrBlock: typing.Optional[dict[str, CfnSubnetCidrBlockDef]] = pydantic.Field(None)
    CfnSubnetNetworkAclAssociation: typing.Optional[dict[str, CfnSubnetNetworkAclAssociationDef]] = pydantic.Field(None)
    CfnSubnetRouteTableAssociation: typing.Optional[dict[str, CfnSubnetRouteTableAssociationDef]] = pydantic.Field(None)
    CfnTrafficMirrorFilter: typing.Optional[dict[str, CfnTrafficMirrorFilterDef]] = pydantic.Field(None)
    CfnTrafficMirrorFilterRule: typing.Optional[dict[str, CfnTrafficMirrorFilterRuleDef]] = pydantic.Field(None)
    CfnTrafficMirrorSession: typing.Optional[dict[str, CfnTrafficMirrorSessionDef]] = pydantic.Field(None)
    CfnTrafficMirrorTarget: typing.Optional[dict[str, CfnTrafficMirrorTargetDef]] = pydantic.Field(None)
    CfnTransitGateway: typing.Optional[dict[str, CfnTransitGatewayDef]] = pydantic.Field(None)
    CfnTransitGatewayAttachment: typing.Optional[dict[str, CfnTransitGatewayAttachmentDef]] = pydantic.Field(None)
    CfnTransitGatewayConnect: typing.Optional[dict[str, CfnTransitGatewayConnectDef]] = pydantic.Field(None)
    CfnTransitGatewayMulticastDomain: typing.Optional[dict[str, CfnTransitGatewayMulticastDomainDef]] = pydantic.Field(None)
    CfnTransitGatewayMulticastDomainAssociation: typing.Optional[dict[str, CfnTransitGatewayMulticastDomainAssociationDef]] = pydantic.Field(None)
    CfnTransitGatewayMulticastGroupMember: typing.Optional[dict[str, CfnTransitGatewayMulticastGroupMemberDef]] = pydantic.Field(None)
    CfnTransitGatewayMulticastGroupSource: typing.Optional[dict[str, CfnTransitGatewayMulticastGroupSourceDef]] = pydantic.Field(None)
    CfnTransitGatewayPeeringAttachment: typing.Optional[dict[str, CfnTransitGatewayPeeringAttachmentDef]] = pydantic.Field(None)
    CfnTransitGatewayRoute: typing.Optional[dict[str, CfnTransitGatewayRouteDef]] = pydantic.Field(None)
    CfnTransitGatewayRouteTable: typing.Optional[dict[str, CfnTransitGatewayRouteTableDef]] = pydantic.Field(None)
    CfnTransitGatewayRouteTableAssociation: typing.Optional[dict[str, CfnTransitGatewayRouteTableAssociationDef]] = pydantic.Field(None)
    CfnTransitGatewayRouteTablePropagation: typing.Optional[dict[str, CfnTransitGatewayRouteTablePropagationDef]] = pydantic.Field(None)
    CfnTransitGatewayVpcAttachment: typing.Optional[dict[str, CfnTransitGatewayVpcAttachmentDef]] = pydantic.Field(None)
    CfnVerifiedAccessEndpoint: typing.Optional[dict[str, CfnVerifiedAccessEndpointDef]] = pydantic.Field(None)
    CfnVerifiedAccessGroup: typing.Optional[dict[str, CfnVerifiedAccessGroupDef]] = pydantic.Field(None)
    CfnVerifiedAccessInstance: typing.Optional[dict[str, CfnVerifiedAccessInstanceDef]] = pydantic.Field(None)
    CfnVerifiedAccessTrustProvider: typing.Optional[dict[str, CfnVerifiedAccessTrustProviderDef]] = pydantic.Field(None)
    CfnVolume: typing.Optional[dict[str, CfnVolumeDef]] = pydantic.Field(None)
    CfnVolumeAttachment: typing.Optional[dict[str, CfnVolumeAttachmentDef]] = pydantic.Field(None)
    CfnVPC: typing.Optional[dict[str, CfnVPCDef]] = pydantic.Field(None)
    CfnVPCCidrBlock: typing.Optional[dict[str, CfnVPCCidrBlockDef]] = pydantic.Field(None)
    CfnVPCDHCPOptionsAssociation: typing.Optional[dict[str, CfnVPCDHCPOptionsAssociationDef]] = pydantic.Field(None)
    CfnVPCEndpoint: typing.Optional[dict[str, CfnVPCEndpointDef]] = pydantic.Field(None)
    CfnVPCEndpointConnectionNotification: typing.Optional[dict[str, CfnVPCEndpointConnectionNotificationDef]] = pydantic.Field(None)
    CfnVPCEndpointService: typing.Optional[dict[str, CfnVPCEndpointServiceDef]] = pydantic.Field(None)
    CfnVPCEndpointServicePermissions: typing.Optional[dict[str, CfnVPCEndpointServicePermissionsDef]] = pydantic.Field(None)
    CfnVPCGatewayAttachment: typing.Optional[dict[str, CfnVPCGatewayAttachmentDef]] = pydantic.Field(None)
    CfnVPCPeeringConnection: typing.Optional[dict[str, CfnVPCPeeringConnectionDef]] = pydantic.Field(None)
    CfnVPNConnection: typing.Optional[dict[str, CfnVPNConnectionDef]] = pydantic.Field(None)
    CfnVPNConnectionRoute: typing.Optional[dict[str, CfnVPNConnectionRouteDef]] = pydantic.Field(None)
    CfnVPNGateway: typing.Optional[dict[str, CfnVPNGatewayDef]] = pydantic.Field(None)
    CfnVPNGatewayRoutePropagation: typing.Optional[dict[str, CfnVPNGatewayRoutePropagationDef]] = pydantic.Field(None)
    CfnCapacityReservationFleetProps: typing.Optional[dict[str, CfnCapacityReservationFleetPropsDef]] = pydantic.Field(None)
    CfnCapacityReservationProps: typing.Optional[dict[str, CfnCapacityReservationPropsDef]] = pydantic.Field(None)
    CfnCarrierGatewayProps: typing.Optional[dict[str, CfnCarrierGatewayPropsDef]] = pydantic.Field(None)
    CfnClientVpnAuthorizationRuleProps: typing.Optional[dict[str, CfnClientVpnAuthorizationRulePropsDef]] = pydantic.Field(None)
    CfnClientVpnEndpointProps: typing.Optional[dict[str, CfnClientVpnEndpointPropsDef]] = pydantic.Field(None)
    CfnClientVpnRouteProps: typing.Optional[dict[str, CfnClientVpnRoutePropsDef]] = pydantic.Field(None)
    CfnClientVpnTargetNetworkAssociationProps: typing.Optional[dict[str, CfnClientVpnTargetNetworkAssociationPropsDef]] = pydantic.Field(None)
    CfnCustomerGatewayProps: typing.Optional[dict[str, CfnCustomerGatewayPropsDef]] = pydantic.Field(None)
    CfnDHCPOptionsProps: typing.Optional[dict[str, CfnDHCPOptionsPropsDef]] = pydantic.Field(None)
    CfnEC2FleetProps: typing.Optional[dict[str, CfnEC2FleetPropsDef]] = pydantic.Field(None)
    CfnEgressOnlyInternetGatewayProps: typing.Optional[dict[str, CfnEgressOnlyInternetGatewayPropsDef]] = pydantic.Field(None)
    CfnEIPAssociationProps: typing.Optional[dict[str, CfnEIPAssociationPropsDef]] = pydantic.Field(None)
    CfnEIPProps: typing.Optional[dict[str, CfnEIPPropsDef]] = pydantic.Field(None)
    CfnEnclaveCertificateIamRoleAssociationProps: typing.Optional[dict[str, CfnEnclaveCertificateIamRoleAssociationPropsDef]] = pydantic.Field(None)
    CfnFlowLogProps: typing.Optional[dict[str, CfnFlowLogPropsDef]] = pydantic.Field(None)
    CfnGatewayRouteTableAssociationProps: typing.Optional[dict[str, CfnGatewayRouteTableAssociationPropsDef]] = pydantic.Field(None)
    CfnHostProps: typing.Optional[dict[str, CfnHostPropsDef]] = pydantic.Field(None)
    CfnInstanceProps: typing.Optional[dict[str, CfnInstancePropsDef]] = pydantic.Field(None)
    CfnInternetGatewayProps: typing.Optional[dict[str, CfnInternetGatewayPropsDef]] = pydantic.Field(None)
    CfnIPAMAllocationProps: typing.Optional[dict[str, CfnIPAMAllocationPropsDef]] = pydantic.Field(None)
    CfnIPAMPoolCidrProps: typing.Optional[dict[str, CfnIPAMPoolCidrPropsDef]] = pydantic.Field(None)
    CfnIPAMPoolProps: typing.Optional[dict[str, CfnIPAMPoolPropsDef]] = pydantic.Field(None)
    CfnIPAMProps: typing.Optional[dict[str, CfnIPAMPropsDef]] = pydantic.Field(None)
    CfnIPAMResourceDiscoveryAssociationProps: typing.Optional[dict[str, CfnIPAMResourceDiscoveryAssociationPropsDef]] = pydantic.Field(None)
    CfnIPAMResourceDiscoveryProps: typing.Optional[dict[str, CfnIPAMResourceDiscoveryPropsDef]] = pydantic.Field(None)
    CfnIPAMScopeProps: typing.Optional[dict[str, CfnIPAMScopePropsDef]] = pydantic.Field(None)
    CfnKeyPairProps: typing.Optional[dict[str, CfnKeyPairPropsDef]] = pydantic.Field(None)
    CfnLaunchTemplateProps: typing.Optional[dict[str, CfnLaunchTemplatePropsDef]] = pydantic.Field(None)
    CfnLocalGatewayRouteProps: typing.Optional[dict[str, CfnLocalGatewayRoutePropsDef]] = pydantic.Field(None)
    CfnLocalGatewayRouteTableProps: typing.Optional[dict[str, CfnLocalGatewayRouteTablePropsDef]] = pydantic.Field(None)
    CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationProps: typing.Optional[dict[str, CfnLocalGatewayRouteTableVirtualInterfaceGroupAssociationPropsDef]] = pydantic.Field(None)
    CfnLocalGatewayRouteTableVPCAssociationProps: typing.Optional[dict[str, CfnLocalGatewayRouteTableVPCAssociationPropsDef]] = pydantic.Field(None)
    CfnNatGatewayProps: typing.Optional[dict[str, CfnNatGatewayPropsDef]] = pydantic.Field(None)
    CfnNetworkAclEntryProps: typing.Optional[dict[str, CfnNetworkAclEntryPropsDef]] = pydantic.Field(None)
    CfnNetworkAclProps: typing.Optional[dict[str, CfnNetworkAclPropsDef]] = pydantic.Field(None)
    CfnNetworkInsightsAccessScopeAnalysisProps: typing.Optional[dict[str, CfnNetworkInsightsAccessScopeAnalysisPropsDef]] = pydantic.Field(None)
    CfnNetworkInsightsAccessScopeProps: typing.Optional[dict[str, CfnNetworkInsightsAccessScopePropsDef]] = pydantic.Field(None)
    CfnNetworkInsightsAnalysisProps: typing.Optional[dict[str, CfnNetworkInsightsAnalysisPropsDef]] = pydantic.Field(None)
    CfnNetworkInsightsPathProps: typing.Optional[dict[str, CfnNetworkInsightsPathPropsDef]] = pydantic.Field(None)
    CfnNetworkInterfaceAttachmentProps: typing.Optional[dict[str, CfnNetworkInterfaceAttachmentPropsDef]] = pydantic.Field(None)
    CfnNetworkInterfacePermissionProps: typing.Optional[dict[str, CfnNetworkInterfacePermissionPropsDef]] = pydantic.Field(None)
    CfnNetworkInterfaceProps: typing.Optional[dict[str, CfnNetworkInterfacePropsDef]] = pydantic.Field(None)
    CfnNetworkPerformanceMetricSubscriptionProps: typing.Optional[dict[str, CfnNetworkPerformanceMetricSubscriptionPropsDef]] = pydantic.Field(None)
    CfnPlacementGroupProps: typing.Optional[dict[str, CfnPlacementGroupPropsDef]] = pydantic.Field(None)
    CfnPrefixListProps: typing.Optional[dict[str, CfnPrefixListPropsDef]] = pydantic.Field(None)
    CfnRouteProps: typing.Optional[dict[str, CfnRoutePropsDef]] = pydantic.Field(None)
    CfnRouteTableProps: typing.Optional[dict[str, CfnRouteTablePropsDef]] = pydantic.Field(None)
    CfnSecurityGroupEgressProps: typing.Optional[dict[str, CfnSecurityGroupEgressPropsDef]] = pydantic.Field(None)
    CfnSecurityGroupIngressProps: typing.Optional[dict[str, CfnSecurityGroupIngressPropsDef]] = pydantic.Field(None)
    CfnSecurityGroupProps: typing.Optional[dict[str, CfnSecurityGroupPropsDef]] = pydantic.Field(None)
    CfnSpotFleetProps: typing.Optional[dict[str, CfnSpotFleetPropsDef]] = pydantic.Field(None)
    CfnSubnetCidrBlockProps: typing.Optional[dict[str, CfnSubnetCidrBlockPropsDef]] = pydantic.Field(None)
    CfnSubnetNetworkAclAssociationProps: typing.Optional[dict[str, CfnSubnetNetworkAclAssociationPropsDef]] = pydantic.Field(None)
    CfnSubnetProps: typing.Optional[dict[str, CfnSubnetPropsDef]] = pydantic.Field(None)
    CfnSubnetRouteTableAssociationProps: typing.Optional[dict[str, CfnSubnetRouteTableAssociationPropsDef]] = pydantic.Field(None)
    CfnTrafficMirrorFilterProps: typing.Optional[dict[str, CfnTrafficMirrorFilterPropsDef]] = pydantic.Field(None)
    CfnTrafficMirrorFilterRuleProps: typing.Optional[dict[str, CfnTrafficMirrorFilterRulePropsDef]] = pydantic.Field(None)
    CfnTrafficMirrorSessionProps: typing.Optional[dict[str, CfnTrafficMirrorSessionPropsDef]] = pydantic.Field(None)
    CfnTrafficMirrorTargetProps: typing.Optional[dict[str, CfnTrafficMirrorTargetPropsDef]] = pydantic.Field(None)
    CfnTransitGatewayAttachmentProps: typing.Optional[dict[str, CfnTransitGatewayAttachmentPropsDef]] = pydantic.Field(None)
    CfnTransitGatewayConnectProps: typing.Optional[dict[str, CfnTransitGatewayConnectPropsDef]] = pydantic.Field(None)
    CfnTransitGatewayMulticastDomainAssociationProps: typing.Optional[dict[str, CfnTransitGatewayMulticastDomainAssociationPropsDef]] = pydantic.Field(None)
    CfnTransitGatewayMulticastDomainProps: typing.Optional[dict[str, CfnTransitGatewayMulticastDomainPropsDef]] = pydantic.Field(None)
    CfnTransitGatewayMulticastGroupMemberProps: typing.Optional[dict[str, CfnTransitGatewayMulticastGroupMemberPropsDef]] = pydantic.Field(None)
    CfnTransitGatewayMulticastGroupSourceProps: typing.Optional[dict[str, CfnTransitGatewayMulticastGroupSourcePropsDef]] = pydantic.Field(None)
    CfnTransitGatewayPeeringAttachmentProps: typing.Optional[dict[str, CfnTransitGatewayPeeringAttachmentPropsDef]] = pydantic.Field(None)
    CfnTransitGatewayProps: typing.Optional[dict[str, CfnTransitGatewayPropsDef]] = pydantic.Field(None)
    CfnTransitGatewayRouteProps: typing.Optional[dict[str, CfnTransitGatewayRoutePropsDef]] = pydantic.Field(None)
    CfnTransitGatewayRouteTableAssociationProps: typing.Optional[dict[str, CfnTransitGatewayRouteTableAssociationPropsDef]] = pydantic.Field(None)
    CfnTransitGatewayRouteTablePropagationProps: typing.Optional[dict[str, CfnTransitGatewayRouteTablePropagationPropsDef]] = pydantic.Field(None)
    CfnTransitGatewayRouteTableProps: typing.Optional[dict[str, CfnTransitGatewayRouteTablePropsDef]] = pydantic.Field(None)
    CfnTransitGatewayVpcAttachmentProps: typing.Optional[dict[str, CfnTransitGatewayVpcAttachmentPropsDef]] = pydantic.Field(None)
    CfnVerifiedAccessEndpointProps: typing.Optional[dict[str, CfnVerifiedAccessEndpointPropsDef]] = pydantic.Field(None)
    CfnVerifiedAccessGroupProps: typing.Optional[dict[str, CfnVerifiedAccessGroupPropsDef]] = pydantic.Field(None)
    CfnVerifiedAccessInstanceProps: typing.Optional[dict[str, CfnVerifiedAccessInstancePropsDef]] = pydantic.Field(None)
    CfnVerifiedAccessTrustProviderProps: typing.Optional[dict[str, CfnVerifiedAccessTrustProviderPropsDef]] = pydantic.Field(None)
    CfnVolumeAttachmentProps: typing.Optional[dict[str, CfnVolumeAttachmentPropsDef]] = pydantic.Field(None)
    CfnVolumeProps: typing.Optional[dict[str, CfnVolumePropsDef]] = pydantic.Field(None)
    CfnVPCCidrBlockProps: typing.Optional[dict[str, CfnVPCCidrBlockPropsDef]] = pydantic.Field(None)
    CfnVPCDHCPOptionsAssociationProps: typing.Optional[dict[str, CfnVPCDHCPOptionsAssociationPropsDef]] = pydantic.Field(None)
    CfnVPCEndpointConnectionNotificationProps: typing.Optional[dict[str, CfnVPCEndpointConnectionNotificationPropsDef]] = pydantic.Field(None)
    CfnVPCEndpointProps: typing.Optional[dict[str, CfnVPCEndpointPropsDef]] = pydantic.Field(None)
    CfnVPCEndpointServicePermissionsProps: typing.Optional[dict[str, CfnVPCEndpointServicePermissionsPropsDef]] = pydantic.Field(None)
    CfnVPCEndpointServiceProps: typing.Optional[dict[str, CfnVPCEndpointServicePropsDef]] = pydantic.Field(None)
    CfnVPCGatewayAttachmentProps: typing.Optional[dict[str, CfnVPCGatewayAttachmentPropsDef]] = pydantic.Field(None)
    CfnVPCPeeringConnectionProps: typing.Optional[dict[str, CfnVPCPeeringConnectionPropsDef]] = pydantic.Field(None)
    CfnVPCProps: typing.Optional[dict[str, CfnVPCPropsDef]] = pydantic.Field(None)
    CfnVPNConnectionProps: typing.Optional[dict[str, CfnVPNConnectionPropsDef]] = pydantic.Field(None)
    CfnVPNConnectionRouteProps: typing.Optional[dict[str, CfnVPNConnectionRoutePropsDef]] = pydantic.Field(None)
    CfnVPNGatewayProps: typing.Optional[dict[str, CfnVPNGatewayPropsDef]] = pydantic.Field(None)
    CfnVPNGatewayRoutePropagationProps: typing.Optional[dict[str, CfnVPNGatewayRoutePropagationPropsDef]] = pydantic.Field(None)
    ...
